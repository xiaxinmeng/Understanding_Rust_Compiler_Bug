{"sha": "a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThmNzNkNGIzNjViYmZlOTE0NWJmZDRhZTE2MTU5ZDYzMmNhMGMzMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-09T19:02:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-09T19:02:39Z"}, "message": "Reorganize per-function data.\n\n\t* cp-tree.h (saved_scope): Add function_decl, bindings.\n\t(language_function): Rename binding_level to bindings.\n\t(cp_function_chain): Use the current_function, not the\n\touter_function_chain.\n\t(current_class_ptr): Make it work, even when there's no\n\tcurrent function.\n\t(current_class_ref): Likewise.\n\t(SF_DEFAULT, SF_PRE_PARSED, SF_INCLASS_INLINE, SF_EXPAND): New\n\tmacros.\n\t(clear_temp_name): Remove.\n\t* decl.c (check_function_type): New function, broken out from\n\tstart_function.\n\t(current_binding_level): Adjust definition.\n\t(pushlevel): Simplify.\n\t(poplevel): Don't use named_label_uses when we're outside\n\ta function scope.\n\t(mark_saved_scope): Mark function_decl and bindings.\n\t(maybe_push_to_top_level): Don't unconditionally push a new\n\tfunction context.  Save bindings and the current_function_decl.\n\tDon't clear named_labels.\n\t(pop_from_top_level): Pop function context if appropriate.\n\t(init_decl_processing): Set init_lang_status and free_lang_status,\n\trather than save_lang_status and restore_lang_status.\n\t(start_function): Take SF_* flags.  Don't clear per-function data.\n\tReorder and simplify to use new per-function data code.  Add\n\tasserts.\n\t(store_parm_decls): Don't call init_function_start here.\n\t(finish_function): Adjust for new handling of per-function data.\n\t(push_cp_function_context): Simplify.\n\t(mark_cp_function_context): Change binding_level to bindings.\n\t* decl2.c (clear_temp_name): Remove.\n\t(start_objects): Use SF flags to start_function.\n\t(start_static_storage_duration_function): Likewise.\n\t* except.c (start_anon_func): Remove redundant calls to\n\tpush_function_context_to.  Use SF flags to start function.\n\t(end_anon_func): Remove redundant call to pop_function_context\n\tfrom.\n\t* lex.c (reinit_parse_for_function): Don't initialize per-function\n\tdata.\n\t* method.c (emit_thunk): Clear current_function after calling\n\tassemble_end_function.  Use SF flags for start_function.\n\t(synthesize_method): Use SF flags for start_function.\n\t* parse.c: Regenerated.\n\t* parse.y (fn.defpen): Likewise.\n\t(pending_inline): Clear current_function, even if something goes\n\twrong.\n\t* pt.c (instantiate_decl): Use SF flags to start_function.\n\tDon't save and restore expanding_p.\n\t(add_tree): Handle the case where we are outside any function.\n\t(end_tree): Likewise.\n\t* rtti.c (sythesize_tinfo_fn): Use SF flags to start_function.\n\t* semantics.c (begin_function_definition): Likewise.\n\t(expand_body): Likewise.\n\nFrom-SVN: r29240", "tree": {"sha": "405b90c13653975957260d95ca2290648afa63ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/405b90c13653975957260d95ca2290648afa63ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/comments", "author": null, "committer": null, "parents": [{"sha": "0a8a198ceb46752b7b7e8f3f7b259347e4ba45b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8a198ceb46752b7b7e8f3f7b259347e4ba45b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8a198ceb46752b7b7e8f3f7b259347e4ba45b6"}], "stats": {"total": 1260, "additions": 680, "deletions": 580}, "files": [{"sha": "369b091f7f7f6c01e9593e5cdc917d510c4bad83", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -1,3 +1,60 @@\n+1999-09-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tReorganize per-function data.\n+\t* cp-tree.h (saved_scope): Add function_decl, bindings.\n+\t(language_function): Rename binding_level to bindings.\n+\t(cp_function_chain): Use the current_function, not the\n+\touter_function_chain.\n+\t(current_class_ptr): Make it work, even when there's no \n+\tcurrent function.\n+\t(current_class_ref): Likewise.\n+\t(SF_DEFAULT, SF_PRE_PARSED, SF_INCLASS_INLINE, SF_EXPAND): New \n+\tmacros.\n+\t(clear_temp_name): Remove.\n+\t* decl.c (check_function_type): New function, broken out from\n+\tstart_function.\n+\t(current_binding_level): Adjust definition.\n+\t(pushlevel): Simplify.\n+\t(poplevel): Don't use named_label_uses when we're outside\n+\ta function scope.\n+\t(mark_saved_scope): Mark function_decl and bindings.\n+\t(maybe_push_to_top_level): Don't unconditionally push a new\n+\tfunction context.  Save bindings and the current_function_decl.\n+\tDon't clear named_labels.\n+\t(pop_from_top_level): Pop function context if appropriate.\n+\t(init_decl_processing): Set init_lang_status and free_lang_status,\n+\trather than save_lang_status and restore_lang_status.\n+\t(start_function): Take SF_* flags.  Don't clear per-function data.\n+\tReorder and simplify to use new per-function data code.  Add\n+\tasserts.\n+\t(store_parm_decls): Don't call init_function_start here.\n+\t(finish_function): Adjust for new handling of per-function data.\n+\t(push_cp_function_context): Simplify.\n+\t(mark_cp_function_context): Change binding_level to bindings.\n+\t* decl2.c (clear_temp_name): Remove.\n+\t(start_objects): Use SF flags to start_function.\n+\t(start_static_storage_duration_function): Likewise.\n+\t* except.c (start_anon_func): Remove redundant calls to \n+\tpush_function_context_to.  Use SF flags to start function.\n+\t(end_anon_func): Remove redundant call to pop_function_context\n+\tfrom.\n+\t* lex.c (reinit_parse_for_function): Don't initialize per-function \n+\tdata.\n+\t* method.c (emit_thunk): Clear current_function after calling\n+\tassemble_end_function.  Use SF flags for start_function.\n+\t(synthesize_method): Use SF flags for start_function.\n+\t* parse.c: Regenerated.\n+\t* parse.y (fn.defpen): Likewise.\n+\t(pending_inline): Clear current_function, even if something goes\n+\twrong.\n+\t* pt.c (instantiate_decl): Use SF flags to start_function.\n+\tDon't save and restore expanding_p.\n+\t(add_tree): Handle the case where we are outside any function.\n+\t(end_tree): Likewise.\n+\t* rtti.c (sythesize_tinfo_fn): Use SF flags to start_function.\n+\t* semantics.c (begin_function_definition): Likewise.\n+\t(expand_body): Likewise.\n+\t\n 1999-09-09  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-tree.h (convert_to_void): Prototype new function."}, {"sha": "04f26c243f2091a4a32ae659b258186fee05763b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -525,6 +525,7 @@ struct saved_scope {\n   tree class_name;\n   tree class_type;\n   tree access_specifier;\n+  tree function_decl;\n   varray_type lang_base;\n   tree *lang_stack;\n   tree lang_name;\n@@ -536,10 +537,12 @@ struct saved_scope {\n   HOST_WIDE_INT x_processing_template_decl;\n   int x_processing_specialization;\n   int x_processing_explicit_instantiation;\n+  int need_pop_function_context;\n \n   char *firstobj;\n \n   struct binding_level *class_bindings;\n+  struct binding_level *bindings;\n \n   struct saved_scope *prev;\n };\n@@ -627,12 +630,12 @@ struct language_function\n   int stmts_are_full_exprs_p; \n \n   struct named_label_list *named_label_uses;\n-  struct binding_level *binding_level;\n+  struct binding_level *bindings;\n };\n \n /* The current C++-specific per-function global variables.  */\n \n-#define cp_function_chain (outer_function_chain->language)\n+#define cp_function_chain (current_function->language)\n \n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n@@ -665,8 +668,10 @@ struct language_function\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */\n \n-#define current_class_ptr cp_function_chain->x_current_class_ptr\n-#define current_class_ref cp_function_chain->x_current_class_ref\n+#define current_class_ptr \\\n+  (current_function ? cp_function_chain->x_current_class_ptr : NULL_TREE)\n+#define current_class_ref \\\n+  (current_function ? cp_function_chain->x_current_class_ref : NULL_TREE)\n \n /* When building a statement-tree, this is the last node added to the\n    tree.  */\n@@ -2942,6 +2947,18 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define PUSH_USING           2  /* We are pushing this DECL as the\n \t\t\t\t   result of a using declaration.  */\n \n+/* Used with start function.  */\n+#define SF_DEFAULT           SF_EXPAND\n+                                /* No flags.  Temporarily, this is\n+\t\t\t\t   SF_EXPAND.  Once we are fully\n+\t\t\t\t   function-at-a-time, this will be\n+\t\t\t\t   0.  */\n+#define SF_PRE_PARSED        1  /* The function declaration has\n+\t\t\t\t   already been parsed.  */\n+#define SF_INCLASS_INLINE    2  /* The function is an inline, defined\n+\t\t\t\t   in the class body.  */\n+#define SF_EXPAND            4  /* Generate RTL for this function.  */\n+\n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n    sense of `same'.  */\n #define same_type_p(type1, type2) \\\n@@ -3226,7 +3243,6 @@ extern tree constructor_name_full\t\tPROTO((tree));\n extern tree constructor_name\t\t\tPROTO((tree));\n extern void setup_vtbl_ptr\t\t\tPROTO((void));\n extern void mark_inline_for_output\t\tPROTO((tree));\n-extern void clear_temp_name\t\t\tPROTO((void));\n extern tree get_temp_name\t\t\tPROTO((tree, int));\n extern void finish_anon_union\t\t\tPROTO((tree));\n extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));"}, {"sha": "8121e80547defef56fc19e6fd9fb189e4358bc67", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 179, "deletions": 145, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -205,6 +205,7 @@ static void pop_cp_function_context PROTO((struct function *));\n static void mark_binding_level PROTO((void *));\n static void mark_cp_function_context PROTO((struct function *));\n static void mark_saved_scope PROTO((void *));\n+static void check_function_type PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -604,7 +605,10 @@ struct binding_level\n   \n /* The binding level currently in effect.  */\n \n-#define current_binding_level cp_function_chain->binding_level\n+#define current_binding_level\t\t\t\\\n+  (current_function\t\t\t\t\\\n+   ? cp_function_chain->bindings   \t\t\\\n+   : scope_chain->bindings)\n \n /* The binding level of the current class, if any.  */\n \n@@ -895,13 +899,6 @@ pushlevel (tag_transparent)\n {\n   register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n \n-  /* If this is the top level of a function,\n-     just make sure that NAMED_LABELS is 0.\n-     They should have been set to 0 at the end of the previous function.  */\n-\n-  if (current_binding_level == global_binding_level)\n-    my_friendly_assert (named_labels == NULL_TREE, 134);\n-\n   /* Reuse or create a struct for this binding level.  */\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n@@ -1517,20 +1514,21 @@ poplevel (keep, reverse, functionbody)\n \n   /* Any uses of undefined labels now operate under constraints\n      of next binding contour.  */\n-  {\n-    struct binding_level *level_chain;\n-    level_chain = current_binding_level->level_chain;\n-    if (level_chain)\n-      {\n-\tstruct named_label_list *labels;\n-\tfor (labels = named_label_uses; labels; labels = labels->next)\n-\t  if (labels->binding_level == current_binding_level)\n-\t    {\n-\t      labels->binding_level = level_chain;\n-\t      labels->names_in_scope = level_chain->names;\n-\t    }\n-      }\n-  }\n+  if (current_function)\n+    {\n+      struct binding_level *level_chain;\n+      level_chain = current_binding_level->level_chain;\n+      if (level_chain)\n+\t{\n+\t  struct named_label_list *labels;\n+\t  for (labels = named_label_uses; labels; labels = labels->next)\n+\t    if (labels->binding_level == current_binding_level)\n+\t      {\n+\t\tlabels->binding_level = level_chain;\n+\t\tlabels->names_in_scope = level_chain->names;\n+\t      }\n+\t}\n+    }\n \n   tmp = current_binding_level->keep;\n \n@@ -2388,13 +2386,15 @@ mark_saved_scope (arg)\n       ggc_mark_tree (t->class_name);\n       ggc_mark_tree (t->class_type);\n       ggc_mark_tree (t->access_specifier);\n+      ggc_mark_tree (t->function_decl);\n       if (t->lang_base)\n \tggc_mark_tree_varray (t->lang_base);\n       ggc_mark_tree (t->lang_name);\n       ggc_mark_tree (t->x_function_parms);\n       ggc_mark_tree (t->template_parms);\n       ggc_mark_tree (t->x_previous_class_type);\n       ggc_mark_tree (t->x_previous_class_values);\n+      mark_binding_level (&t->bindings);\n       t = t->prev;\n     }\n }\n@@ -2448,15 +2448,25 @@ void\n maybe_push_to_top_level (pseudo)\n      int pseudo;\n {\n-  struct saved_scope *s\n-    = (struct saved_scope *) xcalloc (1, sizeof (struct saved_scope));\n+  struct saved_scope *s;\n   struct binding_level *b;\n-  tree old_bindings = NULL_TREE;\n+  tree old_bindings;\n+  int need_pop;\n+\n+  s = (struct saved_scope *) xcalloc (1, sizeof (struct saved_scope));\n \n   b = scope_chain ? current_binding_level : 0;\n \n-  push_function_context_to (NULL_TREE);\n+  /* If we're in the middle of some function, save our state.  */\n+  if (current_function)\n+    {\n+      need_pop = 1;\n+      push_function_context_to (NULL_TREE);\n+    }\n+  else\n+    need_pop = 0;\n \n+  old_bindings = NULL_TREE;\n   if (scope_chain && previous_class_type)\n     old_bindings = store_bindings (previous_class_values, old_bindings);\n \n@@ -2483,18 +2493,18 @@ maybe_push_to_top_level (pseudo)\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n-  current_binding_level = b;\n-\n   s->prev = scope_chain;\n   s->old_bindings = old_bindings;\n+  s->bindings = b;\n+  s->need_pop_function_context = need_pop;\n+  s->function_decl = current_function_decl;\n \n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n   VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n   current_lang_stack = &VARRAY_TREE (current_lang_base, 0);\n   current_lang_name = lang_name_cplusplus;\n   strict_prototype = strict_prototypes_lang_cplusplus;\n-  named_labels = NULL_TREE;\n   current_namespace = global_namespace;\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n@@ -2537,9 +2547,13 @@ pop_from_top_level ()\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;\n \n-  free (s);\n+  /* If we were in the middle of compiling a function, restore our\n+     state.  */\n+  if (s->need_pop_function_context)\n+    pop_function_context_from (NULL_TREE);\n+  current_function_decl = s->function_decl;\n \n-  pop_function_context_from (NULL_TREE);\n+  free (s);\n }\n \f\n /* Push a definition of struct, union or enum tag \"name\".\n@@ -6034,8 +6048,8 @@ init_decl_processing ()\n \n   /* Let the back-end now how to save and restore language-specific\n      per-function globals.  */\n-  save_lang_status = &push_cp_function_context;\n-  restore_lang_status = &pop_cp_function_context;\n+  init_lang_status = &push_cp_function_context;\n+  free_lang_status = &pop_cp_function_context;\n   mark_lang_status = &mark_cp_function_context;\n \n   cp_parse_init ();\n@@ -6062,8 +6076,6 @@ init_decl_processing ()\n   current_lang_name = lang_name_c;\n \n   current_function_decl = NULL_TREE;\n-  named_labels = NULL_TREE;\n-  named_label_uses = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n \n@@ -12800,19 +12812,54 @@ build_enumerator (name, value, type)\n \f\n static int function_depth;\n \n+/* We're defining DECL.  Make sure that it's type is OK.  */\n+\n+static void\n+check_function_type (decl)\n+     tree decl;\n+{\n+  tree fntype = TREE_TYPE (decl);\n+\n+  /* In a function definition, arg types must be complete.  */\n+  require_complete_types_for_parms (current_function_parms);\n+\n+  if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n+    {\n+      cp_error (\"return type `%#T' is incomplete\", TREE_TYPE (fntype));\n+\n+      /* Make it return void instead, but don't change the\n+\t type of the DECL_RESULT, in case we have a named return value.  */\n+      if (TREE_CODE (fntype) == METHOD_TYPE)\n+\t{\n+\t  tree ctype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype)));\n+\t  TREE_TYPE (decl)\n+\t    = build_cplus_method_type (ctype,\n+\t\t\t\t       void_type_node,\n+\t\t\t\t       FUNCTION_ARG_CHAIN (decl));\n+\t}\n+      else\n+\tTREE_TYPE (decl)\n+\t  = build_function_type (void_type_node,\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (decl)));\n+      TREE_TYPE (decl) \n+\t= build_exception_variant (fntype,\n+\t\t\t\t   TYPE_RAISES_EXCEPTIONS (fntype));\n+    }\n+  else\n+    abstract_virtuals_error (decl, TREE_TYPE (fntype));\n+}\n+\n /* Create the FUNCTION_DECL for a function definition.\n    DECLSPECS and DECLARATOR are the parts of the declaration;\n    they describe the function's name and the type it returns,\n    but twisted together in a fashion that parallels the syntax of C.\n \n-   If PRE_PARSED_P is non-zero then DECLARATOR is really the DECL for\n-   the function we are about to process; DECLSPECS are ignored.  For\n-   example, we set PRE_PARSED_P when processing the definition of\n-   inline function that was defined in-class; the definition is\n-   actually processed when the class is complete.  In this case,\n-   PRE_PARSED_P is 2.  We also set PRE_PARSED_P when instanting the\n-   body of a template function, and when constructing thunk functions\n-   and such; in these cases PRE_PARSED_P is 1.\n+   FLAGS is a bitwise or of SF_PRE_PARSED (indicating that the\n+   DECLARATOR is really the DECL for the function we are about to\n+   process and that DECLSPECS should be ignored), SF_INCLASS_INLINE\n+   indicating that the function is an inline defined in-class, and\n+   SF_EXPAND indicating that we should generate RTL for this\n+   function.  \n    \n    This function creates a binding context for the function body\n    as well as setting up the FUNCTION_DECL in current_function_decl.\n@@ -12827,9 +12874,9 @@ static int function_depth;\n    applied to it with the argument list [1, 2].  */\n \n int\n-start_function (declspecs, declarator, attrs, pre_parsed_p)\n+start_function (declspecs, declarator, attrs, flags)\n      tree declspecs, declarator, attrs;\n-     int pre_parsed_p;\n+     int flags;\n {\n   tree decl1;\n   tree ctype = NULL_TREE;\n@@ -12838,38 +12885,20 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   extern int have_extern_spec;\n   extern int used_extern_spec;\n   int doing_friend = 0;\n+  struct binding_level *bl;\n \n   /* Sanity check.  */\n   my_friendly_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE, 160);\n   my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n \n-  /* Assume, until we see it does.  */\n-  current_function_returns_value = 0;\n-  current_function_returns_null = 0;\n-  named_labels = 0;\n-  current_function_assigns_this = 0;\n-  current_function_just_assigned_this = 0;\n-  current_function_parms_stored = 0;\n-  last_dtor_insn = NULL_RTX;\n-  last_parm_cleanup_insn = NULL_RTX;\n-  original_result_rtx = NULL_RTX;\n-  base_init_expr = NULL_TREE;\n-  current_base_init_list = NULL_TREE;\n-  current_member_init_list = NULL_TREE;\n-  ctor_label = dtor_label = NULL_TREE;\n-  static_labelno = 0;\n-  in_function_try_handler = 0;\n-\n-  clear_temp_name ();\n-\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec && !used_extern_spec)\n     {\n       declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n       used_extern_spec = 1;\n     }\n \n-  if (pre_parsed_p)\n+  if (flags & SF_PRE_PARSED)\n     {\n       decl1 = declarator;\n \n@@ -12941,9 +12970,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       && IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)) != NULL_TREE)\n     cp_warning_at (\"`%D' implicitly declared before its definition\", IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)));\n \n-  if (!building_stmt_tree ())\n-    announce_function (decl1);\n-\n   /* Set up current_class_type, and enter the scope of the class, if\n      appropriate.  */\n   if (ctype)\n@@ -12957,7 +12983,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      case where a template parameter has the same name as a field of\n      the class.)  It is not until after this point that\n      PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */\n-  if (pre_parsed_p == 2)\n+  if (flags & SF_INCLASS_INLINE)\n     maybe_begin_member_template_processing (decl1);\n \n   /* Effective C++ rule 15.  See also c_expand_return.  */\n@@ -12993,44 +13019,53 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   current_function_parms = last_function_parms;\n   current_function_parm_tags = last_function_parm_tags;\n \n+  /* Make sure the parameter and return types are reasonable.  When\n+     you declare a function, these types can be incomplete, but they\n+     must be complete when you define the function.  */\n   if (! processing_template_decl)\n-    {\n-      /* In a function definition, arg types must be complete.  */\n-      require_complete_types_for_parms (current_function_parms);\n+    check_function_type (decl1);\n \n-      if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n+  /* Build the return declaration for the function.  */\n+  restype = TREE_TYPE (fntype);\n+  if (!processing_template_decl)\n+    {\n+      if (!DECL_RESULT (decl1))\n \t{\n-\t  cp_error (\"return-type `%#T' is an incomplete type\",\n-\t\t    TREE_TYPE (fntype));\n-\n-\t  /* Make it return void instead, but don't change the\n-\t     type of the DECL_RESULT, in case we have a named return value.  */\n-\t  if (ctype)\n-\t    TREE_TYPE (decl1)\n-\t      = build_cplus_method_type (build_type_variant (ctype,\n-\t\t\t\t\t\t\t     TREE_READONLY (decl1),\n-\t\t\t\t\t\t\t     TREE_SIDE_EFFECTS (decl1)),\n-\t\t\t\t\t void_type_node,\n-\t\t\t\t\t FUNCTION_ARG_CHAIN (decl1));\n-\t  else\n-\t    TREE_TYPE (decl1)\n-\t      = build_function_type (void_type_node,\n-\t\t\t\t     TYPE_ARG_TYPES (TREE_TYPE (decl1)));\n \t  DECL_RESULT (decl1)\n-\t    = build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (fntype)));\n-\t  TREE_READONLY (DECL_RESULT (decl1))\n-\t    = CP_TYPE_CONST_P (TREE_TYPE (fntype));\n-\t  TREE_THIS_VOLATILE (DECL_RESULT (decl1))\n-\t    = CP_TYPE_VOLATILE_P (TREE_TYPE (fntype));\n+\t    = build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (restype));\n+\t  c_apply_type_quals_to_decl (CP_TYPE_QUALS (restype), \n+\t\t\t\t      DECL_RESULT (decl1)); \n \t}\n-\n-      abstract_virtuals_error (decl1, TREE_TYPE (fntype));\n     }\n+  else\n+    /* Just use `void'.  Nobody will ever look at this anyhow.  */\n+    DECL_RESULT (decl1) = build_decl (RESULT_DECL, 0, void_type_node);\n+\n+  /* Initialize RTL machinery.  We cannot do this until\n+     CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this\n+     even when processing a template; this is how we get\n+     CURRENT_FUNCTION set up, and our per-function variables\n+     initialized.  */\n+  bl = current_binding_level;\n+  init_function_start (decl1, input_filename, lineno);\n+  current_binding_level = bl;\n+  expanding_p = (flags & SF_EXPAND) != 0;\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  immediate_size_expand = 0;\n+  get_pending_sizes ();\n+\n+  /* Let the user know we're compiling this function.  */\n+  if (!building_stmt_tree ())\n+    announce_function (decl1);\n \n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */\n-  if (!processing_template_decl && pre_parsed_p == 0)\n+  if (!processing_template_decl && !(flags & SF_PRE_PARSED))\n     {\n       /* A specialization is not used to guide overload resolution.  */\n       if ((flag_guiding_decls \n@@ -13049,7 +13084,9 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       fntype = TREE_TYPE (decl1);\n     }\n \n+  /* Reset these in case the call to pushdecl changed them.  */\n   current_function_decl = decl1;\n+  current_function->decl = decl1;\n \n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n@@ -13126,8 +13163,9 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       DECL_ARGUMENTS (decl1) = current_function_parms;\n       ctype = NULL_TREE;\n     }\n-  restype = TREE_TYPE (fntype);\n \n+  my_friendly_assert (current_class_ptr == NULL_TREE, 19990908);\n+  my_friendly_assert (current_class_ref == NULL_TREE, 19990908);\n   if (ctype)\n     {\n       /* If we're compiling a friend function, neither of the variables\n@@ -13155,17 +13193,15 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t     whenever current_class_ptr is dereferenced.  This time,\n \t     however, we want it to *create* current_class_ref, so we\n \t     temporarily clear current_class_ptr to fool it.  */\n-\t  current_class_ptr = NULL_TREE;\n-\t  current_class_ref = build_indirect_ref (t, NULL_PTR);\n-\t  current_class_ptr = t;\n+\t  cp_function_chain->x_current_class_ref \n+\t    = build_indirect_ref (t, NULL_PTR);\n+\t  cp_function_chain->x_current_class_ptr = t;\n \t  \n \t  resume_momentary (i);\n \t  if (! hack_decl_function_context (decl1))\n \t    end_temporary_allocation ();\n \t}\n     }\n-  else\n-    current_class_ptr = current_class_ref = NULL_TREE;\n \n   pushlevel (0);\n   current_binding_level->parm_flag = 1;\n@@ -13267,15 +13303,6 @@ store_parm_decls ()\n   if (toplevel_bindings_p ())\n     fatal (\"parse errors have confused me too much\");\n \n-  /* Initialize RTL machinery.  */\n-  init_function_start (fndecl, input_filename, lineno);\n-  /* Even though we're inside a function body, we still don't want to\n-     call expand_expr to calculate the size of a variable-sized array.\n-     We haven't necessarily assigned RTL to all variables yet, so it's\n-     not safe to try to expand expressions involving them.  */\n-  immediate_size_expand = 0;\n-  get_pending_sizes ();\n-\n   /* Create a binding level for the parms.  */\n   expand_start_bindings (0);\n \n@@ -13850,7 +13877,8 @@ finish_function (lineno, flags)\n \t  emit_label (cleanup_label);\n \t}\n \n-      /* Get return value into register if that's where it's supposed to be.  */\n+      /* Get return value into register if that's where it's supposed\n+\t to be.  */\n       if (original_result_rtx)\n \tfixup_result_decl (DECL_RESULT (fndecl), original_result_rtx);\n \n@@ -13892,23 +13920,9 @@ finish_function (lineno, flags)\n     my_friendly_abort (122);\n   poplevel (1, 0, 1);\n \n-  /* If this is a in-class inline definition, we may have to pop the\n-     bindings for the template parameters that we added in\n-     maybe_begin_member_template_processing when start_function was\n-     called.  */\n-  if (inclass_inline)\n-    maybe_end_member_template_processing ();\n-\n-  /* Reset scope for C++: if we were in the scope of a class,\n-     then when we finish this function, we are not longer so.\n-     This cannot be done until we know for sure that no more\n-     class members will ever be referenced in this function\n-     (i.e., calls to destructors).  */\n+  /* Remember that we were in class scope.  */\n   if (current_class_name)\n-    {\n-      ctype = current_class_type;\n-      pop_nested_class ();\n-    }\n+    ctype = current_class_type;\n \n   /* Must mark the RESULT_DECL as being in this function.  */\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n@@ -13922,6 +13936,8 @@ finish_function (lineno, flags)\n \n   if (expand_p)\n     {\n+      int returns_null;\n+      int returns_value;\n       int saved_flag_keep_inline_functions =\n \tflag_keep_inline_functions;\n \n@@ -13937,6 +13953,11 @@ finish_function (lineno, flags)\n \t   function is gone.  See save_tree_status.  */\n \tflag_keep_inline_functions = 1;\n \n+      /* Before we call rest_of_compilation (which will pop the\n+\t CURRENT_FUNCTION), we must save these values.  */\n+      returns_null = current_function_returns_null;\n+      returns_value = current_function_returns_value;\n+\n       /* If this is a nested function (like a template instantiation\n \t that we're compiling in the midst of compiling something\n \t else), push a new GC context.  That will keep local variables\n@@ -13983,20 +14004,20 @@ finish_function (lineno, flags)\n       if (ctype && TREE_ASM_WRITTEN (fndecl))\n \tnote_debug_info_needed (ctype);\n \n-      current_function_returns_null |= can_reach_end;\n+      returns_null |= can_reach_end;\n \n       /* Since we don't normally go through c_expand_return for constructors,\n \t this normally gets the wrong value.\n \t Also, named return values have their return codes emitted after\n \t NOTE_INSN_FUNCTION_END, confusing jump.c.  */\n       if (DECL_CONSTRUCTOR_P (fndecl)\n \t  || DECL_NAME (DECL_RESULT (fndecl)) != NULL_TREE)\n-\tcurrent_function_returns_null = 0;\n+\treturns_null = 0;\n \n-      if (TREE_THIS_VOLATILE (fndecl) && current_function_returns_null)\n+      if (TREE_THIS_VOLATILE (fndecl) && returns_null)\n \tcp_warning (\"`noreturn' function `%D' does return\", fndecl);\n       else if ((warn_return_type || pedantic)\n-\t       && current_function_returns_null\n+\t       && returns_null\n \t       && TREE_CODE (TREE_TYPE (fntype)) != VOID_TYPE)\n \t{\n \t  /* If this function returns non-void and control can drop through,\n@@ -14005,10 +14026,27 @@ finish_function (lineno, flags)\n \t}\n       /* With just -W, complain only if function returns both with\n \t and without a value.  */\n-      else if (extra_warnings\n-\t       && current_function_returns_value && current_function_returns_null)\n+      else if (extra_warnings && returns_value && returns_null)\n \twarning (\"this function may return with or without a value\");\n     }\n+  else\n+    {\n+      /* Since we never call rest_of_compilation, we never clear\n+\t CURRENT_FUNCTION.  Do so explicitly.  */\n+      free_after_compilation (current_function);\n+      current_function = NULL;\n+    }\n+\n+  /* If this is a in-class inline definition, we may have to pop the\n+     bindings for the template parameters that we added in\n+     maybe_begin_member_template_processing when start_function was\n+     called.  */\n+  if (inclass_inline)\n+    maybe_end_member_template_processing ();\n+\n+  /* Leave the scope of the class.  */\n+  if (ctype)\n+    pop_nested_class ();\n \n   --function_depth;\n \n@@ -14042,10 +14080,6 @@ finish_function (lineno, flags)\n          pop_cp_function_context and then reset via pop_function_context.  */\n       current_function_decl = NULL_TREE;\n     }\n-\n-  named_label_uses = NULL;\n-  current_class_ptr = NULL_TREE;\n-  current_class_ref = NULL_TREE;\n }\n \f\n /* Create the FUNCTION_DECL for a function definition.\n@@ -14413,8 +14447,8 @@ revert_static_member_fn (decl, fn, argtypes)\n     *argtypes = args;\n }\n \n-/* Save and reinitialize the variables\n-   used during compilation of a C++ function.  */\n+/* Initialize the variables used during compilation of a C++ \n+   function.  */ \n \n static void\n push_cp_function_context (f)\n@@ -14424,8 +14458,6 @@ push_cp_function_context (f)\n     = ((struct language_function *) \n        xcalloc (1, sizeof (struct language_function)));\n   f->language = p;\n-  if (f->next)\n-    p->binding_level = f->next->language->binding_level;\n \n   /* For now, we always assume we're expanding all the way to RTL\n      unless we're explicitly doing otherwise.  */\n@@ -14436,7 +14468,8 @@ push_cp_function_context (f)\n   stmts_are_full_exprs_p = 1;\n }\n \n-/* Restore the variables used during compilation of a C++ function.  */\n+/* Free the language-specific parts of F, now that we've finished\n+   compiling the function.  */\n \n static void\n pop_cp_function_context (f)\n@@ -14470,7 +14503,7 @@ mark_cp_function_context (f)\n   ggc_mark_rtx (p->x_last_parm_cleanup_insn);\n   ggc_mark_rtx (p->x_result_rtx);\n \n-  mark_binding_level (&p->binding_level);\n+  mark_binding_level (&p->bindings);\n }\n \n \n@@ -14499,6 +14532,7 @@ lang_mark_tree (t)\n       struct lang_identifier *li = (struct lang_identifier *) t;\n       struct lang_id2 *li2 = li->x;\n       ggc_mark_tree (li->namespace_bindings);\n+      ggc_mark_tree (li->bindings);\n       ggc_mark_tree (li->class_value);\n       ggc_mark_tree (li->class_template_info);\n "}, {"sha": "67ef3777660078953cf9bb5f48a8c5b382ffd1c4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -2018,12 +2018,6 @@ mark_inline_for_output (decl)\n   ++saved_inlines_used;\n }\n \n-void\n-clear_temp_name ()\n-{\n-  temp_name_counter = 0;\n-}\n-\n /* Hand off a unique name which can be used for variable we don't really\n    want to know about anyway, for example, the anonymous variables which\n    are needed to make references work.  Declare this thing so we can use it.\n@@ -2825,7 +2819,7 @@ start_objects (method_type, initp)\n   start_function (void_list_node,\n \t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n \t\t\t\t\tNULL_TREE),\n-\t\t  NULL_TREE, 0);\n+\t\t  NULL_TREE, SF_DEFAULT);\n \n #if defined(ASM_OUTPUT_CONSTRUCTOR) && defined(ASM_OUTPUT_DESTRUCTOR)\n   /* It can be a static function as long as collect2 does not have\n@@ -3014,7 +3008,7 @@ start_static_storage_duration_function ()\n   start_function (/*specs=*/NULL_TREE, \n \t\t  ssdf_decl,\n \t\t  /*attrs=*/NULL_TREE,\n-\t\t  /*pre_parsed_p=*/1);\n+\t\t  SF_DEFAULT | SF_PRE_PARSED);\n \n   /* Set up the scope of the outermost block in the function.  */\n   store_parm_decls ();"}, {"sha": "821223f07d6c26b9f069b496c23620f3d5183dc0", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -801,7 +801,6 @@ start_anon_func ()\n   tree params;\n   tree t;\n \n-  push_function_context_to (NULL_TREE);\n   push_to_top_level ();\n \n   /* No need to mangle this.  */\n@@ -816,7 +815,7 @@ start_anon_func ()\n \t\t\t    NULL_TREE);\n   start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n \t\t\t\t  void_list_node),\n-\t\t  t, NULL_TREE, 0);\n+\t\t  t, NULL_TREE, SF_DEFAULT);\n   store_parm_decls ();\n   pushlevel (0);\n   clear_last_expr ();\n@@ -841,7 +840,6 @@ end_anon_func ()\n   finish_function (lineno, 0);\n \n   pop_from_top_level ();\n-  pop_function_context_from (NULL_TREE);\n }\n \n /* Return a pointer to a buffer for an exception object of type TYPE.  */"}, {"sha": "988e01a697108a6e376848151daeaee688cdac4e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -1549,8 +1549,6 @@ reinit_parse_for_method (yychar, decl)\n   reinit_parse_for_block (yychar, &inline_text_obstack);\n \n   len = obstack_object_size (&inline_text_obstack);\n-  current_base_init_list = NULL_TREE;\n-  current_member_init_list = NULL_TREE;\n   if (decl == void_type_node\n       || (current_class_type && TYPE_REDEFINED (current_class_type)))\n     {"}, {"sha": "e91eefabba2df3ed5dd3e5fdcf763b5746c1e2f4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -2104,6 +2104,7 @@ emit_thunk (thunk_fndecl)\n     assemble_end_function (thunk_fndecl, fnname);\n     permanent_allocation (1);\n     current_function_decl = 0;\n+    current_function = 0;\n #else /* ASM_OUTPUT_MI_THUNK */\n   /* If we don't have the necessary macro for efficient thunks, generate a\n      thunk function that just makes a call to the real function.\n@@ -2132,7 +2133,8 @@ emit_thunk (thunk_fndecl)\n     DECL_INTERFACE_KNOWN (thunk_fndecl) = 1;\n     DECL_NOT_REALLY_EXTERN (thunk_fndecl) = 1;\n \n-    start_function (NULL_TREE, thunk_fndecl, NULL_TREE, 1);\n+    start_function (NULL_TREE, thunk_fndecl, NULL_TREE, \n+\t\t    SF_DEFAULT | SF_PRE_PARSED);\n     store_parm_decls ();\n     current_function_is_thunk = 1;\n \n@@ -2363,7 +2365,7 @@ synthesize_method (fndecl)\n     push_function_context_to (context);\n \n   interface_unknown = 1;\n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  start_function (NULL_TREE, fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   store_parm_decls ();\n   clear_last_expr ();\n "}, {"sha": "0283e62a9e13d65457c542467219b385893b2ef1", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 396, "deletions": 392, "changes": 788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -705,49 +705,49 @@ static const short yyrline[] = { 0,\n   1928,  1935,  1938,  1944,  1948,  1953,  1959,  1960,  1968,  1971,\n   1975,  1978,  1982,  1987,  1990,  1994,  1997,  1999,  2001,  2003,\n   2010,  2012,  2013,  2014,  2018,  2021,  2025,  2028,  2034,  2036,\n-  2039,  2042,  2045,  2051,  2054,  2057,  2059,  2061,  2065,  2070,\n-  2076,  2081,  2085,  2087,  2092,  2095,  2098,  2100,  2102,  2106,\n-  2111,  2118,  2122,  2129,  2132,  2135,  2141,  2143,  2155,  2159,\n-  2164,  2188,  2190,  2193,  2195,  2200,  2202,  2204,  2206,  2208,\n-  2210,  2214,  2222,  2225,  2227,  2231,  2238,  2244,  2250,  2256,\n-  2266,  2272,  2276,  2283,  2311,  2321,  2327,  2330,  2333,  2335,\n-  2339,  2341,  2345,  2348,  2352,  2355,  2358,  2360,  2364,  2375,\n-  2389,  2390,  2391,  2392,  2395,  2404,  2409,  2415,  2417,  2422,\n-  2424,  2426,  2428,  2430,  2432,  2435,  2445,  2452,  2477,  2483,\n-  2486,  2489,  2491,  2502,  2507,  2510,  2515,  2518,  2525,  2535,\n-  2538,  2545,  2555,  2557,  2560,  2562,  2565,  2572,  2580,  2587,\n-  2593,  2599,  2607,  2611,  2616,  2620,  2623,  2628,  2630,  2638,\n-  2640,  2644,  2647,  2652,  2656,  2662,  2673,  2676,  2680,  2684,\n-  2692,  2697,  2703,  2706,  2708,  2710,  2716,  2718,  2727,  2730,\n-  2732,  2734,  2736,  2740,  2743,  2746,  2748,  2750,  2752,  2756,\n-  2759,  2770,  2780,  2782,  2783,  2787,  2795,  2797,  2805,  2808,\n-  2810,  2812,  2814,  2818,  2821,  2824,  2826,  2828,  2830,  2834,\n-  2837,  2840,  2842,  2844,  2846,  2848,  2855,  2859,  2864,  2868,\n-  2873,  2875,  2879,  2882,  2884,  2887,  2889,  2890,  2893,  2895,\n-  2897,  2903,  2914,  2920,  2926,  2940,  2942,  2946,  2960,  2962,\n-  2964,  2968,  2974,  2987,  2989,  2993,  3006,  3012,  3014,  3015,\n-  3016,  3024,  3029,  3038,  3039,  3043,  3046,  3052,  3058,  3061,\n-  3063,  3065,  3067,  3071,  3075,  3079,  3082,  3086,  3088,  3097,\n-  3100,  3102,  3104,  3106,  3108,  3110,  3112,  3114,  3118,  3122,\n-  3126,  3130,  3132,  3134,  3136,  3138,  3140,  3142,  3144,  3146,\n-  3154,  3156,  3157,  3158,  3161,  3167,  3169,  3174,  3176,  3179,\n-  3192,  3195,  3198,  3202,  3205,  3212,  3214,  3217,  3219,  3221,\n-  3224,  3227,  3230,  3233,  3235,  3238,  3242,  3244,  3250,  3252,\n-  3253,  3255,  3260,  3262,  3264,  3266,  3268,  3271,  3272,  3274,\n-  3277,  3278,  3281,  3281,  3284,  3284,  3287,  3287,  3289,  3291,\n-  3293,  3295,  3301,  3307,  3310,  3313,  3319,  3321,  3323,  3327,\n-  3329,  3330,  3331,  3333,  3336,  3339,  3342,  3348,  3352,  3354,\n-  3357,  3359,  3362,  3366,  3368,  3371,  3373,  3376,  3393,  3401,\n-  3404,  3406,  3408,  3412,  3415,  3416,  3424,  3428,  3432,  3435,\n-  3436,  3442,  3445,  3448,  3450,  3454,  3459,  3462,  3472,  3477,\n-  3478,  3485,  3488,  3491,  3493,  3496,  3498,  3508,  3522,  3526,\n-  3529,  3531,  3535,  3539,  3542,  3545,  3547,  3551,  3553,  3560,\n-  3567,  3570,  3574,  3578,  3582,  3588,  3592,  3597,  3599,  3602,\n-  3607,  3613,  3624,  3627,  3629,  3633,  3641,  3644,  3648,  3651,\n-  3653,  3655,  3661,  3666,  3669,  3671,  3673,  3675,  3677,  3679,\n-  3681,  3683,  3685,  3687,  3689,  3691,  3693,  3695,  3697,  3699,\n-  3701,  3703,  3705,  3707,  3709,  3711,  3713,  3715,  3717,  3719,\n-  3721,  3723,  3725,  3727,  3729,  3731,  3734,  3736\n+  2039,  2042,  2045,  2051,  2054,  2057,  2059,  2061,  2065,  2072,\n+  2078,  2083,  2089,  2091,  2096,  2099,  2102,  2104,  2106,  2110,\n+  2115,  2122,  2126,  2133,  2136,  2139,  2145,  2147,  2159,  2163,\n+  2168,  2192,  2194,  2197,  2199,  2204,  2206,  2208,  2210,  2212,\n+  2214,  2218,  2226,  2229,  2231,  2235,  2242,  2248,  2254,  2260,\n+  2270,  2276,  2280,  2287,  2315,  2325,  2331,  2334,  2337,  2339,\n+  2343,  2345,  2349,  2352,  2356,  2359,  2362,  2364,  2368,  2379,\n+  2393,  2394,  2395,  2396,  2399,  2408,  2413,  2419,  2421,  2426,\n+  2428,  2430,  2432,  2434,  2436,  2439,  2449,  2456,  2481,  2487,\n+  2490,  2493,  2495,  2506,  2511,  2514,  2519,  2522,  2529,  2539,\n+  2542,  2549,  2559,  2561,  2564,  2566,  2569,  2576,  2584,  2591,\n+  2597,  2603,  2611,  2615,  2620,  2624,  2627,  2632,  2634,  2642,\n+  2644,  2648,  2651,  2656,  2660,  2666,  2677,  2680,  2684,  2688,\n+  2696,  2701,  2707,  2710,  2712,  2714,  2720,  2722,  2731,  2734,\n+  2736,  2738,  2740,  2744,  2747,  2750,  2752,  2754,  2756,  2760,\n+  2763,  2774,  2784,  2786,  2787,  2791,  2799,  2801,  2809,  2812,\n+  2814,  2816,  2818,  2822,  2825,  2828,  2830,  2832,  2834,  2838,\n+  2841,  2844,  2846,  2848,  2850,  2852,  2859,  2863,  2868,  2872,\n+  2877,  2879,  2883,  2886,  2888,  2891,  2893,  2894,  2897,  2899,\n+  2901,  2907,  2918,  2924,  2930,  2944,  2946,  2950,  2964,  2966,\n+  2968,  2972,  2978,  2991,  2993,  2997,  3010,  3016,  3018,  3019,\n+  3020,  3028,  3033,  3042,  3043,  3047,  3050,  3056,  3062,  3065,\n+  3067,  3069,  3071,  3075,  3079,  3083,  3086,  3090,  3092,  3101,\n+  3104,  3106,  3108,  3110,  3112,  3114,  3116,  3118,  3122,  3126,\n+  3130,  3134,  3136,  3138,  3140,  3142,  3144,  3146,  3148,  3150,\n+  3158,  3160,  3161,  3162,  3165,  3171,  3173,  3178,  3180,  3183,\n+  3196,  3199,  3202,  3206,  3209,  3216,  3218,  3221,  3223,  3225,\n+  3228,  3231,  3234,  3237,  3239,  3242,  3246,  3248,  3254,  3256,\n+  3257,  3259,  3264,  3266,  3268,  3270,  3272,  3275,  3276,  3278,\n+  3281,  3282,  3285,  3285,  3288,  3288,  3291,  3291,  3293,  3295,\n+  3297,  3299,  3305,  3311,  3314,  3317,  3323,  3325,  3327,  3331,\n+  3333,  3334,  3335,  3337,  3340,  3343,  3346,  3352,  3356,  3358,\n+  3361,  3363,  3366,  3370,  3372,  3375,  3377,  3380,  3397,  3405,\n+  3408,  3410,  3412,  3416,  3419,  3420,  3428,  3432,  3436,  3439,\n+  3440,  3446,  3449,  3452,  3454,  3458,  3463,  3466,  3476,  3481,\n+  3482,  3489,  3492,  3495,  3497,  3500,  3502,  3512,  3526,  3530,\n+  3533,  3535,  3539,  3543,  3546,  3549,  3551,  3555,  3557,  3564,\n+  3571,  3574,  3578,  3582,  3586,  3592,  3596,  3601,  3603,  3606,\n+  3611,  3617,  3628,  3631,  3633,  3637,  3645,  3648,  3652,  3655,\n+  3657,  3659,  3665,  3670,  3673,  3675,  3677,  3679,  3681,  3683,\n+  3685,  3687,  3689,  3691,  3693,  3695,  3697,  3699,  3701,  3703,\n+  3705,  3707,  3709,  3711,  3713,  3715,  3717,  3719,  3721,  3723,\n+  3725,  3727,  3729,  3731,  3733,  3735,  3738,  3740\n };\n #endif\n \n@@ -6326,51 +6326,55 @@ case 458:\n     break;}\n case 459:\n #line 2067 \"parse.y\"\n-{ start_function (NULL_TREE, yyvsp[0].pi->fndecl, NULL_TREE, 2);\n+{ start_function (NULL_TREE, yyvsp[0].pi->fndecl, NULL_TREE, \n+\t\t\t\t  (SF_DEFAULT | SF_PRE_PARSED \n+\t\t\t\t   | SF_INCLASS_INLINE));\n \t\t  reinit_parse_for_function (); ;\n     break;}\n case 460:\n-#line 2072 \"parse.y\"\n+#line 2074 \"parse.y\"\n {\n \t\t  finish_function (lineno, (int)yyvsp[-1].itype | 2);\n \t\t  process_next_inline (yyvsp[-3].pi);\n \t\t;\n     break;}\n case 461:\n-#line 2077 \"parse.y\"\n+#line 2079 \"parse.y\"\n { \n \t\t  finish_function (lineno, (int)yyvsp[0].itype | 2); \n                   process_next_inline (yyvsp[-2].pi);\n \t\t;\n     break;}\n case 462:\n-#line 2082 \"parse.y\"\n-{ process_next_inline (yyvsp[-2].pi); ;\n+#line 2084 \"parse.y\"\n+{ free_after_compilation (current_function);\n+\t\t  current_function = NULL;\n+\t\t  process_next_inline (yyvsp[-2].pi); ;\n     break;}\n case 465:\n-#line 2094 \"parse.y\"\n+#line 2098 \"parse.y\"\n { replace_defarg (yyvsp[-2].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 466:\n-#line 2096 \"parse.y\"\n+#line 2100 \"parse.y\"\n { replace_defarg (yyvsp[-2].ttype, error_mark_node); ;\n     break;}\n case 468:\n-#line 2101 \"parse.y\"\n+#line 2105 \"parse.y\"\n { do_pending_defargs (); ;\n     break;}\n case 469:\n-#line 2103 \"parse.y\"\n+#line 2107 \"parse.y\"\n { do_pending_defargs (); ;\n     break;}\n case 470:\n-#line 2108 \"parse.y\"\n+#line 2112 \"parse.y\"\n { yyvsp[0].itype = suspend_momentary ();\n \t\t  yyval.ttype = current_enum_type;\n \t\t  current_enum_type = start_enum (yyvsp[-1].ttype); ;\n     break;}\n case 471:\n-#line 2112 \"parse.y\"\n+#line 2116 \"parse.y\"\n { TYPE_VALUES (current_enum_type) = yyvsp[-1].ttype;\n \t\t  yyval.ftype.t = finish_enum (current_enum_type);\n \t\t  yyval.ftype.new_type_flag = 1;\n@@ -6379,13 +6383,13 @@ case 471:\n \t\t  check_for_missing_semicolon (yyval.ftype.t); ;\n     break;}\n case 472:\n-#line 2119 \"parse.y\"\n+#line 2123 \"parse.y\"\n { yyvsp[0].itype = suspend_momentary ();\n \t\t  yyval.ttype = current_enum_type;\n \t\t  current_enum_type = start_enum (make_anon_name ()); ;\n     break;}\n case 473:\n-#line 2123 \"parse.y\"\n+#line 2127 \"parse.y\"\n { TYPE_VALUES (current_enum_type) = yyvsp[-1].ttype;\n \t\t  yyval.ftype.t = finish_enum (current_enum_type);\n \t\t  yyval.ftype.new_type_flag = 1;\n@@ -6394,28 +6398,28 @@ case 473:\n \t\t  check_for_missing_semicolon (yyval.ftype.t); ;\n     break;}\n case 474:\n-#line 2130 \"parse.y\"\n+#line 2134 \"parse.y\"\n { yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 475:\n-#line 2133 \"parse.y\"\n+#line 2137 \"parse.y\"\n { yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 476:\n-#line 2136 \"parse.y\"\n+#line 2140 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0; \n \t\t  if (!processing_template_decl)\n \t\t    cp_pedwarn (\"using `typename' outside of template\"); ;\n     break;}\n case 477:\n-#line 2142 \"parse.y\"\n+#line 2146 \"parse.y\"\n { yyvsp[-1].ftype.t = begin_class_definition (yyvsp[-1].ftype.t); ;\n     break;}\n case 478:\n-#line 2144 \"parse.y\"\n+#line 2148 \"parse.y\"\n { \n \t\t  int semi;\n \n@@ -6428,21 +6432,21 @@ case 478:\n \t\t;\n     break;}\n case 479:\n-#line 2155 \"parse.y\"\n+#line 2159 \"parse.y\"\n {\n \t\t  begin_inline_definitions ();\n \t\t;\n     break;}\n case 480:\n-#line 2159 \"parse.y\"\n+#line 2163 \"parse.y\"\n {\n \t\t  finish_inline_definitions ();\n \t\t  yyval.ftype.t = yyvsp[-3].ttype;\n \t\t  yyval.ftype.new_type_flag = 1; \n \t\t;\n     break;}\n case 481:\n-#line 2165 \"parse.y\"\n+#line 2169 \"parse.y\"\n {\n \t\t  if (yyvsp[0].ftype.new_type_flag && yyvsp[0].ftype.t != error_mark_node)\n \t\t    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (yyvsp[0].ftype.t)));\n@@ -6466,83 +6470,83 @@ case 481:\n \t\t;\n     break;}\n case 485:\n-#line 2196 \"parse.y\"\n+#line 2200 \"parse.y\"\n { if (pedantic && !in_system_header)\n \t\t    pedwarn (\"comma at end of enumerator list\"); ;\n     break;}\n case 487:\n-#line 2203 \"parse.y\"\n+#line 2207 \"parse.y\"\n { error (\"storage class specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 488:\n-#line 2205 \"parse.y\"\n+#line 2209 \"parse.y\"\n { error (\"type specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 489:\n-#line 2207 \"parse.y\"\n+#line 2211 \"parse.y\"\n { error (\"type qualifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 490:\n-#line 2209 \"parse.y\"\n+#line 2213 \"parse.y\"\n { error (\"no body nor ';' separates two class, struct or union declarations\"); ;\n     break;}\n case 491:\n-#line 2211 \"parse.y\"\n+#line 2215 \"parse.y\"\n { yyval.ttype = build_decl_list (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 492:\n-#line 2216 \"parse.y\"\n+#line 2220 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-1].ttype; \n \t\t  yyval.ttype = yyvsp[0].ttype; \n \t\t;\n     break;}\n case 493:\n-#line 2224 \"parse.y\"\n+#line 2228 \"parse.y\"\n { current_aggr = yyval.ttype; yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 494:\n-#line 2226 \"parse.y\"\n+#line 2230 \"parse.y\"\n { yyungetc ('{', 1); ;\n     break;}\n case 495:\n-#line 2228 \"parse.y\"\n+#line 2232 \"parse.y\"\n { yyungetc (':', 1); ;\n     break;}\n case 496:\n-#line 2233 \"parse.y\"\n+#line 2237 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-2].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 497:\n-#line 2239 \"parse.y\"\n+#line 2243 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-3].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 498:\n-#line 2245 \"parse.y\"\n+#line 2249 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-2].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-2].ttype, NULL_TREE, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 499:\n-#line 2251 \"parse.y\"\n+#line 2255 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-1].ttype; \n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 500:\n-#line 2257 \"parse.y\"\n+#line 2261 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-2].ttype; \n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n@@ -6552,18 +6556,18 @@ case 500:\n \t\t;\n     break;}\n case 501:\n-#line 2268 \"parse.y\"\n+#line 2272 \"parse.y\"\n { \n \t\t  yyval.ftype.t = xref_tag (current_aggr, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 502:\n-#line 2273 \"parse.y\"\n+#line 2277 \"parse.y\"\n { yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, 0); ;\n     break;}\n case 503:\n-#line 2277 \"parse.y\"\n+#line 2281 \"parse.y\"\n { \n \t\t  yyval.ftype.t = yyvsp[-1].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n@@ -6572,7 +6576,7 @@ case 503:\n \t\t;\n     break;}\n case 504:\n-#line 2285 \"parse.y\"\n+#line 2289 \"parse.y\"\n { \n \t\t  if (yyvsp[-1].ftype.t != error_mark_node)\n \t\t    {\n@@ -6599,53 +6603,53 @@ case 504:\n \t\t;\n     break;}\n case 505:\n-#line 2313 \"parse.y\"\n+#line 2317 \"parse.y\"\n { yyval.ttype = xref_tag (yyval.ttype, make_anon_name (), 0);\n \t\t  yyungetc ('{', 1); ;\n     break;}\n case 506:\n-#line 2323 \"parse.y\"\n+#line 2327 \"parse.y\"\n {\n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 508:\n-#line 2332 \"parse.y\"\n+#line 2336 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 509:\n-#line 2334 \"parse.y\"\n+#line 2338 \"parse.y\"\n { yyungetc(':', 1); yyval.ttype = NULL_TREE; ;\n     break;}\n case 510:\n-#line 2336 \"parse.y\"\n+#line 2340 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 512:\n-#line 2342 \"parse.y\"\n+#line 2346 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 513:\n-#line 2347 \"parse.y\"\n+#line 2351 \"parse.y\"\n { yyval.ttype = finish_base_specifier (access_default_node, yyvsp[0].ttype); ;\n     break;}\n case 514:\n-#line 2349 \"parse.y\"\n+#line 2353 \"parse.y\"\n { yyval.ttype = finish_base_specifier (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 515:\n-#line 2354 \"parse.y\"\n+#line 2358 \"parse.y\"\n { if (yyval.ttype != error_mark_node) yyval.ttype = TYPE_MAIN_DECL (yyvsp[0].ttype); ;\n     break;}\n case 518:\n-#line 2361 \"parse.y\"\n+#line 2365 \"parse.y\"\n { if (yyvsp[-1].ttype != ridpointers[(int)RID_VIRTUAL])\n \t\t    cp_error (\"`%D' access\", yyvsp[-1].ttype);\n \t\t  yyval.ttype = access_default_virtual_node; ;\n     break;}\n case 519:\n-#line 2365 \"parse.y\"\n+#line 2369 \"parse.y\"\n {\n \t\t  if (yyvsp[-2].ttype != access_default_virtual_node)\n \t\t    error (\"multiple access specifiers\");\n@@ -6658,7 +6662,7 @@ case 519:\n \t\t;\n     break;}\n case 520:\n-#line 2376 \"parse.y\"\n+#line 2380 \"parse.y\"\n { if (yyvsp[-1].ttype != ridpointers[(int)RID_VIRTUAL])\n \t\t    cp_error (\"`%D' access\", yyvsp[-1].ttype);\n \t\t  else if (yyval.ttype == access_public_node)\n@@ -6672,55 +6676,55 @@ case 520:\n \t\t;\n     break;}\n case 525:\n-#line 2397 \"parse.y\"\n+#line 2401 \"parse.y\"\n {\n \t\t  current_access_specifier = yyvsp[-1].ttype;\n                 ;\n     break;}\n case 526:\n-#line 2406 \"parse.y\"\n+#line 2410 \"parse.y\"\n { \n \t\t  finish_member_declaration (yyvsp[0].ttype);\n \t\t;\n     break;}\n case 527:\n-#line 2410 \"parse.y\"\n+#line 2414 \"parse.y\"\n { \n \t\t  finish_member_declaration (yyvsp[0].ttype);\n \t\t;\n     break;}\n case 529:\n-#line 2418 \"parse.y\"\n+#line 2422 \"parse.y\"\n { error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0); ;\n     break;}\n case 530:\n-#line 2423 \"parse.y\"\n+#line 2427 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 531:\n-#line 2425 \"parse.y\"\n+#line 2429 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 532:\n-#line 2427 \"parse.y\"\n+#line 2431 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 533:\n-#line 2429 \"parse.y\"\n+#line 2433 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 534:\n-#line 2431 \"parse.y\"\n+#line 2435 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 535:\n-#line 2433 \"parse.y\"\n+#line 2437 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype;\n \t\t  pedantic = yyvsp[-1].itype; ;\n     break;}\n case 536:\n-#line 2436 \"parse.y\"\n+#line 2440 \"parse.y\"\n {  \n \t\t  if (yyvsp[0].ttype)\n \t\t    yyval.ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6732,14 +6736,14 @@ case 536:\n \t\t;\n     break;}\n case 537:\n-#line 2446 \"parse.y\"\n+#line 2450 \"parse.y\"\n { \n \t\t  yyval.ttype = finish_member_class_template (yyvsp[-1].ftype.t); \n \t\t  finish_template_decl (yyvsp[-2].ttype);\n \t\t;\n     break;}\n case 538:\n-#line 2457 \"parse.y\"\n+#line 2461 \"parse.y\"\n {\n \t\t  /* Most of the productions for component_decl only\n \t\t     allow the creation of one new member, so we call\n@@ -6762,53 +6766,53 @@ case 538:\n \t\t;\n     break;}\n case 539:\n-#line 2478 \"parse.y\"\n+#line 2482 \"parse.y\"\n { \n \t\t  if (!yyvsp[0].itype)\n \t\t    grok_x_components (yyvsp[-1].ttype);\n \t\t  yyval.ttype = NULL_TREE; \n \t\t;\n     break;}\n case 540:\n-#line 2484 \"parse.y\"\n+#line 2488 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 541:\n-#line 2487 \"parse.y\"\n+#line 2491 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 542:\n-#line 2490 \"parse.y\"\n+#line 2494 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 543:\n-#line 2492 \"parse.y\"\n+#line 2496 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 544:\n-#line 2503 \"parse.y\"\n+#line 2507 \"parse.y\"\n { tree specs, attrs;\n \t\t  split_specs_attrs (yyvsp[-4].ttype, &specs, &attrs);\n \t\t  yyval.ttype = grokfield (yyvsp[-3].ttype, specs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, attrs)); ;\n     break;}\n case 545:\n-#line 2508 \"parse.y\"\n+#line 2512 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 546:\n-#line 2511 \"parse.y\"\n+#line 2515 \"parse.y\"\n { yyval.ttype = do_class_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 547:\n-#line 2517 \"parse.y\"\n+#line 2521 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 548:\n-#line 2519 \"parse.y\"\n+#line 2523 \"parse.y\"\n { \n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    yyvsp[0].ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6817,7 +6821,7 @@ case 548:\n \t\t;\n     break;}\n case 549:\n-#line 2526 \"parse.y\"\n+#line 2530 \"parse.y\"\n { \n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n@@ -6827,11 +6831,11 @@ case 549:\n \t\t;\n     break;}\n case 550:\n-#line 2537 \"parse.y\"\n+#line 2541 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 551:\n-#line 2539 \"parse.y\"\n+#line 2543 \"parse.y\"\n { \n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    yyvsp[0].ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6840,7 +6844,7 @@ case 551:\n \t\t;\n     break;}\n case 552:\n-#line 2546 \"parse.y\"\n+#line 2550 \"parse.y\"\n { \n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n@@ -6850,106 +6854,106 @@ case 552:\n \t\t;\n     break;}\n case 557:\n-#line 2567 \"parse.y\"\n+#line 2571 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 558:\n-#line 2573 \"parse.y\"\n+#line 2577 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 559:\n-#line 2582 \"parse.y\"\n+#line 2586 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 560:\n-#line 2588 \"parse.y\"\n+#line 2592 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 561:\n-#line 2594 \"parse.y\"\n+#line 2598 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 562:\n-#line 2600 \"parse.y\"\n+#line 2604 \"parse.y\"\n { split_specs_attrs (yyvsp[-3].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-3].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 563:\n-#line 2609 \"parse.y\"\n+#line 2613 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 564:\n-#line 2612 \"parse.y\"\n+#line 2616 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 565:\n-#line 2618 \"parse.y\"\n+#line 2622 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 566:\n-#line 2621 \"parse.y\"\n+#line 2625 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 567:\n-#line 2624 \"parse.y\"\n+#line 2628 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 569:\n-#line 2631 \"parse.y\"\n+#line 2635 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 571:\n-#line 2641 \"parse.y\"\n+#line 2645 \"parse.y\"\n { TREE_CHAIN (yyvsp[0].ttype) = yyval.ttype; yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 572:\n-#line 2646 \"parse.y\"\n+#line 2650 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, NULL_TREE, current_enum_type); ;\n     break;}\n case 573:\n-#line 2648 \"parse.y\"\n+#line 2652 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, yyvsp[0].ttype, current_enum_type); ;\n     break;}\n case 574:\n-#line 2654 \"parse.y\"\n+#line 2658 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 575:\n-#line 2657 \"parse.y\"\n+#line 2661 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[0].ftype.t, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 576:\n-#line 2664 \"parse.y\"\n+#line 2668 \"parse.y\"\n {\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n@@ -6959,101 +6963,101 @@ case 576:\n \t\t;\n     break;}\n case 577:\n-#line 2675 \"parse.y\"\n+#line 2679 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 578:\n-#line 2677 \"parse.y\"\n+#line 2681 \"parse.y\"\n { yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 579:\n-#line 2682 \"parse.y\"\n+#line 2686 \"parse.y\"\n { yyval.ftype.t = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 580:\n-#line 2685 \"parse.y\"\n+#line 2689 \"parse.y\"\n { yyval.ftype.t = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ftype.t); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 581:\n-#line 2694 \"parse.y\"\n+#line 2698 \"parse.y\"\n { yyval.itype = suspend_momentary (); ;\n     break;}\n case 582:\n-#line 2699 \"parse.y\"\n+#line 2703 \"parse.y\"\n { resume_momentary ((int) yyvsp[-1].itype); yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 583:\n-#line 2705 \"parse.y\"\n+#line 2709 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 584:\n-#line 2707 \"parse.y\"\n+#line 2711 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 585:\n-#line 2709 \"parse.y\"\n+#line 2713 \"parse.y\"\n { resume_momentary ((int) yyvsp[-1].itype); yyval.ttype = empty_parms (); ;\n     break;}\n case 586:\n-#line 2711 \"parse.y\"\n+#line 2715 \"parse.y\"\n { resume_momentary ((int) yyvsp[-3].itype); yyval.ttype = NULL_TREE; ;\n     break;}\n case 588:\n-#line 2719 \"parse.y\"\n+#line 2723 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 589:\n-#line 2729 \"parse.y\"\n+#line 2733 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 590:\n-#line 2731 \"parse.y\"\n+#line 2735 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 591:\n-#line 2733 \"parse.y\"\n+#line 2737 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 592:\n-#line 2735 \"parse.y\"\n+#line 2739 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 593:\n-#line 2737 \"parse.y\"\n+#line 2741 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 595:\n-#line 2745 \"parse.y\"\n+#line 2749 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 596:\n-#line 2747 \"parse.y\"\n+#line 2751 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 597:\n-#line 2749 \"parse.y\"\n+#line 2753 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 598:\n-#line 2751 \"parse.y\"\n+#line 2755 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 599:\n-#line 2753 \"parse.y\"\n+#line 2757 \"parse.y\"\n { push_nested_class (yyvsp[-1].ttype, 3);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype);\n \t\t  TREE_COMPLEXITY (yyval.ttype) = current_class_depth; ;\n     break;}\n case 601:\n-#line 2761 \"parse.y\"\n+#line 2765 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -7065,7 +7069,7 @@ case 601:\n \t\t;\n     break;}\n case 602:\n-#line 2771 \"parse.y\"\n+#line 2775 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -7075,138 +7079,138 @@ case 602:\n \t\t;\n     break;}\n case 605:\n-#line 2784 \"parse.y\"\n+#line 2788 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 606:\n-#line 2789 \"parse.y\"\n+#line 2793 \"parse.y\"\n { yyval.ttype = get_type_decl (yyvsp[0].ttype); ;\n     break;}\n case 608:\n-#line 2798 \"parse.y\"\n+#line 2802 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 609:\n-#line 2807 \"parse.y\"\n+#line 2811 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 610:\n-#line 2809 \"parse.y\"\n+#line 2813 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 611:\n-#line 2811 \"parse.y\"\n+#line 2815 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 612:\n-#line 2813 \"parse.y\"\n+#line 2817 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 613:\n-#line 2815 \"parse.y\"\n+#line 2819 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 615:\n-#line 2823 \"parse.y\"\n+#line 2827 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 616:\n-#line 2825 \"parse.y\"\n+#line 2829 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 617:\n-#line 2827 \"parse.y\"\n+#line 2831 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 618:\n-#line 2829 \"parse.y\"\n+#line 2833 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 619:\n-#line 2831 \"parse.y\"\n+#line 2835 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 621:\n-#line 2839 \"parse.y\"\n+#line 2843 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 622:\n-#line 2841 \"parse.y\"\n+#line 2845 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 623:\n-#line 2843 \"parse.y\"\n+#line 2847 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 624:\n-#line 2845 \"parse.y\"\n+#line 2849 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 625:\n-#line 2847 \"parse.y\"\n+#line 2851 \"parse.y\"\n { enter_scope_of (yyvsp[0].ttype); ;\n     break;}\n case 626:\n-#line 2849 \"parse.y\"\n+#line 2853 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  enter_scope_of (yyval.ttype);\n \t\t;\n     break;}\n case 627:\n-#line 2857 \"parse.y\"\n+#line 2861 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 628:\n-#line 2860 \"parse.y\"\n+#line 2864 \"parse.y\"\n { got_scope = NULL_TREE;\n  \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 629:\n-#line 2866 \"parse.y\"\n+#line 2870 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 630:\n-#line 2869 \"parse.y\"\n+#line 2873 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 632:\n-#line 2876 \"parse.y\"\n+#line 2880 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 633:\n-#line 2881 \"parse.y\"\n+#line 2885 \"parse.y\"\n { yyval.ttype = build_functional_cast (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 634:\n-#line 2883 \"parse.y\"\n+#line 2887 \"parse.y\"\n { yyval.ttype = reparse_decl_as_expr (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 635:\n-#line 2885 \"parse.y\"\n+#line 2889 \"parse.y\"\n { yyval.ttype = reparse_absdcl_as_expr (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 640:\n-#line 2896 \"parse.y\"\n+#line 2900 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 641:\n-#line 2898 \"parse.y\"\n+#line 2902 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 642:\n-#line 2905 \"parse.y\"\n+#line 2909 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -7218,31 +7222,31 @@ case 642:\n \t\t;\n     break;}\n case 643:\n-#line 2915 \"parse.y\"\n+#line 2919 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = TREE_TYPE (yyval.ttype);\n \t\t;\n     break;}\n case 644:\n-#line 2921 \"parse.y\"\n+#line 2925 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 645:\n-#line 2927 \"parse.y\"\n+#line 2931 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyvsp[-1].ttype)); ;\n     break;}\n case 647:\n-#line 2943 \"parse.y\"\n+#line 2947 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 648:\n-#line 2948 \"parse.y\"\n+#line 2952 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype);\n@@ -7257,26 +7261,26 @@ case 648:\n \t\t;\n     break;}\n case 649:\n-#line 2961 \"parse.y\"\n+#line 2965 \"parse.y\"\n { yyval.ttype = TREE_TYPE (yyvsp[0].ttype); ;\n     break;}\n case 650:\n-#line 2963 \"parse.y\"\n+#line 2967 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 651:\n-#line 2965 \"parse.y\"\n+#line 2969 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 652:\n-#line 2970 \"parse.y\"\n+#line 2974 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", yyvsp[0].ttype);\n \t\t;\n     break;}\n case 653:\n-#line 2975 \"parse.y\"\n+#line 2979 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype);\n@@ -7291,15 +7295,15 @@ case 653:\n \t\t;\n     break;}\n case 654:\n-#line 2988 \"parse.y\"\n+#line 2992 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-2].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 655:\n-#line 2990 \"parse.y\"\n+#line 2994 \"parse.y\"\n { got_scope = yyval.ttype = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 656:\n-#line 2995 \"parse.y\"\n+#line 2999 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyvsp[-1].ttype = lastiddecl;\n@@ -7313,31 +7317,31 @@ case 656:\n \t\t;\n     break;}\n case 657:\n-#line 3007 \"parse.y\"\n+#line 3011 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype));\n \t\t;\n     break;}\n case 658:\n-#line 3013 \"parse.y\"\n+#line 3017 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype)); ;\n     break;}\n case 661:\n-#line 3017 \"parse.y\"\n+#line 3021 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 662:\n-#line 3026 \"parse.y\"\n+#line 3030 \"parse.y\"\n { yyval.ttype = build_min_nt (TEMPLATE_ID_EXPR, yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 663:\n-#line 3031 \"parse.y\"\n+#line 3035 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -7347,156 +7351,156 @@ case 663:\n \t\t;\n     break;}\n case 665:\n-#line 3040 \"parse.y\"\n+#line 3044 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 666:\n-#line 3045 \"parse.y\"\n+#line 3049 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 667:\n-#line 3047 \"parse.y\"\n+#line 3051 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; got_scope = NULL_TREE; ;\n     break;}\n case 668:\n-#line 3054 \"parse.y\"\n+#line 3058 \"parse.y\"\n { got_scope = void_type_node; ;\n     break;}\n case 669:\n-#line 3060 \"parse.y\"\n+#line 3064 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 670:\n-#line 3062 \"parse.y\"\n+#line 3066 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 671:\n-#line 3064 \"parse.y\"\n+#line 3068 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 672:\n-#line 3066 \"parse.y\"\n+#line 3070 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 673:\n-#line 3068 \"parse.y\"\n+#line 3072 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 674:\n-#line 3072 \"parse.y\"\n+#line 3076 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 676:\n-#line 3081 \"parse.y\"\n+#line 3085 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 677:\n-#line 3083 \"parse.y\"\n+#line 3087 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 679:\n-#line 3089 \"parse.y\"\n+#line 3093 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 680:\n-#line 3099 \"parse.y\"\n+#line 3103 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 681:\n-#line 3101 \"parse.y\"\n+#line 3105 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 682:\n-#line 3103 \"parse.y\"\n+#line 3107 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 683:\n-#line 3105 \"parse.y\"\n+#line 3109 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 684:\n-#line 3107 \"parse.y\"\n+#line 3111 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 685:\n-#line 3109 \"parse.y\"\n+#line 3113 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 686:\n-#line 3111 \"parse.y\"\n+#line 3115 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 687:\n-#line 3113 \"parse.y\"\n+#line 3117 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 688:\n-#line 3115 \"parse.y\"\n+#line 3119 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 689:\n-#line 3119 \"parse.y\"\n+#line 3123 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 691:\n-#line 3128 \"parse.y\"\n+#line 3132 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 692:\n-#line 3131 \"parse.y\"\n+#line 3135 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 693:\n-#line 3133 \"parse.y\"\n+#line 3137 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, empty_parms (), yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 694:\n-#line 3135 \"parse.y\"\n+#line 3139 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 695:\n-#line 3137 \"parse.y\"\n+#line 3141 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 696:\n-#line 3139 \"parse.y\"\n+#line 3143 \"parse.y\"\n { yyval.ttype = make_call_declarator (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 697:\n-#line 3141 \"parse.y\"\n+#line 3145 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 698:\n-#line 3143 \"parse.y\"\n+#line 3147 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 699:\n-#line 3145 \"parse.y\"\n+#line 3149 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 700:\n-#line 3147 \"parse.y\"\n+#line 3151 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); ;\n     break;}\n case 707:\n-#line 3170 \"parse.y\"\n+#line 3174 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids label declarations\"); ;\n     break;}\n case 710:\n-#line 3181 \"parse.y\"\n+#line 3185 \"parse.y\"\n { \n \t\t  while (yyvsp[-1].ttype)\n \t\t    {\n@@ -7506,357 +7510,357 @@ case 710:\n \t\t;\n     break;}\n case 711:\n-#line 3194 \"parse.y\"\n+#line 3198 \"parse.y\"\n {;\n     break;}\n case 713:\n-#line 3200 \"parse.y\"\n+#line 3204 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 714:\n-#line 3202 \"parse.y\"\n+#line 3206 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 715:\n-#line 3207 \"parse.y\"\n+#line 3211 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_if_stmt ();\n \t\t  cond_stmt_keyword = \"if\";\n \t\t;\n     break;}\n case 716:\n-#line 3212 \"parse.y\"\n+#line 3216 \"parse.y\"\n { finish_if_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 717:\n-#line 3214 \"parse.y\"\n+#line 3218 \"parse.y\"\n { yyval.ttype = finish_then_clause (yyvsp[-3].ttype); ;\n     break;}\n case 719:\n-#line 3219 \"parse.y\"\n+#line 3223 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 720:\n-#line 3221 \"parse.y\"\n+#line 3225 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 721:\n-#line 3226 \"parse.y\"\n+#line 3230 \"parse.y\"\n {;\n     break;}\n case 723:\n-#line 3232 \"parse.y\"\n+#line 3236 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 724:\n-#line 3234 \"parse.y\"\n+#line 3238 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 725:\n-#line 3236 \"parse.y\"\n+#line 3240 \"parse.y\"\n { begin_else_clause (); ;\n     break;}\n case 726:\n-#line 3238 \"parse.y\"\n+#line 3242 \"parse.y\"\n { \n \t\t  finish_else_clause (yyvsp[-3].ttype); \n \t\t  finish_if_stmt ();\n \t\t;\n     break;}\n case 727:\n-#line 3243 \"parse.y\"\n+#line 3247 \"parse.y\"\n { finish_if_stmt (); ;\n     break;}\n case 728:\n-#line 3245 \"parse.y\"\n+#line 3249 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_while_stmt ();\n \t\t  cond_stmt_keyword = \"while\";\n \t\t;\n     break;}\n case 729:\n-#line 3250 \"parse.y\"\n+#line 3254 \"parse.y\"\n { finish_while_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 730:\n-#line 3252 \"parse.y\"\n+#line 3256 \"parse.y\"\n { finish_while_stmt (yyvsp[-3].ttype); ;\n     break;}\n case 731:\n-#line 3254 \"parse.y\"\n+#line 3258 \"parse.y\"\n { yyval.ttype = begin_do_stmt (); ;\n     break;}\n case 732:\n-#line 3256 \"parse.y\"\n+#line 3260 \"parse.y\"\n {\n \t\t  finish_do_body (yyvsp[-2].ttype);\n \t\t  cond_stmt_keyword = \"do\";\n \t\t;\n     break;}\n case 733:\n-#line 3261 \"parse.y\"\n+#line 3265 \"parse.y\"\n { finish_do_stmt (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 734:\n-#line 3263 \"parse.y\"\n+#line 3267 \"parse.y\"\n { yyval.ttype = begin_for_stmt (); ;\n     break;}\n case 735:\n-#line 3265 \"parse.y\"\n+#line 3269 \"parse.y\"\n { finish_for_init_stmt (yyvsp[-2].ttype); ;\n     break;}\n case 736:\n-#line 3267 \"parse.y\"\n+#line 3271 \"parse.y\"\n { finish_for_cond (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 737:\n-#line 3269 \"parse.y\"\n+#line 3273 \"parse.y\"\n { finish_for_expr (yyvsp[-1].ttype, yyvsp[-8].ttype); ;\n     break;}\n case 738:\n-#line 3271 \"parse.y\"\n+#line 3275 \"parse.y\"\n { finish_for_stmt (yyvsp[-3].ttype, yyvsp[-10].ttype); ;\n     break;}\n case 739:\n-#line 3273 \"parse.y\"\n+#line 3277 \"parse.y\"\n { begin_switch_stmt (); ;\n     break;}\n case 740:\n-#line 3275 \"parse.y\"\n+#line 3279 \"parse.y\"\n { yyval.ttype = finish_switch_cond (yyvsp[-1].ttype); ;\n     break;}\n case 741:\n-#line 3277 \"parse.y\"\n+#line 3281 \"parse.y\"\n { finish_switch_stmt (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 742:\n-#line 3279 \"parse.y\"\n+#line 3283 \"parse.y\"\n { finish_case_label (yyvsp[-1].ttype, NULL_TREE); ;\n     break;}\n case 744:\n-#line 3282 \"parse.y\"\n+#line 3286 \"parse.y\"\n { finish_case_label (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 746:\n-#line 3285 \"parse.y\"\n+#line 3289 \"parse.y\"\n { finish_case_label (NULL_TREE, NULL_TREE); ;\n     break;}\n case 748:\n-#line 3288 \"parse.y\"\n+#line 3292 \"parse.y\"\n { finish_break_stmt (); ;\n     break;}\n case 749:\n-#line 3290 \"parse.y\"\n+#line 3294 \"parse.y\"\n { finish_continue_stmt (); ;\n     break;}\n case 750:\n-#line 3292 \"parse.y\"\n+#line 3296 \"parse.y\"\n { finish_return_stmt (NULL_TREE); ;\n     break;}\n case 751:\n-#line 3294 \"parse.y\"\n+#line 3298 \"parse.y\"\n { finish_return_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 752:\n-#line 3296 \"parse.y\"\n+#line 3300 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 753:\n-#line 3302 \"parse.y\"\n+#line 3306 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 754:\n-#line 3308 \"parse.y\"\n+#line 3312 \"parse.y\"\n { finish_asm_stmt (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 755:\n-#line 3312 \"parse.y\"\n+#line 3316 \"parse.y\"\n { finish_asm_stmt (yyvsp[-10].ttype, yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype); ;\n     break;}\n case 756:\n-#line 3314 \"parse.y\"\n+#line 3318 \"parse.y\"\n { \n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n \t\t  finish_goto_stmt (yyvsp[-1].ttype);\n \t\t;\n     break;}\n case 757:\n-#line 3320 \"parse.y\"\n+#line 3324 \"parse.y\"\n { finish_goto_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 758:\n-#line 3322 \"parse.y\"\n+#line 3326 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 759:\n-#line 3324 \"parse.y\"\n+#line 3328 \"parse.y\"\n { error (\"label must be followed by statement\");\n \t\t  yyungetc ('}', 0);\n \t\t  finish_stmt (); ;\n     break;}\n case 760:\n-#line 3328 \"parse.y\"\n+#line 3332 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 763:\n-#line 3332 \"parse.y\"\n+#line 3336 \"parse.y\"\n { do_local_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 765:\n-#line 3338 \"parse.y\"\n+#line 3342 \"parse.y\"\n { yyval.ttype = begin_function_try_block (); ;\n     break;}\n case 766:\n-#line 3340 \"parse.y\"\n+#line 3344 \"parse.y\"\n { finish_function_try_block (yyvsp[-2].ttype); ;\n     break;}\n case 767:\n-#line 3342 \"parse.y\"\n+#line 3346 \"parse.y\"\n {\n \t\t  finish_function_handler_sequence (yyvsp[-4].ttype);\n \t\t  yyval.itype = yyvsp[-3].itype;\n \t\t;\n     break;}\n case 768:\n-#line 3350 \"parse.y\"\n+#line 3354 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 769:\n-#line 3352 \"parse.y\"\n+#line 3356 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 770:\n-#line 3354 \"parse.y\"\n+#line 3358 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 773:\n-#line 3364 \"parse.y\"\n+#line 3368 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 774:\n-#line 3366 \"parse.y\"\n+#line 3370 \"parse.y\"\n { finish_handler_parms (yyvsp[-1].ttype); ;\n     break;}\n case 775:\n-#line 3368 \"parse.y\"\n+#line 3372 \"parse.y\"\n { finish_handler (yyvsp[-3].ttype); ;\n     break;}\n case 778:\n-#line 3378 \"parse.y\"\n+#line 3382 \"parse.y\"\n { expand_start_catch_block (NULL_TREE); ;\n     break;}\n case 779:\n-#line 3394 \"parse.y\"\n+#line 3398 \"parse.y\"\n { \n \t\t  check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  start_handler_parms (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t       TREE_VALUE (yyvsp[-1].ftype.t));\n \t\t;\n     break;}\n case 780:\n-#line 3403 \"parse.y\"\n+#line 3407 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 781:\n-#line 3405 \"parse.y\"\n+#line 3409 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 782:\n-#line 3407 \"parse.y\"\n+#line 3411 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 783:\n-#line 3409 \"parse.y\"\n+#line 3413 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 784:\n-#line 3414 \"parse.y\"\n+#line 3418 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 786:\n-#line 3417 \"parse.y\"\n+#line 3421 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 787:\n-#line 3426 \"parse.y\"\n+#line 3430 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 788:\n-#line 3429 \"parse.y\"\n+#line 3433 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 789:\n-#line 3434 \"parse.y\"\n+#line 3438 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 791:\n-#line 3437 \"parse.y\"\n+#line 3441 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3444 \"parse.y\"\n+#line 3448 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 795:\n-#line 3451 \"parse.y\"\n+#line 3455 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 796:\n-#line 3456 \"parse.y\"\n+#line 3460 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 797:\n-#line 3461 \"parse.y\"\n+#line 3465 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 798:\n-#line 3463 \"parse.y\"\n+#line 3467 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 799:\n-#line 3474 \"parse.y\"\n+#line 3478 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 801:\n-#line 3479 \"parse.y\"\n+#line 3483 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 802:\n-#line 3487 \"parse.y\"\n+#line 3491 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 803:\n-#line 3489 \"parse.y\"\n+#line 3493 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 804:\n-#line 3492 \"parse.y\"\n+#line 3496 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 805:\n-#line 3494 \"parse.y\"\n+#line 3498 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 806:\n-#line 3497 \"parse.y\"\n+#line 3501 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 807:\n-#line 3499 \"parse.y\"\n+#line 3503 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7868,7 +7872,7 @@ case 807:\n \t\t;\n     break;}\n case 808:\n-#line 3509 \"parse.y\"\n+#line 3513 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7881,99 +7885,99 @@ case 808:\n \t\t;\n     break;}\n case 809:\n-#line 3524 \"parse.y\"\n+#line 3528 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 810:\n-#line 3526 \"parse.y\"\n+#line 3530 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 813:\n-#line 3537 \"parse.y\"\n+#line 3541 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 814:\n-#line 3540 \"parse.y\"\n+#line 3544 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 815:\n-#line 3543 \"parse.y\"\n+#line 3547 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 816:\n-#line 3546 \"parse.y\"\n+#line 3550 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 817:\n-#line 3548 \"parse.y\"\n+#line 3552 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 819:\n-#line 3554 \"parse.y\"\n+#line 3558 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 820:\n-#line 3564 \"parse.y\"\n+#line 3568 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 821:\n-#line 3568 \"parse.y\"\n+#line 3572 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 822:\n-#line 3571 \"parse.y\"\n+#line 3575 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 823:\n-#line 3575 \"parse.y\"\n+#line 3579 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 824:\n-#line 3579 \"parse.y\"\n+#line 3583 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 825:\n-#line 3583 \"parse.y\"\n+#line 3587 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 826:\n-#line 3590 \"parse.y\"\n+#line 3594 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 827:\n-#line 3593 \"parse.y\"\n+#line 3597 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 830:\n-#line 3604 \"parse.y\"\n+#line 3608 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 831:\n-#line 3609 \"parse.y\"\n+#line 3613 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 832:\n-#line 3614 \"parse.y\"\n+#line 3618 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7984,192 +7988,192 @@ case 832:\n \t\t;\n     break;}\n case 833:\n-#line 3626 \"parse.y\"\n+#line 3630 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 834:\n-#line 3628 \"parse.y\"\n+#line 3632 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 835:\n-#line 3630 \"parse.y\"\n+#line 3634 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 836:\n-#line 3635 \"parse.y\"\n+#line 3639 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 837:\n-#line 3643 \"parse.y\"\n+#line 3647 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 838:\n-#line 3645 \"parse.y\"\n+#line 3649 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 839:\n-#line 3650 \"parse.y\"\n+#line 3654 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 840:\n-#line 3652 \"parse.y\"\n+#line 3656 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 841:\n-#line 3654 \"parse.y\"\n+#line 3658 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3656 \"parse.y\"\n+#line 3660 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 843:\n-#line 3663 \"parse.y\"\n+#line 3667 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 844:\n-#line 3668 \"parse.y\"\n+#line 3672 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 845:\n-#line 3670 \"parse.y\"\n+#line 3674 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 846:\n-#line 3672 \"parse.y\"\n+#line 3676 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 847:\n-#line 3674 \"parse.y\"\n+#line 3678 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 848:\n-#line 3676 \"parse.y\"\n+#line 3680 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 849:\n-#line 3678 \"parse.y\"\n+#line 3682 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 850:\n-#line 3680 \"parse.y\"\n+#line 3684 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 851:\n-#line 3682 \"parse.y\"\n+#line 3686 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 852:\n-#line 3684 \"parse.y\"\n+#line 3688 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 853:\n-#line 3686 \"parse.y\"\n+#line 3690 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 854:\n-#line 3688 \"parse.y\"\n+#line 3692 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 855:\n-#line 3690 \"parse.y\"\n+#line 3694 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 856:\n-#line 3692 \"parse.y\"\n+#line 3696 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 857:\n-#line 3694 \"parse.y\"\n+#line 3698 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 858:\n-#line 3696 \"parse.y\"\n+#line 3700 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3698 \"parse.y\"\n+#line 3702 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 860:\n-#line 3700 \"parse.y\"\n+#line 3704 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 861:\n-#line 3702 \"parse.y\"\n+#line 3706 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 862:\n-#line 3704 \"parse.y\"\n+#line 3708 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 863:\n-#line 3706 \"parse.y\"\n+#line 3710 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 864:\n-#line 3708 \"parse.y\"\n+#line 3712 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 865:\n-#line 3710 \"parse.y\"\n+#line 3714 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 866:\n-#line 3712 \"parse.y\"\n+#line 3716 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 867:\n-#line 3714 \"parse.y\"\n+#line 3718 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 868:\n-#line 3716 \"parse.y\"\n+#line 3720 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 869:\n-#line 3718 \"parse.y\"\n+#line 3722 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 870:\n-#line 3720 \"parse.y\"\n+#line 3724 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 871:\n-#line 3722 \"parse.y\"\n+#line 3726 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 872:\n-#line 3724 \"parse.y\"\n+#line 3728 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 873:\n-#line 3726 \"parse.y\"\n+#line 3730 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 874:\n-#line 3728 \"parse.y\"\n+#line 3732 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 875:\n-#line 3730 \"parse.y\"\n+#line 3734 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 876:\n-#line 3732 \"parse.y\"\n+#line 3736 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 877:\n-#line 3735 \"parse.y\"\n+#line 3739 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 878:\n-#line 3737 \"parse.y\"\n+#line 3741 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8394,7 +8398,7 @@ case 878:\n     }\n   return 1;\n }\n-#line 3740 \"parse.y\"\n+#line 3744 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "76b883002b5ff901082fb8c38c43be0a89993f8d", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -2064,7 +2064,9 @@ initlist:\n \n fn.defpen:\n \tPRE_PARSED_FUNCTION_DECL\n-\t\t{ start_function (NULL_TREE, $1->fndecl, NULL_TREE, 2);\n+\t\t{ start_function (NULL_TREE, $1->fndecl, NULL_TREE, \n+\t\t\t\t  (SF_DEFAULT | SF_PRE_PARSED \n+\t\t\t\t   | SF_INCLASS_INLINE));\n \t\t  reinit_parse_for_function (); }\n \n pending_inline:\n@@ -2079,7 +2081,9 @@ pending_inline:\n                   process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init error\n-\t\t{ process_next_inline ($1); }\n+\t\t{ free_after_compilation (current_function);\n+\t\t  current_function = NULL;\n+\t\t  process_next_inline ($1); }\n \t;\n \n pending_inlines:"}, {"sha": "feb7f76807241b957001d7e491e044f726b1fa78", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -9683,13 +9683,9 @@ instantiate_decl (d)\n     {\n       extern struct obstack *saveable_obstack;\n       extern struct obstack *rtl_obstack;\n-      int saved_expanding_p = expanding_p;\n-\n-      /* We're not expanding all the way to RTL here.  */\n-      expanding_p = 0;\n \n       /* Set up context.  */\n-      start_function (NULL_TREE, d, NULL_TREE, 1);\n+      start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n       store_parm_decls ();\n \n       /* Anything we might\n@@ -9710,7 +9706,6 @@ instantiate_decl (d)\n       /* Clean up.  */\n       pop_obstacks ();\n       finish_function (lineno, 0);\n-      expanding_p = saved_expanding_p;\n \n       /* Now, generate RTL for the function.  */\n       expand_body (d);\n@@ -9869,8 +9864,13 @@ add_tree (t)\n void\n begin_tree ()\n {\n-  saved_trees = tree_cons (NULL_TREE, last_tree, saved_trees);\n-  last_tree = NULL_TREE;\n+  if (current_function)\n+    {\n+      saved_trees = tree_cons (NULL_TREE, last_tree, saved_trees);\n+      last_tree = NULL_TREE;\n+    }\n+  else\n+    saved_trees = tree_cons (NULL_TREE, NULL_TREE, saved_trees);\n }\n \n \n@@ -9879,7 +9879,8 @@ end_tree ()\n {\n   my_friendly_assert (saved_trees != NULL_TREE, 0);\n \n-  last_tree = TREE_VALUE (saved_trees);\n+  if (current_function)\n+    last_tree = TREE_VALUE (saved_trees);\n   saved_trees = TREE_CHAIN (saved_trees);\n }\n "}, {"sha": "b19408edb357324285371546f1c271ae9e18122c", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -1120,7 +1120,8 @@ synthesize_tinfo_fn (fndecl)\n   DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n   cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n \n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n+  start_function (NULL_TREE, fndecl, NULL_TREE, \n+\t\t  SF_DEFAULT | SF_PRE_PARSED);\n   store_parm_decls ();\n   clear_last_expr ();\n   push_momentary ();"}, {"sha": "38eab3b31975f09ab1d202cc100be937cc7663cc", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8f73d4b365bbfe9145bfd4ae16159d632ca0c33/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a8f73d4b365bbfe9145bfd4ae16159d632ca0c33", "patch": "@@ -1394,7 +1394,7 @@ begin_function_definition (decl_specs, declarator)\n   tree specs;\n   tree attrs;\n   split_specs_attrs (decl_specs, &specs, &attrs);\n-  if (!start_function (specs, declarator, attrs, 0))\n+  if (!start_function (specs, declarator, attrs, SF_DEFAULT))\n     return 0;\n   \n   reinit_parse_for_function ();\n@@ -2182,16 +2182,10 @@ void\n expand_body (fn)\n      tree fn;\n {\n-  int saved_expanding_p;\n   tree t;\n   tree try_block;\n \n-  /* Let the compiler know that now is the time to really generate\n-     actualy RTL.  */\n-  saved_expanding_p = expanding_p;\n-  expanding_p = 1;\n-\n-  start_function (NULL_TREE, fn, NULL_TREE, 1);\n+  start_function (NULL_TREE, fn, NULL_TREE, SF_PRE_PARSED | SF_EXPAND);\n   store_parm_decls ();\n \n   /* There are a few things that we do not handle recursively.  For\n@@ -2242,7 +2236,4 @@ expand_body (fn)\n     }\n \n   finish_function (lineno, 0);\n-\n-  /* Restore EXPANDING_P.  */\n-  expanding_p = saved_expanding_p;\n }"}]}