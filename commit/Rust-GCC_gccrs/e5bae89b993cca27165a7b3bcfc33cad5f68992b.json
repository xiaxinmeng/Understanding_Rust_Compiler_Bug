{"sha": "e5bae89b993cca27165a7b3bcfc33cad5f68992b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTViYWU4OWI5OTNjY2EyNzE2NWE3YjNiY2ZjMzNjYWQ1ZjY4OTkyYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-07T15:48:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-07T15:48:23Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Add is_full_var flag.\n\n2008-07-07  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (struct variable_info): Add is_full_var flag.\n\t(new_var_info): Set it to false.\n\t(solution_set_add): Correctly handle pointers outside a var and\n\tinside a field.\n\t(type_safe): Treat variables with is_full_var properly.\n\t(do_sd_constraint): Likewise.\n\t(do_ds_constraint): Likewise.\n\t(process_constraint): Remove zeroing offset for !use_field_sensitive.\n\t(get_constraint_for_ptr_offset): New function.\n\t(get_constraint_for_component_ref): For addresses at least include\n\tthe last field of the variable.  Handle is_full_vars properly.\n\t(get_constraint_for_1): Factor common code, handle POINTER_PLUS_EXPR.\n\t(handle_ptr_arith): Remove.\n\t(find_func_aliases): Simplify assignment handling.\n\t(create_function_info_for): For parameter and result varinfos set\n\tis_full_var flag.\n\t(create_variable_info_for): Set is_full_var flag whenever we\n\tjust created a single varinfo for a decl.\n\t(init_alias_vars): Initialize use_field_sensitive from\n\tmax-fields-for-field-sensitive parameter.\n\n\t* gcc.dg/torture/pta-ptrarith-1.c: New testcase.\n\t* gcc.dg/torture/pta-ptrarith-2.c: Likewise.\n\t* gcc.dg/torture/ipa-pta-1.c: Likewise.\n\nFrom-SVN: r137573", "tree": {"sha": "e593ea89c560060af1cb0a96659d392dc5ae6d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e593ea89c560060af1cb0a96659d392dc5ae6d94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5bae89b993cca27165a7b3bcfc33cad5f68992b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bae89b993cca27165a7b3bcfc33cad5f68992b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5bae89b993cca27165a7b3bcfc33cad5f68992b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bae89b993cca27165a7b3bcfc33cad5f68992b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77092cda69052ab6d1eca621173e76040266e5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77092cda69052ab6d1eca621173e76040266e5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77092cda69052ab6d1eca621173e76040266e5d9"}], "stats": {"total": 600, "additions": 367, "deletions": 233}, "files": [{"sha": "7faf0de305a19c3e75791ef4cfb712befd133770", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -1,3 +1,26 @@\n+2008-07-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add is_full_var flag.\n+\t(new_var_info): Set it to false.\n+\t(solution_set_add): Correctly handle pointers outside a var and\n+\tinside a field.\n+\t(type_safe): Treat variables with is_full_var properly.\n+\t(do_sd_constraint): Likewise.\n+\t(do_ds_constraint): Likewise.\n+\t(process_constraint): Remove zeroing offset for !use_field_sensitive.\n+\t(get_constraint_for_ptr_offset): New function.\n+\t(get_constraint_for_component_ref): For addresses at least include\n+\tthe last field of the variable.  Handle is_full_vars properly.\n+\t(get_constraint_for_1): Factor common code, handle POINTER_PLUS_EXPR.\n+\t(handle_ptr_arith): Remove.\n+\t(find_func_aliases): Simplify assignment handling.\n+\t(create_function_info_for): For parameter and result varinfos set\n+\tis_full_var flag.\n+\t(create_variable_info_for): Set is_full_var flag whenever we\n+\tjust created a single varinfo for a decl.\n+\t(init_alias_vars): Initialize use_field_sensitive from\n+\tmax-fields-for-field-sensitive parameter.\n+\n 2008-07-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36713"}, {"sha": "b212e44c398150b5f986a7fbd11c24a8a31c0105", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -1,3 +1,9 @@\n+2008-07-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/torture/pta-ptrarith-1.c: New testcase.\n+\t* gcc.dg/torture/pta-ptrarith-2.c: Likewise.\n+\t* gcc.dg/torture/ipa-pta-1.c: Likewise.\n+\n 2008-07-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/36726"}, {"sha": "c5adb259d26e4e00a5a20b0bb7bd0571b80decf3", "filename": "gcc/testsuite/gcc.dg/torture/ipa-pta-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fipa-pta -fdump-ipa-pta\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+struct X { char x; char y; };\n+\n+void bar (char *p);\n+\n+void test1 (char a, char b, char c, char d, char e, char f, char g, char h)\n+{\n+  char *p = &a;\n+  p++;\n+  bar (p);\n+}\n+\n+void test2 (struct X a, char b, char c, char d, char e, char f, char g, char h)\n+{\n+  char *p = &a.x;\n+  p++;\n+  bar (p);\n+}\n+\n+void test3 (struct X a, char b, char c, char d, char e, char f, char g, char h)\n+{\n+  char *p = &a.y;\n+  bar (p);\n+}\n+\n+void test4 (int a, char b, char c, char d, char e, char f, char g, char h)\n+{\n+  char *p = (char *)&a;\n+  p++;\n+  p++;\n+  p++;\n+  p++;\n+  bar (p);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"bar.arg0 = { test4.arg0 test3.arg0 test2.arg0 test1.arg0 }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "2a8dc9e3037d32e051adb419c9e46b8b8bd0019c", "filename": "gcc/testsuite/gcc.dg/torture/pta-ptrarith-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-1.c?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fdump-tree-alias\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+struct Foo {\n+  int *p;\n+};\n+\n+void __attribute__((noinline))\n+foo (void *p)\n+{\n+  struct Foo *f = (struct Foo *)p - 1;\n+  *f->p = 0;\n+}\n+\n+int bar (void)\n+{\n+  struct Foo f;\n+  int i = 1;\n+  f.p = &i;\n+  foo (&f + 1);\n+  return i;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (bar () != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"ESCAPED = { ESCAPED NONLOCAL f .* i }\" \"alias\" } } */\n+/* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "fb5b2e15ede91696c0c6ba29a7b231935d5f1d03", "filename": "gcc/testsuite/gcc.dg/torture/pta-ptrarith-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-ptrarith-2.c?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fdump-tree-alias\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+struct Foo {\n+  int **p;\n+  int **q;\n+};\n+\n+int __attribute__((noinline))\n+bar (void)\n+{\n+  struct Foo f;\n+  int j, i = 1;\n+  char *p;\n+  int *x = &i;\n+  int *y = &j;\n+  f.p = &y;\n+  f.q = &x;\n+  p = (char *)&f;\n+  for (j = 0; j < sizeof (int *); ++j)\n+    p++;\n+  return ***(int ***)p;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (bar () != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* In theory = { i } is the correct solution.  But it's not easy to scan\n+   for that reliably, so just use what we create now.  */\n+/* { dg-final { scan-tree-dump \"= { i j }\" \"alias\" } } */\n+/* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "6565d2c4b7dc4c57fd3c17177fbf149c9b1b9b5b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 229, "deletions": 233, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bae89b993cca27165a7b3bcfc33cad5f68992b/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e5bae89b993cca27165a7b3bcfc33cad5f68992b", "patch": "@@ -220,6 +220,9 @@ struct variable_info\n   /* True for variables whose size is not known or variable.  */\n   unsigned int is_unknown_size_var:1;\n \n+  /* True for (sub-)fields that represent a whole variable.  */\n+  unsigned int is_full_var : 1;\n+\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var:1;\n \n@@ -373,6 +376,7 @@ new_var_info (tree t, unsigned int id, const char *name)\n   ret->is_heap_var = false;\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n+  ret->is_full_var = false;\n   var = t;\n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n@@ -752,22 +756,32 @@ solution_set_add (bitmap set, unsigned HOST_WIDE_INT offset)\n \n   EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n     {\n-      /* If this is a properly sized variable, only add offset if it's\n-\t less than end.  Otherwise, it is globbed to a single\n-\t variable.  */\n+      varinfo_t vi = get_varinfo (i);\n \n-      if ((get_varinfo (i)->offset + offset) < get_varinfo (i)->fullsize)\n+      /* If this is a variable with just one field just set its bit\n+         in the result.  */\n+      if (vi->is_artificial_var\n+\t  || vi->is_unknown_size_var\n+\t  || vi->is_full_var)\n+\tbitmap_set_bit (result, i);\n+      else\n \t{\n-\t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (i)->offset + offset;\n-\t  varinfo_t v = first_vi_for_offset (get_varinfo (i), fieldoffset);\n+\t  unsigned HOST_WIDE_INT fieldoffset = vi->offset + offset;\n+\t  varinfo_t v = first_vi_for_offset (vi, fieldoffset);\n+\t  /* If the result is outside of the variable use the last field.  */\n \t  if (!v)\n-\t    continue;\n+\t    {\n+\t      v = vi;\n+\t      while (v->next != NULL)\n+\t\tv = v->next;\n+\t    }\n \t  bitmap_set_bit (result, v->id);\n-\t}\n-      else if (get_varinfo (i)->is_artificial_var\n-\t       || get_varinfo (i)->is_unknown_size_var)\n-\t{\n-\t  bitmap_set_bit (result, i);\n+\t  /* If the result is not exactly at fieldoffset include the next\n+\t     field as well.  See get_constraint_for_ptr_offset for more\n+\t     rationale.  */\n+\t  if (v->offset != fieldoffset\n+\t      && v->next != NULL)\n+\t    bitmap_set_bit (result, v->next->id);\n \t}\n     }\n \n@@ -1375,7 +1389,8 @@ type_safe (unsigned int n, unsigned HOST_WIDE_INT *offset)\n      0.  */\n   if (ninfo->is_special_var\n       || ninfo->is_artificial_var\n-      || ninfo->is_unknown_size_var)\n+      || ninfo->is_unknown_size_var\n+      || ninfo->is_full_var)\n     {\n       *offset = 0;\n       return true;\n@@ -1415,7 +1430,11 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n          sub-fields off.  This avoids quadratic behavior.  */\n       EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n \t{\n-\t  varinfo_t v = lookup_vi_for_tree (get_varinfo (j)->decl);\n+\t  varinfo_t v = get_varinfo (j);\n+\t  if (v->is_full_var)\n+\t    continue;\n+\n+\t  v = lookup_vi_for_tree (v->decl);\n \t  if (v->next != NULL)\n \t    {\n \t      if (vars == NULL)\n@@ -1455,6 +1474,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  unsigned int t;\n \n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n+\t  /* If the access is outside of the variable we can ignore it.  */\n \t  if (!v)\n \t    continue;\n \t  t = find (v->id);\n@@ -1507,9 +1527,14 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t unsigned HOST_WIDE_INT fieldoffset = jvi->offset + loff;\n \t varinfo_t v;\n \n-\t v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n-\t if (!v)\n-\t   continue;\n+\t v = get_varinfo (j);\n+\t if (!v->is_full_var)\n+\t   {\n+\t     v = first_vi_for_offset (v, fieldoffset);\n+\t     /* If the access is outside of the variable we can ignore it.  */\n+\t     if (!v)\n+\t       continue;\n+\t   }\n \t t = find (v->id);\n \n \t if (bitmap_set_bit (get_varinfo (t)->solution, anything_id)\n@@ -1535,6 +1560,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  bitmap tmp;\n \n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n+\t  /* If the access is outside of the variable we can ignore it.  */\n \t  if (!v)\n \t    continue;\n \t  t = find (v->id);\n@@ -2597,12 +2623,6 @@ process_constraint (constraint_t t)\n   gcc_assert (rhs.var < VEC_length (varinfo_t, varmap));\n   gcc_assert (lhs.var < VEC_length (varinfo_t, varmap));\n \n-  if (!use_field_sensitive)\n-    {\n-      t->rhs.offset = 0;\n-      t->lhs.offset = 0;\n-    }\n-\n   /* ANYTHING == ANYTHING is pointless.  */\n   if (lhs.var == anything_id && rhs.var == anything_id)\n     return;\n@@ -2678,6 +2698,119 @@ bitpos_of_field (const tree fdecl)\n }\n \n \n+/* Get constraint expressions for offsetting PTR by OFFSET.  Stores the\n+   resulting constraint expressions in *RESULTS.  */\n+\n+static void\n+get_constraint_for_ptr_offset (tree ptr, tree offset,\n+\t\t\t       VEC (ce_s, heap) **results)\n+{\n+  struct constraint_expr *c;\n+  unsigned int j, n;\n+  unsigned HOST_WIDE_INT rhsunitoffset, rhsoffset;\n+\n+  /* If we do not do field-sensitive PTA adding offsets to pointers\n+     does not change the points-to solution.  */\n+  if (!use_field_sensitive)\n+    {\n+      get_constraint_for (ptr, results);\n+      return;\n+    }\n+\n+  /* If the offset is not a non-negative integer constant that fits\n+     in a HOST_WIDE_INT, we have to fall back to a conservative\n+     solution which includes all sub-fields of all pointed-to\n+     variables of ptr.\n+     ???  As we do not have the ability to express this, fall back\n+     to anything.  */\n+  if (!host_integerp (offset, 1))\n+    {\n+      struct constraint_expr temp;\n+      temp.var = anything_id;\n+      temp.type = SCALAR;\n+      temp.offset = 0;\n+      VEC_safe_push (ce_s, heap, *results, &temp);\n+      return;\n+    }\n+\n+  /* Make sure the bit-offset also fits.  */\n+  rhsunitoffset = TREE_INT_CST_LOW (offset);\n+  rhsoffset = rhsunitoffset * BITS_PER_UNIT;\n+  if (rhsunitoffset != rhsoffset / BITS_PER_UNIT)\n+    {\n+      struct constraint_expr temp;\n+      temp.var = anything_id;\n+      temp.type = SCALAR;\n+      temp.offset = 0;\n+      VEC_safe_push (ce_s, heap, *results, &temp);\n+      return;\n+    }\n+\n+  get_constraint_for (ptr, results);\n+  if (rhsoffset == 0)\n+    return;\n+\n+  /* As we are eventually appending to the solution do not use\n+     VEC_iterate here.  */\n+  n = VEC_length (ce_s, *results);\n+  for (j = 0; j < n; j++)\n+    {\n+      varinfo_t curr;\n+      c = VEC_index (ce_s, *results, j);\n+      curr = get_varinfo (c->var);\n+\n+      if (c->type == ADDRESSOF\n+\t  && !curr->is_full_var)\n+\t{\n+\t  varinfo_t temp, curr = get_varinfo (c->var);\n+\n+\t  /* Search the sub-field which overlaps with the\n+\t     pointed-to offset.  As we deal with positive offsets\n+\t     only, we can start the search from the current variable.  */\n+\t  temp = first_vi_for_offset (curr, curr->offset + rhsoffset);\n+\n+\t  /* If the result is outside of the variable we have to provide\n+\t     a conservative result, as the variable is still reachable\n+\t     from the resulting pointer (even though it technically\n+\t     cannot point to anything).  The last sub-field is such\n+\t     a conservative result.\n+\t     ???  If we always had a sub-field for &object + 1 then\n+\t     we could represent this in a more precise way.  */\n+\t  if (temp == NULL)\n+\t    {\n+\t      temp = curr;\n+\t      while (temp->next != NULL)\n+\t\ttemp = temp->next;\n+\t      continue;\n+\t    }\n+\n+\t  /* If the found variable is not exactly at the pointed to\n+\t     result, we have to include the next variable in the\n+\t     solution as well.  Otherwise two increments by offset / 2\n+\t     do not result in the same or a conservative superset\n+\t     solution.  */\n+\t  if (temp->offset != curr->offset + rhsoffset\n+\t      && temp->next != NULL)\n+\t    {\n+\t      struct constraint_expr c2;\n+\t      c2.var = temp->next->id;\n+\t      c2.type = ADDRESSOF;\n+\t      c2.offset = 0;\n+\t      VEC_safe_push (ce_s, heap, *results, &c2);\n+\t    }\n+\t  c->var = temp->id;\n+\t  c->offset = 0;\n+\t}\n+      else if (c->type == ADDRESSOF\n+\t       /* If this varinfo represents a full variable just use it.  */\n+\t       && curr->is_full_var)\n+\tc->offset = 0;\n+      else\n+\tc->offset = rhsoffset;\n+    }\n+}\n+\n+\n /* Given a COMPONENT_REF T, return the constraint_expr vector for it.\n    If address_p is true the result will be taken its address of.  */\n \n@@ -2714,15 +2847,18 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n   /* Pretend to take the address of the base, we'll take care of\n      adding the required subset of sub-fields below.  */\n   get_constraint_for_1 (t, results, true);\n-  result = VEC_last (ce_s, *results);\n-\n   gcc_assert (VEC_length (ce_s, *results) == 1);\n+  result = VEC_last (ce_s, *results);\n \n   /* This can also happen due to weird offsetof type macros.  */\n   if (TREE_CODE (t) != ADDR_EXPR && result->type == ADDRESSOF)\n     result->type = SCALAR;\n \n-  if (result->type == SCALAR)\n+  if (result->type == SCALAR\n+      && get_varinfo (result->var)->is_full_var)\n+    /* For single-field vars do not bother about the offset.  */\n+    result->offset = 0;\n+  else if (result->type == SCALAR)\n     {\n       /* In languages like C, you can access one past the end of an\n \t array.  You aren't allowed to dereference it, so we can\n@@ -2751,12 +2887,25 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n \t\t    break;\n \t\t}\n \t    }\n-\t  /* assert that we found *some* field there. The user couldn't be\n-\t     accessing *only* padding.  */\n-\t  /* Still the user could access one past the end of an array\n-\t     embedded in a struct resulting in accessing *only* padding.  */\n-\t  gcc_assert (VEC_length (ce_s, *results) >= 1\n-\t\t      || ref_contains_array_ref (orig_t));\n+\t  /* If we are going to take the address of this field then\n+\t     to be able to compute reachability correctly add at least\n+\t     the last field of the variable.  */\n+\t  if (address_p\n+\t      && VEC_length (ce_s, *results) == 0)\n+\t    {\n+\t      curr = get_varinfo (cexpr.var);\n+\t      while (curr->next != NULL)\n+\t\tcurr = curr->next;\n+\t      cexpr.var = curr->id;\n+\t      VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t    }\n+\t  else\n+\t    /* Assert that we found *some* field there. The user couldn't be\n+\t       accessing *only* padding.  */\n+\t    /* Still the user could access one past the end of an array\n+\t       embedded in a struct resulting in accessing *only* padding.  */\n+\t    gcc_assert (VEC_length (ce_s, *results) >= 1\n+\t\t\t|| ref_contains_array_ref (orig_t));\n \t}\n       else if (bitmaxsize == 0)\n \t{\n@@ -2900,24 +3049,10 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t\tVEC_safe_push (ce_s, heap, *results, &temp);\n \t\treturn;\n \t      }\n-\t    else\n-\t      {\n-\t\ttemp.var = anything_id;\n-\t\ttemp.type = SCALAR;\n-\t\ttemp.offset = 0;\n-\t\tVEC_safe_push (ce_s, heap, *results, &temp);\n-\t\treturn;\n-\t      }\n \t    break;\n-\t  default:\n-\t    {\n-\t      temp.type = ADDRESSOF;\n-\t      temp.var = anything_id;\n-\t      temp.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &temp);\n-\t      return;\n-\t    }\n+\t  default:;\n \t  }\n+\tbreak;\n       }\n     case tcc_reference:\n       {\n@@ -2934,15 +3069,9 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t  case COMPONENT_REF:\n \t    get_constraint_for_component_ref (t, results, address_p);\n \t    return;\n-\t  default:\n-\t    {\n-\t      temp.type = ADDRESSOF;\n-\t      temp.var = anything_id;\n-\t      temp.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &temp);\n-\t      return;\n-\t    }\n+\t  default:;\n \t  }\n+\tbreak;\n       }\n     case tcc_unary:\n       {\n@@ -2963,15 +3092,19 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \n \t      /* FALLTHRU  */\n \t    }\n-\t  default:\n-\t    {\n-\t      temp.type = ADDRESSOF;\n-\t      temp.var = anything_id;\n-\t      temp.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &temp);\n-\t      return;\n-\t    }\n+\t  default:;\n \t  }\n+\tbreak;\n+      }\n+    case tcc_binary:\n+      {\n+\tif (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t  {\n+\t    get_constraint_for_ptr_offset (TREE_OPERAND (t, 0),\n+\t\t\t\t\t   TREE_OPERAND (t, 1), results);\n+\t    return;\n+\t  }\n+\tbreak;\n       }\n     case tcc_exceptional:\n       {\n@@ -2982,37 +3115,28 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t      get_constraint_for_1 (PHI_RESULT (t), results, address_p);\n \t      return;\n \t    }\n-\t    break;\n \t  case SSA_NAME:\n \t    {\n \t      get_constraint_for_ssa_var (t, results, address_p);\n \t      return;\n \t    }\n-\t    break;\n-\t  default:\n-\t    {\n-\t      temp.type = ADDRESSOF;\n-\t      temp.var = anything_id;\n-\t      temp.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &temp);\n-\t      return;\n-\t    }\n+\t  default:;\n \t  }\n+\tbreak;\n       }\n     case tcc_declaration:\n       {\n \tget_constraint_for_ssa_var (t, results, address_p);\n \treturn;\n       }\n-    default:\n-      {\n-\ttemp.type = ADDRESSOF;\n-\ttemp.var = anything_id;\n-\ttemp.offset = 0;\n-\tVEC_safe_push (ce_s, heap, *results, &temp);\n-\treturn;\n-      }\n+    default:;\n     }\n+\n+  /* The default fallback is a constraint from anything.  */\n+  temp.type = ADDRESSOF;\n+  temp.var = anything_id;\n+  temp.offset = 0;\n+  VEC_safe_push (ce_s, heap, *results, &temp);\n }\n \n /* Given a gimple tree T, return the constraint expression vector for it.  */\n@@ -3298,80 +3422,6 @@ do_structure_copy (tree lhsop, tree rhsop)\n     }\n }\n \n-\n-/* Handle pointer arithmetic EXPR when creating aliasing constraints.\n-   Expressions of the type PTR + CST can be handled in two ways:\n-\n-   1- If the constraint for PTR is ADDRESSOF for a non-structure\n-      variable, then we can use it directly because adding or\n-      subtracting a constant may not alter the original ADDRESSOF\n-      constraint (i.e., pointer arithmetic may not legally go outside\n-      an object's boundaries).\n-\n-   2- If the constraint for PTR is ADDRESSOF for a structure variable,\n-      then if CST is a compile-time constant that can be used as an\n-      offset, we can determine which sub-variable will be pointed-to\n-      by the expression.\n-\n-   Return true if the expression is handled.  For any other kind of\n-   expression, return false so that each operand can be added as a\n-   separate constraint by the caller.  */\n-\n-static bool\n-handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n-{\n-  tree op0, op1;\n-  struct constraint_expr *c, *c2;\n-  unsigned int i = 0;\n-  unsigned int j = 0;\n-  VEC (ce_s, heap) *temp = NULL;\n-  unsigned HOST_WIDE_INT rhsunitoffset, rhsoffset;\n-\n-  if (TREE_CODE (expr) != POINTER_PLUS_EXPR)\n-    return false;\n-\n-  op0 = TREE_OPERAND (expr, 0);\n-  op1 = TREE_OPERAND (expr, 1);\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (op0)));\n-\n-  /* If the offset is not a non-negative integer constant that fits\n-     in a HOST_WIDE_INT, we cannot handle it here.  */\n-  if (!host_integerp (op1, 1))\n-    return false;\n-\n-  /* Make sure the bit-offset also fits.  */\n-  rhsunitoffset = TREE_INT_CST_LOW (op1);\n-  rhsoffset = rhsunitoffset * BITS_PER_UNIT;\n-  if (rhsunitoffset != rhsoffset / BITS_PER_UNIT)\n-    return false;\n-\n-  get_constraint_for (op0, &temp);\n-\n-  for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n-    for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)\n-      {\n-\tif (c2->type == ADDRESSOF && rhsoffset != 0)\n-\t  {\n-\t    varinfo_t temp = get_varinfo (c2->var);\n-\n-\t    /* An access one after the end of an array is valid,\n-\t       so simply punt on accesses we cannot resolve.  */\n-\t    temp = first_vi_for_offset (temp, rhsoffset);\n-\t    if (temp == NULL)\n-\t      continue;\n-\t    c2->var = temp->id;\n-\t    c2->offset = 0;\n-\t  }\n-\telse\n-\t  c2->offset = rhsoffset;\n-\tprocess_constraint (new_constraint (*c, *c2));\n-      }\n-\n-  VEC_free (ce_s, heap, temp);\n-\n-  return true;\n-}\n-\n /* Create a constraint ID = OP.  */\n \n static void\n@@ -3771,89 +3821,29 @@ find_func_aliases (tree origt)\n \t    }\n \t}\n     }\n-  /* Otherwise, just a regular assignment statement.  */\n-  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+  /* Otherwise, just a regular assignment statement.  Only care about\n+     operations with pointer result, others are dealt with as escape\n+     points if they have pointer operands.  */\n+  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT\n+\t   && could_have_pointers (GIMPLE_STMT_OPERAND (t, 0)))\n     {\n       tree lhsop = GIMPLE_STMT_OPERAND (t, 0);\n       tree rhsop = GIMPLE_STMT_OPERAND (t, 1);\n-      int i;\n \n-      if (AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n-\t  && AGGREGATE_TYPE_P (TREE_TYPE (rhsop)))\n-\t{\n-\t  do_structure_copy (lhsop, rhsop);\n-\t}\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (lhsop)))\n+\tdo_structure_copy (lhsop, rhsop);\n       else\n \t{\n-\t  /* Only care about operations with pointers, structures\n-\t     containing pointers, dereferences, and call expressions.  */\n-\t  if (could_have_pointers (lhsop)\n-\t      || TREE_CODE (rhsop) == CALL_EXPR)\n+\t  unsigned int j;\n+\t  get_constraint_for (lhsop, &lhsc);\n+\t  get_constraint_for (rhsop, &rhsc);\n+\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n \t    {\n-\t      get_constraint_for (lhsop, &lhsc);\n-\t      switch (TREE_CODE_CLASS (TREE_CODE (rhsop)))\n-\t\t{\n-\t\t  /* RHS that consist of unary operations,\n-\t\t     exceptional types, or bare decls/constants, get\n-\t\t     handled directly by get_constraint_for.  */\n-\t\t  case tcc_reference:\n-\t\t  case tcc_declaration:\n-\t\t  case tcc_constant:\n-\t\t  case tcc_exceptional:\n-\t\t  case tcc_expression:\n-\t\t  case tcc_vl_exp:\n-\t\t  case tcc_unary:\n-\t\t      {\n-\t\t\tunsigned int j;\n-\n-\t\t\tget_constraint_for (rhsop, &rhsc);\n-\t\t\tfor (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n-\t\t\t  {\n-\t\t\t    struct constraint_expr *c2;\n-\t\t\t    unsigned int k;\n-\n-\t\t\t    for (k = 0; VEC_iterate (ce_s, rhsc, k, c2); k++)\n-\t\t\t      process_constraint (new_constraint (*c, *c2));\n-\t\t\t  }\n-\n-\t\t      }\n-\t\t    break;\n+\t      struct constraint_expr *c2;\n+\t      unsigned int k;\n \n-\t\t  case tcc_binary:\n-\t\t      {\n-\t\t\t/* For pointer arithmetic of the form\n-\t\t\t   PTR + CST, we can simply use PTR's\n-\t\t\t   constraint because pointer arithmetic is\n-\t\t\t   not allowed to go out of bounds.  */\n-\t\t\tif (handle_ptr_arith (lhsc, rhsop))\n-\t\t\t  break;\n-\t\t      }\n-\t\t    /* FALLTHRU  */\n-\n-\t\t  /* Otherwise, walk each operand.  Notice that we\n-\t\t     can't use the operand interface because we need\n-\t\t     to process expressions other than simple operands\n-\t\t     (e.g. INDIRECT_REF, ADDR_EXPR, CALL_EXPR).  */\n-\t\t  default:\n-\t\t    for (i = 0; i < TREE_OPERAND_LENGTH (rhsop); i++)\n-\t\t      {\n-\t\t\ttree op = TREE_OPERAND (rhsop, i);\n-\t\t\tunsigned int j;\n-\n-\t\t\tgcc_assert (VEC_length (ce_s, rhsc) == 0);\n-\t\t\tget_constraint_for (op, &rhsc);\n-\t\t\tfor (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n-\t\t\t  {\n-\t\t\t    struct constraint_expr *c2;\n-\t\t\t    while (VEC_length (ce_s, rhsc) > 0)\n-\t\t\t      {\n-\t\t\t\tc2 = VEC_last (ce_s, rhsc);\n-\t\t\t\tprocess_constraint (new_constraint (*c, *c2));\n-\t\t\t\tVEC_pop (ce_s, rhsc);\n-\t\t\t      }\n-\t\t\t  }\n-\t\t      }\n-\t\t}\n+\t      for (k = 0; VEC_iterate (ce_s, rhsc, k, c2); k++)\n+\t\tprocess_constraint (new_constraint (*c, *c2));\n \t    }\n \t}\n     }\n@@ -4222,8 +4212,7 @@ create_function_info_for (tree decl, const char *name)\n   stats.total_vars++;\n \n   /* If it's varargs, we don't know how many arguments it has, so we\n-     can't do much.\n-  */\n+     can't do much.  */\n   if (is_varargs)\n     {\n       vi->fullsize = ~0;\n@@ -4257,6 +4246,7 @@ create_function_info_for (tree decl, const char *name)\n       VEC_safe_push (varinfo_t, heap, varmap, argvi);\n       argvi->offset = i;\n       argvi->size = 1;\n+      argvi->is_full_var = true;\n       argvi->fullsize = vi->fullsize;\n       insert_into_field_list_sorted (vi, argvi);\n       stats.total_vars ++;\n@@ -4293,6 +4283,7 @@ create_function_info_for (tree decl, const char *name)\n       resultvi->offset = i;\n       resultvi->size = 1;\n       resultvi->fullsize = vi->fullsize;\n+      resultvi->is_full_var = true;\n       insert_into_field_list_sorted (vi, resultvi);\n       stats.total_vars ++;\n       if (DECL_RESULT (decl))\n@@ -4411,6 +4402,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  vi->is_unknown_size_var = 1;\n \t  vi->fullsize = ~0;\n \t  vi->size = ~0;\n+\t  vi->is_full_var = true;\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n \t  return index;\n \t}\n@@ -4447,6 +4439,8 @@ create_variable_info_for (tree decl, const char *name)\n \t  stats.total_vars++;\n \t}\n     }\n+  else\n+    vi->is_full_var = true;\n \n   VEC_free (fieldoff_s, heap, fieldstack);\n \n@@ -5198,6 +5192,8 @@ init_base_vars (void)\n static void\n init_alias_vars (void)\n {\n+  use_field_sensitive = (MAX_FIELDS_FOR_FIELD_SENSITIVE > 1);\n+\n   bitmap_obstack_initialize (&pta_obstack);\n   bitmap_obstack_initialize (&oldpta_obstack);\n   bitmap_obstack_initialize (&predbitmap_obstack);"}]}