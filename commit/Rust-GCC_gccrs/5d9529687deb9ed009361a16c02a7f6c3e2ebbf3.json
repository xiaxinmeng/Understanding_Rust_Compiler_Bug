{"sha": "5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "node_id": "C_kwDOANBUbNoAKDVkOTUyOTY4N2RlYjllZDAwOTM2MWExNmMwMmE3ZjZjM2UyZWJiZjM", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2023-01-18T08:34:19Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2023-01-18T08:34:19Z"}, "message": "rs6000: Teach rs6000_opaque_type_invalid_use_p about gcall [PR108348]\n\nPR108348 shows one special case that MMA opaque types are\nused in function arguments and treated as pass by reference,\nit results in one copying from argument to a temp variable,\nsince this copying happens before rs6000_function_arg check,\nit can cause ICE without MMA support then.  This patch is to\nteach function rs6000_opaque_type_invalid_use_p to check if\nany function argument in a gcall stmt has the invalid use of\nMMA opaque types.\n\nbtw, I checked the handling on return value, it doesn't have\nthis kind of issue as its checking and error emission is quite\nearly, so this doesn't handle function return value.\n\n\tPR target/108348\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.cc (rs6000_opaque_type_invalid_use_p): Add the\n\tsupport for invalid uses of MMA opaque type in function arguments.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/pr108348-1.c: New test.\n\t* gcc.target/powerpc/pr108348-2.c: New test.", "tree": {"sha": "8f7e5f09a53b86b43b47b9397b8d079815678ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f7e5f09a53b86b43b47b9397b8d079815678ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159b0f41adc4c8ead45e12a523470381ce716ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159b0f41adc4c8ead45e12a523470381ce716ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159b0f41adc4c8ead45e12a523470381ce716ff2"}], "stats": {"total": 65, "additions": 61, "deletions": 4}, "files": [{"sha": "16ca3a31757dffa71c9e4c967bdb8b0fa7e4a483", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "patch": "@@ -28928,9 +28928,9 @@ constant_generates_xxspltidp (vec_const_128bit_type *vsx_const)\n    __vector_pair built-in types.  They are target specific and\n    only available when MMA is supported.  With MMA supported, it\n    simply returns true, otherwise it checks if the given gimple\n-   STMT is an assignment or asm stmt and uses either of these two\n-   opaque types unexpectedly, if yes, it would raise an error\n-   message and returns true, otherwise it returns false.  */\n+   STMT is an assignment, asm or call stmt and uses either of\n+   these two opaque types unexpectedly, if yes, it would raise\n+   an error message and returns true, otherwise it returns false.  */\n \n bool\n rs6000_opaque_type_invalid_use_p (gimple *stmt)\n@@ -28959,7 +28959,7 @@ rs6000_opaque_type_invalid_use_p (gimple *stmt)\n   if (stmt)\n     {\n       /* The usage of MMA opaque types is very limited for now,\n-\t to check with gassign and gasm is enough so far.  */\n+\t to check with gassign, gasm and gcall is enough so far.  */\n       if (gassign *ga = dyn_cast<gassign *> (stmt))\n \t{\n \t  tree lhs = gimple_assign_lhs (ga);\n@@ -28988,6 +28988,17 @@ rs6000_opaque_type_invalid_use_p (gimple *stmt)\n \t\treturn true;\n \t    }\n \t}\n+      else if (gcall *gc = dyn_cast<gcall *> (stmt))\n+\t{\n+\t  unsigned nargs = gimple_call_num_args (gc);\n+\t  for (unsigned i = 0; i < nargs; i++)\n+\t    {\n+\t      tree arg = gimple_call_arg (gc, i);\n+\t      tree type = TREE_TYPE (arg);\n+\t      if (check_and_error_invalid_use (type))\n+\t\treturn true;\n+\t    }\n+\t}\n     }\n \n   return false;"}, {"sha": "29cbe7abffcd91157a8f619eb9aef7efd12ba8f6", "filename": "gcc/testsuite/gcc.target/powerpc/pr108348-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-1.c?ref=5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* If the default cpu type is power10 or later, type __vector_quad is\n+   supported.  To keep the test point available all the time, this case\n+   specifies -mdejagnu-cpu=power9 here.  This needs -mabi=no-altivec\n+   to do the copying for pass-by-reference function argument on 32 bit\n+   environment.  */\n+/* { dg-options \"-mdejagnu-cpu=power9 -mabi=no-altivec\" } */\n+\n+/* Verify there is no ICE on 32 bit and don't check the error messages\n+   on unsupported type since they could be fragile and are not test\n+   points of this case.  */\n+\n+/* { dg-excess-errors \"pr108348-1\" } */\n+\n+extern void bar (__vector_quad v);\n+\n+void\n+foo (void)\n+{\n+  __vector_quad v;\n+  bar (v);\n+}\n+"}, {"sha": "9aa8939e2f4761730f0acdd5214ac0dc8b0f4fc0", "filename": "gcc/testsuite/gcc.target/powerpc/pr108348-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9529687deb9ed009361a16c02a7f6c3e2ebbf3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr108348-2.c?ref=5d9529687deb9ed009361a16c02a7f6c3e2ebbf3", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* If the default cpu type is power10 or later, type __vector_pair is\n+   supported.  To keep the test point available all the time, this case\n+   specifies -mdejagnu-cpu=power9 here.  This needs -mabi=no-altivec\n+   to do the copying for pass-by-reference function argument on 32 bit\n+   environment.  */\n+/* { dg-options \"-mdejagnu-cpu=power9 -mabi=no-altivec\" } */\n+\n+/* Verify there is no ICE on 32 bit and don't check the error messages\n+   on unsupported type since they could be fragile and are not test\n+   points of this case.  */\n+\n+/* { dg-excess-errors \"pr108348-2\" } */\n+\n+extern void bar (__vector_pair v);\n+\n+void\n+foo (void)\n+{\n+  __vector_pair v;\n+  bar (v);\n+}\n+"}]}