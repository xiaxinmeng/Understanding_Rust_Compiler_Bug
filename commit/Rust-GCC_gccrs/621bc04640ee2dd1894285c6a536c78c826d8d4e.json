{"sha": "621bc04640ee2dd1894285c6a536c78c826d8d4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIxYmMwNDY0MGVlMmRkMTg5NDI4NWM2YTUzNmM3OGM4MjZkOGQ0ZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-08-13T16:57:16Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-08-13T16:57:16Z"}, "message": "i386.h (FIXED_REGISTERS): Do not mark REX registers here.\n\n\t* config/i386/i386.h (FIXED_REGISTERS): Do not mark REX registers here.\n\t(CALL_USED_REGISTERS): Use bitmaps to mark call-used registers\n\tfor different ABIs.\n\t(enum reg_class): Move CLOBBERED_REGS just before GENERAL_REGS.\n\t(REG_CLASS_NAMES): Update.\n\t(REG_CLASS_CONTENTS): Update.  Clear CLOBBERED_REGS members.\n\t* config/i386/i386.c (ix86_conditional_register_usage): Disable\n\tREX registers on 32bit targets.  Handle bitmaps from\n\tCALL_USED_REGISTERS initializer.  Calculate CLOBBERED_REGS register\n\tset from GENERAL_REGS also for 32bit targets.  Do not change call\n\tused register set for TARGET_64BIT_MS_ABI separately.\n\nFrom-SVN: r190349", "tree": {"sha": "ab9b7496ed7dbe9d53479d9a120b07d98f8a69d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab9b7496ed7dbe9d53479d9a120b07d98f8a69d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/621bc04640ee2dd1894285c6a536c78c826d8d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621bc04640ee2dd1894285c6a536c78c826d8d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621bc04640ee2dd1894285c6a536c78c826d8d4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621bc04640ee2dd1894285c6a536c78c826d8d4e/comments", "author": null, "committer": null, "parents": [{"sha": "391886c8e0153d41b3ab4daf4d2dd1d923d9c50f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391886c8e0153d41b3ab4daf4d2dd1d923d9c50f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391886c8e0153d41b3ab4daf4d2dd1d923d9c50f"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "bb28bd87271244692b710f79e6ebeffe5f5da3a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=621bc04640ee2dd1894285c6a536c78c826d8d4e", "patch": "@@ -1,3 +1,17 @@\n+2012-08-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (FIXED_REGISTERS): Do not mark REX registers here.\n+\t(CALL_USED_REGISTERS): Use bitmaps to mark call-used registers\n+\tfor different ABIs.\n+\t(enum reg_class): Move CLOBBERED_REGS just before GENERAL_REGS.\n+\t(REG_CLASS_NAMES): Update.\n+\t(REG_CLASS_CONTENTS): Update.  Clear CLOBBERED_REGS members.\n+\t* config/i386/i386.c (ix86_conditional_register_usage): Disable\n+\tREX registers on 32bit targets.  Handle bitmaps from\n+\tCALL_USED_REGISTERS initializer.  Calculate CLOBBERED_REGS register\n+\tset from GENERAL_REGS also for 32bit targets.  Do not change call\n+\tused register set for TARGET_64BIT_MS_ABI separately.\n+\n 2012-08-13  Richard Guenther  <rguenther@suse.de>\n \n \t* basic-block.h (struct basic_block): Remove loop_depth\n@@ -110,8 +124,8 @@\n \t(output_symtab, referenced_from_other_partition_p,\n \treachable_from_other_partition_p, referenced_from_this_partition_p,\n \treachable_from_this_partition_p): Update.\n-\t(lsei_end_p, lsei_next, lsei_node, lsei_cgraph_node, lsei_varpool_node): New\n-\tinline functions.\n+\t(lsei_end_p, lsei_next, lsei_node, lsei_cgraph_node,\n+\tlsei_varpool_node): New inline functions.\n \t(LCC_NOT_FOUND): New macro.\n \t(lto_symtab_encoder_deref, lsei_start, lsei_next_in_partition,\n \tlsei_start_in_partition, lsei_next_function_in_partition,\n@@ -160,7 +174,7 @@\n 2012-08-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_stdarg_optimize_hook): Shift DECL_UID\n-\tin the va_list_vars bitmap by num_ssa_names.\n+\tindex in the va_list_vars bitmap by num_ssa_names.\n \n 2012-08-11  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "624dab1554d6bf2e0871fba12819a05d5ba19fc0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=621bc04640ee2dd1894285c6a536c78c826d8d4e", "patch": "@@ -4135,43 +4135,42 @@ ix86_option_override (void)\n static void\n ix86_conditional_register_usage (void)\n {\n-  int i;\n+  int i, c_mask;\n   unsigned int j;\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (fixed_regs[i] > 1)\n-\tfixed_regs[i] = (fixed_regs[i] == (TARGET_64BIT ? 3 : 2));\n-      if (call_used_regs[i] > 1)\n-\tcall_used_regs[i] = (call_used_regs[i] == (TARGET_64BIT ? 3 : 2));\n-    }\n-\n   /* The PIC register, if it exists, is fixed.  */\n   j = PIC_OFFSET_TABLE_REGNUM;\n   if (j != INVALID_REGNUM)\n     fixed_regs[j] = call_used_regs[j] = 1;\n \n-  /* The 64-bit MS_ABI changes the set of call-used registers.  */\n-  if (TARGET_64BIT_MS_ABI)\n+  /* For 32-bit targets, squash the REX registers.  */\n+  if (! TARGET_64BIT)\n     {\n-      call_used_regs[SI_REG] = 0;\n-      call_used_regs[DI_REG] = 0;\n-      call_used_regs[XMM6_REG] = 0;\n-      call_used_regs[XMM7_REG] = 0;\n+      for (i = FIRST_REX_INT_REG; i <= LAST_REX_INT_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n       for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n-\tcall_used_regs[i] = 0;\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n     }\n \n-  /* The default setting of CLOBBERED_REGS is for 32-bit; add in the\n-     other call-clobbered regs for 64-bit.  */\n-  if (TARGET_64BIT)\n+  /*  See the definition of CALL_USED_REGISTERS in i386.h.  */\n+  c_mask = (TARGET_64BIT_MS_ABI ? (1 << 3)\n+\t    : TARGET_64BIT ? (1 << 2)\n+\t    : (1 << 1));\n+  \n+  CLEAR_HARD_REG_SET (reg_class_contents[(int)CLOBBERED_REGS]);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      CLEAR_HARD_REG_SET (reg_class_contents[(int)CLOBBERED_REGS]);\n+      /* Set/reset conditionally defined registers from\n+\t CALL_USED_REGISTERS initializer.  */\n+      if (call_used_regs[i] > 1)\n+\tcall_used_regs[i] = !!(call_used_regs[i] & c_mask);\n \n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[(int)GENERAL_REGS], i)\n-\t    && call_used_regs[i])\n-\t  SET_HARD_REG_BIT (reg_class_contents[(int)CLOBBERED_REGS], i);\n+      /* Calculate registers of CLOBBERED_REGS register set\n+\t as call used registers from GENERAL_REGS register set.  */\n+      if (TEST_HARD_REG_BIT (reg_class_contents[(int)GENERAL_REGS], i)\n+\t  && call_used_regs[i])\n+\tSET_HARD_REG_BIT (reg_class_contents[(int)CLOBBERED_REGS], i);\n     }\n \n   /* If MMX is disabled, squash the registers.  */\n@@ -4191,15 +4190,6 @@ ix86_conditional_register_usage (void)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       if (TEST_HARD_REG_BIT (reg_class_contents[(int)FLOAT_REGS], i))\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n-\n-  /* If 32-bit, squash the 64-bit registers.  */\n-  if (! TARGET_64BIT)\n-    {\n-      for (i = FIRST_REX_INT_REG; i <= LAST_REX_INT_REG; i++)\n-\treg_names[i] = \"\";\n-      for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n-\treg_names[i] = \"\";\n-    }\n }\n \n \f"}, {"sha": "5ff82abe93e7a7a4ff8de64801ac1737f7150d2c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/621bc04640ee2dd1894285c6a536c78c826d8d4e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=621bc04640ee2dd1894285c6a536c78c826d8d4e", "patch": "@@ -921,12 +921,9 @@ enum target_cpu_default\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer.\n \n-   The value is zero if the register is not fixed on either 32 or\n-   64 bit targets, one if the register if fixed on both 32 and 64\n-   bit targets, two if it is only fixed on 32bit targets and three\n-   if its only fixed on 64bit targets.\n-   Proper values are computed in TARGET_CONDITIONAL_REGISTER_USAGE.\n- */\n+   REX registers are disabled for 32bit targets in\n+   TARGET_CONDITIONAL_REGISTER_USAGE.  */\n+\n #define FIXED_REGISTERS\t\t\t\t\t\t\\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n {  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,\t\\\n@@ -937,10 +934,9 @@ enum target_cpu_default\n /* mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7*/\t\t\t\\\n      0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n /*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n-     2,   2,   2,   2,   2,   2,   2,   2,\t\t\t\\\n+     0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n-     2,   2,    2,    2,    2,    2,    2,    2 }\n-\n+     0,   0,    0,    0,    0,    0,    0,    0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -949,25 +945,26 @@ enum target_cpu_default\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.\n \n-   The value is zero if the register is not call used on either 32 or\n-   64 bit targets, one if the register if call used on both 32 and 64\n-   bit targets, two if it is only call used on 32bit targets and three\n-   if its only call used on 64bit targets.\n-   Proper values are computed in TARGET_CONDITIONAL_REGISTER_USAGE.\n-*/\n+   Value is set to 1 if the register is call used unconditionally.\n+   Bit one is set if the register is call used on TARGET_32BIT ABI.\n+   Bit two is set if the register is call used on TARGET_64BIT ABI.\n+   Bit three is set if the register is call used on TARGET_64BIT_MS_ABI.\n+\n+   Proper values are computed in TARGET_CONDITIONAL_REGISTER_USAGE.  */\n+\n #define CALL_USED_REGISTERS\t\t\t\t\t\\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n-{  1, 1, 1, 0, 3, 3, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,\t\\\n+{  1, 1, 1, 0, 4, 4, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,\t\\\n /*arg,flags,fpsr,fpcr,frame*/\t\t\t\t\t\\\n     1,   1,    1,   1,    1,\t\t\t\t\t\\\n /*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n+     1,   1,   1,   1,   1,   1,   6,   6,\t\t\t\\\n /* mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7*/\t\t\t\\\n      1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n /*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n      1,   1,   1,   1,   2,   2,   2,   2,\t\t\t\\\n /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n-     1,   1,    1,    1,    1,    1,    1,    1 }\n+     6,   6,    6,    6,    6,    6,    6,    6 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -1203,11 +1200,11 @@ enum reg_class\n   NO_REGS,\n   AREG, DREG, CREG, BREG, SIREG, DIREG,\n   AD_REGS,\t\t\t/* %eax/%edx for DImode */\n-  CLOBBERED_REGS,\t\t/* call-clobbered integers */\n   Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n   NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esp */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n   LEGACY_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n+  CLOBBERED_REGS,\t\t/* call-clobbered integer registers */\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp\n \t\t\t\t   %r8 %r9 %r10 %r11 %r12 %r13 %r14 %r15 */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n@@ -1253,10 +1250,10 @@ enum reg_class\n    \"AREG\", \"DREG\", \"CREG\", \"BREG\",\t\\\n    \"SIREG\", \"DIREG\",\t\t\t\\\n    \"AD_REGS\",\t\t\t\t\\\n-   \"CLOBBERED_REGS\",\t\t\t\\\n    \"Q_REGS\", \"NON_Q_REGS\",\t\t\\\n    \"INDEX_REGS\",\t\t\t\\\n    \"LEGACY_REGS\",\t\t\t\\\n+   \"CLOBBERED_REGS\",\t\t\t\\\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n    \"FLOAT_REGS\",\t\t\t\\\n@@ -1274,21 +1271,20 @@ enum reg_class\n /* Define which registers fit in which classes.  This is an initializer\n    for a vector of HARD_REG_SET of length N_REG_CLASSES.\n \n-   Note that the default setting of CLOBBERED_REGS is for 32-bit; this\n-   is adjusted by TARGET_CONDITIONAL_REGISTER_USAGE for the 64-bit ABI\n-   in effect.  */\n+   Note that CLOBBERED_REGS are calculated by\n+   TARGET_CONDITIONAL_REGISTER_USAGE.  */\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {     { 0x00,     0x0 },\t\t\t\t\t\t\\\n       { 0x01,     0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n       { 0x04,     0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n       { 0x10,     0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n       { 0x03,     0x0 },\t\t/* AD_REGS */\t\t\t\\\n-      { 0x07,     0x0 },\t\t/* CLOBBERED_REGS */\t\t\\\n       { 0x0f,     0x0 },\t\t/* Q_REGS */\t\t\t\\\n   { 0x1100f0,  0x1fe0 },\t\t/* NON_Q_REGS */\t\t\\\n       { 0x7f,  0x1fe0 },\t\t/* INDEX_REGS */\t\t\\\n   { 0x1100ff,     0x0 },\t\t/* LEGACY_REGS */\t\t\\\n+      { 0x00,     0x0 },\t\t/* CLOBBERED_REGS */\t\t\\\n   { 0x1100ff,  0x1fe0 },\t\t/* GENERAL_REGS */\t\t\\\n      { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\\\n     { 0xff00,     0x0 },\t\t/* FLOAT_REGS */\t\t\\"}]}