{"sha": "cb713a8d52e60134d85df14670a07feac505c86c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3MTNhOGQ1MmU2MDEzNGQ4NWRmMTQ2NzBhMDdmZWFjNTA1Yzg2Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-06-17T22:45:08Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-06-17T22:45:08Z"}, "message": "h8300-protos.h: Update to ISO C.\n\n\t* config/h8300/h8300-protos.h: Update to ISO C.\n\t* config/h8300/h8300.c: Likewise.\n\t* config/h8300/h8300.h: Likewise.\n\t* config/h8300/h8300.md: Likewise.\n\nFrom-SVN: r68121", "tree": {"sha": "f491c55d0ae81c619e90fde0a91f065086affb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f491c55d0ae81c619e90fde0a91f065086affb32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb713a8d52e60134d85df14670a07feac505c86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb713a8d52e60134d85df14670a07feac505c86c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb713a8d52e60134d85df14670a07feac505c86c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb713a8d52e60134d85df14670a07feac505c86c/comments", "author": null, "committer": null, "parents": [{"sha": "019bb98ee136c8aecdbf2c52e17e08f9e6caf06c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019bb98ee136c8aecdbf2c52e17e08f9e6caf06c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019bb98ee136c8aecdbf2c52e17e08f9e6caf06c"}], "stats": {"total": 515, "additions": 195, "deletions": 320}, "files": [{"sha": "e57272e7c0d71711e7972677147b26139416b9a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb713a8d52e60134d85df14670a07feac505c86c", "patch": "@@ -1,3 +1,10 @@\n+2003-06-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300-protos.h: Update to ISO C.\n+\t* config/h8300/h8300.c: Likewise.\n+\t* config/h8300/h8300.h: Likewise.\n+\t* config/h8300/h8300.md: Likewise.\n+\n 2003-06-16  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.in: Replace BUILD_CC references with CC_FOR_BUILD."}, {"sha": "320e031946c11819039e941f57eb08f1825e9d6b", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=cb713a8d52e60134d85df14670a07feac505c86c", "patch": "@@ -26,79 +26,79 @@ Boston, MA 02111-1307, USA.  */\n \n /* Declarations for functions used in insn-output.c.  */\n #ifdef RTX_CODE\n-extern const char *output_plussi PARAMS ((rtx *));\n-extern unsigned int compute_plussi_length PARAMS ((rtx *));\n-extern int compute_plussi_cc PARAMS ((rtx *));\n-extern const char *output_a_shift PARAMS ((rtx *));\n-extern unsigned int compute_a_shift_length PARAMS ((rtx, rtx *));\n-extern int compute_a_shift_cc PARAMS ((rtx, rtx *));\n-extern const char *emit_a_rotate PARAMS ((enum rtx_code, rtx *));\n-extern const char *output_simode_bld PARAMS ((int, rtx[]));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n-extern int do_movsi PARAMS ((rtx[]));\n-extern void notice_update_cc PARAMS ((rtx, rtx));\n-extern const char *output_logical_op PARAMS ((enum machine_mode, rtx *));\n-extern unsigned int compute_logical_op_length PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t       rtx *));\n-extern int compute_logical_op_cc PARAMS ((enum machine_mode, rtx *));\n-extern void expand_a_shift PARAMS ((enum machine_mode, int, rtx[]));\n-extern int h8300_shift_needs_scratch_p PARAMS ((int, enum machine_mode));\n-extern int expand_a_rotate PARAMS ((enum rtx_code, rtx[]));\n-extern int fix_bit_operand PARAMS ((rtx *, int, enum rtx_code));\n-extern int h8300_adjust_insn_length PARAMS ((rtx, int));\n-extern void split_adds_subs PARAMS ((enum machine_mode, rtx[]));\n+extern const char *output_plussi (rtx *);\n+extern unsigned int compute_plussi_length (rtx *);\n+extern int compute_plussi_cc (rtx *);\n+extern const char *output_a_shift (rtx *);\n+extern unsigned int compute_a_shift_length (rtx, rtx *);\n+extern int compute_a_shift_cc (rtx, rtx *);\n+extern const char *emit_a_rotate (enum rtx_code, rtx *);\n+extern const char *output_simode_bld (int, rtx[]);\n+extern void print_operand_address (FILE *, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void final_prescan_insn (rtx, rtx *, int);\n+extern int do_movsi (rtx[]);\n+extern void notice_update_cc (rtx, rtx);\n+extern const char *output_logical_op (enum machine_mode, rtx *);\n+extern unsigned int compute_logical_op_length (enum machine_mode,\n+\t\t\t\t\t       rtx *);\n+extern int compute_logical_op_cc (enum machine_mode, rtx *);\n+extern void expand_a_shift (enum machine_mode, int, rtx[]);\n+extern int h8300_shift_needs_scratch_p (int, enum machine_mode);\n+extern int expand_a_rotate (enum rtx_code, rtx[]);\n+extern int fix_bit_operand (rtx *, int, enum rtx_code);\n+extern int h8300_adjust_insn_length (rtx, int);\n+extern void split_adds_subs (enum machine_mode, rtx[]);\n \n-extern int general_operand_src PARAMS ((rtx, enum machine_mode));\n-extern int general_operand_dst PARAMS ((rtx, enum machine_mode));\n-extern int single_one_operand PARAMS ((rtx, enum machine_mode));\n-extern int single_zero_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n-extern int two_insn_adds_subs_operand PARAMS ((rtx, enum machine_mode));\n-extern int small_call_insn_operand PARAMS ((rtx, enum machine_mode));\n-extern int jump_address_operand PARAMS ((rtx, enum machine_mode));\n-extern int bit_operand PARAMS ((rtx, enum machine_mode));\n-extern int bit_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int stack_pointer_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_int_gt_2_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_int_ge_8_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_int_qi_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_int_hi_operand PARAMS ((rtx, enum machine_mode));\n-extern int incdec_operand PARAMS ((rtx, enum machine_mode));\n-extern int bit_operator PARAMS ((rtx, enum machine_mode));\n-extern int nshift_operator PARAMS ((rtx, enum machine_mode));\n-extern int eqne_operator PARAMS ((rtx, enum machine_mode));\n-extern int gtle_operator PARAMS ((rtx, enum machine_mode));\n-extern int gtuleu_operator PARAMS ((rtx, enum machine_mode));\n-extern int iorxor_operator PARAMS ((rtx, enum machine_mode));\n+extern int general_operand_src (rtx, enum machine_mode);\n+extern int general_operand_dst (rtx, enum machine_mode);\n+extern int single_one_operand (rtx, enum machine_mode);\n+extern int single_zero_operand (rtx, enum machine_mode);\n+extern int call_insn_operand (rtx, enum machine_mode);\n+extern int two_insn_adds_subs_operand (rtx, enum machine_mode);\n+extern int small_call_insn_operand (rtx, enum machine_mode);\n+extern int jump_address_operand (rtx, enum machine_mode);\n+extern int bit_operand (rtx, enum machine_mode);\n+extern int bit_memory_operand (rtx, enum machine_mode);\n+extern int stack_pointer_operand (rtx, enum machine_mode);\n+extern int const_int_gt_2_operand (rtx, enum machine_mode);\n+extern int const_int_ge_8_operand (rtx, enum machine_mode);\n+extern int const_int_qi_operand (rtx, enum machine_mode);\n+extern int const_int_hi_operand (rtx, enum machine_mode);\n+extern int incdec_operand (rtx, enum machine_mode);\n+extern int bit_operator (rtx, enum machine_mode);\n+extern int nshift_operator (rtx, enum machine_mode);\n+extern int eqne_operator (rtx, enum machine_mode);\n+extern int gtle_operator (rtx, enum machine_mode);\n+extern int gtuleu_operator (rtx, enum machine_mode);\n+extern int iorxor_operator (rtx, enum machine_mode);\n \n-extern int h8300_eightbit_constant_address_p PARAMS ((rtx));\n-extern int h8300_tiny_constant_address_p PARAMS ((rtx));\n-extern int byte_accesses_mergeable_p PARAMS ((rtx, rtx));\n+extern int h8300_eightbit_constant_address_p (rtx);\n+extern int h8300_tiny_constant_address_p (rtx);\n+extern int byte_accesses_mergeable_p (rtx, rtx);\n \n /* Used in builtins.c */\n-extern rtx h8300_return_addr_rtx PARAMS ((int, rtx));\n+extern rtx h8300_return_addr_rtx (int, rtx);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern struct rtx_def *function_arg PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode, tree, int));\n-extern int h8300_funcvec_function_p PARAMS ((tree));\n-extern int h8300_eightbit_data_p PARAMS ((tree));\n-extern int h8300_tiny_data_p PARAMS ((tree));\n+extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n+\t\t\t\t     enum machine_mode, tree, int);\n+extern int h8300_funcvec_function_p (tree);\n+extern int h8300_eightbit_data_p (tree);\n+extern int h8300_tiny_data_p (tree);\n #endif /* TREE_CODE */\n \n-extern void h8300_init_once PARAMS ((void));\n-extern int h8300_can_use_return_insn_p PARAMS ((void));\n-extern void h8300_expand_prologue PARAMS ((void));\n-extern void h8300_expand_epilogue PARAMS ((void));\n-extern int h8300_current_function_interrupt_function_p PARAMS ((void));\n-extern void asm_file_start PARAMS ((FILE *));\n-extern int h8300_initial_elimination_offset PARAMS ((int, int));\n+extern void h8300_init_once (void);\n+extern int h8300_can_use_return_insn_p (void);\n+extern void h8300_expand_prologue (void);\n+extern void h8300_expand_epilogue (void);\n+extern int h8300_current_function_interrupt_function_p (void);\n+extern void asm_file_start (FILE *);\n+extern int h8300_initial_elimination_offset (int, int);\n \n struct cpp_reader;\n-extern void h8300_pr_interrupt PARAMS ((struct cpp_reader *));\n-extern void h8300_pr_saveall PARAMS ((struct cpp_reader *));\n+extern void h8300_pr_interrupt (struct cpp_reader *);\n+extern void h8300_pr_saveall (struct cpp_reader *);\n \n #endif /* ! GCC_H8300_PROTOS_H */"}, {"sha": "474b499f2c08921f1c1334f76ee1a7e34c27e17b", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 122, "deletions": 254, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=cb713a8d52e60134d85df14670a07feac505c86c", "patch": "@@ -46,31 +46,31 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n \n /* Forward declarations.  */\n-static const char *byte_reg PARAMS ((rtx, int));\n-static int h8300_interrupt_function_p PARAMS ((tree));\n-static int h8300_monitor_function_p PARAMS ((tree));\n-static int h8300_os_task_function_p PARAMS ((tree));\n-static void dosize PARAMS ((int, unsigned int));\n-static int round_frame_size PARAMS ((int));\n-static unsigned int compute_saved_regs PARAMS ((void));\n-static void push PARAMS ((int));\n-static void pop PARAMS ((int));\n-static const char *cond_string PARAMS ((enum rtx_code));\n-static unsigned int h8300_asm_insn_count PARAMS ((const char *));\n+static const char *byte_reg (rtx, int);\n+static int h8300_interrupt_function_p (tree);\n+static int h8300_monitor_function_p (tree);\n+static int h8300_os_task_function_p (tree);\n+static void dosize (int, unsigned int);\n+static int round_frame_size (int);\n+static unsigned int compute_saved_regs (void);\n+static void push (int);\n+static void pop (int);\n+static const char *cond_string (enum rtx_code);\n+static unsigned int h8300_asm_insn_count (const char *);\n const struct attribute_spec h8300_attribute_table[];\n-static tree h8300_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree h8300_handle_eightbit_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree h8300_handle_tiny_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static void h8300_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void h8300_insert_attributes PARAMS ((tree, tree *));\n-static void h8300_file_end PARAMS ((void));\n+static tree h8300_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n+static tree h8300_handle_eightbit_data_attribute (tree *, tree, tree, int, bool *);\n+static tree h8300_handle_tiny_data_attribute (tree *, tree, tree, int, bool *);\n+static void h8300_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void h8300_insert_attributes (tree, tree *);\n+static void h8300_file_end (void);\n #ifndef OBJECT_FORMAT_ELF\n-static void h8300_asm_named_section PARAMS ((const char *, unsigned int));\n+static void h8300_asm_named_section (const char *, unsigned int);\n #endif\n-static void h8300_encode_section_info PARAMS ((tree, rtx, int));\n-static int h8300_and_costs PARAMS ((rtx));\n-static int h8300_shift_costs PARAMS ((rtx));\n-static bool h8300_rtx_costs PARAMS ((rtx, int, int, int *));\n+static void h8300_encode_section_info (tree, rtx, int);\n+static int h8300_and_costs (rtx);\n+static int h8300_shift_costs (rtx);\n+static bool h8300_rtx_costs (rtx, int, int, int *);\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -290,7 +290,7 @@ enum h8_cpu\n /* Initialize various cpu specific globals at start up.  */\n \n void\n-h8300_init_once ()\n+h8300_init_once (void)\n {\n   static const char *const h8_push_ops[2] = { \"push\" , \"push.l\" };\n   static const char *const h8_pop_ops[2]  = { \"pop\"  , \"pop.l\"  };\n@@ -359,9 +359,7 @@ h8300_init_once ()\n }\n \n static const char *\n-byte_reg (x, b)\n-     rtx x;\n-     int b;\n+byte_reg (rtx x, int b)\n {\n   static const char *const names_small[] = {\n     \"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n@@ -427,8 +425,7 @@ dosize (sign, size)\n /* Round up frame size SIZE.  */\n \n static int\n-round_frame_size (size)\n-     int size;\n+round_frame_size (int size)\n {\n   return ((size + STACK_BOUNDARY / BITS_PER_UNIT - 1)\n \t  & -STACK_BOUNDARY / BITS_PER_UNIT);\n@@ -438,7 +435,7 @@ round_frame_size (size)\n    Return a bit vector of registers.  */\n \n static unsigned int\n-compute_saved_regs ()\n+compute_saved_regs (void)\n {\n   unsigned int saved_regs = 0;\n   int regno;\n@@ -460,8 +457,7 @@ compute_saved_regs ()\n /* Emit an insn to push register RN.  */\n \n static void\n-push (rn)\n-     int rn;\n+push (int rn)\n {\n   rtx reg = gen_rtx_REG (word_mode, rn);\n   rtx x;\n@@ -477,8 +473,7 @@ push (rn)\n /* Emit an insn to pop register RN.  */\n \n static void\n-pop (rn)\n-     int rn;\n+pop (int rn)\n {\n   rtx reg = gen_rtx_REG (word_mode, rn);\n   rtx x;\n@@ -512,7 +507,7 @@ pop (rn)\n /* Generate RTL code for the function prologue.  */\n \n void\n-h8300_expand_prologue ()\n+h8300_expand_prologue (void)\n {\n   int regno;\n   int saved_regs;\n@@ -590,7 +585,7 @@ h8300_expand_prologue ()\n }\n \n int\n-h8300_can_use_return_insn_p ()\n+h8300_can_use_return_insn_p (void)\n {\n   return (reload_completed\n \t  && !frame_pointer_needed\n@@ -601,7 +596,7 @@ h8300_can_use_return_insn_p ()\n /* Generate RTL code for the function epilogue.  */\n \n void\n-h8300_expand_epilogue ()\n+h8300_expand_epilogue (void)\n {\n   int regno;\n   int saved_regs;\n@@ -672,18 +667,17 @@ h8300_expand_epilogue ()\n /* Output assembly language code for the function epilogue.  */\n \n static void\n-h8300_output_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+h8300_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t\tHOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   pragma_saveall = 0;\n }\n-  \n+\n /* Return nonzero if the current function is an interrupt\n    function.  */\n \n int\n-h8300_current_function_interrupt_function_p ()\n+h8300_current_function_interrupt_function_p (void)\n {\n   return (h8300_interrupt_function_p (current_function_decl)\n \t  || h8300_monitor_function_p (current_function_decl));\n@@ -692,8 +686,7 @@ h8300_current_function_interrupt_function_p ()\n /* Output assembly code for the start of the file.  */\n \n void\n-asm_file_start (file)\n-     FILE *file;\n+asm_file_start (FILE *file)\n {\n   fprintf (file, \";\\tGCC For the Hitachi H8/300\\n\");\n   fprintf (file, \";\\tBy Hitachi America Ltd and Cygnus Support\\n\");\n@@ -720,7 +713,7 @@ asm_file_start (file)\n /* Output assembly language code for the end of file.  */\n \n static void\n-h8300_file_end ()\n+h8300_file_end (void)\n {\n   fputs (\"\\t.end\\n\", asm_out_file);\n }\n@@ -729,9 +722,7 @@ h8300_file_end ()\n    instruction.  */\n \n int\n-general_operand_src (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_operand_src (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) == mode\n       && GET_CODE (op) == MEM\n@@ -744,9 +735,7 @@ general_operand_src (op, mode)\n    instruction.  */\n \n int\n-general_operand_dst (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_operand_dst (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) == mode\n       && GET_CODE (op) == MEM\n@@ -759,9 +748,7 @@ general_operand_dst (op, mode)\n    binary representation.  */\n \n int\n-single_one_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+single_one_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (operand) == CONST_INT)\n     {\n@@ -778,9 +765,7 @@ single_one_operand (operand, mode)\n    binary representation.  */\n \n int\n-single_zero_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+single_zero_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (operand) == CONST_INT)\n     {\n@@ -796,9 +781,7 @@ single_zero_operand (operand, mode)\n /* Return true if OP is a valid call operand.  */\n \n int\n-call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -816,9 +799,7 @@ call_insn_operand (op, mode)\n    straightforward way.  Otherwise, return 0.  */\n \n int\n-two_insn_adds_subs_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+two_insn_adds_subs_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -863,9 +844,7 @@ two_insn_adds_subs_operand (op, mode)\n    instead of adds/subs.  */\n \n void\n-split_adds_subs (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+split_adds_subs (enum machine_mode mode, rtx *operands)\n {\n   HOST_WIDE_INT val = INTVAL (operands[1]);\n   rtx reg = operands[0];\n@@ -911,9 +890,7 @@ split_adds_subs (mode, operands)\n    an operand for a small call (4 bytes instead of 6 bytes).  */\n \n int\n-small_call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -935,9 +912,7 @@ small_call_insn_operand (op, mode)\n /* Return true if OP is a valid jump operand.  */\n \n int\n-jump_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+jump_address_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG)\n     return mode == Pmode;\n@@ -958,9 +933,7 @@ jump_address_operand (op, mode)\n extern int rtx_equal_function_value_matters;\n \n int\n-bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+bit_operand (rtx op, enum machine_mode mode)\n {\n   /* We can accept any general operand, except that MEM operands must\n      be limited to those that use addresses valid for the 'U' constraint.  */\n@@ -982,9 +955,7 @@ bit_operand (op, mode)\n }\n \n int\n-bit_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+bit_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == MEM\n \t  && EXTRA_CONSTRAINT (op, 'U'));\n@@ -1001,15 +972,13 @@ bit_memory_operand (op, mode)\n    with this attribute may be safely used in an interrupt vector.  */\n \n void\n-h8300_pr_interrupt (pfile)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+h8300_pr_interrupt (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   pragma_interrupt = 1;\n }\n \n void\n-h8300_pr_saveall (pfile)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+h8300_pr_saveall (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   pragma_saveall = 1;\n }\n@@ -1020,11 +989,8 @@ h8300_pr_saveall (pfile)\n    If the argument is to be pushed, NULL_RTX is returned.  */\n \n rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t      tree type, int named)\n {\n   static const char *const hand_list[] = {\n     \"__main\",\n@@ -1090,8 +1056,7 @@ function_arg (cum, mode, type, named)\n }\n \f\n static int\n-h8300_and_costs (x)\n-     rtx x;\n+h8300_and_costs (rtx x)\n {\n   rtx operands[4];\n \n@@ -1110,8 +1075,7 @@ h8300_and_costs (x)\n }\n \n static int\n-h8300_shift_costs (x)\n-     rtx x;\n+h8300_shift_costs (rtx x)\n {\n   rtx operands[4];\n \n@@ -1128,10 +1092,7 @@ h8300_shift_costs (x)\n }\n \n static bool\n-h8300_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -1243,8 +1204,7 @@ h8300_rtx_costs (x, code, outer_code, total)\n /* Return assembly language string which identifies a comparison type.  */\n \n static const char *\n-cond_string (code)\n-     enum rtx_code code;\n+cond_string (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -1277,10 +1237,7 @@ cond_string (code)\n    FILE.  */\n \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   /* This is used for communication between codes V,W,Z and Y.  */\n   static int bitint;\n@@ -1568,9 +1525,7 @@ print_operand (file, x, code)\n /* Output assembly language output for the address ADDR to FILE.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -1631,9 +1586,8 @@ print_operand_address (file, addr)\n    option.  */\n \n void\n-final_prescan_insn (insn, operand, num_operands)\n-     rtx insn, *operand ATTRIBUTE_UNUSED;\n-     int num_operands ATTRIBUTE_UNUSED;\n+final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n+\t\t    int num_operands ATTRIBUTE_UNUSED)\n {\n   /* This holds the last insn address.  */\n   static int last_insn_address = 0;\n@@ -1651,8 +1605,7 @@ final_prescan_insn (insn, operand, num_operands)\n /* Prepare for an SI sized move.  */\n \n int\n-do_movsi (operands)\n-     rtx operands[];\n+do_movsi (rtx operands[])\n {\n   rtx src = operands[1];\n   rtx dst = operands[0];\n@@ -1673,8 +1626,7 @@ do_movsi (operands)\n    the other its replacement, at the start of a routine.  */\n \n int\n-h8300_initial_elimination_offset (from, to)\n-     int from, to;\n+h8300_initial_elimination_offset (int from, int to)\n {\n   int offset = 0;\n   /* The number of bytes that the return address takes on the stack.  */\n@@ -1706,9 +1658,7 @@ h8300_initial_elimination_offset (from, to)\n }\n \n rtx\n-h8300_return_addr_rtx (count, frame)\n-     int count;\n-     rtx frame;\n+h8300_return_addr_rtx (int count, rtx frame)\n {\n   rtx ret;\n \n@@ -1728,9 +1678,7 @@ h8300_return_addr_rtx (count, frame)\n /* Update the condition code from the insn.  */\n \n void\n-notice_update_cc (body, insn)\n-     rtx body;\n-     rtx insn;\n+notice_update_cc (rtx body, rtx insn)\n {\n   rtx set;\n \n@@ -1797,9 +1745,7 @@ notice_update_cc (body, insn)\n /* Return nonzero if X is a stack pointer.  */\n \n int\n-stack_pointer_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+stack_pointer_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return x == stack_pointer_rtx;\n }\n@@ -1808,9 +1754,7 @@ stack_pointer_operand (x, mode)\n    than 2.  */\n \n int\n-const_int_gt_2_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_int_gt_2_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT\n \t  && abs (INTVAL (x)) > 2);\n@@ -1820,9 +1764,7 @@ const_int_gt_2_operand (x, mode)\n    smaller than 8.  */\n \n int\n-const_int_ge_8_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_int_ge_8_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT\n \t  && abs (INTVAL (x)) >= 8);\n@@ -1831,9 +1773,7 @@ const_int_ge_8_operand (x, mode)\n /* Return nonzero if X is a constant expressible in QImode.  */\n \n int\n-const_int_qi_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_int_qi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT\n \t  && (INTVAL (x) & 0xff) == INTVAL (x));\n@@ -1842,9 +1782,7 @@ const_int_qi_operand (x, mode)\n /* Return nonzero if X is a constant expressible in HImode.  */\n \n int\n-const_int_hi_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_int_hi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT\n \t  && (INTVAL (x) & 0xffff) == INTVAL (x));\n@@ -1853,9 +1791,7 @@ const_int_hi_operand (x, mode)\n /* Return nonzero if X is a constant suitable for inc/dec.  */\n \n int\n-incdec_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+incdec_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT\n \t  && (CONST_OK_FOR_M (INTVAL (x))\n@@ -1865,9 +1801,7 @@ incdec_operand (x, mode)\n /* Return nonzero if X is either EQ or NE.  */\n \n int\n-eqne_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+eqne_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1877,9 +1811,7 @@ eqne_operator (x, mode)\n /* Return nonzero if X is GT, LE, GTU, or LEU.  */\n \n int\n-gtle_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+gtle_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1889,9 +1821,7 @@ gtle_operator (x, mode)\n /* Return nonzero if X is either GTU or LEU.  */\n \n int\n-gtuleu_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+gtuleu_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1901,9 +1831,7 @@ gtuleu_operator (x, mode)\n /* Return nonzero if X is either IOR or XOR.  */\n \n int\n-iorxor_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+iorxor_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1913,9 +1841,7 @@ iorxor_operator (x, mode)\n /* Recognize valid operators for bit instructions.  */\n \n int\n-bit_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+bit_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1925,8 +1851,7 @@ bit_operator (x, mode)\n }\n \f\n const char *\n-output_plussi (operands)\n-     rtx *operands;\n+output_plussi (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -1999,8 +1924,7 @@ output_plussi (operands)\n }\n \n unsigned int\n-compute_plussi_length (operands)\n-     rtx *operands;\n+compute_plussi_length (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -2068,8 +1992,7 @@ compute_plussi_length (operands)\n }\n \n int\n-compute_plussi_cc (operands)\n-     rtx *operands;\n+compute_plussi_cc (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -2122,9 +2045,7 @@ compute_plussi_cc (operands)\n }\n \f\n const char *\n-output_logical_op (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+output_logical_op (enum machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -2298,9 +2219,7 @@ output_logical_op (mode, operands)\n }\n \n unsigned int\n-compute_logical_op_length (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+compute_logical_op_length (enum machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -2443,9 +2362,7 @@ compute_logical_op_length (mode, operands)\n }\n \n int\n-compute_logical_op_cc (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -2556,9 +2473,7 @@ compute_logical_op_cc (mode, operands)\n    refer to shift_alg_[qhs]i.  */\n \n int\n-nshift_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+nshift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2575,10 +2490,7 @@ nshift_operator (x, mode)\n /* Emit code to do shifts.  */\n \n void\n-expand_a_shift (mode, code, operands)\n-     enum machine_mode mode;\n-     int code;\n-     rtx operands[];\n+expand_a_shift (enum machine_mode mode, int code, rtx operands[])\n {\n   emit_move_insn (operands[0], operands[1]);\n \n@@ -2783,9 +2695,9 @@ struct shift_info {\n   int cc_special;\n };\n \n-static void get_shift_alg PARAMS ((enum shift_type,\n-\t\t\t\t   enum shift_mode, unsigned int,\n-\t\t\t\t   struct shift_info *));\n+static void get_shift_alg (enum shift_type,\n+\t\t\t   enum shift_mode, unsigned int,\n+\t\t\t   struct shift_info *);\n \n /* Given SHIFT_TYPE, SHIFT_MODE, and shift count COUNT, determine the\n    best algorithm for doing the shift.  The assembler code is stored\n@@ -2800,11 +2712,8 @@ static void get_shift_alg PARAMS ((enum shift_type,\n    result is returned through INFO.  */\n \n static void\n-get_shift_alg (shift_type, shift_mode, count, info)\n-     enum shift_type shift_type;\n-     enum shift_mode shift_mode;\n-     unsigned int count;\n-     struct shift_info *info;\n+get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n+\t       unsigned int count, struct shift_info *info)\n {\n   enum h8_cpu cpu;\n \n@@ -3249,9 +3158,7 @@ get_shift_alg (shift_type, shift_mode, count, info)\n    needed for some shift with COUNT and MODE.  Return 0 otherwise.  */\n \n int\n-h8300_shift_needs_scratch_p (count, mode)\n-     int count;\n-     enum machine_mode mode;\n+h8300_shift_needs_scratch_p (int count, enum machine_mode mode)\n {\n   enum h8_cpu cpu;\n   int a, lr, ar;\n@@ -3300,8 +3207,7 @@ h8300_shift_needs_scratch_p (count, mode)\n /* Emit the assembler code for doing shifts.  */\n \n const char *\n-output_a_shift (operands)\n-     rtx *operands;\n+output_a_shift (rtx *operands)\n {\n   static int loopend_lab;\n   rtx shift = operands[3];\n@@ -3453,8 +3359,7 @@ output_a_shift (operands)\n }\n \n static unsigned int\n-h8300_asm_insn_count (template)\n-     const char *template;\n+h8300_asm_insn_count (const char *template)\n {\n   unsigned int count = 1;\n \n@@ -3466,9 +3371,7 @@ h8300_asm_insn_count (template)\n }\n \n unsigned int\n-compute_a_shift_length (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx *operands;\n+compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n   rtx shift = operands[3];\n   enum machine_mode mode = GET_MODE (shift);\n@@ -3616,9 +3519,7 @@ compute_a_shift_length (insn, operands)\n }\n \n int\n-compute_a_shift_cc (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx *operands;\n+compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n   rtx shift = operands[3];\n   enum machine_mode mode = GET_MODE (shift);\n@@ -3715,9 +3616,7 @@ compute_a_shift_cc (insn, operands)\n    emit_a_rotate () at the insn emit time.  */\n \n int\n-expand_a_rotate (code, operands)\n-     enum rtx_code code;\n-     rtx operands[];\n+expand_a_rotate (enum rtx_code code, rtx operands[])\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -3772,9 +3671,7 @@ expand_a_rotate (code, operands)\n /* Emit rotate insns.  */\n \n const char *\n-emit_a_rotate (code, operands)\n-     enum rtx_code code;\n-     rtx *operands;\n+emit_a_rotate (enum rtx_code code, rtx *operands)\n {\n   rtx dst = operands[0];\n   rtx rotate_amount = operands[2];\n@@ -3884,10 +3781,7 @@ emit_a_rotate (code, operands)\n    operating insn.  */\n \n int\n-fix_bit_operand (operands, what, type)\n-     rtx *operands;\n-     int what;\n-     enum rtx_code type;\n+fix_bit_operand (rtx *operands, int what, enum rtx_code type)\n {\n   /* The bit_operand predicate accepts any memory during RTL generation, but\n      only 'U' memory afterwards, so if this is a MEM operand, we must force\n@@ -3935,8 +3829,7 @@ fix_bit_operand (operands, what, type)\n    by the \"interrupt\" attribute.  */\n \n static int\n-h8300_interrupt_function_p (func)\n-     tree func;\n+h8300_interrupt_function_p (tree func)\n {\n   tree a;\n \n@@ -3951,8 +3844,7 @@ h8300_interrupt_function_p (func)\n    by the \"OS_Task\" attribute.  */\n \n static int\n-h8300_os_task_function_p (func)\n-     tree func;\n+h8300_os_task_function_p (tree func)\n {\n   tree a;\n \n@@ -3967,8 +3859,7 @@ h8300_os_task_function_p (func)\n    by the \"monitor\" attribute.  */\n \n static int\n-h8300_monitor_function_p (func)\n-     tree func;\n+h8300_monitor_function_p (tree func)\n {\n   tree a;\n \n@@ -3983,8 +3874,7 @@ h8300_monitor_function_p (func)\n    through the function vector.  */\n \n int\n-h8300_funcvec_function_p (func)\n-     tree func;\n+h8300_funcvec_function_p (tree func)\n {\n   tree a;\n \n@@ -3999,8 +3889,7 @@ h8300_funcvec_function_p (func)\n    data area.  */\n \n int\n-h8300_eightbit_data_p (decl)\n-     tree decl;\n+h8300_eightbit_data_p (tree decl)\n {\n   tree a;\n \n@@ -4015,8 +3904,7 @@ h8300_eightbit_data_p (decl)\n    data area.  */\n \n int\n-h8300_tiny_data_p (decl)\n-     tree decl;\n+h8300_tiny_data_p (tree decl)\n {\n   tree a;\n \n@@ -4030,9 +3918,7 @@ h8300_tiny_data_p (decl)\n /* Generate an 'interrupt_handler' attribute for decls.  */\n \n static void\n-h8300_insert_attributes (node, attributes)\n-     tree node;\n-     tree *attributes;\n+h8300_insert_attributes (tree node, tree *attributes)\n {\n   if (!pragma_interrupt\n       || TREE_CODE (node) != FUNCTION_DECL)\n@@ -4075,12 +3961,10 @@ const struct attribute_spec h8300_attribute_table[] =\n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-h8300_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+h8300_handle_fndecl_attribute (tree *node, tree name,\n+\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t       bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -4095,12 +3979,10 @@ h8300_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an \"eightbit_data\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-h8300_handle_eightbit_data_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+h8300_handle_eightbit_data_attribute (tree *node, tree name,\n+\t\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t      bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -4120,12 +4002,10 @@ h8300_handle_eightbit_data_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an \"tiny_data\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-h8300_handle_tiny_data_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+h8300_handle_tiny_data_attribute (tree *node, tree name,\n+\t\t\t\t  tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t  int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t  bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -4145,10 +4025,7 @@ h8300_handle_tiny_data_attribute (node, name, args, flags, no_add_attrs)\n /* Mark function vectors, and various small data objects.  */\n \n static void\n-h8300_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+h8300_encode_section_info (tree decl, rtx rtl, int first)\n {\n   int extra_flags = 0;\n \n@@ -4171,9 +4048,7 @@ h8300_encode_section_info (decl, rtl, first)\n }\n \n const char *\n-output_simode_bld (bild, operands)\n-     int bild;\n-     rtx operands[];\n+output_simode_bld (int bild, rtx operands[])\n {\n   if (TARGET_H8300)\n     {\n@@ -4221,9 +4096,7 @@ output_simode_bld (bild, operands)\n    We use this to get the lengths of various memory references correct.  */\n \n int\n-h8300_adjust_insn_length (insn, length)\n-     rtx insn;\n-     int length ATTRIBUTE_UNUSED;\n+h8300_adjust_insn_length (rtx insn, int length ATTRIBUTE_UNUSED)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -4389,9 +4262,7 @@ h8300_adjust_insn_length (insn, length)\n \n #ifndef OBJECT_FORMAT_ELF\n static void\n-h8300_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n+h8300_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n {\n   /* ??? Perhaps we should be using default_coff_asm_named_section.  */\n   fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n@@ -4402,8 +4273,7 @@ h8300_asm_named_section (name, flags)\n    which is a special case of the 'R' operand.  */\n \n int\n-h8300_eightbit_constant_address_p (x)\n-     rtx x;\n+h8300_eightbit_constant_address_p (rtx x)\n {\n   /* The ranges of the 8-bit area. */\n   const unsigned HOST_WIDE_INT n1 = trunc_int_for_mode (0xff00, HImode);\n@@ -4434,8 +4304,7 @@ h8300_eightbit_constant_address_p (x)\n    on H8/300H and H8S.  */\n \n int\n-h8300_tiny_constant_address_p (x)\n-     rtx x;\n+h8300_tiny_constant_address_p (rtx x)\n {\n   /* The ranges of the 16-bit area.  */\n   const unsigned HOST_WIDE_INT h1 = trunc_int_for_mode (0x00000000, SImode);\n@@ -4467,8 +4336,7 @@ h8300_tiny_constant_address_p (x)\n }\n \n int\n-byte_accesses_mergeable_p (addr1, addr2)\n-     rtx addr1, addr2;\n+byte_accesses_mergeable_p (rtx addr1, rtx addr2)\n {\n   HOST_WIDE_INT offset1, offset2;\n   rtx reg1, reg2;"}, {"sha": "03b4cc37bacf59cfb291baeb49d629d8e0873bad", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=cb713a8d52e60134d85df14670a07feac505c86c", "patch": "@@ -1128,7 +1128,7 @@ struct cum_arg\n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  \n+   This is suitable for output with `assemble_name'.\n \n    N.B.: The h8300.md branch_true and branch_false patterns also know\n    how to generate internal labels.  */"}, {"sha": "6ec03c386d98a22cd526aef370ceab9485664d74", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb713a8d52e60134d85df14670a07feac505c86c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=cb713a8d52e60134d85df14670a07feac505c86c", "patch": "@@ -2091,7 +2091,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && reg_overlap_mentioned_p (operands[0], operands[1])\n-   && reload_completed\" \n+   && reload_completed\"\n   [(set (match_dup 2)\n \t(match_dup 1))\n    (set (match_dup 3)\n@@ -2106,7 +2106,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\n-   && reload_completed\" \n+   && reload_completed\"\n   [(set (match_dup 0)\n \t(const_int 0))\n    (set (strict_low_part (match_dup 2))"}]}