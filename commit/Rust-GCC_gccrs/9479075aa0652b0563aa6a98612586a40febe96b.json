{"sha": "9479075aa0652b0563aa6a98612586a40febe96b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3OTA3NWFhMDY1MmIwNTYzYWE2YTk4NjEyNTg2YTQwZmViZTk2Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2004-12-29T13:38:30Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-12-29T13:38:30Z"}, "message": "re PR tree-optimization/18179 (vectorizer: wrong alignment/step/initial-address computed for struct accesses)\n\n2004-12-29  Ira Rosen  <irar@il.ibm.com>\n\n        PR tree-optimization/18179\n        * tree-vectorizer.c (vect_get_base_and_offset): Call get_inner_reference\n        and vect_analyze_offset_expr.\n        (vect_create_addr_base_for_vector_ref): Build address_base by combining\n        base and initial_offset fields of vect_stmt_info.\n        (vect_update_inits_of_dr): Update offset of data-ref instead of its\n        access-fn. Remove argument.\n        (vect_update_inits_of_drs): Call vect_update_inits_of_dr with new\n        arguments.\n        (vect_compute_data_ref_alignment): Check misalignment info in\n        vect_stmt_info. Remove argument.\n        (vect_compute_data_refs_alignment): Call vect_compute_data_ref_alignment\n        with correct argument.\n        (vect_analyze_data_ref_access): Check access info in vect_stmt_info.\n        (vect_analyze_pointer_ref_access): Update step and initial_offset fields\n        of vect_stmt_info.\n        (vect_get_memtag_and_dr): Call vect_get_base_and_offset and set the\n        fields of stmt_vec_info.\n        (vect_analyze_data_refs): Find vectype and pass it to\n        vect_get_memtag_and_dr.\n        (vect_get_first_index): Remove.\n        (vect_compute_array_base_alignment): Remove.\n        (vect_compute_array_ref_alignment): Remove\n        (vect_create_data_ref_ptr): Use TYPE_SIZE_UNIT instead GET_MODE_SIZE.\n        (vect_gen_niters_for_prolog_loop): Use TREE_CONSTANT instead\n        host_integerp.\n        (vectorizable_load): Use size arithmetics.\n\nFrom-SVN: r92704", "tree": {"sha": "2fa700b11e876b47f3fd734a2bb33c2f1b63fd30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fa700b11e876b47f3fd734a2bb33c2f1b63fd30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9479075aa0652b0563aa6a98612586a40febe96b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9479075aa0652b0563aa6a98612586a40febe96b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9479075aa0652b0563aa6a98612586a40febe96b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9479075aa0652b0563aa6a98612586a40febe96b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21c58af545af192f00d6242179ff41f0bba47d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c58af545af192f00d6242179ff41f0bba47d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c58af545af192f00d6242179ff41f0bba47d6b"}], "stats": {"total": 840, "additions": 309, "deletions": 531}, "files": [{"sha": "b01838679884c2407e4cb0bb9775000125218732", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9479075aa0652b0563aa6a98612586a40febe96b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9479075aa0652b0563aa6a98612586a40febe96b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9479075aa0652b0563aa6a98612586a40febe96b", "patch": "@@ -1,3 +1,33 @@\n+2004-12-29  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/18179\n+\t* tree-vectorizer.c (vect_get_base_and_offset): Call get_inner_reference\n+\tand vect_analyze_offset_expr.\n+\t(vect_create_addr_base_for_vector_ref): Build address_base by combining \n+\tbase and initial_offset fields of vect_stmt_info.\n+\t(vect_update_inits_of_dr): Update offset of data-ref instead of its\n+\taccess-fn. Remove argument.\n+\t(vect_update_inits_of_drs): Call vect_update_inits_of_dr with new\n+\targuments.\n+\t(vect_compute_data_ref_alignment): Check misalignment info in \n+\tvect_stmt_info. Remove argument.\n+\t(vect_compute_data_refs_alignment): Call vect_compute_data_ref_alignment\n+\twith correct argument.\n+\t(vect_analyze_data_ref_access): Check access info in vect_stmt_info.\n+\t(vect_analyze_pointer_ref_access): Update step and initial_offset fields\n+\tof vect_stmt_info.\n+\t(vect_get_memtag_and_dr): Call vect_get_base_and_offset and set the \n+\tfields of stmt_vec_info.\n+\t(vect_analyze_data_refs): Find vectype and pass it to \n+\tvect_get_memtag_and_dr.\n+\t(vect_get_first_index): Remove.\n+\t(vect_compute_array_base_alignment): Remove.\n+\t(vect_compute_array_ref_alignment): Remove\n+\t(vect_create_data_ref_ptr): Use TYPE_SIZE_UNIT instead GET_MODE_SIZE.\n+\t(vect_gen_niters_for_prolog_loop): Use TREE_CONSTANT instead \n+\thost_integerp.\n+\t(vectorizable_load): Use size arithmetics.\n+\n 2004-12-29  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/18179"}, {"sha": "f3f6a10d1c5223987ec5d5ae7ea0dd862d2de7a1", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 279, "deletions": 531, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9479075aa0652b0563aa6a98612586a40febe96b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9479075aa0652b0563aa6a98612586a40febe96b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=9479075aa0652b0563aa6a98612586a40febe96b", "patch": "@@ -214,24 +214,20 @@ static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *, bool);\n static void vect_mark_relevant (varray_type *, tree);\n static bool vect_stmt_relevant_p (tree, loop_vec_info);\n static tree vect_get_loop_niters (struct loop *, tree *);\n-static bool vect_compute_data_ref_alignment \n-  (struct data_reference *, loop_vec_info);\n+static bool vect_compute_data_ref_alignment (struct data_reference *);\n static bool vect_analyze_data_ref_access (struct data_reference *);\n-static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n static bool vect_can_advance_ivs_p (struct loop *);\n-static tree vect_get_base_and_offset\n-  (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n+static tree vect_get_base_and_offset (struct data_reference *, tree, tree, \n+\t\t\t\t      loop_vec_info, tree *, tree *, tree *,\n+\t\t\t\t      bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n   (tree, tree, bool);\n-static tree vect_compute_array_base_alignment (tree, tree, tree *, tree *);\n-static tree vect_compute_array_ref_alignment\n-  (struct data_reference *, loop_vec_info, tree, tree *);\n static tree vect_get_ptr_offset (tree, tree, tree *);\n static tree vect_get_memtag_and_dr\n-  (tree, tree, bool, loop_vec_info, struct data_reference **);\n+  (tree, tree, bool, loop_vec_info, tree, struct data_reference **);\n static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n \t\t\t\t      tree *, tree *);\n \n@@ -255,8 +251,7 @@ static void vect_generate_tmps_on_preheader\n static tree vect_build_loop_niters (loop_vec_info);\n static void vect_update_ivs_after_vectorizer (struct loop *, tree, edge); \n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n-static void vect_update_inits_of_dr \n-  (struct data_reference *, struct loop *, tree niters);\n+static void vect_update_inits_of_dr (struct data_reference *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n static void vect_do_peeling_for_loop_bound \n@@ -1530,9 +1525,15 @@ vect_analyze_offset_expr (tree expr,\n /* Function vect_get_base_and_offset\n \n    Return the BASE of the data reference EXPR.\n-   If VECTYPE is given, also compute the OFFSET from BASE in bits.\n-   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset in \n-   bits of 'a.b[i] + 4B' from a.\n+   If VECTYPE is given, also compute the INITIAL_OFFSET from BASE, MISALIGN and \n+   STEP.\n+   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n+   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n+   instantiated with initial_conditions of access_functions of variables, \n+   modulo alignment, and STEP is the evolution of the DR_REF in this loop.\n+\n+   Function get_inner_reference is used for the above in case of ARRAY_REF and\n+   COMPONENT_REF.\n \n    Input:\n    EXPR - the memory reference that is being analyzed\n@@ -1545,76 +1546,80 @@ vect_analyze_offset_expr (tree expr,\n    BASE (returned value) - the base of the data reference EXPR.\n                            E.g, if EXPR is a.b[k].c[i][j] the returned\n \t\t\t   base is a.\n-   OFFSET - offset of EXPR from BASE in bits\n+   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n+   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n+              computation is impossible\n+   STEP - evolution of the DR_REF in the loop\n    BASE_ALIGNED_P - indicates if BASE is aligned\n  \n    If something unexpected is encountered (an unsupported form of data-ref),\n-   or if VECTYPE is given but OFFSET cannot be determined:\n    then NULL_TREE is returned.  */\n \n static tree \n vect_get_base_and_offset (struct data_reference *dr, \n \t\t\t  tree expr, \n \t\t\t  tree vectype, \n \t\t\t  loop_vec_info loop_vinfo,\n-\t\t\t  tree *offset,\n+\t\t\t  tree *initial_offset,\n+\t\t\t  tree *misalign,\n+\t\t\t  tree *step,\n \t\t\t  bool *base_aligned_p)\n {\n   tree this_offset = size_zero_node;\n+  tree this_misalign = size_zero_node;\n+  tree this_step = size_zero_node;\n   tree base = NULL_TREE;\n   tree next_ref;\n   tree oprnd0, oprnd1;\n-  struct data_reference *array_dr;\n   enum tree_code code = TREE_CODE (expr);\n+  HOST_WIDE_INT pbitsize;\n+  HOST_WIDE_INT pbitpos;\n+  tree poffset;\n+  enum machine_mode pmode;\n+  int punsignedp, pvolatilep;\n+  tree bit_pos_in_bytes;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   *base_aligned_p = false;\n \n   switch (code)\n     {\n     /* These cases end the recursion:  */\n     case VAR_DECL:\n-      *offset = size_zero_node;\n-      if (vectype && DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n+    case PARM_DECL:\n+      *initial_offset = size_zero_node;\n+      *step = size_zero_node;\n+      *misalign = size_zero_node;\n+      if (DECL_ALIGN (expr) >= TYPE_ALIGN (vectype))\n \t*base_aligned_p = true;\n       return expr;\n \n     case SSA_NAME:\n-      if (!vectype)\n-\treturn expr;\n-\n       if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n \treturn NULL_TREE;\n       \n       if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n \t{\n-\t  base = vect_get_ptr_offset (expr, vectype, offset);\n+\t  base = vect_get_ptr_offset (expr, vectype, misalign);\n \t  if (base)\n \t    *base_aligned_p = true;\n \t}\n       else\n \t{\t  \n \t  *base_aligned_p = true;\n-\t  *offset = size_zero_node;\n-\t  base = expr;\n+\t  *misalign = size_zero_node;\n \t}\n-      return base;\n+      *initial_offset = size_zero_node;\n+      *step = size_zero_node;\n+      return expr;\n       \n     case INTEGER_CST:      \n-      *offset = int_const_binop (MULT_EXPR, expr,     \n-\t\t\t\t build_int_cst (NULL_TREE, BITS_PER_UNIT), 1);\n+      *initial_offset = fold_convert (sizetype, expr);\n+      *misalign = fold_convert (sizetype, expr);\n+      *step = size_zero_node;\n       return expr;\n \n     /* These cases continue the recursion:  */\n-    case COMPONENT_REF:\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n-\n-      this_offset = bit_position (oprnd1);\n-      if (vectype && !host_integerp (this_offset, 1))\n-        return NULL_TREE;\n-      next_ref = oprnd0;\n-      break;\n-\n     case ADDR_EXPR:\n       oprnd0 = TREE_OPERAND (expr, 0);\n       next_ref = oprnd0;\n@@ -1624,68 +1629,95 @@ vect_get_base_and_offset (struct data_reference *dr,\n       oprnd0 = TREE_OPERAND (expr, 0);\n       next_ref = oprnd0;\n       break;\n-    \n-    case ARRAY_REF:\n-      if (DR_REF (dr) != expr)\n-\t/* Build array data_reference struct if the existing DR_REF \n-\t   doesn't match EXPR. This happens, for example, when the \n-\t   EXPR is *T and T is initialized to &arr[indx]. The DR struct\n-\t   contains information on the access of T, not of arr. In order\n-\t   to continue  the analysis, we create a new DR struct that\n-\t   describes the access of arr.  \n-\t*/\n-\tarray_dr = analyze_array (DR_STMT (dr), expr, DR_IS_READ (dr));\n-      else\n-\tarray_dr = dr;\n-\t  \n-      next_ref = vect_compute_array_ref_alignment (array_dr, loop_vinfo,  \n-\t\t\t\t\t\t   vectype, &this_offset);\n-      if (!next_ref)\n-\treturn NULL_TREE;\n-\n-      if (vectype &&\n-\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (next_ref))) >= TYPE_ALIGN (vectype))\n-\t{\n-\t  *offset = this_offset;\n-\t  *base_aligned_p = true;\n-\t  return next_ref;\n-\t}\n-      break;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      /* In case we have a PLUS_EXPR of the form\n-\t (oprnd0 + oprnd1), we assume that only oprnd0 determines the base. \n-\t This is verified in  vect_get_memtag_and_dr.  */ \n       oprnd0 = TREE_OPERAND (expr, 0);\n       oprnd1 = TREE_OPERAND (expr, 1);\n \n-      base = vect_get_base_and_offset \n-\t(dr, oprnd1, vectype, loop_vinfo, &this_offset, base_aligned_p);  \n-      if (vectype && !base) \n-\treturn NULL_TREE;\n+      /* In case we have a PLUS_EXPR of the form\n+\t (oprnd0 + oprnd1), we assume that only oprnd0 determines the base.  \n+\t This is verified in vect_get_memtag_and_dr.  */\n+      base = vect_get_base_and_offset (dr, oprnd1, vectype, loop_vinfo, \n+\t\t\t\t       &this_offset, &this_misalign, \n+\t\t\t\t       &this_step, base_aligned_p);  \n+      /* Offset was already computed in vect_analyze_pointer_ref_access.  */\n+      this_offset = size_zero_node;\n+\n+      if (!base) \n+\tthis_misalign = NULL_TREE;\n \n       next_ref = oprnd0;\n       break;\n \n     default:\n-      return NULL_TREE;\n-    }\n+      if (!handled_component_p (expr))\n+\t/* Unsupported expression.  */\n+\treturn NULL_TREE;\n+\n+      /* Find the base and the offset from it.  */\n+      next_ref = get_inner_reference (expr, &pbitsize, &pbitpos, &poffset,\n+\t\t\t\t      &pmode, &punsignedp, &pvolatilep);\n+      if (!next_ref)\n+\treturn NULL_TREE;\n \n-  base = vect_get_base_and_offset (dr, next_ref, vectype, \n-\t\t\t\t   loop_vinfo, offset, base_aligned_p);  \n+      if (poffset \n+\t  && !vect_analyze_offset_expr (poffset, loop, TYPE_SIZE_UNIT (vectype), \n+\t\t\t\t\t&this_offset, &this_misalign, \n+\t\t\t\t\t&this_step))\n+\t{\n+\t  /* Failed to compute offset or step.  */\n+\t  *step = NULL_TREE;\n+\t  *initial_offset = NULL_TREE;\n+\t  *misalign = NULL_TREE;\n+\t  return NULL_TREE;\n+\t}\n \n-  if (vectype && base)\n+      /* Add bit position to OFFSET and MISALIGN.  */\n+\n+      bit_pos_in_bytes = size_int (pbitpos/BITS_PER_UNIT);\n+      /* Check that there is no remainder in bits.  */\n+      if (pbitpos%BITS_PER_UNIT)\n+\t{\n+\t  if (vect_debug_details (NULL))\n+\t    fprintf (dump_file, \"bit offset alignment.\");\n+\t  return NULL_TREE;\n+\t}\n+      this_offset = fold (size_binop (PLUS_EXPR, bit_pos_in_bytes, \n+\t\t\t\t      fold_convert (sizetype, this_offset)));     \n+      if (this_misalign) \n+\tthis_misalign = size_binop (PLUS_EXPR, this_misalign, bit_pos_in_bytes); \n+\n+      /* Continue the recursion to refine the base (get_inner_reference returns \n+\t &a for &a[i], and not a).  */\n+      break;\n+    }\n+\n+  base = vect_get_base_and_offset (dr, next_ref, vectype, loop_vinfo, \n+\t\t\t\t   initial_offset, misalign, step, \n+\t\t\t\t   base_aligned_p);  \n+  if (base)\n     {\n-      *offset = int_const_binop (PLUS_EXPR, *offset, this_offset, 1);\n-      if (!host_integerp (*offset, 1) || TREE_OVERFLOW (*offset))\n-        return NULL_TREE;\n+      /* Combine the results.  */\n+      if (this_misalign && *misalign)\n+\t*misalign = size_binop (PLUS_EXPR, *misalign, this_misalign);\n+      else \n+\t*misalign = NULL_TREE;\n+\n+      *step = size_binop (PLUS_EXPR, *step, this_step);\n+\n+      *initial_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (*initial_offset), \n+\t\t\t\t      *initial_offset, this_offset));\n \n       if (vect_debug_details (NULL))\n         {\n           print_generic_expr (dump_file, expr, TDF_SLIM);\n-          fprintf (dump_file, \" --> total offset for ref: \");\n-          print_generic_expr (dump_file, *offset, TDF_SLIM);\n+          fprintf (dump_file, \"\\n --> total offset for ref: \");\n+          print_generic_expr (dump_file, *initial_offset, TDF_SLIM);\n+          fprintf (dump_file, \"\\n --> total misalign for ref: \");\n+          print_generic_expr (dump_file, *misalign, TDF_SLIM);\n+          fprintf (dump_file, \"\\n --> total step for ref: \");\n+          print_generic_expr (dump_file, *step, TDF_SLIM);\n         }\n     }    \n   return base;\n@@ -1821,95 +1853,66 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \t\t\t\t      tree offset)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree data_ref_base = unshare_expr (STMT_VINFO_VECT_DR_BASE (stmt_info));\n   tree base_name = unshare_expr (DR_BASE_NAME (dr));\n   tree ref = DR_REF (dr);\n-  tree data_ref_base_type = TREE_TYPE (data_ref_base);\n   tree scalar_type = TREE_TYPE (ref);\n   tree scalar_ptr_type = build_pointer_type (scalar_type);\n-  tree access_fn;\n-  tree init_val, step, init_oval;\n-  bool ok;\n-  bool is_ptr_ref, is_array_ref, is_addr_expr;\n-  tree array_base;\n   tree vec_stmt;\n   tree new_temp;\n-  tree array_ref;\n   tree addr_base, addr_expr;\n   tree dest, new_stmt;\n+  tree base_offset = unshare_expr (STMT_VINFO_VECT_INIT_OFFSET (stmt_info));\n \n-  /* Only the access function of the last index is relevant (i_n in\n-     a[i_1][i_2]...[i_n]), the others correspond to loop invariants.  */\n-  access_fn = DR_ACCESS_FN (dr, 0);\n-  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_oval, &step, \n-\t\t\t\t    true);\n-  if (!ok)\n-    init_oval = integer_zero_node;\n-\n-  is_ptr_ref = TREE_CODE (data_ref_base_type) == POINTER_TYPE\n-\t       && TREE_CODE (data_ref_base) == SSA_NAME;\n-  is_array_ref = TREE_CODE (data_ref_base_type) == ARRAY_TYPE;\n-  is_addr_expr = TREE_CODE (data_ref_base) == ADDR_EXPR\n-                 || TREE_CODE (data_ref_base) == PLUS_EXPR\n-                 || TREE_CODE (data_ref_base) == MINUS_EXPR;\n-  gcc_assert (is_ptr_ref || is_array_ref || is_addr_expr);\n-\n-  /** Create: &(base[init_val])\n-\n-      if data_ref_base is an ARRAY_TYPE:\n-\t base = data_ref_base\n-\n-      if data_ref_base is the SSA_NAME of a POINTER_TYPE:\n-\t base = *((scalar_array *) data_ref_base)\n-   **/\n-\n-  if (is_array_ref)\n-    array_base = data_ref_base;\n-  else /* is_ptr_ref  or is_addr_expr */\n+  if (TREE_CODE (TREE_TYPE (data_ref_base)) != POINTER_TYPE)\n+    /* After the analysis stage, we expect to get here only with RECORD_TYPE\n+       and ARRAY_TYPE. */\n+    /* Add '&' to ref_base.  */\n+    data_ref_base = build_fold_addr_expr (data_ref_base);\n+  else\n     {\n-      /* array_ptr = (scalar_array_ptr_type *) data_ref_base;  */\n+      /* Create '(scalar_type*) base' for pointers.  */\n+      tree dest, new_stmt, new_temp, vec_stmt, tmp_base;\n       tree scalar_array_type = build_array_type (scalar_type, 0);\n       tree scalar_array_ptr_type = build_pointer_type (scalar_array_type);\n       tree array_ptr = create_tmp_var (scalar_array_ptr_type, \"array_ptr\");\n       add_referenced_tmp_var (array_ptr);\n \n       dest = create_tmp_var (TREE_TYPE (data_ref_base), \"dataref\");\n       add_referenced_tmp_var (dest);\n-      data_ref_base = \n-\tforce_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n-      append_to_statement_list_force (new_stmt, new_stmt_list);\n-\n-      vec_stmt = fold_convert (scalar_array_ptr_type, data_ref_base);\n+      tmp_base = force_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n+      append_to_statement_list_force (new_stmt,  new_stmt_list);\n+      \n+      vec_stmt = fold_convert (scalar_array_ptr_type, tmp_base);\n       vec_stmt = build2 (MODIFY_EXPR, void_type_node, array_ptr, vec_stmt);\n       new_temp = make_ssa_name (array_ptr, vec_stmt);\n       TREE_OPERAND (vec_stmt, 0) = new_temp;\n-      append_to_statement_list_force (vec_stmt, new_stmt_list);\n-\n-      /* (*array_ptr)  */\n-      array_base = build_fold_indirect_ref (new_temp);\n+      append_to_statement_list_force (vec_stmt,  new_stmt_list);\n+      data_ref_base = new_temp;\n     }\n \n-  dest = create_tmp_var (TREE_TYPE (init_oval), \"newinit\");\n+  /* Create base_offset */\n+  dest = create_tmp_var (TREE_TYPE (base_offset), \"base_off\");\n   add_referenced_tmp_var (dest);\n-  init_val = force_gimple_operand (init_oval, &new_stmt, false, dest);  \n+  base_offset = force_gimple_operand (base_offset, &new_stmt, false, dest);  \n   append_to_statement_list_force (new_stmt, new_stmt_list);\n \n   if (offset)\n     {\n-      tree tmp = create_tmp_var (TREE_TYPE (init_val), \"offset\");\n+      tree tmp = create_tmp_var (TREE_TYPE (base_offset), \"offset\");\n       add_referenced_tmp_var (tmp);\n-      vec_stmt = build2 (PLUS_EXPR, TREE_TYPE (init_val), init_val, offset);\n-      vec_stmt = build2 (MODIFY_EXPR, TREE_TYPE (init_val), tmp, vec_stmt);\n-      init_val = make_ssa_name (tmp, vec_stmt);\n-      TREE_OPERAND (vec_stmt, 0) = init_val;\n-      append_to_statement_list_force (vec_stmt, new_stmt_list);\n+      offset = fold (build2 (MULT_EXPR, TREE_TYPE (offset), offset, \n+\t\t\t     STMT_VINFO_VECT_STEP (stmt_info)));\n+      base_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (base_offset), base_offset, \n+\t\t\t\t  offset));\n+      base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n+      append_to_statement_list_force (new_stmt, new_stmt_list);\n     }\n-\n-  array_ref = build4 (ARRAY_REF, scalar_type, array_base, init_val, \n-\t\t      NULL_TREE, NULL_TREE);\n-  addr_base = build_fold_addr_expr (array_ref);\n+  \n+  /* base + base_offset */\n+  addr_base = fold (build2 (PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base, \n+\t\t\t    base_offset));\n \n   /* addr_expr = addr_base */\n   addr_expr = vect_get_new_vect_var (scalar_ptr_type, vect_pointer_var,\n@@ -1920,6 +1923,12 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n   append_to_statement_list_force (vec_stmt, new_stmt_list);\n \n+  if (vect_debug_details (NULL))\n+    {\n+      fprintf (dump_file, \"created \");\n+      print_generic_expr (dump_file, vec_stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n   return new_temp;\n }\n \n@@ -2158,8 +2167,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n   ptr_update = create_tmp_var (type, \"update\");\n   add_referenced_tmp_var (ptr_update);\n-  vectype_size = build_int_cst (integer_type_node,\n-                                GET_MODE_SIZE (TYPE_MODE (vectype)));\n+  vectype_size = TYPE_SIZE_UNIT (vectype);\n   vec_stmt = build2 (MULT_EXPR, integer_type_node, idx, vectype_size);\n   vec_stmt = build2 (MODIFY_EXPR, void_type_node, tmp, vec_stmt);\n   new_temp = make_ssa_name (tmp, vec_stmt);\n@@ -2753,11 +2761,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       else\n \t{\n \t  int mis = DR_MISALIGNMENT (dr);\n-\t  tree tmis = (mis == -1 ?\n-\t\t       integer_zero_node : \n-\t\t       build_int_cst (integer_type_node, mis));\n-\t  tmis = int_const_binop (MULT_EXPR, tmis, \n-\t\t\tbuild_int_cst (integer_type_node, BITS_PER_UNIT), 1);\n+\t  tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n+\t  tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n \t  data_ref = build2 (MISALIGNED_INDIRECT_REF, vectype, data_ref, tmis);\n \t}\n       new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n@@ -3287,7 +3292,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   /* If the loop bound is known at compile time we already verified that it is\n      greater than vf; since the misalignment ('iters') is at most vf, there's\n      no need to generate the MIN_EXPR in this case.  */\n-  if (!host_integerp (loop_niters, 0))\n+  if (!TREE_CONSTANT (loop_niters))\n     iters = build2 (MIN_EXPR, niters_type, iters, loop_niters);\n \n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n@@ -3311,25 +3316,18 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n    NITERS iterations were peeled from LOOP.  DR represents a data reference\n    in LOOP.  This function updates the information recorded in DR to\n    account for the fact that the first NITERS iterations had already been \n-   executed.  Specifically, it updates the initial_condition of the \n-   access_function of DR.  */\n+   executed.  Specifically, it updates the OFFSET field of stmt_info.  */\n \n static void\n-vect_update_inits_of_dr (struct data_reference *dr, struct loop *loop, \n-\t\t\t tree niters)\n+vect_update_inits_of_dr (struct data_reference *dr, tree niters)\n {\n-  tree access_fn = DR_ACCESS_FN (dr, 0);\n-  tree init, init_new, step;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+  tree offset = STMT_VINFO_VECT_INIT_OFFSET (stmt_info);\n       \n-  step = evolution_part_in_loop_num (access_fn, loop->num);\n-  init = initial_condition (access_fn);\n-      \n-  init_new = build2 (PLUS_EXPR, TREE_TYPE (init),\n-\t\t  build2 (MULT_EXPR, TREE_TYPE (niters),\n-\t\t\t niters, step), init);\n-  DR_ACCESS_FN (dr, 0) = chrec_replace_initial_condition (access_fn, init_new);\n-  \n-  return;\n+  niters = fold (build2 (MULT_EXPR, TREE_TYPE (niters), niters, \n+\t\t\t STMT_VINFO_VECT_STEP (stmt_info)));\n+  offset = fold (build2 (PLUS_EXPR, TREE_TYPE (offset), offset, niters));\n+  STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n }\n \n \n@@ -3347,21 +3345,20 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   unsigned int i;\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n<<vect_update_inits_of_dr>>\\n\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      vect_update_inits_of_dr (dr, loop, niters);\n+      vect_update_inits_of_dr (dr, niters);\n     }\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      vect_update_inits_of_dr (dr, loop, niters);\n+      vect_update_inits_of_dr (dr, niters);\n     }\n }\n \n@@ -4095,158 +4092,6 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_get_first_index.\n-\n-   REF is a data reference.  \n-   If it is an ARRAY_REF: if its lower bound is simple enough, \n-   put it in ARRAY_FIRST_INDEX and return TRUE; otherwise - return FALSE.\n-   If it is not an ARRAY_REF: REF has no \"first index\";\n-   ARRAY_FIRST_INDEX in zero, and the function returns TRUE.  */\n-\n-static bool\n-vect_get_first_index (tree ref, tree *array_first_index)\n-{\n-  tree array_start;\n-\n-  if (TREE_CODE (ref) != ARRAY_REF)\n-    *array_first_index = size_zero_node;\n-  else\n-    {\n-      array_start = array_ref_low_bound (ref);\n-      if (!host_integerp (array_start, 0))\n-\t{\n-\t  if (vect_debug_details (NULL))\n-\t    {\n-\t      fprintf (dump_file, \"array min val not simple integer cst.\");\n-\t      print_generic_expr (dump_file, array_start, TDF_DETAILS);\n-\t    }\n-\t  return false;\n-\t}\n-      *array_first_index = array_start;\n-    }\n-\n-  return true;\n-}\n-\n-\n-/* Function vect_compute_array_base_alignment.\n-   A utility function of vect_compute_array_ref_alignment.\n-\n-   Compute the misalignment of ARRAY in bits.\n-\n-   Input:\n-   ARRAY - an array_ref (possibly multidimensional) of type ARRAY_TYPE.\n-   VECTYPE - we are interested in the misalignment modulo the size of vectype.\n-\t     if NULL: don't compute misalignment, just return the base of ARRAY.\n-   PREV_DIMENSIONS - initialized to one.\n-   MISALIGNMENT - the computed misalignment in bits.\n-\n-   Output:\n-   If VECTYPE is not NULL:\n-     Return NULL_TREE if the misalignment cannot be computed. Otherwise, return \n-     the base of the array, and put the computed misalignment in MISALIGNMENT. \n-   If VECTYPE is NULL:\n-     Return the base of the array.\n-\n-   For a[idx_N]...[idx_2][idx_1][idx_0], the address of \n-   a[idx_N]...[idx_2][idx_1] is \n-   {&a + idx_1 * dim_0 + idx_2 * dim_0 * dim_1 + ...  \n-    ... + idx_N * dim_0 * ... * dim_N-1}. \n-   (The misalignment of &a is not checked here).\n-   Note, that every term contains dim_0, therefore, if dim_0 is a \n-   multiple of NUNITS, the whole sum is a multiple of NUNITS.\n-   Otherwise, if idx_1 is constant, and dim_1 is a multiple of\n-   NUINTS, we can say that the misalignment of the sum is equal to\n-   the misalignment of {idx_1 * dim_0}.  If idx_1 is not constant,\n-   we can't determine this array misalignment, and we return\n-   false. \n-   We proceed recursively in this manner, accumulating total misalignment\n-   and the multiplication of previous dimensions for correct misalignment\n-   calculation.  */\n-\n-static tree\n-vect_compute_array_base_alignment (tree array,\n-\t\t\t\t   tree vectype,\n-\t\t\t\t   tree *prev_dimensions,\n-\t\t\t\t   tree *misalignment)\n-{\n-  tree index;\n-  tree domain;\n-  tree dimension_size;\n-  tree mis;\n-  tree bits_per_vectype;\n-  tree bits_per_vectype_unit;\n-\n-  /* The 'stop condition' of the recursion.  */\n-  if (TREE_CODE (array) != ARRAY_REF)\n-    return array;\n-  \n-  if (!vectype)\n-    /* Just get the base decl.  */\n-    return vect_compute_array_base_alignment \n-\t\t(TREE_OPERAND (array, 0), NULL, NULL, NULL);\n-\n-  if (!host_integerp (*misalignment, 1) || TREE_OVERFLOW (*misalignment) || \n-      !host_integerp (*prev_dimensions, 1) || TREE_OVERFLOW (*prev_dimensions))\n-    return NULL_TREE;\n-\n-  domain = TYPE_DOMAIN (TREE_TYPE (array));\n-  dimension_size = \n-\tint_const_binop (PLUS_EXPR,\n-\t\tint_const_binop (MINUS_EXPR, TYPE_MAX_VALUE (domain), \n-\t\t\t\t\t     TYPE_MIN_VALUE (domain), 1),\n-\t\tsize_one_node, 1);\n-\n-  /* Check if the dimension size is a multiple of NUNITS, the remaining sum\n-     is a multiple of NUNITS: \n-\n-     dimension_size % GET_MODE_NUNITS (TYPE_MODE (vectype)) == 0 ?\n-   */\n-  mis = int_const_binop (TRUNC_MOD_EXPR, dimension_size,\n-\t build_int_cst (NULL_TREE, GET_MODE_NUNITS (TYPE_MODE (vectype))), 1);\n-  if (integer_zerop (mis))\n-    /* This array is aligned. Continue just in order to get the base decl.  */\n-    return vect_compute_array_base_alignment \n-\t\t(TREE_OPERAND (array, 0), NULL, NULL, NULL);\n-\n-  index = TREE_OPERAND (array, 1);\n-  if (!host_integerp (index, 1))\n-    /* The current index is not constant.  */\n-    return NULL_TREE;\n-   \n-  index = int_const_binop (MINUS_EXPR, index, TYPE_MIN_VALUE (domain), 0);\n-\n-  bits_per_vectype = fold_convert (unsigned_type_node, \n-    build_int_cst (NULL_TREE, BITS_PER_UNIT * \n-\t\t GET_MODE_SIZE (TYPE_MODE (vectype))));\n-  bits_per_vectype_unit =  fold_convert (unsigned_type_node,\n-    build_int_cst (NULL_TREE, BITS_PER_UNIT * \n-\t\t GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (vectype)))));\n-  \n-  /* Add {idx_i * dim_i-1 * ... * dim_0 } to the misalignment computed\n-     earlier:\n-\n-     *misalignment = \n-       (*misalignment + index_val * dimension_size * *prev_dimensions) \n-\t\t\t\t\t\t\t% vectype_nunits;\n-   */\n-\n-  mis = int_const_binop (MULT_EXPR, index, dimension_size, 1);\n-  mis = int_const_binop (MULT_EXPR, mis, *prev_dimensions, 1);\n-  mis = int_const_binop (MULT_EXPR, mis, bits_per_vectype_unit, 1);\n-  mis = int_const_binop (PLUS_EXPR, *misalignment, mis, 1);\n-  *misalignment = int_const_binop (TRUNC_MOD_EXPR, mis, bits_per_vectype, 1);\n-\n-\n-  *prev_dimensions = int_const_binop (MULT_EXPR, \n-\t\t\t\t*prev_dimensions, dimension_size, 1);\n-\n-  return vect_compute_array_base_alignment (TREE_OPERAND (array, 0), vectype,\n-\t\t\t\t\t    prev_dimensions,\n-\t\t\t\t\t    misalignment);\n-}\n-\n- \n /* Function vect_compute_data_ref_alignment\n \n    Compute the misalignment of the data reference DR.\n@@ -4260,58 +4105,33 @@ vect_compute_array_base_alignment (tree array,\n    only for trivial cases. TODO.  */\n \n static bool\n-vect_compute_data_ref_alignment (struct data_reference *dr, \n-\t\t\t\t loop_vec_info loop_vinfo)\n+vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n   tree stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);  \n   tree ref = DR_REF (dr);\n   tree vectype;\n-  tree scalar_type;\n-  tree offset = size_zero_node;\n-  tree base, bit_offset, alignment;\n-  tree unit_bits = fold_convert (unsigned_type_node, \n-\t\t\t\t build_int_cst (NULL_TREE, BITS_PER_UNIT));\n-  tree dr_base;\n+  tree base, alignment;\n   bool base_aligned_p;\n+  tree misalign;\n    \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n   DR_MISALIGNMENT (dr) = -1;\n \n-  scalar_type = TREE_TYPE (ref);\n-  vectype = get_vectype_for_scalar_type (scalar_type);\n-  if (!vectype)\n-    {\n-      if (vect_debug_details (NULL))\n-        {\n-          fprintf (dump_file, \"no vectype for stmt: \");\n-          print_generic_expr (dump_file, stmt, TDF_SLIM);\n-          fprintf (dump_file, \" scalar_type: \");\n-          print_generic_expr (dump_file, scalar_type, TDF_DETAILS);\n-        }\n-      /* It is not possible to vectorize this data reference.  */\n-      return false;\n-    }\n-  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n-  gcc_assert (TREE_CODE (ref) == ARRAY_REF || TREE_CODE (ref) == INDIRECT_REF);\n-  \n-  if (TREE_CODE (ref) == ARRAY_REF)\n-    dr_base = ref;\n-  else\n-    dr_base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n+  misalign = STMT_VINFO_VECT_MISALIGNMENT (stmt_info);\n+  base_aligned_p = STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info);\n+  base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n+  vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n-  base = vect_get_base_and_offset (dr, dr_base, vectype, \n-\t\t\t  loop_vinfo, &bit_offset, &base_aligned_p);\n-  if (!base)\n+  if (!misalign)\n     {\n       if (vect_debug_details (NULL)) \n \t{\n \t  fprintf (dump_file, \"Unknown alignment for access: \");\n-\t  print_generic_expr (dump_file, \n-\t\t\t      STMT_VINFO_VECT_DR_BASE (stmt_info), TDF_SLIM);\n+\t  print_generic_expr (dump_file, base, TDF_SLIM);\n \t}\n       return true;\n     }\n@@ -4337,40 +4157,25 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n       DECL_USER_ALIGN (base) = 1;\n     }\n \n-  /* At this point we assume that the base is aligned, and the offset from it\n-     (including index, if relevant) has been computed and is in BIT_OFFSET.  */\n+  /* At this point we assume that the base is aligned.  */\n   gcc_assert (base_aligned_p \n \t      || (TREE_CODE (base) == VAR_DECL \n \t\t  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));\n \n-  /* Convert into bytes.  */\n-  offset = int_const_binop (TRUNC_DIV_EXPR, bit_offset, unit_bits, 1);\n-  /* Check that there is no remainder in bits.  */\n-  bit_offset = int_const_binop (TRUNC_MOD_EXPR, bit_offset, unit_bits, 1);\n-  if (!integer_zerop (bit_offset))\n-    {\n-      if (vect_debug_details (NULL))\n-\t{\n-\t  fprintf (dump_file, \"bit offset alignment: \");\n-\t  print_generic_expr (dump_file, bit_offset, TDF_SLIM);\n-\t}\n-      return false;\n-    }\n-  \n   /* Alignment required, in bytes:  */\n-  alignment = fold_convert (unsigned_type_node,\n-\t    build_int_cst (NULL_TREE, TYPE_ALIGN (vectype)/BITS_PER_UNIT));\n+  alignment = size_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n \n   /* Modulo alignment.  */\n-  offset = int_const_binop (TRUNC_MOD_EXPR, offset, alignment, 0);\n-  if (!host_integerp (offset, 1) || TREE_OVERFLOW (offset))\n+  misalign = size_binop (TRUNC_MOD_EXPR, misalign, alignment);\n+  if (tree_int_cst_sgn (misalign) < 0)\n     {\n+      /* Negative misalignment value.  */\n       if (vect_debug_details (NULL))\n \tfprintf (dump_file, \"unexpected misalign value\");\n       return false;\n     }\n \n-  DR_MISALIGNMENT (dr) = tree_low_cst (offset, 1);\n+  DR_MISALIGNMENT (dr) = tree_low_cst (misalign, 1);\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"misalign = %d\", DR_MISALIGNMENT (dr));\n@@ -4379,102 +4184,6 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n }\n \n \n-/* Function vect_compute_array_ref_alignment\n-\n-   Compute the alignment of an array-ref.\n-   The alignment we compute here is relative to \n-   TYPE_ALIGN(VECTYPE) boundary.  \n-\n-   Output:\n-   OFFSET - the alignment in bits\n-   Return value - the base of the array-ref. E.g, \n-                  if the array-ref is a.b[k].c[i][j] the returned\n-\t\t  base is a.b[k].c\n-*/\n-\n-static tree\n-vect_compute_array_ref_alignment (struct data_reference *dr,\n-\t\t\t\t  loop_vec_info loop_vinfo,\n-\t\t\t\t  tree vectype,\n-\t\t\t\t  tree *offset)\n-{\n-  tree array_first_index = size_zero_node;\n-  tree init;\n-  tree ref = DR_REF (dr);\n-  tree scalar_type = TREE_TYPE (ref);\n-  tree oprnd0 = TREE_OPERAND (ref, 0);\n-  tree dims = size_one_node;  \n-  tree misalign = size_zero_node;\n-  tree next_ref, this_offset = size_zero_node;\n-  tree nunits;\n-  tree nbits;\n-\n-  if (TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n-    /* The reference is an array without its last index.  */\n-    next_ref = vect_compute_array_base_alignment (ref, vectype, &dims, \n-\t\t\t\t\t\t  &misalign);\n-  else\n-    next_ref = vect_compute_array_base_alignment (oprnd0, vectype, &dims, \n-\t\t\t\t\t\t  &misalign);\n-  if (!vectype)\n-    /* Alignment is not requested. Just return the base.  */\n-    return next_ref;\n-\n-  /* Compute alignment.  */\n-  if (!host_integerp (misalign, 1) || TREE_OVERFLOW (misalign) || !next_ref)\n-    return NULL_TREE;\n-  this_offset = misalign;\n-\n-  /* Check the first index accessed.  */\n-  if (!vect_get_first_index (ref, &array_first_index))\n-    {\n-      if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"no first_index for array.\");\n-      return NULL_TREE;\n-    }\n-\n-  /* Check the index of the array_ref.  */\n-  init = initial_condition_in_loop_num (DR_ACCESS_FN (dr, 0), \n-\t\t\t\t\tLOOP_VINFO_LOOP (loop_vinfo)->num);\n-\n-  /* FORNOW: In order to simplify the handling of alignment, we make sure\n-     that the first location at which the array is accessed ('init') is on an\n-     'NUNITS' boundary, since we are assuming here that 'array base' is aligned. \n-     This is too conservative, since we require that\n-     both {'array_base' is a multiple of NUNITS} && {'init' is a multiple of\n-     NUNITS}, instead of just {('array_base' + 'init') is a multiple of NUNITS}.\n-     This should be relaxed in the future.  */\n-\n-  if (!init || !host_integerp (init, 0))\n-    {\n-      if (vect_debug_details (NULL))\n-\tfprintf (dump_file, \"non constant init. \");\n-      return NULL_TREE;\n-    }\n-\n-  /* bytes per scalar element: */\n-  nunits = fold_convert (unsigned_type_node,\n-\tbuild_int_cst (NULL_TREE, GET_MODE_SIZE (TYPE_MODE (scalar_type))));\n-  nbits = int_const_binop (MULT_EXPR, nunits,     \n-\t\t\t   build_int_cst (NULL_TREE, BITS_PER_UNIT), 1);\n-\n-  /* misalign = offset + (init-array_first_index)*nunits*bits_in_byte */\n-  misalign = int_const_binop (MINUS_EXPR, init, array_first_index, 0);\n-  misalign = int_const_binop (MULT_EXPR, misalign, nbits, 0);\n-  misalign = int_const_binop (PLUS_EXPR, misalign, this_offset, 0);\n-\n-  /* TODO: allow negative misalign values.  */\n-  if (!host_integerp (misalign, 1) || TREE_OVERFLOW (misalign))\n-    {\n-      if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"unexpected misalign value\");\n-      return NULL_TREE;\n-    }\n-  *offset = misalign;\n-  return next_ref;\n-}\n-\n-\n /* Function vect_compute_data_refs_alignment\n \n    Compute the misalignment of data references in the loop.\n@@ -4494,14 +4203,14 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (!vect_compute_data_ref_alignment (dr, loop_vinfo))\n+      if (!vect_compute_data_ref_alignment (dr))\n \treturn false;\n     }\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      if (!vect_compute_data_ref_alignment (dr, loop_vinfo))\n+      if (!vect_compute_data_ref_alignment (dr))\n \treturn false;\n     }\n \n@@ -4753,53 +4462,22 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n /* Function vect_analyze_data_ref_access.\n \n    Analyze the access pattern of the data-reference DR. For now, a data access\n-   has to consecutive and aligned to be considered vectorizable.  */\n+   has to consecutive to be considered vectorizable.  */\n \n static bool\n vect_analyze_data_ref_access (struct data_reference *dr)\n {\n-  varray_type access_fns = DR_ACCESS_FNS (dr);\n-  tree access_fn;\n-  tree init, step;\n-  unsigned int dimensions, i;\n-\n-  /* Check that in case of multidimensional array ref A[i1][i2]..[iN],\n-     i1, i2, ..., iN-1 are loop invariant (to make sure that the memory\n-     access is contiguous).  */\n-  dimensions = VARRAY_ACTIVE_SIZE (access_fns);\n-\n-  for (i = 1; i < dimensions; i++) /* Not including the last dimension.  */\n-    {\n-      access_fn = DR_ACCESS_FN (dr, i);\n+  tree stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt); \n+  tree step = STMT_VINFO_VECT_STEP (stmt_info);\n+  tree scalar_type = TREE_TYPE (DR_REF (dr));\n \n-      if (evolution_part_in_loop_num (access_fn, \n-\t\t\t\t      loop_containing_stmt (DR_STMT (dr))->num))\n-\t{\n-\t  /* Evolution part is not NULL in this loop (it is neither constant \n-\t     nor invariant).  */\n-\t  if (vect_debug_details (NULL))\n-\t    {\n-\t      fprintf (dump_file, \n-\t\t       \"not vectorized: complicated multidim. array access.\");\n-\t      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n-\t    }\n-\t  return false;\n-\t}\n-    }\n-  \n-  access_fn = DR_ACCESS_FN (dr, 0); /*  The last dimension access function.  */\n-  if (!evolution_function_is_constant_p (access_fn)\n-      && !vect_is_simple_iv_evolution (loop_containing_stmt (DR_STMT (dr))->num,\n-\t\t\t\t       access_fn, &init, &step, true))\n+  if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n     {\n       if (vect_debug_details (NULL))\n-\t{\n-\t  fprintf (dump_file, \"not vectorized: complicated access function.\");\n-\t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n-\t}\n+\tfprintf (dump_file, \"not consecutive access\");\n       return false;\n     }\n-  \n   return true;\n }\n \n@@ -4869,9 +4547,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   tree access_fn = analyze_scalar_evolution (loop, TREE_OPERAND (memref, 0));\n   tree init, step;\t\n-  int step_val;\n   tree reftype, innertype;\n-  enum machine_mode innermode;\n   tree indx_access_fn; \n   int loopnum = loop->num;\n   struct data_reference *dr;\n@@ -4898,16 +4574,14 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \t\t\n   STRIP_NOPS (init);\n \n-  if (!host_integerp (step,0))\n+  if (!TREE_CONSTANT (step))\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop)) \n \tfprintf (dump_file, \n \t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n     }\n \n-  step_val = TREE_INT_CST_LOW (step);\n-\n   reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n@@ -4925,15 +4599,23 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n     }\n \n   innertype = TREE_TYPE (reftype);\n-  innermode = TYPE_MODE (innertype);\n-  if (GET_MODE_SIZE (innermode) != step_val) \n+  if (tree_int_cst_compare (TYPE_SIZE_UNIT (innertype), step))\n     {\n       /* FORNOW: support only consecutive access */\n       if (vect_debug_stats (loop) || vect_debug_details (loop)) \n \tfprintf (dump_file, \"not vectorized: non consecutive access.\");\t\n       return NULL;\n     }\n \n+  STMT_VINFO_VECT_STEP (stmt_info) = fold_convert (sizetype, step);\n+  if (TREE_CODE (init) == PLUS_EXPR \n+      || TREE_CODE (init) == MINUS_EXPR)\n+    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n+      fold (size_binop (TREE_CODE (init), size_zero_node, \n+\t\t\tfold_convert (sizetype, TREE_OPERAND (init, 1))));\n+  else\n+    STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = size_zero_node;\n+\n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n   if (vect_debug_details (NULL)) \n@@ -4980,12 +4662,13 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n static tree\n vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read, \n-\t\t\tloop_vec_info loop_vinfo, struct data_reference **dr)\n+\t\t\tloop_vec_info loop_vinfo, \n+\t\t\ttree vectype, struct data_reference **dr)\n {\n   tree symbl, oprnd0, oprnd1;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree offset;\n-  tree tag;\n+  tree offset, misalign, step;\n+  tree ref_to_be_analyzed, tag, dr_base;\n   struct data_reference *new_dr;\n   bool base_aligned_p;\n \n@@ -5032,8 +4715,7 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t  /* Fall through.  */\n \t\n \tcase ADDR_EXPR:\n-\t  symbl = vect_get_base_and_offset ((*dr), memref, NULL_TREE, \n-\t\t\t\t\tloop_vinfo, &offset, &base_aligned_p);\n+\t  symbl = STMT_VINFO_VECT_DR_BASE (stmt_info);\n \t  break; /* For recursive call.  */\n \n \tcase PLUS_EXPR:\n@@ -5075,35 +4757,86 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t    return NULL_TREE; \n \t  *dr = new_dr;\n \t  symbl = DR_BASE_NAME (new_dr);\n-\t  STMT_VINFO_VECT_DR_BASE (stmt_info) = symbl;\n+\t  ref_to_be_analyzed = DR_BASE_NAME (new_dr);\n \t  break;\n       \n \tcase ARRAY_REF:\n \t  new_dr = analyze_array (stmt, memref, is_read);\n \t  *dr = new_dr;\n \t  symbl = DR_BASE_NAME (new_dr);\n-\t  STMT_VINFO_VECT_DR_BASE (stmt_info) = TREE_OPERAND (memref, 0);\n+\t  ref_to_be_analyzed = memref;\n \t  break;\n \n \tdefault:\n \t  /* TODO: Support data-refs of form a[i].p for unions and single\n \t     field structures.  */\n \t  return NULL_TREE;\n-\t}      \n+\t}  \n+\n+      offset = size_zero_node;\n+      misalign = size_zero_node;\n+      step = size_zero_node;\n+\n+      /* Analyze data-ref, find its base, initial offset from the base, step,\n+\t and alignment.  */\n+      dr_base = vect_get_base_and_offset (new_dr, ref_to_be_analyzed, \n+\t\t\t\t\t  vectype, loop_vinfo, &offset, \n+\t\t\t\t\t  &misalign, &step, &base_aligned_p);\n+      if (!dr_base)\n+\treturn NULL_TREE;\n+    \n+      /* Initialize information according to above analysis.  */\n+      /* Since offset and step of a pointer can be also set in\n+\t vect_analyze_pointer_ref_access, we combine the values here. */\n+      if (STMT_VINFO_VECT_INIT_OFFSET (stmt_info))\n+\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = \n+\t  fold (build2 (PLUS_EXPR, TREE_TYPE (offset), offset,\n+\t\t\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info)));\t\t  \n+      else\n+\tSTMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n+\n+      if (step && STMT_VINFO_VECT_STEP (stmt_info))\n+\tSTMT_VINFO_VECT_STEP (stmt_info) = \n+\t  size_binop (PLUS_EXPR, step, STMT_VINFO_VECT_STEP (stmt_info));\n+      else\n+\tSTMT_VINFO_VECT_STEP (stmt_info) = step;\n+\n+      STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned_p;\n+      STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n+      STMT_VINFO_VECT_DR_BASE (stmt_info) = dr_base;\t     \n     }\n \n   if (!symbl)\n-     return NULL_TREE;\n+    return NULL_TREE;\n   /* Recursive call to retrieve the relevant memtag.  */\n-  tag = vect_get_memtag_and_dr (symbl, stmt, is_read, loop_vinfo, dr);\n+  tag = vect_get_memtag_and_dr (symbl, stmt, is_read, loop_vinfo, vectype, dr);\n   return tag;\n }\n \n \n+\n /* Function vect_analyze_data_refs.\n \n    Find all the data references in the loop.\n \n+   The general structure of the analysis of data refs in the vectorizer is as \n+   follows:\n+   1- vect_analyze_data_refs(loop): \n+      Find and analyze all data-refs in the loop:\n+          foreach ref\n+             ref_stmt.memtag =  vect_get_memtag_and_dr (ref)\n+   1.1- vect_get_memtag_and_dr(ref): \n+      Analyze ref, and build a DR (data_referece struct) for it;\n+      call vect_get_base_and_offset to compute base, initial_offset, \n+      step and alignment. Set ref_stmt.base, ref_stmt.initial_offset,\n+      ref_stmt.alignment, and ref_stmt.step accordingly. \n+   1.1.1- vect_get_base_and_offset():\n+      Calculate base, initial_offset, step and alignment.      \n+      For ARRAY_REFs and COMPONENT_REFs use call get_inner_reference.\n+   2- vect_analyze_dependences(): apply dependece testing using ref_stmt.DR\n+   3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n+   4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n+\n    FORNOW: Handle aligned INDIRECT_REFs and ARRAY_REFs \n \t   which base is really an array (not a pointer) and which alignment \n \t   can be forced. This restriction will be relaxed.  */\n@@ -5136,6 +4869,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  int nvuses, nv_may_defs, nv_must_defs;\n \t  tree memref = NULL;\n \t  tree symbl;\n+\t  tree scalar_type, vectype;\n \n \t  /* Assumption: there exists a data-ref in stmt, if and only if \n              it has vuses/vdefs.  */\n@@ -5179,13 +4913,26 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      datarefs = &(LOOP_VINFO_DATAREF_WRITES (loop_vinfo));\n \t      is_read = false;\n \t    }\n-\n+\t  \n+\t  scalar_type = TREE_TYPE (memref);\n+\t  vectype = get_vectype_for_scalar_type (scalar_type);\n+\t  if (!vectype)\n+\t    {\n+\t      if (vect_debug_details (NULL))\n+\t\t{\n+\t\t  fprintf (dump_file, \"no vectype for stmt: \");\n+\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" scalar_type: \");\n+\t\t  print_generic_expr (dump_file, scalar_type, TDF_DETAILS);\n+\t\t}\n+\t      /* It is not possible to vectorize this data reference.  */\n+\t      return false;\n+\t    }\n \t  /* Analyze MEMREF. If it is of a supported form, build data_reference\n-\t     struct for it (DR) and find the relevant symbol for aliasing \n-\t     purposes.  */\n+\t     struct for it (DR) and find memtag for aliasing purposes.  */\n \t  dr = NULL;\n \t  symbl = vect_get_memtag_and_dr (memref, stmt, is_read, loop_vinfo, \n-\t\t\t\t\t &dr);\n+\t\t\t\t\t  vectype, &dr);\n \t  if (!symbl)\n \t    {\n \t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n@@ -5196,6 +4943,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      return false;\n \t    }\n \t  STMT_VINFO_MEMTAG (stmt_info) = symbl;\n+\t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n \t  STMT_VINFO_DATA_REF (stmt_info) = dr;\n \t}"}]}