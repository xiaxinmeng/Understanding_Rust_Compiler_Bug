{"sha": "5af1e827bbb624eb28f80d2c5e0da46185af3708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmMWU4MjdiYmI2MjRlYjI4ZjgwZDJjNWUwZGE0NjE4NWFmMzcwOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-27T10:03:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-27T12:16:35Z"}, "message": "Avoid uniform lane BB vectorization\n\nThis makes sure to use splats early when facing uniform internal\noperands in BB SLP discovery rather than relying on the late\nheuristincs re-building nodes from scratch.\n\n2020-10-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_build_slp_tree_2): When vectorizing\n\tBBs splat uniform operands and stop SLP discovery.\n\n\t* gcc.target/i386/pr95866-1.c: Adjust.", "tree": {"sha": "14498c1e161ef861cfe7bc4b6f7e72e1eb3c39e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14498c1e161ef861cfe7bc4b6f7e72e1eb3c39e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af1e827bbb624eb28f80d2c5e0da46185af3708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af1e827bbb624eb28f80d2c5e0da46185af3708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af1e827bbb624eb28f80d2c5e0da46185af3708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af1e827bbb624eb28f80d2c5e0da46185af3708/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e6e941db7ced1fb967beed5f15b69b4d56bce61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6e941db7ced1fb967beed5f15b69b4d56bce61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6e941db7ced1fb967beed5f15b69b4d56bce61"}], "stats": {"total": 24, "additions": 23, "deletions": 1}, "files": [{"sha": "553d415eed82c238ba318d91ec40c72585b6e8a1", "filename": "gcc/testsuite/gcc.target/i386/pr95866-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af1e827bbb624eb28f80d2c5e0da46185af3708/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af1e827bbb624eb28f80d2c5e0da46185af3708/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c?ref=5af1e827bbb624eb28f80d2c5e0da46185af3708", "patch": "@@ -13,6 +13,6 @@ void foo(int i)\n \n /* We should not use vector operations for i + 1 and (i + 1) & 31 but\n    instead use { j, j, j, j }.  */ \n-/* { dg-final { scan-tree-dump-times \"Building parent vector operands from scalars\" 2 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Using a splat of the uniform operand\" 2 \"slp2\" } } */\n /* { dg-final { scan-tree-dump-not \" = \\{i_\" \"slp2\" } } */\n /* { dg-final { scan-tree-dump-times \" = \\{j_\" 1 \"slp2\" } } */"}, {"sha": "85865dae1ab0d00046e77284bbb0328313ef1884", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af1e827bbb624eb28f80d2c5e0da46185af3708/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af1e827bbb624eb28f80d2c5e0da46185af3708/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=5af1e827bbb624eb28f80d2c5e0da46185af3708", "patch": "@@ -1486,6 +1486,28 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  continue;\n \t}\n \n+      if (is_a <bb_vec_info> (vinfo)\n+\t  && oprnd_info->first_dt == vect_internal_def)\n+\t{\n+\t  /* For BB vectorization, if all defs are the same do not\n+\t     bother to continue the build along the single-lane\n+\t     graph but use a splat of the scalar value.  */\n+\t  stmt_vec_info first_def = oprnd_info->def_stmts[0];\n+\t  for (j = 1; j < group_size; ++j)\n+\t    if (oprnd_info->def_stmts[j] != first_def)\n+\t      break;\n+\t  if (j == group_size\n+\t      /* But avoid doing this for loads where we may be\n+\t\t able to CSE things.  */\n+\t      && !gimple_vuse (first_def->stmt))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Using a splat of the uniform operand\\n\");\n+\t      oprnd_info->first_dt = vect_external_def;\n+\t    }\n+\t}\n+\n       if (oprnd_info->first_dt != vect_internal_def\n \t  && oprnd_info->first_dt != vect_reduction_def\n \t  && oprnd_info->first_dt != vect_induction_def)"}]}