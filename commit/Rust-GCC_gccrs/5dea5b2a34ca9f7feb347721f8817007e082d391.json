{"sha": "5dea5b2a34ca9f7feb347721f8817007e082d391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlYTViMmEzNGNhOWY3ZmViMzQ3NzIxZjg4MTcwMDdlMDgyZDM5MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-20T19:07:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-20T19:07:41Z"}, "message": "Remove TARGET_VECTORIZE_BUILTIN_VEC_PERM.\n\nFrom-SVN: r180266", "tree": {"sha": "aaff514b00f4b911357d6c3e26711c9e1af2ef70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaff514b00f4b911357d6c3e26711c9e1af2ef70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dea5b2a34ca9f7feb347721f8817007e082d391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dea5b2a34ca9f7feb347721f8817007e082d391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dea5b2a34ca9f7feb347721f8817007e082d391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dea5b2a34ca9f7feb347721f8817007e082d391/comments", "author": null, "committer": null, "parents": [{"sha": "0019028b0b585fddd080e626e33c3c4420fbd486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0019028b0b585fddd080e626e33c3c4420fbd486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0019028b0b585fddd080e626e33c3c4420fbd486"}], "stats": {"total": 506, "additions": 75, "deletions": 431}, "files": [{"sha": "f4e16e19157aa901d7b7e3a7e1fdaa6c68281704", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -1,3 +1,25 @@\n+2011-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.def (builtin_vec_perm): Remove.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_VEC_PERM): Remove.\n+\n+\t* config/i386/i386.c (ix86_expand_vec_perm_builtin): Remove.\n+\t(IX86_BUILTIN_VEC_PERM_*): Remove.\n+\t(bdesc_args): Remove vec_perm builtins\n+\t(ix86_expand_builtin): Likewise.\n+\t(ix86_expand_vec_perm_const_1): Rename from\n+\tix86_expand_vec_perm_builtin_1.\n+\t(extract_vec_perm_cst): Merge into...\n+\t(ix86_vectorize_vec_perm_const_ok): ... here.  Rename from\n+\tix86_vectorize_builtin_vec_perm_ok.\n+\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Remove.\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vec_perm): Remove.\n+\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Remove.\n+\n+\t* config/spu/spu.c (spu_builtin_vec_perm): Remove.\n+\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Remove.\n+\n 2011-10-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/47989\n@@ -16,8 +38,8 @@\n \n \tPR other/50659\n \t* doc/cppopts.texi: Use @smallexample/@end smallexample in\n-    \tdocumentation for -fdebug-cpp instead of @quotation/@end quotation\n-    \tthat is not supported by contrib/texi2pod.pl.\n+\tdocumentation for -fdebug-cpp instead of @quotation/@end quotation\n+\tthat is not supported by contrib/texi2pod.pl.\n \n 2011-10-19  Jan Hubicka  <jh@suse.cz>\n \n@@ -36,8 +58,8 @@\n \n 2011-10-20  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n-       PR target/50106\n-       * config/arm/arm.c (thumb_unexpanded_epilogue): Handle return\n+\tPR target/50106\n+\t* config/arm/arm.c (thumb_unexpanded_epilogue): Handle return\n \treg size from 1-3.\n \n 2011-10-20  Richard Guenther  <rguenther@suse.de>"}, {"sha": "775035627f868a421adcad3179c05b12568ae878", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 292, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -2509,7 +2509,6 @@ static void ix86_compute_frame_layout (struct ix86_frame *);\n static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n static void ix86_add_new_builtins (HOST_WIDE_INT);\n-static rtx ix86_expand_vec_perm_builtin (tree);\n static tree ix86_canonical_va_list_type (tree);\n static void predict_jump (int);\n static unsigned int split_stack_prologue_scratch_regno (void);\n@@ -25058,19 +25057,6 @@ enum ix86_builtins\n \n   IX86_BUILTIN_CVTUDQ2PS,\n \n-  IX86_BUILTIN_VEC_PERM_V2DF,\n-  IX86_BUILTIN_VEC_PERM_V4SF,\n-  IX86_BUILTIN_VEC_PERM_V2DI,\n-  IX86_BUILTIN_VEC_PERM_V4SI,\n-  IX86_BUILTIN_VEC_PERM_V8HI,\n-  IX86_BUILTIN_VEC_PERM_V16QI,\n-  IX86_BUILTIN_VEC_PERM_V2DI_U,\n-  IX86_BUILTIN_VEC_PERM_V4SI_U,\n-  IX86_BUILTIN_VEC_PERM_V8HI_U,\n-  IX86_BUILTIN_VEC_PERM_V16QI_U,\n-  IX86_BUILTIN_VEC_PERM_V4DF,\n-  IX86_BUILTIN_VEC_PERM_V8SF,\n-\n   /* FMA4 instructions.  */\n   IX86_BUILTIN_VFMADDSS,\n   IX86_BUILTIN_VFMADDSD,\n@@ -25779,19 +25765,6 @@ static const struct builtin_description bdesc_args[] =\n   /* SSE2 */\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_shufpd, \"__builtin_ia32_shufpd\", IX86_BUILTIN_SHUFPD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n \n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2df\", IX86_BUILTIN_VEC_PERM_V2DF, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_V2DI },\n-  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4sf\", IX86_BUILTIN_VEC_PERM_V4SF, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2di\", IX86_BUILTIN_VEC_PERM_V2DI, UNKNOWN, (int) V2DI_FTYPE_V2DI_V2DI_V2DI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4si\", IX86_BUILTIN_VEC_PERM_V4SI, UNKNOWN, (int) V4SI_FTYPE_V4SI_V4SI_V4SI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v8hi\", IX86_BUILTIN_VEC_PERM_V8HI, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI_V8HI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v16qi\", IX86_BUILTIN_VEC_PERM_V16QI, UNKNOWN, (int) V16QI_FTYPE_V16QI_V16QI_V16QI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2di_u\", IX86_BUILTIN_VEC_PERM_V2DI_U, UNKNOWN, (int) V2UDI_FTYPE_V2UDI_V2UDI_V2UDI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4si_u\", IX86_BUILTIN_VEC_PERM_V4SI_U, UNKNOWN, (int) V4USI_FTYPE_V4USI_V4USI_V4USI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v8hi_u\", IX86_BUILTIN_VEC_PERM_V8HI_U, UNKNOWN, (int) V8UHI_FTYPE_V8UHI_V8UHI_V8UHI },\n-  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v16qi_u\", IX86_BUILTIN_VEC_PERM_V16QI_U, UNKNOWN, (int) V16UQI_FTYPE_V16UQI_V16UQI_V16UQI },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4df\", IX86_BUILTIN_VEC_PERM_V4DF, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_V4DI },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v8sf\", IX86_BUILTIN_VEC_PERM_V8SF, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_V8SI },\n-\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_movmskpd, \"__builtin_ia32_movmskpd\", IX86_BUILTIN_MOVMSKPD, UNKNOWN, (int) INT_FTYPE_V2DF  },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_pmovmskb, \"__builtin_ia32_pmovmskb128\", IX86_BUILTIN_PMOVMSKB128, UNKNOWN, (int) INT_FTYPE_V16QI },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sqrtv2df2, \"__builtin_ia32_sqrtpd\", IX86_BUILTIN_SQRTPD, UNKNOWN, (int) V2DF_FTYPE_V2DF },\n@@ -28700,20 +28673,6 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_VEC_SET_V16QI:\n       return ix86_expand_vec_set_builtin (exp);\n \n-    case IX86_BUILTIN_VEC_PERM_V2DF:\n-    case IX86_BUILTIN_VEC_PERM_V4SF:\n-    case IX86_BUILTIN_VEC_PERM_V2DI:\n-    case IX86_BUILTIN_VEC_PERM_V4SI:\n-    case IX86_BUILTIN_VEC_PERM_V8HI:\n-    case IX86_BUILTIN_VEC_PERM_V16QI:\n-    case IX86_BUILTIN_VEC_PERM_V2DI_U:\n-    case IX86_BUILTIN_VEC_PERM_V4SI_U:\n-    case IX86_BUILTIN_VEC_PERM_V8HI_U:\n-    case IX86_BUILTIN_VEC_PERM_V16QI_U:\n-    case IX86_BUILTIN_VEC_PERM_V4DF:\n-    case IX86_BUILTIN_VEC_PERM_V8SF:\n-      return ix86_expand_vec_perm_builtin (exp);\n-\n     case IX86_BUILTIN_INFQ:\n     case IX86_BUILTIN_HUGE_VALQ:\n       {\n@@ -31930,9 +31889,6 @@ struct expand_vec_perm_d\n \n static bool expand_vec_perm_1 (struct expand_vec_perm_d *d);\n static bool expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d);\n-static int extract_vec_perm_cst (struct expand_vec_perm_d *, tree);\n-static bool ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask);\n-\n \n /* Get a vector mode of the same size as the original but with elements\n    twice as wide.  This is only guaranteed to apply to integral vectors.  */\n@@ -34621,64 +34577,6 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n }\n \n \n-/* Implement targetm.vectorize.builtin_vec_perm.  */\n-\n-static tree\n-ix86_vectorize_builtin_vec_perm (tree vec_type, tree *mask_type)\n-{\n-  tree itype = TREE_TYPE (vec_type);\n-  bool u = TYPE_UNSIGNED (itype);\n-  enum machine_mode vmode = TYPE_MODE (vec_type);\n-  enum ix86_builtins fcode;\n-  bool ok = TARGET_SSE2;\n-\n-  switch (vmode)\n-    {\n-    case V4DFmode:\n-      ok = TARGET_AVX;\n-      fcode = IX86_BUILTIN_VEC_PERM_V4DF;\n-      goto get_di;\n-    case V2DFmode:\n-      fcode = IX86_BUILTIN_VEC_PERM_V2DF;\n-    get_di:\n-      itype = ix86_get_builtin_type (IX86_BT_DI);\n-      break;\n-\n-    case V8SFmode:\n-      ok = TARGET_AVX;\n-      fcode = IX86_BUILTIN_VEC_PERM_V8SF;\n-      goto get_si;\n-    case V4SFmode:\n-      ok = TARGET_SSE;\n-      fcode = IX86_BUILTIN_VEC_PERM_V4SF;\n-    get_si:\n-      itype = ix86_get_builtin_type (IX86_BT_SI);\n-      break;\n-\n-    case V2DImode:\n-      fcode = u ? IX86_BUILTIN_VEC_PERM_V2DI_U : IX86_BUILTIN_VEC_PERM_V2DI;\n-      break;\n-    case V4SImode:\n-      fcode = u ? IX86_BUILTIN_VEC_PERM_V4SI_U : IX86_BUILTIN_VEC_PERM_V4SI;\n-      break;\n-    case V8HImode:\n-      fcode = u ? IX86_BUILTIN_VEC_PERM_V8HI_U : IX86_BUILTIN_VEC_PERM_V8HI;\n-      break;\n-    case V16QImode:\n-      fcode = u ? IX86_BUILTIN_VEC_PERM_V16QI_U : IX86_BUILTIN_VEC_PERM_V16QI;\n-      break;\n-    default:\n-      ok = false;\n-      break;\n-    }\n-\n-  if (!ok)\n-    return NULL_TREE;\n-\n-  *mask_type = itype;\n-  return ix86_builtins[(int) fcode];\n-}\n-\n /* Return a vector mode with twice as many elements as VMODE.  */\n /* ??? Consider moving this to a table generated by genmodes.c.  */\n \n@@ -36395,12 +36293,12 @@ expand_vec_perm_vpshufb4_vpermq2 (struct expand_vec_perm_d *d)\n   return true;\n }\n \n-/* The guts of ix86_expand_vec_perm_builtin, also used by the ok hook.\n+/* The guts of ix86_expand_vec_perm_const, also used by the ok hook.\n    With all of the interface bits taken care of, perform the expansion\n    in D and return true on success.  */\n \n static bool\n-ix86_expand_vec_perm_builtin_1 (struct expand_vec_perm_d *d)\n+ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n {\n   /* Try a single instruction expansion.  */\n   if (expand_vec_perm_1 (d))\n@@ -36459,179 +36357,6 @@ ix86_expand_vec_perm_builtin_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n-/* Extract the values from the vector CST into the permutation array in D.\n-   Return 0 on error, 1 if all values from the permutation come from the\n-   first vector, 2 if all values from the second vector, and 3 otherwise.  */\n-\n-static int\n-extract_vec_perm_cst (struct expand_vec_perm_d *d, tree cst)\n-{\n-  tree list = TREE_VECTOR_CST_ELTS (cst);\n-  unsigned i, nelt = d->nelt;\n-  int ret = 0;\n-\n-  for (i = 0; i < nelt; ++i, list = TREE_CHAIN (list))\n-    {\n-      unsigned HOST_WIDE_INT e;\n-\n-      if (!host_integerp (TREE_VALUE (list), 1))\n-\treturn 0;\n-      e = tree_low_cst (TREE_VALUE (list), 1);\n-      if (e >= 2 * nelt)\n-\treturn 0;\n-\n-      ret |= (e < nelt ? 1 : 2);\n-      d->perm[i] = e;\n-    }\n-  gcc_assert (list == NULL);\n-\n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (ret == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d->perm[i] -= nelt;\n-\n-  return ret;\n-}\n-\n-static rtx\n-ix86_expand_vec_perm_builtin (tree exp)\n-{\n-  struct expand_vec_perm_d d;\n-  tree arg0, arg1, arg2;\n-  bool maybe_retry = false;\n-\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  arg1 = CALL_EXPR_ARG (exp, 1);\n-  arg2 = CALL_EXPR_ARG (exp, 2);\n-\n-  d.vmode = TYPE_MODE (TREE_TYPE (arg0));\n-  d.nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = false;\n-  gcc_assert (VECTOR_MODE_P (d.vmode));\n-\n-  if (TREE_CODE (arg2) != VECTOR_CST)\n-    {\n-      error_at (EXPR_LOCATION (exp),\n-\t\t\"vector permutation requires vector constant\");\n-      goto exit_error;\n-    }\n-\n-  switch (extract_vec_perm_cst (&d, arg2))\n-    {\n-    default:\n-      gcc_unreachable();\n-\n-    case 0:\n-      error_at (EXPR_LOCATION (exp), \"invalid vector permutation constant\");\n-      goto exit_error;\n-\n-    case 3:\n-      if (!operand_equal_p (arg0, arg1, 0))\n-\t{\n-\t  d.op0 = expand_expr (arg0, NULL_RTX, d.vmode, EXPAND_NORMAL);\n-\t  d.op0 = force_reg (d.vmode, d.op0);\n-\t  d.op1 = expand_expr (arg1, NULL_RTX, d.vmode, EXPAND_NORMAL);\n-\t  d.op1 = force_reg (d.vmode, d.op1);\n-\t  break;\n-\t}\n-\n-      /* The elements of PERM do not suggest that only the first operand\n-\t is used, but both operands are identical.  Allow easier matching\n-\t of the permutation by folding the permutation into the single\n-\t input vector.  */\n-      {\n-\tunsigned i, nelt = d.nelt;\n-\tfor (i = 0; i < nelt; ++i)\n-\t  if (d.perm[i] >= nelt)\n-\t    d.perm[i] -= nelt;\n-\tmaybe_retry = true;\n-      }\n-      /* FALLTHRU */\n-\n-    case 1:\n-      d.op0 = expand_expr (arg0, NULL_RTX, d.vmode, EXPAND_NORMAL);\n-      d.op0 = force_reg (d.vmode, d.op0);\n-      d.op1 = d.op0;\n-      break;\n-\n-    case 2:\n-      d.op0 = expand_expr (arg1, NULL_RTX, d.vmode, EXPAND_NORMAL);\n-      d.op0 = force_reg (d.vmode, d.op0);\n-      d.op1 = d.op0;\n-      break;\n-    }\n-\n-  d.target = gen_reg_rtx (d.vmode);\n-  if (ix86_expand_vec_perm_builtin_1 (&d))\n-    return d.target;\n-\n-  /* If the mask says both arguments are needed, but they are the same,\n-     the above tried to expand with d.op0 == d.op1.  If that didn't work,\n-     retry with d.op0 != d.op1 as that is what testing has been done with.  */\n-  if (maybe_retry)\n-    {\n-      rtx seq;\n-      bool ok;\n-\n-      extract_vec_perm_cst (&d, arg2);\n-      d.op1 = gen_reg_rtx (d.vmode);\n-      start_sequence ();\n-      ok = ix86_expand_vec_perm_builtin_1 (&d);\n-      seq = get_insns ();\n-      end_sequence ();\n-      if (ok)\n-\t{\n-\t  emit_move_insn (d.op1, d.op0);\n-\t  emit_insn (seq);\n-\t  return d.target;\n-\t}\n-    }\n-\n-  /* For compiler generated permutations, we should never got here, because\n-     the compiler should also be checking the ok hook.  But since this is a\n-     builtin the user has access too, so don't abort.  */\n-  switch (d.nelt)\n-    {\n-    case 2:\n-      sorry (\"vector permutation (%d %d)\", d.perm[0], d.perm[1]);\n-      break;\n-    case 4:\n-      sorry (\"vector permutation (%d %d %d %d)\",\n-\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3]);\n-      break;\n-    case 8:\n-      sorry (\"vector permutation (%d %d %d %d %d %d %d %d)\",\n-\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3],\n-\t     d.perm[4], d.perm[5], d.perm[6], d.perm[7]);\n-      break;\n-    case 16:\n-      sorry (\"vector permutation \"\n-\t     \"(%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d)\",\n-\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3],\n-\t     d.perm[4], d.perm[5], d.perm[6], d.perm[7],\n-\t     d.perm[8], d.perm[9], d.perm[10], d.perm[11],\n-\t     d.perm[12], d.perm[13], d.perm[14], d.perm[15]);\n-      break;\n-    case 32:\n-      sorry (\"vector permutation \"\n-\t     \"(%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d \"\n-\t     \"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d)\",\n-\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3],\n-\t     d.perm[4], d.perm[5], d.perm[6], d.perm[7],\n-\t     d.perm[8], d.perm[9], d.perm[10], d.perm[11],\n-\t     d.perm[12], d.perm[13], d.perm[14], d.perm[15],\n-\t     d.perm[16], d.perm[17], d.perm[18], d.perm[19],\n-\t     d.perm[20], d.perm[21], d.perm[22], d.perm[23],\n-\t     d.perm[24], d.perm[25], d.perm[26], d.perm[27],\n-\t     d.perm[28], d.perm[29], d.perm[30], d.perm[31]);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n- exit_error:\n-  return CONST0_RTX (d.vmode);\n-}\n-\n bool\n ix86_expand_vec_perm_const (rtx operands[4])\n {\n@@ -36693,7 +36418,7 @@ ix86_expand_vec_perm_const (rtx operands[4])\n       break;\n     }\n \n-  if (ix86_expand_vec_perm_builtin_1 (&d))\n+  if (ix86_expand_vec_perm_const_1 (&d))\n     return true;\n \n   /* If the mask says both arguments are needed, but they are the same,\n@@ -36707,7 +36432,7 @@ ix86_expand_vec_perm_const (rtx operands[4])\n       memcpy (d.perm, perm, sizeof (perm));\n       d.op1 = gen_reg_rtx (d.vmode);\n       start_sequence ();\n-      ok = ix86_expand_vec_perm_builtin_1 (&d);\n+      ok = ix86_expand_vec_perm_const_1 (&d);\n       seq = get_insns ();\n       end_sequence ();\n       if (ok)\n@@ -36724,14 +36449,15 @@ ix86_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.builtin_vec_perm_ok.  */\n \n static bool\n-ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n+ix86_vectorize_vec_perm_const_ok (tree vec_type, tree mask)\n {\n   struct expand_vec_perm_d d;\n-  int vec_mask;\n+  unsigned int i, nelt, which;\n   bool ret, one_vec;\n+  tree list;\n \n   d.vmode = TYPE_MODE (vec_type);\n-  d.nelt = GET_MODE_NUNITS (d.vmode);\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = true;\n \n   /* Given sufficient ISA support we can just return true here\n@@ -36749,13 +36475,29 @@ ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n \treturn true;\n     }\n \n-  vec_mask = extract_vec_perm_cst (&d, mask);\n+  /* Extract the values from the vector CST into the permutation\n+     array in D.  */\n+  list = TREE_VECTOR_CST_ELTS (mask);\n+  for (i = which = 0; i < nelt; ++i, list = TREE_CHAIN (list))\n+    {\n+      unsigned HOST_WIDE_INT e;\n \n-  /* Check whether the mask can be applied to the vector type.  */\n-  if (vec_mask < 0 || vec_mask > 3)\n-    return false;\n+      gcc_checking_assert (host_integerp (TREE_VALUE (list), 1));\n+      e = tree_low_cst (TREE_VALUE (list), 1);\n+      gcc_assert (e < 2 * nelt);\n+\n+      which |= (e < nelt ? 1 : 2);\n+      d.perm[i] = e;\n+    }\n+  gcc_assert (list == NULL);\n \n-  one_vec = (vec_mask != 3);\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to the vector type.  */\n+  one_vec = (which != 3);\n \n   /* Implementable with shufps or pshufd.  */\n   if (one_vec && (d.vmode == V4SFmode || d.vmode == V4SImode))\n@@ -36769,7 +36511,7 @@ ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n     d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n \n   start_sequence ();\n-  ret = ix86_expand_vec_perm_builtin_1 (&d);\n+  ret = ix86_expand_vec_perm_const_1 (&d);\n   end_sequence ();\n \n   return ret;\n@@ -38137,12 +37879,9 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n   ix86_builtin_vectorization_cost\n-#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n-#define TARGET_VECTORIZE_BUILTIN_VEC_PERM \\\n-  ix86_vectorize_builtin_vec_perm\n #undef TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK \\\n-  ix86_vectorize_builtin_vec_perm_ok\n+  ix86_vectorize_vec_perm_const_ok\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n   ix86_preferred_simd_mode"}, {"sha": "80833c4ee89ec5d59204090a165d7303850cb6e9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -988,7 +988,6 @@ static tree rs6000_builtin_mask_for_load (void);\n static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n static tree rs6000_builtin_conversion (unsigned int, tree, tree);\n-static tree rs6000_builtin_vec_perm (tree, tree *);\n static bool rs6000_builtin_support_vector_misalignment (enum\n \t\t\t\t\t\t\tmachine_mode,\n \t\t\t\t\t\t\tconst_tree,\n@@ -1407,8 +1406,6 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD rs6000_builtin_mul_widen_odd\n #undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n #define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n-#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n-#define TARGET_VECTORIZE_BUILTIN_VEC_PERM rs6000_builtin_vec_perm\n #undef TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n #define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\t\t\\\n   rs6000_builtin_support_vector_misalignment\n@@ -3475,65 +3472,6 @@ rs6000_builtin_support_vector_misalignment (enum machine_mode mode,\n   return false;\n }\n \n-/* Implement targetm.vectorize.builtin_vec_perm.  */\n-tree\n-rs6000_builtin_vec_perm (tree type, tree *mask_element_type)\n-{\n-  tree inner_type = TREE_TYPE (type);\n-  bool uns_p = TYPE_UNSIGNED (inner_type);\n-  tree d;\n-\n-  *mask_element_type = unsigned_char_type_node;\n-\n-  switch (TYPE_MODE (type))\n-    {\n-    case V16QImode:\n-      d = (uns_p\n-\t   ? rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_16QI_UNS]\n-\t   : rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_16QI]);\n-      break;\n-\n-    case V8HImode:\n-      d = (uns_p\n-\t   ? rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_8HI_UNS]\n-\t   : rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_8HI]);\n-      break;\n-\n-    case V4SImode:\n-      d = (uns_p\n-\t   ? rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_4SI_UNS]\n-\t   : rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_4SI]);\n-      break;\n-\n-    case V4SFmode:\n-      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_4SF];\n-      break;\n-\n-    case V2DFmode:\n-      if (!TARGET_ALLOW_DF_PERMUTE)\n-\treturn NULL_TREE;\n-\n-      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_2DF];\n-      break;\n-\n-    case V2DImode:\n-      if (!TARGET_ALLOW_DF_PERMUTE)\n-\treturn NULL_TREE;\n-\n-      d = (uns_p\n-\t   ? rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_2DI_UNS]\n-\t   : rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_2DI]);\n-      break;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-\n-  gcc_assert (d);\n-  return d;\n-}\n-\n-\n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int\n rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,"}, {"sha": "0bab5cfb692cebf668387dd5e03caee441e373ba", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -218,7 +218,6 @@ static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n static int spu_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, int);\n static bool spu_vector_alignment_reachable (const_tree, bool);\n-static tree spu_builtin_vec_perm (tree, tree *);\n static enum machine_mode spu_addr_space_pointer_mode (addr_space_t);\n static enum machine_mode spu_addr_space_address_mode (addr_space_t);\n static bool spu_addr_space_subset_p (addr_space_t, addr_space_t);\n@@ -449,9 +448,6 @@ static void spu_setup_incoming_varargs (cumulative_args_t cum,\n #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n \n-#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n-#define TARGET_VECTORIZE_BUILTIN_VEC_PERM spu_builtin_vec_perm\n-\n #undef TARGET_LIBGCC_CMP_RETURN_MODE\n #define TARGET_LIBGCC_CMP_RETURN_MODE spu_libgcc_cmp_return_mode\n \n@@ -6958,49 +6954,6 @@ spu_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_packed\n   return true;\n }\n \n-/* Implement targetm.vectorize.builtin_vec_perm.  */\n-tree\n-spu_builtin_vec_perm (tree type, tree *mask_element_type)\n-{\n-  *mask_element_type = unsigned_char_type_node;\n-\n-  switch (TYPE_MODE (type))\n-    {\n-    case V16QImode:\n-      if (TYPE_UNSIGNED (type))\n-        return spu_builtin_decls[SPU_SHUFFLE_0];\n-      else\n-        return spu_builtin_decls[SPU_SHUFFLE_1];\n-\n-    case V8HImode:\n-      if (TYPE_UNSIGNED (type))\n-        return spu_builtin_decls[SPU_SHUFFLE_2];\n-      else\n-        return spu_builtin_decls[SPU_SHUFFLE_3];\n-\n-    case V4SImode:\n-      if (TYPE_UNSIGNED (type))\n-        return spu_builtin_decls[SPU_SHUFFLE_4];\n-      else\n-        return spu_builtin_decls[SPU_SHUFFLE_5];\n-\n-    case V2DImode:\n-      if (TYPE_UNSIGNED (type))\n-        return spu_builtin_decls[SPU_SHUFFLE_6];\n-      else\n-        return spu_builtin_decls[SPU_SHUFFLE_7];\n-\n-    case V4SFmode:\n-      return spu_builtin_decls[SPU_SHUFFLE_8];\n-\n-    case V2DFmode:\n-      return spu_builtin_decls[SPU_SHUFFLE_9];\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-}\n-\n /* Return the appropriate mode for a named address pointer.  */\n static enum machine_mode\n spu_addr_space_pointer_mode (addr_space_t addrspace)"}, {"sha": "c52753a10b53cacf1af764a2e06421e8f24ab413", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -5711,12 +5711,8 @@ misalignment value (@var{misalign}).\n Return true if vector alignment is reachable (by peeling N iterations) for the given type.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VEC_PERM (tree @var{type}, tree *@var{mask_element_type})\n-Target builtin that implements vector permute.\n-@end deftypefn\n-\n @deftypefn {Target Hook} bool TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK (tree @var{vec_type}, tree @var{mask})\n-Return true if a vector created for @code{builtin_vec_perm} is valid.\n+Return true if a vector created for @code{vec_perm_const} is valid.\n @end deftypefn\n \n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_CONVERSION (unsigned @var{code}, tree @var{dest_type}, tree @var{src_type})"}, {"sha": "22e82ee8d8b42e892ce705b3f920d1fa9fd37a07", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -5649,12 +5649,8 @@ misalignment value (@var{misalign}).\n Return true if vector alignment is reachable (by peeling N iterations) for the given type.\n @end deftypefn\n \n-@hook TARGET_VECTORIZE_BUILTIN_VEC_PERM\n-Target builtin that implements vector permute.\n-@end deftypefn\n-\n @hook TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK\n-Return true if a vector created for @code{builtin_vec_perm} is valid.\n+Return true if a vector created for @code{vec_perm_const} is valid.\n @end deftypefn\n \n @hook TARGET_VECTORIZE_BUILTIN_CONVERSION"}, {"sha": "c9d6067297345655917c11a7f1fea90c2d808662", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -985,12 +985,6 @@ DEFHOOK\n  bool, (const_tree type, bool is_packed),\n  default_builtin_vector_alignment_reachable)\n \n-/* Target builtin that implements vector permute.  */\n-DEFHOOK\n-(builtin_vec_perm,\n- \"\",\n- tree, (tree type, tree *mask_element_type), NULL)\n-\n /* Return true if a vector created for builtin_vec_perm is valid.  */\n DEFHOOK\n (builtin_vec_perm_ok,"}, {"sha": "e8a6fca2c7b8bb2e153ef4c9d882f41bca481ab7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -1,3 +1,10 @@\n+2011-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.target/i386/vperm-v2df.c, gcc.target/i386/vperm-v2di.c,\n+\tgcc.target/i386/vperm-v4sf-1.c, gcc.target/i386/vperm-v4sf-2.c, \n+\tgcc.target/i386/vperm-v4si-1.c, gcc.target/i386/vperm-v4si-2.c:\n+\tUse __builtin_shuffle.\n+\n 2011-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/50514\n@@ -12,12 +19,11 @@\n \n \t* gfortran.dg/format_string.f: New test.\n \n-\n 2011-10-20  Uros Bizjak  <ubizjak@gmail.com>\n \n-       * gcc.dg/ipa/ipa-sra-2.c: Add dg-require-effective-target\n-       non_strict_align.\n-       * gcc.dg/ipa/ipa-sra-6.c: Ditto.\n+\t* gcc.dg/ipa/ipa-sra-2.c: Add dg-require-effective-target\n+\tnon_strict_align.\n+\t* gcc.dg/ipa/ipa-sra-6.c: Ditto.\n \n 2011-10-20  Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "5aefc05f47452c43d9da046b3ce2a1df79f4e832", "filename": "gcc/testsuite/gcc.target/i386/vperm-v2df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -16,7 +16,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1) \\\n-  b.v = __builtin_ia32_vec_perm_v2df (i[0].v, i[1].v, (IV){E0, E1}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   __asm__(\"\" : : : \"memory\"); \\"}, {"sha": "282cce6e9b9d78fcec36e64e9b1521ddc99258ce", "filename": "gcc/testsuite/gcc.target/i386/vperm-v2di.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -16,7 +16,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1) \\\n-  b.v = __builtin_ia32_vec_perm_v2di (i[0].v, i[1].v, (IV){E0, E1}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   __asm__(\"\" : : : \"memory\"); \\"}, {"sha": "f16c34bc2bc74bef0d77a7092ad6563875d7c6fa", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4sf-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -16,7 +16,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1, E2, E3) \\\n-  b.v = __builtin_ia32_vec_perm_v4sf (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   c.s[2] = i[0].s[E2]; \\"}, {"sha": "12a4623700b95774bbae66aa3189fbe45a3534a8", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4sf-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -15,7 +15,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1, E2, E3) \\\n-  b.v = __builtin_ia32_vec_perm_v4sf (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   c.s[2] = i[0].s[E2]; \\"}, {"sha": "4667f9556bfc65b27b4cc8c6203ca4e388015989", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4si-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -16,7 +16,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1, E2, E3) \\\n-  b.v = __builtin_ia32_vec_perm_v4si (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   c.s[2] = i[0].s[E2]; \\"}, {"sha": "9304345559df0f77bdf4744ed29350ff65ebcecb", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4si-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dea5b2a34ca9f7feb347721f8817007e082d391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c?ref=5dea5b2a34ca9f7feb347721f8817007e082d391", "patch": "@@ -15,7 +15,7 @@ extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n #define assert(T) ((T) || (__builtin_trap (), 0))\n \n #define TEST(E0, E1, E2, E3) \\\n-  b.v = __builtin_ia32_vec_perm_v4si (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n   c.s[0] = i[0].s[E0]; \\\n   c.s[1] = i[0].s[E1]; \\\n   c.s[2] = i[0].s[E2]; \\"}]}