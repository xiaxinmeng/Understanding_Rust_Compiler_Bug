{"sha": "d2d3604c74a30cebd485537b698dc89fcdd17709", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkMzYwNGM3NGEzMGNlYmQ0ODU1MzdiNjk4ZGM4OWZjZGQxNzcwOQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2005-03-18T11:48:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:48:35Z"}, "message": "exp_ch3.adb (Check_Attr): New subprogram.\n\n2005-03-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch3.adb (Check_Attr): New subprogram.\n\t(Check_Stream_Attribute): Move the code for 13.13.2(9/1) enforcement\n\tinto a new Check_Attr subprogram, in order to provide a more\n\texplanatory error message (including the name of the missing attribute).\n\t(Stream_Operation_OK): Renamed from Stream_Operations_OK. This\n\tsubprogram determines whether a default implementation exists for a\n\tgiven stream attribute.\n\t(Make_Predefined_Primitive_Specs, Predefined_Primitive_Bodies):\n\tDetermine whether to generate a default implementation for each stream\n\tattribute separately, as this depends on the specific attribute.\n\n\t* exp_strm.adb (Make_Field_Attribute): For the case of an illegal\n\tlimited extension where a stream attribute is missing for a limited\n\tcomponent (which will have been flagged in Exp_Ch3.Sem_Attr), do not\n\tgenerate a bogus reference to the missing attribute to prevent\n\tcascaded errors. Instead, generate a null statement.\n\n\t* sem_attr.adb (Check_Stream_Attribute): A stream attribute is\n\tavailable for a limited type if it has been specified for an ancestor\n\tof the type.\n\nFrom-SVN: r96666", "tree": {"sha": "d59347be747a5b2ef697914ddc0433ddb62ab540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d59347be747a5b2ef697914ddc0433ddb62ab540"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2d3604c74a30cebd485537b698dc89fcdd17709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d3604c74a30cebd485537b698dc89fcdd17709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d3604c74a30cebd485537b698dc89fcdd17709", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d3604c74a30cebd485537b698dc89fcdd17709/comments", "author": null, "committer": null, "parents": [{"sha": "2b599687903bc76b54fb4635116ba4a9bc821a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b599687903bc76b54fb4635116ba4a9bc821a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b599687903bc76b54fb4635116ba4a9bc821a34"}], "stats": {"total": 196, "additions": 134, "deletions": 62}, "files": [{"sha": "9aa83aa51dd658ed92fee4a39f0bf07875549631", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 97, "deletions": 58, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d2d3604c74a30cebd485537b698dc89fcdd17709", "patch": "@@ -285,10 +285,14 @@ package body Exp_Ch3 is\n    --  Freeze entities of all predefined primitive operations. This is needed\n    --  because the bodies of these operations do not normally do any freezeing.\n \n-   function Stream_Operations_OK (Typ : Entity_Id) return Boolean;\n-   --  Check whether stream operations must be emitted for a given type.\n-   --  Various restrictions prevent the generation of these operations, as\n-   --  a useful optimization or for certification purposes.\n+   function Stream_Operation_OK\n+     (Typ       : Entity_Id;\n+      Operation : TSS_Name_Type) return Boolean;\n+   --  Check whether the named stream operation must be emitted for a given\n+   --  type. The rules for inheritance of stream attributes by type extensions\n+   --  are enforced by this function. Furthermore, various restrictions prevent\n+   --  the generation of these operations, as a useful optimization or for\n+   --  certification purposes.\n \n    --------------------------\n    -- Adjust_Discriminants --\n@@ -3012,23 +3016,32 @@ package body Exp_Ch3 is\n       Par_Read  : constant Boolean   := Present (TSS (Par, TSS_Stream_Read));\n       Par_Write : constant Boolean   := Present (TSS (Par, TSS_Stream_Write));\n \n+      procedure Check_Attr (Nam : Name_Id; TSS_Nam : TSS_Name_Type);\n+      --  Check that Comp has a user-specified Nam stream attribute\n+\n+      procedure Check_Attr (Nam : Name_Id; TSS_Nam : TSS_Name_Type) is\n+      begin\n+         if No (TSS (Base_Type (Etype (Comp)), TSS_Nam)) then\n+            Error_Msg_Name_1 := Nam;\n+            Error_Msg_N\n+              (\"|component& in limited extension must have% attribute\", Comp);\n+         end if;\n+      end Check_Attr;\n+\n    begin\n       if Par_Read or else Par_Write then\n          Comp := First_Component (Typ);\n          while Present (Comp) loop\n             if Comes_From_Source (Comp)\n-              and then  Original_Record_Component (Comp) = Comp\n+              and then Original_Record_Component (Comp) = Comp\n               and then Is_Limited_Type (Etype (Comp))\n             then\n-               if (Par_Read and then\n-                     No (TSS (Base_Type (Etype (Comp)), TSS_Stream_Read)))\n-                 or else\n-                  (Par_Write and then\n-                     No (TSS (Base_Type (Etype (Comp)), TSS_Stream_Write)))\n-               then\n-                  Error_Msg_N\n-                    (\"|component must have Stream attribute\",\n-                       Parent (Comp));\n+               if Par_Read then\n+                  Check_Attr (Name_Read, TSS_Stream_Read);\n+               end if;\n+\n+               if Par_Write then\n+                  Check_Attr (Name_Write, TSS_Stream_Write);\n                end if;\n             end if;\n \n@@ -5543,22 +5556,24 @@ package body Exp_Ch3 is\n \n         Ret_Type => Standard_Integer));\n \n-      --  Specs for dispatching stream attributes. We skip these for limited\n-      --  types, since there is no question of dispatching in the limited case.\n-\n-      --  We also skip these operations if dispatching is not available\n-      --  or if streams are not available (since what's the point?)\n-\n-      if Stream_Operations_OK (Tag_Typ) then\n-         Append_To (Res,\n-           Predef_Stream_Attr_Spec (Loc, Tag_Typ, TSS_Stream_Read));\n-         Append_To (Res,\n-           Predef_Stream_Attr_Spec (Loc, Tag_Typ, TSS_Stream_Write));\n-         Append_To (Res,\n-           Predef_Stream_Attr_Spec (Loc, Tag_Typ, TSS_Stream_Input));\n-         Append_To (Res,\n-           Predef_Stream_Attr_Spec (Loc, Tag_Typ, TSS_Stream_Output));\n-      end if;\n+      --  Specs for dispatching stream attributes.\n+\n+      declare\n+         Stream_Op_TSS_Names :\n+           constant array (Integer range <>) of TSS_Name_Type :=\n+             (TSS_Stream_Read,\n+              TSS_Stream_Write,\n+              TSS_Stream_Input,\n+              TSS_Stream_Output);\n+      begin\n+         for Op in Stream_Op_TSS_Names'Range loop\n+            if Stream_Operation_OK (Tag_Typ, Stream_Op_TSS_Names (Op)) then\n+               Append_To (Res,\n+                  Predef_Stream_Attr_Spec (Loc, Tag_Typ,\n+                    Stream_Op_TSS_Names (Op)));\n+            end if;\n+         end loop;\n+      end;\n \n       --  Spec of \"=\" if expanded if the type is not limited and if a\n       --  user defined \"=\" was not already declared for the non-full\n@@ -6004,32 +6019,38 @@ package body Exp_Ch3 is\n       --  non-limited types (in the limited case there is no dispatching).\n       --  We also skip them if dispatching or finalization are not available.\n \n-      if Stream_Operations_OK (Tag_Typ) then\n-         if No (TSS (Tag_Typ, TSS_Stream_Read)) then\n-            Build_Record_Read_Procedure (Loc, Tag_Typ, Decl, Ent);\n-            Append_To (Res, Decl);\n-         end if;\n+      if Stream_Operation_OK (Tag_Typ, TSS_Stream_Read)\n+        and then No (TSS (Tag_Typ, TSS_Stream_Read))\n+      then\n+         Build_Record_Read_Procedure (Loc, Tag_Typ, Decl, Ent);\n+         Append_To (Res, Decl);\n+      end if;\n \n-         if No (TSS (Tag_Typ, TSS_Stream_Write)) then\n-            Build_Record_Write_Procedure (Loc, Tag_Typ, Decl, Ent);\n-            Append_To (Res, Decl);\n-         end if;\n+      if Stream_Operation_OK (Tag_Typ, TSS_Stream_Write)\n+        and then No (TSS (Tag_Typ, TSS_Stream_Write))\n+      then\n+         Build_Record_Write_Procedure (Loc, Tag_Typ, Decl, Ent);\n+         Append_To (Res, Decl);\n+      end if;\n \n-         --  Skip bodies of _Input and _Output for the abstract case, since\n-         --  the corresponding specs are abstract (see Predef_Spec_Or_Body)\n+      --  Skip bodies of _Input and _Output for the abstract case, since\n+      --  the corresponding specs are abstract (see Predef_Spec_Or_Body)\n \n-         if not Is_Abstract (Tag_Typ) then\n-            if No (TSS (Tag_Typ, TSS_Stream_Input)) then\n-               Build_Record_Or_Elementary_Input_Function\n-                 (Loc, Tag_Typ, Decl, Ent);\n-               Append_To (Res, Decl);\n-            end if;\n+      if not Is_Abstract (Tag_Typ) then\n+         if Stream_Operation_OK (Tag_Typ, TSS_Stream_Input)\n+           and then No (TSS (Tag_Typ, TSS_Stream_Input))\n+         then\n+            Build_Record_Or_Elementary_Input_Function\n+              (Loc, Tag_Typ, Decl, Ent);\n+            Append_To (Res, Decl);\n+         end if;\n \n-            if No (TSS (Tag_Typ, TSS_Stream_Output)) then\n-               Build_Record_Or_Elementary_Output_Procedure\n-                 (Loc, Tag_Typ, Decl, Ent);\n-               Append_To (Res, Decl);\n-            end if;\n+         if Stream_Operation_OK (Tag_Typ, TSS_Stream_Output)\n+           and then No (TSS (Tag_Typ, TSS_Stream_Output))\n+         then\n+            Build_Record_Or_Elementary_Output_Procedure\n+              (Loc, Tag_Typ, Decl, Ent);\n+            Append_To (Res, Decl);\n          end if;\n       end if;\n \n@@ -6216,17 +6237,35 @@ package body Exp_Ch3 is\n       return Res;\n    end Predefined_Primitive_Freeze;\n \n-   --------------------------\n-   -- Stream_Operations_OK --\n-   --------------------------\n+   -------------------------\n+   -- Stream_Operation_OK --\n+   -------------------------\n+\n+   function Stream_Operation_OK\n+     (Typ       : Entity_Id;\n+      Operation : TSS_Name_Type) return Boolean\n+   is\n+      Has_Inheritable_Stream_Attribute : Boolean := False;\n \n-   function Stream_Operations_OK (Typ : Entity_Id) return Boolean is\n    begin\n+      if Is_Limited_Type (Typ)\n+        and then Is_Tagged_Type (Typ)\n+        and then Is_Derived_Type (Typ)\n+      then\n+         --  Special case of a limited type extension: a default implementation\n+         --  of the stream attributes Read and Write exists if the attribute\n+         --  has been specified for an ancestor type.\n+\n+         Has_Inheritable_Stream_Attribute :=\n+           Present (Find_Inherited_TSS (Base_Type (Etype (Typ)), Operation));\n+      end if;\n+\n       return\n-        not Is_Limited_Type (Typ)\n+        not (Is_Limited_Type (Typ)\n+               and then not Has_Inheritable_Stream_Attribute)\n           and then RTE_Available (RE_Tag)\n           and then RTE_Available (RE_Root_Stream_Type)\n           and then not Restriction_Active (No_Dispatch)\n           and then not Restriction_Active (No_Streams);\n-   end Stream_Operations_OK;\n+   end Stream_Operation_OK;\n end Exp_Ch3;"}, {"sha": "c58753484945cf0679d3bd65633d543672285fd2", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=d2d3604c74a30cebd485537b698dc89fcdd17709", "patch": "@@ -26,6 +26,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Exp_Tss;  use Exp_Tss;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -36,7 +37,6 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n-with Exp_Tss;  use Exp_Tss;\n with Uintp;    use Uintp;\n \n package body Exp_Strm is\n@@ -1173,6 +1173,11 @@ package body Exp_Strm is\n       Stms : List_Id;\n       Typt : Entity_Id;\n \n+      In_Limited_Extension : Boolean := False;\n+      --  Set to True while processing the record extension definition\n+      --  for an extension of a limited type (for which an ancestor type\n+      --  has an explicit Nam attribute definition).\n+\n       function Make_Component_List_Attributes (CL : Node_Id) return List_Id;\n       --  Returns a sequence of attributes to process the components that\n       --  are referenced in the given component list.\n@@ -1254,7 +1259,29 @@ package body Exp_Strm is\n       --------------------------\n \n       function Make_Field_Attribute (C : Entity_Id) return Node_Id is\n+         Field_Typ : constant Entity_Id := Stream_Base_Type (Etype (C));\n+\n+         TSS_Names : constant array (Name_Input .. Name_Write) of\n+                       TSS_Name_Type :=\n+                        (Name_Read   => TSS_Stream_Read,\n+                         Name_Write  => TSS_Stream_Write,\n+                         Name_Input  => TSS_Stream_Input,\n+                         Name_Output => TSS_Stream_Output,\n+                         others      => TSS_Null);\n+         pragma Assert (TSS_Names (Nam) /= TSS_Null);\n+\n       begin\n+         if In_Limited_Extension\n+           and then Is_Limited_Type (Field_Typ)\n+           and then No (Find_Inherited_TSS (Field_Typ, TSS_Names (Nam)))\n+         then\n+            --  The declaration is illegal per 13.13.2(9/1), and this is\n+            --  enforced in Exp_Ch3.Check_Stream_Attributes. Keep the\n+            --  caller happy by returning a null statement.\n+\n+            return Make_Null_Statement (Loc);\n+         end if;\n+\n          return\n            Make_Attribute_Reference (Loc,\n              Prefix =>\n@@ -1331,6 +1358,10 @@ package body Exp_Strm is\n \n       if Nkind (Rdef) = N_Derived_Type_Definition then\n          Rdef := Record_Extension_Part (Rdef);\n+\n+         if Is_Limited_Type (Typt) then\n+            In_Limited_Extension := True;\n+         end if;\n       end if;\n \n       if Present (Component_List (Rdef)) then"}, {"sha": "f10ec25c707d97cbb806dd5b80f9a3d7107a9e1a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d3604c74a30cebd485537b698dc89fcdd17709/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d2d3604c74a30cebd485537b698dc89fcdd17709", "patch": "@@ -1244,12 +1244,14 @@ package body Sem_Attr is\n          Btyp := Implementation_Base_Type (P_Type);\n \n          --  Stream attributes not allowed on limited types unless the\n-         --  stream attribute was generated by the expander (in which\n-         --  case the underlying type will be used, as described in Sinfo).\n+         --  attribute reference was generated by the expander (in which\n+         --  case the underlying type will be used, as described in Sinfo),\n+         --  or the attribute was specified explicitly for the type itself\n+         --  or one of its ancestors.\n \n          if Is_Limited_Type (P_Type)\n            and then Comes_From_Source (N)\n-           and then not Present (TSS (Btyp, Nam))\n+           and then not Present (Find_Inherited_TSS (Btyp, Nam))\n            and then not Has_Rep_Pragma (Btyp, Name_Stream_Convert)\n          then\n             Error_Msg_Name_1 := Aname;"}]}