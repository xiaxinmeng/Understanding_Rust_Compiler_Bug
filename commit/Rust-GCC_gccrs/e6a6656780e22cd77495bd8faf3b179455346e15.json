{"sha": "e6a6656780e22cd77495bd8faf3b179455346e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhNjY1Njc4MGUyMmNkNzc0OTViZDhmYWYzYjE3OTQ1NTM0NmUxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-11-08T02:16:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-11-08T02:16:48Z"}, "message": "class.c (add_vcall_offset_vtbl_entries_1): Correct ordering of vcall offfsets.\n\n\t* class.c (add_vcall_offset_vtbl_entries_1): Correct ordering of\n\tvcall offfsets.  Split out ...\n\t(add_vcall_offset): ... new function.\n\n\t* g++.dg/abi/vthunk3.C: New test.\n\nFrom-SVN: r58912", "tree": {"sha": "8a244591acba56e22812980ef1a56c3b92b02e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a244591acba56e22812980ef1a56c3b92b02e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6a6656780e22cd77495bd8faf3b179455346e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a6656780e22cd77495bd8faf3b179455346e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a6656780e22cd77495bd8faf3b179455346e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a6656780e22cd77495bd8faf3b179455346e15/comments", "author": null, "committer": null, "parents": [{"sha": "4f2c9d7ec6409e570be8df243c57e4e3298b26e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2c9d7ec6409e570be8df243c57e4e3298b26e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2c9d7ec6409e570be8df243c57e4e3298b26e6"}], "stats": {"total": 261, "additions": 166, "deletions": 95}, "files": [{"sha": "224c5908fa5ab8f3112f2e6c551d001a0420c96f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6a6656780e22cd77495bd8faf3b179455346e15", "patch": "@@ -1,5 +1,9 @@\n 2002-11-07  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (add_vcall_offset_vtbl_entries_1): Correct ordering of\n+\tvcall offfsets.  Split out ...\n+\t(add_vcall_offset): ... new function.\n+\n \tPR c++/8338\n \t* pt.c (for_each_template_parm): Add htab parameter.\n \t(process_partial_specialization): Adjust call."}, {"sha": "2ca45a67f8459b95e54d8915eef9645259bcf36f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 134, "deletions": 95, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e6a6656780e22cd77495bd8faf3b179455346e15", "patch": "@@ -156,6 +156,7 @@ static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void add_vcall_offset_vtbl_entries_r PARAMS ((tree, vtbl_init_data *));\n static void add_vcall_offset_vtbl_entries_1 PARAMS ((tree, vtbl_init_data *));\n static void build_vcall_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n+static void add_vcall_offset (tree, tree, vtbl_init_data *);\n static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n@@ -7908,116 +7909,154 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n      tree binfo;\n      vtbl_init_data* vid;\n {\n-  tree derived_virtuals;\n-  tree base_virtuals;\n-  tree orig_virtuals;\n-  tree binfo_inits;\n-  /* If BINFO is a primary base, the most derived class which has BINFO as\n-     a primary base; otherwise, just BINFO.  */\n-  tree non_primary_binfo;\n+  tree binfo_in_rtti;\n \n-  binfo_inits = NULL_TREE;\n+  if (vid->ctor_vtbl_p)\n+    binfo_in_rtti = (get_original_base\n+\t\t     (binfo, TYPE_BINFO (BINFO_TYPE (vid->rtti_binfo))));\n+  else\n+    binfo_in_rtti = binfo;\n \n-  /* We might be a primary base class.  Go up the inheritance hierarchy\n-     until we find the most derived class of which we are a primary base:\n-     it is the BINFO_VIRTUALS there that we need to consider.  */\n-  non_primary_binfo = binfo;\n-  while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n+  /* Make entries for the rest of the virtuals.  */\n+  if (abi_version_at_least (2))\n     {\n-      tree b;\n+      tree orig_fn;\n \n-      /* If we have reached a virtual base, then it must be vid->vbase,\n-\t because we ignore other virtual bases in\n-\t add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary\n-\t base (possibly multi-level) of vid->binfo, or we wouldn't\n-\t have called build_vcall_and_vbase_vtbl_entries for it.  But it\n-\t might be a lost primary, so just skip down to vid->binfo.  */\n-      if (TREE_VIA_VIRTUAL (non_primary_binfo))\n+      /* The ABI requires that the methods be processed in declaration\n+\t order.  G++ 3.2 used the order in the vtable.  */\n+      for (orig_fn = TYPE_METHODS (BINFO_TYPE (binfo));\n+\t   orig_fn;\n+\t   orig_fn = TREE_CHAIN (orig_fn))\n+\tif (DECL_VINDEX (orig_fn))\n+\t  add_vcall_offset (orig_fn, binfo_in_rtti, vid);\n+    }\n+  else\n+    {\n+      tree derived_virtuals;\n+      tree base_virtuals;\n+      tree orig_virtuals;\n+      /* If BINFO is a primary base, the most derived class which has\n+\t BINFO as a primary base; otherwise, just BINFO.  */\n+      tree non_primary_binfo;\n+\n+      /* We might be a primary base class.  Go up the inheritance hierarchy\n+\t until we find the most derived class of which we are a primary base:\n+\t it is the BINFO_VIRTUALS there that we need to consider.  */\n+      non_primary_binfo = binfo;\n+      while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n \t{\n-\t  if (non_primary_binfo != vid->vbase)\n-\t    abort ();\n-\t  non_primary_binfo = vid->binfo;\n-\t  break;\n-\t}\n+\t  tree b;\n+\n+\t  /* If we have reached a virtual base, then it must be vid->vbase,\n+\t     because we ignore other virtual bases in\n+\t     add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary\n+\t     base (possibly multi-level) of vid->binfo, or we wouldn't\n+\t     have called build_vcall_and_vbase_vtbl_entries for it.  But it\n+\t     might be a lost primary, so just skip down to vid->binfo.  */\n+\t  if (TREE_VIA_VIRTUAL (non_primary_binfo))\n+\t    {\n+\t      if (non_primary_binfo != vid->vbase)\n+\t\tabort ();\n+\t      non_primary_binfo = vid->binfo;\n+\t      break;\n+\t    }\n \n-      b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n-      if (get_primary_binfo (b) != non_primary_binfo)\n-\tbreak;\n-      non_primary_binfo = b;\n-    }\n+\t  b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n+\t  if (get_primary_binfo (b) != non_primary_binfo)\n+\t    break;\n+\t  non_primary_binfo = b;\n+\t}\n \n-  if (vid->ctor_vtbl_p)\n-    /* For a ctor vtable we need the equivalent binfo within the hierarchy\n-       where rtti_binfo is the most derived type.  */\n-    non_primary_binfo = get_original_base\n+      if (vid->ctor_vtbl_p)\n+\t/* For a ctor vtable we need the equivalent binfo within the hierarchy\n+\t   where rtti_binfo is the most derived type.  */\n+\tnon_primary_binfo = get_original_base\n           (non_primary_binfo, TYPE_BINFO (BINFO_TYPE (vid->rtti_binfo)));\n+      \n+      for (base_virtuals = BINFO_VIRTUALS (binfo),\n+\t     derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n+\t     orig_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n+\t   base_virtuals;\n+\t   base_virtuals = TREE_CHAIN (base_virtuals),\n+\t     derived_virtuals = TREE_CHAIN (derived_virtuals),\n+\t     orig_virtuals = TREE_CHAIN (orig_virtuals))\n+\t{\n+\t  tree orig_fn;\n \n-  /* Make entries for the rest of the virtuals.  */\n-  for (base_virtuals = BINFO_VIRTUALS (binfo),\n-\t derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n-\t orig_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n-       base_virtuals;\n-       base_virtuals = TREE_CHAIN (base_virtuals),\n-\t derived_virtuals = TREE_CHAIN (derived_virtuals),\n-\t orig_virtuals = TREE_CHAIN (orig_virtuals))\n-    {\n-      tree orig_fn;\n-      tree fn;\n-      size_t i;\n-      tree vcall_offset;\n+\t  /* Find the declaration that originally caused this function to\n+\t     be present in BINFO_TYPE (binfo).  */\n+\t  orig_fn = BV_FN (orig_virtuals);\n \n-      /* Find the declaration that originally caused this function to\n-\t be present in BINFO_TYPE (binfo).  */\n-      orig_fn = BV_FN (orig_virtuals);\n+\t  /* When processing BINFO, we only want to generate vcall slots for\n+\t     function slots introduced in BINFO.  So don't try to generate\n+\t     one if the function isn't even defined in BINFO.  */\n+\t  if (!same_type_p (DECL_CONTEXT (orig_fn), BINFO_TYPE (binfo)))\n+\t    continue;\n \n-      /* When processing BINFO, we only want to generate vcall slots for\n-\t function slots introduced in BINFO.  So don't try to generate\n-\t one if the function isn't even defined in BINFO.  */\n-      if (!same_type_p (DECL_CONTEXT (orig_fn), BINFO_TYPE (binfo)))\n-\tcontinue;\n+\t  add_vcall_offset (orig_fn, binfo_in_rtti, vid);\n+\t}\n+    }\n+}\n \n-      /* Find the overriding function.  */\n-      fn = BV_FN (derived_virtuals);\n+/* Add a vcall offset entry for ORIG_FN to the vtable.  In a\n+   construction vtable, BINFO_IN_RTTI is the base corresponding to the\n+   vtable base in VID->RTTI_BINFO.  */\n \n-      /* If there is already an entry for a function with the same\n-\t signature as FN, then we do not need a second vcall offset.\n-\t Check the list of functions already present in the derived\n-\t class vtable.  */\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (vid->fns); ++i) \n-\t{\n-\t  tree derived_entry;\n-\n-\t  derived_entry = VARRAY_TREE (vid->fns, i);\n-\t  if (same_signature_p (BV_FN (derived_entry), fn)\n-\t      /* We only use one vcall offset for virtual destructors,\n-\t\t even though there are two virtual table entries.  */\n-\t      || (DECL_DESTRUCTOR_P (BV_FN (derived_entry))\n-\t\t  && DECL_DESTRUCTOR_P (fn)))\n-\t    break;\n-\t}\n-      if (i != VARRAY_ACTIVE_SIZE (vid->fns))\n-\tcontinue;\n+static void\n+add_vcall_offset (tree orig_fn, tree binfo_in_rtti,\n+\t\t  vtbl_init_data *vid)\n+{\n+  size_t i;\n+  tree vcall_offset;\n \n-      /* If we are building these vcall offsets as part of building\n-\t the vtable for the most derived class, remember the vcall\n-\t offset.  */\n-      if (vid->binfo == TYPE_BINFO (vid->derived))\n-\tCLASSTYPE_VCALL_INDICES (vid->derived) \n-\t  = tree_cons (fn, vid->index, CLASSTYPE_VCALL_INDICES (vid->derived));\n+  /* If there is already an entry for a function with the same\n+     signature as FN, then we do not need a second vcall offset.\n+     Check the list of functions already present in the derived\n+     class vtable.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (vid->fns); ++i) \n+    {\n+      tree derived_entry;\n \n-      /* The next vcall offset will be found at a more negative\n-\t offset.  */\n-      vid->index = size_binop (MINUS_EXPR, vid->index,\n-\t\t\t       ssize_int (TARGET_VTABLE_DATA_ENTRY_DISTANCE));\n+      derived_entry = VARRAY_TREE (vid->fns, i);\n+      if (same_signature_p (derived_entry, orig_fn)\n+\t  /* We only use one vcall offset for virtual destructors,\n+\t     even though there are two virtual table entries.  */\n+\t  || (DECL_DESTRUCTOR_P (derived_entry)\n+\t      && DECL_DESTRUCTOR_P (orig_fn)))\n+\treturn;\n+    }\n \n-      /* Keep track of this function.  */\n-      VARRAY_PUSH_TREE (vid->fns, derived_virtuals);\n+  /* If we are building these vcall offsets as part of building\n+     the vtable for the most derived class, remember the vcall\n+     offset.  */\n+  if (vid->binfo == TYPE_BINFO (vid->derived))\n+    CLASSTYPE_VCALL_INDICES (vid->derived) \n+      = tree_cons (orig_fn, vid->index, \n+\t\t   CLASSTYPE_VCALL_INDICES (vid->derived));\n \n-      if (vid->generate_vcall_entries)\n-\t{\n-\t  tree base;\n-\t  tree base_binfo;\n+  /* The next vcall offset will be found at a more negative\n+     offset.  */\n+  vid->index = size_binop (MINUS_EXPR, vid->index,\n+\t\t\t   ssize_int (TARGET_VTABLE_DATA_ENTRY_DISTANCE));\n+\n+  /* Keep track of this function.  */\n+  VARRAY_PUSH_TREE (vid->fns, orig_fn);\n+\n+  if (vid->generate_vcall_entries)\n+    {\n+      tree base;\n+      tree base_binfo;\n+      tree fn;\n \n+      /* Find the overriding function.  */\n+      fn = find_final_overrider (BINFO_TYPE (vid->rtti_binfo), \n+\t\t\t\t binfo_in_rtti, orig_fn);\n+      if (fn == error_mark_node)\n+\tvcall_offset = build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t       integer_zero_node);\n+      else\n+\t{\n+\t  fn = TREE_PURPOSE (fn);\n \t  /* The FN comes from BASE.  So, we must calculate the\n \t     adjustment from vid->vbase to BASE.  We can just look for\n \t     BASE in the complete object because we are converting\n@@ -8037,10 +8076,10 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \t\t\t\t      vcall_offset);\n \t  vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t\t       vcall_offset));\n-\n-\t  *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n-\t  vid->last_init = &TREE_CHAIN (*vid->last_init);\n \t}\n+      /* Add the intiailizer to the vtable.  */\n+      *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n+      vid->last_init = &TREE_CHAIN (*vid->last_init);\n     }\n }\n "}, {"sha": "679029eed3182b1dd93ca2e38e24d1f5be24279f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6a6656780e22cd77495bd8faf3b179455346e15", "patch": "@@ -1,5 +1,7 @@\n 2002-11-07  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* g++.dg/abi/vthunk3.C: New test.\n+\n \tPR c++/8338\n \t* g++.dg/template/crash2.C: New test.\n "}, {"sha": "59e60678d0682043089eb35a1d817599c093b230", "filename": "gcc/testsuite/g++.dg/abi/vthunk3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvthunk3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a6656780e22cd77495bd8faf3b179455346e15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvthunk3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvthunk3.C?ref=e6a6656780e22cd77495bd8faf3b179455346e15", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct A {\n+  virtual void a ();\n+};\n+\n+struct B : virtual public A {\n+  virtual void b ();\n+  virtual void a ();\n+};\n+\n+struct C {\n+  virtual void c ();\n+};\n+\n+struct D : public C, public B {\n+};\n+\n+struct E : virtual public D {\n+  void b ();\n+};\n+\n+void E::b () {}\n+\n+// { dg-final { scan-assembler _ZTvn4_n20_N1E1bEv } }"}]}