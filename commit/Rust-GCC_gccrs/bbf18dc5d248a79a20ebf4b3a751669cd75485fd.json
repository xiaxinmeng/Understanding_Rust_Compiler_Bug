{"sha": "bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJmMThkYzVkMjQ4YTc5YTIwZWJmNGIzYTc1MTY2OWNkNzU0ODVmZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-12T15:25:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-12T15:25:52Z"}, "message": "gfortran.texi: Add description in sections on TS 29113 and further interoperability with C.\n\n2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.texi : Add description in sections on TS 29113 and\n\tfurther interoperability with C.\n\t* trans-array.c (gfc_conv_descriptor_attribute): New function.\n\t(gfc_get_dataptr_offset): Remove static function attribute.\n\t* trans-array.h : Add prototypes for above functions.\n\t* trans-decl.c : Add declarations for the library functions\n\tcfi_desc_to_gfc_desc and gfc_desc_to_cfi_desc.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): New function.\n\t(gfc_conv_procedure_call): Call it for scalar and array actual\n\targuments, when the formal arguments are bind_c with assumed\n\tshape or assumed rank.\n\t* trans.h : External declarations for gfor_fndecl_cfi_to_gfc\n\tand gfor_fndecl_gfc_to_cfi.\n\n2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/ISO_Fortran_binding_1.f90 : New test.\n\t* gfortran.dg/ISO_Fortran_binding_1.c : Auxilliary file for test.\n\t* gfortran.dg/ISO_Fortran_binding_2.f90 : New test.\n\t* gfortran.dg/ISO_Fortran_binding_2.c : Auxilliary file for test.\n\t* gfortran.dg/bind_c_array_params_2.f90 : Change search string\n\tfor dump tree scan.\n\n2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* ISO_Fortran_binding.h : New file.\n\t* Makefile.am : Include ISO_Fortran_binding.c in the list of\n\tfiles to compile.\n\t* Makefile.in : Regenerated.\n\t* gfortran.map : Add _gfortran_cfi_desc_to_gfc_desc,\n\t_gfortran_gfc_desc_to_cfi_desc and the CFI API functions.\n\t* runtime/ISO_Fortran_binding.c : New file containing the new\n\tfunctions added to the map.\n\nFrom-SVN: r267881", "tree": {"sha": "dfff4a53d274e517577746cfd677e88335f966dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfff4a53d274e517577746cfd677e88335f966dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/comments", "author": null, "committer": null, "parents": [{"sha": "af79605ec27c0db7dee9ee001cd7d768eb6fcf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af79605ec27c0db7dee9ee001cd7d768eb6fcf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af79605ec27c0db7dee9ee001cd7d768eb6fcf02"}], "stats": {"total": 2278, "additions": 2161, "deletions": 117}, "files": [{"sha": "a34fbd8a1fbfd0fddd665aec052e6fbddd0219f2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -1,3 +1,19 @@\n+2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.texi : Add description in sections on TS 29113 and\n+\tfurther interoperability with C.\n+\t* trans-array.c (gfc_conv_descriptor_attribute): New function.\n+\t(gfc_get_dataptr_offset): Remove static function attribute.\n+\t* trans-array.h : Add prototypes for above functions.\n+\t* trans-decl.c : Add declarations for the library functions\n+\tcfi_desc_to_gfc_desc and gfc_desc_to_cfi_desc.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): New function.\n+\t(gfc_conv_procedure_call): Call it for scalar and array actual\n+\targuments, when the formal arguments are bind_c with assumed\n+\tshape or assumed rank.\n+\t* trans.h : External declarations for gfor_fndecl_cfi_to_gfc\n+\tand gfor_fndecl_gfc_to_cfi.\n+\n 2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/35031"}, {"sha": "e44b8ccaad3c18f389643bf900fee82a77b25cc6", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -384,7 +384,7 @@ extension are also run through preprocessing.\n This manual specifically documents the Fortran front end, which handles\n the programming language's syntax and semantics.  The aspects of GCC\n which relate to the optimization passes and the back-end code generation\n-are documented in the GCC manual; see \n+are documented in the GCC manual; see\n @ref{Top,,Introduction,gcc,Using the GNU Compiler Collection (GCC)}.\n The two manuals together provide a complete reference for the GNU\n Fortran compiler.\n@@ -446,11 +446,11 @@ to preprocess such files (@uref{http://www.daniellnagle.com/coco.html}).\n @cindex Fortran 77\n @cindex @command{g77}\n \n-The GNU Fortran compiler is the successor to @command{g77}, the Fortran \n-77 front end included in GCC prior to version 4.  It is an entirely new \n-program that has been designed to provide Fortran 95 support and \n-extensibility for future Fortran language standards, as well as providing \n-backwards compatibility for Fortran 77 and nearly all of the GNU language \n+The GNU Fortran compiler is the successor to @command{g77}, the Fortran\n+77 front end included in GCC prior to version 4.  It is an entirely new\n+program that has been designed to provide Fortran 95 support and\n+extensibility for future Fortran language standards, as well as providing\n+backwards compatibility for Fortran 77 and nearly all of the GNU language\n extensions supported by @command{g77}.\n \n \n@@ -490,10 +490,10 @@ change in future versions of GCC.  See\n @uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n \n At present, the GNU Fortran compiler passes the\n-@uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html, \n+@uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html,\n NIST Fortran 77 Test Suite}, and produces acceptable results on the\n @uref{http://www.netlib.org/lapack/faq.html#1.21, LAPACK Test Suite}.\n-It also provides respectable performance on \n+It also provides respectable performance on\n the @uref{http://www.polyhedron.com/fortran-compiler-comparisons/polyhedron-benchmark-suite,\n Polyhedron Fortran\n compiler benchmarks} and the\n@@ -668,7 +668,7 @@ This is the default.\n @section @env{GFORTRAN_UNBUFFERED_PRECONNECTED}---Do not buffer I/O on preconnected units\n \n The environment variable named @env{GFORTRAN_UNBUFFERED_PRECONNECTED} controls\n-whether I/O on a preconnected unit (i.e.@: STDOUT or STDERR) is unbuffered.  If \n+whether I/O on a preconnected unit (i.e.@: STDOUT or STDERR) is unbuffered.  If\n the first letter is @samp{y}, @samp{Y} or @samp{1}, I/O is unbuffered.  This\n will slow down small sequential reads and writes.  If the first letter\n is @samp{n}, @samp{N} or @samp{0}, I/O is buffered.  This is the default.\n@@ -733,7 +733,7 @@ A missing mode for an exception is taken to mean @code{BIG_ENDIAN}.\n Examples of values for @env{GFORTRAN_CONVERT_UNIT} are:\n @itemize @w{}\n @item @code{'big_endian'}  Do all unformatted I/O in big_endian mode.\n-@item @code{'little_endian;native:10-20,25'}  Do all unformatted I/O \n+@item @code{'little_endian;native:10-20,25'}  Do all unformatted I/O\n in little_endian mode, except for units 10 to 20 and 25, which are in\n native format.\n @item @code{'10-20'}  Units 10 to 20 are big-endian, the rest is native.\n@@ -834,7 +834,7 @@ initialization are available.\n \n @item The @code{ASSOCIATE} construct.\n \n-@item Interoperability with C including enumerations, \n+@item Interoperability with C including enumerations,\n \n @item In structure constructors the components with default values may be\n omitted.\n@@ -999,7 +999,7 @@ about the current Fortran 2008 implementation status.  In particular, the\n following is implemented.\n \n @itemize\n-@item The @option{-std=f2008} option and support for the file extensions \n+@item The @option{-std=f2008} option and support for the file extensions\n @file{.f08} and @file{.F08}.\n \n @item The @code{OPEN} statement now supports the @code{NEWUNIT=} option,\n@@ -1103,8 +1103,6 @@ arrays are supported for named constants (@code{PARAMETER}).\n @node Fortran 2018 status\n @section Status of Fortran 2018 support\n \n-So far very little work has been done to support Fortran 2018.\n-\n @itemize\n @item ERROR STOP in a PURE procedure\n An @code{ERROR STOP} statement is permitted in a @code{PURE}\n@@ -1143,8 +1141,12 @@ attribute is compatible with TS 29113.\n \n @item Assumed types (@code{TYPE(*)}).\n \n-@item Assumed-rank (@code{DIMENSION(..)}). However, the array descriptor\n-of the TS is not yet supported.\n+@item Assumed-rank (@code{DIMENSION(..)}).\n+\n+@item ISO_Fortran_binding (now in Fortran 2018 18.4) is implemented such that\n+conversion of the array descriptor for assumed type or assumed rank arrays is\n+done in the library. The include file ISO_Fortran_binding.h is can be found in\n+@code{~prefix/lib/gcc/$target/$version}.\n @end itemize\n \n \n@@ -1300,7 +1302,7 @@ being called from a multi-threaded program.\n \n The GNU Fortran runtime library, (@code{libgfortran}), supports being\n called concurrently from multiple threads with the following\n-exceptions. \n+exceptions.\n \n During library initialization, the C @code{getenv} function is used,\n which need not be thread-safe.  Similarly, the @code{getenv}\n@@ -1430,7 +1432,7 @@ processor dependent.  GNU Fortran behaves as follows:\n @cindex file, symbolic link\n \n This section documents the behavior of GNU Fortran for file operations on\n-symbolic links, on systems that support them. \n+symbolic links, on systems that support them.\n \n @itemize\n \n@@ -1497,7 +1499,7 @@ record containing a single subrecord:\n program main\n   use iso_fortran_env, only: int32\n   implicit none\n-  integer(int32) :: i \n+  integer(int32) :: i\n   real, dimension(10) :: a, b\n   call random_number(a)\n   open (10,file='test.dat',form='unformatted',access='stream')\n@@ -1725,7 +1727,7 @@ PROGRAM test_print\n END PROGRAM test_print\n @end smallexample\n \n-Expanded namelist reads are permitted.  This causes an error if \n+Expanded namelist reads are permitted.  This causes an error if\n @option{-std=f95} is used.  In the following example, the first element\n of the array will be given the value 0.00 and the two succeeding\n elements will be given the values 1.00 and 2.00.\n@@ -1988,7 +1990,7 @@ pointer in order to increment it.  Consider the following example:\n         real pointee(10)\n         pointer (ipt, pointee)\n         ipt = loc (target)\n-        ipt = ipt + 1       \n+        ipt = ipt + 1\n @end smallexample\n The last statement does not set @code{ipt} to the address of\n @code{target(1)}, as it would in C pointer arithmetic.  Adding @code{1}\n@@ -2120,13 +2122,13 @@ portable.\n @cindex OpenMP\n \n OpenMP (Open Multi-Processing) is an application programming\n-interface (API) that supports multi-platform shared memory \n-multiprocessing programming in C/C++ and Fortran on many \n+interface (API) that supports multi-platform shared memory\n+multiprocessing programming in C/C++ and Fortran on many\n architectures, including Unix and Microsoft Windows platforms.\n It consists of a set of compiler directives, library routines,\n and environment variables that influence run-time behavior.\n \n-GNU Fortran strives to be compatible to the \n+GNU Fortran strives to be compatible to the\n @uref{http://openmp.org/wp/openmp-specifications/,\n OpenMP Application Program Interface v4.5}.\n \n@@ -2169,7 +2171,7 @@ if the stacksize is limited.\n @item\n On glibc-based systems, OpenMP enabled applications cannot be statically\n linked due to limitations of the underlying pthreads-implementation.  It\n-might be possible to get a working solution if \n+might be possible to get a working solution if\n @command{-Wl,--whole-archive -lpthread -Wl,--no-whole-archive} is added\n to the command line.  However, this is not supported by @command{gcc} and\n thus not recommended.\n@@ -2213,20 +2215,20 @@ change in future versions of GCC.  See\n @cindex @code{%REF}\n @cindex @code{%LOC}\n \n-GNU Fortran supports argument list functions @code{%VAL}, @code{%REF} \n-and @code{%LOC} statements, for backward compatibility with g77. \n-It is recommended that these should be used only for code that is \n-accessing facilities outside of GNU Fortran, such as operating system \n-or windowing facilities.  It is best to constrain such uses to isolated \n-portions of a program--portions that deal specifically and exclusively \n-with low-level, system-dependent facilities.  Such portions might well \n-provide a portable interface for use by the program as a whole, but are \n-themselves not portable, and should be thoroughly tested each time they \n+GNU Fortran supports argument list functions @code{%VAL}, @code{%REF}\n+and @code{%LOC} statements, for backward compatibility with g77.\n+It is recommended that these should be used only for code that is\n+accessing facilities outside of GNU Fortran, such as operating system\n+or windowing facilities.  It is best to constrain such uses to isolated\n+portions of a program--portions that deal specifically and exclusively\n+with low-level, system-dependent facilities.  Such portions might well\n+provide a portable interface for use by the program as a whole, but are\n+themselves not portable, and should be thoroughly tested each time they\n are rebuilt using a new compiler or version of a compiler.\n \n-@code{%VAL} passes a scalar argument by value, @code{%REF} passes it by \n-reference and @code{%LOC} passes its memory location.  Since gfortran \n-already passes scalar arguments by reference, @code{%REF} is in effect \n+@code{%VAL} passes a scalar argument by value, @code{%REF} passes it by\n+reference and @code{%LOC} passes its memory location.  Since gfortran\n+already passes scalar arguments by reference, @code{%REF} is in effect\n a do-nothing.  @code{%LOC} has the same effect as a Fortran pointer.\n \n An example of passing an argument by value to a C subroutine foo.:\n@@ -2384,7 +2386,7 @@ following shows some examples:\n @example\n structure /appointment/\n   ! nested structure definition: app_time is an array of two 'time'\n-  structure /time/ app_time (2) \n+  structure /time/ app_time (2)\n     integer(1) hour, minute\n   end structure\n   character(10) memo\n@@ -2970,7 +2972,7 @@ with the following:\n @smallexample\n c     Variable declaration\n       CHARACTER(LEN=20) FMT\n-c     \n+c\n c     Other code here...\n c\n       WRITE(FMT,'(\"(I\", I0, \")\")') N+1\n@@ -2983,7 +2985,7 @@ or with:\n @smallexample\n c     Variable declaration\n       CHARACTER(LEN=20) FMT\n-c     \n+c\n c     Other code here...\n c\n       WRITE(FMT,*) N+1\n@@ -3430,11 +3432,14 @@ and constraints, it adds assumed-type (@code{TYPE(*)}) and assumed-rank\n assumed-shape, assumed-rank and deferred-shape arrays, including\n allocatables and pointers.\n \n-Note: Currently, GNU Fortran does not support the array descriptor\n+Note: Currently, GNU Fortran does not use internally the array descriptor\n (dope vector) as specified in the Technical Specification, but uses\n-an array descriptor with different fields. The Chasm Language\n-Interoperability Tools, @url{http://chasm-interop.sourceforge.net/},\n-provide an interface to GNU Fortran's array descriptor.\n+an array descriptor with different fields. Assumed type and assumed rank\n+formal arguments are converted in the library to the specified form. The\n+ISO_Fortran_binding API functions (also Fortran 2018 18.4) are implemented\n+in libgfortran. Alternatively, the Chasm Language Interoperability Tools,\n+@url{http://chasm-interop.sourceforge.net/}, provide an interface to GNU\n+Fortran's array descriptor.\n \n The Technical Specification adds the following new features, which\n are supported by GNU Fortran:\n@@ -5735,7 +5740,7 @@ ideas and significant help to the GNU Fortran project\n The following people have contributed bug reports,\n smaller or larger patches,\n and much needed feedback and encouragement for the\n-GNU Fortran project: \n+GNU Fortran project:\n \n @itemize @minus\n @item Bill Clodius"}, {"sha": "6b3c0e2d65b12077a1185ef662148f5db9e08741", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -292,6 +292,22 @@ gfc_conv_descriptor_rank (tree desc)\n }\n \n \n+tree\n+gfc_conv_descriptor_attribute (tree desc)\n+{\n+  tree tmp;\n+  tree dtype;\n+\n+  dtype = gfc_conv_descriptor_dtype (desc);\n+  tmp = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (dtype)),\n+\t\t\t   GFC_DTYPE_ATTRIBUTE);\n+  gcc_assert (tmp!= NULL_TREE\n+\t      && TREE_TYPE (tmp) == short_integer_type_node);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t  dtype, tmp, NULL_TREE);\n+}\n+\n+\n tree\n gfc_get_descriptor_dimension (tree desc)\n {\n@@ -6767,7 +6783,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \n \n /* Calculate the overall offset, including subreferences.  */\n-static void\n+void\n gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \t\t\tbool subref, gfc_expr *expr)\n {"}, {"sha": "a6d71672876afb3a13003b62102020d5443c9fcf", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -136,6 +136,8 @@ void gfc_conv_tmp_array_ref (gfc_se * se);\n /* Translate a reference to an array temporary.  */\n void gfc_conv_tmp_ref (gfc_se *);\n \n+/* Calculate the overall offset, including subreferences.  */\n+void gfc_get_dataptr_offset (stmtblock_t*, tree, tree, tree, bool, gfc_expr*);\n /* Obtain the span of an array.  */\n tree gfc_get_array_span (tree, gfc_expr *);\n /* Evaluate an array expression.  */\n@@ -167,6 +169,7 @@ tree gfc_conv_descriptor_offset_get (tree);\n tree gfc_conv_descriptor_span_get (tree);\n tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_rank (tree);\n+tree gfc_conv_descriptor_attribute (tree);\n tree gfc_get_descriptor_dimension (tree);\n tree gfc_conv_descriptor_stride_get (tree, tree);\n tree gfc_conv_descriptor_lbound_get (tree, tree);"}, {"sha": "c4cdcd681935b65f53ec7c30cb7962438222cfd5", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -114,6 +114,8 @@ tree gfor_fndecl_fdate;\n tree gfor_fndecl_ttynam;\n tree gfor_fndecl_in_pack;\n tree gfor_fndecl_in_unpack;\n+tree gfor_fndecl_cfi_to_gfc;\n+tree gfor_fndecl_gfc_to_cfi;\n tree gfor_fndecl_associated;\n tree gfor_fndecl_system_clock4;\n tree gfor_fndecl_system_clock8;\n@@ -3619,6 +3621,14 @@ gfc_build_builtin_function_decls (void)\n \tget_identifier (PREFIX(\"internal_unpack\")), \".wR\",\n \tvoid_type_node, 2, pvoid_type_node, pvoid_type_node);\n \n+  gfor_fndecl_cfi_to_gfc = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"cfi_desc_to_gfc_desc\")), \".ww\",\n+\tvoid_type_node, 2, pvoid_type_node, ppvoid_type_node);\n+\n+  gfor_fndecl_gfc_to_cfi = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"gfc_desc_to_cfi_desc\")), \".wR\",\n+\tvoid_type_node, 2, ppvoid_type_node, pvoid_type_node);\n+\n   gfor_fndecl_associated = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"associated\")), \".RR\",\n \tinteger_type_node, 2, ppvoid_type_node, ppvoid_type_node);"}, {"sha": "c3388d7eb272c702020c59063d4f11e9936dd4ac", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -4891,6 +4891,102 @@ expr_may_alias_variables (gfc_expr *e, bool array_may_alias)\n }\n \n \n+/* Provide an interface between gfortran array descriptors and the F2018:18.4\n+   ISO_Fortran_binding array descriptors. */\n+\n+static void\n+gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n+{\n+  tree tmp;\n+  tree cfi_desc_ptr;\n+  tree gfc_desc_ptr;\n+  tree type;\n+  int attribute;\n+  symbol_attribute attr = gfc_expr_attr (e);\n+\n+  /* If this is a full array or a scalar, the allocatable and pointer\n+     attributes can be passed. Otherwise it is 'CFI_attribute_other'*/\n+  attribute = 2;\n+  if (!e->rank || gfc_get_full_arrayspec_from_expr (e))\n+    {\n+      if (attr.pointer)\n+\tattribute = 0;\n+      else if (attr.allocatable)\n+\tattribute = 1;\n+    }\n+\n+  if (e->rank)\n+    {\n+      gfc_conv_expr_descriptor (parmse, e);\n+\n+      /* All the temporary descriptors are marked as DECL_ARTIFICIAL. If\n+\t the expression type is different from the descriptor type, then\n+\t the offset must be found (eg. to a component ref or substring)\n+\t and the dtype updated.  */\n+      type = gfc_typenode_for_spec (&e->ts);\n+      if (DECL_ARTIFICIAL (parmse->expr)\n+\t  && type != gfc_get_element_type (TREE_TYPE (parmse->expr)))\n+\t{\n+\t  /* Obtain the offset to the data.  */\n+\t  gfc_get_dataptr_offset (&parmse->pre, parmse->expr, parmse->expr,\n+\t\t\t\t  gfc_index_zero_node, true, e);\n+\n+\t  /* Update the dtype.  */\n+\t  gfc_add_modify (&parmse->pre,\n+\t\t\t  gfc_conv_descriptor_dtype (parmse->expr),\n+\t\t\t  gfc_get_dtype_rank_type (e->rank, type));\n+\t}\n+      else if (!is_subref_array (e) && !DECL_ARTIFICIAL (parmse->expr))\n+\t{\n+\t  /* Make sure that the span is set for expressions where it\n+\t     might not have been done already.  */\n+\t  tmp = TREE_TYPE (parmse->expr);\n+\t  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (tmp));\n+\t  tmp = fold_convert (gfc_array_index_type, tmp);\n+\t  gfc_conv_descriptor_span_set (&parmse->pre, parmse->expr, tmp);\n+\t}\n+    }\n+  else\n+    {\n+      gfc_conv_expr (parmse, e);\n+      /* Copy the scalar for INTENT_IN.  */\n+      if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n+\tparmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n+      parmse->expr = gfc_conv_scalar_to_descriptor (parmse,\n+\t\t\t\t\t\t    parmse->expr, attr);\n+    }\n+\n+  /* Set the CFI attribute field.  */\n+  tmp = gfc_conv_descriptor_attribute (parmse->expr);\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t void_type_node, tmp,\n+\t\t\t build_int_cst (TREE_TYPE (tmp), attribute));\n+  gfc_add_expr_to_block (&parmse->pre, tmp);\n+\n+  /* Now pass the gfc_descriptor by reference.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n+\n+  /* Variables to point to the gfc and CFI descriptors.  */\n+  gfc_desc_ptr = parmse->expr;\n+  cfi_desc_ptr = gfc_create_var (pvoid_type_node, \"cfi\");\n+\n+  /* Allocate the CFI descriptor and fill the fields.  */\n+  tmp = gfc_build_addr_expr (NULL_TREE, cfi_desc_ptr);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);\n+  gfc_add_expr_to_block (&parmse->pre, tmp);\n+\n+  /* The CFI descriptor is passed to the bind_C procedure.  */\n+  parmse->expr = cfi_desc_ptr;\n+\n+  /* Transfer values back to gfc descriptor and free the CFI descriptor.  */\n+  tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n+  gfc_prepend_expr_to_block (&parmse->post, tmp);\n+}\n+\n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -5234,7 +5330,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    tmp = gfc_get_symbol_decl (e->symtree->n.sym->cp_pointer);\n \t\t    parmse.expr = convert (type, tmp);\n \t\t}\n- \t      else if (fsym && fsym->attr.value)\n+\n+\t      else if (sym->attr.is_bind_c && e\n+\t\t       && fsym && fsym->attr.dimension\n+\t\t       && (fsym->as->type == AS_ASSUMED_RANK\n+\t\t\t   || fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n+\t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n+\n+\t      else if (fsym && fsym->attr.value)\n \t\t{\n \t\t  if (fsym->ts.type == BT_CHARACTER\n \t\t      && fsym->ts.is_c_interop\n@@ -5273,6 +5377,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      }\n \t\t    }\n \t\t}\n+\n \t      else if (arg->name && arg->name[0] == '%')\n \t\t/* Argument list functions %VAL, %LOC and %REF are signalled\n \t\t   through arg->name.  */\n@@ -5287,6 +5392,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  gfc_conv_expr (&parmse, e);\n \t\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n \t\t}\n+\n \t      else if (e->expr_type == EXPR_FUNCTION\n \t\t       && e->symtree->n.sym->result\n \t\t       && e->symtree->n.sym->result != e->symtree->n.sym\n@@ -5297,6 +5403,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  if (fsym && fsym->attr.proc_pointer)\n \t\t    parmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n \t\t}\n+\n \t      else\n \t\t{\n \t\t  if (e->ts.type == BT_CLASS && fsym\n@@ -5670,7 +5777,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    parmse.force_tmp = 1;\n \t\t}\n \n-\t      if (e->expr_type == EXPR_VARIABLE\n+\t      if (sym->attr.is_bind_c && e\n+\t\t  && fsym && fsym->attr.dimension\n+\t\t  && (fsym->as->type == AS_ASSUMED_RANK\n+\t\t      || fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n+\t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n+\n+\t      else if (e->expr_type == EXPR_VARIABLE\n \t\t    && is_subref_array (e)\n \t\t    && !(fsym && fsym->attr.pointer))\n \t\t/* The actual argument is a component reference to an\n@@ -5680,6 +5794,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_subref_array_arg (&parmse, e, nodesc_arg,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n+\n \t      else if (gfc_is_class_array_ref (e, NULL)\n \t\t\t && fsym && fsym->ts.type == BT_DERIVED)\n \t\t/* The actual argument is a component reference to an"}, {"sha": "805ed76318fc156eaca2d7917efff3ef0f71d10a", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -801,6 +801,8 @@ extern GTY(()) tree gfor_fndecl_ctime;\n extern GTY(()) tree gfor_fndecl_fdate;\n extern GTY(()) tree gfor_fndecl_in_pack;\n extern GTY(()) tree gfor_fndecl_in_unpack;\n+extern GTY(()) tree gfor_fndecl_cfi_to_gfc;\n+extern GTY(()) tree gfor_fndecl_gfc_to_cfi;\n extern GTY(()) tree gfor_fndecl_associated;\n extern GTY(()) tree gfor_fndecl_system_clock4;\n extern GTY(()) tree gfor_fndecl_system_clock8;"}, {"sha": "3bf5c3d4950c7f7bb14a4afd6d0287fd96d929c1", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,205 @@\n+/* Test F2008 18.5: ISO_Fortran_binding.h functions.  */\n+\n+#include <ISO_Fortran_binding.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <complex.h>\n+\n+/* Test the example in F2008 C.12.9: Processing assumed-shape arrays in C,\n+   modified to use CFI_address instead of pointer arithmetic.  */\n+\n+int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc,\n+\t\t     CFI_cdesc_t * c_desc)\n+{\n+  CFI_index_t idx[2];\n+  int *res_addr;\n+  int err = 1; /* this error code represents all errors */\n+\n+  if (a_desc->rank == 0)\n+    {\n+      err = *(int*)a_desc->base_addr;\n+      *(int*)a_desc->base_addr = 0;\n+      return err;\n+    }\n+\n+  if (a_desc->type != CFI_type_int\n+      || b_desc->type != CFI_type_int\n+      || c_desc->type != CFI_type_int)\n+    return err;\n+\n+  /* Only support two dimensions. */\n+  if (a_desc->rank != 2\n+      || b_desc->rank != 2\n+      || c_desc->rank != 2)\n+    return err;\n+\n+  for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)\n+    for (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)\n+      {\n+\tres_addr = CFI_address (a_desc, idx);\n+\t*res_addr = *(int*)CFI_address (b_desc, idx)\n+\t\t    * *(int*)CFI_address (c_desc, idx);\n+      }\n+\n+  return 0;\n+}\n+\n+\n+int deallocate_c(CFI_cdesc_t * dd)\n+{\n+  return CFI_deallocate(dd);\n+}\n+\n+\n+int allocate_c(CFI_cdesc_t * da, CFI_index_t lower[], CFI_index_t upper[])\n+{\n+  int err = 1;\n+  CFI_index_t idx[2];\n+  int *res_addr;\n+\n+  if (CFI_allocate(da, lower, upper, 0)) return err;\n+\n+\n+  for (idx[0] = 0; idx[0] < da->dim[0].extent; idx[0]++)\n+    for (idx[1] = 0; idx[1] < da->dim[1].extent; idx[1]++)\n+      {\n+\tres_addr = CFI_address (da, idx);\n+\t*res_addr = (int)((idx[0] + da->dim[0].lower_bound)\n+\t\t\t  * (idx[1] + da->dim[1].lower_bound));\n+      }\n+\n+  return 0;\n+}\n+\n+int establish_c(CFI_cdesc_t * desc)\n+{\n+  typedef struct {double x; double _Complex y;} t;\n+  int err;\n+  CFI_index_t idx[1], extent[1];\n+  t *res_addr;\n+  double value = 1.0;\n+  double complex z_value = 0.0 + 2.0 * I;\n+\n+  extent[0] = 10;\n+  err = CFI_establish((CFI_cdesc_t *)desc,\n+\t\t      malloc ((size_t)(extent[0] * sizeof(t))),\n+\t\t      CFI_attribute_pointer,\n+\t\t      CFI_type_struct,\n+\t\t      sizeof(t), 1, extent);\n+  for (idx[0] = 0; idx[0] < extent[0]; idx[0]++)\n+    {\n+      res_addr = (t*)CFI_address (desc, idx);\n+      res_addr->x = value++;\n+      res_addr->y = z_value * (idx[0] + 1);\n+    }\n+  return err;\n+}\n+\n+int contiguous_c(CFI_cdesc_t * desc)\n+{\n+  return CFI_is_contiguous(desc);\n+}\n+\n+float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n+{\n+  CFI_index_t idx[CFI_MAX_RANK], lower[CFI_MAX_RANK],\n+\t\t  strides[CFI_MAX_RANK], upper[CFI_MAX_RANK];\n+  CFI_CDESC_T(1) section;\n+  int ind, size;\n+  float *ret_addr;\n+  float ans = 0.0;\n+\n+  /* Case (i) from F2018:18.5.5.7. */\n+  if (*std_case == 1)\n+    {\n+      lower[0] = (CFI_index_t)low[0];\n+      strides[0] = (CFI_index_t)str[0];\n+      ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,\n+\t\t\t  CFI_type_float, 0, 1, NULL);\n+      if (ind) return -1.0;\n+      ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);\n+      if (ind) return -2.0;\n+\n+      /* Sum over the section  */\n+      size = (section.dim[0].extent - 1)\n+\t\t* section.elem_len/section.dim[0].sm + 1;\n+      for (idx[0] = 0; idx[0] < size; idx[0]++)\n+        ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n+      return ans;\n+    }\n+  else if (*std_case == 2)\n+    {\n+      int ind;\n+      lower[0] = source->dim[0].lower_bound;\n+      upper[0] = source->dim[0].lower_bound + source->dim[0].extent - 1;\n+      strides[0] = str[0];\n+      lower[1] = upper[1] = source->dim[1].lower_bound + low[1] - 1;\n+      strides[1] = 0;\n+      ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,\n+\t\t\t  CFI_type_float, 0, 1, NULL);\n+      if (ind) return -1.0;\n+      ind = CFI_section((CFI_cdesc_t *)&section, source,\n+\t\t\tlower, upper, strides);\n+      if (ind) return -2.0;\n+\n+      /* Sum over the section  */\n+      size = (section.dim[0].extent - 1)\n+\t\t* section.elem_len/section.dim[0].sm + 1;\n+      for (idx[0] = 0; idx[0] < size; idx[0]++)\n+        ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n+      return ans;\n+    }\n+\n+  return 0.0;\n+}\n+\n+\n+double select_part_c (CFI_cdesc_t * source)\n+{\n+  typedef struct {\n+    double x; double _Complex y;\n+    } t;\n+  CFI_CDESC_T(2) component;\n+  CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;\n+  CFI_index_t extent[] = {10,10};\n+  CFI_index_t idx[] = {4,0};\n+  double ans = 0.0;\n+  int size;\n+\n+  (void)CFI_establish(comp_cdesc, NULL, CFI_attribute_other,\n+\t\t      CFI_type_double_Complex, sizeof(double _Complex),\n+\t\t      2, extent);\n+  (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);\n+\n+  /* Sum over comp_cdesc[4,:]  */\n+  size = comp_cdesc->dim[1].extent;\n+  for (idx[1] = 0; idx[1] < size; idx[1]++)\n+    ans += cimag (*(double _Complex*)CFI_address ((CFI_cdesc_t*)comp_cdesc,\n+\t\t\t\t\t\t  idx));\n+  return ans;\n+}\n+\n+\n+int setpointer_c(CFI_cdesc_t * ptr, int lbounds[])\n+{\n+  CFI_index_t lower_bounds[] = {lbounds[0],lbounds[1]};\n+  int ind;\n+  ind = CFI_setpointer(ptr, ptr, lower_bounds);\n+  return ind;\n+}\n+\n+\n+int assumed_size_c(CFI_cdesc_t * desc)\n+{\n+  int ierr;\n+\n+  ierr = CFI_is_contiguous(desc);\n+  if (ierr)\n+    return 1;\n+  if (desc->rank)\n+    ierr = 2 * (desc->dim[desc->rank-1].extent\n+\t\t\t\t!= (CFI_index_t)(long long)(-1));\n+  else\n+    ierr = 3;\n+  return ierr;\n+}"}, {"sha": "4a11e22884fceb97911e748ac74f18180aab2872", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.f90", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,244 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_1.c }\n+!\n+! Test F2008 18.5: ISO_Fortran_binding.h functions.\n+!\n+  USE, INTRINSIC :: ISO_C_BINDING\n+\n+  TYPE, BIND(C) :: T\n+    REAL(C_DOUBLE) :: X\n+    complex(C_DOUBLE_COMPLEX) :: Y\n+  END TYPE\n+\n+  type :: mytype\n+    integer :: i\n+    integer :: j\n+  end type\n+\n+  INTERFACE\n+    FUNCTION elemental_mult(a, b, c) BIND(C, NAME=\"elemental_mult_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a, b, c\n+    END FUNCTION elemental_mult\n+\n+    FUNCTION c_deallocate(a) BIND(C, NAME=\"deallocate_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_deallocate\n+\n+    FUNCTION c_allocate(a, lower, upper) BIND(C, NAME=\"allocate_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+      integer(C_INTPTR_T), DIMENSION(15) :: lower, upper\n+    END FUNCTION c_allocate\n+\n+    FUNCTION c_establish(a) BIND(C, NAME=\"establish_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      import\n+      INTEGER(C_INT) :: err\n+      type (T), DIMENSION(..), intent(out) :: a\n+    END FUNCTION c_establish\n+\n+    FUNCTION c_contiguous(a) BIND(C, NAME=\"contiguous_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_contiguous\n+\n+    FUNCTION c_section(std_case, a, lower, strides) BIND(C, NAME=\"section_c\") RESULT(ans)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      real(C_FLOAT) :: ans\n+      INTEGER(C_INT) :: std_case\n+      INTEGER(C_INT), dimension(15) :: lower\n+      INTEGER(C_INT), dimension(15) :: strides\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_section\n+\n+    FUNCTION c_select_part(a) BIND(C, NAME=\"select_part_c\") RESULT(ans)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      real(C_DOUBLE) :: ans\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_select_part\n+\n+    FUNCTION c_setpointer(a, lbounds) BIND(C, NAME=\"setpointer_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      INTEGER(C_INT), dimension(2) :: lbounds\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_setpointer\n+\n+    FUNCTION c_assumed_size(a) BIND(C, NAME=\"assumed_size_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_assumed_size\n+\n+  END INTERFACE\n+\n+  integer, dimension(:,:), allocatable :: x, y, z\n+  integer, dimension(2,2) :: a, b, c\n+  integer, dimension(4,4) :: d\n+  integer :: i = 42, j, k\n+  integer(C_INTPTR_T), dimension(15) :: lower, upper\n+  real, dimension(10,10) :: arg\n+  type (mytype), dimension(2,2) :: der\n+\n+  allocate (x, source = reshape ([4,3,2,1], [2,2]))\n+  allocate (y, source = reshape ([2,3,4,5], [2,2]))\n+  allocate (z, source = reshape ([0,0,0,0], [2,2]))\n+\n+  call test_CFI_address\n+  call test_CFI_deallocate\n+  call test_CFI_allocate\n+  call test_CFI_establish\n+  call test_CFI_contiguous (a)\n+  call test_CFI_section (arg)\n+  call test_CFI_select_part\n+  call test_CFI_setpointer\n+  call test_assumed_size (a)\n+contains\n+  subroutine test_CFI_address\n+! Basic test that CFI_desc_t can be passed and that CFI_address works\n+    if (elemental_mult (z, x, y) .ne. 0) stop 1\n+    if (any (z .ne. reshape ([8,9,8,5], [2,2]))) stop 2\n+\n+    a = reshape ([4,3,2,1], [2,2])\n+    b = reshape ([2,3,4,5], [2,2])\n+    c = 0\n+! Verify that components of arrays of derived types are OK.\n+    der%j = a\n+! Check that non-pointer/non-allocatable arguments are OK\n+    if (elemental_mult (c, der%j, b) .ne. 0) stop 3\n+    if (any (c .ne. reshape ([8,9,8,5], [2,2]))) stop 4\n+\n+! Check array sections\n+    d = 0\n+    d(4:2:-2, 1:3:2) = b\n+    if (elemental_mult (c, a, d(4:2:-2, 1:3:2)) .ne. 0) stop 5\n+    if (any (c .ne. reshape ([8,9,8,5], [2,2]))) stop 6\n+\n+! If a scalar result is passed to 'elemental_mult' it is returned\n+! as the function result and then zeroed. This tests that scalars\n+! are correctly converted to CF_desc_t.\n+    if ((elemental_mult (i, a, b) .ne. 42) &\n+        .or. (i .ne. 0)) stop 7\n+    deallocate (y,z)\n+end subroutine test_CFI_address\n+\n+  subroutine test_CFI_deallocate\n+! Test CFI_deallocate.\n+    if (c_deallocate (x) .ne. 0) stop 8\n+    if (allocated (x)) stop 9\n+  end subroutine test_CFI_deallocate\n+\n+  subroutine test_CFI_allocate\n+! Test CFI_allocate.\n+    lower(1:2) = [2,2]\n+    upper(1:2) = [10,10]\n+\n+    if (c_allocate (x, lower, upper) .ne. 0) stop 10\n+    if (.not.allocated (x)) stop 11\n+    if (any (lbound (x) .ne. lower(1:2))) stop 12\n+    if (any (ubound (x) .ne. upper(1:2))) stop 13\n+\n+! Elements are filled by 'c_allocate' with the product of the fortran indices\n+    do j = lower(1) , upper(1)\n+      do k = lower(2) , upper(2)\n+        x(j,k) = x(j,k) - j * k\n+      end do\n+    end do\n+    if (any (x .ne. 0)) stop 14\n+    deallocate (x)\n+  end subroutine test_CFI_allocate\n+\n+  subroutine test_CFI_establish\n+! Test CFI_establish.\n+    type(T), pointer :: case2(:) => null()\n+    if (c_establish(case2) .ne. 0) stop 14\n+    if (ubound(case2, 1) .ne. 9) stop 15\n+    if (.not.associated(case2)) stop 16\n+    if (sizeof(case2) .ne. 240) stop 17\n+    if (int (sum (case2%x)) .ne. 55) stop 18\n+    if (int (sum (imag (case2%y))) .ne. 110) stop 19\n+    deallocate (case2)\n+  end subroutine test_CFI_establish\n+\n+  subroutine test_CFI_contiguous (arg)\n+    integer, dimension (2,*) :: arg\n+    character(4), dimension(2) :: chr\n+! These are contiguous\n+    if (c_contiguous (arg) .ne. 0) stop 20\n+    if (.not.allocated (x)) allocate (x(2, 2))\n+    if (c_contiguous (x) .ne. 0) stop 22\n+    deallocate (x)\n+    if (c_contiguous (chr) .ne. 0) stop 23\n+! These are not contiguous\n+    if (c_contiguous (der%i) .eq. 0) stop 24\n+    if (c_contiguous (arg(1:1,1:2)) .eq. 0) stop 25\n+    if (c_contiguous (d(4:2:-2, 1:3:2)) .eq. 0) stop 26\n+    if (c_contiguous (chr(:)(2:3)) .eq. 0) stop 27\n+  end subroutine test_CFI_contiguous\n+\n+  subroutine test_CFI_section (arg)\n+    real, dimension (100) :: a\n+    real, dimension (10,*) :: arg\n+    integer, dimension(15) :: lower, strides\n+    integer :: i\n+\n+! Case (i) from F2018:18.5.5.7.\n+    a = [(real(i), i = 1, 100)]\n+    lower(1) = 10\n+    strides(1) = 5\n+    if (int (sum(a(lower(1)::strides(1))) &\n+             - c_section(1, a, lower, strides)) .ne. 0) stop 28\n+! Case (ii) from F2018:18.5.5.7.\n+    arg(:,1:10) = reshape ([(real(i), i = 1, 100)], [10,10])\n+    lower(1) = 1\n+    lower(2) = 5\n+    strides(1) = 1\n+    strides(2) = 0\n+    if (int (sum(arg(:,5)) &\n+             - c_section (2, arg, lower, strides)) .ne. 0) stop 29\n+  end subroutine test_CFI_section\n+\n+  subroutine test_CFI_select_part\n+! Test the example from F2018:18.5.5.8.\n+! Modify to take rank 2 and sum the section type_t(5, :)%y%im\n+! Note that sum_z_5 = sum (type_t(5, :)%y%im) is broken on Darwin.\n+!\n+    type (t), dimension(10, 10) :: type_t\n+    real(kind(type_t%x)) :: v, sum_z_5 = 0.0\n+    complex(kind(type_t%y)) :: z\n+! Set the array 'type_t'.\n+    do j = 1, 10\n+      do k = 1, 10\n+        v = dble (j * k)\n+        z = cmplx (2 * v, 3 * v)\n+        type_t(j, k) = t (v, z)\n+        if (j .eq. 5) sum_z_5 = sum_z_5 + imag (z)\n+      end do\n+    end do\n+! Now do the test.\n+    if (int (c_select_part (type_t) - sum_z_5) .ne. 0) stop 28\n+  end subroutine test_CFI_select_part\n+\n+  subroutine test_CFI_setpointer\n+! Test the example from F2018:18.5.5.9.\n+    integer, dimension(:,:), pointer :: ptr => NULL ()\n+    integer, dimension(2,2), target :: tgt\n+    integer, dimension(2) :: lbounds = [-1, -2]\n+! The C-function resets the lbounds\n+    ptr(1:, 1:) => tgt\n+    if (c_setpointer (ptr, lbounds) .ne. 0) stop 30\n+    if (any (lbound(ptr) .ne. lbounds)) stop 31\n+  end subroutine test_CFI_setpointer\n+\n+  subroutine test_assumed_size (arg)\n+    integer, dimension(2,*) :: arg\n+! The C-function checks contiguousness and that extent[1] == -1.\n+    if (c_assumed_size (arg) .ne. 0) stop 32\n+  end subroutine\n+end"}, {"sha": "1c1af2070b3f9d76b65ac5940ad9ec5b6ee86e6b", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_2.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,115 @@\n+/* Test F2018 18.5: ISO_Fortran_binding.h functions.  */\n+\n+#include <ISO_Fortran_binding.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <complex.h>\n+\n+/* Test the example in F2018 C.12.9: Processing assumed-shape arrays in C,\n+   modified to use CFI_address instead of pointer arithmetic.  */\n+\n+int address_c(CFI_cdesc_t * a_desc, const int idx[])\n+{\n+  int *res_addr;\n+  CFI_index_t CFI_idx[1];\n+\n+  CFI_idx[0] = (CFI_index_t)idx[0];\n+\n+  res_addr = CFI_address (a_desc, CFI_idx);\n+  if (res_addr == NULL)\n+    return -1;\n+  return *res_addr;\n+}\n+\n+\n+int deallocate_c(CFI_cdesc_t * dd)\n+{\n+  return CFI_deallocate(dd);\n+}\n+\n+\n+int allocate_c(CFI_cdesc_t * da, CFI_index_t lower[], CFI_index_t upper[])\n+{\n+  return CFI_allocate(da, lower, upper, 0);\n+}\n+\n+int establish_c(CFI_cdesc_t * desc, int *rank, int *attr)\n+{\n+  typedef struct {double x; double _Complex y;} t;\n+  int err;\n+  CFI_index_t idx[1], extent[1];\n+  void *ptr;\n+\n+  extent[0] = 1;\n+  ptr = malloc ((size_t)(extent[0] * sizeof(t)));\n+  err = CFI_establish((CFI_cdesc_t *)desc,\n+\t\t      ptr,\n+\t\t      (CFI_attribute_t)*attr,\n+\t\t      CFI_type_struct,\n+\t\t      sizeof(t), (CFI_rank_t)*rank, extent);\n+  free (ptr);\n+  return err;\n+}\n+\n+int contiguous_c(CFI_cdesc_t * desc)\n+{\n+  return CFI_is_contiguous(desc);\n+}\n+\n+float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n+{\n+  CFI_index_t idx[CFI_MAX_RANK], lower[CFI_MAX_RANK],\n+\t\t  strides[CFI_MAX_RANK], upper[CFI_MAX_RANK];\n+  CFI_CDESC_T(1) section;\n+  int ind, size;\n+  float *ret_addr;\n+  float ans = 0.0;\n+\n+  if (*std_case == 1)\n+    {\n+      lower[0] = (CFI_index_t)low[0];\n+      strides[0] = (CFI_index_t)str[0];\n+      ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,\n+\t\t\t  CFI_type_float, 0, 1, NULL);\n+      if (ind) return -1.0;\n+      ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);\n+      if (ind) return (float)ind;\n+    }\n+\n+  return 0.0;\n+}\n+\n+\n+int select_part_c (CFI_cdesc_t * source)\n+{\n+  typedef struct\n+  {\n+    double x;\n+    double _Complex y;\n+  } t;\n+  CFI_CDESC_T(2) component;\n+  CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;\n+  CFI_index_t extent[] = {10,10};\n+  CFI_index_t idx[] = {4,0};\n+  int res;\n+\n+  res = CFI_establish(comp_cdesc, NULL, CFI_attribute_other,\n+\t\t      CFI_type_double_Complex, sizeof(double _Complex),\n+\t\t      2, extent);\n+  if (res)\n+    return res;\n+\n+  res = CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);\n+\n+  return res;\n+}\n+\n+\n+int setpointer_c(CFI_cdesc_t * ptr1, CFI_cdesc_t * ptr2, int lbounds[])\n+{\n+  CFI_index_t lower_bounds[] = {lbounds[0],lbounds[1]};\n+  int ind;\n+\n+  ind = CFI_setpointer(ptr1, ptr2, lower_bounds);\n+  return ind;\n+}"}, {"sha": "2670045e1faae66c7f3d525970135ff594b16a4e", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_2.f90", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,193 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_2.c }\n+! { dg-options \"-fbounds-check\" }\n+!\n+! Test F2018 18.5: ISO_Fortran_binding.h function errors.\n+!\n+  USE, INTRINSIC :: ISO_C_BINDING\n+\n+  TYPE, BIND(C) :: T\n+    REAL(C_DOUBLE) :: X\n+    complex(C_DOUBLE_COMPLEX) :: Y\n+  END TYPE\n+\n+  type :: mytype\n+    integer :: i\n+    integer :: j\n+  end type\n+\n+  INTERFACE\n+    FUNCTION c_address(a, idx) BIND(C, NAME=\"address_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      INTEGER(C_INT), dimension(1) :: idx\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_address\n+\n+    FUNCTION c_deallocate(a) BIND(C, NAME=\"deallocate_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_deallocate\n+\n+    FUNCTION c_allocate(a, lower, upper) BIND(C, NAME=\"allocate_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+      integer(C_INTPTR_T), DIMENSION(15) :: lower, upper\n+    END FUNCTION c_allocate\n+\n+    FUNCTION c_establish(a, rank, attr) BIND(C, NAME=\"establish_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      import\n+      INTEGER(C_INT) :: err\n+      INTEGER(C_INT) :: rank, attr\n+      type (T), DIMENSION(..), intent(out) :: a\n+    END FUNCTION c_establish\n+\n+    FUNCTION c_contiguous(a) BIND(C, NAME=\"contiguous_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_contiguous\n+\n+    FUNCTION c_section(std_case, a, lower, strides) BIND(C, NAME=\"section_c\") RESULT(ans)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      real(C_FLOAT) :: ans\n+      INTEGER(C_INT) :: std_case\n+      INTEGER(C_INT), dimension(15) :: lower\n+      INTEGER(C_INT), dimension(15) :: strides\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_section\n+\n+    FUNCTION c_select_part(a) BIND(C, NAME=\"select_part_c\") RESULT(ans)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: ans\n+      type(*), DIMENSION(..) :: a\n+    END FUNCTION c_select_part\n+\n+    FUNCTION c_setpointer(a, b, lbounds) BIND(C, NAME=\"setpointer_c\") RESULT(err)\n+      USE, INTRINSIC :: ISO_C_BINDING\n+      INTEGER(C_INT) :: err\n+      INTEGER(C_INT), dimension(2) :: lbounds\n+      type(*), DIMENSION(..) :: a, b\n+    END FUNCTION c_setpointer\n+  END INTERFACE\n+\n+  integer(C_INTPTR_T), dimension(15) :: lower, upper\n+\n+  call test_CFI_address\n+  call test_CFI_deallocate\n+  call test_CFI_allocate\n+  call test_CFI_establish\n+  call test_CFI_contiguous\n+  call test_CFI_section\n+  call test_CFI_select_part\n+  call test_CFI_setpointer\n+\n+contains\n+  subroutine test_CFI_address\n+    integer, dimension(:), allocatable :: a\n+    allocate (a, source = [1,2,3])\n+    if (c_address (a, [2]) .ne. 3) stop 1   ! OK\n+    if (c_address (a, [3]) .ne. -1) stop 2  ! \"subscripts[0], is out of bounds\"\n+    if (c_address (a, [-1]) .ne. -1) stop 3 ! \"subscripts[0], is out of bounds\"\n+    deallocate (a)\n+    if (c_address (a, [2]) .ne. -1) stop 4  ! \"C Descriptor must not be NULL\"\n+  end subroutine test_CFI_address\n+\n+  subroutine test_CFI_deallocate\n+    integer, dimension(:), allocatable :: a\n+    integer, dimension(2,2) :: b\n+    if (c_deallocate (a) .ne. 2) stop 5     ! \"Base address is already NULL\"\n+    allocate (a(2))\n+    if (c_deallocate (a) .ne. 0) stop 6     ! OK\n+    if (c_deallocate (b) .ne. 7) stop 7     ! \"must describe a pointer or allocatable\"\n+  end subroutine test_CFI_deallocate\n+\n+  subroutine test_CFI_allocate\n+    integer, dimension(:,:), allocatable :: a\n+    integer, dimension(2,2) :: b\n+    lower(1:2) = [2,2]\n+    upper(1:2) = [10,10]\n+    allocate (a(1,1))\n+    if (c_allocate (a, lower, upper) .ne. 3) stop 8  ! \"C descriptor must be NULL\"\n+    if (allocated (a)) deallocate (a)\n+    if (c_allocate (a, lower, upper) .ne. 0) stop 9  ! OK\n+    if (c_allocate (b, lower, upper) .ne. 7) STOP 10 ! \"must describe a pointer or allocatable\"\n+  end subroutine test_CFI_allocate\n+\n+  subroutine test_CFI_establish\n+    type(T), allocatable :: a(:)\n+    INTEGER(C_INT) :: rank\n+    INTEGER(C_INT) :: attr\n+    attr = 0                                         ! establish a pointer\n+    rank = 16\n+    if (c_establish (a, rank, attr) .ne. 5) stop 11  ! \"Rank must be between 0 and 15\"\n+    rank = 1\n+    if (c_establish (a, rank, attr) .ne. 0) stop 12  ! OK\n+    if (allocated (a)) deallocate (a)\n+    if (c_establish (a, rank, attr) .ne. 0) Stop 13  ! OK the first time\n+    if (c_establish (a, rank, attr) .ne. 10) Stop 14 ! \"its base address must be NULL\"\n+    if (allocated (a)) deallocate (a)\n+    attr = 1                                         ! establish an allocatable\n+    if (c_establish (a, rank, attr) .ne. 7) Stop 15  ! \"is for a nonallocatable entity\"\n+  end subroutine test_CFI_establish\n+\n+  subroutine test_CFI_contiguous\n+    integer, allocatable :: a\n+    if (c_contiguous (a) .ne. 2) stop 16  ! \"Descriptor is already NULL\"\n+    allocate (a)\n+    if (c_contiguous (a) .ne. 5) stop 17  ! \"must describe an array\"\n+  end subroutine test_CFI_contiguous\n+\n+  subroutine test_CFI_section\n+    real, allocatable, dimension (:) :: a\n+    integer, dimension(15) :: lower, strides\n+    integer :: i\n+    real :: b\n+    lower(1) = 10\n+    strides(1) = 5\n+    if (int (c_section (1, a, lower, strides)) .ne. 2) &\n+        stop 18 ! \"Base address of source must not be NULL\"\n+    allocate (a(100))\n+    if (int (c_section (1, a, lower, strides)) .ne. 0) &\n+        stop 19 ! OK\n+    if (int (c_section (1, b, lower, strides)) .ne. 5) &\n+        stop 20 ! \"Source must describe an array\"\n+    strides(1) = 0\n+    if (int (c_section (1, a, lower, strides)) .ne. 5) &\n+        stop 21 ! \"Rank of result must be equal to the rank of source\"\n+    strides(1) = 5\n+    lower(1) = -1\n+    if (int (c_section (1, a, lower, strides)) .ne. 12) &\n+        stop 22 ! \"Lower bounds must be within the bounds of the fortran array\"\n+    lower(1) = 100\n+    if (int (c_section (1, a, lower, strides)) .ne. 12) &\n+        stop 23 ! \"Lower bounds must be within the bounds of the fortran array\"\n+  end subroutine test_CFI_section\n+\n+  subroutine test_CFI_select_part\n+    type(t), allocatable, dimension(:) :: a\n+    type(t) :: src\n+    allocate (a(1), source = src)\n+    if (c_select_part (a) .ne. 5) stop 24 ! \"Source and result must have the same rank\"\n+    deallocate (a)\n+    if (c_select_part (a) .ne. 2) stop 25 ! \"source must not be NULL\"\n+  end subroutine test_CFI_select_part\n+\n+  subroutine test_CFI_setpointer\n+    integer, dimension(2,2), target :: tgt1\n+    integer, dimension(:,:), pointer :: src\n+    type (t), dimension(2), target :: tgt2\n+    type (t), dimension(:), pointer :: res\n+    type (t), dimension(2, 2), target, save :: tgt3\n+    type (t), dimension(:, :), pointer :: src1\n+    integer, dimension(2) :: lbounds = [-1, -2]\n+    src => tgt1\n+    res => tgt2\n+    if (c_setpointer (res, src, lbounds) .ne. 4) stop 26 ! \"Element lengths\"\n+    src1 => tgt3\n+    if (c_setpointer (res, src1, lbounds) .ne. 5) stop 27 ! \"Ranks of result\"\n+  end subroutine test_CFI_setpointer\n+end"}, {"sha": "ad7a9aa8e0bd43a83487a079bf21f072ba8eb400", "filename": "gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -5,7 +5,7 @@\n !\n ! Check that assumed-shape variables are correctly passed to BIND(C)\n ! as defined in TS 29913\n-! \n+!\n interface\n   subroutine test (xx) bind(C, name=\"myBindC\")\n     type(*), dimension(:,:) :: xx\n@@ -20,4 +20,4 @@ end subroutine test\n ! { dg-final { scan-assembler-times \"myBindC,%r2\" 1 { target { hppa*-*-* } } } }\n ! { dg-final { scan-assembler-times \"call\\tmyBindC\" 1 { target { *-*-cygwin* } } } }\n ! { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,myBindC\" 1 { target { s390*-*-* } } } }\n-! { dg-final { scan-tree-dump-times \"test \\\\\\(&parm\\\\.\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"cfi_desc_to_gfc_desc \\\\\\(&parm\\\\.\" 1 \"original\" } }"}, {"sha": "e4a1c119751631481dbe787629d7be997697f3d6", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -1,3 +1,14 @@\n+2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* ISO_Fortran_binding.h : New file.\n+\t* Makefile.am : Include ISO_Fortran_binding.c in the list of\n+\tfiles to compile.\n+\t* Makefile.in : Regenerated.\n+\t* gfortran.map : Add _gfortran_cfi_desc_to_gfc_desc,\n+\t_gfortran_gfc_desc_to_cfi_desc and the CFI API functions.\n+\t* runtime/ISO_Fortran_binding.c : New file containing the new\n+\tfunctions added to the map.\n+\n 2019-01-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libfortran/88807"}, {"sha": "4282cf5f694edbf92d0c23e7f4413f24290e0468", "filename": "libgfortran/ISO_Fortran_binding.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FISO_Fortran_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FISO_Fortran_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FISO_Fortran_binding.h?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,206 @@\n+/* Declarations for ISO Fortran binding.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Daniel Celis Garza  <celisdanieljr@gmail.com>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef ISO_FORTRAN_BINDING_H\n+#define ISO_FORTRAN_BINDING_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>  /* Standard ptrdiff_t tand size_t. */\n+#include <stdint.h>  /* Integer types. */\n+\n+/* Constants, defined as macros. */\n+#define CFI_VERSION 1\n+#define CFI_MAX_RANK 15\n+\n+/* Attributes. */\n+#define CFI_attribute_pointer 0\n+#define CFI_attribute_allocatable 1\n+#define CFI_attribute_other 2\n+\n+/* Error codes.\n+   CFI_INVALID_STRIDE should be defined in the standard because they are useful to the implementation of the functions.\n+ */\n+#define CFI_SUCCESS 0\n+#define CFI_FAILURE 1\n+#define CFI_ERROR_BASE_ADDR_NULL 2\n+#define CFI_ERROR_BASE_ADDR_NOT_NULL 3\n+#define CFI_INVALID_ELEM_LEN 4\n+#define CFI_INVALID_RANK 5\n+#define CFI_INVALID_TYPE 6\n+#define CFI_INVALID_ATTRIBUTE 7\n+#define CFI_INVALID_EXTENT 8\n+#define CFI_INVALID_STRIDE 9\n+#define CFI_INVALID_DESCRIPTOR 10\n+#define CFI_ERROR_MEM_ALLOCATION 11\n+#define CFI_ERROR_OUT_OF_BOUNDS 12\n+\n+/* CFI type definitions. */\n+typedef ptrdiff_t CFI_index_t;\n+typedef int8_t CFI_rank_t;\n+typedef int8_t CFI_attribute_t;\n+typedef int16_t CFI_type_t;\n+\n+/* CFI_dim_t. */\n+typedef struct CFI_dim_t\n+  {\n+    CFI_index_t lower_bound;\n+    CFI_index_t extent;\n+    CFI_index_t sm;\n+  }\n+CFI_dim_t;\n+\n+/* CFI_cdesc_t, C descriptors are cast to this structure as follows:\n+   CFI_CDESC_T(CFI_MAX_RANK) foo;\n+   CFI_cdesc_t * bar = (CFI_cdesc_t *) &foo;\n+ */\n+typedef struct CFI_cdesc_t\n+ {\n+    void *base_addr;\n+    size_t elem_len;\n+    int version;\n+    CFI_rank_t rank;\n+    CFI_attribute_t attribute;\n+    CFI_type_t type;\n+    CFI_dim_t dim[];\n+ }\n+CFI_cdesc_t;\n+\n+/* CFI_CDESC_T with an explicit type. */\n+#define CFI_CDESC_TYPE_T(r, base_type) \\\n+\tstruct { \\\n+\t\tbase_type *base_addr; \\\n+\t\tsize_t elem_len; \\\n+\t\tint version; \\\n+\t\tCFI_rank_t rank; \\\n+\t\tCFI_attribute_t attribute; \\\n+\t\tCFI_type_t type; \\\n+\t\tCFI_dim_t dim[r]; \\\n+\t}\n+#define CFI_CDESC_T(r) CFI_CDESC_TYPE_T (r, void)\n+\n+/* CFI function declarations. */\n+extern void *CFI_address (const CFI_cdesc_t *, const CFI_index_t []);\n+extern int CFI_allocate (CFI_cdesc_t *, const CFI_index_t [], const CFI_index_t [],\n+\t\t\t size_t);\n+extern int CFI_deallocate (CFI_cdesc_t *);\n+extern int CFI_establish (CFI_cdesc_t *, void *, CFI_attribute_t, CFI_type_t, size_t,\n+\t\t\t  CFI_rank_t, const CFI_index_t []);\n+extern int CFI_is_contiguous (const CFI_cdesc_t *);\n+extern int CFI_section (CFI_cdesc_t *, const CFI_cdesc_t *, const CFI_index_t [],\n+\t\t\tconst CFI_index_t [], const CFI_index_t []);\n+extern int CFI_select_part (CFI_cdesc_t *, const CFI_cdesc_t *, size_t, size_t);\n+extern int CFI_setpointer (CFI_cdesc_t *, CFI_cdesc_t *, const CFI_index_t []);\n+\n+/* Types and kind numbers. Allows bitwise and to reveal the intrinsic type of a kind type. It also allows us to find the kind parameter by inverting the bit-shift equation.\n+   CFI_type_kind_shift = 8\n+   CFI_intrinsic_type  = 0 0 0 0 0 0 0 0 0 0 1 0\n+   CFI_type_kind       = 0 0 0 0 0 0 0 0 1 0 0 0\n+   CFI_type_example    = CFI_intrinsic_type + (CFI_type_kind << CFI_type_kind_shift)\n+   Defining the CFI_type_example.\n+   CFI_type_kind       = 0 0 0 0 0 0 0 0 1 0 0 0  << CFI_type_kind_shift\n+\t\t\t-------------------------\n+\t\t\t 1 0 0 0 0 0 0 0 0 0 0 0  +\n+   CFI_intrinsic_type  = 0 0 0 0 0 0 0 0 0 0 1 0\n+\t\t\t-------------------------\n+   CFI_type_example    = 1 0 0 0 0 0 0 0 0 0 1 0\n+   Finding the intrinsic type with the logical mask.\n+   CFI_type_example    = 1 0 0 0 0 0 0 0 0 0 1 0  &\n+   CFI_type_mask       = 0 0 0 0 1 1 1 1 1 1 1 1\n+\t\t\t-------------------------\n+   CFI_intrinsic_type  = 0 0 0 0 0 0 0 0 0 0 1 0\n+   Using the intrinsic type and kind shift to find the kind value of the type.\n+   CFI_type_kind = (CFI_type_example - CFI_intrinsic_type) >> CFI_type_kind_shift\n+   CFI_type_example   = 1 0 0 0 0 0 0 0 0 0 1 0  -\n+   CFI_intrinsic_type = 0 0 0 0 0 0 0 0 0 0 1 0\n+\t\t\t-------------------------\n+\t\t\t1 0 0 0 0 0 0 0 0 0 0 0  >> CFI_type_kind_shift\n+\t\t\t-------------------------\n+   CFI_type_kind      = 0 0 0 0 0 0 0 0 1 0 0 0\n+ */\n+#define CFI_type_mask 0xFF\n+#define CFI_type_kind_shift 8\n+\n+/* Intrinsic types. Their kind number defines their storage size. */\n+#define CFI_type_Integer 1\n+#define CFI_type_Logical 2\n+#define CFI_type_Real 3\n+#define CFI_type_Complex 4\n+#define CFI_type_Character 5\n+\n+/* Types with no kind. */\n+#define CFI_type_struct 6\n+#define CFI_type_cptr 7\n+#define CFI_type_cfunptr 8\n+#define CFI_type_other -1\n+\n+/* Types with kind parameter.\n+   The kind parameter represents the type's byte size. The exception is kind = 10, which has byte size of 64 but 80 bit precision. Complex variables are double the byte size of their real counterparts. The ucs4_char matches wchar_t if sizeof (wchar_t) == 4.\n+ */\n+#define CFI_type_char (CFI_type_Character + (1 << CFI_type_kind_shift))\n+#define CFI_type_ucs4_char (CFI_type_Character + (4 << CFI_type_kind_shift))\n+\n+/* C-Fortran Interoperability types. */\n+#define CFI_type_signed_char (CFI_type_Integer + (1 << CFI_type_kind_shift))\n+#define CFI_type_short (CFI_type_Integer + (2 << CFI_type_kind_shift))\n+#define CFI_type_int (CFI_type_Integer + (4 << CFI_type_kind_shift))\n+#define CFI_type_long (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_long_long (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_size_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_int8_t (CFI_type_Integer + (1 << CFI_type_kind_shift))\n+#define CFI_type_int16_t (CFI_type_Integer + (2 << CFI_type_kind_shift))\n+#define CFI_type_int32_t (CFI_type_Integer + (4 << CFI_type_kind_shift))\n+#define CFI_type_int64_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_int_least8_t (CFI_type_Integer + (1 << CFI_type_kind_shift))\n+#define CFI_type_int_least16_t (CFI_type_Integer + (2 << CFI_type_kind_shift))\n+#define CFI_type_int_least32_t (CFI_type_Integer + (4 << CFI_type_kind_shift))\n+#define CFI_type_int_least64_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_int_fast8_t (CFI_type_Integer + (1 << CFI_type_kind_shift))\n+#define CFI_type_int_fast16_t (CFI_type_Integer + (2 << CFI_type_kind_shift))\n+#define CFI_type_int_fast32_t (CFI_type_Integer + (4 << CFI_type_kind_shift))\n+#define CFI_type_int_fast64_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_intmax_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_intptr_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_ptrdiff_t (CFI_type_Integer + (8 << CFI_type_kind_shift))\n+#define CFI_type_int128_t (CFI_type_Integer + (16 << CFI_type_kind_shift))\n+#define CFI_type_int_least128_t (CFI_type_Integer + (16 << CFI_type_kind_shift))\n+#define CFI_type_int_fast128_t (CFI_type_Integer + (16 << CFI_type_kind_shift))\n+#define CFI_type_Bool (CFI_type_Logical + (1 << CFI_type_kind_shift))\n+#define CFI_type_float (CFI_type_Real + (4 << CFI_type_kind_shift))\n+#define CFI_type_double (CFI_type_Real + (8 << CFI_type_kind_shift))\n+#define CFI_type_long_double (CFI_type_Real + (10 << CFI_type_kind_shift))\n+#define CFI_type_float128 (CFI_type_Real + (16 << CFI_type_kind_shift))\n+#define CFI_type_float_Complex (CFI_type_Complex + (4 << CFI_type_kind_shift))\n+#define CFI_type_double_Complex (CFI_type_Complex + (8 << CFI_type_kind_shift))\n+#define CFI_type_long_double_Complex (CFI_type_Complex + (10 << CFI_type_kind_shift))\n+#define CFI_type_float128_Complex (CFI_type_Complex + (16 << CFI_type_kind_shift))\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* ISO_FORTRAN_BINDING_H */"}, {"sha": "90fdef41097b593c7c3d1ab1c30d81c19b0bf84a", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -30,6 +30,9 @@ version_arg =\n version_dep =\n endif\n \n+gfor_c_HEADERS = $(srcdir)/ISO_Fortran_binding.h\n+gfor_cdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/include\n+\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS)) \\\n \t    $(lt_host_flags)\n \n@@ -783,6 +786,9 @@ $(srcdir)/generated/spread_c8.c \\\n $(srcdir)/generated/spread_c10.c \\\n $(srcdir)/generated/spread_c16.c \n \n+i_isobinding_c = \\\n+$(srcdir)/runtime/ISO_Fortran_binding.c\n+\n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -810,7 +816,7 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n     $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n     $(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n-    $(i_findloc2s_c)\n+    $(i_findloc2s_c) $(i_isobinding_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\"}, {"sha": "ef0f13271e3e502713d8f63d633cbf733eca514c", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -179,7 +179,7 @@ am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps)\n+\t$(am__configure_deps) $(gfor_c_HEADERS)\n am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n  configure.lineno config.status.lineno\n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n@@ -215,7 +215,7 @@ am__uninstall_files_from_dir = { \\\n   }\n am__installdirs = \"$(DESTDIR)$(cafexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \\\n-\t\"$(DESTDIR)$(fincludedir)\"\n+\t\"$(DESTDIR)$(gfor_cdir)\" \"$(DESTDIR)$(fincludedir)\"\n LTLIBRARIES = $(cafexeclib_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libcaf_single_la_LIBADD =\n am_libcaf_single_la_OBJECTS = single.lo\n@@ -378,7 +378,8 @@ am__objects_49 = findloc1_i1.lo findloc1_i2.lo findloc1_i4.lo \\\n \tfindloc1_r16.lo findloc1_c4.lo findloc1_c8.lo findloc1_c16.lo\n am__objects_50 = findloc1_s1.lo findloc1_s4.lo\n am__objects_51 = findloc2_s1.lo findloc2_s4.lo\n-am__objects_52 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_52 = ISO_Fortran_binding.lo\n+am__objects_53 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -393,14 +394,15 @@ am__objects_52 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_40) $(am__objects_41) $(am__objects_42) \\\n \t$(am__objects_43) $(am__objects_44) $(am__objects_45) \\\n \t$(am__objects_46) $(am__objects_47) $(am__objects_48) \\\n-\t$(am__objects_49) $(am__objects_50) $(am__objects_51)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_53 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_49) $(am__objects_50) $(am__objects_51) \\\n+\t$(am__objects_52)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_54 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo async.lo\n-am__objects_54 = size_from_kind.lo $(am__objects_53)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_55 = access.lo c99_functions.lo \\\n+am__objects_55 = size_from_kind.lo $(am__objects_54)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_56 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -410,19 +412,19 @@ am__objects_54 = size_from_kind.lo $(am__objects_53)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_56 = ieee_helper.lo\n-am__objects_57 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_57 = ieee_helper.lo\n+am__objects_58 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n-\tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n-\tselected_char_kind.lo size.lo is_contiguous.lo spread_generic.lo \\\n-\tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n-\treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n-\tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_55) $(am__objects_56)\n-@IEEE_SUPPORT_TRUE@am__objects_58 = ieee_arithmetic.lo \\\n+\tierrno.lo ishftc.lo is_contiguous.lo mvbits.lo move_alloc.lo \\\n+\tpack_generic.lo selected_char_kind.lo size.lo \\\n+\tspread_generic.lo string_intrinsics.lo rand.lo random.lo \\\n+\treshape_generic.lo reshape_packed.lo selected_int_kind.lo \\\n+\tselected_real_kind.lo unpack_generic.lo in_pack_generic.lo \\\n+\tin_unpack_generic.lo $(am__objects_56) $(am__objects_57)\n+@IEEE_SUPPORT_TRUE@am__objects_59 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_59 =\n-am__objects_60 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_60 =\n+am__objects_61 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -446,19 +448,19 @@ am__objects_60 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_61 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_62 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_62 = misc_specifics.lo\n-am__objects_63 = $(am__objects_60) $(am__objects_61) $(am__objects_62) \\\n+am__objects_63 = misc_specifics.lo\n+am__objects_64 = $(am__objects_61) $(am__objects_62) $(am__objects_63) \\\n \tdprod_r8.lo f2c_specifics.lo random_init.lo\n-am__objects_64 = $(am__objects_3) $(am__objects_52) $(am__objects_54) \\\n-\t$(am__objects_57) $(am__objects_58) $(am__objects_59) \\\n-\t$(am__objects_63)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_64)\n+am__objects_65 = $(am__objects_3) $(am__objects_53) $(am__objects_55) \\\n+\t$(am__objects_58) $(am__objects_59) $(am__objects_60) \\\n+\t$(am__objects_64)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_65)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n@@ -531,7 +533,7 @@ am__can_run_installinfo = \\\n     *) (install-info --version) >/dev/null 2>&1;; \\\n   esac\n DATA = $(toolexeclib_DATA)\n-HEADERS = $(nodist_finclude_HEADERS)\n+HEADERS = $(gfor_c_HEADERS) $(nodist_finclude_HEADERS)\n am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \\\n \t$(LISP)config.h.in\n # Read a list of newline-separated strings from the standard input,\n@@ -690,7 +692,6 @@ pdfdir = @pdfdir@\n prefix = @prefix@\n program_transform_name = @program_transform_name@\n psdir = @psdir@\n-runstatedir = @runstatedir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n srcdir = @srcdir@\n@@ -715,6 +716,8 @@ gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n @LIBGFOR_USE_SYMVER_FALSE@version_dep = \n @LIBGFOR_USE_SYMVER_GNU_TRUE@@LIBGFOR_USE_SYMVER_TRUE@version_dep = $(srcdir)/gfortran.map\n @LIBGFOR_USE_SYMVER_SUN_TRUE@@LIBGFOR_USE_SYMVER_TRUE@version_dep = gfortran.map-sun\n+gfor_c_HEADERS = $(srcdir)/ISO_Fortran_binding.h\n+gfor_cdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)/include\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS)) \\\n \t    $(lt_host_flags)\n \n@@ -757,10 +760,10 @@ gfor_helper_src = intrinsics/associated.c intrinsics/abort.c \\\n \tintrinsics/args.c intrinsics/cshift0.c intrinsics/eoshift0.c \\\n \tintrinsics/eoshift2.c intrinsics/erfc_scaled.c \\\n \tintrinsics/extends_type_of.c intrinsics/fnum.c \\\n-\tintrinsics/ierrno.c intrinsics/ishftc.c intrinsics/mvbits.c \\\n+\tintrinsics/ierrno.c intrinsics/ishftc.c \\\n+\tintrinsics/is_contiguous.c intrinsics/mvbits.c \\\n \tintrinsics/move_alloc.c intrinsics/pack_generic.c \\\n \tintrinsics/selected_char_kind.c intrinsics/size.c \\\n-\tintrinsics/is_contiguous.c \\\n \tintrinsics/spread_generic.c intrinsics/string_intrinsics.c \\\n \tintrinsics/rand.c intrinsics/random.c \\\n \tintrinsics/reshape_generic.c intrinsics/reshape_packed.c \\\n@@ -1341,6 +1344,9 @@ $(srcdir)/generated/spread_c8.c \\\n $(srcdir)/generated/spread_c10.c \\\n $(srcdir)/generated/spread_c16.c \n \n+i_isobinding_c = \\\n+$(srcdir)/runtime/ISO_Fortran_binding.c\n+\n m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -1368,7 +1374,7 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n     $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n     $(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n-    $(i_findloc2s_c)\n+    $(i_findloc2s_c) $(i_isobinding_c)\n \n \n # Machine generated specifics\n@@ -1698,6 +1704,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ISO_Fortran_binding.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/abort.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/access.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l1.Plo@am__quote@\n@@ -1892,6 +1899,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/is_contiguous.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ishftc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kill.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortran_c.Plo@am__quote@\n@@ -2199,7 +2207,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/size.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/size_from_kind.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/is_contiguous.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sleep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c16.Plo@am__quote@\n@@ -6089,6 +6096,13 @@ findloc2_s4.lo: $(srcdir)/generated/findloc2_s4.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc2_s4.lo `test -f '$(srcdir)/generated/findloc2_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc2_s4.c\n \n+ISO_Fortran_binding.lo: $(srcdir)/runtime/ISO_Fortran_binding.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ISO_Fortran_binding.lo -MD -MP -MF $(DEPDIR)/ISO_Fortran_binding.Tpo -c -o ISO_Fortran_binding.lo `test -f '$(srcdir)/runtime/ISO_Fortran_binding.c' || echo '$(srcdir)/'`$(srcdir)/runtime/ISO_Fortran_binding.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/ISO_Fortran_binding.Tpo $(DEPDIR)/ISO_Fortran_binding.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$(srcdir)/runtime/ISO_Fortran_binding.c' object='ISO_Fortran_binding.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ISO_Fortran_binding.lo `test -f '$(srcdir)/runtime/ISO_Fortran_binding.c' || echo '$(srcdir)/'`$(srcdir)/runtime/ISO_Fortran_binding.c\n+\n size_from_kind.lo: io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT size_from_kind.lo -MD -MP -MF $(DEPDIR)/size_from_kind.Tpo -c -o size_from_kind.lo `test -f 'io/size_from_kind.c' || echo '$(srcdir)/'`io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/size_from_kind.Tpo $(DEPDIR)/size_from_kind.Plo\n@@ -6285,6 +6299,13 @@ ishftc.lo: intrinsics/ishftc.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ishftc.lo `test -f 'intrinsics/ishftc.c' || echo '$(srcdir)/'`intrinsics/ishftc.c\n \n+is_contiguous.lo: intrinsics/is_contiguous.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT is_contiguous.lo -MD -MP -MF $(DEPDIR)/is_contiguous.Tpo -c -o is_contiguous.lo `test -f 'intrinsics/is_contiguous.c' || echo '$(srcdir)/'`intrinsics/is_contiguous.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/is_contiguous.Tpo $(DEPDIR)/is_contiguous.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='intrinsics/is_contiguous.c' object='is_contiguous.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o is_contiguous.lo `test -f 'intrinsics/is_contiguous.c' || echo '$(srcdir)/'`intrinsics/is_contiguous.c\n+\n mvbits.lo: intrinsics/mvbits.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mvbits.lo -MD -MP -MF $(DEPDIR)/mvbits.Tpo -c -o mvbits.lo `test -f 'intrinsics/mvbits.c' || echo '$(srcdir)/'`intrinsics/mvbits.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/mvbits.Tpo $(DEPDIR)/mvbits.Plo\n@@ -6320,13 +6341,6 @@ size.lo: intrinsics/size.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o size.lo `test -f 'intrinsics/size.c' || echo '$(srcdir)/'`intrinsics/size.c\n \n-is_contiguous.lo: intrinsics/is_contiguous.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT is_contiguous.lo -MD -MP -MF $(DEPDIR)/is_contiguous.Tpo -c -o is_contiguous.lo `test -f 'intrinsics/is_contiguous.c' || echo '$(srcdir)/'`intrinsics/is_contiguous.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/is_contiguous.Tpo $(DEPDIR)/is_contiguous.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='intrinsics/is_contiguous.c' object='is_contiguous.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o is_contiguous.lo `test -f 'intrinsics/is_contiguous.c' || echo '$(srcdir)/'`intrinsics/is_contiguous.c\n-\n spread_generic.lo: intrinsics/spread_generic.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_generic.lo -MD -MP -MF $(DEPDIR)/spread_generic.Tpo -c -o spread_generic.lo `test -f 'intrinsics/spread_generic.c' || echo '$(srcdir)/'`intrinsics/spread_generic.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/spread_generic.Tpo $(DEPDIR)/spread_generic.Plo\n@@ -6664,6 +6678,27 @@ uninstall-toolexeclibDATA:\n \t@list='$(toolexeclib_DATA)'; test -n \"$(toolexeclibdir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \tdir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)\n+install-gfor_cHEADERS: $(gfor_c_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\t@list='$(gfor_c_HEADERS)'; test -n \"$(gfor_cdir)\" || list=; \\\n+\tif test -n \"$$list\"; then \\\n+\t  echo \" $(MKDIR_P) '$(DESTDIR)$(gfor_cdir)'\"; \\\n+\t  $(MKDIR_P) \"$(DESTDIR)$(gfor_cdir)\" || exit 1; \\\n+\tfi; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(gfor_cdir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(gfor_cdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-gfor_cHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(gfor_c_HEADERS)'; test -n \"$(gfor_cdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\tdir='$(DESTDIR)$(gfor_cdir)'; $(am__uninstall_files_from_dir)\n install-nodist_fincludeHEADERS: $(nodist_finclude_HEADERS)\n \t@$(NORMAL_INSTALL)\n \t@list='$(nodist_finclude_HEADERS)'; test -n \"$(fincludedir)\" || list=; \\\n@@ -6749,7 +6784,7 @@ check: $(BUILT_SOURCES)\n \t$(MAKE) $(AM_MAKEFLAGS) check-am\n all-am: Makefile $(LTLIBRARIES) $(DATA) $(HEADERS) config.h all-local\n installdirs:\n-\tfor dir in \"$(DESTDIR)$(cafexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(fincludedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(cafexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(gfor_cdir)\" \"$(DESTDIR)$(fincludedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: $(BUILT_SOURCES)\n@@ -6808,7 +6843,7 @@ info: info-am\n \n info-am:\n \n-install-data-am: install-nodist_fincludeHEADERS\n+install-data-am: install-gfor_cHEADERS install-nodist_fincludeHEADERS\n \n install-dvi: install-dvi-am\n \n@@ -6858,7 +6893,7 @@ ps: ps-am\n \n ps-am:\n \n-uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n+uninstall-am: uninstall-cafexeclibLTLIBRARIES uninstall-gfor_cHEADERS \\\n \tuninstall-nodist_fincludeHEADERS uninstall-toolexeclibDATA \\\n \tuninstall-toolexeclibLTLIBRARIES\n \n@@ -6873,16 +6908,16 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n \tdvi dvi-am html html-am info info-am install install-am \\\n \tinstall-cafexeclibLTLIBRARIES install-data install-data-am \\\n \tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-exec-local install-html install-html-am install-info \\\n-\tinstall-info-am install-man install-nodist_fincludeHEADERS \\\n-\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n-\tinstall-strip install-toolexeclibDATA \\\n+\tinstall-exec-local install-gfor_cHEADERS install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-nodist_fincludeHEADERS install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip install-toolexeclibDATA \\\n \tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n \tinstalldirs maintainer-clean maintainer-clean-generic \\\n \tmaintainer-clean-local mostlyclean mostlyclean-compile \\\n \tmostlyclean-generic mostlyclean-libtool mostlyclean-local pdf \\\n \tpdf-am ps ps-am tags tags-am uninstall uninstall-am \\\n-\tuninstall-cafexeclibLTLIBRARIES \\\n+\tuninstall-cafexeclibLTLIBRARIES uninstall-gfor_cHEADERS \\\n \tuninstall-nodist_fincludeHEADERS uninstall-toolexeclibDATA \\\n \tuninstall-toolexeclibLTLIBRARIES\n "}, {"sha": "531e2ca06705298332f6d12eaea74369d4469a6a", "filename": "libgfortran/configure", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -780,7 +780,6 @@ infodir\n docdir\n oldincludedir\n includedir\n-runstatedir\n localstatedir\n sharedstatedir\n sysconfdir\n@@ -871,7 +870,6 @@ datadir='${datarootdir}'\n sysconfdir='${prefix}/etc'\n sharedstatedir='${prefix}/com'\n localstatedir='${prefix}/var'\n-runstatedir='${localstatedir}/run'\n includedir='${prefix}/include'\n oldincludedir='/usr/include'\n docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\n@@ -1124,15 +1122,6 @@ do\n   | -silent | --silent | --silen | --sile | --sil)\n     silent=yes ;;\n \n-  -runstatedir | --runstatedir | --runstatedi | --runstated \\\n-  | --runstate | --runstat | --runsta | --runst | --runs \\\n-  | --run | --ru | --r)\n-    ac_prev=runstatedir ;;\n-  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \\\n-  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \\\n-  | --run=* | --ru=* | --r=*)\n-    runstatedir=$ac_optarg ;;\n-\n   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n     ac_prev=sbindir ;;\n   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n@@ -1270,7 +1259,7 @@ fi\n for ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n \t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n \t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n-\t\tlibdir localedir mandir runstatedir\n+\t\tlibdir localedir mandir\n do\n   eval ac_val=\\$$ac_var\n   # Remove trailing slashes.\n@@ -1423,7 +1412,6 @@ Fine tuning of the installation directories:\n   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n-  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]\n   --libdir=DIR            object code libraries [EPREFIX/lib]\n   --includedir=DIR        C header files [PREFIX/include]\n   --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n@@ -12696,7 +12684,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12699 \"configure\"\n+#line 12687 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12802,7 +12790,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12805 \"configure\"\n+#line 12793 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16051,7 +16039,7 @@ else\n     We can't simply define LARGE_OFF_T to be 9223372036854775807,\n     since some C++ compilers masquerading as C compilers\n     incorrectly reject 9223372036854775807.  */\n-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))\n+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))\n   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n \t\t       && LARGE_OFF_T % 2147483647 == 1)\n \t\t      ? 1 : -1];\n@@ -16097,7 +16085,7 @@ else\n     We can't simply define LARGE_OFF_T to be 9223372036854775807,\n     since some C++ compilers masquerading as C compilers\n     incorrectly reject 9223372036854775807.  */\n-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))\n+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))\n   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n \t\t       && LARGE_OFF_T % 2147483647 == 1)\n \t\t      ? 1 : -1];\n@@ -16121,7 +16109,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n     We can't simply define LARGE_OFF_T to be 9223372036854775807,\n     since some C++ compilers masquerading as C compilers\n     incorrectly reject 9223372036854775807.  */\n-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))\n+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))\n   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n \t\t       && LARGE_OFF_T % 2147483647 == 1)\n \t\t      ? 1 : -1];\n@@ -16166,7 +16154,7 @@ else\n     We can't simply define LARGE_OFF_T to be 9223372036854775807,\n     since some C++ compilers masquerading as C compilers\n     incorrectly reject 9223372036854775807.  */\n-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))\n+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))\n   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n \t\t       && LARGE_OFF_T % 2147483647 == 1)\n \t\t      ? 1 : -1];\n@@ -16190,7 +16178,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n     We can't simply define LARGE_OFF_T to be 9223372036854775807,\n     since some C++ compilers masquerading as C compilers\n     incorrectly reject 9223372036854775807.  */\n-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))\n+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))\n   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721\n \t\t       && LARGE_OFF_T % 2147483647 == 1)\n \t\t      ? 1 : -1];"}, {"sha": "f7f270bc606df645e7f887e4fdb4d5492429cd97", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -1486,6 +1486,16 @@ GFORTRAN_C99_8 {\n \n GFORTRAN_9 {\n   global:\n+  CFI_address;\n+  CFI_allocate;\n+  CFI_deallocate;\n+  CFI_establish;\n+  CFI_is_contiguous;\n+  CFI_section;\n+  CFI_select_part;\n+  CFI_setpointer;\n+  _gfortran_gfc_desc_to_cfi_desc;\n+  _gfortran_cfi_desc_to_gfc_desc;\n   _gfortran_findloc0_c16;\n   _gfortran_findloc0_c4;\n   _gfortran_findloc0_c8;"}, {"sha": "4161a748b910f963cccc2eb028679934a6ed5bd0", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "added", "additions": 864, "deletions": 0, "changes": 864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf18dc5d248a79a20ebf4b3a751669cd75485fd/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=bbf18dc5d248a79a20ebf4b3a751669cd75485fd", "patch": "@@ -0,0 +1,864 @@\n+/* Functions to convert descriptors between CFI and gfortran\n+   and the CFI function declarations whose prototypes appear\n+   in ISO_Fortran_binding.h.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Daniel Celis Garza  <celisdanieljr@gmail.com>\n+\t       and Paul Thomas  <pault@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <ISO_Fortran_binding.h>\n+#include <string.h>\n+\n+extern void cfi_desc_to_gfc_desc (gfc_array_void *, CFI_cdesc_t **);\n+export_proto(cfi_desc_to_gfc_desc);\n+\n+void\n+cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n+{\n+  int n;\n+  CFI_cdesc_t *s = *s_ptr;\n+\n+  /* If not a full pointer or allocatable array free the descriptor\n+     and return.  */\n+  if (!s || s->attribute == CFI_attribute_other)\n+    goto finish;\n+\n+  GFC_DESCRIPTOR_DATA (d) = s->base_addr;\n+\n+  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)\n+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+  else\n+    GFC_DESCRIPTOR_SIZE (d) =  (index_type)s->dim[0].sm;\n+\n+  d->dtype.version = s->version;\n+  GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;\n+  GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);\n+\n+  /* Correct the unfortunate difference in order with types.  */\n+  if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)\n+    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n+  else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)\n+    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n+\n+  d->dtype.attribute = (signed short)s->attribute;\n+\n+  if (s->rank)\n+    d->span = (index_type)s->dim[0].sm;\n+\n+  /* On the other hand, CFI_establish can change the bounds.  */\n+  d->offset = 0;\n+  for (n = 0; n < GFC_DESCRIPTOR_RANK (d); n++)\n+    {\n+      GFC_DESCRIPTOR_LBOUND(d, n) = (index_type)s->dim[n].lower_bound;\n+      GFC_DESCRIPTOR_UBOUND(d, n) = (index_type)(s->dim[n].extent\n+\t\t\t\t\t\t+ s->dim[n].lower_bound - 1);\n+      GFC_DESCRIPTOR_STRIDE(d, n) = (index_type)(s->dim[n].sm / s->elem_len);\n+      d->offset -= GFC_DESCRIPTOR_STRIDE(d, n) * GFC_DESCRIPTOR_LBOUND(d, n);\n+    }\n+\n+finish:\n+  if (s)\n+    free (s);\n+  s = NULL;\n+}\n+\n+extern void gfc_desc_to_cfi_desc (CFI_cdesc_t **, const gfc_array_void *);\n+export_proto(gfc_desc_to_cfi_desc);\n+\n+void\n+gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n+{\n+  int n;\n+  CFI_cdesc_t *d;\n+\n+  /* Play it safe with allocation of the flexible array member 'dim'\n+     by setting the length to CFI_MAX_RANK. This should not be necessary\n+     but valgrind complains accesses after the allocated block.  */\n+  d = malloc (sizeof (CFI_cdesc_t)\n+\t\t+ (CFI_type_t)(CFI_MAX_RANK * sizeof (CFI_dim_t)));\n+\n+  d->base_addr = GFC_DESCRIPTOR_DATA (s);\n+  d->elem_len = GFC_DESCRIPTOR_SIZE (s);\n+  d->version = s->dtype.version;\n+  d->rank = (CFI_rank_t)GFC_DESCRIPTOR_RANK (s);\n+  d->attribute = (CFI_attribute_t)s->dtype.attribute;\n+\n+  if (GFC_DESCRIPTOR_TYPE (s) == BT_CHARACTER)\n+    d->type = CFI_type_struct;\n+  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)\n+    d->type = CFI_type_Character;\n+  else\n+    d->type = (CFI_type_t)GFC_DESCRIPTOR_TYPE (s);\n+\n+  d->type = (CFI_type_t)(d->type\n+\t\t+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));\n+\n+  /* Full pointer or allocatable arrays have zero lower_bound.  */\n+  for (n = 0; n < GFC_DESCRIPTOR_RANK (s); n++)\n+    {\n+      if (d->attribute == CFI_attribute_other)\n+\td->dim[n].lower_bound = (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n);\n+      else\n+\td->dim[n].lower_bound = 0;\n+\n+      /* Assumed size arrays have gfc ubound == 0 and CFI extent = -1.  */\n+      if ((n == GFC_DESCRIPTOR_RANK (s) - 1)\n+\t  && GFC_DESCRIPTOR_LBOUND(s, n) == 1\n+\t  && GFC_DESCRIPTOR_UBOUND(s, n) == 0)\n+\td->dim[n].extent = -1;\n+      else\n+\td->dim[n].extent = (CFI_index_t)GFC_DESCRIPTOR_UBOUND(s, n)\n+\t\t\t    - (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n) + 1;\n+      d->dim[n].sm = (CFI_index_t)(GFC_DESCRIPTOR_STRIDE(s, n) * s->span);\n+    }\n+\n+  *d_ptr = d;\n+}\n+\n+void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])\n+{\n+  int i;\n+  char *base_addr = (char *)dv->base_addr;\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C Descriptor must not be NULL. */\n+      if (dv == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_address: C Descriptor is NULL.\\n\");\n+\t  return NULL;\n+\t}\n+\n+      /* Base address of C Descriptor must not be NULL. */\n+      if (dv->base_addr == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_address: base address of C Descriptor \"\n+\t\t   \"must not be NULL.\\n\");\n+\t  return NULL;\n+\t}\n+    }\n+\n+  /* Return base address if C descriptor is a scalar. */\n+  if (dv->rank == 0)\n+    return dv->base_addr;\n+\n+  /* Calculate the appropriate base address if dv is not a scalar. */\n+  else\n+    {\n+      /* Base address is the C address of the element of the object\n+\t specified by subscripts. */\n+      for (i = 0; i < dv->rank; i++)\n+\t{\n+\t  if (unlikely (compile_options.bounds_check)\n+\t      && ((dv->dim[i].extent != -1\n+\t\t   && subscripts[i] >= dv->dim[i].extent)\n+\t\t  || subscripts[i] < 0))\n+\t    {\n+\t      fprintf (stderr, \"CFI_address: subscripts[%d], is out of \"\n+\t\t       \"bounds. dv->dim[%d].extent = %d subscripts[%d] \"\n+\t\t       \"= %d.\\n\", i, i, (int)dv->dim[i].extent, i,\n+\t\t       (int)subscripts[i]);\n+              return NULL;\n+            }\n+\n+\t  base_addr = base_addr + (CFI_index_t)(subscripts[i] * dv->dim[i].sm);\n+\t}\n+    }\n+\n+  return (void *)base_addr;\n+}\n+\n+\n+int\n+CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],\n+\t      const CFI_index_t upper_bounds[], size_t elem_len)\n+{\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C Descriptor must not be NULL. */\n+      if (dv == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_allocate: C Descriptor is NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* The C Descriptor must be for an allocatable or pointer object. */\n+      if (dv->attribute == CFI_attribute_other)\n+\t{\n+\t  fprintf (stderr, \"CFI_allocate: The object of the C descriptor \"\n+\t\t   \"must be a pointer or allocatable variable.\\n\");\n+\t  return CFI_INVALID_ATTRIBUTE;\n+\t}\n+\n+      /* Base address of C Descriptor must be NULL. */\n+      if (dv->base_addr != NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_allocate: Base address of C descriptor \"\n+\t\t   \"must be NULL.\\n\");\n+\t  return CFI_ERROR_BASE_ADDR_NOT_NULL;\n+\t}\n+    }\n+\n+  /* If the type is a character, the descriptor's element length is replaced\n+   * by the elem_len argument. */\n+  if (dv->type == CFI_type_char || dv->type == CFI_type_ucs4_char ||\n+      dv->type == CFI_type_signed_char)\n+    dv->elem_len = elem_len;\n+\n+  /* Dimension information and calculating the array length. */\n+  size_t arr_len = 1;\n+\n+  /* If rank is greater than 0, lower_bounds and upper_bounds are used. They're\n+   * ignored otherwhise. */\n+  if (dv->rank > 0)\n+    {\n+      if (unlikely (compile_options.bounds_check)\n+\t  && (lower_bounds == NULL || upper_bounds == NULL))\n+\t{\n+\t  fprintf (stderr, \"CFI_allocate: If 0 < rank (= %d) upper_bounds[] \"\n+\t\t   \"and lower_bounds[], must not be NULL.\\n\", dv->rank);\n+\t  return CFI_INVALID_EXTENT;\n+\t}\n+\n+      for (int i = 0; i < dv->rank; i++)\n+\t{\n+\t  dv->dim[i].lower_bound = lower_bounds[i];\n+\t  dv->dim[i].extent = upper_bounds[i] - dv->dim[i].lower_bound + 1;\n+\t  if (i == 0)\n+\t    dv->dim[i].sm = dv->elem_len;\n+\t  else\n+\t    dv->dim[i].sm = dv->elem_len * dv->dim[i - 1].extent;\n+\t  arr_len *= dv->dim[i].extent;\n+        }\n+    }\n+\n+  dv->base_addr = calloc (arr_len, dv->elem_len);\n+  if (dv->base_addr == NULL)\n+    {\n+      fprintf (stderr, \"CFI_allocate: Failure in memory allocation.\\n\");\n+      return CFI_ERROR_MEM_ALLOCATION;\n+    }\n+\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int\n+CFI_deallocate (CFI_cdesc_t *dv)\n+{\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C Descriptor must not be NULL */\n+      if (dv == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_deallocate: C Descriptor is NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* Base address must not be NULL. */\n+      if (dv->base_addr == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_deallocate: Base address is already NULL.\\n\");\n+\t  return CFI_ERROR_BASE_ADDR_NULL;\n+\t}\n+\n+      /* C Descriptor must be for an allocatable or pointer variable. */\n+      if (dv->attribute == CFI_attribute_other)\n+\t{\n+\t  fprintf (stderr, \"CFI_deallocate: C Descriptor must describe a \"\n+\t\t  \"pointer or allocatable object.\\n\");\n+\t  return CFI_INVALID_ATTRIBUTE;\n+\t}\n+    }\n+\n+  /* Free and nullify memory. */\n+  free (dv->base_addr);\n+  dv->base_addr = NULL;\n+\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n+\t\t   CFI_type_t type, size_t elem_len, CFI_rank_t rank,\n+\t\t   const CFI_index_t extents[])\n+{\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C descriptor must not be NULL. */\n+      if (dv == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_establish: C descriptor is NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* Rank must be between 0 and CFI_MAX_RANK. */\n+      if (rank < 0 || rank > CFI_MAX_RANK)\n+\t{\n+\t  fprintf (stderr, \"CFI_establish: Rank must be between 0 and %d, \"\n+\t\t   \"0 < rank (0 !< %d).\\n\", CFI_MAX_RANK, (int)rank);\n+      return CFI_INVALID_RANK;\n+    }\n+\n+      /* C Descriptor must not be an allocated allocatable. */\n+      if (dv->attribute == CFI_attribute_allocatable && dv->base_addr != NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_establish: If the C Descriptor represents an \"\n+\t\t   \"allocatable variable (dv->attribute = %d), its base \"\n+\t\t   \"address must be NULL (dv->base_addr = NULL).\\n\",\n+\t\t   CFI_attribute_allocatable);\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+       /* If base address is not NULL, the established C Descriptor is for a\n+\t  nonallocatable entity. */\n+      if (attribute == CFI_attribute_allocatable && base_addr != NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_establish: If base address is not NULL \"\n+\t\t   \"(base_addr != NULL), the established C descriptor is \"\n+\t\t   \"for a nonallocatable entity (attribute != %d).\\n\",\n+\t\t   CFI_attribute_allocatable);\n+\t  return CFI_INVALID_ATTRIBUTE;\n+\t}\n+    }\n+\n+  dv->base_addr = base_addr;\n+\n+  if (type == CFI_type_char || type == CFI_type_ucs4_char ||\n+      type == CFI_type_signed_char || type == CFI_type_struct ||\n+      type == CFI_type_other)\n+    dv->elem_len = elem_len;\n+  else\n+    {\n+      /* base_type describes the intrinsic type with kind parameter. */\n+      size_t base_type = type & CFI_type_mask;\n+      /* base_type_size is the size in bytes of the variable as given by its\n+       * kind parameter. */\n+      size_t base_type_size = (type - base_type) >> CFI_type_kind_shift;\n+      /* Kind types 10 have a size of 64 bytes. */\n+      if (base_type_size == 10)\n+\t{\n+\t  base_type_size = 64;\n+\t}\n+      /* Complex numbers are twice the size of their real counterparts. */\n+      if (base_type == CFI_type_Complex)\n+\t{\n+\t  base_type_size *= 2;\n+\t}\n+      dv->elem_len = base_type_size;\n+    }\n+\n+  dv->version = CFI_VERSION;\n+  dv->rank = rank;\n+  dv->attribute = attribute;\n+  dv->type = type;\n+\n+  /* Extents must not be NULL if rank is greater than zero and base_addr is not\n+   * NULL */\n+  if (rank > 0 && base_addr != NULL)\n+    {\n+      if (unlikely (compile_options.bounds_check) && extents == NULL)\n+        {\n+\t  fprintf (stderr, \"CFI_establish: Extents must not be NULL \"\n+\t\t   \"(extents != NULL) if rank (= %d) > 0 nd base address\"\n+\t\t   \"is not NULL (base_addr != NULL).\\n\", (int)rank);\n+\t  return CFI_INVALID_EXTENT;\n+\t}\n+\n+      for (int i = 0; i < rank; i++)\n+\t{\n+\t  /* If the C Descriptor is for a pointer then the lower bounds of every\n+\t   * dimension are set to zero. */\n+\t  if (attribute == CFI_attribute_pointer)\n+\t    dv->dim[i].lower_bound = 0;\n+\t  else\n+\t    dv->dim[i].lower_bound = 1;\n+\n+\t  dv->dim[i].extent = extents[i];\n+\t  if (i == 0)\n+\t    dv->dim[i].sm = dv->elem_len;\n+\t  else\n+\t    dv->dim[i].sm = (CFI_index_t)(dv->elem_len * extents[i - 1]);\n+\t}\n+    }\n+\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int CFI_is_contiguous (const CFI_cdesc_t *dv)\n+{\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C descriptor must not be NULL. */\n+      if (dv == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_is_contiguous: C descriptor is NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* Base address must not be NULL. */\n+      if (dv->base_addr == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_is_contiguous: Base address of C Descriptor \"\n+\t\t   \"is already NULL.\\n\");\n+\t  return CFI_ERROR_BASE_ADDR_NULL;\n+\t}\n+\n+      /* Must be an array. */\n+      if (dv->rank == 0)\n+\t{\n+\t  fprintf (stderr, \"CFI_is_contiguous: C Descriptor must describe an \"\n+\t\t   \"array (0 < dv->rank = %d).\\n\", dv->rank);\n+\t  return CFI_INVALID_RANK;\n+\t}\n+    }\n+\n+  /* Assumed size arrays are always contiguous.  */\n+  if (dv->rank > 0 && dv->dim[dv->rank - 1].extent == -1)\n+    return CFI_SUCCESS;\n+\n+  /* If an array is not contiguous the memory stride is different to the element\n+   * length. */\n+  for (int i = 0; i < dv->rank; i++)\n+    {\n+      if (i == 0 && dv->dim[i].sm == (CFI_index_t)dv->elem_len)\n+\tcontinue;\n+      else if (i > 0\n+\t       && dv->dim[i].sm == (CFI_index_t)(dv->elem_len\n+\t\t\t\t   * dv->dim[i - 1].extent))\n+\tcontinue;\n+\n+      return CFI_FAILURE;\n+    }\n+\n+  /* Array sections are guaranteed to be contiguous by the previous test.  */\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n+\t\t const CFI_index_t lower_bounds[],\n+\t\t const CFI_index_t upper_bounds[], const CFI_index_t strides[])\n+{\n+  /* Dimension information. */\n+  CFI_index_t lower[CFI_MAX_RANK];\n+  CFI_index_t upper[CFI_MAX_RANK];\n+  CFI_index_t stride[CFI_MAX_RANK];\n+  int zero_count = 0;\n+  bool assumed_size;\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C Descriptors must not be NULL. */\n+      if (source == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Source must not be  NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      if (result == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Result must not be NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* Base address of source must not be NULL. */\n+      if (source->base_addr == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Base address of source must \"\n+\t\t   \"not be NULL.\\n\");\n+\t  return CFI_ERROR_BASE_ADDR_NULL;\n+\t}\n+\n+      /* Result must not be an allocatable array. */\n+      if (result->attribute == CFI_attribute_allocatable)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Result must not describe an \"\n+\t\t   \"allocatable array.\\n\");\n+\t  return CFI_INVALID_ATTRIBUTE;\n+\t}\n+\n+      /* Source must be some form of array (nonallocatable nonpointer array,\n+\t allocated allocatable array or an associated pointer array). */\n+      if (source->rank <= 0)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Source must describe an array \"\n+\t\t       \"(0 < source->rank, 0 !< %d).\\n\", source->rank);\n+\t  return CFI_INVALID_RANK;\n+\t}\n+\n+      /* Element lengths of source and result must be equal. */\n+      if (result->elem_len != source->elem_len)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: The element lengths of \"\n+\t\t   \"source (source->elem_len = %d) and result \"\n+\t\t   \"(result->elem_len = %d) must be equal.\\n\",\n+\t\t   (int)source->elem_len, (int)result->elem_len);\n+\t  return CFI_INVALID_ELEM_LEN;\n+\t}\n+\n+      /* Types must be equal. */\n+      if (result->type != source->type)\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Types of source \"\n+\t\t   \"(source->type = %d) and result (result->type = %d) \"\n+\t\t   \"must be equal.\\n\", source->type, result->type);\n+\t  return CFI_INVALID_TYPE;\n+\t}\n+    }\n+\n+  /* Stride of zero in the i'th dimension means rank reduction in that\n+     dimension. */\n+  for (int i = 0; i < source->rank; i++)\n+    {\n+      if (strides[i] == 0)\n+\tzero_count++;\n+    }\n+\n+  /* Rank of result must be equal the the rank of source minus the number of\n+   * zeros in strides. */\n+  if (unlikely (compile_options.bounds_check)\n+      && result->rank != source->rank - zero_count)\n+    {\n+      fprintf (stderr, \"CFI_section: Rank of result must be equal to the \"\n+\t\t       \"rank of source minus the number of zeros in strides \"\n+\t\t       \"(result->rank = source->rank - zero_count, %d != %d \"\n+\t\t       \"- %d).\\n\", result->rank, source->rank, zero_count);\n+      return CFI_INVALID_RANK;\n+    }\n+\n+  /* Lower bounds. */\n+  if (lower_bounds == NULL)\n+    {\n+      for (int i = 0; i < source->rank; i++)\n+\tlower[i] = source->dim[i].lower_bound;\n+    }\n+  else\n+    {\n+      for (int i = 0; i < source->rank; i++)\n+\tlower[i] = lower_bounds[i];\n+    }\n+\n+  /* Upper bounds. */\n+  if (upper_bounds == NULL)\n+    {\n+      if (unlikely (compile_options.bounds_check)\n+\t  && source->dim[source->rank - 1].extent == -1)\n+        {\n+\t  fprintf (stderr, \"CFI_section: Source must not be an assumed size \"\n+\t\t   \"array if upper_bounds is NULL.\\n\");\n+\t  return CFI_INVALID_EXTENT;\n+\t}\n+\n+      for (int i = 0; i < source->rank; i++)\n+\tupper[i] = source->dim[i].lower_bound + source->dim[i].extent - 1;\n+    }\n+  else\n+    {\n+      for (int i = 0; i < source->rank; i++)\n+\tupper[i] = upper_bounds[i];\n+    }\n+\n+  /* Stride */\n+  if (strides == NULL)\n+    {\n+      for (int i = 0; i < source->rank; i++)\n+\tstride[i] = 1;\n+    }\n+  else\n+    {\n+      for (int i = 0; i < source->rank; i++)\n+\t{\n+\t  stride[i] = strides[i];\n+\t  /* If stride[i] == 0 then lower[i] and upper[i] must be equal. */\n+\t  if (unlikely (compile_options.bounds_check)\n+\t      && stride[i] == 0 && lower[i] != upper[i])\n+\t    {\n+\t      fprintf (stderr, \"CFI_section: If strides[%d] = 0, then the \"\n+\t\t       \"lower bounds, lower_bounds[%d] = %d, and \"\n+\t\t       \"upper_bounds[%d] = %d, must be equal.\\n\",\n+\t\t       i, i, (int)lower_bounds[i], i, (int)upper_bounds[i]);\n+\t      return CFI_ERROR_OUT_OF_BOUNDS;\n+\t    }\n+\t}\n+    }\n+\n+  /* Check that section upper and lower bounds are within the array bounds. */\n+  for (int i = 0; i < source->rank; i++)\n+    {\n+      assumed_size = (i == source->rank - 1)\n+\t\t     && (source->dim[i].extent == -1);\n+      if (unlikely (compile_options.bounds_check)\n+\t  && lower_bounds != NULL\n+\t  && (lower[i] < source->dim[i].lower_bound ||\n+\t      (!assumed_size && lower[i] > source->dim[i].lower_bound\n+\t\t\t\t\t   + source->dim[i].extent - 1)))\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Lower bounds must be within the \"\n+\t\t   \"bounds of the fortran array (source->dim[%d].lower_bound \"\n+\t\t   \"<= lower_bounds[%d] <= source->dim[%d].lower_bound \"\n+\t\t   \"+ source->dim[%d].extent - 1, %d <= %d <= %d).\\n\",\n+\t\t   i, i, i, i, (int)source->dim[i].lower_bound, (int)lower[i],\n+\t\t   (int)(source->dim[i].lower_bound\n+\t\t\t + source->dim[i].extent - 1));\n+\t  return CFI_ERROR_OUT_OF_BOUNDS;\n+        }\n+\n+      if (unlikely (compile_options.bounds_check)\n+\t  && upper_bounds != NULL\n+\t  && (upper[i] < source->dim[i].lower_bound\n+\t      || (!assumed_size\n+\t\t  && upper[i] > source->dim[i].lower_bound\n+\t\t\t\t+ source->dim[i].extent - 1)))\n+\t{\n+\t  fprintf (stderr, \"CFI_section: Upper bounds must be within the \"\n+\t\t   \"bounds of the fortran array (source->dim[%d].lower_bound \"\n+\t\t   \"<= upper_bounds[%d] <= source->dim[%d].lower_bound + \"\n+\t\t   \"source->dim[%d].extent - 1, %d !<= %d !<= %d).\\n\",\n+\t\t   i, i, i, i, (int)source->dim[i].lower_bound, (int)upper[i],\n+\t\t   (int)(source->dim[i].lower_bound\n+\t\t\t + source->dim[i].extent - 1));\n+\t  return CFI_ERROR_OUT_OF_BOUNDS;\n+\t}\n+\n+      if (unlikely (compile_options.bounds_check)\n+\t  && upper[i] < lower[i] && stride[i] >= 0)\n+        {\n+          fprintf (stderr, \"CFI_section: If the upper bound is smaller than \"\n+\t\t   \"the lower bound for a given dimension (upper[%d] < \"\n+\t\t   \"lower[%d], %d < %d), then he stride for said dimension\"\n+\t\t   \"t must be negative (stride[%d] < 0, %d < 0).\\n\",\n+\t\t   i, i, (int)upper[i], (int)lower[i], i, (int)stride[i]);\n+\t  return CFI_INVALID_STRIDE;\n+\t}\n+    }\n+\n+  /* Set the appropriate dimension information that gives us access to the\n+   * data. */\n+  int aux = 0;\n+  for (int i = 0; i < source->rank; i++)\n+    {\n+      if (stride[i] == 0)\n+\t{\n+\t  aux++;\n+\t  /* Adjust 'lower' for the base address offset.  */\n+\t  lower[i] = lower[i] - source->dim[i].lower_bound;\n+\t  continue;\n+\t}\n+      int idx = i - aux;\n+      result->dim[idx].lower_bound = lower[i];\n+      result->dim[idx].extent = upper[i] - lower[i] + 1;\n+      result->dim[idx].sm = stride[i] * source->dim[i].sm;\n+      /* Adjust 'lower' for the base address offset.  */\n+      lower[idx] = lower[idx] - source->dim[i].lower_bound;\n+    }\n+\n+  /* Set the base address. */\n+  result->base_addr = CFI_address (source, lower);\n+\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n+\t\t     size_t displacement, size_t elem_len)\n+{\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* C Descriptors must not be NULL. */\n+      if (source == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Source must not be NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      if (result == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Result must not be NULL.\\n\");\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+\n+      /* Attribute of result will be CFI_attribute_other or\n+\t CFI_attribute_pointer. */\n+      if (result->attribute == CFI_attribute_allocatable)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Result must not describe an \"\n+\t\t   \"allocatable object (result->attribute != %d).\\n\",\n+\t\t   CFI_attribute_allocatable);\n+\t  return CFI_INVALID_ATTRIBUTE;\n+\t}\n+\n+      /* Base address of source must not be NULL. */\n+      if (source->base_addr == NULL)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Base address of source must \"\n+\t\t   \"not be NULL.\\n\");\n+\t  return CFI_ERROR_BASE_ADDR_NULL;\n+\t}\n+\n+      /* Source and result must have the same rank. */\n+      if (source->rank != result->rank)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Source and result must have \"\n+\t\t   \"the same rank (source->rank = %d, result->rank = %d).\\n\",\n+\t\t   (int)source->rank, (int)result->rank);\n+\t  return CFI_INVALID_RANK;\n+\t}\n+\n+      /* Nonallocatable nonpointer must not be an assumed size array. */\n+      if (source->rank > 0 && source->dim[source->rank - 1].extent == -1)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Source must not describe an \"\n+\t\t   \"assumed size array  (source->dim[%d].extent != -1).\\n\",\n+\t\t   source->rank - 1);\n+\t  return CFI_INVALID_DESCRIPTOR;\n+\t}\n+    }\n+\n+  /* Element length. */\n+  if (result->type == CFI_type_char || result->type == CFI_type_ucs4_char ||\n+      result->type == CFI_type_signed_char)\n+    result->elem_len = elem_len;\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      /* Ensure displacement is within the bounds of the element length\n+\t of source.*/\n+      if (displacement > source->elem_len - 1)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Displacement must be within the \"\n+\t\t   \"bounds of source (0 <= displacement <= source->elem_len \"\n+\t\t   \"- 1, 0 <= %d <= %d).\\n\", (int)displacement,\n+\t\t   (int)(source->elem_len - 1));\n+\t  return CFI_ERROR_OUT_OF_BOUNDS;\n+\t}\n+\n+      /* Ensure displacement and element length of result are less than or\n+\t equal to the element length of source. */\n+      if (displacement + result->elem_len > source->elem_len)\n+\t{\n+\t  fprintf (stderr, \"CFI_select_part: Displacement plus the element \"\n+\t\t   \"length of result must be less than or equal to the \"\n+\t\t   \"element length of source (displacement + result->elem_len \"\n+\t\t   \"<= source->elem_len, %d + %d = %d <= %d).\\n\",\n+\t\t   (int)displacement, (int)result->elem_len,\n+\t\t   (int)(displacement + result->elem_len),\n+\t\t   (int)source->elem_len);\n+\t  return CFI_ERROR_OUT_OF_BOUNDS;\n+\t}\n+    }\n+\n+  if (result->rank > 0)\n+    {\n+      for (int i = 0; i < result->rank; i++)\n+\t{\n+\t  result->dim[i].lower_bound = source->dim[i].lower_bound;\n+\t  result->dim[i].extent = source->dim[i].extent;\n+\t  result->dim[i].sm = source->dim[i].sm;\n+        }\n+    }\n+\n+  result->base_addr = (char *) source->base_addr + displacement;\n+  return CFI_SUCCESS;\n+}\n+\n+\n+int CFI_setpointer (CFI_cdesc_t *result, CFI_cdesc_t *source,\n+\t\t    const CFI_index_t lower_bounds[])\n+{\n+  /* Result must not be NULL. */\n+  if (unlikely (compile_options.bounds_check) && result == NULL)\n+    {\n+      fprintf (stderr, \"CFI_setpointer: Result is NULL.\\n\");\n+      return CFI_INVALID_DESCRIPTOR;\n+    }\n+\n+  /* If source is NULL, the result is a C Descriptor that describes a\n+   * disassociated pointer. */\n+  if (source == NULL)\n+    {\n+      result->base_addr = NULL;\n+      result->version  = CFI_VERSION;\n+      result->attribute = CFI_attribute_pointer;\n+    }\n+  else\n+    {\n+      /* Check that element lengths, ranks and types of source and result are\n+       * the same. */\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  if (result->elem_len != source->elem_len)\n+\t    {\n+\t      fprintf (stderr, \"CFI_setpointer: Element lengths of result \"\n+\t\t       \"(result->elem_len = %d) and source (source->elem_len \"\n+\t\t       \"= %d) must be the same.\\n\", (int)result->elem_len,\n+\t\t       (int)source->elem_len);\n+\t      return CFI_INVALID_ELEM_LEN;\n+\t    }\n+\n+\t  if (result->rank != source->rank)\n+\t    {\n+\t      fprintf (stderr, \"CFI_setpointer: Ranks of result (result->rank \"\n+\t\t       \"= %d) and source (source->rank = %d) must be the same.\"\n+\t\t       \"\\n\", result->rank, source->rank);\n+\t      return CFI_INVALID_RANK;\n+\t    }\n+\n+\t  if (result->type != source->type)\n+\t    {\n+\t      fprintf (stderr, \"CFI_setpointer: Types of result (result->type\"\n+\t\t       \"= %d) and source (source->type = %d) must be the same.\"\n+\t\t       \"\\n\", result->type, source->type);\n+\t      return CFI_INVALID_TYPE;\n+\t    }\n+\t}\n+\n+      /* If the source is a disassociated pointer, the result must also describe\n+       * a disassociated pointer. */\n+      if (source->base_addr == NULL &&\n+          source->attribute == CFI_attribute_pointer)\n+\tresult->base_addr = NULL;\n+      else\n+\tresult->base_addr = source->base_addr;\n+\n+      /* Assign components to result. */\n+      result->version = source->version;\n+      result->attribute = source->attribute;\n+\n+      /* Dimension information. */\n+      for (int i = 0; i < source->rank; i++)\n+\t{\n+\t  if (lower_bounds != NULL)\n+\t    result->dim[i].lower_bound = lower_bounds[i];\n+\t  else\n+\t    result->dim[i].lower_bound = source->dim[i].lower_bound;\n+\n+\t  result->dim[i].extent = source->dim[i].extent;\n+\t  result->dim[i].sm = source->dim[i].sm;\n+\t}\n+    }\n+\n+  return CFI_SUCCESS;\n+}"}]}