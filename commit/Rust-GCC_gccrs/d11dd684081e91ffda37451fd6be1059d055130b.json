{"sha": "d11dd684081e91ffda37451fd6be1059d055130b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExZGQ2ODQwODFlOTFmZmRhMzc0NTFmZDZiZTEwNTlkMDU1MTMwYg==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2005-05-24T22:21:01Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-05-24T22:21:01Z"}, "message": "objc-act.c (objc_build_struct): New function.\n\n        * objc-act.c (objc_build_struct): New function.\n        (objc_derived_from_p): Likewise.\n        (objc_build_component_ref): Likewise.\n        (objc_copy_binfo): Likewise.\n        (objc_xref_basetypes): Likewise.\n        (objc_lookup_protocol): Likewise.\n        (objc_compare_protocols): Likewise.\n        (objc_volatilize_decl): Likewise.\n        (encode_aggregate_fields): Likewise.\n        (volatilized_hash): Likewise.\n        (volatilized_eq): Likewise.\n        (objc_compare_types): Likewise.\n        (objc_type_quals_match): Likewise.\n        (DERIVED_FROM_P): New ObjC macro, corresponding to C++ macro\n        of same name.\n        (get_class_ivars): Add second parameter indicating if entire\n        hierarchy is desired.\n        (struct volatilized_type): New type.\n        (volatilized_htab): New hash table.\n        (objc_types_compatible_p, objc_comptypes): Remove functions.\n        (synth_module_prologue): Do not initialize 'unused_list'.\n        (objc_get_class_reference): Fix ObjC++ impedance mismatches.\n        (objc_declare_alias): Implement as a typedef.\n        (objc_substitute_decl, objc_gimplify_expr): Reformat.\n        (objc_get_class_ivars): Adjust call to get_class_ivars().\n        (next_sjlj_build_enter_and_setjmp, synth_forward_declarations,\n        build_ivar_reference, get_super_receiver): Call\n        objc_build_component_ref() instead of build_component_ref().\n        (objc_begin_catch_clause): Use DERIVED_FROM_P() instead of\n        objc_comptypes().\n        (build_private_template): Call objc_build_struct() instead of\n        start_struct() and finish_struct().\n        (hash_init): Initialize volatilized_htab.\n        (objc_is_public): Adjust calls to objc_get_ivars(); adjust\n        ObjC++ impedance mismatches.\n        (encode_aggregate_within): Streamline by calling\n        encode_aggregate_fields().\n        * objc-act.h (objc_types_compatible_p): Remove prototype.\n        (OCTI_UNUSED_LIST, unused_list): Remove slot.\n        * objc-lang.c (LANG_HOOKS_TYPES_COMPATIBLE_P): Remove.\n\nFrom-SVN: r100123", "tree": {"sha": "7db8d120f1a3e40bd8e85d5c3ff0bda8bc25d200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7db8d120f1a3e40bd8e85d5c3ff0bda8bc25d200"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d11dd684081e91ffda37451fd6be1059d055130b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11dd684081e91ffda37451fd6be1059d055130b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11dd684081e91ffda37451fd6be1059d055130b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11dd684081e91ffda37451fd6be1059d055130b/comments", "author": null, "committer": null, "parents": [{"sha": "18d311d8d8d85acc1062a5699079464ca79af978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d311d8d8d85acc1062a5699079464ca79af978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18d311d8d8d85acc1062a5699079464ca79af978"}], "stats": {"total": 991, "additions": 611, "deletions": 380}, "files": [{"sha": "9059696c78add8c588638ee7b79e6ee8521c9db4", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=d11dd684081e91ffda37451fd6be1059d055130b", "patch": "@@ -1,3 +1,46 @@\n+2005-05-24  Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* objc-act.c (objc_build_struct): New function.\n+\t(objc_derived_from_p): Likewise.\n+\t(objc_build_component_ref): Likewise.\n+\t(objc_copy_binfo): Likewise.\n+\t(objc_xref_basetypes): Likewise.\n+\t(objc_lookup_protocol): Likewise.\n+\t(objc_compare_protocols): Likewise.\n+\t(objc_volatilize_decl): Likewise.\n+\t(encode_aggregate_fields): Likewise.\n+\t(volatilized_hash): Likewise.\n+\t(volatilized_eq): Likewise.\n+\t(objc_compare_types): Likewise.\n+\t(objc_type_quals_match): Likewise.\n+\t(DERIVED_FROM_P): New ObjC macro, corresponding to C++ macro\n+\tof same name.\n+\t(get_class_ivars): Add second parameter indicating if entire\n+\thierarchy is desired.\n+\t(struct volatilized_type): New type.\n+\t(volatilized_htab): New hash table.\n+\t(objc_types_compatible_p, objc_comptypes): Remove functions.\n+\t(synth_module_prologue): Do not initialize 'unused_list'.\n+\t(objc_get_class_reference): Fix ObjC++ impedance mismatches.\n+\t(objc_declare_alias): Implement as a typedef.\n+\t(objc_substitute_decl, objc_gimplify_expr): Reformat.\n+\t(objc_get_class_ivars): Adjust call to get_class_ivars().\n+\t(next_sjlj_build_enter_and_setjmp, synth_forward_declarations,\n+\tbuild_ivar_reference, get_super_receiver): Call\n+\tobjc_build_component_ref() instead of build_component_ref().\n+\t(objc_begin_catch_clause): Use DERIVED_FROM_P() instead of\n+\tobjc_comptypes().\n+\t(build_private_template): Call objc_build_struct() instead of\n+\tstart_struct() and finish_struct().\n+\t(hash_init): Initialize volatilized_htab.\n+\t(objc_is_public): Adjust calls to objc_get_ivars(); adjust\n+\tObjC++ impedance mismatches.\n+\t(encode_aggregate_within): Streamline by calling\n+\tencode_aggregate_fields().\n+\t* objc-act.h (objc_types_compatible_p): Remove prototype.\n+\t(OCTI_UNUSED_LIST, unused_list): Remove slot.\n+\t* objc-lang.c (LANG_HOOKS_TYPES_COMPATIBLE_P): Remove.\n+\n 2005-05-18  Geoffrey Keating  <geoffk@apple.com>\n \n \t* Make-lang.in (cc1obj-dummy): New."}, {"sha": "0d27a248c47a9000a046060daf1b35806d584ed9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 568, "deletions": 375, "changes": 943, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d11dd684081e91ffda37451fd6be1059d055130b", "patch": "@@ -169,12 +169,20 @@ static tree is_ivar (tree, tree);\n static void build_objc_exception_stuff (void);\n static void build_next_objc_exception_stuff (void);\n \n+/* We only need the following for ObjC; ObjC++ will use C++'s definition\n+   of DERIVED_FROM_P.  */\n+#ifndef OBJCPLUS\n+static bool objc_derived_from_p (tree, tree);\n+#define DERIVED_FROM_P(PARENT, CHILD) objc_derived_from_p (PARENT, CHILD)\n+#endif\n+static void objc_xref_basetypes (tree, tree);\n+\n static void build_class_template (void);\n static void build_selector_template (void);\n static void build_category_template (void);\n static void build_super_template (void);\n static tree build_protocol_initializer (tree, tree, tree, tree, tree);\n-static tree get_class_ivars (tree);\n+static tree get_class_ivars (tree, bool);\n static tree generate_protocol_list (tree);\n static void build_protocol_reference (tree);\n \n@@ -388,6 +396,14 @@ struct string_descriptor GTY(())\n \n static GTY((param_is (struct string_descriptor))) htab_t string_htab;\n \n+/* Store the EH-volatilized types in a hash table, for easy retrieval.  */\n+struct volatilized_type GTY(())\n+{\n+  tree type;\n+};\n+\n+static GTY((param_is (struct volatilized_type))) htab_t volatilized_htab;\n+\n FILE *gen_declaration_file;\n \n /* Tells \"encode_pointer/encode_aggregate\" whether we are generating\n@@ -777,351 +793,470 @@ objc_is_class_id (tree type)\n   return OBJC_TYPE_NAME (type) == objc_class_id;\n }\n \n+/* Construct a C struct with tag NAME, a base struct with tag\n+   SUPER_NAME (if any), and FIELDS indicated.  */\n \n-int\n-objc_types_compatible_p (tree type1, tree type2)\n+static tree\n+objc_build_struct (tree name, tree fields, tree super_name)\n+{\n+  tree s = start_struct (RECORD_TYPE, name);\n+  tree super = (super_name ? xref_tag (RECORD_TYPE, super_name) : NULL_TREE);\n+\n+  if (super)\n+    {\n+      /* Prepend a packed variant of the base class into the layout.  This\n+\t is necessary to preserve ObjC ABI compatibility.  */\n+      tree base = build_decl (FIELD_DECL, NULL_TREE, super);\n+      tree field = TYPE_FIELDS (super);\n+\n+      while (field && TREE_CHAIN (field)\n+\t     && TREE_CODE (TREE_CHAIN (field)) == FIELD_DECL)\n+\tfield = TREE_CHAIN (field);\n+\n+      /* For ObjC ABI purposes, the \"packed\" size of a base class is\n+\t the the sum of the offset and the size (in bits) of the last\n+\t field in the class.  */\n+      DECL_SIZE (base)\n+\t= (field && TREE_CODE (field) == FIELD_DECL\n+\t   ? size_binop (PLUS_EXPR, \n+\t\t\t size_binop (PLUS_EXPR,\n+\t\t\t\t     size_binop\n+\t\t\t\t     (MULT_EXPR,\n+\t\t\t\t      convert (bitsizetype,\n+\t\t\t\t\t       DECL_FIELD_OFFSET (field)),\n+\t\t\t\t      bitsize_int (BITS_PER_UNIT)),\n+\t\t\t\t     DECL_FIELD_BIT_OFFSET (field)),\n+\t\t\t DECL_SIZE (field))\n+\t   : bitsize_zero_node);\n+      DECL_SIZE_UNIT (base)\n+\t= size_binop (FLOOR_DIV_EXPR, convert (sizetype, DECL_SIZE (base)),\n+\t\t      size_int (BITS_PER_UNIT));\n+      DECL_ARTIFICIAL (base) = 1;\n+      DECL_ALIGN (base) = 1;\n+      DECL_FIELD_CONTEXT (base) = s;\n+#ifdef OBJCPLUS\n+      DECL_FIELD_IS_BASE (base) = 1;\n+\n+      if (fields)\n+\tTREE_NO_WARNING (fields) = 1;\t/* Suppress C++ ABI warnings -- we   */\n+#endif\t\t\t\t\t/* are following the ObjC ABI here.  */\n+      TREE_CHAIN (base) = fields;\n+      fields = base;\n+    }\n+\n+  s = finish_struct (s, fields, NULL_TREE);\n+\n+  /* Use TYPE_BINFO structures to point at the super class, if any.  */\n+  objc_xref_basetypes (s, super);\n+\n+  return s;\n+}\n+\n+/* Mark DECL as being 'volatile' for purposes of Darwin\n+   _setjmp()/_longjmp() exception handling.  Called from\n+   objc_mark_locals_volatile().  */\n+void\n+objc_volatilize_decl (tree decl)\n+{\n+  /* Do not mess with variables that are 'static' or (already)\n+     'volatile'.  */\n+  if (!TREE_THIS_VOLATILE (decl) && !TREE_STATIC (decl)\n+      && (TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == PARM_DECL))\n+    {\n+      tree t = TREE_TYPE (decl);\n+      struct volatilized_type key;\n+      void **loc;\n+\n+      t = build_qualified_type (t, (TYPE_QUALS (t)\n+\t\t\t\t    | TYPE_QUAL_VOLATILE));\n+      key.type = t;\n+      loc = htab_find_slot (volatilized_htab, &key, INSERT);\n+\n+      if (!*loc)\n+\t{\n+\t  *loc = ggc_alloc (sizeof (key));\n+\t  ((struct volatilized_type *) *loc)->type = t;\n+\t}\n+\n+      TREE_TYPE (decl) = t;\n+      TREE_THIS_VOLATILE (decl) = 1;\n+      TREE_SIDE_EFFECTS (decl) = 1;\n+      DECL_REGISTER (decl) = 0;\n+#ifndef OBJCPLUS\n+      C_DECL_REGISTER (decl) = 0;\n+#endif\n+    }\n+}\n+\n+/* Check if protocol PROTO is adopted (directly or indirectly) by class CLS\n+   (including its categoreis and superclasses) or by object type TYP.\n+   Issue a warning if PROTO is not adopted anywhere and WARN is set.  */\n+\n+static bool\n+objc_lookup_protocol (tree proto, tree cls, tree typ, bool warn)\n {\n+  bool class_type = (cls != NULL_TREE);\n \n-  if (objc_is_object_ptr (type1) || objc_is_object_ptr (type2)\n-      || objc_is_class_name (type1) || objc_is_class_name (type2))\n+  while (cls)\n     {\n-      return lhd_types_compatible_p (type1, type2);\n+      tree c;\n+\n+      /* Check protocols adopted by the class and its categories.  */\n+      for (c = cls; c; c = CLASS_CATEGORY_LIST (c))\n+\t{\n+\t  if (lookup_protocol_in_reflist (CLASS_PROTOCOL_LIST (c), proto))\n+\t    return true;\n+\t}\n+\n+      /* Repeat for superclasses.  */\n+      cls = lookup_interface (CLASS_SUPER_NAME (cls));\n     }\n-  else\n+\n+  /* Check for any protocols attached directly to the object type.  */\n+  if (TYPE_HAS_OBJC_INFO (typ))\n     {\n-#ifdef OBJCPLUS\n-      return cxx_types_compatible_p (type1, type2);\n-#else\n-      return c_types_compatible_p (type1, type2);\n-#endif\n+      if (lookup_protocol_in_reflist (TYPE_OBJC_PROTOCOL_LIST (typ), proto))\n+\treturn true;\n+    }\n+\n+  if (warn)\n+    {\n+      strcpy (errbuf, class_type ? \"class \\'\" : \"type \\'\");\n+      gen_type_name_0 (class_type ? typ : TYPE_POINTER_TO (typ));\n+      strcat (errbuf, \"\\' does not \");\n+      /* NB: Types 'id' and 'Class' cannot reasonably be described as\n+\t \"implementing\" a given protocol, since they do not have an\n+\t implementation.  */\n+      strcat (errbuf, class_type ? \"implement\" : \"conform to\");\n+      strcat (errbuf, \" the \\'\");\n+      strcat (errbuf, IDENTIFIER_POINTER (PROTOCOL_NAME (proto)));\n+      strcat (errbuf, \"\\' protocol\");\n+      warning (0, errbuf);\n     }\n+\n+  return false;\n }\n \n+/* Check if class RCLS and instance struct type RTYP conform to at least the\n+   same protocols that LCLS and LTYP conform to.  */\n+\n+static bool\n+objc_compare_protocols (tree lcls, tree ltyp, tree rcls, tree rtyp, bool warn)\n+{\n+  tree p;\n+  bool have_lproto = false;\n+\n+  while (lcls)\n+    {\n+      /* NB: We do _not_ look at categories defined for LCLS; these may or\n+\t may not get loaded in, and therefore it is unreasonable to require\n+\t that RCLS/RTYP must implement any of their protocols.  */\n+      for (p = CLASS_PROTOCOL_LIST (lcls); p; p = TREE_CHAIN (p))\n+\t{\n+\t  have_lproto = true;\n \n-/* Return 1 if LHS and RHS are compatible types for assignment or\n-   various other operations.  Return 0 if they are incompatible, and\n-   return -1 if we choose to not decide (because the types are really\n-   just C types, not ObjC specific ones).  When the operation is\n-   REFLEXIVE (typically comparisons), check for compatibility in\n-   either direction; when it's not (typically assignments), don't.\n+\t  if (!objc_lookup_protocol (TREE_VALUE (p), rcls, rtyp, warn))\n+\t    return warn;\n+\t}\n \n-   This function is called in two cases: when both lhs and rhs are\n-   pointers to records (in which case we check protocols too), and\n-   when both lhs and rhs are records (in which case we check class\n-   inheritance only).\n+      /* Repeat for superclasses.  */\n+      lcls = lookup_interface (CLASS_SUPER_NAME (lcls));\n+    }\n \n-   Warnings about classes/protocols not implementing a protocol are\n-   emitted here (multiple of those warnings might be emitted for a\n-   single line!); generic warnings about incompatible assignments and\n-   lacks of casts in comparisons are/must be emitted by the caller if\n-   we return 0.\n-*/\n+  /* Check for any protocols attached directly to the object type.  */\n+  if (TYPE_HAS_OBJC_INFO (ltyp))\n+    {\n+      for (p = TYPE_OBJC_PROTOCOL_LIST (ltyp); p; p = TREE_CHAIN (p))\n+\t{\n+\t  have_lproto = true;\n \n-int\n-objc_comptypes (tree lhs, tree rhs, int reflexive)\n+\t  if (!objc_lookup_protocol (TREE_VALUE (p), rcls, rtyp, warn))\n+\t    return warn;\n+\t}\n+    }\n+\n+  /* NB: If LTYP and LCLS have no protocols to search for, return 'true'\n+     vacuously, _unless_ RTYP is a protocol-qualified 'id'.  We can get\n+     away with simply checking for 'id' or 'Class' (!RCLS), since this\n+     routine will not get called in other cases.  */\n+  return have_lproto || (rcls != NULL_TREE);\n+}\n+\n+/* Determine if it is permissible to assign (if ARGNO is greater than -3)\n+   an instance of RTYP to an instance of LTYP or to compare the two\n+   (if ARGNO is equal to -3), per ObjC type system rules.  Before\n+   returning 'true', this routine may issue warnings related to, e.g.,\n+   protocol conformance.  When returning 'false', the routine must\n+   produce absolutely no warnings; the C or C++ front-end will do so\n+   instead, if needed.  If either LTYP or RTYP is not an Objective-C type,\n+   the routine must return 'false'.\n+\n+   The ARGNO parameter is encoded as follows:\n+     >= 1\tParameter number (CALLEE contains function being called);\n+     0\t\tReturn value;\n+     -1\t\tAssignment;\n+     -2\t\tInitialization;\n+     -3\t\tComparison (LTYP and RTYP may match in either direction).  */\n+\n+bool\n+objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n {\n-  /* New clause for protocols.  */\n+  tree lcls, rcls, lproto, rproto;\n+  bool pointers_compatible;\n+\n+  /* We must be dealing with pointer types */\n+  if (!POINTER_TYPE_P (ltyp) || !POINTER_TYPE_P (rtyp))\n+    return false;\n \n-  /* Here we manage the case of a POINTER_TYPE = POINTER_TYPE.  We only\n-     manage the ObjC ones, and leave the rest to the C code.  */\n-  if (TREE_CODE (lhs) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (lhs)) == RECORD_TYPE\n-      && TREE_CODE (rhs) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (rhs)) == RECORD_TYPE)\n+  do\n     {\n-      int lhs_is_proto = IS_PROTOCOL_QUALIFIED_UNTYPED (lhs);\n-      int rhs_is_proto = IS_PROTOCOL_QUALIFIED_UNTYPED (rhs);\n+      ltyp = TREE_TYPE (ltyp);  /* Remove indirections.  */\n+      rtyp = TREE_TYPE (rtyp);\n+    }\n+  while (POINTER_TYPE_P (ltyp) && POINTER_TYPE_P (rtyp));\n \n-      if (lhs_is_proto)\n-        {\n-\t  tree lproto, lproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (lhs));\n-\t  tree rproto, rproto_list;\n-\t  tree p;\n+  /* Past this point, we are only interested in ObjC class instances,\n+     or 'id' or 'Class'.  */\n+  if (TREE_CODE (ltyp) != RECORD_TYPE || TREE_CODE (rtyp) != RECORD_TYPE)\n+    return false;\n \n-\t  /* <Protocol> = <Protocol>  */\n-\t  if (rhs_is_proto)\n-\t    {\n-\t      /* Class <Protocol> != id <Protocol>;\n-\t\t id <Protocol> != Class <Protocol>  */\n-\t      if (IS_ID (lhs) != IS_ID (rhs))\n-\t\treturn 0;\n+  if (!objc_is_object_id (ltyp) && !objc_is_class_id (ltyp)\n+      && !TYPE_HAS_OBJC_INFO (ltyp))\n+    return false;\n \n-\t      rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n+  if (!objc_is_object_id (rtyp) && !objc_is_class_id (rtyp)\n+      && !TYPE_HAS_OBJC_INFO (rtyp))\n+    return false;\n \n-\t      if (!reflexive)\n-\t\t{\n-\t\t  /* An assignment between objects of type 'id\n-\t\t     <Protocol>'; make sure the protocol on the lhs is\n-\t\t     supported by the object on the rhs.  */\n-\t\t  for (lproto = lproto_list; lproto;\n-\t\t       lproto = TREE_CHAIN (lproto))\n-\t\t    {\n-\t\t      p = TREE_VALUE (lproto);\n-\t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n+  /* Past this point, we are committed to returning 'true' to the caller.\n+     However, we can still warn about type and/or protocol mismatches.  */\n \n-\t\t      if (!rproto)\n-\t\t\twarning\n-\t\t\t  (0, \"object does not conform to the %qs protocol\",\n-\t\t\t   IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n-\t\t    }\n-\t\t  return 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Obscure case - a comparison between two objects\n-\t\t     of type 'id <Protocol>'.  Check that either the\n-\t\t     protocol on the lhs is supported by the object on\n-\t\t     the rhs, or viceversa.  */\n-\n-\t\t  /* Check if the protocol on the lhs is supported by the\n-\t\t     object on the rhs.  */\n-\t\t  for (lproto = lproto_list; lproto;\n-\t\t       lproto = TREE_CHAIN (lproto))\n-\t\t    {\n-\t\t      p = TREE_VALUE (lproto);\n-\t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\n-\t\t      if (!rproto)\n-\t\t\t{\n-\t\t\t  /* Check failed - check if the protocol on the rhs\n-\t\t\t     is supported by the object on the lhs.  */\n-\t\t\t  for (rproto = rproto_list; rproto;\n-\t\t\t       rproto = TREE_CHAIN (rproto))\n-\t\t\t    {\n-\t\t\t      p = TREE_VALUE (rproto);\n-\t\t\t      lproto = lookup_protocol_in_reflist (lproto_list,\n-\t\t\t\t\t\t\t\t   p);\n-\n-\t\t\t      if (!lproto)\n-\t\t\t\t{\n-\t\t\t\t  /* This check failed too: incompatible  */\n-\t\t\t\t  return 0;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t  return 1;\n-\t\t\t}\n-\t\t    }\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t  /* <Protocol> = <class> *  */\n-\t  else if (TYPED_OBJECT (TREE_TYPE (rhs)))\n-\t    {\n-\t      tree rname = OBJC_TYPE_NAME (TREE_TYPE (rhs));\n-\t      tree rinter;\n+  if (TYPE_HAS_OBJC_INFO (ltyp))\n+    {\n+      lcls = TYPE_OBJC_INTERFACE (ltyp);\n+      lproto = TYPE_OBJC_PROTOCOL_LIST (ltyp);\n+    }\n+  else\n+    lcls = lproto = NULL_TREE;\n \n-\t      /* Class <Protocol> != <class> *  */\n-\t      if (IS_CLASS (lhs))\n-\t\treturn 0;\n+  if (TYPE_HAS_OBJC_INFO (rtyp))\n+    {\n+      rcls = TYPE_OBJC_INTERFACE (rtyp);\n+      rproto = TYPE_OBJC_PROTOCOL_LIST (rtyp);\n+    }\n+  else\n+    rcls = rproto = NULL_TREE;\n \n-\t      /* Make sure the protocol is supported by the object on\n-\t\t the rhs.  */\n-\t      for (lproto = lproto_list; lproto; lproto = TREE_CHAIN (lproto))\n-\t\t{\n-\t\t  p = TREE_VALUE (lproto);\n-\t\t  rproto = 0;\n-\t\t  rinter = lookup_interface (rname);\n+  /* If either type is an unqualified 'id', we're done.  */\n+  if ((!lproto && objc_is_object_id (ltyp))\n+      || (!rproto && objc_is_object_id (rtyp)))\n+    return true;\n \n-\t\t  while (rinter && !rproto)\n-\t\t    {\n-\t\t      tree cat;\n-\n-\t\t      rproto_list = CLASS_PROTOCOL_LIST (rinter);\n-\t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\t\t      /* If the underlying ObjC class does not have\n-\t\t\t the protocol we're looking for, check for \"one-off\"\n-\t\t\t protocols (e.g., `NSObject<MyProt> *foo;') attached\n-\t\t\t to the rhs.  */\n-\t\t      if (!rproto && TYPE_HAS_OBJC_INFO (TREE_TYPE (rhs)))\n-\t\t\t{\n-\t\t\t  rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n-\t\t\t  rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\t\t\t}\n-\n-\t\t      /* Check for protocols adopted by categories.  */\n-\t\t      cat = CLASS_CATEGORY_LIST (rinter);\n-\t\t      while (cat && !rproto)\n-\t\t\t{\n-\t\t\t  rproto_list = CLASS_PROTOCOL_LIST (cat);\n-\t\t\t  rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\t\t\t  cat = CLASS_CATEGORY_LIST (cat);\n-\t\t\t}\n-\n-\t\t      rinter = lookup_interface (CLASS_SUPER_NAME (rinter));\n-\t\t    }\n+  pointers_compatible = (TYPE_MAIN_VARIANT (ltyp) == TYPE_MAIN_VARIANT (rtyp));\n \n-\t\t  if (!rproto)\n-\t\t    warning (0, \"class %qs does not implement the %qs protocol\",\n-\t\t\t     IDENTIFIER_POINTER (OBJC_TYPE_NAME (TREE_TYPE (rhs))),\n-\t\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n-\t\t}\n-\t      return 1;\n-\t    }\n-\t  /* id <Protocol> = id; Class <Protocol> = id */\n-\t  else if (objc_is_object_id (TREE_TYPE (rhs)))\n-\t    {\n-\t      return 1;\n-\t    }\n-\t  /* id <Protocol> != Class; Class <Protocol> = Class */\n-\t  else if (objc_is_class_id (TREE_TYPE (rhs)))\n-\t    {\n-\t      return IS_CLASS (lhs);\n-\t    }\n-\t  /* <Protocol> = ?? : let comptypes decide.  */\n-          return -1;\n-        }\n-      else if (rhs_is_proto)\n-\t{\n-\t  /* <class> * = <Protocol> */\n-\t  if (TYPED_OBJECT (TREE_TYPE (lhs)))\n-\t    {\n-\t      /* <class> * != Class <Protocol> */\n-\t      if (IS_CLASS (rhs))\n-\t\treturn 0;\n+  /* If the underlying types are the same, and at most one of them has\n+     a protocol list, we do not need to issue any diagnostics.  */\n+  if (pointers_compatible && (!lproto || !rproto))\n+    return true;\n \n-\t      if (reflexive)\n-\t\t{\n-\t\t  tree rname = OBJC_TYPE_NAME (TREE_TYPE (lhs));\n-\t\t  tree rinter;\n-\t\t  tree rproto, rproto_list = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rhs));\n-\n-\t\t  /* Make sure the protocol is supported by the object on\n-\t\t     the lhs.  */\n-\t\t  for (rproto = rproto_list; rproto;\n-\t\t       rproto = TREE_CHAIN (rproto))\n-\t\t    {\n-\t\t      tree p = TREE_VALUE (rproto);\n-\t\t      tree lproto = 0;\n-\t\t      rinter = lookup_interface (rname);\n-\n-\t\t      while (rinter && !lproto)\n-\t\t\t{\n-\t\t\t  tree cat;\n-\n-\t\t\t  tree lproto_list = CLASS_PROTOCOL_LIST (rinter);\n-\t\t\t  lproto = lookup_protocol_in_reflist (lproto_list, p);\n-\t\t\t  /* If the underlying ObjC class does not\n-\t\t\t     have the protocol we're looking for,\n-\t\t\t     check for \"one-off\" protocols (e.g.,\n-\t\t\t     `NSObject<MyProt> *foo;') attached to the\n-\t\t\t     lhs.  */\n-\t\t\t  if (!lproto && TYPE_HAS_OBJC_INFO (TREE_TYPE (lhs)))\n-\t\t\t    {\n-\t\t\t      lproto_list = TYPE_OBJC_PROTOCOL_LIST\n-\t\t\t\t(TREE_TYPE (lhs));\n-\t\t\t      lproto = lookup_protocol_in_reflist\n-\t\t\t\t(lproto_list, p);\n-\t\t\t    }\n-\n-\t\t\t  /* Check for protocols adopted by categories.  */\n-\t\t\t  cat = CLASS_CATEGORY_LIST (rinter);\n-\t\t\t  while (cat && !lproto)\n-\t\t\t    {\n-\t\t\t      lproto_list = CLASS_PROTOCOL_LIST (cat);\n-\t\t\t      lproto = lookup_protocol_in_reflist (lproto_list,\n-\t\t\t\t\t\t\t\t   p);\n-\t\t\t      cat = CLASS_CATEGORY_LIST (cat);\n-\t\t\t    }\n-\t\t\t\n-\t\t\t  rinter = lookup_interface (CLASS_SUPER_NAME\n-\t\t\t\t\t\t     (rinter));\n-\t\t\t}\n-\t\t\n-\t\t      if (!lproto)\n-\t\t\twarning (0, \"class %qs does not implement the %qs protocol\",\n-\t\t\t\t IDENTIFIER_POINTER (OBJC_TYPE_NAME\n-\t\t\t\t\t\t     (TREE_TYPE (lhs))),\n-\t\t\t\t IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n-\t\t    }\n-\t\t  return 1;\n-\t\t}\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  /* id = id <Protocol>; id = Class <Protocol> */\n-\t  else if (objc_is_object_id (TREE_TYPE (lhs)))\n-\t    {\n-\t      return 1;\n-\t    }\n-\t  /* Class != id <Protocol>; Class = Class <Protocol> */\n-\t  else if (objc_is_class_id (TREE_TYPE (lhs)))\n-\t    {\n-\t      return IS_CLASS (rhs);\n-\t    }\n-\t  /* ??? = <Protocol> : let comptypes decide */\n-\t  else\n-\t    {\n-\t      return -1;\n-\t    }\n-\t}\n-      else\n+  /* If exactly one of the types is 'Class', issue a diagnostic; any\n+     exceptions of this rule have already been handled.  */\n+  if (objc_is_class_id (ltyp) ^ objc_is_class_id (rtyp))\n+    pointers_compatible = false;\n+  /* Otherwise, check for inheritance relations.  */\n+  else\n+    {\n+      if (!pointers_compatible)\n+\tpointers_compatible\n+\t  = (objc_is_object_id (ltyp) || objc_is_object_id (rtyp));\n+\n+      if (!pointers_compatible)\n+\tpointers_compatible = DERIVED_FROM_P (ltyp, rtyp);\n+\n+      if (!pointers_compatible && argno == -3)\n+\tpointers_compatible = DERIVED_FROM_P (rtyp, ltyp);\n+    }\n+\n+  /* If the pointers match modulo protocols, check for protocol conformance\n+     mismatches.  */\n+  if (pointers_compatible)\n+    {\n+      pointers_compatible = objc_compare_protocols (lcls, ltyp, rcls, rtyp,\n+\t\t\t\t\t\t    argno != -3);\n+\n+      if (!pointers_compatible && argno == -3)\n+\tpointers_compatible = objc_compare_protocols (rcls, rtyp, lcls, ltyp,\n+\t\t\t\t\t\t      argno != -3);\n+    }\n+\n+  if (!pointers_compatible)\n+    {\n+      /* NB: For the time being, we shall make our warnings look like their\n+\t C counterparts.  In the future, we may wish to make them more\n+\t ObjC-specific.  */\n+      switch (argno)\n \t{\n-\t  /* Attention: we shouldn't defer to comptypes here.  One bad\n-\t     side effect would be that we might loose the REFLEXIVE\n-\t     information.\n-\t  */\n-\t  lhs = TREE_TYPE (lhs);\n-\t  rhs = TREE_TYPE (rhs);\n+\tcase -3:\n+\t  warning (0, \"comparison of distinct Objective-C types lacks a cast\");\n+\t  break;\n+\n+\tcase -2:\n+\t  warning (0, \"initialization from distinct Objective-C type\");\n+\t  break;\n+\n+\tcase -1:\n+\t  warning (0, \"assignment from distinct Objective-C type\");\n+\t  break;\n+\n+\tcase 0:\n+\t  warning (0, \"distinct Objective-C type in return\");\n+\t  break;\n+\n+\tdefault:\n+\t  warning (0, \"passing argument %d of %qE from distinct \"\n+\t\t   \"Objective-C type\", argno, callee);\n+\t  break;\n \t}\n     }\n \n-  if (TREE_CODE (lhs) != RECORD_TYPE || TREE_CODE (rhs) != RECORD_TYPE)\n+  return true;\n+}\n+\n+/* Check if LTYP and RTYP have the same type qualifiers.  If either type\n+   lives in the volatilized hash table, ignore the 'volatile' bit when\n+   making the comparison.  */\n+\n+bool\n+objc_type_quals_match (tree ltyp, tree rtyp)\n+{\n+  int lquals = TYPE_QUALS (ltyp), rquals = TYPE_QUALS (rtyp);\n+  struct volatilized_type key;\n+\n+  key.type = ltyp;\n+\n+  if (htab_find_slot (volatilized_htab, &key, NO_INSERT))\n+    lquals &= ~TYPE_QUAL_VOLATILE;\n+\n+  key.type = rtyp;\n+\n+  if (htab_find_slot (volatilized_htab, &key, NO_INSERT))\n+    rquals &= ~TYPE_QUAL_VOLATILE;\n+\n+  return (lquals == rquals);\n+}\n+\n+#ifndef OBJCPLUS\n+/* Determine if CHILD is derived from PARENT.  The routine assumes that\n+   both parameters are RECORD_TYPEs, and is non-reflexive.  */\n+\n+static bool\n+objc_derived_from_p (tree parent, tree child)\n+{\n+  parent = TYPE_MAIN_VARIANT (parent);\n+\n+  for (child = TYPE_MAIN_VARIANT (child);\n+       TYPE_BINFO (child) && BINFO_N_BASE_BINFOS (TYPE_BINFO (child));)\n     {\n-      /* Nothing to do with ObjC - let immediately comptypes take\n-\t responsibility for checking.  */\n-      return -1;\n+      child = TYPE_MAIN_VARIANT (BINFO_TYPE (BINFO_BASE_BINFO\n+\t\t\t\t\t     (TYPE_BINFO (child),\n+\t\t\t\t\t      0)));\n+\n+      if (child == parent)\n+\treturn true;\n     }\n \n-  /* `id' = `<class> *' `<class> *' = `id': always allow it.\n-     Please note that\n-     'Object *o = [[Object alloc] init]; falls\n-     in the case <class> * = `id'.\n-  */\n-  if ((objc_is_object_id (lhs) && TYPED_OBJECT (rhs))\n-      || (objc_is_object_id (rhs) && TYPED_OBJECT (lhs)))\n-    return 1;\n+  return false;\n+}\n+#endif\n+\n+static tree\n+objc_build_component_ref (tree datum, tree component)\n+{\n+  /* If COMPONENT is NULL, the caller is referring to the anonymous\n+     base class field.  */\n+  if (!component)\n+    {\n+      tree base = TYPE_FIELDS (TREE_TYPE (datum));\n \n-  /* `id' = `Class', `Class' = `id' */\n+      return build3 (COMPONENT_REF, TREE_TYPE (base), datum, base, NULL_TREE);\n+    }\n \n-  else if ((objc_is_object_id (lhs) && objc_is_class_id (rhs))\n-\t   || (objc_is_class_id (lhs) && objc_is_object_id (rhs)))\n-    return 1;\n+  /* The 'build_component_ref' routine has been removed from the C++\n+     front-end, but 'finish_class_member_access_expr' seems to be\n+     a worthy substitute.  */\n+#ifdef OBJCPLUS\n+  return finish_class_member_access_expr (datum, component);\n+#else\n+  return build_component_ref (datum, component);\n+#endif\n+}\n \n-  /* `Class' != `<class> *' && `<class> *' != `Class'!  */\n-  else if ((OBJC_TYPE_NAME (lhs) == objc_class_id && TYPED_OBJECT (rhs))\n-\t   || (OBJC_TYPE_NAME (rhs) == objc_class_id && TYPED_OBJECT (lhs)))\n-    return 0;\n+/* Recursively copy inheritance information rooted at BINFO.  To do this,\n+   we emulate the song and dance performed by cp/tree.c:copy_binfo().  */\n \n-  /* `<class> *' = `<class> *' */\n+static tree\n+objc_copy_binfo (tree binfo)\n+{\n+  tree btype = BINFO_TYPE (binfo);\n+  tree binfo2 = make_tree_binfo (BINFO_N_BASE_BINFOS (binfo));\n+  tree base_binfo;\n+  int ix;\n \n-  else if (TYPED_OBJECT (lhs) && TYPED_OBJECT (rhs))\n+  BINFO_TYPE (binfo2) = btype;\n+  BINFO_OFFSET (binfo2) = BINFO_OFFSET (binfo);\n+  BINFO_BASE_ACCESSES (binfo2) = BINFO_BASE_ACCESSES (binfo);\n+\n+  /* Recursively copy base binfos of BINFO.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n-      tree lname = OBJC_TYPE_NAME (lhs);\n-      tree rname = OBJC_TYPE_NAME (rhs);\n-      tree inter;\n+      tree base_binfo2 = objc_copy_binfo (base_binfo);\n+\n+      BINFO_INHERITANCE_CHAIN (base_binfo2) = binfo2;\n+      BINFO_BASE_APPEND (binfo2, base_binfo2);\n+    }\n+\n+  return binfo2;\n+}\n+\n+/* Record superclass information provided in BASETYPE for ObjC class REF.\n+   This is loosely based on cp/decl.c:xref_basetypes().  */\n \n-      if (lname == rname)\n-\treturn 1;\n+static void\n+objc_xref_basetypes (tree ref, tree basetype)\n+{\n+  tree binfo = make_tree_binfo (basetype ? 1 : 0);\n \n-      /* If the left hand side is a super class of the right hand side,\n-\t allow it.  */\n-      for (inter = lookup_interface (rname); inter;\n-\t   inter = lookup_interface (CLASS_SUPER_NAME (inter)))\n-\tif (lname == CLASS_SUPER_NAME (inter))\n-\t  return 1;\n+  TYPE_BINFO (ref) = binfo;\n+  BINFO_OFFSET (binfo) = size_zero_node;\n+  BINFO_TYPE (binfo) = ref;\n \n-      /* Allow the reverse when reflexive.  */\n-      if (reflexive)\n-\tfor (inter = lookup_interface (lname); inter;\n-\t     inter = lookup_interface (CLASS_SUPER_NAME (inter)))\n-\t  if (rname == CLASS_SUPER_NAME (inter))\n-\t    return 1;\n+  if (basetype)\n+    {\n+      tree base_binfo = objc_copy_binfo (TYPE_BINFO (basetype));\n \n-      return 0;\n+      BINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n+      BINFO_BASE_ACCESSES (binfo) = VEC_alloc (tree, gc, 1);\n+      BINFO_BASE_APPEND (binfo, base_binfo);\n+      BINFO_BASE_ACCESS_APPEND (binfo, access_public_node);\n     }\n-  else\n-    /* Not an ObjC type - let comptypes do the check.  */\n-    return -1;\n+}\n+\n+static hashval_t\n+volatilized_hash (const void *ptr)\n+{\n+  tree typ = ((struct volatilized_type *)ptr)->type;\n+\n+  return (hashval_t) typ;\n+}\n+\n+static int\n+volatilized_eq (const void *ptr1, const void *ptr2)\n+{\n+  tree typ1 = ((struct volatilized_type *)ptr1)->type;\n+  tree typ2 = ((struct volatilized_type *)ptr2)->type;\n+\n+  return typ1 == typ2;\n }\n \n /* Called from finish_decl.  */\n@@ -1532,10 +1667,6 @@ synth_module_prologue (void)\n   /* Pre-build the following entities - for speed/convenience.  */\n   self_id = get_identifier (\"self\");\n   ucmd_id = get_identifier (\"_cmd\");\n-#ifndef OBJCPLUS\n-  /* The C++ front-end does not appear to grok __attribute__((__unused__)).  */\n-  unused_list = build_tree_list (get_identifier (\"__unused__\"), NULL_TREE);\n-#endif\t  \n \n #ifdef OBJCPLUS\n   pop_lang_context ();\n@@ -2512,23 +2643,29 @@ add_class_reference (tree ident)\n tree\n objc_get_class_reference (tree ident)\n {\n-  tree orig_ident;\n+  tree orig_ident = (DECL_P (ident)\n+\t\t     ? DECL_NAME (ident)\n+\t\t     : TYPE_P (ident)\n+\t\t     ? OBJC_TYPE_NAME (ident)\n+\t\t     : ident);\n   bool local_scope = false;\n \n #ifdef OBJCPLUS\n   if (processing_template_decl)\n     /* Must wait until template instantiation time.  */\n     return build_min_nt (CLASS_REFERENCE_EXPR, ident);\n+#endif\n+\n   if (TREE_CODE (ident) == TYPE_DECL)\n-    {\n-      /* The type must exist in the global namespace.  */\n-      if (DECL_CONTEXT (ident) && DECL_CONTEXT (ident) != global_namespace)\n-\tlocal_scope = true;\n+    ident = (DECL_ORIGINAL_TYPE (ident)\n+\t     ? DECL_ORIGINAL_TYPE (ident)\n+\t     : TREE_TYPE (ident));\n \n-      ident = DECL_NAME (ident);\n-    }\n+#ifdef OBJCPLUS\n+  if (TYPE_P (ident) && TYPE_CONTEXT (ident)\n+      && TYPE_CONTEXT (ident) != global_namespace)\n+    local_scope = true;\n #endif\n-  orig_ident = ident;\n \n   if (local_scope || !(ident = objc_is_class_name (ident)))\n     {\n@@ -2656,7 +2793,20 @@ objc_declare_alias (tree alias_ident, tree class_ident)\n   else if (objc_is_class_name (alias_ident))\n     warning (0, \"class %qs already exists\", IDENTIFIER_POINTER (alias_ident));\n   else\n-    alias_chain = tree_cons (underlying_class, alias_ident, alias_chain);\n+    {\n+      /* Implement @compatibility_alias as a typedef.  */\n+#ifdef OBJCPLUS\n+      push_lang_context (lang_name_c); /* extern \"C\" */\n+#endif\n+      lang_hooks.decls.pushdecl (build_decl\n+\t\t\t\t (TYPE_DECL,\n+\t\t\t\t  alias_ident,\n+\t\t\t\t  xref_tag (RECORD_TYPE, underlying_class)));\n+#ifdef OBJCPLUS\n+      pop_lang_context ();\n+#endif\n+      alias_chain = tree_cons (underlying_class, alias_ident, alias_chain);\n+    }\n }\n \n void\n@@ -2807,10 +2957,11 @@ objc_substitute_decl (tree expr, tree oldexpr, tree newexpr)\n   switch (TREE_CODE (expr))\n     {\n     case COMPONENT_REF:\n-      return build_component_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n-\t\t\t\t\t\t\toldexpr,\n-\t\t\t\t\t\t\tnewexpr),\n-\t\t\t\t  DECL_NAME (TREE_OPERAND (expr, 1)));\n+      return objc_build_component_ref\n+\t     (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+\t\t\t\t    oldexpr,\n+\t\t\t\t    newexpr),\n+\t      DECL_NAME (TREE_OPERAND (expr, 1)));\n     case ARRAY_REF:\n       return build_array_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\t    oldexpr,\n@@ -3103,7 +3254,7 @@ objc_get_class_ivars (tree class_name)\n   tree interface = lookup_interface (class_name);\n \n   if (interface)\n-    return get_class_ivars (interface);\n+    return get_class_ivars (interface, true);\n \n   error (\"cannot find interface declaration for %qs\",\n \t IDENTIFIER_POINTER (class_name));\n@@ -3115,7 +3266,7 @@ objc_get_class_ivars (tree class_name)\n    and for @defs constructs.  */\n \n static tree\n-get_class_ivars (tree interface)\n+get_class_ivars (tree interface, bool inherited)\n {\n   tree ivar_chain = copy_list (CLASS_RAW_IVARS (interface));\n \n@@ -3126,6 +3277,9 @@ get_class_ivars (tree interface)\n   if (!CLASS_IVARS (interface))\n     CLASS_IVARS (interface) = ivar_chain;\n \n+  if (!inherited)\n+    return ivar_chain;\n+\n   while (CLASS_SUPER_NAME (interface))\n     {\n       /* Prepend super-class ivars.  */\n@@ -3283,8 +3437,8 @@ next_sjlj_build_enter_and_setjmp (void)\n   t = tree_cons (NULL, t, NULL);\n   enter = build_function_call (objc_exception_try_enter_decl, t);\n \n-  t = build_component_ref (cur_try_context->stack_decl,\n-\t\t\t   get_identifier (\"buf\"));\n+  t = objc_build_component_ref (cur_try_context->stack_decl,\n+\t\t\t\tget_identifier (\"buf\"));\n   t = build_fold_addr_expr (t);\n #ifdef OBJCPLUS\n   /* Convert _setjmp argument to type that is expected.  */\n@@ -3569,7 +3723,7 @@ objc_begin_catch_clause (tree decl)\n \t  t = CATCH_TYPES (stmt);\n \t  if (t == error_mark_node)\n \t    continue;\n-\t  if (!t || objc_comptypes (TREE_TYPE (t), TREE_TYPE (type), 0) == 1)\n+\t  if (!t || DERIVED_FROM_P (TREE_TYPE (t), TREE_TYPE (type)))\n \t    {\n \t      warning (0, \"exception of type %<%T%> will be caught\",\n \t\t       TREE_TYPE (type));\n@@ -3869,9 +4023,10 @@ build_private_template (tree class)\n {\n   if (!CLASS_STATIC_TEMPLATE (class))\n     {\n-      tree record = start_struct (RECORD_TYPE, CLASS_NAME (class));\n+      tree record = objc_build_struct (CLASS_NAME (class),\n+\t\t\t\t       get_class_ivars (class, false),\n+\t\t\t\t       CLASS_SUPER_NAME (class));\n \n-      finish_struct (record, get_class_ivars (class), NULL_TREE);\n       /* mark this record as class template - for class type checking */\n       INIT_TYPE_OBJC_INFO (record);\n       TYPE_OBJC_INTERFACE (record) = class;\n@@ -4702,8 +4857,8 @@ synth_forward_declarations (void)\n   /* Pre-build the following entities - for speed/convenience.  */\n \n   an_id = get_identifier (\"super_class\");\n-  ucls_super_ref = build_component_ref (UOBJC_CLASS_decl, an_id);\n-  uucls_super_ref = build_component_ref (UOBJC_METACLASS_decl, an_id);\n+  ucls_super_ref = objc_build_component_ref (UOBJC_CLASS_decl, an_id);\n+  uucls_super_ref = objc_build_component_ref (UOBJC_METACLASS_decl, an_id);\n }\n \n static void\n@@ -6482,7 +6637,7 @@ build_ivar_reference (tree id)\n       self_decl = convert (objc_instance_type, self_decl); /* cast */\n     }\n \n-  return build_component_ref (build_indirect_ref (self_decl, \"->\"), id);\n+  return objc_build_component_ref (build_indirect_ref (self_decl, \"->\"), id);\n }\n \f\n /* Compute a hash value for a given method SEL_NAME.  */\n@@ -6510,6 +6665,10 @@ hash_init (void)\n   /* Initialize the hash table used to hold the constant string objects.  */\n   string_htab = htab_create_ggc (31, string_hash,\n \t\t\t\t   string_eq, NULL);\n+\n+  /* Initialize the hash table used to hold EH-volatilized types.  */\n+  volatilized_htab = htab_create_ggc (31, volatilized_hash,\n+\t\t\t\t      volatilized_eq, NULL);\n }\n \n /* WARNING!!!!  hash_enter is called with a method, and will peek\n@@ -6924,8 +7083,14 @@ is_private (tree decl)\n int\n objc_is_public (tree expr, tree identifier)\n {\n-  tree basetype = TREE_TYPE (expr);\n-  tree decl;\n+  tree basetype, decl;\n+\n+#ifdef OBJCPLUS\n+  if (processing_template_decl)\n+    return 1;\n+#endif\n+\n+  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n \n   if (basetype && TREE_CODE (basetype) == RECORD_TYPE)\n     {\n@@ -6940,7 +7105,7 @@ objc_is_public (tree expr, tree identifier)\n \t      return 0;\n \t    }\n \n-\t  if ((decl = is_ivar (get_class_ivars (class), identifier)))\n+\t  if ((decl = is_ivar (get_class_ivars (class, true), identifier)))\n \t    {\n \t      if (TREE_PUBLIC (decl))\n \t\treturn 1;\n@@ -6949,19 +7114,26 @@ objc_is_public (tree expr, tree identifier)\n \t\t all instance variables should be public within the context\n \t\t of the implementation.  */\n \t      if (objc_implementation_context\n-\t\t  && (((TREE_CODE (objc_implementation_context)\n-\t\t\t== CLASS_IMPLEMENTATION_TYPE)\n-\t\t       || (TREE_CODE (objc_implementation_context)\n-\t\t\t   == CATEGORY_IMPLEMENTATION_TYPE))\n-\t\t      && (CLASS_NAME (objc_implementation_context)\n-\t\t\t  == OBJC_TYPE_NAME (basetype))))\n+\t\t && ((TREE_CODE (objc_implementation_context)\n+\t\t      == CLASS_IMPLEMENTATION_TYPE)\n+\t\t     || (TREE_CODE (objc_implementation_context)\n+\t\t\t == CATEGORY_IMPLEMENTATION_TYPE)))\n \t\t{\n-\t\t  int private = is_private (decl);\n+\t\t  tree curtype = TYPE_MAIN_VARIANT\n+\t\t\t\t (CLASS_STATIC_TEMPLATE\n+\t\t\t\t  (implementation_template));\n \n-\t\t  if (private)\n-\t\t    error (\"instance variable %qs is declared private\",\n-\t\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n-\t\t  return !private;\n+\t\t  if (basetype == curtype\n+\t\t      || DERIVED_FROM_P (basetype, curtype))\n+\t\t    {\n+\t\t      int private = is_private (decl);\n+\n+\t\t      if (private)\n+\t\t\terror (\"instance variable %qs is declared private\",\n+\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\n+\t\t      return !private;\n+\t\t    }\n \t\t}\n \n \t      /* The 2.95.2 compiler sometimes allowed C functions to access\n@@ -7396,7 +7568,7 @@ continue_class (tree class)\n       pop_lang_context ();\n #endif /* OBJCPLUS */\n \n-      return get_class_ivars (implementation_template);\n+      return get_class_ivars (implementation_template, true);\n     }\n \n   else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)\n@@ -7681,6 +7853,47 @@ encode_array (tree type, int curtype, int format)\n   return;\n }\n \f\n+static void\n+encode_aggregate_fields (tree type, int pointed_to, int curtype, int format)\n+{\n+  tree field = TYPE_FIELDS (type);\n+\n+  for (; field; field = TREE_CHAIN (field))\n+    {\n+#ifdef OBJCPLUS\n+      /* C++ static members, and things that are not field at all,\n+\t should not appear in the encoding.  */\n+      if (TREE_CODE (field) != FIELD_DECL || TREE_STATIC (field))\n+\tcontinue;\n+#endif\n+\n+      /* Recursively encode fields of embedded base classes.  */\n+      if (DECL_ARTIFICIAL (field) && !DECL_NAME (field) \n+\t  && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n+\t{\n+\t  encode_aggregate_fields (TREE_TYPE (field),\n+\t\t\t\t   pointed_to, curtype, format);\n+\t  continue;\n+\t}\n+\n+      if (generating_instance_variables && !pointed_to)\n+\t{\n+\t  tree fname = DECL_NAME (field);\n+\n+\t  obstack_1grow (&util_obstack, '\"');\n+\n+\t  if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n+\t    obstack_grow (&util_obstack,\n+\t\t\t  IDENTIFIER_POINTER (fname),\n+\t\t\t  strlen (IDENTIFIER_POINTER (fname)));\n+\n+\t  obstack_1grow (&util_obstack, '\"');\n+        }\n+\n+      encode_field_decl (field, curtype, format);\n+    }\n+}\n+\n static void\n encode_aggregate_within (tree type, int curtype, int format, int left,\n \t\t\t int right)\n@@ -7721,30 +7934,8 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n      if required.  */\n   if (inline_contents)\n     {\n-      tree fields = TYPE_FIELDS (type);\n-\n       obstack_1grow (&util_obstack, '=');\n-      for (; fields; fields = TREE_CHAIN (fields))\n-\t{\n-#ifdef OBJCPLUS\n-\t  /* C++ static members, and things that are not fields at all,\n-\t     should not appear in the encoding.  */\n-\t  if (TREE_CODE (fields) != FIELD_DECL || TREE_STATIC (fields))\n-\t    continue;\n-#endif\n-\t  if (generating_instance_variables && !pointed_to)\n-\t    {\n-\t      tree fname = DECL_NAME (fields);\n-\n-\t      obstack_1grow (&util_obstack, '\"');\n-\t      if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n-\t\tobstack_grow (&util_obstack,\n-\t\t\t      IDENTIFIER_POINTER (fname),\n-\t\t\t      strlen (IDENTIFIER_POINTER (fname)));\n-\t      obstack_1grow (&util_obstack, '\"');\n-\t    }\n-\t  encode_field_decl (fields, curtype, format);\n-\t}\n+      encode_aggregate_fields (type, pointed_to, curtype, format);\n     }\n   /* Close parenth/bracket.  */  \t\t\t\n   obstack_1grow (&util_obstack, right);\n@@ -8392,13 +8583,13 @@ get_super_receiver (void)\n       }\n \n       /* Set receiver to self.  */\n-      super_expr = build_component_ref (UOBJC_SUPER_decl, self_id);\n+      super_expr = objc_build_component_ref (UOBJC_SUPER_decl, self_id);\n       super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);\n       super_expr_list = super_expr;\n \n       /* Set class to begin searching.  */\n-      super_expr = build_component_ref (UOBJC_SUPER_decl,\n-\t\t\t\t\tget_identifier (\"super_class\"));\n+      super_expr = objc_build_component_ref (UOBJC_SUPER_decl,\n+\t\t\t\t\t     get_identifier (\"super_class\"));\n \n       if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \t{\n@@ -9174,14 +9365,14 @@ objc_rewrite_function_call (tree function, tree params)\n    a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend or one\n    of its cousins).  */\n \n-enum gimplify_status objc_gimplify_expr (tree *expr_p, tree *pre_p, \n-\t\t\t\t\t tree *post_p)\n+enum gimplify_status\n+objc_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n {\n   enum gimplify_status r0, r1;\n-  if (TREE_CODE (*expr_p) == OBJ_TYPE_REF \n+  if (TREE_CODE (*expr_p) == OBJ_TYPE_REF\n       && TREE_CODE (OBJ_TYPE_REF_EXPR (*expr_p)) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (OBJ_TYPE_REF_EXPR (*expr_p), 0)) \n-\t    == FUNCTION_DECL)\n+      && TREE_CODE (TREE_OPERAND (OBJ_TYPE_REF_EXPR (*expr_p), 0))\n+\t == FUNCTION_DECL)\n     {\n       /* Postincrements in OBJ_TYPE_REF_OBJECT don't affect the\n \t value of the OBJ_TYPE_REF, so force them to be emitted\n@@ -9193,8 +9384,10 @@ enum gimplify_status objc_gimplify_expr (tree *expr_p, tree *pre_p,\n \t\t\t  is_gimple_val, fb_rvalue);\n       r1 = gimplify_expr (&OBJ_TYPE_REF_EXPR (*expr_p), pre_p, post_p,\n \t\t\t  is_gimple_val, fb_rvalue);\n+\n       return MIN (r0, r1);\n     }\n+\n #ifdef OBJCPLUS\n   return cp_gimplify_expr (expr_p, pre_p, post_p);\n #else"}, {"sha": "f99f60d07baa17845125fe920b6c3ce350517a97", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=d11dd684081e91ffda37451fd6be1059d055130b", "patch": "@@ -32,7 +32,6 @@ const char *objc_printable_name (tree, int);\n tree objc_get_callee_fndecl (tree);\n void objc_finish_file (void);\n tree objc_fold_obj_type_ref (tree, tree);\n-int objc_types_compatible_p (tree, tree);\n enum gimplify_status objc_gimplify_expr (tree *, tree *, tree *);\n \n /* NB: The remaining public functions are prototyped in c-common.h, for the\n@@ -190,7 +189,6 @@ enum objc_tree_index\n     OCTI_STATIC_NST_DECL,\n     OCTI_SELF_ID,\n     OCTI_UCMD_ID,\n-    OCTI_UNUSED_LIST,\n \n     OCTI_SELF_DECL,\n     OCTI_UMSG_DECL,\n@@ -305,7 +303,6 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \n #define self_id\t\t\tobjc_global_trees[OCTI_SELF_ID]\n #define ucmd_id\t\t\tobjc_global_trees[OCTI_UCMD_ID]\n-#define unused_list\t\tobjc_global_trees[OCTI_UNUSED_LIST]\n \n #define self_decl\t\tobjc_global_trees[OCTI_SELF_DECL]\n #define umsg_decl\t\tobjc_global_trees[OCTI_UMSG_DECL]"}, {"sha": "e8e50c92d76dc511d4b2eff55482ed801a3d033f", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11dd684081e91ffda37451fd6be1059d055130b/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=d11dd684081e91ffda37451fd6be1059d055130b", "patch": "@@ -45,8 +45,6 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_INIT objc_init\n #undef LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME objc_printable_name\n-#undef LANG_HOOKS_TYPES_COMPATIBLE_P\n-#define LANG_HOOKS_TYPES_COMPATIBLE_P objc_types_compatible_p\n #undef LANG_HOOKS_GIMPLIFY_EXPR \n #define LANG_HOOKS_GIMPLIFY_EXPR objc_gimplify_expr\n #undef LANG_HOOKS_GET_CALLEE_FNDECL"}]}