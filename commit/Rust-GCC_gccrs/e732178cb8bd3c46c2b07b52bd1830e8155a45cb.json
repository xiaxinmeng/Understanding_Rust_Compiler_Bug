{"sha": "e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczMjE3OGNiOGJkM2M0NmMyYjA3YjUyYmQxODMwZTgxNTVhNDVjYg==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-04-24T16:58:12Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-04-24T16:58:12Z"}, "message": "re PR target/6420 (libstdc++ failures on sparc-linux-gnu)\n\n2002-04-24  David S. Miller  <davem@redhat.com>\n\n\tPR target/6420\n\t* config/sparc/sparc.h (FUNCTION_OK_FOR_SIBCALL): Return false if\n\t32-bit Sparc and current_function_returns_struct is true.\n\nFrom-SVN: r52720", "tree": {"sha": "08a38236077ac77af6000593449dd89f1d2c9057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a38236077ac77af6000593449dd89f1d2c9057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e732178cb8bd3c46c2b07b52bd1830e8155a45cb/comments", "author": null, "committer": null, "parents": [{"sha": "e879eb2f793c9e39c65e57894df94e993fba37ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e879eb2f793c9e39c65e57894df94e993fba37ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e879eb2f793c9e39c65e57894df94e993fba37ae"}], "stats": {"total": 25, "additions": 23, "deletions": 2}, "files": [{"sha": "8482554c725afa24a5358f0ca0fe16e67acacece", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e732178cb8bd3c46c2b07b52bd1830e8155a45cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e732178cb8bd3c46c2b07b52bd1830e8155a45cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "patch": "@@ -1,3 +1,9 @@\n+2002-04-24  David S. Miller  <davem@redhat.com>\n+\n+\tPR target/6420\n+\t* config/sparc/sparc.h (FUNCTION_OK_FOR_SIBCALL): Return false if\n+\t32-bit Sparc and current_function_returns_struct is true.\n+\n Wed Apr 24 13:48:25 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* loop.c (canonicalize_condition): Use gen_int_mode."}, {"sha": "872b1eeeee05745bec69620404d25adac730fc60", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e732178cb8bd3c46c2b07b52bd1830e8155a45cb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e732178cb8bd3c46c2b07b52bd1830e8155a45cb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e732178cb8bd3c46c2b07b52bd1830e8155a45cb", "patch": "@@ -1902,8 +1902,23 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define STRICT_ARGUMENT_NAMING TARGET_V9\n \n /* We do not allow sibling calls if -mflat, nor\n-   we do not allow indirect calls to be optimized into sibling calls.  */\n-#define FUNCTION_OK_FOR_SIBCALL(DECL) (DECL && ! TARGET_FLAT)\n+   we do not allow indirect calls to be optimized into sibling calls.\n+\n+   Also, on sparc 32-bit we cannot emit a sibling call when the\n+   current function returns a structure.  This is because the \"unimp\n+   after call\" convention would cause the callee to return to the\n+   wrong place.  The generic code already disallows cases where the\n+   function being called returns a structure.\n+\n+   It may seem strange how this last case could occur.  Usually there\n+   is code after the call which jumps to epilogue code which dumps the\n+   return value into the struct return area.  That ought to invalidate\n+   the sibling call right?  Well, in the c++ case we can end up passing\n+   the pointer to the struct return area to a constructor (which returns\n+   void) and then nothing else happens.  Such a sibling call would look\n+   valid without the added check here.  */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) \\\n+\t(! TARGET_FLAT && (TARGET_ARCH64 || ! current_function_returns_struct))\n \n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */"}]}