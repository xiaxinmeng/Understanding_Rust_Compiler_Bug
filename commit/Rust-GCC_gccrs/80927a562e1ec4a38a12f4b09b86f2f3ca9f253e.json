{"sha": "80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5MjdhNTYyZTFlYzRhMzhhMTJmNGIwOWI4NmYyZjNjYTlmMjUzZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-07-24T07:57:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-07-24T07:57:13Z"}, "message": "re PR fortran/40643 (maxloc/minloc: Wrong result for NaN at position 1)\n\n\tPR fortran/40643\n\tPR fortran/31067\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc,\n\tgfc_conv_intrinsic_minmaxval): Handle Infinities and NaNs properly,\n\toptimize.\n\t* trans-array.c (gfc_trans_scalarized_loop_end): No longer static.\n\t* trans-array.h (gfc_trans_scalarized_loop_end): New prototype.\n\n\t* libgfortran.h (GFC_REAL_4_INFINITY, GFC_REAL_8_INFINITY,\n\tGFC_REAL_10_INFINITY, GFC_REAL_16_INFINITY, GFC_REAL_4_QUIET_NAN,\n\tGFC_REAL_8_QUIET_NAN, GFC_REAL_10_QUIET_NAN, GFC_REAL_16_QUIET_NAN):\n\tDefine.\n\t* m4/iparm.m4 (atype_inf, atype_nan): Define.\n\t* m4/ifunction.m4: Formatting.\n\t* m4/iforeach.m4: Likewise.\n\t(START_FOREACH_FUNCTION): Initialize dest to all 1s, not all 0s.\n\t(START_FOREACH_BLOCK, FINISH_FOREACH_FUNCTION,\n\tFINISH_MASKED_FOREACH_FUNCTION): Run foreach block inside a loop\n\tuntil count[0] == extent[0].\n\t* m4/minval.m4: Formatting.  Handle NaNs and infinities.  Optimize.\n\t* m4/maxval.m4: Likewise.\n\t* m4/minloc0.m4: Likewise.\n\t* m4/maxloc0.m4: Likewise.\n\t* m4/minloc1.m4: Likewise.\n\t* m4/maxloc1.m4: Likewise.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Likewise.\n\t* generated/maxloc0_16_i2.c: Likewise.\n\t* generated/maxloc0_16_i4.c: Likewise.\n\t* generated/maxloc0_16_i8.c: Likewise.\n\t* generated/maxloc0_16_r10.c: Likewise.\n\t* generated/maxloc0_16_r16.c: Likewise.\n\t* generated/maxloc0_16_r4.c: Likewise.\n\t* generated/maxloc0_16_r8.c: Likewise.\n\t* generated/maxloc0_4_i16.c: Likewise.\n\t* generated/maxloc0_4_i1.c: Likewise.\n\t* generated/maxloc0_4_i2.c: Likewise.\n\t* generated/maxloc0_4_i4.c: Likewise.\n\t* generated/maxloc0_4_i8.c: Likewise.\n\t* generated/maxloc0_4_r10.c: Likewise.\n\t* generated/maxloc0_4_r16.c: Likewise.\n\t* generated/maxloc0_4_r4.c: Likewise.\n\t* generated/maxloc0_4_r8.c: Likewise.\n\t* generated/maxloc0_8_i16.c: Likewise.\n\t* generated/maxloc0_8_i1.c: Likewise.\n\t* generated/maxloc0_8_i2.c: Likewise.\n\t* generated/maxloc0_8_i4.c: Likewise.\n\t* generated/maxloc0_8_i8.c: Likewise.\n\t* generated/maxloc0_8_r10.c: Likewise.\n\t* generated/maxloc0_8_r16.c: Likewise.\n\t* generated/maxloc0_8_r4.c: Likewise.\n\t* generated/maxloc0_8_r8.c: Likewise.\n\t* generated/maxloc1_16_i16.c: Likewise.\n\t* generated/maxloc1_16_i1.c: Likewise.\n\t* generated/maxloc1_16_i2.c: Likewise.\n\t* generated/maxloc1_16_i4.c: Likewise.\n\t* generated/maxloc1_16_i8.c: Likewise.\n\t* generated/maxloc1_16_r10.c: Likewise.\n\t* generated/maxloc1_16_r16.c: Likewise.\n\t* generated/maxloc1_16_r4.c: Likewise.\n\t* generated/maxloc1_16_r8.c: Likewise.\n\t* generated/maxloc1_4_i16.c: Likewise.\n\t* generated/maxloc1_4_i1.c: Likewise.\n\t* generated/maxloc1_4_i2.c: Likewise.\n\t* generated/maxloc1_4_i4.c: Likewise.\n\t* generated/maxloc1_4_i8.c: Likewise.\n\t* generated/maxloc1_4_r10.c: Likewise.\n\t* generated/maxloc1_4_r16.c: Likewise.\n\t* generated/maxloc1_4_r4.c: Likewise.\n\t* generated/maxloc1_4_r8.c: Likewise.\n\t* generated/maxloc1_8_i16.c: Likewise.\n\t* generated/maxloc1_8_i1.c: Likewise.\n\t* generated/maxloc1_8_i2.c: Likewise.\n\t* generated/maxloc1_8_i4.c: Likewise.\n\t* generated/maxloc1_8_i8.c: Likewise.\n\t* generated/maxloc1_8_r10.c: Likewise.\n\t* generated/maxloc1_8_r16.c: Likewise.\n\t* generated/maxloc1_8_r4.c: Likewise.\n\t* generated/maxloc1_8_r8.c: Likewise.\n\t* generated/maxval_i16.c: Likewise.\n\t* generated/maxval_i1.c: Likewise.\n\t* generated/maxval_i2.c: Likewise.\n\t* generated/maxval_i4.c: Likewise.\n\t* generated/maxval_i8.c: Likewise.\n\t* generated/maxval_r10.c: Likewise.\n\t* generated/maxval_r16.c: Likewise.\n\t* generated/maxval_r4.c: Likewise.\n\t* generated/maxval_r8.c: Likewise.\n\t* generated/minloc0_16_i16.c: Likewise.\n\t* generated/minloc0_16_i1.c: Likewise.\n\t* generated/minloc0_16_i2.c: Likewise.\n\t* generated/minloc0_16_i4.c: Likewise.\n\t* generated/minloc0_16_i8.c: Likewise.\n\t* generated/minloc0_16_r10.c: Likewise.\n\t* generated/minloc0_16_r16.c: Likewise.\n\t* generated/minloc0_16_r4.c: Likewise.\n\t* generated/minloc0_16_r8.c: Likewise.\n\t* generated/minloc0_4_i16.c: Likewise.\n\t* generated/minloc0_4_i1.c: Likewise.\n\t* generated/minloc0_4_i2.c: Likewise.\n\t* generated/minloc0_4_i4.c: Likewise.\n\t* generated/minloc0_4_i8.c: Likewise.\n\t* generated/minloc0_4_r10.c: Likewise.\n\t* generated/minloc0_4_r16.c: Likewise.\n\t* generated/minloc0_4_r4.c: Likewise.\n\t* generated/minloc0_4_r8.c: Likewise.\n\t* generated/minloc0_8_i16.c: Likewise.\n\t* generated/minloc0_8_i1.c: Likewise.\n\t* generated/minloc0_8_i2.c: Likewise.\n\t* generated/minloc0_8_i4.c: Likewise.\n\t* generated/minloc0_8_i8.c: Likewise.\n\t* generated/minloc0_8_r10.c: Likewise.\n\t* generated/minloc0_8_r16.c: Likewise.\n\t* generated/minloc0_8_r4.c: Likewise.\n\t* generated/minloc0_8_r8.c: Likewise.\n\t* generated/minloc1_16_i16.c: Likewise.\n\t* generated/minloc1_16_i1.c: Likewise.\n\t* generated/minloc1_16_i2.c: Likewise.\n\t* generated/minloc1_16_i4.c: Likewise.\n\t* generated/minloc1_16_i8.c: Likewise.\n\t* generated/minloc1_16_r10.c: Likewise.\n\t* generated/minloc1_16_r16.c: Likewise.\n\t* generated/minloc1_16_r4.c: Likewise.\n\t* generated/minloc1_16_r8.c: Likewise.\n\t* generated/minloc1_4_i16.c: Likewise.\n\t* generated/minloc1_4_i1.c: Likewise.\n\t* generated/minloc1_4_i2.c: Likewise.\n\t* generated/minloc1_4_i4.c: Likewise.\n\t* generated/minloc1_4_i8.c: Likewise.\n\t* generated/minloc1_4_r10.c: Likewise.\n\t* generated/minloc1_4_r16.c: Likewise.\n\t* generated/minloc1_4_r4.c: Likewise.\n\t* generated/minloc1_4_r8.c: Likewise.\n\t* generated/minloc1_8_i16.c: Likewise.\n\t* generated/minloc1_8_i1.c: Likewise.\n\t* generated/minloc1_8_i2.c: Likewise.\n\t* generated/minloc1_8_i4.c: Likewise.\n\t* generated/minloc1_8_i8.c: Likewise.\n\t* generated/minloc1_8_r10.c: Likewise.\n\t* generated/minloc1_8_r16.c: Likewise.\n\t* generated/minloc1_8_r4.c: Likewise.\n\t* generated/minloc1_8_r8.c: Likewise.\n\t* generated/minval_i16.c: Likewise.\n\t* generated/minval_i1.c: Likewise.\n\t* generated/minval_i2.c: Likewise.\n\t* generated/minval_i4.c: Likewise.\n\t* generated/minval_i8.c: Likewise.\n\t* generated/minval_r10.c: Likewise.\n\t* generated/minval_r16.c: Likewise.\n\t* generated/minval_r4.c: Likewise.\n\t* generated/minval_r8.c: Likewise.\n\t* generated/product_c10.c: Likewise.\n\t* generated/product_c16.c: Likewise.\n\t* generated/product_c4.c: Likewise.\n\t* generated/product_c8.c: Likewise.\n\t* generated/product_i16.c: Likewise.\n\t* generated/product_i1.c: Likewise.\n\t* generated/product_i2.c: Likewise.\n\t* generated/product_i4.c: Likewise.\n\t* generated/product_i8.c: Likewise.\n\t* generated/product_r10.c: Likewise.\n\t* generated/product_r16.c: Likewise.\n\t* generated/product_r4.c: Likewise.\n\t* generated/product_r8.c: Likewise.\n\t* generated/sum_c10.c: Likewise.\n\t* generated/sum_c16.c: Likewise.\n\t* generated/sum_c4.c: Likewise.\n\t* generated/sum_c8.c: Likewise.\n\t* generated/sum_i16.c: Likewise.\n\t* generated/sum_i1.c: Likewise.\n\t* generated/sum_i2.c: Likewise.\n\t* generated/sum_i4.c: Likewise.\n\t* generated/sum_i8.c: Likewise.\n\t* generated/sum_r10.c: Likewise.\n\t* generated/sum_r16.c: Likewise.\n\t* generated/sum_r4.c: Likewise.\n\t* generated/sum_r8.c: Likewise.\n\n\t* gfortran.dg/maxlocval_2.f90: New test.\n\t* gfortran.dg/maxlocval_3.f90: New test.\n\t* gfortran.dg/maxlocval_4.f90: New test.\n\t* gfortran.dg/minlocval_1.f90: New test.\n\t* gfortran.dg/minlocval_2.f90: New test.\n\t* gfortran.dg/minlocval_3.f90: New test.\n\t* gfortran.dg/minlocval_4.f90: New test.\n\nFrom-SVN: r150041", "tree": {"sha": "3a1ba521bd64c06116c292171eb8e9008c0f6c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a1ba521bd64c06116c292171eb8e9008c0f6c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a802a9e6ddcf43f9c211b417f8435e3b63ce3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a802a9e6ddcf43f9c211b417f8435e3b63ce3cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a802a9e6ddcf43f9c211b417f8435e3b63ce3cc"}], "stats": {"total": 35955, "additions": 22428, "deletions": 13527}, "files": [{"sha": "580a0b2c259c865a16b643cf320192f2b7c66343", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -1,3 +1,13 @@\n+2009-07-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/40643\n+\tPR fortran/31067\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc,\n+\tgfc_conv_intrinsic_minmaxval): Handle Infinities and NaNs properly,\n+\toptimize.\n+\t* trans-array.c (gfc_trans_scalarized_loop_end): No longer static.\n+\t* trans-array.h (gfc_trans_scalarized_loop_end): New prototype.\n+\n 2009-07-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/40839"}, {"sha": "c625bc4bf60b780a085e0e5ae958d0c42171e477", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -2755,7 +2755,7 @@ gfc_start_scalarized_body (gfc_loopinfo * loop, stmtblock_t * pbody)\n \n /* Generates the actual loop code for a scalarization loop.  */\n \n-static void\n+void\n gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n \t\t\t       stmtblock_t * pbody)\n {\n@@ -2822,7 +2822,8 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       loopbody = gfc_finish_block (pbody);\n \n       /* Initialize the loopvar.  */\n-      gfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n+      if (loop->loopvar[n] != loop->from[n])\n+\tgfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n \n       exit_label = gfc_build_label_decl (NULL_TREE);\n "}, {"sha": "175b3c60ff5dd794ac2099ac833bbdac390167c3", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -1,5 +1,5 @@\n /* Header for array handling functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -84,6 +84,8 @@ void gfc_copy_loopinfo_to_se (gfc_se *, gfc_loopinfo *);\n \n /* Marks the start of a scalarized expression, and declares loop variables.  */\n void gfc_start_scalarized_body (gfc_loopinfo *, stmtblock_t *);\n+/* Generates one actual loop for a scalarized expression.  */\n+void  gfc_trans_scalarized_loop_end (gfc_loopinfo *, int, stmtblock_t *);\n /* Generates the actual loops for a scalarized expression.  */\n void gfc_trans_scalarizing_loops (gfc_loopinfo *, stmtblock_t *);\n /* Mark the end of the main loop body and the start of the copying loop.  */"}, {"sha": "779343224fd8fdd32eeffc66d4809a637b01d8a6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 543, "deletions": 30, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -2146,6 +2146,72 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n }\n \n \n+/* Emit code for minloc or maxloc intrinsic.  There are many different cases\n+   we need to handle.  For performance reasons we sometimes create two\n+   loops instead of one, where the second one is much simpler.\n+   Examples for minloc intrinsic:\n+   1) Result is an array, a call is generated\n+   2) Array mask is used and NaNs need to be supported:\n+      limit = Infinity;\n+      pos = 0;\n+      S = from;\n+      while (S <= to) {\n+\tif (mask[S]) {\n+\t  if (pos == 0) pos = S + (1 - from);\n+\t  if (a[S] <= limit) { limit = a[S]; pos = S + (1 - from); goto lab1; }\n+\t}\n+\tS++;\n+      }\n+      goto lab2;\n+      lab1:;\n+      while (S <= to) {\n+\tif (mask[S]) if (a[S] < limit) { limit = a[S]; pos = S + (1 - from); }\n+\tS++;\n+      }\n+      lab2:;\n+   3) NaNs need to be supported, but it is known at compile time or cheaply\n+      at runtime whether array is nonempty or not:\n+      limit = Infinity;\n+      pos = 0;\n+      S = from;\n+      while (S <= to) {\n+\tif (a[S] <= limit) { limit = a[S]; pos = S + (1 - from); goto lab1; }\n+\tS++;\n+      }\n+      if (from <= to) pos = 1;\n+      goto lab2;\n+      lab1:;\n+      while (S <= to) {\n+\tif (a[S] < limit) { limit = a[S]; pos = S + (1 - from); }\n+\tS++;\n+      }\n+      lab2:;\n+   4) NaNs aren't supported, array mask is used:\n+      limit = infinities_supported ? Infinity : huge (limit);\n+      pos = 0;\n+      S = from;\n+      while (S <= to) {\n+\tif (mask[S]) { limit = a[S]; pos = S + (1 - from); goto lab1; }\n+\tS++;\n+      }\n+      goto lab2;\n+      lab1:;\n+      while (S <= to) {\n+\tif (mask[S]) if (a[S] < limit) { limit = a[S]; pos = S + (1 - from); }\n+\tS++;\n+      }\n+      lab2:;\n+   5) Same without array mask:\n+      limit = infinities_supported ? Infinity : huge (limit);\n+      pos = (from <= to) ? 1 : 0;\n+      S = from;\n+      while (S <= to) {\n+\tif (a[S] < limit) { limit = a[S]; pos = S + (1 - from); }\n+\tS++;\n+      }\n+   For 3) and 5), if mask is scalar, this all goes into a conditional,\n+   setting pos = 0; in the else branch.  */\n+\n static void\n gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n {\n@@ -2156,9 +2222,12 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tree limit;\n   tree type;\n   tree tmp;\n+  tree cond;\n   tree elsetmp;\n   tree ifbody;\n   tree offset;\n+  tree nonempty;\n+  tree lab1, lab2;\n   gfc_loopinfo loop;\n   gfc_actual_arglist *actual;\n   gfc_ss *arrayss;\n@@ -2190,21 +2259,39 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   actual = actual->next->next;\n   gcc_assert (actual);\n   maskexpr = actual->expr;\n+  nonempty = NULL;\n   if (maskexpr && maskexpr->rank != 0)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n       gcc_assert (maskss != gfc_ss_terminator);\n     }\n   else\n-    maskss = NULL;\n+    {\n+      mpz_t asize;\n+      if (gfc_array_size (arrayexpr, &asize) == SUCCESS)\n+\t{\n+\t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n+\t  mpz_clear (asize);\n+\t  nonempty = fold_build2 (GT_EXPR, boolean_type_node, nonempty,\n+\t\t\t\t  gfc_index_zero_node);\n+\t}\n+      maskss = NULL;\n+    }\n \n   limit = gfc_create_var (gfc_typenode_for_spec (&arrayexpr->ts), \"limit\");\n   n = gfc_validate_kind (arrayexpr->ts.type, arrayexpr->ts.kind, false);\n   switch (arrayexpr->ts.type)\n     {\n     case BT_REAL:\n-      tmp = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge,\n-\t\t\t\t   arrayexpr->ts.kind, 0);\n+      if (HONOR_INFINITIES (DECL_MODE (limit)))\n+\t{\n+\t  REAL_VALUE_TYPE real;\n+\t  real_inf (&real);\n+\t  tmp = build_real (TREE_TYPE (limit), real);\n+\t}\n+      else\n+\ttmp = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge,\n+\t\t\t\t     arrayexpr->ts.kind, 0);\n       break;\n \n     case BT_INTEGER:\n@@ -2239,11 +2326,30 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_loop_setup (&loop, &expr->where);\n \n   gcc_assert (loop.dimen == 1);\n+  if (nonempty == NULL && maskss == NULL && loop.from[0] && loop.to[0])\n+    nonempty = fold_build2 (LE_EXPR, boolean_type_node, loop.from[0],\n+\t\t\t    loop.to[0]);\n \n+  lab1 = NULL;\n+  lab2 = NULL;\n   /* Initialize the position to zero, following Fortran 2003.  We are free\n      to do this because Fortran 95 allows the result of an entirely false\n-     mask to be processor dependent.  */\n-  gfc_add_modify (&loop.pre, pos, gfc_index_zero_node);\n+     mask to be processor dependent.  If we know at compile time the array\n+     is non-empty and no MASK is used, we can initialize to 1 to simplify\n+     the inner loop.  */\n+  if (nonempty != NULL && !HONOR_NANS (DECL_MODE (limit)))\n+    gfc_add_modify (&loop.pre, pos,\n+\t\t    fold_build3 (COND_EXPR, gfc_array_index_type,\n+\t\t\t\t nonempty, gfc_index_one_node,\n+\t\t\t\t gfc_index_zero_node));\n+  else\n+    {\n+      gfc_add_modify (&loop.pre, pos, gfc_index_zero_node);\n+      lab1 = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (lab1) = 1;\n+      lab2 = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (lab2) = 1;\n+    }\n \n   gfc_mark_ss_chain_used (arrayss, 1);\n   if (maskss)\n@@ -2285,27 +2391,47 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t       gfc_index_one_node, loop.from[0]);\n   else\n     tmp = gfc_index_one_node;\n-  \n+\n   gfc_add_modify (&block, offset, tmp);\n \n+  if (nonempty == NULL && HONOR_NANS (DECL_MODE (limit)))\n+    {\n+      stmtblock_t ifblock2;\n+      tree ifbody2;\n+\n+      gfc_start_block (&ifblock2);\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n+\t\t\t loop.loopvar[0], offset);\n+      gfc_add_modify (&ifblock2, pos, tmp);\n+      ifbody2 = gfc_finish_block (&ifblock2);\n+      cond = fold_build2 (EQ_EXPR, boolean_type_node, pos,\n+\t\t\t  gfc_index_zero_node);\n+      tmp = build3_v (COND_EXPR, cond, ifbody2,\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n   tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n \t\t     loop.loopvar[0], offset);\n   gfc_add_modify (&ifblock, pos, tmp);\n \n+  if (lab1)\n+    gfc_add_expr_to_block (&ifblock, build1_v (GOTO_EXPR, lab1));\n+\n   ifbody = gfc_finish_block (&ifblock);\n \n-  /* If it is a more extreme value or pos is still zero and the value\n-     equal to the limit.  */\n-  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t     fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t  pos, gfc_index_zero_node),\n-\t\t     fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t  arrayse.expr, limit));\n-  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t     fold_build2 (op, boolean_type_node,\n-\t\t\t\t  arrayse.expr, limit), tmp);\n-  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt (input_location));\n-  gfc_add_expr_to_block (&block, tmp);\n+  if (!lab1 || HONOR_NANS (DECL_MODE (limit)))\n+    {\n+      if (lab1)\n+\tcond = fold_build2 (op == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t    boolean_type_node, arrayse.expr, limit);\n+      else\n+\tcond = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\n+      ifbody = build3_v (COND_EXPR, cond, ifbody,\n+\t\t\t build_empty_stmt (input_location));\n+    }\n+  gfc_add_expr_to_block (&block, ifbody);\n \n   if (maskss)\n     {\n@@ -2319,8 +2445,95 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n     tmp = gfc_finish_block (&block);\n   gfc_add_expr_to_block (&body, tmp);\n \n+  if (lab1)\n+    {\n+      gfc_trans_scalarized_loop_end (&loop, 0, &body);\n+\n+      if (HONOR_NANS (DECL_MODE (limit)))\n+\t{\n+\t  if (nonempty != NULL)\n+\t    {\n+\t      ifbody = build2_v (MODIFY_EXPR, pos, gfc_index_one_node);\n+\t      tmp = build3_v (COND_EXPR, nonempty, ifbody,\n+\t\t\t      build_empty_stmt (input_location));\n+\t      gfc_add_expr_to_block (&loop.code[0], tmp);\n+\t    }\n+\t}\n+\n+      gfc_add_expr_to_block (&loop.code[0], build1_v (GOTO_EXPR, lab2));\n+      gfc_add_expr_to_block (&loop.code[0], build1_v (LABEL_EXPR, lab1));\n+      gfc_start_block (&body);\n+\n+      /* If we have a mask, only check this element if the mask is set.  */\n+      if (maskss)\n+\t{\n+\t  gfc_init_se (&maskse, NULL);\n+\t  gfc_copy_loopinfo_to_se (&maskse, &loop);\n+\t  maskse.ss = maskss;\n+\t  gfc_conv_expr_val (&maskse, maskexpr);\n+\t  gfc_add_block_to_block (&body, &maskse.pre);\n+\n+\t  gfc_start_block (&block);\n+\t}\n+      else\n+\tgfc_init_block (&block);\n+\n+      /* Compare with the current limit.  */\n+      gfc_init_se (&arrayse, NULL);\n+      gfc_copy_loopinfo_to_se (&arrayse, &loop);\n+      arrayse.ss = arrayss;\n+      gfc_conv_expr_val (&arrayse, arrayexpr);\n+      gfc_add_block_to_block (&block, &arrayse.pre);\n+\n+      /* We do the following if this is a more extreme value.  */\n+      gfc_start_block (&ifblock);\n+\n+      /* Assign the value to the limit...  */\n+      gfc_add_modify (&ifblock, limit, arrayse.expr);\n+\n+      /* Remember where we are.  An offset must be added to the loop\n+\t counter to obtain the required position.  */\n+      if (loop.from[0])\n+\ttmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t   gfc_index_one_node, loop.from[0]);\n+      else\n+\ttmp = gfc_index_one_node;\n+\n+      gfc_add_modify (&block, offset, tmp);\n+\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n+\t\t\t loop.loopvar[0], offset);\n+      gfc_add_modify (&ifblock, pos, tmp);\n+\n+      ifbody = gfc_finish_block (&ifblock);\n+\n+      cond = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\n+      tmp = build3_v (COND_EXPR, cond, ifbody,\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      if (maskss)\n+\t{\n+\t  /* We enclose the above in if (mask) {...}.  */\n+\t  tmp = gfc_finish_block (&block);\n+\n+\t  tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n+\t}\n+      else\n+\ttmp = gfc_finish_block (&block);\n+      gfc_add_expr_to_block (&body, tmp);\n+      /* Avoid initializing loopvar[0] again, it should be left where\n+\t it finished by the first loop.  */\n+      loop.from[0] = loop.loopvar[0];\n+    }\n+\n   gfc_trans_scalarizing_loops (&loop, &body);\n \n+  if (lab2)\n+    gfc_add_expr_to_block (&loop.pre, build1_v (LABEL_EXPR, lab2));\n+\n   /* For a scalar mask, enclose the loop in an if statement.  */\n   if (maskexpr && maskss == NULL)\n     {\n@@ -2352,15 +2565,113 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   se->expr = convert (type, pos);\n }\n \n+/* Emit code for minval or maxval intrinsic.  There are many different cases\n+   we need to handle.  For performance reasons we sometimes create two\n+   loops instead of one, where the second one is much simpler.\n+   Examples for minval intrinsic:\n+   1) Result is an array, a call is generated\n+   2) Array mask is used and NaNs need to be supported, rank 1:\n+      limit = Infinity;\n+      nonempty = false;\n+      S = from;\n+      while (S <= to) {\n+\tif (mask[S]) { nonempty = true; if (a[S] <= limit) goto lab; }\n+\tS++;\n+      }\n+      limit = nonempty ? NaN : huge (limit);\n+      lab:\n+      while (S <= to) { if(mask[S]) limit = min (a[S], limit); S++; }\n+   3) NaNs need to be supported, but it is known at compile time or cheaply\n+      at runtime whether array is nonempty or not, rank 1:\n+      limit = Infinity;\n+      S = from;\n+      while (S <= to) { if (a[S] <= limit) goto lab; S++; }\n+      limit = (from <= to) ? NaN : huge (limit);\n+      lab:\n+      while (S <= to) { limit = min (a[S], limit); S++; }\n+   4) Array mask is used and NaNs need to be supported, rank > 1:\n+      limit = Infinity;\n+      nonempty = false;\n+      fast = false;\n+      S1 = from1;\n+      while (S1 <= to1) {\n+\tS2 = from2;\n+\twhile (S2 <= to2) {\n+\t  if (mask[S1][S2]) {\n+\t    if (fast) limit = min (a[S1][S2], limit);\n+\t    else {\n+\t      nonempty = true;\n+\t      if (a[S1][S2] <= limit) {\n+\t\tlimit = a[S1][S2];\n+\t\tfast = true;\n+\t      }\n+\t    }\n+\t  }\n+\t  S2++;\n+\t}\n+\tS1++;\n+      }\n+      if (!fast)\n+\tlimit = nonempty ? NaN : huge (limit);\n+   5) NaNs need to be supported, but it is known at compile time or cheaply\n+      at runtime whether array is nonempty or not, rank > 1:\n+      limit = Infinity;\n+      fast = false;\n+      S1 = from1;\n+      while (S1 <= to1) {\n+\tS2 = from2;\n+\twhile (S2 <= to2) {\n+\t  if (fast) limit = min (a[S1][S2], limit);\n+\t  else {\n+\t    if (a[S1][S2] <= limit) {\n+\t      limit = a[S1][S2];\n+\t      fast = true;\n+\t    }\n+\t  }\n+\t  S2++;\n+\t}\n+\tS1++;\n+      }\n+      if (!fast)\n+\tlimit = (nonempty_array) ? NaN : huge (limit);\n+   6) NaNs aren't supported, but infinities are.  Array mask is used:\n+      limit = Infinity;\n+      nonempty = false;\n+      S = from;\n+      while (S <= to) {\n+\tif (mask[S]) { nonempty = true; limit = min (a[S], limit); }\n+\tS++;\n+      }\n+      limit = nonempty ? limit : huge (limit);\n+   7) Same without array mask:\n+      limit = Infinity;\n+      S = from;\n+      while (S <= to) { limit = min (a[S], limit); S++; }\n+      limit = (from <= to) ? limit : huge (limit);\n+   8) Neither NaNs nor infinities are supported (-ffast-math or BT_INTEGER):\n+      limit = huge (limit);\n+      S = from;\n+      while (S <= to) { limit = min (a[S], limit); S++); }\n+      (or\n+      while (S <= to) { if (mask[S]) limit = min (a[S], limit); S++; }\n+      with array mask instead).\n+   For 3), 5), 7) and 8), if mask is scalar, this all goes into a conditional,\n+   setting limit = huge (limit); in the else branch.  */\n+\n static void\n gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n {\n   tree limit;\n   tree type;\n   tree tmp;\n   tree ifbody;\n+  tree nonempty;\n+  tree nonempty_var;\n+  tree lab;\n+  tree fast;\n+  tree huge_cst = NULL, nan_cst = NULL;\n   stmtblock_t body;\n-  stmtblock_t block;\n+  stmtblock_t block, block2;\n   gfc_loopinfo loop;\n   gfc_actual_arglist *actual;\n   gfc_ss *arrayss;\n@@ -2384,7 +2695,22 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   switch (expr->ts.type)\n     {\n     case BT_REAL:\n-      tmp = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge, expr->ts.kind, 0);\n+      huge_cst = gfc_conv_mpfr_to_tree (gfc_real_kinds[n].huge,\n+\t\t\t\t\texpr->ts.kind, 0);\n+      if (HONOR_INFINITIES (DECL_MODE (limit)))\n+\t{\n+\t  REAL_VALUE_TYPE real;\n+\t  real_inf (&real);\n+\t  tmp = build_real (type, real);\n+\t}\n+      else\n+\ttmp = huge_cst;\n+      if (HONOR_NANS (DECL_MODE (limit)))\n+\t{\n+\t  REAL_VALUE_TYPE real;\n+\t  real_nan (&real, \"\", 1, DECL_MODE (limit));\n+\t  nan_cst = build_real (type, real);\n+\t}\n       break;\n \n     case BT_INTEGER:\n@@ -2400,7 +2726,11 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n      -HUGE for BT_REAL and (-HUGE - 1) for BT_INTEGER; the most positive\n      possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n-    tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n+    {\n+      tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n+      if (huge_cst)\n+\thuge_cst = fold_build1 (NEGATE_EXPR, TREE_TYPE (huge_cst), huge_cst);\n+    }\n \n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n     tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp),\n@@ -2417,13 +2747,24 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   actual = actual->next->next;\n   gcc_assert (actual);\n   maskexpr = actual->expr;\n+  nonempty = NULL;\n   if (maskexpr && maskexpr->rank != 0)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n       gcc_assert (maskss != gfc_ss_terminator);\n     }\n   else\n-    maskss = NULL;\n+    {\n+      mpz_t asize;\n+      if (gfc_array_size (arrayexpr, &asize) == SUCCESS)\n+\t{\n+\t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n+\t  mpz_clear (asize);\n+\t  nonempty = fold_build2 (GT_EXPR, boolean_type_node, nonempty,\n+\t\t\t\t  gfc_index_zero_node);\n+\t}\n+      maskss = NULL;\n+    }\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -2435,6 +2776,35 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_ss_startstride (&loop);\n   gfc_conv_loop_setup (&loop, &expr->where);\n \n+  if (nonempty == NULL && maskss == NULL\n+      && loop.dimen == 1 && loop.from[0] && loop.to[0])\n+    nonempty = fold_build2 (LE_EXPR, boolean_type_node, loop.from[0],\n+\t\t\t    loop.to[0]);\n+  nonempty_var = NULL;\n+  if (nonempty == NULL\n+      && (HONOR_INFINITIES (DECL_MODE (limit))\n+\t  || HONOR_NANS (DECL_MODE (limit))))\n+    {\n+      nonempty_var = gfc_create_var (boolean_type_node, \"nonempty\");\n+      gfc_add_modify (&se->pre, nonempty_var, boolean_false_node);\n+      nonempty = nonempty_var;\n+    }\n+  lab = NULL;\n+  fast = NULL;\n+  if (HONOR_NANS (DECL_MODE (limit)))\n+    {\n+      if (loop.dimen == 1)\n+\t{\n+\t  lab = gfc_build_label_decl (NULL_TREE);\n+\t  TREE_USED (lab) = 1;\n+\t}\n+      else\n+\t{\n+\t  fast = gfc_create_var (boolean_type_node, \"fast\");\n+\t  gfc_add_modify (&se->pre, fast, boolean_false_node);\n+\t}\n+    }\n+\n   gfc_mark_ss_chain_used (arrayss, 1);\n   if (maskss)\n     gfc_mark_ss_chain_used (maskss, 1);\n@@ -2462,13 +2832,76 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_expr_val (&arrayse, arrayexpr);\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n-  /* Assign the value to the limit...  */\n-  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n+  gfc_init_block (&block2);\n+\n+  if (nonempty_var)\n+    gfc_add_modify (&block2, nonempty_var, boolean_true_node);\n+\n+  if (HONOR_NANS (DECL_MODE (limit)))\n+    {\n+      tmp = fold_build2 (op == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t boolean_type_node, arrayse.expr, limit);\n+      if (lab)\n+\tifbody = build1_v (GOTO_EXPR, lab);\n+      else\n+\t{\n+\t  stmtblock_t ifblock;\n+\n+\t  gfc_init_block (&ifblock);\n+\t  gfc_add_modify (&ifblock, limit, arrayse.expr);\n+\t  gfc_add_modify (&ifblock, fast, boolean_true_node);\n+\t  ifbody = gfc_finish_block (&ifblock);\n+\t}\n+      tmp = build3_v (COND_EXPR, tmp, ifbody,\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block2, tmp);\n+    }\n+  else\n+    {\n+      /* MIN_EXPR/MAX_EXPR has unspecified behavior with NaNs or\n+\t signed zeros.  */\n+      if (HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n+\t{\n+\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n+\t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n+\t\t\t  build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&block2, tmp);\n+\t}\n+      else\n+\t{\n+\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t     type, arrayse.expr, limit);\n+\t  gfc_add_modify (&block2, limit, tmp);\n+\t}\n+    }\n+\n+  if (fast)\n+    {\n+      tree elsebody = gfc_finish_block (&block2);\n+\n+      /* MIN_EXPR/MAX_EXPR has unspecified behavior with NaNs or\n+\t signed zeros.  */\n+      if (HONOR_NANS (DECL_MODE (limit))\n+\t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n+\t{\n+\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n+\t  ifbody = build3_v (COND_EXPR, tmp, ifbody,\n+\t\t\t     build_empty_stmt (input_location));\n+\t}\n+      else\n+\t{\n+\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t     type, arrayse.expr, limit);\n+\t  ifbody = build2_v (MODIFY_EXPR, limit, tmp);\n+\t}\n+      tmp = build3_v (COND_EXPR, fast, ifbody, elsebody);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  else\n+    gfc_add_block_to_block (&block, &block2);\n \n-  /* If it is a more extreme value.  */\n-  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n-  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt (input_location));\n-  gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n   tmp = gfc_finish_block (&block);\n@@ -2478,20 +2911,100 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t    build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n+  if (lab)\n+    {\n+      gfc_trans_scalarized_loop_end (&loop, 0, &body);\n+\n+      tmp = fold_build3 (COND_EXPR, type, nonempty, nan_cst, huge_cst);\n+      gfc_add_modify (&loop.code[0], limit, tmp);\n+      gfc_add_expr_to_block (&loop.code[0], build1_v (LABEL_EXPR, lab));\n+\n+      gfc_start_block (&body);\n+\n+      /* If we have a mask, only add this element if the mask is set.  */\n+      if (maskss)\n+\t{\n+\t  gfc_init_se (&maskse, NULL);\n+\t  gfc_copy_loopinfo_to_se (&maskse, &loop);\n+\t  maskse.ss = maskss;\n+\t  gfc_conv_expr_val (&maskse, maskexpr);\n+\t  gfc_add_block_to_block (&body, &maskse.pre);\n+\n+\t  gfc_start_block (&block);\n+\t}\n+      else\n+\tgfc_init_block (&block);\n+\n+      /* Compare with the current limit.  */\n+      gfc_init_se (&arrayse, NULL);\n+      gfc_copy_loopinfo_to_se (&arrayse, &loop);\n+      arrayse.ss = arrayss;\n+      gfc_conv_expr_val (&arrayse, arrayexpr);\n+      gfc_add_block_to_block (&block, &arrayse.pre);\n+\n+      /* MIN_EXPR/MAX_EXPR has unspecified behavior with NaNs or\n+\t signed zeros.  */\n+      if (HONOR_NANS (DECL_MODE (limit))\n+\t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n+\t{\n+\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n+\t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n+\t\t\t  build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      else\n+\t{\n+\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t     type, arrayse.expr, limit);\n+\t  gfc_add_modify (&block, limit, tmp);\n+\t}\n+\n+      gfc_add_block_to_block (&block, &arrayse.post);\n+\n+      tmp = gfc_finish_block (&block);\n+      if (maskss)\n+\t/* We enclose the above in if (mask) {...}.  */\n+\ttmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t\tbuild_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&body, tmp);\n+      /* Avoid initializing loopvar[0] again, it should be left where\n+\t it finished by the first loop.  */\n+      loop.from[0] = loop.loopvar[0];\n+    }\n   gfc_trans_scalarizing_loops (&loop, &body);\n \n+  if (fast)\n+    {\n+      tmp = fold_build3 (COND_EXPR, type, nonempty, nan_cst, huge_cst);\n+      ifbody = build2_v (MODIFY_EXPR, limit, tmp);\n+      tmp = build3_v (COND_EXPR, fast, build_empty_stmt (input_location),\n+\t\t      ifbody);\n+      gfc_add_expr_to_block (&loop.pre, tmp);\n+    }\n+  else if (HONOR_INFINITIES (DECL_MODE (limit)) && !lab)\n+    {\n+      tmp = fold_build3 (COND_EXPR, type, nonempty, limit, huge_cst);\n+      gfc_add_modify (&loop.pre, limit, tmp);\n+    }\n+\n   /* For a scalar mask, enclose the loop in an if statement.  */\n   if (maskexpr && maskss == NULL)\n     {\n+      tree else_stmt;\n+\n       gfc_init_se (&maskse, NULL);\n       gfc_conv_expr_val (&maskse, maskexpr);\n       gfc_init_block (&block);\n       gfc_add_block_to_block (&block, &loop.pre);\n       gfc_add_block_to_block (&block, &loop.post);\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n-\t\t      build_empty_stmt (input_location));\n+      if (HONOR_INFINITIES (DECL_MODE (limit)))\n+\telse_stmt = build2_v (MODIFY_EXPR, limit, huge_cst);\n+      else\n+\telse_stmt = build_empty_stmt (input_location);\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp, else_stmt);\n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&se->pre, &block);\n     }"}, {"sha": "671f681caf57a40106f34a11bc23920a7283b582", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -1,3 +1,15 @@\n+2009-07-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/40643\n+\tPR fortran/31067\n+\t* gfortran.dg/maxlocval_2.f90: New test.\n+\t* gfortran.dg/maxlocval_3.f90: New test.\n+\t* gfortran.dg/maxlocval_4.f90: New test.\n+\t* gfortran.dg/minlocval_1.f90: New test.\n+\t* gfortran.dg/minlocval_2.f90: New test.\n+\t* gfortran.dg/minlocval_3.f90: New test.\n+\t* gfortran.dg/minlocval_4.f90: New test.\n+\n 2009-07-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/dll-4.c: Allow foo1 and foo2 in either order in"}, {"sha": "82f917a9bc16047e2f06b07c2950ac24f60f003b", "filename": "gcc/testsuite/gfortran.dg/maxlocval_2.f90", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_2.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,153 @@\n+! { dg-do run }\n+  real :: a(3), nan, minf, pinf\n+  real, allocatable :: c(:)\n+  logical :: l\n+  logical :: l2(3)\n+\n+  nan = 0.0\n+  minf = 0.0\n+  pinf = 0.0\n+  nan = 0.0/nan\n+  minf = -1.0/minf\n+  pinf = 1.0/pinf\n+\n+  allocate (c(3))\n+  a(:) = nan\n+  if (maxloc (a, dim = 1).ne.1) call abort\n+  if (.not.isnan(maxval (a, dim = 1))) call abort\n+  a(:) = minf\n+  if (maxloc (a, dim = 1).ne.1) call abort\n+  if (maxval (a, dim = 1).ne.minf) call abort\n+  a(1:2) = nan\n+  if (maxloc (a, dim = 1).ne.3) call abort\n+  if (maxval (a, dim = 1).ne.minf) call abort\n+  a(2) = 1.0\n+  if (maxloc (a, dim = 1).ne.2) call abort\n+  if (maxval (a, dim = 1).ne.1) call abort\n+  a(2) = pinf\n+  if (maxloc (a, dim = 1).ne.2) call abort\n+  if (maxval (a, dim = 1).ne.pinf) call abort\n+  c(:) = nan\n+  if (maxloc (c, dim = 1).ne.1) call abort\n+  if (.not.isnan(maxval (c, dim = 1))) call abort\n+  c(:) = minf\n+  if (maxloc (c, dim = 1).ne.1) call abort\n+  if (maxval (c, dim = 1).ne.minf) call abort\n+  c(1:2) = nan\n+  if (maxloc (c, dim = 1).ne.3) call abort\n+  if (maxval (c, dim = 1).ne.minf) call abort\n+  c(2) = 1.0\n+  if (maxloc (c, dim = 1).ne.2) call abort\n+  if (maxval (c, dim = 1).ne.1) call abort\n+  c(2) = pinf\n+  if (maxloc (c, dim = 1).ne.2) call abort\n+  if (maxval (c, dim = 1).ne.pinf) call abort\n+  l = .false.\n+  l2(:) = .false.\n+  a(:) = nan\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  a(:) = minf\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  a(1:2) = nan\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  a(2) = 1.0\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  a(2) = pinf\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  c(:) = nan\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  c(:) = minf\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  c(1:2) = nan\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  c(2) = 1.0\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  c(2) = pinf\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(minf)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(minf)) call abort\n+  l = .true.\n+  l2(:) = .true.\n+  a(:) = nan\n+  if (maxloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (.not.isnan(maxval (a, dim = 1, mask = l))) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (.not.isnan(maxval (a, dim = 1, mask = l2))) call abort\n+  a(:) = minf\n+  if (maxloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.minf) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.minf) call abort\n+  a(1:2) = nan\n+  if (maxloc (a, dim = 1, mask = l).ne.3) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.minf) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.3) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.minf) call abort\n+  a(2) = 1.0\n+  if (maxloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.1) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.1) call abort\n+  a(2) = pinf\n+  if (maxloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.pinf) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.pinf) call abort\n+  c(:) = nan\n+  if (maxloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (.not.isnan(maxval (c, dim = 1, mask = l))) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (.not.isnan(maxval (c, dim = 1, mask = l2))) call abort\n+  c(:) = minf\n+  if (maxloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.minf) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.minf) call abort\n+  c(1:2) = nan\n+  if (maxloc (c, dim = 1, mask = l).ne.3) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.minf) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.3) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.minf) call abort\n+  c(2) = 1.0\n+  if (maxloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.1) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.1) call abort\n+  c(2) = pinf\n+  if (maxloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.pinf) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.pinf) call abort\n+  deallocate (c)\n+  allocate (c(-2:-3))\n+  if (maxloc (c, dim = 1).ne.0) call abort\n+  if (maxval (c, dim = 1).ne.-huge(minf)) call abort\n+end"}, {"sha": "cbd35957b1356e4c53bd3ff7d80452c59e3c27d0", "filename": "gcc/testsuite/gfortran.dg/maxlocval_3.f90", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_3.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,122 @@\n+! { dg-do run }\n+  integer :: a(3), h\n+  integer, allocatable :: c(:)\n+  logical :: l\n+  logical :: l2(3)\n+\n+  h = -huge(h)\n+  h = h - 1\n+  allocate (c(3))\n+  a(:) = 5\n+  if (maxloc (a, dim = 1).ne.1) call abort\n+  if (maxval (a, dim = 1).ne.5) call abort\n+  a(2) = huge(h)\n+  if (maxloc (a, dim = 1).ne.2) call abort\n+  if (maxval (a, dim = 1).ne.huge(h)) call abort\n+  a(:) = h\n+  if (maxloc (a, dim = 1).ne.1) call abort\n+  if (maxval (a, dim = 1).ne.h) call abort\n+  a(3) = -huge(h)\n+  if (maxloc (a, dim = 1).ne.3) call abort\n+  if (maxval (a, dim = 1).ne.-huge(h)) call abort\n+  c(:) = 5\n+  if (maxloc (c, dim = 1).ne.1) call abort\n+  if (maxval (c, dim = 1).ne.5) call abort\n+  c(2) = huge(h)\n+  if (maxloc (c, dim = 1).ne.2) call abort\n+  if (maxval (c, dim = 1).ne.huge(h)) call abort\n+  c(:) = h\n+  if (maxloc (c, dim = 1).ne.1) call abort\n+  if (maxval (c, dim = 1).ne.h) call abort\n+  c(3) = -huge(h)\n+  if (maxloc (c, dim = 1).ne.3) call abort\n+  if (maxval (c, dim = 1).ne.-huge(h)) call abort\n+  l = .false.\n+  l2(:) = .false.\n+  a(:) = 5\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.h) call abort\n+  a(2) = huge(h)\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.h) call abort\n+  a(:) = h\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.h) call abort\n+  a(3) = -huge(h)\n+  if (maxloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.h) call abort\n+  c(:) = 5\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.h) call abort\n+  c(2) = huge(h)\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.h) call abort\n+  c(:) = h\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.h) call abort\n+  c(3) = -huge(h)\n+  if (maxloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.h) call abort\n+  l = .true.\n+  l2(:) = .true.\n+  a(:) = 5\n+  if (maxloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.5) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.5) call abort\n+  a(2) = huge(h)\n+  if (maxloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  a(:) = h\n+  if (maxloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.h) call abort\n+  a(3) = -huge(h)\n+  if (maxloc (a, dim = 1, mask = l).ne.3) call abort\n+  if (maxval (a, dim = 1, mask = l).ne.-huge(h)) call abort\n+  if (maxloc (a, dim = 1, mask = l2).ne.3) call abort\n+  if (maxval (a, dim = 1, mask = l2).ne.-huge(h)) call abort\n+  c(:) = 5\n+  if (maxloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.5) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.5) call abort\n+  c(2) = huge(h)\n+  if (maxloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(:) = h\n+  if (maxloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.h) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.h) call abort\n+  c(3) = -huge(h)\n+  if (maxloc (c, dim = 1, mask = l).ne.3) call abort\n+  if (maxval (c, dim = 1, mask = l).ne.-huge(h)) call abort\n+  if (maxloc (c, dim = 1, mask = l2).ne.3) call abort\n+  if (maxval (c, dim = 1, mask = l2).ne.-huge(h)) call abort\n+  deallocate (c)\n+  allocate (c(-2:-3))\n+  if (maxloc (c, dim = 1).ne.0) call abort\n+  if (maxval (c, dim = 1).ne.h) call abort\n+end"}, {"sha": "408b08d6fadcea8d37f335c57bc918f5ecb860a7", "filename": "gcc/testsuite/gfortran.dg/maxlocval_4.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxlocval_4.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+  real :: a(3,3), b(3), nan, minf, pinf, h\n+  logical :: l, l2\n+  logical :: l3(3,3), l4(3,3), l5(3,3)\n+\n+  nan = 0.0\n+  minf = 0.0\n+  pinf = 0.0\n+  nan = 0.0/nan\n+  minf = -1.0/minf\n+  pinf = 1.0/pinf\n+  h = -huge(h)\n+  l = .false.\n+  l2 = .true.\n+  l3 = .false.\n+  l4 = .true.\n+  l5 = .true.\n+  l5(1,1) = .false.\n+  l5(1,2) = .false.\n+  l5(2,3) = .false.\n+  a = reshape ((/ nan, nan, nan, minf, minf, minf, minf, pinf, minf /), (/ 3, 3 /))\n+  if (maxval (a).ne.pinf) call abort\n+  if (any (maxloc (a).ne.(/ 2, 3 /))) call abort\n+  b = maxval (a, dim = 1)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, minf, pinf /))) call abort\n+  if (any (maxloc (a, dim = 1).ne.(/ 1, 1, 2 /))) call abort\n+  b = maxval (a, dim = 2)\n+  if (any (b.ne.(/ minf, pinf, minf /))) call abort\n+  if (any (maxloc (a, dim = 2).ne.(/ 2, 3, 2 /))) call abort\n+  if (maxval (a, mask = l).ne.h) call abort\n+  if (any (maxloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  b = maxval (a, dim = 1, mask = l)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (maxloc (a, dim = 1, mask = l).ne.(/ 0, 0, 0 /))) call abort\n+  b = maxval (a, dim = 2, mask = l)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (maxloc (a, dim = 2, mask = l).ne.(/ 0, 0, 0 /))) call abort\n+  if (maxval (a, mask = l3).ne.h) call abort\n+  if (any (maxloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  b = maxval (a, dim = 1, mask = l3)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (maxloc (a, dim = 1, mask = l3).ne.(/ 0, 0, 0 /))) call abort\n+  b = maxval (a, dim = 2, mask = l3)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (maxloc (a, dim = 2, mask = l3).ne.(/ 0, 0, 0 /))) call abort\n+  if (maxval (a, mask = l2).ne.pinf) call abort\n+  if (maxval (a, mask = l4).ne.pinf) call abort\n+  if (any (maxloc (a, mask = l2).ne.(/ 2, 3 /))) call abort\n+  if (any (maxloc (a, mask = l4).ne.(/ 2, 3 /))) call abort\n+  b = maxval (a, dim = 1, mask = l2)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, minf, pinf /))) call abort\n+  if (any (maxloc (a, dim = 1, mask = l2).ne.(/ 1, 1, 2 /))) call abort\n+  b = maxval (a, dim = 2, mask = l2)\n+  if (any (b.ne.(/ minf, pinf, minf /))) call abort\n+  if (any (maxloc (a, dim = 2, mask = l2).ne.(/ 2, 3, 2 /))) call abort\n+  b = maxval (a, dim = 1, mask = l4)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, minf, pinf /))) call abort\n+  if (any (maxloc (a, dim = 1, mask = l2).ne.(/ 1, 1, 2 /))) call abort\n+  b = maxval (a, dim = 2, mask = l4)\n+  if (any (b.ne.(/ minf, pinf, minf /))) call abort\n+  if (any (maxloc (a, dim = 2, mask = l2).ne.(/ 2, 3, 2 /))) call abort\n+  if (maxval (a, mask = l5).ne.minf) call abort\n+  if (any (maxloc (a, mask = l5).ne.(/ 2, 2 /))) call abort\n+  b = maxval (a, dim = 1, mask = l5)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, minf, minf /))) call abort\n+  if (any (maxloc (a, dim = 1, mask = l5).ne.(/ 2, 2, 1 /))) call abort\n+  b = maxval (a, dim = 2, mask = l5)\n+  if (any (b.ne.(/ minf, minf, minf /))) call abort\n+  if (any (maxloc (a, dim = 2, mask = l5).ne.(/ 3, 2, 2 /))) call abort\n+  a = nan\n+  if (.not.isnan(maxval (a))) call abort\n+  if (maxval (a, mask = l).ne.h) call abort\n+  if (.not.isnan(maxval (a, mask = l2))) call abort\n+  if (maxval (a, mask = l3).ne.h) call abort\n+  if (.not.isnan(maxval (a, mask = l4))) call abort\n+  if (.not.isnan(maxval (a, mask = l5))) call abort\n+  if (any (maxloc (a).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l2).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l4).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l5).ne.(/ 2, 1 /))) call abort\n+  a = minf\n+  if (maxval (a).ne.minf) call abort\n+  if (maxval (a, mask = l).ne.h) call abort\n+  if (maxval (a, mask = l2).ne.minf) call abort\n+  if (maxval (a, mask = l3).ne.h) call abort\n+  if (maxval (a, mask = l4).ne.minf) call abort\n+  if (maxval (a, mask = l5).ne.minf) call abort\n+  if (any (maxloc (a).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l2).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l4).ne.(/ 1, 1 /))) call abort\n+  if (any (maxloc (a, mask = l5).ne.(/ 2, 1 /))) call abort\n+  a = nan\n+  a(1,3) = minf\n+  if (maxval (a).ne.minf) call abort\n+  if (maxval (a, mask = l).ne.h) call abort\n+  if (maxval (a, mask = l2).ne.minf) call abort\n+  if (maxval (a, mask = l3).ne.h) call abort\n+  if (maxval (a, mask = l4).ne.minf) call abort\n+  if (maxval (a, mask = l5).ne.minf) call abort\n+  if (any (maxloc (a).ne.(/ 1, 3 /))) call abort\n+  if (any (maxloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l2).ne.(/ 1, 3 /))) call abort\n+  if (any (maxloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (maxloc (a, mask = l4).ne.(/ 1, 3 /))) call abort\n+  if (any (maxloc (a, mask = l5).ne.(/ 1, 3 /))) call abort\n+end"}, {"sha": "f821e54bd68bec024eb67394c2f32f59445b6a5c", "filename": "gcc/testsuite/gfortran.dg/minlocval_1.f90", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_1.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,153 @@\n+! { dg-do run }\n+  real :: a(3), nan, minf, pinf\n+  real, allocatable :: c(:)\n+  logical :: l\n+  logical :: l2(3)\n+\n+  nan = 0.0\n+  minf = 0.0\n+  pinf = 0.0\n+  nan = 0.0/nan\n+  minf = -1.0/minf\n+  pinf = 1.0/pinf\n+\n+  allocate (c(3))\n+  a(:) = nan\n+  if (minloc (a, dim = 1).ne.1) call abort\n+  if (.not.isnan(minval (a, dim = 1))) call abort\n+  a(:) = pinf\n+  if (minloc (a, dim = 1).ne.1) call abort\n+  if (minval (a, dim = 1).ne.pinf) call abort\n+  a(1:2) = nan\n+  if (minloc (a, dim = 1).ne.3) call abort\n+  if (minval (a, dim = 1).ne.pinf) call abort\n+  a(2) = 1.0\n+  if (minloc (a, dim = 1).ne.2) call abort\n+  if (minval (a, dim = 1).ne.1) call abort\n+  a(2) = minf\n+  if (minloc (a, dim = 1).ne.2) call abort\n+  if (minval (a, dim = 1).ne.minf) call abort\n+  c(:) = nan\n+  if (minloc (c, dim = 1).ne.1) call abort\n+  if (.not.isnan(minval (c, dim = 1))) call abort\n+  c(:) = pinf\n+  if (minloc (c, dim = 1).ne.1) call abort\n+  if (minval (c, dim = 1).ne.pinf) call abort\n+  c(1:2) = nan\n+  if (minloc (c, dim = 1).ne.3) call abort\n+  if (minval (c, dim = 1).ne.pinf) call abort\n+  c(2) = 1.0\n+  if (minloc (c, dim = 1).ne.2) call abort\n+  if (minval (c, dim = 1).ne.1) call abort\n+  c(2) = minf\n+  if (minloc (c, dim = 1).ne.2) call abort\n+  if (minval (c, dim = 1).ne.minf) call abort\n+  l = .false.\n+  l2(:) = .false.\n+  a(:) = nan\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  a(:) = pinf\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  a(1:2) = nan\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  a(2) = 1.0\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  a(2) = minf\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  c(:) = nan\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  c(:) = pinf\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  c(1:2) = nan\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  c(2) = 1.0\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  c(2) = minf\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(pinf)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(pinf)) call abort\n+  l = .true.\n+  l2(:) = .true.\n+  a(:) = nan\n+  if (minloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (.not.isnan(minval (a, dim = 1, mask = l))) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (.not.isnan(minval (a, dim = 1, mask = l2))) call abort\n+  a(:) = pinf\n+  if (minloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l).ne.pinf) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.pinf) call abort\n+  a(1:2) = nan\n+  if (minloc (a, dim = 1, mask = l).ne.3) call abort\n+  if (minval (a, dim = 1, mask = l).ne.pinf) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.3) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.pinf) call abort\n+  a(2) = 1.0\n+  if (minloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l).ne.1) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.1) call abort\n+  a(2) = minf\n+  if (minloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l).ne.minf) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.minf) call abort\n+  c(:) = nan\n+  if (minloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (.not.isnan(minval (c, dim = 1, mask = l))) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (.not.isnan(minval (c, dim = 1, mask = l2))) call abort\n+  c(:) = pinf\n+  if (minloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l).ne.pinf) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.pinf) call abort\n+  c(1:2) = nan\n+  if (minloc (c, dim = 1, mask = l).ne.3) call abort\n+  if (minval (c, dim = 1, mask = l).ne.pinf) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.3) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.pinf) call abort\n+  c(2) = 1.0\n+  if (minloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l).ne.1) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.1) call abort\n+  c(2) = minf\n+  if (minloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l).ne.minf) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.minf) call abort\n+  deallocate (c)\n+  allocate (c(-2:-3))\n+  if (minloc (c, dim = 1).ne.0) call abort\n+  if (minval (c, dim = 1).ne.huge(pinf)) call abort\n+end"}, {"sha": "8e04dc6ded88a92cc8f39c11cedb5597300fea03", "filename": "gcc/testsuite/gfortran.dg/minlocval_2.f90", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_2.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,122 @@\n+! { dg-do run }\n+  integer :: a(3), h\n+  integer, allocatable :: c(:)\n+  logical :: l\n+  logical :: l2(3)\n+\n+  h = -huge(h)\n+  h = h - 1\n+  allocate (c(3))\n+  a(:) = 5\n+  if (minloc (a, dim = 1).ne.1) call abort\n+  if (minval (a, dim = 1).ne.5) call abort\n+  a(2) = h\n+  if (minloc (a, dim = 1).ne.2) call abort\n+  if (minval (a, dim = 1).ne.h) call abort\n+  a(:) = huge(h)\n+  if (minloc (a, dim = 1).ne.1) call abort\n+  if (minval (a, dim = 1).ne.huge(h)) call abort\n+  a(3) = huge(h) - 1\n+  if (minloc (a, dim = 1).ne.3) call abort\n+  if (minval (a, dim = 1).ne.huge(h)-1) call abort\n+  c(:) = 5\n+  if (minloc (c, dim = 1).ne.1) call abort\n+  if (minval (c, dim = 1).ne.5) call abort\n+  c(2) = h\n+  if (minloc (c, dim = 1).ne.2) call abort\n+  if (minval (c, dim = 1).ne.h) call abort\n+  c(:) = huge(h)\n+  if (minloc (c, dim = 1).ne.1) call abort\n+  if (minval (c, dim = 1).ne.huge(h)) call abort\n+  c(3) = huge(h) - 1\n+  if (minloc (c, dim = 1).ne.3) call abort\n+  if (minval (c, dim = 1).ne.huge(h)-1) call abort\n+  l = .false.\n+  l2(:) = .false.\n+  a(:) = 5\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  a(2) = h\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  a(:) = huge(h)\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  a(3) = huge(h) - 1\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(:) = 5\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(2) = h\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(:) = huge(h)\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(3) = huge(h) - 1\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  l = .true.\n+  l2(:) = .true.\n+  a(:) = 5\n+  if (minloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l).ne.5) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.5) call abort\n+  a(2) = h\n+  if (minloc (a, dim = 1, mask = l).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l).ne.h) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.h) call abort\n+  a(:) = huge(h)\n+  if (minloc (a, dim = 1, mask = l).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)) call abort\n+  a(3) = huge(h) - 1\n+  if (minloc (a, dim = 1, mask = l).ne.3) call abort\n+  if (minval (a, dim = 1, mask = l).ne.huge(h)-1) call abort\n+  if (minloc (a, dim = 1, mask = l2).ne.3) call abort\n+  if (minval (a, dim = 1, mask = l2).ne.huge(h)-1) call abort\n+  c(:) = 5\n+  if (minloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l).ne.5) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.5) call abort\n+  c(2) = h\n+  if (minloc (c, dim = 1, mask = l).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l).ne.h) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.2) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.h) call abort\n+  c(:) = huge(h)\n+  if (minloc (c, dim = 1, mask = l).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.1) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)) call abort\n+  c(3) = huge(h) - 1\n+  if (minloc (c, dim = 1, mask = l).ne.3) call abort\n+  if (minval (c, dim = 1, mask = l).ne.huge(h)-1) call abort\n+  if (minloc (c, dim = 1, mask = l2).ne.3) call abort\n+  if (minval (c, dim = 1, mask = l2).ne.huge(h)-1) call abort\n+  deallocate (c)\n+  allocate (c(-2:-3))\n+  if (minloc (c, dim = 1).ne.0) call abort\n+  if (minval (c, dim = 1).ne.huge(h)) call abort\n+end"}, {"sha": "6a4fc558a3547981405d181f00589a4c8720a375", "filename": "gcc/testsuite/gfortran.dg/minlocval_3.f90", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_3.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,284 @@\n+  real :: a(30), b(10, 10), m\n+  real, allocatable :: c(:), d(:, :)\n+  integer :: e(30), f(10, 10), n\n+  integer, allocatable :: g(:), h(:,:)\n+  logical :: l(30), l2(10, 10)\n+  allocate (c (30))\n+  allocate (d (10, 10))\n+  allocate (g (30))\n+  allocate (h (10, 10))\n+  a = 7.0\n+  b = 7.0\n+  c = 7.0\n+  d = 7.0\n+  e = 7\n+  f = 7\n+  g = 7\n+  h = 7\n+  m = huge(m)\n+  n = huge(n)\n+  a(7) = 6.0\n+  b(5, 5) = 6.0\n+  b(5, 6) = 5.0\n+  b(6, 7) = 4.0\n+  c(7) = 6.0\n+  d(5, 5) = 6.0\n+  d(5, 6) = 5.0\n+  d(6, 7) = 4.0\n+  e(7) = 6\n+  f(5, 5) = 6\n+  f(5, 6) = 5\n+  f(6, 7) = 4\n+  g(7) = 6\n+  h(5, 5) = 6\n+  h(5, 6) = 5\n+  h(6, 7) = 4\n+  if (minloc (a, dim = 1).ne.7) call abort\n+  if (minval (a, dim = 1).ne.6.0) call abort\n+  if (minloc (a(::2), dim = 1).ne.4) call abort\n+  if (minval (a(::2), dim = 1).ne.6.0) call abort\n+  if (any (minloc (a).ne.(/ 7 /))) call abort\n+  if (minval (a).ne.6.0) call abort\n+  if (any (minloc (a(::2)).ne.(/ 4 /))) call abort\n+  if (minval (a(::2)).ne.6.0) call abort\n+  if (any (minloc (b, dim = 1).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (b, dim = 1).ne.(/ 7.0, 7.0, 7.0, 7.0, 6.0, 5.0, 4.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 1).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 1).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b, dim = 2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (b, dim = 2).ne.(/ 7.0, 7.0, 7.0, 7.0, 5.0, 4.0, 7.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 2).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 2).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b).ne.(/ 6, 7 /))) call abort\n+  if (minval (b).ne.4.0) call abort\n+  if (any (minloc (b(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (b(::2,::2)).ne.6.0) call abort\n+  if (minloc (c, dim = 1).ne.7) call abort\n+  if (minval (c, dim = 1).ne.6.0) call abort\n+  if (minloc (c(::2), dim = 1).ne.4) call abort\n+  if (minval (c(::2), dim = 1).ne.6.0) call abort\n+  if (any (minloc (c).ne.(/ 7 /))) call abort\n+  if (minval (c).ne.6.0) call abort\n+  if (any (minloc (c(::2)).ne.(/ 4 /))) call abort\n+  if (minval (c(::2)).ne.6.0) call abort\n+  if (any (minloc (d, dim = 1).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (d, dim = 1).ne.(/ 7.0, 7.0, 7.0, 7.0, 6.0, 5.0, 4.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 1).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 1).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d, dim = 2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (d, dim = 2).ne.(/ 7.0, 7.0, 7.0, 7.0, 5.0, 4.0, 7.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 2).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 2).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d).ne.(/ 6, 7 /))) call abort\n+  if (minval (d).ne.4.0) call abort\n+  if (any (minloc (d(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (d(::2,::2)).ne.6.0) call abort\n+  if (minloc (e, dim = 1).ne.7) call abort\n+  if (minval (e, dim = 1).ne.6) call abort\n+  if (minloc (e(::2), dim = 1).ne.4) call abort\n+  if (minval (e(::2), dim = 1).ne.6) call abort\n+  if (any (minloc (e).ne.(/ 7 /))) call abort\n+  if (minval (e).ne.6) call abort\n+  if (any (minloc (e(::2)).ne.(/ 4 /))) call abort\n+  if (minval (e(::2)).ne.6) call abort\n+  if (any (minloc (f, dim = 1).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (f, dim = 1).ne.(/ 7, 7, 7, 7, 6, 5, 4, 7, 7, 7 /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 1).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 1).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (f, dim = 2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (f, dim = 2).ne.(/ 7, 7, 7, 7, 5, 4, 7, 7, 7, 7 /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 2).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 2).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (f).ne.(/ 6, 7 /))) call abort\n+  if (minval (f).ne.4) call abort\n+  if (any (minloc (f(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (f(::2,::2)).ne.6) call abort\n+  if (minloc (g, dim = 1).ne.7) call abort\n+  if (minval (g, dim = 1).ne.6) call abort\n+  if (minloc (g(::2), dim = 1).ne.4) call abort\n+  if (minval (g(::2), dim = 1).ne.6) call abort\n+  if (any (minloc (g).ne.(/ 7 /))) call abort\n+  if (minval (g).ne.6) call abort\n+  if (any (minloc (g(::2)).ne.(/ 4 /))) call abort\n+  if (minval (g(::2)).ne.6) call abort\n+  if (any (minloc (h, dim = 1).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (h, dim = 1).ne.(/ 7, 7, 7, 7, 6, 5, 4, 7, 7, 7 /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 1).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 1).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (h, dim = 2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (h, dim = 2).ne.(/ 7, 7, 7, 7, 5, 4, 7, 7, 7, 7 /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 2).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 2).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (h).ne.(/ 6, 7 /))) call abort\n+  if (minval (h).ne.4) call abort\n+  if (any (minloc (h(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (h(::2,::2)).ne.6) call abort\n+  l = .true.\n+  l2 = .true.\n+  if (minloc (a, dim = 1, mask = l).ne.7) call abort\n+  if (minval (a, dim = 1, mask = l).ne.6.0) call abort\n+  if (minloc (a(::2), dim = 1, mask = l(::2)).ne.4) call abort\n+  if (minval (a(::2), dim = 1, mask = l(::2)).ne.6.0) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 7 /))) call abort\n+  if (minval (a, mask = l).ne.6.0) call abort\n+  if (any (minloc (a(::2), mask = l(::2)).ne.(/ 4 /))) call abort\n+  if (minval (a(::2), mask = l(::2)).ne.6.0) call abort\n+  if (any (minloc (b, dim = 1, mask = l2).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (b, dim = 1, mask = l2).ne.(/ 7.0, 7.0, 7.0, 7.0, 6.0, 5.0, 4.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b, dim = 2, mask = l2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (b, dim = 2, mask = l2).ne.(/ 7.0, 7.0, 7.0, 7.0, 5.0, 4.0, 7.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (b, mask = l2).ne.(/ 6, 7 /))) call abort\n+  if (minval (b, mask = l2).ne.4.0) call abort\n+  if (any (minloc (b(::2,::2), mask = l2(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (b(::2,::2), mask = l2(::2,::2)).ne.6.0) call abort\n+  if (minloc (c, dim = 1, mask = l).ne.7) call abort\n+  if (minval (c, dim = 1, mask = l).ne.6.0) call abort\n+  if (minloc (c(::2), dim = 1, mask = l(::2)).ne.4) call abort\n+  if (minval (c(::2), dim = 1, mask = l(::2)).ne.6.0) call abort\n+  if (any (minloc (c, mask = l).ne.(/ 7 /))) call abort\n+  if (minval (c, mask = l).ne.6.0) call abort\n+  if (any (minloc (c(::2), mask = l(::2)).ne.(/ 4 /))) call abort\n+  if (minval (c(::2), mask = l(::2)).ne.6.0) call abort\n+  if (any (minloc (d, dim = 1, mask = l2).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (d, dim = 1, mask = l2).ne.(/ 7.0, 7.0, 7.0, 7.0, 6.0, 5.0, 4.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d, dim = 2, mask = l2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (d, dim = 2, mask = l2).ne.(/ 7.0, 7.0, 7.0, 7.0, 5.0, 4.0, 7.0, 7.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 7.0, 7.0, 6.0, 7.0, 7.0 /))) call abort\n+  if (any (minloc (d, mask = l2).ne.(/ 6, 7 /))) call abort\n+  if (minval (d, mask = l2).ne.4.0) call abort\n+  if (any (minloc (d(::2,::2), mask = l2(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (d(::2,::2), mask = l2(::2,::2)).ne.6.0) call abort\n+  if (minloc (e, dim = 1, mask = l).ne.7) call abort\n+  if (minval (e, dim = 1, mask = l).ne.6) call abort\n+  if (minloc (e(::2), dim = 1, mask = l(::2)).ne.4) call abort\n+  if (minval (e(::2), dim = 1, mask = l(::2)).ne.6) call abort\n+  if (any (minloc (e, mask = l).ne.(/ 7 /))) call abort\n+  if (minval (e, mask = l).ne.6) call abort\n+  if (any (minloc (e(::2), mask = l(::2)).ne.(/ 4 /))) call abort\n+  if (minval (e(::2), mask = l(::2)).ne.6) call abort\n+  if (any (minloc (f, dim = 1, mask = l2).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (f, dim = 1, mask = l2).ne.(/ 7, 7, 7, 7, 6, 5, 4, 7, 7, 7 /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (f, dim = 2, mask = l2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (f, dim = 2, mask = l2).ne.(/ 7, 7, 7, 7, 5, 4, 7, 7, 7, 7 /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (f, mask = l2).ne.(/ 6, 7 /))) call abort\n+  if (minval (f, mask = l2).ne.4) call abort\n+  if (any (minloc (f(::2,::2), mask = l2(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (f(::2,::2), mask = l2(::2,::2)).ne.6) call abort\n+  if (minloc (g, dim = 1, mask = l).ne.7) call abort\n+  if (minval (g, dim = 1, mask = l).ne.6) call abort\n+  if (minloc (g(::2), dim = 1, mask = l(::2)).ne.4) call abort\n+  if (minval (g(::2), dim = 1, mask = l(::2)).ne.6) call abort\n+  if (any (minloc (g, mask = l).ne.(/ 7 /))) call abort\n+  if (minval (g, mask = l).ne.6) call abort\n+  if (any (minloc (g(::2), mask = l(::2)).ne.(/ 4 /))) call abort\n+  if (minval (g(::2), mask = l(::2)).ne.6) call abort\n+  if (any (minloc (h, dim = 1, mask = l2).ne.(/ 1, 1, 1, 1, 5, 5, 6, 1, 1, 1 /))) call abort\n+  if (any (minval (h, dim = 1, mask = l2).ne.(/ 7, 7, 7, 7, 6, 5, 4, 7, 7, 7 /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (h, dim = 2, mask = l2).ne.(/ 1, 1, 1, 1, 6, 7, 1, 1, 1, 1 /))) call abort\n+  if (any (minval (h, dim = 2, mask = l2).ne.(/ 7, 7, 7, 7, 5, 4, 7, 7, 7, 7 /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 1, 1, 3, 1, 1 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 7, 7, 6, 7, 7 /))) call abort\n+  if (any (minloc (h, mask = l2).ne.(/ 6, 7 /))) call abort\n+  if (minval (h, mask = l2).ne.4) call abort\n+  if (any (minloc (h(::2,::2), mask = l2(::2,::2)).ne.(/ 3, 3 /))) call abort\n+  if (minval (h(::2,::2), mask = l2(::2,::2)).ne.6) call abort\n+  l = .false.\n+  l2 = .false.\n+  if (minloc (a, dim = 1, mask = l).ne.0) call abort\n+  if (minval (a, dim = 1, mask = l).ne.m) call abort\n+  if (minloc (a(::2), dim = 1, mask = l(::2)).ne.0) call abort\n+  if (minval (a(::2), dim = 1, mask = l(::2)).ne.m) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 0 /))) call abort\n+  if (minval (a, mask = l).ne.m) call abort\n+  if (any (minloc (a(::2), mask = l(::2)).ne.(/ 0 /))) call abort\n+  if (minval (a(::2), mask = l(::2)).ne.m) call abort\n+  if (any (minloc (b, dim = 1, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (b, dim = 1, mask = l2).ne.(/ m, m, m, m, m, m, m, m, m, m /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ m, m, m, m, m /))) call abort\n+  if (any (minloc (b, dim = 2, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (b, dim = 2, mask = l2).ne.(/ m, m, m, m, m, m, m, m, m, m /))) call abort\n+  if (any (minloc (b(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (b(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ m, m, m, m, m /))) call abort\n+  if (any (minloc (b, mask = l2).ne.(/ 0, 0 /))) call abort\n+  if (minval (b, mask = l2).ne.m) call abort\n+  if (any (minloc (b(::2,::2), mask = l2(::2,::2)).ne.(/ 0, 0 /))) call abort\n+  if (minval (b(::2,::2), mask = l2(::2,::2)).ne.m) call abort\n+  if (minloc (c, dim = 1, mask = l).ne.0) call abort\n+  if (minval (c, dim = 1, mask = l).ne.m) call abort\n+  if (minloc (c(::2), dim = 1, mask = l(::2)).ne.0) call abort\n+  if (minval (c(::2), dim = 1, mask = l(::2)).ne.m) call abort\n+  if (any (minloc (c, mask = l).ne.(/ 0 /))) call abort\n+  if (minval (c, mask = l).ne.m) call abort\n+  if (any (minloc (c(::2), mask = l(::2)).ne.(/ 0 /))) call abort\n+  if (minval (c(::2), mask = l(::2)).ne.m) call abort\n+  if (any (minloc (d, dim = 1, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (d, dim = 1, mask = l2).ne.(/ m, m, m, m, m, m, m, m, m, m /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ m, m, m, m, m /))) call abort\n+  if (any (minloc (d, dim = 2, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (d, dim = 2, mask = l2).ne.(/ m, m, m, m, m, m, m, m, m, m /))) call abort\n+  if (any (minloc (d(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (d(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ m, m, m, m, m /))) call abort\n+  if (any (minloc (d, mask = l2).ne.(/ 0, 0 /))) call abort\n+  if (minval (d, mask = l2).ne.m) call abort\n+  if (any (minloc (d(::2,::2), mask = l2(::2,::2)).ne.(/ 0, 0 /))) call abort\n+  if (minval (d(::2,::2), mask = l2(::2,::2)).ne.m) call abort\n+  if (minloc (e, dim = 1, mask = l).ne.0) call abort\n+  if (minval (e, dim = 1, mask = l).ne.n) call abort\n+  if (minloc (e(::2), dim = 1, mask = l(::2)).ne.0) call abort\n+  if (minval (e(::2), dim = 1, mask = l(::2)).ne.n) call abort\n+  if (any (minloc (e, mask = l).ne.(/ 0 /))) call abort\n+  if (minval (e, mask = l).ne.n) call abort\n+  if (any (minloc (e(::2), mask = l(::2)).ne.(/ 0 /))) call abort\n+  if (minval (e(::2), mask = l(::2)).ne.n) call abort\n+  if (any (minloc (f, dim = 1, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (f, dim = 1, mask = l2).ne.(/ n, n, n, n, n, n, n, n, n, n /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ n, n, n, n, n /))) call abort\n+  if (any (minloc (f, dim = 2, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (f, dim = 2, mask = l2).ne.(/ n, n, n, n, n, n, n, n, n, n /))) call abort\n+  if (any (minloc (f(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (f(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ n, n, n, n, n /))) call abort\n+  if (any (minloc (f, mask = l2).ne.(/ 0, 0 /))) call abort\n+  if (minval (f, mask = l2).ne.n) call abort\n+  if (any (minloc (f(::2,::2), mask = l2(::2,::2)).ne.(/ 0, 0 /))) call abort\n+  if (minval (f(::2,::2), mask = l2(::2,::2)).ne.n) call abort\n+  if (minloc (g, dim = 1, mask = l).ne.0) call abort\n+  if (minval (g, dim = 1, mask = l).ne.n) call abort\n+  if (minloc (g(::2), dim = 1, mask = l(::2)).ne.0) call abort\n+  if (minval (g(::2), dim = 1, mask = l(::2)).ne.n) call abort\n+  if (any (minloc (g, mask = l).ne.(/ 0 /))) call abort\n+  if (minval (g, mask = l).ne.n) call abort\n+  if (any (minloc (g(::2), mask = l(::2)).ne.(/ 0 /))) call abort\n+  if (minval (g(::2), mask = l(::2)).ne.n) call abort\n+  if (any (minloc (h, dim = 1, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (h, dim = 1, mask = l2).ne.(/ n, n, n, n, n, n, n, n, n, n /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 1, mask = l2(::2,::2)).ne.(/ n, n, n, n, n /))) call abort\n+  if (any (minloc (h, dim = 2, mask = l2).ne.(/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (h, dim = 2, mask = l2).ne.(/ n, n, n, n, n, n, n, n, n, n /))) call abort\n+  if (any (minloc (h(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ 0, 0, 0, 0, 0 /))) call abort\n+  if (any (minval (h(::2,::2), dim = 2, mask = l2(::2,::2)).ne.(/ n, n, n, n, n /))) call abort\n+  if (any (minloc (h, mask = l2).ne.(/ 0, 0 /))) call abort\n+  if (minval (h, mask = l2).ne.n) call abort\n+  if (any (minloc (h(::2,::2), mask = l2(::2,::2)).ne.(/ 0, 0 /))) call abort\n+  if (minval (h(::2,::2), mask = l2(::2,::2)).ne.n) call abort\n+  a = 7.0\n+  b = 7.0\n+  c = 7.0\n+  d = 7.0\n+end"}, {"sha": "1e72ba8e2a93301175e97a843d23b1506b8888cd", "filename": "gcc/testsuite/gfortran.dg/minlocval_4.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminlocval_4.f90?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+  real :: a(3,3), b(3), nan, minf, pinf, h\n+  logical :: l, l2\n+  logical :: l3(3,3), l4(3,3), l5(3,3)\n+\n+  nan = 0.0\n+  minf = 0.0\n+  pinf = 0.0\n+  nan = 0.0/nan\n+  minf = -1.0/minf\n+  pinf = 1.0/pinf\n+  h = huge(h)\n+  l = .false.\n+  l2 = .true.\n+  l3 = .false.\n+  l4 = .true.\n+  l5 = .true.\n+  l5(1,1) = .false.\n+  l5(1,2) = .false.\n+  l5(2,3) = .false.\n+  a = reshape ((/ nan, nan, nan, pinf, pinf, pinf, pinf, minf, pinf /), (/ 3, 3 /))\n+  if (minval (a).ne.minf) call abort\n+  if (any (minloc (a).ne.(/ 2, 3 /))) call abort\n+  b = minval (a, dim = 1)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, pinf, minf /))) call abort\n+  if (any (minloc (a, dim = 1).ne.(/ 1, 1, 2 /))) call abort\n+  b = minval (a, dim = 2)\n+  if (any (b.ne.(/ pinf, minf, pinf /))) call abort\n+  if (any (minloc (a, dim = 2).ne.(/ 2, 3, 2 /))) call abort\n+  if (minval (a, mask = l).ne.h) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  b = minval (a, dim = 1, mask = l)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (minloc (a, dim = 1, mask = l).ne.(/ 0, 0, 0 /))) call abort\n+  b = minval (a, dim = 2, mask = l)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (minloc (a, dim = 2, mask = l).ne.(/ 0, 0, 0 /))) call abort\n+  if (minval (a, mask = l3).ne.h) call abort\n+  if (any (minloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  b = minval (a, dim = 1, mask = l3)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (minloc (a, dim = 1, mask = l3).ne.(/ 0, 0, 0 /))) call abort\n+  b = minval (a, dim = 2, mask = l3)\n+  if (any (b.ne.(/ h, h, h /))) call abort\n+  if (any (minloc (a, dim = 2, mask = l3).ne.(/ 0, 0, 0 /))) call abort\n+  if (minval (a, mask = l2).ne.minf) call abort\n+  if (minval (a, mask = l4).ne.minf) call abort\n+  if (any (minloc (a, mask = l2).ne.(/ 2, 3 /))) call abort\n+  if (any (minloc (a, mask = l4).ne.(/ 2, 3 /))) call abort\n+  b = minval (a, dim = 1, mask = l2)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, pinf, minf /))) call abort\n+  if (any (minloc (a, dim = 1, mask = l2).ne.(/ 1, 1, 2 /))) call abort\n+  b = minval (a, dim = 2, mask = l2)\n+  if (any (b.ne.(/ pinf, minf, pinf /))) call abort\n+  if (any (minloc (a, dim = 2, mask = l2).ne.(/ 2, 3, 2 /))) call abort\n+  b = minval (a, dim = 1, mask = l4)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, pinf, minf /))) call abort\n+  if (any (minloc (a, dim = 1, mask = l2).ne.(/ 1, 1, 2 /))) call abort\n+  b = minval (a, dim = 2, mask = l4)\n+  if (any (b.ne.(/ pinf, minf, pinf /))) call abort\n+  if (any (minloc (a, dim = 2, mask = l2).ne.(/ 2, 3, 2 /))) call abort\n+  if (minval (a, mask = l5).ne.pinf) call abort\n+  if (any (minloc (a, mask = l5).ne.(/ 2, 2 /))) call abort\n+  b = minval (a, dim = 1, mask = l5)\n+  if (.not.isnan(b(1))) call abort\n+  b(1) = 0.0\n+  if (any (b.ne.(/ 0.0, pinf, pinf /))) call abort\n+  if (any (minloc (a, dim = 1, mask = l5).ne.(/ 2, 2, 1 /))) call abort\n+  b = minval (a, dim = 2, mask = l5)\n+  if (any (b.ne.(/ pinf, pinf, pinf /))) call abort\n+  if (any (minloc (a, dim = 2, mask = l5).ne.(/ 3, 2, 2 /))) call abort\n+  a = nan\n+  if (.not.isnan(minval (a))) call abort\n+  if (minval (a, mask = l).ne.h) call abort\n+  if (.not.isnan(minval (a, mask = l2))) call abort\n+  if (minval (a, mask = l3).ne.h) call abort\n+  if (.not.isnan(minval (a, mask = l4))) call abort\n+  if (.not.isnan(minval (a, mask = l5))) call abort\n+  if (any (minloc (a).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l2).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l4).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l5).ne.(/ 2, 1 /))) call abort\n+  a = pinf\n+  if (minval (a).ne.pinf) call abort\n+  if (minval (a, mask = l).ne.h) call abort\n+  if (minval (a, mask = l2).ne.pinf) call abort\n+  if (minval (a, mask = l3).ne.h) call abort\n+  if (minval (a, mask = l4).ne.pinf) call abort\n+  if (minval (a, mask = l5).ne.pinf) call abort\n+  if (any (minloc (a).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l2).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l4).ne.(/ 1, 1 /))) call abort\n+  if (any (minloc (a, mask = l5).ne.(/ 2, 1 /))) call abort\n+  a = nan\n+  a(1,3) = pinf\n+  if (minval (a).ne.pinf) call abort\n+  if (minval (a, mask = l).ne.h) call abort\n+  if (minval (a, mask = l2).ne.pinf) call abort\n+  if (minval (a, mask = l3).ne.h) call abort\n+  if (minval (a, mask = l4).ne.pinf) call abort\n+  if (minval (a, mask = l5).ne.pinf) call abort\n+  if (any (minloc (a).ne.(/ 1, 3 /))) call abort\n+  if (any (minloc (a, mask = l).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l2).ne.(/ 1, 3 /))) call abort\n+  if (any (minloc (a, mask = l3).ne.(/ 0, 0 /))) call abort\n+  if (any (minloc (a, mask = l4).ne.(/ 1, 3 /))) call abort\n+  if (any (minloc (a, mask = l5).ne.(/ 1, 3 /))) call abort\n+end"}, {"sha": "12db11758d5471a749806f56a5bede3fb540240a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -1,3 +1,177 @@\n+2009-07-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/40643\n+\tPR fortran/31067\n+\t* libgfortran.h (GFC_REAL_4_INFINITY, GFC_REAL_8_INFINITY,\n+\tGFC_REAL_10_INFINITY, GFC_REAL_16_INFINITY, GFC_REAL_4_QUIET_NAN,\n+\tGFC_REAL_8_QUIET_NAN, GFC_REAL_10_QUIET_NAN, GFC_REAL_16_QUIET_NAN):\n+\tDefine.\n+\t* m4/iparm.m4 (atype_inf, atype_nan): Define.\n+\t* m4/ifunction.m4: Formatting.\n+\t* m4/iforeach.m4: Likewise.\n+\t(START_FOREACH_FUNCTION): Initialize dest to all 1s, not all 0s.\n+\t(START_FOREACH_BLOCK, FINISH_FOREACH_FUNCTION,\n+\tFINISH_MASKED_FOREACH_FUNCTION): Run foreach block inside a loop\n+\tuntil count[0] == extent[0].\n+\t* m4/minval.m4: Formatting.  Handle NaNs and infinities.  Optimize.\n+\t* m4/maxval.m4: Likewise.\n+\t* m4/minloc0.m4: Likewise.\n+\t* m4/maxloc0.m4: Likewise.\n+\t* m4/minloc1.m4: Likewise.\n+\t* m4/maxloc1.m4: Likewise.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Likewise.\n+\t* generated/maxloc0_16_i2.c: Likewise.\n+\t* generated/maxloc0_16_i4.c: Likewise.\n+\t* generated/maxloc0_16_i8.c: Likewise.\n+\t* generated/maxloc0_16_r10.c: Likewise.\n+\t* generated/maxloc0_16_r16.c: Likewise.\n+\t* generated/maxloc0_16_r4.c: Likewise.\n+\t* generated/maxloc0_16_r8.c: Likewise.\n+\t* generated/maxloc0_4_i16.c: Likewise.\n+\t* generated/maxloc0_4_i1.c: Likewise.\n+\t* generated/maxloc0_4_i2.c: Likewise.\n+\t* generated/maxloc0_4_i4.c: Likewise.\n+\t* generated/maxloc0_4_i8.c: Likewise.\n+\t* generated/maxloc0_4_r10.c: Likewise.\n+\t* generated/maxloc0_4_r16.c: Likewise.\n+\t* generated/maxloc0_4_r4.c: Likewise.\n+\t* generated/maxloc0_4_r8.c: Likewise.\n+\t* generated/maxloc0_8_i16.c: Likewise.\n+\t* generated/maxloc0_8_i1.c: Likewise.\n+\t* generated/maxloc0_8_i2.c: Likewise.\n+\t* generated/maxloc0_8_i4.c: Likewise.\n+\t* generated/maxloc0_8_i8.c: Likewise.\n+\t* generated/maxloc0_8_r10.c: Likewise.\n+\t* generated/maxloc0_8_r16.c: Likewise.\n+\t* generated/maxloc0_8_r4.c: Likewise.\n+\t* generated/maxloc0_8_r8.c: Likewise.\n+\t* generated/maxloc1_16_i16.c: Likewise.\n+\t* generated/maxloc1_16_i1.c: Likewise.\n+\t* generated/maxloc1_16_i2.c: Likewise.\n+\t* generated/maxloc1_16_i4.c: Likewise.\n+\t* generated/maxloc1_16_i8.c: Likewise.\n+\t* generated/maxloc1_16_r10.c: Likewise.\n+\t* generated/maxloc1_16_r16.c: Likewise.\n+\t* generated/maxloc1_16_r4.c: Likewise.\n+\t* generated/maxloc1_16_r8.c: Likewise.\n+\t* generated/maxloc1_4_i16.c: Likewise.\n+\t* generated/maxloc1_4_i1.c: Likewise.\n+\t* generated/maxloc1_4_i2.c: Likewise.\n+\t* generated/maxloc1_4_i4.c: Likewise.\n+\t* generated/maxloc1_4_i8.c: Likewise.\n+\t* generated/maxloc1_4_r10.c: Likewise.\n+\t* generated/maxloc1_4_r16.c: Likewise.\n+\t* generated/maxloc1_4_r4.c: Likewise.\n+\t* generated/maxloc1_4_r8.c: Likewise.\n+\t* generated/maxloc1_8_i16.c: Likewise.\n+\t* generated/maxloc1_8_i1.c: Likewise.\n+\t* generated/maxloc1_8_i2.c: Likewise.\n+\t* generated/maxloc1_8_i4.c: Likewise.\n+\t* generated/maxloc1_8_i8.c: Likewise.\n+\t* generated/maxloc1_8_r10.c: Likewise.\n+\t* generated/maxloc1_8_r16.c: Likewise.\n+\t* generated/maxloc1_8_r4.c: Likewise.\n+\t* generated/maxloc1_8_r8.c: Likewise.\n+\t* generated/maxval_i16.c: Likewise.\n+\t* generated/maxval_i1.c: Likewise.\n+\t* generated/maxval_i2.c: Likewise.\n+\t* generated/maxval_i4.c: Likewise.\n+\t* generated/maxval_i8.c: Likewise.\n+\t* generated/maxval_r10.c: Likewise.\n+\t* generated/maxval_r16.c: Likewise.\n+\t* generated/maxval_r4.c: Likewise.\n+\t* generated/maxval_r8.c: Likewise.\n+\t* generated/minloc0_16_i16.c: Likewise.\n+\t* generated/minloc0_16_i1.c: Likewise.\n+\t* generated/minloc0_16_i2.c: Likewise.\n+\t* generated/minloc0_16_i4.c: Likewise.\n+\t* generated/minloc0_16_i8.c: Likewise.\n+\t* generated/minloc0_16_r10.c: Likewise.\n+\t* generated/minloc0_16_r16.c: Likewise.\n+\t* generated/minloc0_16_r4.c: Likewise.\n+\t* generated/minloc0_16_r8.c: Likewise.\n+\t* generated/minloc0_4_i16.c: Likewise.\n+\t* generated/minloc0_4_i1.c: Likewise.\n+\t* generated/minloc0_4_i2.c: Likewise.\n+\t* generated/minloc0_4_i4.c: Likewise.\n+\t* generated/minloc0_4_i8.c: Likewise.\n+\t* generated/minloc0_4_r10.c: Likewise.\n+\t* generated/minloc0_4_r16.c: Likewise.\n+\t* generated/minloc0_4_r4.c: Likewise.\n+\t* generated/minloc0_4_r8.c: Likewise.\n+\t* generated/minloc0_8_i16.c: Likewise.\n+\t* generated/minloc0_8_i1.c: Likewise.\n+\t* generated/minloc0_8_i2.c: Likewise.\n+\t* generated/minloc0_8_i4.c: Likewise.\n+\t* generated/minloc0_8_i8.c: Likewise.\n+\t* generated/minloc0_8_r10.c: Likewise.\n+\t* generated/minloc0_8_r16.c: Likewise.\n+\t* generated/minloc0_8_r4.c: Likewise.\n+\t* generated/minloc0_8_r8.c: Likewise.\n+\t* generated/minloc1_16_i16.c: Likewise.\n+\t* generated/minloc1_16_i1.c: Likewise.\n+\t* generated/minloc1_16_i2.c: Likewise.\n+\t* generated/minloc1_16_i4.c: Likewise.\n+\t* generated/minloc1_16_i8.c: Likewise.\n+\t* generated/minloc1_16_r10.c: Likewise.\n+\t* generated/minloc1_16_r16.c: Likewise.\n+\t* generated/minloc1_16_r4.c: Likewise.\n+\t* generated/minloc1_16_r8.c: Likewise.\n+\t* generated/minloc1_4_i16.c: Likewise.\n+\t* generated/minloc1_4_i1.c: Likewise.\n+\t* generated/minloc1_4_i2.c: Likewise.\n+\t* generated/minloc1_4_i4.c: Likewise.\n+\t* generated/minloc1_4_i8.c: Likewise.\n+\t* generated/minloc1_4_r10.c: Likewise.\n+\t* generated/minloc1_4_r16.c: Likewise.\n+\t* generated/minloc1_4_r4.c: Likewise.\n+\t* generated/minloc1_4_r8.c: Likewise.\n+\t* generated/minloc1_8_i16.c: Likewise.\n+\t* generated/minloc1_8_i1.c: Likewise.\n+\t* generated/minloc1_8_i2.c: Likewise.\n+\t* generated/minloc1_8_i4.c: Likewise.\n+\t* generated/minloc1_8_i8.c: Likewise.\n+\t* generated/minloc1_8_r10.c: Likewise.\n+\t* generated/minloc1_8_r16.c: Likewise.\n+\t* generated/minloc1_8_r4.c: Likewise.\n+\t* generated/minloc1_8_r8.c: Likewise.\n+\t* generated/minval_i16.c: Likewise.\n+\t* generated/minval_i1.c: Likewise.\n+\t* generated/minval_i2.c: Likewise.\n+\t* generated/minval_i4.c: Likewise.\n+\t* generated/minval_i8.c: Likewise.\n+\t* generated/minval_r10.c: Likewise.\n+\t* generated/minval_r16.c: Likewise.\n+\t* generated/minval_r4.c: Likewise.\n+\t* generated/minval_r8.c: Likewise.\n+\t* generated/product_c10.c: Likewise.\n+\t* generated/product_c16.c: Likewise.\n+\t* generated/product_c4.c: Likewise.\n+\t* generated/product_c8.c: Likewise.\n+\t* generated/product_i16.c: Likewise.\n+\t* generated/product_i1.c: Likewise.\n+\t* generated/product_i2.c: Likewise.\n+\t* generated/product_i4.c: Likewise.\n+\t* generated/product_i8.c: Likewise.\n+\t* generated/product_r10.c: Likewise.\n+\t* generated/product_r16.c: Likewise.\n+\t* generated/product_r4.c: Likewise.\n+\t* generated/product_r8.c: Likewise.\n+\t* generated/sum_c10.c: Likewise.\n+\t* generated/sum_c16.c: Likewise.\n+\t* generated/sum_c4.c: Likewise.\n+\t* generated/sum_c8.c: Likewise.\n+\t* generated/sum_i16.c: Likewise.\n+\t* generated/sum_i1.c: Likewise.\n+\t* generated/sum_i2.c: Likewise.\n+\t* generated/sum_i4.c: Likewise.\n+\t* generated/sum_i8.c: Likewise.\n+\t* generated/sum_r10.c: Likewise.\n+\t* generated/sum_r16.c: Likewise.\n+\t* generated/sum_r4.c: Likewise.\n+\t* generated/sum_r8.c: Likewise.\n+\n 2009-07-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/32784"}, {"sha": "5649018db894ee82b32d34bc0e9d2f402320c89e", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_1 maxval;\n-\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n+    GFC_INTEGER_1 maxval;\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_INTEGER_1 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-\n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "1ff74f6e2227fc7e1a6f3a712360384fa6f4c8a5", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_16 maxval;\n-\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n+    GFC_INTEGER_16 maxval;\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_INTEGER_16 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-\n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "8ca75b9f99cacc6aa5873f4b9cb463f77b5e90b3", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_2 maxval;\n-\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n+    GFC_INTEGER_2 maxval;\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_INTEGER_2 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-\n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "18feabbcde422e15739b2b7ae14f419aa2b7067e", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_4 maxval;\n-\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n+    GFC_INTEGER_4 maxval;\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_INTEGER_4 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-\n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "bc5a3b3ebb7e24299d26ff37ed686afb0e7f7834", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_8 maxval;\n-\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n+    GFC_INTEGER_8 maxval;\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_INTEGER_8 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-\n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "ee0052f9328dcfd8e9e1969e2cf049b4aa635b3c", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_10 maxval;\n-\n-  maxval = -GFC_REAL_10_HUGE;\n+    GFC_REAL_10 maxval;\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_REAL_10 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_10_HUGE;\n-\n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "3c28d196855d5b571d1e7460bfd7662b3ea91b4b", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_16 maxval;\n-\n-  maxval = -GFC_REAL_16_HUGE;\n+    GFC_REAL_16 maxval;\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_REAL_16 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_16_HUGE;\n-\n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "616ec7acd97fdfe02624def948dbb76802643426", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_4 maxval;\n-\n-  maxval = -GFC_REAL_4_HUGE;\n+    GFC_REAL_4 maxval;\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_REAL_4 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_4_HUGE;\n-\n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "8bb5f0d8f8a6f06da27b128e0dcd729a462f6857", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_8 maxval;\n-\n-  maxval = -GFC_REAL_8_HUGE;\n+    GFC_REAL_8 maxval;\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   {\n \n   GFC_REAL_8 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_8_HUGE;\n-\n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "5fb626b59e71dd3e55c5ae7e80f4aa6675fd0ced", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_1 maxval;\n-\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n+    GFC_INTEGER_1 maxval;\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_INTEGER_1 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-\n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "e4d252d4ec3459f752a734ca3de38ca9e84b48f1", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_16 maxval;\n-\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n+    GFC_INTEGER_16 maxval;\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_INTEGER_16 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-\n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "a3866e4867f9312ae0ba90a5f0adace93bcb6a9a", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_2 maxval;\n-\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n+    GFC_INTEGER_2 maxval;\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_INTEGER_2 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-\n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "0a4a5bda97f971426f31b3500a7eeb0a821390b8", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_4 maxval;\n-\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n+    GFC_INTEGER_4 maxval;\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_INTEGER_4 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-\n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "435123bdc6108bad80c00fec6c163fe4529e404d", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_8 maxval;\n-\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n+    GFC_INTEGER_8 maxval;\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_INTEGER_8 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-\n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "4b99bbecf22a9647deb02094a53a91301fc6e700", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_10 maxval;\n-\n-  maxval = -GFC_REAL_10_HUGE;\n+    GFC_REAL_10 maxval;\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_REAL_10 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_10_HUGE;\n-\n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "1290355cc8e5442036b518c723d07ef2f2f6ef5d", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_16 maxval;\n-\n-  maxval = -GFC_REAL_16_HUGE;\n+    GFC_REAL_16 maxval;\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_REAL_16 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_16_HUGE;\n-\n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "5483fda44a2e7569aed9f0c90b5e2b90b94a0803", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_4 maxval;\n-\n-  maxval = -GFC_REAL_4_HUGE;\n+    GFC_REAL_4 maxval;\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_REAL_4 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_4_HUGE;\n-\n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "e4631db4ef8c4d24d51d410360e3fe37d45a6e11", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_8 maxval;\n-\n-  maxval = -GFC_REAL_8_HUGE;\n+    GFC_REAL_8 maxval;\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   {\n \n   GFC_REAL_8 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_8_HUGE;\n-\n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "ddfc4df57f102de07ebbb4e443bf69ef2a6aa8d3", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_1 maxval;\n-\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n+    GFC_INTEGER_1 maxval;\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_INTEGER_1 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-\n+#if defined(GFC_INTEGER_1_INFINITY)\n+    maxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_1_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "ce324b5fdf65a5e9ee7e53f262e4a5560aa4cda1", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_16 maxval;\n-\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n+    GFC_INTEGER_16 maxval;\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_INTEGER_16 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-\n+#if defined(GFC_INTEGER_16_INFINITY)\n+    maxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "1b59bb6250897365ddc93298d0db793e8f169eb9", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_2 maxval;\n-\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n+    GFC_INTEGER_2 maxval;\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_INTEGER_2 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-\n+#if defined(GFC_INTEGER_2_INFINITY)\n+    maxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_2_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "f1071d1e9900d39adc8cebe6df3762eed2065e3b", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_4 maxval;\n-\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n+    GFC_INTEGER_4 maxval;\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_INTEGER_4 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-\n+#if defined(GFC_INTEGER_4_INFINITY)\n+    maxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "2774558ea0ede47048715789d741b76cd800b636", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_INTEGER_8 maxval;\n-\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n+    GFC_INTEGER_8 maxval;\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_INTEGER_8 maxval;\n+   int fast = 0;\n \n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-\n+#if defined(GFC_INTEGER_8_INFINITY)\n+    maxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+    maxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_INTEGER_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "0d5183c41a6b13fb3e5ed6e79f13ec41bfaef3ab", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_10 maxval;\n-\n-  maxval = -GFC_REAL_10_HUGE;\n+    GFC_REAL_10 maxval;\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_REAL_10 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_10_HUGE;\n-\n+#if defined(GFC_REAL_10_INFINITY)\n+    maxval = -GFC_REAL_10_INFINITY;\n+#else\n+    maxval = -GFC_REAL_10_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_10_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "51bc7b3ee8c9d0ec80a2d18b0d2111bf968faddd", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_16 maxval;\n-\n-  maxval = -GFC_REAL_16_HUGE;\n+    GFC_REAL_16 maxval;\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_REAL_16 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_16_HUGE;\n-\n+#if defined(GFC_REAL_16_INFINITY)\n+    maxval = -GFC_REAL_16_INFINITY;\n+#else\n+    maxval = -GFC_REAL_16_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_16_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "cebe571ccbeea214c3395a2585d732247a4d2405", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_4 maxval;\n-\n-  maxval = -GFC_REAL_4_HUGE;\n+    GFC_REAL_4 maxval;\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_REAL_4 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_4_HUGE;\n-\n+#if defined(GFC_REAL_4_INFINITY)\n+    maxval = -GFC_REAL_4_INFINITY;\n+#else\n+    maxval = -GFC_REAL_4_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_4_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "d33299504ec6c67aa5a87048be94dd486623cc51", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -63,8 +63,8 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n-\t                        \"MAXLOC\");\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -87,51 +87,83 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)\n-    dest[n * dstride] = 0;\n+    dest[n * dstride] = 1;\n   {\n \n-  GFC_REAL_8 maxval;\n-\n-  maxval = -GFC_REAL_8_HUGE;\n+    GFC_REAL_8 maxval;\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+    int fast = 0;\n+#endif\n \n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*base > maxval || !dest[0])\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+#endif\n+\t  if (*base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }\n@@ -219,50 +251,87 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   {\n \n   GFC_REAL_8 maxval;\n+   int fast = 0;\n \n-  maxval = -GFC_REAL_8_HUGE;\n-\n+#if defined(GFC_REAL_8_INFINITY)\n+    maxval = -GFC_REAL_8_INFINITY;\n+#else\n+    maxval = -GFC_REAL_8_HUGE;\n+#endif\n   while (base)\n     {\n-      {\n-        /* Implementation start.  */\n+      do\n+\t{\n+\t  /* Implementation start.  */\n \n-  if (*mbase && (*base > maxval || !dest[0]))\n-    {\n-      maxval = *base;\n-      for (n = 0; n < rank; n++)\n-        dest[n * dstride] = count[n] + 1;\n-    }\n-        /* Implementation end.  */\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      mbase += mstride[0];\n+\t}\n+      while (0);\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_8_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else do\n+\t{\n+\t  if (*mbase && *base > maxval)\n+\t    {\n+\t      maxval = *base;\n+\t      for (n = 0; n < rank; n++)\n+\t\tdest[n * dstride] = count[n] + 1;\n+\t    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n       n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the loop.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-            }\n-        }\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n     }\n   }\n }"}, {"sha": "5caf976fb77747026866e7e6ad90c0c15b8e14ad", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "7a0f533420ca0e9a9451d12ee87be4fe5485ff80", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "a0a9f16dbcf8569e23496662f53ca0cf6e526b7e", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "5a460ba449b414bd4f9a9307761b7a203d31dc93", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "e62ca1cada32e177a938207ebe64704146bef66c", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "072f7ef2b2cee5409846a575eec5596b1c35c51c", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "d4f13e9db4d781a528c1467e505ccf3cbc2cf416", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "4010ee412315450224c74dba0fca01950d8a3255", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "d837637248f5e3fa7f8399e83ac1b06e45d3ba25", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_16)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "c79018653d06f37577ddb59ce03477cd267397da", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "9a5a35dcf5be85f7eca88c68ff666cb9d05fdee1", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "19710651ee12851056c694ae20f57442a0b69787", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "5b068face6722566f963b1d3fb30401d8c28d1e8", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "209c3680e64bac19ab1a25753087c3ed48f87ee2", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "2f914d75b196221d4038721d276b27a795b9b022", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "c0fd3e83681cf7160c3fe1a014ec4911932cbaf4", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "90e58a0c689616d664bd7e04c9a0fb7074f17c8d", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "741fb481e58656a45770e8cf8f06eaebec8be938", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_4)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "966953727dd4a50b0de897ec1dd9f93762f4e046", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_1 maxval;\n-  maxval = (-GFC_INTEGER_1_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_1 maxval;\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tmaxval = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "fb131d53dbb55e1c1f854255e478d1819e0ac2be", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_16 maxval;\n-  maxval = (-GFC_INTEGER_16_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_16 maxval;\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tmaxval = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "c13eb68b5a0c040fbc67f7a65d0131d9da72a2e0", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_2 maxval;\n-  maxval = (-GFC_INTEGER_2_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_2 maxval;\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tmaxval = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "412133c0325333998683cbd8facc4f5012748a69", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_4 maxval;\n-  maxval = (-GFC_INTEGER_4_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_4 maxval;\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tmaxval = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "6ddb24d371d710e15452f883e26bc5b65ccb7eef", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_INTEGER_8 maxval;\n-  maxval = (-GFC_INTEGER_8_HUGE-1);\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_INTEGER_8 maxval;\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tmaxval = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tmaxval = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "3ff4ca4cc75bc4b1b72cd08a455723e606f0471a", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_10 maxval;\n-  maxval = -GFC_REAL_10_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_10 maxval;\n+#if defined (GFC_REAL_10_INFINITY)\n+\tmaxval = -GFC_REAL_10_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_10_HUGE;\n+#endif\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_10_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "d392bee6b6585e2f994843d1d732c0b4250741bb", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_16 maxval;\n-  maxval = -GFC_REAL_16_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_16 maxval;\n+#if defined (GFC_REAL_16_INFINITY)\n+\tmaxval = -GFC_REAL_16_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_16_HUGE;\n+#endif\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_16_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "159fa60503bacc0680d4bf65987c09ace78077d3", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_4 maxval;\n-  maxval = -GFC_REAL_4_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_4 maxval;\n+#if defined (GFC_REAL_4_INFINITY)\n+\tmaxval = -GFC_REAL_4_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_4_HUGE;\n+#endif\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_4_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "858865a974c1b56dbb208cf2a49a943b50236187", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -85,15 +85,15 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -129,7 +129,7 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -143,22 +143,37 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > maxval || !result)\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-          }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -168,28 +183,28 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -269,15 +284,15 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -314,7 +329,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -329,22 +344,50 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  GFC_REAL_8 maxval;\n-  maxval = -GFC_REAL_8_HUGE;\n-  result = 0;\n-        if (len <= 0)\n+\tGFC_REAL_8 maxval;\n+#if defined (GFC_REAL_8_INFINITY)\n+\tmaxval = -GFC_REAL_8_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_8_HUGE;\n+#endif\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tif (len <= 0)\n \t  *dest = 0;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && (*src > maxval || !result))\n-    {\n-      maxval = *src;\n-      result = (GFC_INTEGER_8)n + 1;\n-    }\n-              }\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_8_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -355,30 +398,30 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -426,26 +469,26 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -501,21 +544,21 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "c4f1a32ab4d8e9043a86783636a1627a97b56b84", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -84,15 +84,15 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -128,7 +128,7 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -142,17 +142,30 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n       src = base;\n       {\n \n-  result = (-GFC_INTEGER_1_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tresult = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_1_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > result)\n-    result = *src;\n-          }\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_INTEGER_1_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -162,28 +175,28 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -263,15 +276,15 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -308,7 +321,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -323,17 +336,45 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  result = (-GFC_INTEGER_1_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_1_INFINITY)\n+\tresult = -GFC_INTEGER_1_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_1_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && *src > result)\n-    result = *src;\n-              }\n+#if defined (GFC_INTEGER_1_INFINITY) || defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_INTEGER_1_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_INTEGER_1_QUIET_NAN : (-GFC_INTEGER_1_HUGE-1);\n+#else\n+\t\tresult = (-GFC_INTEGER_1_HUGE-1);\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -344,30 +385,30 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -415,26 +456,26 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -490,21 +531,21 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "493c1decc5e54fde812327241271d9beea3e795a", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -84,15 +84,15 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -128,7 +128,7 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -142,17 +142,30 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n       src = base;\n       {\n \n-  result = (-GFC_INTEGER_16_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tresult = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_16_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > result)\n-    result = *src;\n-          }\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_INTEGER_16_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -162,28 +175,28 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -263,15 +276,15 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -308,7 +321,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -323,17 +336,45 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  result = (-GFC_INTEGER_16_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_16_INFINITY)\n+\tresult = -GFC_INTEGER_16_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_16_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && *src > result)\n-    result = *src;\n-              }\n+#if defined (GFC_INTEGER_16_INFINITY) || defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_INTEGER_16_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_INTEGER_16_QUIET_NAN : (-GFC_INTEGER_16_HUGE-1);\n+#else\n+\t\tresult = (-GFC_INTEGER_16_HUGE-1);\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -344,30 +385,30 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -415,26 +456,26 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -490,21 +531,21 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "9c82cbb1333eaec8bbde536cbdc23d87803189cb", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -84,15 +84,15 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -128,7 +128,7 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -142,17 +142,30 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n       src = base;\n       {\n \n-  result = (-GFC_INTEGER_2_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tresult = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_2_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > result)\n-    result = *src;\n-          }\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_INTEGER_2_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -162,28 +175,28 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -263,15 +276,15 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -308,7 +321,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -323,17 +336,45 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  result = (-GFC_INTEGER_2_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_2_INFINITY)\n+\tresult = -GFC_INTEGER_2_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_2_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && *src > result)\n-    result = *src;\n-              }\n+#if defined (GFC_INTEGER_2_INFINITY) || defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_INTEGER_2_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_INTEGER_2_QUIET_NAN : (-GFC_INTEGER_2_HUGE-1);\n+#else\n+\t\tresult = (-GFC_INTEGER_2_HUGE-1);\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -344,30 +385,30 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -415,26 +456,26 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -490,21 +531,21 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "603d414e64b7310f063aff0f66c6c410c94b2e2a", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -84,15 +84,15 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -128,7 +128,7 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -142,17 +142,30 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n       src = base;\n       {\n \n-  result = (-GFC_INTEGER_4_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tresult = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_4_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > result)\n-    result = *src;\n-          }\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_INTEGER_4_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -162,28 +175,28 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -263,15 +276,15 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -308,7 +321,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -323,17 +336,45 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  result = (-GFC_INTEGER_4_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_4_INFINITY)\n+\tresult = -GFC_INTEGER_4_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_4_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && *src > result)\n-    result = *src;\n-              }\n+#if defined (GFC_INTEGER_4_INFINITY) || defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_INTEGER_4_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_INTEGER_4_QUIET_NAN : (-GFC_INTEGER_4_HUGE-1);\n+#else\n+\t\tresult = (-GFC_INTEGER_4_HUGE-1);\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -344,30 +385,30 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -415,26 +456,26 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -490,21 +531,21 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "a979d6647b5ca832ea99d053523a7d626f704f3f", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e", "patch": "@@ -84,15 +84,15 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n+\t{\n+\t  if (n == 0)\n \t    str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -128,7 +128,7 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        len = 0;\n+\tlen = 0;\n     }\n \n   base = array->data;\n@@ -142,17 +142,30 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n       src = base;\n       {\n \n-  result = (-GFC_INTEGER_8_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tresult = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_8_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n \n-  if (*src > result)\n-    result = *src;\n-          }\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_INTEGER_8_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -162,28 +175,28 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n \t      continue_loop = 0;\n \t      break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -263,15 +276,15 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n     \t\t   * extent[rank-1];\n@@ -308,7 +321,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       count[n] = 0;\n       dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n       if (extent[n] <= 0)\n-        return;\n+\treturn;\n     }\n \n   dest = retarray->data;\n@@ -323,17 +336,45 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       msrc = mbase;\n       {\n \n-  result = (-GFC_INTEGER_8_HUGE-1);\n-        if (len <= 0)\n+#if defined (GFC_INTEGER_8_INFINITY)\n+\tresult = -GFC_INTEGER_8_INFINITY;\n+#else\n+\tresult = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tif (len <= 0)\n \t  *dest = (-GFC_INTEGER_8_HUGE-1);\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n \t      {\n \n-  if (*msrc && *src > result)\n-    result = *src;\n-              }\n+#if defined (GFC_INTEGER_8_INFINITY) || defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_INTEGER_8_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_INTEGER_8_QUIET_NAN : (-GFC_INTEGER_8_HUGE-1);\n+#else\n+\t\tresult = (-GFC_INTEGER_8_HUGE-1);\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t      }\n \t    *dest = result;\n \t  }\n       }\n@@ -344,30 +385,30 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          mbase -= mstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              mbase += mstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n     }\n }\n \n@@ -415,26 +456,26 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n       extent[n] =\n-        GFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n \n       if (extent[n] <= 0)\n-        extent[n] = 0;\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n       size_t alloc_size, str;\n \n       for (n = 0; n < rank; n++)\n-        {\n-          if (n == 0)\n-            str = 1;\n-          else\n-            str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n \n \t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n \n-        }\n+\t}\n \n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n@@ -490,21 +531,21 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n       dest += dstride[0];\n       n = 0;\n       while (count[n] == extent[n])\n-        {\n+\t{\n \t  /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n \t    return;\n-          else\n-            {\n-              count[n]++;\n-              dest += dstride[n];\n-            }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n       \t}\n     }\n }"}, {"sha": "daf0dd8188d203a2c89738e52a01fd92362ffc0d", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "ea1c2e7ac48e91b30b77f40726a0b223d0e32e75", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "db0733030288eaab6b43fbf7dad8d3ac86879d18", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "b6d831b55c698fb2cee4897be7201a33e4fd576a", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "2fbd7609d1e14ca51f2cdae9254c11614b293085", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "613ad4813bed57ece274a68e04e8acd410ce78b6", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7591cd5bda9a6fc01d47df5a4045ebebeb24c716", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "85601fb3c4fa8737648c426384e42f45f109e720", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "88e1ee89dfdcbeaa181df0dec0876c57f16434f7", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7bfc7a71e15302b2ecf34bbffcb5c81c0f1a98c0", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "d40885435e16b2d463790837bfa5a672d8f09386", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "6b35a7a9c5684de91995141d788d943279f3fba4", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "c9ee9bf07c210c50619b503cd988c567f98e8104", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "0187a3d8afde5b694807654d8ccd7db9cccc38cf", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "ce3cd2789b480242e4daad68619957b26ffdf5ae", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "cedfbf3b5b25e466b532e52e81a5276cd3bdaa48", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "42211a993cd1b8217d414ce2c3f5cf980b492295", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "39cc14dd790f51066a800f7c543bcbe69fdee72c", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9edd1057fb1baa9a6cbf687e0e3712dd9676098f", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "0cb3ee02bf91a2fdbe89849ebf07c922cd2222c8", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "817e61e44d81cda216b7bf3ff3497cac979bbd2a", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "84c219b4fead2709f4cd688eda416d3623142f3b", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "52f4f504f3d6f5ef152950a32a8e34e63061d46d", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "980cd7e4a8f52c9e88b39854485b5043aa01ab43", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "26f79d468f920387d004b4041cd54f0394b07e01", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "87f1927346e18459cee8a8a5b073d7e1cb94dccb", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7305962030252ec63c2c9156f328944b407cf5a8", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "38ba7f09d5a79c22d5792084dd0a56eba1ea7494", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "29b37f40b943fd56fa69b2e1ae84e3703d5fc6c5", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "cf4c3b643e2e440acbfc4fe90662bcfa179b54f8", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "3c5d3384617b9f865f7f238421f48c163118c968", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 148, "deletions": 79, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "98470995ead849b743d14b5a7ca67bfa29faa59c", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9d1f9f677b2901714513e6d466c5fb97e714df3f", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "35ce55a90032413267b188a7bdd1f00a2ede4c8d", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9b6017b377237cc909dd665fa594c8afbb56e01d", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "8501c5db7166ad0bdc7db6ff420d64fd9349e3a1", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "c71129fbf742401344a4fbe7687047300f71bae5", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "f9ca1b794068919957f32752dc36448a14e7cee2", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "3cd44447e52c7f9fa93d9ff2a9daa032e9dd0154", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "5e6d77db7b7e6b71541850e20b0ca3d70adb4ba6", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "26d76d1d9da9016705e0dd060926bfb8a1c79ae6", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9f987c334e2b63b41a51f3fc57e48b0f12a0a318", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "5799f6cace7609646c5ea557ba3f612e62bad23d", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "01ca074733c6db704f3a31c663d4925074c25f61", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "5c6460c1c4bdf19c07cc93022069cccc6d4907d5", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "20ec151c4bd2fea1c5458806b52071135a4cf971", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "800a89dc7dc343b808c774b94c1297e456603e1a", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "17636618057e49f121447d1f10d82af8273d0122", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "085f162072c7b707a1e044611e88ae0eb81cf564", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "97ed00bcc9248761c7ad0700ac4b0255324303b4", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "79520cd315c5e6add0f3ee49b42bd25acdea95ff", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "768c3ed331dafc87a459c297125e2dde6e5c80d9", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "4543a8d6e1111a85b4133efaa0b17bc0c512f400", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "2cac359266dd741e4e2e4d8c12c50d398152c80a", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "2a0262fe1cf16b6808bc1b7246b2f9d56133a081", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "c83d08f3c181d9262c73b48bc08d0723395353d3", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "606084653708e5fb9cb079b0ae7131d70459ae5c", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "df380f8ba2730b4c7aedc084e6680af67bcac5c8", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 141, "deletions": 98, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "78ec1c266ad6090b0d0fb2dab41b572e9aa7d506", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "d5ea61b2e4f6ecfde6efc98faefd8f081cf81c47", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "f34efb6cc89473e4003f60ef1e687f9daed16d82", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "f0cf6991fb7611a459a38cf90b416ab63f6210ec", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "f1ccca56c374603f7ac80b1d88cae9159af2e6ef", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "b97cac68855a45043739b6e97ca28a7d9139c0d0", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "0c61a3645f76e2900e0ed4120e3c9dea8f135ddf", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "a860fb0716e6a35538e12ffb337b4f1dd1acaa72", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "ebd167b4fa17dc6d57d7684aacf1a3c3399a221f", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 129, "deletions": 88, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "cde84b1861437b49204d18d1d8ad44f2945ee604", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9df23f3a9c47ace0d2b119aab7c8b1944b5c88cf", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "2a7681697fd7e2e402235876d2312f4220f0771d", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "9be251f92e16ac27e65e4f98bf26d49f3559f170", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "336995f358d4bdfb9b0b2c3abc0da6ca9a05efbf", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "51b01e6fd290ecf4dca0b537709d860b68c84c27", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7024a120ac89dcd45a91f3f493fd3b66d21fcef3", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "ccb65f56b7e7d0dae7b944f6ae5c76b360ba16a1", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "e9a8f890d2e2210635452671d8108fd0b0b8bb63", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "081c274c421f8a525b811c78c8629335a8b94d1c", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "d1bc0333cc275a705743f450cfa6cc1fd43b7fc8", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "8228afdef42e3accb9e55e6622d13c216bb275c2", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "825a89f75902d03724524470a8d751127014e049", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "1568e18437ca2335821fcae993027933e1b7e8b0", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "490182768f857abb09acdeee3c71a89122fb47aa", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "4bd6e428e39ed4141df7fe152fab9dd661ad8071", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "6512ed2b5a7f53a79d26654fa2b1eb30ec007f4a", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "29b724d24e2a14c834dac65177333eea9a2f1f53", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "254431358be5b488fe712a14b702dd6bd234f814", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "35d3ae05f3a2ccb00b357994db5589cbbf664c7a", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "0d437ff672abd1560c0d0e06d38be5eff271dd48", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7a3a443da2386c7034248ffed132d45226971bbb", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "1386b319de17f103bdec9c24e03d3dfab308962e", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "56b2cae0e4eca551d4e81f0d0859853c096a521f", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "12c0c6948a5a84dfc99528c6bad28e21b471c670", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "8f1740b15101a41fb5a7b1fdace672862c22e878", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "a2e200274f5bc2c15af48d6ea730ee0363352c8e", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "14e501c67fe034724d2e50e083c5f3142b3256aa", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 63, "deletions": 60, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "3c01ae8fe714b010da20e35413d91530d9df519c", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "4ff62474107444b56fdc8bf646c0cc63a009205a", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "aef7b9b8dc75fac059b08594a1415ce5c97e10c1", "filename": "libgfortran/m4/maxloc0.m4", "status": "modified", "additions": 82, "deletions": 17, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "84b5a35c5c44ea47edf7ad2580369b8abe7f250b", "filename": "libgfortran/m4/maxloc1.m4", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "7557eb130a1cce2a3496362ad57732aad1f45439", "filename": "libgfortran/m4/maxval.m4", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxval.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fmaxval.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxval.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "1345f2df472ef8896a81eeb87663e4478edee83a", "filename": "libgfortran/m4/minloc0.m4", "status": "modified", "additions": 82, "deletions": 17, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "6fa5e69ccc75d26842e101e03e590d1592c56a1b", "filename": "libgfortran/m4/minloc1.m4", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}, {"sha": "3acae2eaa88e647c7bb0e56f3bb295ffef511e44", "filename": "libgfortran/m4/minval.m4", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminval.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80927a562e1ec4a38a12f4b09b86f2f3ca9f253e/libgfortran%2Fm4%2Fminval.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminval.m4?ref=80927a562e1ec4a38a12f4b09b86f2f3ca9f253e"}]}