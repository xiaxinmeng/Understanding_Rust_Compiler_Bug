{"sha": "3038054c687e9400976012eea70333db70ad6a7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAzODA1NGM2ODdlOTQwMDk3NjAxMmVlYTcwMzMzZGI3MGFkNmE3Yg==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-10-29T18:37:47Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-10-29T18:37:47Z"}, "message": "Added Cilk runtime library (libcilkrts) into GCC.\n\nFrom-SVN: r204173", "tree": {"sha": "235d812c6202e962d45c0cce844b2afcc5a0596d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/235d812c6202e962d45c0cce844b2afcc5a0596d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3038054c687e9400976012eea70333db70ad6a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3038054c687e9400976012eea70333db70ad6a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3038054c687e9400976012eea70333db70ad6a7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3038054c687e9400976012eea70333db70ad6a7b/comments", "author": null, "committer": null, "parents": [{"sha": "939b37da6ded55070bd78fc28d3fd2222b4278fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939b37da6ded55070bd78fc28d3fd2222b4278fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939b37da6ded55070bd78fc28d3fd2222b4278fa"}], "stats": {"total": 58909, "additions": 58908, "deletions": 1}, "files": [{"sha": "f5563b2d3aa7e7578838100d28f9de1567f73bab", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -1,3 +1,12 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* Makefile.def: Add libcilkrts to target_modules.  Make libcilkrts \n+\tdepend on libstdc++ and libgcc.\n+\t* configure: Regenerate.\n+\t* configure.ac: Added libcilkrts to target binaries.  Also, restrict\n+\tlibcilkrts for POSIX and i*86, and x86_64 architectures.\n+\t* Makefile.in: Added libcilkrts related fields to support building it.\n+\n 2013-10-26  Jeff Law  <law@redhat.com>\n \n \t* Makefile.def (target_modules): Remove libmudflap"}, {"sha": "32296d1160f8205177a405fbf91a67d2325ff8b7", "filename": "Makefile.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -125,6 +125,8 @@ target_modules = { module= libvtv;\n \t\t   bootstrap=true;\n \t\t   lib_path=.libs;\n \t\t   raw_cxx=true; };\n+target_modules = { module= libcilkrts;\n+\t\t   lib_path=.libs; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true; };\n@@ -491,6 +493,7 @@ dependencies = { module=all-m4; on=all-build-texinfo; };\n // on libgcc and newlib/libgloss.\n lang_env_dependencies = { module=libjava; cxx=true; };\n lang_env_dependencies = { module=libitm; cxx=true; };\n+lang_env_dependencies = { module=libcilkrts; cxx=true; };\n lang_env_dependencies = { module=newlib; no_c=true; };\n lang_env_dependencies = { module=libgloss; no_c=true; };\n lang_env_dependencies = { module=libgcc; no_gcc=true; no_c=true; };\n@@ -531,6 +534,8 @@ dependencies = { module=install-target-libsanitizer; on=install-target-libstdc++\n dependencies = { module=install-target-libsanitizer; on=install-target-libgcc; };\n dependencies = { module=install-target-libvtv; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-libvtv; on=install-target-libgcc; };\n+dependencies = { module=install-target-libcilkrts; on=install-target-libstdc++-v3; };\n+dependencies = { module=install-target-libcilkrts; on=install-target-libgcc; };\n dependencies = { module=install-target-libjava; on=install-target-libgcc; };\n dependencies = { module=install-target-libitm; on=install-target-libgcc; };\n dependencies = { module=install-target-libobjc; on=install-target-libgcc; };"}, {"sha": "572b3d0941e425a5a334b8364ca3ad42dfc332a5", "filename": "Makefile.in", "status": "modified", "additions": 999, "deletions": 1, "changes": 1000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -575,7 +575,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)$(HOST_LIB_PATH_libcilkrts)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -597,6 +597,10 @@ TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n TARGET_LIB_PATH_libgomp = $$r/$(TARGET_SUBDIR)/libgomp/.libs:\n @endif target-libgomp\n \n+@if target-libcilkrts\n+TARGET_LIB_PATH_libcilkrts = $$r/$(TARGET_SUBDIR)/libcilkrts/.libs:\n+@endif target-libcilkrts\n+\n @if target-libitm\n TARGET_LIB_PATH_libitm = $$r/$(TARGET_SUBDIR)/libitm/.libs:\n @endif target-libitm\n@@ -942,6 +946,7 @@ configure-target:  \\\n     maybe-configure-target-boehm-gc \\\n     maybe-configure-target-rda \\\n     maybe-configure-target-libada \\\n+    maybe-configure-target-libcilkrts \\\n     maybe-configure-target-libgomp \\\n     maybe-configure-target-libitm \\\n     maybe-configure-target-libatomic\n@@ -1100,6 +1105,7 @@ all-target: maybe-all-target-libada\n @if target-libgomp-no-bootstrap\n all-target: maybe-all-target-libgomp\n @endif target-libgomp-no-bootstrap\n+all-target: maybe-all-target-libcilkrts\n all-target: maybe-all-target-libitm\n all-target: maybe-all-target-libatomic\n \n@@ -1925,6 +1931,7 @@ mostlyclean-target: maybe-mostlyclean-target-boehm-gc\n mostlyclean-target: maybe-mostlyclean-target-rda\n mostlyclean-target: maybe-mostlyclean-target-libada\n mostlyclean-target: maybe-mostlyclean-target-libgomp\n+mostlyclean-target: maybe-mostlyclean-target-libcilkrts\n mostlyclean-target: maybe-mostlyclean-target-libitm\n mostlyclean-target: maybe-mostlyclean-target-libatomic\n \n@@ -2007,6 +2014,7 @@ clean-target: maybe-clean-target-boehm-gc\n clean-target: maybe-clean-target-rda\n clean-target: maybe-clean-target-libada\n clean-target: maybe-clean-target-libgomp\n+clean-target: maybe-clean-target-libcilkrts\n clean-target: maybe-clean-target-libitm\n clean-target: maybe-clean-target-libatomic\n \n@@ -2089,6 +2097,7 @@ distclean-target: maybe-distclean-target-boehm-gc\n distclean-target: maybe-distclean-target-rda\n distclean-target: maybe-distclean-target-libada\n distclean-target: maybe-distclean-target-libgomp\n+distclean-target: maybe-distclean-target-libcilkrts\n distclean-target: maybe-distclean-target-libitm\n distclean-target: maybe-distclean-target-libatomic\n \n@@ -2171,6 +2180,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-boehm-gc\n maintainer-clean-target: maybe-maintainer-clean-target-rda\n maintainer-clean-target: maybe-maintainer-clean-target-libada\n maintainer-clean-target: maybe-maintainer-clean-target-libgomp\n+maintainer-clean-target: maybe-maintainer-clean-target-libcilkrts\n maintainer-clean-target: maybe-maintainer-clean-target-libitm\n maintainer-clean-target: maybe-maintainer-clean-target-libatomic\n \n@@ -2463,6 +2473,7 @@ install-target:  \\\n     maybe-install-target-rda \\\n     maybe-install-target-libada \\\n     maybe-install-target-libgomp \\\n+    maybe-install-target-libcilkrts \\\n     maybe-install-target-libitm \\\n     maybe-install-target-libatomic\n \n@@ -2564,6 +2575,7 @@ install-strip-target:  \\\n     maybe-install-strip-target-boehm-gc \\\n     maybe-install-strip-target-rda \\\n     maybe-install-strip-target-libada \\\n+    maybe-install-strip-target-libcilkrts \\\n     maybe-install-strip-target-libgomp \\\n     maybe-install-strip-target-libitm \\\n     maybe-install-strip-target-libatomic\n@@ -41869,6 +41881,983 @@ maintainer-clean-target-libada:\n @endif target-libada\n \n \n+.PHONY: configure-target-libcilkrts maybe-configure-target-libcilkrts\n+maybe-configure-target-libcilkrts:\n+@if gcc-bootstrap\n+configure-target-libcilkrts: stage_current\n+@endif gcc-bootstrap\n+@if target-libcilkrts\n+maybe-configure-target-libcilkrts: configure-target-libcilkrts\n+configure-target-libcilkrts: \n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libcilkrts...(1)\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libcilkrts; \\\n+\tcd \"$(TARGET_SUBDIR)/libcilkrts\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1 \n+@endif target-libcilkrts\n+\n+\n+.PHONY: configure-stage1-target-libcilkrts maybe-configure-stage1-target-libcilkrts\n+maybe-configure-stage1-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stage1-target-libcilkrts: configure-stage1-target-libcilkrts\n+configure-stage1-target-libcilkrts:\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(2)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 1 in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  $(STAGE1_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+.PHONY: configure-stage2-target-libcilkrts maybe-configure-stage2-target-libcilkrts\n+maybe-configure-stage2-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stage2-target-libcilkrts: configure-stage2-target-libcilkrts\n+configure-stage2-target-libcilkrts:\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(3)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 2 in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE2_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+.PHONY: configure-stage3-target-libcilkrts maybe-configure-stage3-target-libcilkrts\n+maybe-configure-stage3-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stage3-target-libcilkrts: configure-stage3-target-libcilkrts\n+configure-stage3-target-libcilkrts:\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(4)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 3 in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE3_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+.PHONY: configure-stage4-target-libcilkrts maybe-configure-stage4-target-libcilkrts\n+maybe-configure-stage4-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stage4-target-libcilkrts: configure-stage4-target-libcilkrts\n+configure-stage4-target-libcilkrts:\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(4)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 4 in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE4_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+.PHONY: configure-stageprofile-target-libcilkrts maybe-configure-stageprofile-target-libcilkrts\n+maybe-configure-stageprofile-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stageprofile-target-libcilkrts: configure-stageprofile-target-libcilkrts\n+configure-stageprofile-target-libcilkrts:\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(5)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage profile in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEprofile_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+.PHONY: configure-stagefeedback-target-libcilkrts maybe-configure-stagefeedback-target-libcilkrts\n+maybe-configure-stagefeedback-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-configure-stagefeedback-target-libcilkrts: configure-stagefeedback-target-libcilkrts\n+configure-stagefeedback-target-libcilkrts:\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libcilkrts...(6)\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage feedback in $(TARGET_SUBDIR)/libcilkrts ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts ; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libcilkrts\"; \\\n+\tlibsrcdir=\"$$s/libcilkrts\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEfeedback_CONFIGURE_FLAGS)\n+@endif target-libcilkrts-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: all-target-libcilkrts maybe-all-target-libcilkrts\n+maybe-all-target-libcilkrts:\n+@if gcc-bootstrap\n+all-target-libcilkrts: stage_current\n+@endif gcc-bootstrap\n+@if target-libcilkrts\n+TARGET-target-libcilkrts=all\n+maybe-all-target-libcilkrts: all-target-libcilkrts\n+all-target-libcilkrts: configure-target-libcilkrts\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t$(TARGET-target-libcilkrts))\n+@endif target-libcilkrts\n+\n+\n+\n+.PHONY: all-stage1-target-libcilkrts maybe-all-stage1-target-libcilkrts\n+.PHONY: clean-stage1-target-libcilkrts maybe-clean-stage1-target-libcilkrts\n+maybe-all-stage1-target-libcilkrts:\n+maybe-clean-stage1-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stage1-target-libcilkrts: all-stage1-target-libcilkrts\n+all-stage1: all-stage1-target-libcilkrts\n+TARGET-stage1-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stage1-target-libcilkrts: configure-stage1-target-libcilkrts\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n+\t\t$(TARGET-stage1-target-libcilkrts)\n+\n+maybe-clean-stage1-target-libcilkrts: clean-stage1-target-libcilkrts\n+clean-stage1: clean-stage1-target-libcilkrts\n+clean-stage1-target-libcilkrts:\n+\t@if [ $(current_stage) = stage1 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage1-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage1-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+.PHONY: all-stage2-target-libcilkrts maybe-all-stage2-target-libcilkrts\n+.PHONY: clean-stage2-target-libcilkrts maybe-clean-stage2-target-libcilkrts\n+maybe-all-stage2-target-libcilkrts:\n+maybe-clean-stage2-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stage2-target-libcilkrts: all-stage2-target-libcilkrts\n+all-stage2: all-stage2-target-libcilkrts\n+TARGET-stage2-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stage2-target-libcilkrts: configure-stage2-target-libcilkrts\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n+\t\t$(TARGET-stage2-target-libcilkrts)\n+\n+maybe-clean-stage2-target-libcilkrts: clean-stage2-target-libcilkrts\n+clean-stage2: clean-stage2-target-libcilkrts\n+clean-stage2-target-libcilkrts:\n+\t@if [ $(current_stage) = stage2 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage2-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage2-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+.PHONY: all-stage3-target-libcilkrts maybe-all-stage3-target-libcilkrts\n+.PHONY: clean-stage3-target-libcilkrts maybe-clean-stage3-target-libcilkrts\n+maybe-all-stage3-target-libcilkrts:\n+maybe-clean-stage3-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stage3-target-libcilkrts: all-stage3-target-libcilkrts\n+all-stage3: all-stage3-target-libcilkrts\n+TARGET-stage3-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stage3-target-libcilkrts: configure-stage3-target-libcilkrts\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n+\t\t$(TARGET-stage3-target-libcilkrts)\n+\n+maybe-clean-stage3-target-libcilkrts: clean-stage3-target-libcilkrts\n+clean-stage3: clean-stage3-target-libcilkrts\n+clean-stage3-target-libcilkrts:\n+\t@if [ $(current_stage) = stage3 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage3-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage3-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+.PHONY: all-stage4-target-libcilkrts maybe-all-stage4-target-libcilkrts\n+.PHONY: clean-stage4-target-libcilkrts maybe-clean-stage4-target-libcilkrts\n+maybe-all-stage4-target-libcilkrts:\n+maybe-clean-stage4-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stage4-target-libcilkrts: all-stage4-target-libcilkrts\n+all-stage4: all-stage4-target-libcilkrts\n+TARGET-stage4-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stage4-target-libcilkrts: configure-stage4-target-libcilkrts\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n+\t\t$(TARGET-stage4-target-libcilkrts)\n+\n+maybe-clean-stage4-target-libcilkrts: clean-stage4-target-libcilkrts\n+clean-stage4: clean-stage4-target-libcilkrts\n+clean-stage4-target-libcilkrts:\n+\t@if [ $(current_stage) = stage4 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage4-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage4-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+.PHONY: all-stageprofile-target-libcilkrts maybe-all-stageprofile-target-libcilkrts\n+.PHONY: clean-stageprofile-target-libcilkrts maybe-clean-stageprofile-target-libcilkrts\n+maybe-all-stageprofile-target-libcilkrts:\n+maybe-clean-stageprofile-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stageprofile-target-libcilkrts: all-stageprofile-target-libcilkrts\n+all-stageprofile: all-stageprofile-target-libcilkrts\n+TARGET-stageprofile-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stageprofile-target-libcilkrts: configure-stageprofile-target-libcilkrts\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n+\t\t$(TARGET-stageprofile-target-libcilkrts)\n+\n+maybe-clean-stageprofile-target-libcilkrts: clean-stageprofile-target-libcilkrts\n+clean-stageprofile: clean-stageprofile-target-libcilkrts\n+clean-stageprofile-target-libcilkrts:\n+\t@if [ $(current_stage) = stageprofile ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stageprofile-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stageprofile-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+.PHONY: all-stagefeedback-target-libcilkrts maybe-all-stagefeedback-target-libcilkrts\n+.PHONY: clean-stagefeedback-target-libcilkrts maybe-clean-stagefeedback-target-libcilkrts\n+maybe-all-stagefeedback-target-libcilkrts:\n+maybe-clean-stagefeedback-target-libcilkrts:\n+@if target-libcilkrts-bootstrap\n+maybe-all-stagefeedback-target-libcilkrts: all-stagefeedback-target-libcilkrts\n+all-stagefeedback: all-stagefeedback-target-libcilkrts\n+TARGET-stagefeedback-target-libcilkrts = $(TARGET-target-libcilkrts)\n+all-stagefeedback-target-libcilkrts: configure-stagefeedback-target-libcilkrts\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n+\t\t$(TARGET-stagefeedback-target-libcilkrts)\n+\n+maybe-clean-stagefeedback-target-libcilkrts: clean-stagefeedback-target-libcilkrts\n+clean-stagefeedback: clean-stagefeedback-target-libcilkrts\n+clean-stagefeedback-target-libcilkrts:\n+\t@if [ $(current_stage) = stagefeedback ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stagefeedback-libcilkrts/Makefile ] || exit 0; \\\n+\t  $(MAKE) stagefeedback-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t  \\\n+\t\t clean\n+@endif target-libcilkrts-bootstrap\n+\n+\n+\n+\n+\n+\n+.PHONY: check-target-libcilkrts maybe-check-target-libcilkrts\n+maybe-check-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-check-target-libcilkrts: check-target-libcilkrts\n+\n+check-target-libcilkrts:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libcilkrts\n+\n+.PHONY: install-target-libcilkrts maybe-install-target-libcilkrts\n+maybe-install-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-install-target-libcilkrts: install-target-libcilkrts\n+\n+install-target-libcilkrts: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libcilkrts\n+\n+.PHONY: install-strip-target-libcilkrts maybe-install-strip-target-libcilkrts\n+maybe-install-strip-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-install-strip-target-libcilkrts: install-strip-target-libcilkrts\n+\n+install-strip-target-libcilkrts: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libcilkrts\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libcilkrts info-target-libcilkrts\n+maybe-info-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-info-target-libcilkrts: info-target-libcilkrts\n+\n+info-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-dvi-target-libcilkrts dvi-target-libcilkrts\n+maybe-dvi-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-dvi-target-libcilkrts: dvi-target-libcilkrts\n+\n+dvi-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-pdf-target-libcilkrts pdf-target-libcilkrts\n+maybe-pdf-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-pdf-target-libcilkrts: pdf-target-libcilkrts\n+\n+pdf-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-html-target-libcilkrts html-target-libcilkrts\n+maybe-html-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-html-target-libcilkrts: html-target-libcilkrts\n+\n+html-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-TAGS-target-libcilkrts TAGS-target-libcilkrts\n+maybe-TAGS-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-TAGS-target-libcilkrts: TAGS-target-libcilkrts\n+\n+TAGS-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-install-info-target-libcilkrts install-info-target-libcilkrts\n+maybe-install-info-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-install-info-target-libcilkrts: install-info-target-libcilkrts\n+\n+install-info-target-libcilkrts: \\\n+    configure-target-libcilkrts \\\n+    info-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-install-pdf-target-libcilkrts install-pdf-target-libcilkrts\n+maybe-install-pdf-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-install-pdf-target-libcilkrts: install-pdf-target-libcilkrts\n+\n+install-pdf-target-libcilkrts: \\\n+    configure-target-libcilkrts \\\n+    pdf-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-install-html-target-libcilkrts install-html-target-libcilkrts\n+maybe-install-html-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-install-html-target-libcilkrts: install-html-target-libcilkrts\n+\n+install-html-target-libcilkrts: \\\n+    configure-target-libcilkrts \\\n+    html-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-installcheck-target-libcilkrts installcheck-target-libcilkrts\n+maybe-installcheck-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-installcheck-target-libcilkrts: installcheck-target-libcilkrts\n+\n+installcheck-target-libcilkrts: \\\n+    configure-target-libcilkrts \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-mostlyclean-target-libcilkrts mostlyclean-target-libcilkrts\n+maybe-mostlyclean-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-mostlyclean-target-libcilkrts: mostlyclean-target-libcilkrts\n+\n+mostlyclean-target-libcilkrts: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-clean-target-libcilkrts clean-target-libcilkrts\n+maybe-clean-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-clean-target-libcilkrts: clean-target-libcilkrts\n+\n+clean-target-libcilkrts: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-distclean-target-libcilkrts distclean-target-libcilkrts\n+maybe-distclean-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-distclean-target-libcilkrts: distclean-target-libcilkrts\n+\n+distclean-target-libcilkrts: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n+\n+.PHONY: maybe-maintainer-clean-target-libcilkrts maintainer-clean-target-libcilkrts\n+maybe-maintainer-clean-target-libcilkrts:\n+@if target-libcilkrts\n+maybe-maintainer-clean-target-libcilkrts: maintainer-clean-target-libcilkrts\n+\n+maintainer-clean-target-libcilkrts: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libcilkrts\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libcilkrts\n \n \n \n@@ -45901,6 +46890,7 @@ configure-stage3-target-libvtv: maybe-all-stage3-gcc\n configure-stage4-target-libvtv: maybe-all-stage4-gcc\n configure-stageprofile-target-libvtv: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-gcc\n+configure-target-libcilkrts: stage_last\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n configure-stage1-target-libgcc: maybe-all-stage1-gcc\n@@ -45955,6 +46945,7 @@ configure-target-boehm-gc: maybe-all-gcc\n configure-target-rda: maybe-all-gcc\n configure-target-libada: maybe-all-gcc\n configure-target-libgomp: maybe-all-gcc\n+configure-target-libcilkrts: maybe-all-gcc\n configure-target-libitm: maybe-all-gcc\n configure-target-libatomic: maybe-all-gcc\n @endif gcc-no-bootstrap\n@@ -46720,6 +47711,8 @@ configure-stage3-target-libvtv: maybe-all-stage3-target-libstdc++-v3\n configure-stage4-target-libvtv: maybe-all-stage4-target-libstdc++-v3\n configure-stageprofile-target-libvtv: maybe-all-stageprofile-target-libstdc++-v3\n configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-target-libstdc++-v3\n+configure-target-libcilkrts: maybe-all-target-libstdc++-v3\n+configure-target-libcilkrts: maybe-all-gcc\n all-target-libstdc++-v3: maybe-configure-target-libgomp\n \n all-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp\n@@ -46735,6 +47728,8 @@ install-target-libsanitizer: maybe-install-target-libstdc++-v3\n install-target-libsanitizer: maybe-install-target-libgcc\n install-target-libvtv: maybe-install-target-libstdc++-v3\n install-target-libvtv: maybe-install-target-libgcc\n+install-target-libcilkrts: maybe-install-target-libstdc++-v3\n+install-target-libcilkrts: maybe-install-target-libgcc\n install-target-libjava: maybe-install-target-libgcc\n install-target-libitm: maybe-install-target-libgcc\n install-target-libobjc: maybe-install-target-libgcc\n@@ -46783,6 +47778,7 @@ configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libvtv: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n+configure-target-libcilkrts: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n configure-target-libbacktrace: maybe-all-target-libgcc\n configure-target-libquadmath: maybe-all-target-libgcc\n@@ -46830,6 +47826,8 @@ configure-target-winsup: maybe-all-target-newlib maybe-all-target-libgloss\n \n \n configure-target-libffi: maybe-all-target-newlib maybe-all-target-libgloss\n+configure-target-libcilkrts: maybe-all-target-newlib maybe-all-target-libgloss\n+configure-target-libcilkrts: maybe-all-target-libstdc++-v3\n \n configure-target-libjava: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-libjava: maybe-all-target-libstdc++-v3"}, {"sha": "c95990a6f4ceb20b4f3c7488d5c2bf06294d923d", "filename": "configure", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -2772,6 +2772,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libcilkrts \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -3164,6 +3165,25 @@ $as_echo \"yes\" >&6; }\n     fi\n fi\n \n+# Disable libcilkrts on unsupported systems.\n+if test -d ${srcdir}/libcilkrts; then\n+    if test x$enable_libcilkrts = x; then\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libcilkrts support\" >&5\n+$as_echo_n \"checking for libcilkrts support... \" >&6; }\n+\tif (srcdir=${srcdir}/libcilkrts; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+\t    noconfigdirs=\"$noconfigdirs target-libcilkrts\"\n+\telse\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; }\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then"}, {"sha": "140877ffedc3ff8c415bef2eadbaa03abf9e6ea2", "filename": "configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -156,6 +156,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libcilkrts \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -506,6 +507,22 @@ if test -d ${srcdir}/libatomic; then\n     fi\n fi\n \n+# Disable libcilkrts on unsupported systems.\n+if test -d ${srcdir}/libcilkrts; then\n+    if test x$enable_libcilkrts = x; then\n+\tAC_MSG_CHECKING([for libcilkrts support])\n+\tif (srcdir=${srcdir}/libcilkrts; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    AC_MSG_RESULT([no])\n+\t    noconfigdirs=\"$noconfigdirs target-libcilkrts\"\n+\telse\n+\t    AC_MSG_RESULT([yes])\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then"}, {"sha": "884e861b25d7bb8145304919a10fb7699559a02e", "filename": "libcilkrts/ChangeLog", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FChangeLog?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,105 @@\n+2013-10-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* libcilkrts/Makefile.am: New file.  Libcilkrts version 3902.\n+\t* libcilkrts/Makefile.in: Likewise\n+\t* libcilkrts/README: Likewise\n+\t* libcilkrts/aclocal.m4: Likewise\n+\t* libcilkrts/configure: Likewise\n+\t* libcilkrts/configure.ac: Likewise\n+\t* libcilkrts/include/cilk/cilk.h: Likewise\n+\t* libcilkrts/include/cilk/cilk_api.h: Likewise\n+\t* libcilkrts/include/cilk/cilk_api_linux.h: Likewise\n+\t* libcilkrts/include/cilk/cilk_stub.h: Likewise\n+\t* libcilkrts/include/cilk/cilk_undocumented.h: Likewise\n+\t* libcilkrts/include/cilk/common.h: Likewise\n+\t* libcilkrts/include/cilk/holder.h: Likewise\n+\t* libcilkrts/include/cilk/hyperobject_base.h: Likewise\n+\t* libcilkrts/include/cilk/metaprogramming.h: Likewise\n+\t* libcilkrts/include/cilk/reducer.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_file.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_list.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_max.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_min.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_min_max.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_opadd.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_opand.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_opmul.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_opor.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_opxor.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_ostream.h: Likewise\n+\t* libcilkrts/include/cilk/reducer_string.h: Likewise\n+\t* libcilkrts/include/cilktools/cilkscreen.h: Likewise\n+\t* libcilkrts/include/cilktools/cilkview.h: Likewise\n+\t* libcilkrts/include/cilktools/fake_mutex.h: Likewise\n+\t* libcilkrts/include/cilktools/lock_guard.h: Likewise\n+\t* libcilkrts/include/internal/abi.h: Likewise\n+\t* libcilkrts/include/internal/cilk_fake.h: Likewise\n+\t* libcilkrts/include/internal/cilk_version.h: Likewise\n+\t* libcilkrts/include/internal/inspector-abi.h: Likewise\n+\t* libcilkrts/include/internal/metacall.h: Likewise\n+\t* libcilkrts/include/internal/rev.mk: Likewise\n+\t* libcilkrts/mk/cilk-version.mk: Likewise\n+\t* libcilkrts/mk/unix-common.mk: Likewise\n+\t* libcilkrts/runtime/acknowledgements.dox: Likewise\n+\t* libcilkrts/runtime/bug.cpp: Likewise\n+\t* libcilkrts/runtime/bug.h: Likewise\n+\t* libcilkrts/runtime/c_reducers.c: Likewise\n+\t* libcilkrts/runtime/cilk-abi-cilk-for.cpp: Likewise\n+\t* libcilkrts/runtime/cilk-abi-vla-internal.c: Likewise\n+\t* libcilkrts/runtime/cilk-abi-vla-internal.h: Likewise\n+\t* libcilkrts/runtime/cilk-abi-vla.c: Likewise\n+\t* libcilkrts/runtime/cilk-abi.c: Likewise\n+\t* libcilkrts/runtime/cilk-ittnotify.h: Likewise\n+\t* libcilkrts/runtime/cilk-tbb-interop.h: Likewise\n+\t* libcilkrts/runtime/cilk_api.c: Likewise\n+\t* libcilkrts/runtime/cilk_fiber-unix.cpp: Likewise\n+\t* libcilkrts/runtime/cilk_fiber-unix.h: Likewise\n+\t* libcilkrts/runtime/cilk_fiber.cpp: Likewise\n+\t* libcilkrts/runtime/cilk_fiber.h: Likewise\n+\t* libcilkrts/runtime/cilk_malloc.c: Likewise\n+\t* libcilkrts/runtime/cilk_malloc.h: Likewise\n+\t* libcilkrts/runtime/component.h: Likewise\n+\t* libcilkrts/runtime/doxygen-layout.xml: Likewise\n+\t* libcilkrts/runtime/doxygen.cfg: Likewise\n+\t* libcilkrts/runtime/except-gcc.cpp: Likewise\n+\t* libcilkrts/runtime/except-gcc.h: Likewise\n+\t* libcilkrts/runtime/except.h: Likewise\n+\t* libcilkrts/runtime/frame_malloc.c: Likewise\n+\t* libcilkrts/runtime/frame_malloc.h: Likewise\n+\t* libcilkrts/runtime/full_frame.c: Likewise\n+\t* libcilkrts/runtime/full_frame.h: Likewise\n+\t* libcilkrts/runtime/global_state.cpp: Likewise\n+\t* libcilkrts/runtime/global_state.h: Likewise\n+\t* libcilkrts/runtime/jmpbuf.c: Likewise\n+\t* libcilkrts/runtime/jmpbuf.h: Likewise\n+\t* libcilkrts/runtime/local_state.c: Likewise\n+\t* libcilkrts/runtime/local_state.h: Likewise\n+\t* libcilkrts/runtime/metacall_impl.c: Likewise\n+\t* libcilkrts/runtime/metacall_impl.h: Likewise\n+\t* libcilkrts/runtime/os-unix.c: Likewise\n+\t* libcilkrts/runtime/os.h: Likewise\n+\t* libcilkrts/runtime/os_mutex-unix.c: Likewise\n+\t* libcilkrts/runtime/os_mutex.h: Likewise\n+\t* libcilkrts/runtime/pedigrees.c: Likewise\n+\t* libcilkrts/runtime/pedigrees.h: Likewise\n+\t* libcilkrts/runtime/record-replay.cpp: Likewise\n+\t* libcilkrts/runtime/record-replay.h: Likewise\n+\t* libcilkrts/runtime/reducer_impl.cpp: Likewise\n+\t* libcilkrts/runtime/reducer_impl.h: Likewise\n+\t* libcilkrts/runtime/rts-common.h: Likewise\n+\t* libcilkrts/runtime/scheduler.c: Likewise\n+\t* libcilkrts/runtime/scheduler.h: Likewise\n+\t* libcilkrts/runtime/signal_node.c: Likewise\n+\t* libcilkrts/runtime/signal_node.h: Likewise\n+\t* libcilkrts/runtime/spin_mutex.c: Likewise\n+\t* libcilkrts/runtime/spin_mutex.h: Likewise\n+\t* libcilkrts/runtime/stacks.h: Likewise\n+\t* libcilkrts/runtime/stats.c: Likewise\n+\t* libcilkrts/runtime/stats.h: Likewise\n+\t* libcilkrts/runtime/symbol_test.c: Likewise\n+\t* libcilkrts/runtime/sysdep-unix.c: Likewise\n+\t* libcilkrts/runtime/sysdep.h: Likewise\n+\t* libcilkrts/runtime/unix_symbols.t: Likewise\n+\t* libcilkrts/runtime/worker_mutex.c: Likewise\n+\t* libcilkrts/runtime/worker_mutex.h: Likewise\n+"}, {"sha": "f332cfb13de66b1df4284273aacd0c3c6da8de0f", "filename": "libcilkrts/Makefile.am", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FMakefile.am?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,173 @@\n+#  @copyright\n+#  Copyright (C) 2011, 2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+AUTOMAKE_OPTIONS = foreign\n+\n+# Use when building GCC\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# Compiler and linker flags.\n+GENERAL_FLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/runtime -I$(top_srcdir)/runtime/config/$(config_dir) -DIN_CILK_RUNTIME=1\n+GENERAL_FLAGS += -D_Cilk_spawn=\"\" -D_Cilk_sync=\"\" -D_Cilk_for=for\n+\n+# Enable Intel Cilk Plus extension\n+GENERAL_FLAGS += -fcilkplus\n+\n+AM_CFLAGS = $(GENERAL_FLAGS) -std=c99\n+AM_CPPFLAGS = $(GENERAL_FLAGS)\n+AM_LDFLAGS = -lpthread -ldl\n+\n+# Target list.\n+toolexeclib_LTLIBRARIES = libcilkrts.la\n+\n+libcilkrts_la_SOURCES =            \\\n+  runtime/config/$(config_dir)/cilk-abi-vla.c           \\\n+  runtime/config/$(config_dir)/os-unix-sysdep.c \\\n+  runtime/bug.cpp                  \\\n+  runtime/cilk-abi.c               \\\n+  runtime/cilk-abi-cilk-for.cpp    \\\n+  runtime/cilk-abi-vla-internal.c  \\\n+  runtime/cilk_api.c               \\\n+  runtime/cilk_fiber.cpp           \\\n+  runtime/cilk_fiber-unix.cpp      \\\n+  runtime/cilk_malloc.c            \\\n+  runtime/c_reducers.c             \\\n+  runtime/except-gcc.cpp           \\\n+  runtime/frame_malloc.c           \\\n+  runtime/full_frame.c             \\\n+  runtime/global_state.cpp         \\\n+  runtime/jmpbuf.c                 \\\n+  runtime/local_state.c            \\\n+  runtime/metacall_impl.c          \\\n+  runtime/os_mutex-unix.c          \\\n+  runtime/os-unix.c                \\\n+  runtime/pedigrees.c              \\\n+  runtime/record-replay.cpp        \\\n+  runtime/reducer_impl.cpp         \\\n+  runtime/scheduler.c              \\\n+  runtime/signal_node.c            \\\n+  runtime/spin_mutex.c             \\\n+  runtime/stats.c                  \\\n+  runtime/symbol_test.c            \\\n+  runtime/sysdep-unix.c            \\\n+  runtime/worker_mutex.c\n+\n+\n+# Load the $(REVISION) value.\n+include include/internal/rev.mk\n+\n+#libcilkrts_la_LDFLAGS  = -rpath '$(libdir)'\n+libcilkrts_la_LDFLAGS = -version-info 5:0:0\n+libcilkrts_la_LDFLAGS += -lpthread -ldl\n+\n+# If we're building on Linux, use the Linux version script\n+if LINUX_LINKER_SCRIPT\n+    libcilkrts_la_LDFLAGS += -Wl,--version-script,$(srcdir)/runtime/linux-symbols.ver\n+endif\n+\n+# If we're building on MacOS, use the Mac versioning\n+if MAC_LINKER_SCRIPT\n+  libcilkrts_la_LDFLAGS += -Wl,-exported_symbols_list,$(srcdir)/runtime/mac-symbols.txt\n+endif\n+\n+\n+# Hack for Cygwin\n+libcilkrts_la_LDFLAGS += -no-undefined\n+\n+# C/C++ header files for Cilk.\n+cilkincludedir = $(includedir)/cilk\n+cilkinclude_HEADERS =              \\\n+  include/cilk/cilk_api.h          \\\n+  include/cilk/cilk_api_linux.h    \\\n+  include/cilk/cilk.h              \\\n+  include/cilk/cilk_stub.h         \\\n+  include/cilk/cilk_undocumented.h \\\n+  include/cilk/common.h            \\\n+  include/cilk/holder.h            \\\n+  include/cilk/hyperobject_base.h  \\\n+  include/cilk/metaprogramming.h   \\\n+  include/cilk/reducer_file.h      \\\n+  include/cilk/reducer.h           \\\n+  include/cilk/reducer_list.h      \\\n+  include/cilk/reducer_max.h       \\\n+  include/cilk/reducer_min.h       \\\n+  include/cilk/reducer_min_max.h   \\\n+  include/cilk/reducer_opadd.h     \\\n+  include/cilk/reducer_opand.h     \\\n+  include/cilk/reducer_opmul.h     \\\n+  include/cilk/reducer_opor.h      \\\n+  include/cilk/reducer_opxor.h     \\\n+  include/cilk/reducer_ostream.h   \\\n+  include/cilk/reducer_string.h\n+\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+"}, {"sha": "ecf8080faf9cb866151c41a06216691e63850641", "filename": "libcilkrts/Makefile.in", "status": "added", "additions": 1045, "deletions": 0, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FMakefile.in?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,1045 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+#  @copyright\n+#  Copyright (C) 2011, 2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+#########################################################################\n+#\n+#  @copyright\n+#  Copyright (C) 2011-2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+###########################################################################\n+\n+# DO NOT EDIT THIS FILE!\n+#\n+# It was automatically generated by cilkrts/include/internal/Makefile\n+\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+DIST_COMMON = $(srcdir)/include/internal/rev.mk README ChangeLog \\\n+\t$(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n+\t$(top_srcdir)/configure $(am__configure_deps) \\\n+\t$(srcdir)/../mkinstalldirs $(srcdir)/../depcomp \\\n+\t$(cilkinclude_HEADERS)\n+\n+# If we're building on Linux, use the Linux version script\n+@LINUX_LINKER_SCRIPT_TRUE@am__append_1 = -Wl,--version-script,$(srcdir)/runtime/linux-symbols.ver\n+\n+# If we're building on MacOS, use the Mac versioning\n+@MAC_LINKER_SCRIPT_TRUE@am__append_2 = -Wl,-exported_symbols_list,$(srcdir)/runtime/mac-symbols.txt\n+subdir = .\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+\t\"$(DESTDIR)$(cilkincludedir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libcilkrts_la_LIBADD =\n+am_libcilkrts_la_OBJECTS = cilk-abi-vla.lo os-unix-sysdep.lo bug.lo \\\n+\tcilk-abi.lo cilk-abi-cilk-for.lo cilk-abi-vla-internal.lo \\\n+\tcilk_api.lo cilk_fiber.lo cilk_fiber-unix.lo cilk_malloc.lo \\\n+\tc_reducers.lo except-gcc.lo frame_malloc.lo full_frame.lo \\\n+\tglobal_state.lo jmpbuf.lo local_state.lo metacall_impl.lo \\\n+\tos_mutex-unix.lo os-unix.lo pedigrees.lo record-replay.lo \\\n+\treducer_impl.lo scheduler.lo signal_node.lo spin_mutex.lo \\\n+\tstats.lo symbol_test.lo sysdep-unix.lo worker_mutex.lo\n+libcilkrts_la_OBJECTS = $(am_libcilkrts_la_OBJECTS)\n+libcilkrts_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libcilkrts_la_LDFLAGS) $(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libcilkrts_la_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+HEADERS = $(cilkinclude_HEADERS)\n+ETAGS = etags\n+CTAGS = ctags\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+config_dir = @config_dir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AUTOMAKE_OPTIONS = foreign\n+\n+# Use when building GCC\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# Compiler and linker flags.\n+\n+# Enable Intel Cilk Plus extension\n+GENERAL_FLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/runtime \\\n+\t-I$(top_srcdir)/runtime/config/$(config_dir) \\\n+\t-DIN_CILK_RUNTIME=1 -D_Cilk_spawn=\"\" -D_Cilk_sync=\"\" \\\n+\t-D_Cilk_for=for -fcilkplus\n+AM_CFLAGS = $(GENERAL_FLAGS) -std=c99\n+AM_CPPFLAGS = $(GENERAL_FLAGS)\n+AM_LDFLAGS = -lpthread -ldl\n+\n+# Target list.\n+toolexeclib_LTLIBRARIES = libcilkrts.la\n+libcilkrts_la_SOURCES = \\\n+  runtime/config/$(config_dir)/cilk-abi-vla.c           \\\n+  runtime/config/$(config_dir)/os-unix-sysdep.c \\\n+  runtime/bug.cpp                  \\\n+  runtime/cilk-abi.c               \\\n+  runtime/cilk-abi-cilk-for.cpp    \\\n+  runtime/cilk-abi-vla-internal.c  \\\n+  runtime/cilk_api.c               \\\n+  runtime/cilk_fiber.cpp           \\\n+  runtime/cilk_fiber-unix.cpp      \\\n+  runtime/cilk_malloc.c            \\\n+  runtime/c_reducers.c             \\\n+  runtime/except-gcc.cpp           \\\n+  runtime/frame_malloc.c           \\\n+  runtime/full_frame.c             \\\n+  runtime/global_state.cpp         \\\n+  runtime/jmpbuf.c                 \\\n+  runtime/local_state.c            \\\n+  runtime/metacall_impl.c          \\\n+  runtime/os_mutex-unix.c          \\\n+  runtime/os-unix.c                \\\n+  runtime/pedigrees.c              \\\n+  runtime/record-replay.cpp        \\\n+  runtime/reducer_impl.cpp         \\\n+  runtime/scheduler.c              \\\n+  runtime/signal_node.c            \\\n+  runtime/spin_mutex.c             \\\n+  runtime/stats.c                  \\\n+  runtime/symbol_test.c            \\\n+  runtime/sysdep-unix.c            \\\n+  runtime/worker_mutex.c\n+\n+CILK_REVISION = 3902\n+\n+# Load the $(REVISION) value.\n+\n+#libcilkrts_la_LDFLAGS  = -rpath '$(libdir)'\n+\n+# Hack for Cygwin\n+libcilkrts_la_LDFLAGS = -version-info 5:0:0 -lpthread -ldl \\\n+\t$(am__append_1) $(am__append_2) -no-undefined\n+\n+# C/C++ header files for Cilk.\n+cilkincludedir = $(includedir)/cilk\n+cilkinclude_HEADERS = \\\n+  include/cilk/cilk_api.h          \\\n+  include/cilk/cilk_api_linux.h    \\\n+  include/cilk/cilk.h              \\\n+  include/cilk/cilk_stub.h         \\\n+  include/cilk/cilk_undocumented.h \\\n+  include/cilk/common.h            \\\n+  include/cilk/holder.h            \\\n+  include/cilk/hyperobject_base.h  \\\n+  include/cilk/metaprogramming.h   \\\n+  include/cilk/reducer_file.h      \\\n+  include/cilk/reducer.h           \\\n+  include/cilk/reducer_list.h      \\\n+  include/cilk/reducer_max.h       \\\n+  include/cilk/reducer_min.h       \\\n+  include/cilk/reducer_min_max.h   \\\n+  include/cilk/reducer_opadd.h     \\\n+  include/cilk/reducer_opand.h     \\\n+  include/cilk/reducer_opmul.h     \\\n+  include/cilk/reducer_opor.h      \\\n+  include/cilk/reducer_opxor.h     \\\n+  include/cilk/reducer_ostream.h   \\\n+  include/cilk/reducer_string.h\n+\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .cpp .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am $(srcdir)/include/internal/rev.mk $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libcilkrts.la: $(libcilkrts_la_OBJECTS) $(libcilkrts_la_DEPENDENCIES) \n+\t$(libcilkrts_la_LINK) -rpath $(toolexeclibdir) $(libcilkrts_la_OBJECTS) $(libcilkrts_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bug.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/c_reducers.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk-abi-cilk-for.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk-abi-vla-internal.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk-abi-vla.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk-abi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk_api.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk_fiber-unix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk_fiber.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cilk_malloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/except-gcc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/frame_malloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/full_frame.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/global_state.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jmpbuf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/local_state.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/metacall_impl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-unix-sysdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-unix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os_mutex-unix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pedigrees.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/record-replay.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reducer_impl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scheduler.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/signal_node.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spin_mutex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stats.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/symbol_test.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sysdep-unix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/worker_mutex.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+cilk-abi-vla.lo: runtime/config/$(config_dir)/cilk-abi-vla.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cilk-abi-vla.lo -MD -MP -MF $(DEPDIR)/cilk-abi-vla.Tpo -c -o cilk-abi-vla.lo `test -f 'runtime/config/$(config_dir)/cilk-abi-vla.c' || echo '$(srcdir)/'`runtime/config/$(config_dir)/cilk-abi-vla.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cilk-abi-vla.Tpo $(DEPDIR)/cilk-abi-vla.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/config/$(config_dir)/cilk-abi-vla.c' object='cilk-abi-vla.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cilk-abi-vla.lo `test -f 'runtime/config/$(config_dir)/cilk-abi-vla.c' || echo '$(srcdir)/'`runtime/config/$(config_dir)/cilk-abi-vla.c\n+\n+os-unix-sysdep.lo: runtime/config/$(config_dir)/os-unix-sysdep.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT os-unix-sysdep.lo -MD -MP -MF $(DEPDIR)/os-unix-sysdep.Tpo -c -o os-unix-sysdep.lo `test -f 'runtime/config/$(config_dir)/os-unix-sysdep.c' || echo '$(srcdir)/'`runtime/config/$(config_dir)/os-unix-sysdep.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/os-unix-sysdep.Tpo $(DEPDIR)/os-unix-sysdep.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/config/$(config_dir)/os-unix-sysdep.c' object='os-unix-sysdep.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o os-unix-sysdep.lo `test -f 'runtime/config/$(config_dir)/os-unix-sysdep.c' || echo '$(srcdir)/'`runtime/config/$(config_dir)/os-unix-sysdep.c\n+\n+cilk-abi.lo: runtime/cilk-abi.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cilk-abi.lo -MD -MP -MF $(DEPDIR)/cilk-abi.Tpo -c -o cilk-abi.lo `test -f 'runtime/cilk-abi.c' || echo '$(srcdir)/'`runtime/cilk-abi.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cilk-abi.Tpo $(DEPDIR)/cilk-abi.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/cilk-abi.c' object='cilk-abi.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cilk-abi.lo `test -f 'runtime/cilk-abi.c' || echo '$(srcdir)/'`runtime/cilk-abi.c\n+\n+cilk-abi-vla-internal.lo: runtime/cilk-abi-vla-internal.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cilk-abi-vla-internal.lo -MD -MP -MF $(DEPDIR)/cilk-abi-vla-internal.Tpo -c -o cilk-abi-vla-internal.lo `test -f 'runtime/cilk-abi-vla-internal.c' || echo '$(srcdir)/'`runtime/cilk-abi-vla-internal.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cilk-abi-vla-internal.Tpo $(DEPDIR)/cilk-abi-vla-internal.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/cilk-abi-vla-internal.c' object='cilk-abi-vla-internal.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cilk-abi-vla-internal.lo `test -f 'runtime/cilk-abi-vla-internal.c' || echo '$(srcdir)/'`runtime/cilk-abi-vla-internal.c\n+\n+cilk_api.lo: runtime/cilk_api.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cilk_api.lo -MD -MP -MF $(DEPDIR)/cilk_api.Tpo -c -o cilk_api.lo `test -f 'runtime/cilk_api.c' || echo '$(srcdir)/'`runtime/cilk_api.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cilk_api.Tpo $(DEPDIR)/cilk_api.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/cilk_api.c' object='cilk_api.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cilk_api.lo `test -f 'runtime/cilk_api.c' || echo '$(srcdir)/'`runtime/cilk_api.c\n+\n+cilk_malloc.lo: runtime/cilk_malloc.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cilk_malloc.lo -MD -MP -MF $(DEPDIR)/cilk_malloc.Tpo -c -o cilk_malloc.lo `test -f 'runtime/cilk_malloc.c' || echo '$(srcdir)/'`runtime/cilk_malloc.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cilk_malloc.Tpo $(DEPDIR)/cilk_malloc.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/cilk_malloc.c' object='cilk_malloc.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cilk_malloc.lo `test -f 'runtime/cilk_malloc.c' || echo '$(srcdir)/'`runtime/cilk_malloc.c\n+\n+c_reducers.lo: runtime/c_reducers.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT c_reducers.lo -MD -MP -MF $(DEPDIR)/c_reducers.Tpo -c -o c_reducers.lo `test -f 'runtime/c_reducers.c' || echo '$(srcdir)/'`runtime/c_reducers.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/c_reducers.Tpo $(DEPDIR)/c_reducers.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/c_reducers.c' object='c_reducers.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o c_reducers.lo `test -f 'runtime/c_reducers.c' || echo '$(srcdir)/'`runtime/c_reducers.c\n+\n+frame_malloc.lo: runtime/frame_malloc.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT frame_malloc.lo -MD -MP -MF $(DEPDIR)/frame_malloc.Tpo -c -o frame_malloc.lo `test -f 'runtime/frame_malloc.c' || echo '$(srcdir)/'`runtime/frame_malloc.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/frame_malloc.Tpo $(DEPDIR)/frame_malloc.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/frame_malloc.c' object='frame_malloc.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o frame_malloc.lo `test -f 'runtime/frame_malloc.c' || echo '$(srcdir)/'`runtime/frame_malloc.c\n+\n+full_frame.lo: runtime/full_frame.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT full_frame.lo -MD -MP -MF $(DEPDIR)/full_frame.Tpo -c -o full_frame.lo `test -f 'runtime/full_frame.c' || echo '$(srcdir)/'`runtime/full_frame.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/full_frame.Tpo $(DEPDIR)/full_frame.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/full_frame.c' object='full_frame.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o full_frame.lo `test -f 'runtime/full_frame.c' || echo '$(srcdir)/'`runtime/full_frame.c\n+\n+jmpbuf.lo: runtime/jmpbuf.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT jmpbuf.lo -MD -MP -MF $(DEPDIR)/jmpbuf.Tpo -c -o jmpbuf.lo `test -f 'runtime/jmpbuf.c' || echo '$(srcdir)/'`runtime/jmpbuf.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/jmpbuf.Tpo $(DEPDIR)/jmpbuf.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/jmpbuf.c' object='jmpbuf.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o jmpbuf.lo `test -f 'runtime/jmpbuf.c' || echo '$(srcdir)/'`runtime/jmpbuf.c\n+\n+local_state.lo: runtime/local_state.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT local_state.lo -MD -MP -MF $(DEPDIR)/local_state.Tpo -c -o local_state.lo `test -f 'runtime/local_state.c' || echo '$(srcdir)/'`runtime/local_state.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/local_state.Tpo $(DEPDIR)/local_state.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/local_state.c' object='local_state.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o local_state.lo `test -f 'runtime/local_state.c' || echo '$(srcdir)/'`runtime/local_state.c\n+\n+metacall_impl.lo: runtime/metacall_impl.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT metacall_impl.lo -MD -MP -MF $(DEPDIR)/metacall_impl.Tpo -c -o metacall_impl.lo `test -f 'runtime/metacall_impl.c' || echo '$(srcdir)/'`runtime/metacall_impl.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/metacall_impl.Tpo $(DEPDIR)/metacall_impl.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/metacall_impl.c' object='metacall_impl.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o metacall_impl.lo `test -f 'runtime/metacall_impl.c' || echo '$(srcdir)/'`runtime/metacall_impl.c\n+\n+os_mutex-unix.lo: runtime/os_mutex-unix.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT os_mutex-unix.lo -MD -MP -MF $(DEPDIR)/os_mutex-unix.Tpo -c -o os_mutex-unix.lo `test -f 'runtime/os_mutex-unix.c' || echo '$(srcdir)/'`runtime/os_mutex-unix.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/os_mutex-unix.Tpo $(DEPDIR)/os_mutex-unix.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/os_mutex-unix.c' object='os_mutex-unix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o os_mutex-unix.lo `test -f 'runtime/os_mutex-unix.c' || echo '$(srcdir)/'`runtime/os_mutex-unix.c\n+\n+os-unix.lo: runtime/os-unix.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT os-unix.lo -MD -MP -MF $(DEPDIR)/os-unix.Tpo -c -o os-unix.lo `test -f 'runtime/os-unix.c' || echo '$(srcdir)/'`runtime/os-unix.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/os-unix.Tpo $(DEPDIR)/os-unix.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/os-unix.c' object='os-unix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o os-unix.lo `test -f 'runtime/os-unix.c' || echo '$(srcdir)/'`runtime/os-unix.c\n+\n+pedigrees.lo: runtime/pedigrees.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pedigrees.lo -MD -MP -MF $(DEPDIR)/pedigrees.Tpo -c -o pedigrees.lo `test -f 'runtime/pedigrees.c' || echo '$(srcdir)/'`runtime/pedigrees.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/pedigrees.Tpo $(DEPDIR)/pedigrees.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/pedigrees.c' object='pedigrees.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pedigrees.lo `test -f 'runtime/pedigrees.c' || echo '$(srcdir)/'`runtime/pedigrees.c\n+\n+scheduler.lo: runtime/scheduler.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT scheduler.lo -MD -MP -MF $(DEPDIR)/scheduler.Tpo -c -o scheduler.lo `test -f 'runtime/scheduler.c' || echo '$(srcdir)/'`runtime/scheduler.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/scheduler.Tpo $(DEPDIR)/scheduler.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/scheduler.c' object='scheduler.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o scheduler.lo `test -f 'runtime/scheduler.c' || echo '$(srcdir)/'`runtime/scheduler.c\n+\n+signal_node.lo: runtime/signal_node.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT signal_node.lo -MD -MP -MF $(DEPDIR)/signal_node.Tpo -c -o signal_node.lo `test -f 'runtime/signal_node.c' || echo '$(srcdir)/'`runtime/signal_node.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/signal_node.Tpo $(DEPDIR)/signal_node.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/signal_node.c' object='signal_node.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o signal_node.lo `test -f 'runtime/signal_node.c' || echo '$(srcdir)/'`runtime/signal_node.c\n+\n+spin_mutex.lo: runtime/spin_mutex.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spin_mutex.lo -MD -MP -MF $(DEPDIR)/spin_mutex.Tpo -c -o spin_mutex.lo `test -f 'runtime/spin_mutex.c' || echo '$(srcdir)/'`runtime/spin_mutex.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/spin_mutex.Tpo $(DEPDIR)/spin_mutex.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/spin_mutex.c' object='spin_mutex.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spin_mutex.lo `test -f 'runtime/spin_mutex.c' || echo '$(srcdir)/'`runtime/spin_mutex.c\n+\n+stats.lo: runtime/stats.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT stats.lo -MD -MP -MF $(DEPDIR)/stats.Tpo -c -o stats.lo `test -f 'runtime/stats.c' || echo '$(srcdir)/'`runtime/stats.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/stats.Tpo $(DEPDIR)/stats.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/stats.c' object='stats.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o stats.lo `test -f 'runtime/stats.c' || echo '$(srcdir)/'`runtime/stats.c\n+\n+symbol_test.lo: runtime/symbol_test.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT symbol_test.lo -MD -MP -MF $(DEPDIR)/symbol_test.Tpo -c -o symbol_test.lo `test -f 'runtime/symbol_test.c' || echo '$(srcdir)/'`runtime/symbol_test.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/symbol_test.Tpo $(DEPDIR)/symbol_test.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/symbol_test.c' object='symbol_test.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o symbol_test.lo `test -f 'runtime/symbol_test.c' || echo '$(srcdir)/'`runtime/symbol_test.c\n+\n+sysdep-unix.lo: runtime/sysdep-unix.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sysdep-unix.lo -MD -MP -MF $(DEPDIR)/sysdep-unix.Tpo -c -o sysdep-unix.lo `test -f 'runtime/sysdep-unix.c' || echo '$(srcdir)/'`runtime/sysdep-unix.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/sysdep-unix.Tpo $(DEPDIR)/sysdep-unix.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/sysdep-unix.c' object='sysdep-unix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sysdep-unix.lo `test -f 'runtime/sysdep-unix.c' || echo '$(srcdir)/'`runtime/sysdep-unix.c\n+\n+worker_mutex.lo: runtime/worker_mutex.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT worker_mutex.lo -MD -MP -MF $(DEPDIR)/worker_mutex.Tpo -c -o worker_mutex.lo `test -f 'runtime/worker_mutex.c' || echo '$(srcdir)/'`runtime/worker_mutex.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/worker_mutex.Tpo $(DEPDIR)/worker_mutex.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/worker_mutex.c' object='worker_mutex.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o worker_mutex.lo `test -f 'runtime/worker_mutex.c' || echo '$(srcdir)/'`runtime/worker_mutex.c\n+\n+.cpp.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cpp.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cpp.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+bug.lo: runtime/bug.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT bug.lo -MD -MP -MF $(DEPDIR)/bug.Tpo -c -o bug.lo `test -f 'runtime/bug.cpp' || echo '$(srcdir)/'`runtime/bug.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/bug.Tpo $(DEPDIR)/bug.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/bug.cpp' object='bug.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o bug.lo `test -f 'runtime/bug.cpp' || echo '$(srcdir)/'`runtime/bug.cpp\n+\n+cilk-abi-cilk-for.lo: runtime/cilk-abi-cilk-for.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT cilk-abi-cilk-for.lo -MD -MP -MF $(DEPDIR)/cilk-abi-cilk-for.Tpo -c -o cilk-abi-cilk-for.lo `test -f 'runtime/cilk-abi-cilk-for.cpp' || echo '$(srcdir)/'`runtime/cilk-abi-cilk-for.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/cilk-abi-cilk-for.Tpo $(DEPDIR)/cilk-abi-cilk-for.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/cilk-abi-cilk-for.cpp' object='cilk-abi-cilk-for.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o cilk-abi-cilk-for.lo `test -f 'runtime/cilk-abi-cilk-for.cpp' || echo '$(srcdir)/'`runtime/cilk-abi-cilk-for.cpp\n+\n+cilk_fiber.lo: runtime/cilk_fiber.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT cilk_fiber.lo -MD -MP -MF $(DEPDIR)/cilk_fiber.Tpo -c -o cilk_fiber.lo `test -f 'runtime/cilk_fiber.cpp' || echo '$(srcdir)/'`runtime/cilk_fiber.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/cilk_fiber.Tpo $(DEPDIR)/cilk_fiber.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/cilk_fiber.cpp' object='cilk_fiber.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o cilk_fiber.lo `test -f 'runtime/cilk_fiber.cpp' || echo '$(srcdir)/'`runtime/cilk_fiber.cpp\n+\n+cilk_fiber-unix.lo: runtime/cilk_fiber-unix.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT cilk_fiber-unix.lo -MD -MP -MF $(DEPDIR)/cilk_fiber-unix.Tpo -c -o cilk_fiber-unix.lo `test -f 'runtime/cilk_fiber-unix.cpp' || echo '$(srcdir)/'`runtime/cilk_fiber-unix.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/cilk_fiber-unix.Tpo $(DEPDIR)/cilk_fiber-unix.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/cilk_fiber-unix.cpp' object='cilk_fiber-unix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o cilk_fiber-unix.lo `test -f 'runtime/cilk_fiber-unix.cpp' || echo '$(srcdir)/'`runtime/cilk_fiber-unix.cpp\n+\n+except-gcc.lo: runtime/except-gcc.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT except-gcc.lo -MD -MP -MF $(DEPDIR)/except-gcc.Tpo -c -o except-gcc.lo `test -f 'runtime/except-gcc.cpp' || echo '$(srcdir)/'`runtime/except-gcc.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/except-gcc.Tpo $(DEPDIR)/except-gcc.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/except-gcc.cpp' object='except-gcc.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o except-gcc.lo `test -f 'runtime/except-gcc.cpp' || echo '$(srcdir)/'`runtime/except-gcc.cpp\n+\n+global_state.lo: runtime/global_state.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT global_state.lo -MD -MP -MF $(DEPDIR)/global_state.Tpo -c -o global_state.lo `test -f 'runtime/global_state.cpp' || echo '$(srcdir)/'`runtime/global_state.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/global_state.Tpo $(DEPDIR)/global_state.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/global_state.cpp' object='global_state.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o global_state.lo `test -f 'runtime/global_state.cpp' || echo '$(srcdir)/'`runtime/global_state.cpp\n+\n+record-replay.lo: runtime/record-replay.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT record-replay.lo -MD -MP -MF $(DEPDIR)/record-replay.Tpo -c -o record-replay.lo `test -f 'runtime/record-replay.cpp' || echo '$(srcdir)/'`runtime/record-replay.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/record-replay.Tpo $(DEPDIR)/record-replay.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/record-replay.cpp' object='record-replay.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o record-replay.lo `test -f 'runtime/record-replay.cpp' || echo '$(srcdir)/'`runtime/record-replay.cpp\n+\n+reducer_impl.lo: runtime/reducer_impl.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT reducer_impl.lo -MD -MP -MF $(DEPDIR)/reducer_impl.Tpo -c -o reducer_impl.lo `test -f 'runtime/reducer_impl.cpp' || echo '$(srcdir)/'`runtime/reducer_impl.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/reducer_impl.Tpo $(DEPDIR)/reducer_impl.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/reducer_impl.cpp' object='reducer_impl.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o reducer_impl.lo `test -f 'runtime/reducer_impl.cpp' || echo '$(srcdir)/'`runtime/reducer_impl.cpp\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+install-cilkincludeHEADERS: $(cilkinclude_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(cilkincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(cilkincludedir)\"\n+\t@list='$(cilkinclude_HEADERS)'; test -n \"$(cilkincludedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(cilkincludedir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(cilkincludedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-cilkincludeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(cilkinclude_HEADERS)'; test -n \"$(cilkincludedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(cilkincludedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(cilkincludedir)\" && rm -f $$files\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS)\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(cilkincludedir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am clean-multi\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am distclean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-libtool distclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am: install-cilkincludeHEADERS\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am maintainer-clean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am mostlyclean-multi\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-cilkincludeHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: all-multi clean-multi distclean-multi install-am install-multi \\\n+\tinstall-strip maintainer-clean-multi mostlyclean-multi\n+\n+.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \\\n+\tclean clean-generic clean-libtool clean-multi \\\n+\tclean-toolexeclibLTLIBRARIES ctags distclean distclean-compile \\\n+\tdistclean-generic distclean-libtool distclean-multi \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-cilkincludeHEADERS install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-multi install-pdf \\\n+\tinstall-pdf-am install-ps install-ps-am install-strip \\\n+\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n+\tinstalldirs maintainer-clean maintainer-clean-generic \\\n+\tmaintainer-clean-multi mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool mostlyclean-multi pdf \\\n+\tpdf-am ps ps-am tags uninstall uninstall-am \\\n+\tuninstall-cilkincludeHEADERS uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "7c101150ece98a3657a89d1c231ddb302ba360a7", "filename": "libcilkrts/README", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FREADME?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,84 @@\n+Intel(R) Cilk(TM) Plus runtime library\n+\n+Index:\n+1. BUILDING\n+2. USING\n+3. DOXYGEN DOCUMENTATION\n+4. QUESTIONS OR BUGS\n+5. CONTRIBUTIONS\n+\n+#\n+#  1. BUILDING:\n+#\n+\n+To distribute applications that use the Intel Cilk Plus language\n+extensions to non-development systems, you need to build the Intel\n+Cilk Plus runtime library and distribute it with your application.\n+\n+To build the libcilkrts.so runtime library component, you need the\n+autoconf and automake packages, which are available through your\n+favorite package manager.  You also need a C/C++ compiler that\n+supports the Intel Cilk Plus language extensions, since the runtime\n+uses Intel Cilk Plus features internally.  Use either the Intel(R)\n+C++ Compiler (icc command) v12.1 or later, or in GCC 4.9 or later\n+(gcc command).\n+\n+Once you have the necessary prerequisites installed, you can use the\n+following commands to create the library:\n+\n+% libtoolize\n+% aclocal\n+% automake --add-missing\n+% autoconf\n+% ./configure\n+% make\n+% make install\n+\n+This will produce the libcilkrts.so shared object.  To install the\n+library in a custom location, set the prefix while running the\n+configure script:\n+\n+% ./configure --prefix=/your/path/to/lib\n+\n+#\n+#  2. USING:\n+#\n+\n+The Intel(R) C++ Compiler will automatically try to bring in the\n+Intel Cilk Plus runtime in any program that uses the relevant\n+features.  GCC requires explicit linking of both the library and\n+its dependencies (libpthread, libdl).  For example:\n+\n+% gcc foo.c -lcilkrts -lpthread -ldl\n+\n+#\n+#  3. DOXYGEN DOCUMENTATION:\n+#\n+\n+The library source has Doxygen markup.  Generate HTML documentation\n+based on the markup by changing directory into runtime and running:\n+\n+% doxygen doxygen.cfg\n+\n+#\n+#  4. QUESTIONS OR BUGS:\n+#\n+\n+Issues with the Intel Cilk Plus runtime can be addressed in the Intel\n+Cilk Plus forums:\n+http://software.intel.com/en-us/forums/intel-cilk-plus/\n+\n+#\n+#  5. CONTRIBUTIONS:\n+#\n+\n+The Intel Cilk Plus runtime library is dual licensed. The upstream copy\n+of the library is maintained via the BSD-licensed version available at:\n+http://cilkplus.org/\n+\n+Changes to the Intel Cilk Plus runtime are welcome and should be\n+contributed to the upstream version via http://cilkplus.org/.\n+\n+------------------------\n+Intel and Cilk are trademarks of Intel Corporation in the U.S. and/or\n+other countries."}, {"sha": "446bedeffa20a2d5319f9825ec54bdc97fbe3c0f", "filename": "libcilkrts/aclocal.m4", "status": "added", "additions": 939, "deletions": 0, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Faclocal.m4?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,939 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"}, {"sha": "18fb408e4a76afec131fee306a78e649d8d0c55d", "filename": "libcilkrts/configure", "status": "added", "additions": 16649, "deletions": 0, "changes": 16649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "9acdc11027e624eb635312f3afffb74b690bddc2", "filename": "libcilkrts/configure.ac", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure.ac?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,148 @@\n+#  @copyright\n+#  Copyright (C) 2011-2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+AC_INIT([Cilk Runtime Library], [2.0], [cilk@intel.com])\n+AC_PREREQ([2.64])\n+\n+# Needed to define ${target}.  Needs to be very early to avoid annoying\n+# warning about calling AC_ARG_PROGRAM before AC_CANONICAL_SYSTEM\n+AC_CANONICAL_SYSTEM\n+AM_INIT_AUTOMAKE(foreign no-dist)\n+\n+# Build a DLL on Windows\n+# AC_LIBTOOL_WIN32_DLL\n+AC_PROG_CXX\n+AC_PROG_CC\n+# AC_PROG_LIBTOOL\n+# AC_CONFIG_MACRO_DIR([..])\n+AC_CONFIG_FILES([Makefile])\n+AM_ENABLE_MULTILIB(, ..)\n+\n+# Get target configury.\n+. ${srcdir}/configure.tgt\n+if test -n \"$UNSUPPORTED\"; then\n+   AC_MSG_ERROR([Configuration ${target} is unsupported.])\n+fi\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+AC_ARG_ENABLE([version-specific-runtime-libs],\n+  AC_HELP_STRING([--enable-version-specific-runtime-libs],\n+                 [Specify that runtime libraries should be installed in a compi\n+ler-specific directory]),\n+  [case \"$enableval\" in\n+    yes) enable_version_specific_runtime_libs=yes ;;\n+    no)  enable_version_specific_runtime_libs=no ;;\n+    *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs\n+]);;\n+   esac],\n+  [enable_version_specific_runtime_libs=no])\n+AC_MSG_RESULT($enable_version_specific_runtime_libs)\n+\n+\n+# Calculate toolexeclibdir\n+# Also toolexecdir, though it's only used in toolexeclibdir\n+case ${enable_version_specific_runtime_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+   toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+\n+# Set config_dir based on the target.  config_dir specifies where to get\n+# target-specific files.  The generic implementation is incomplete, but\n+# contains information on what's needed\n+case \"${target}\" in\n+\n+  x86_64-*-*)\n+    config_dir=\"x86\"\n+    ;;\n+\n+  i[456]86-*-*)\n+    config_dir=\"x86\"\n+    ;;\n+\n+  *)\n+    config_dir=\"generic\"\n+    ;;\n+\n+esac\n+AC_SUBST(config_dir)\n+\n+# We have linker scripts for appropriate operating systems\n+linux_linker_script=no\n+case \"${host}\" in\n+    *-*-linux*)\n+        linux_linker_script=yes\n+        ;;\n+esac\n+AM_CONDITIONAL(LINUX_LINKER_SCRIPT, test \"$linux_linker_script\" = \"yes\")\n+\n+mac_linker_script=no\n+case \"${host}\" in\n+    *-*-apple*)\n+        mac_linker_script=yes\n+        ;;\n+esac\n+AM_CONDITIONAL(MAC_LINKER_SCRIPT, test \"$mac_linker_script\" = \"yes\")\n+\n+AM_PROG_LIBTOOL\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+# Must be last\n+AC_OUTPUT"}, {"sha": "f7663521cda8a776b14b905ae1c0cc21f1136fdf", "filename": "libcilkrts/configure.tgt", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure.tgt?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,61 @@\n+#  @copyright\n+#  Copyright (C) 2011-2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+# Disable Cilk Runtime library for non x86 architecture...for now.\n+case \"${target}\" in\n+  x86_64-*-*)\n+    ;;\n+  i?86-*-*)\n+    ;;\n+  *-*-*)\n+    UNSUPPORTED=1\n+    ;;\n+esac\n+\n+# Disable libcilkrts on non POSIX hosted systems.\n+if test x$enable_libcilkrts = x ; then\n+    # Enable libcilkrts by default on hosted POSIX systems.\n+    case \"${target}\" in\n+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)\n+        ;;\n+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly*)\n+        ;;\n+    *-*-solaris2* | *-*-hpux11*)\n+        ;;\n+    *-*-darwin* | *-*-aix*)\n+        ;;\n+    *)\n+        UNSUPPORTED=1\n+        ;;\n+    esac\n+fi"}, {"sha": "2d0de0d293e411b8031deb68b066d73d2b87e0cb", "filename": "libcilkrts/include/cilk/cilk.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,71 @@\n+/*  cilk.h                  -*-C++-*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2010-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+ \n+/** @file cilk.h\n+ *\n+ *  @brief Provides convenient aliases for the Cilk language keywords.\n+ *\n+ *  @details\n+ *  Since Cilk is a nonstandard extension to both C and C++, the Cilk\n+ *  language keywords all begin with \u201c`_Cilk_`\u201d, which guarantees that they\n+ *  will not conflict with user-defined identifiers in properly written \n+ *  programs, so that \u201cstandard\u201d C and C++ programs can safely be\n+ *  compiled a Cilk-enabled C or C++ compiler.\n+ *\n+ *  However, this means that the keywords _look_ like something grafted on to\n+ *  the base language. Therefore, you can include this header:\n+ *\n+ *      #include \"cilk/cilk.h\"\n+ *\n+ *  and then write the Cilk keywords with a \u201c`cilk_`\u201d prefix instead of\n+ *  \u201c`_Cilk_`\u201d.\n+ *\n+ *  @ingroup language\n+ */\n+ \n+ \n+/** @defgroup language Language Keywords\n+ *  Definitions having to do with the Cilk language.\n+ *  @{\n+ */\n+ \n+#ifndef cilk_spawn\n+# define cilk_spawn _Cilk_spawn ///< Spawn a task that can execute in parallel.\n+# define cilk_sync  _Cilk_sync  ///< Wait for spawned tasks to complete.\n+# define cilk_for   _Cilk_for   ///< Execute iterations of a for loop in parallel.\n+#endif\n+\n+/// @}"}, {"sha": "a21687b7b32992f888a02e56f51f2e4fdb449366", "filename": "libcilkrts/include/cilk/cilk_api.h", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,424 @@\n+/*  cilk_api.h\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+ \n+/** @file cilk_api.h\n+ *\n+ * @brief Defines the documented API exposed by the Cilk Plus for use\n+ * by applications.\n+ *\n+ *  @ingroup api\n+ */\n+ \n+#ifndef INCLUDED_CILK_API_H\n+#define INCLUDED_CILK_API_H\n+\n+/** @defgroup api Runtime API\n+ *  API to allow user programs to interact with the Cilk runtime.\n+ *  @{\n+ */\n+\n+#ifndef CILK_STUB /* Real (non-stub) definitions */\n+\n+#if ! defined(__cilk) && ! defined(USE_CILK_API)\n+#   ifdef _WIN32\n+#       error Cilk API is being used with non-Cilk compiler (or Cilk is disabled)\n+#   else\n+#       warning Cilk API is being used with non-Cilk compiler (or Cilk is disabled)\n+#   endif\n+#endif\n+\n+#include <cilk/common.h>\n+\n+#ifdef __cplusplus\n+#   include <cstddef>  /* Defines size_t */\n+#else\n+#   include <stddef.h> /* Defines size_t */\n+#endif\n+\n+#ifdef _WIN32\n+#   ifndef IN_CILK_RUNTIME\n+/* Ensure the library is brought if any of these functions are being called. */\n+#       pragma comment(lib, \"cilkrts\")\n+#   endif\n+\n+#   ifndef __cplusplus\n+#       include <wchar.h>\n+#   endif\n+#endif /* _WIN32 */\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Return values from __cilkrts_set_param() and __cilkrts_set_param_w() \n+ */\n+enum __cilkrts_set_param_status {\n+    __CILKRTS_SET_PARAM_SUCCESS = 0, /**< Success - parameter set */\n+    __CILKRTS_SET_PARAM_UNIMP   = 1, /**< Unimplemented parameter */\n+    __CILKRTS_SET_PARAM_XRANGE  = 2, /**< Parameter value out of range */\n+    __CILKRTS_SET_PARAM_INVALID = 3, /**< Invalid parameter value */\n+    __CILKRTS_SET_PARAM_LATE    = 4  /**< Too late to change parameter value */\n+};\n+\n+/** Set user controllable runtime parameters\n+ *\n+ *  Call this function to set runtime parameters that control the behavior \n+ *  of the Cilk scheduler.\n+ *\n+ *  @param param    A string specifying the parameter to be set. One of:\n+ *  -   `\"nworkers\"`\n+ *  -   `\"force reduce\"`\n+ *  @param value    A string specifying the parameter value.\n+ *  @returns        A value from the @ref __cilkrts_set_param_status \n+ *                  enumeration indicating the result of the operation.\n+ *\n+ *  @par The \"nworkers\" parameter\n+ *\n+ *  This parameter specifies the number of worker threads to be created by the\n+ *  Cilk runtime. @a Value must be a string of digits to be parsed by \n+ *  `strtol()`.\n+ *\n+ *  The number of worker threads is:\n+ *  1.  the value set with `__cilkrts_set_param(\"nworkers\")`, if it is \n+ *      positive; otherwise,\n+ *  2.  the value of the CILK_NWORKERS environment variable, if it is \n+ *      defined; otherwise\n+ *  3.  the number of cores available, as reported by the operating system.\n+ *\n+ *  @note\n+ *  Technically, Cilk distinguishes between the _user thread_ (the thread that\n+ *  the user code was executing on when the Cilk runtime started), and \n+ *  _worker threads_ (new threads created by the Cilk runtime to support\n+ *  Cilk parallelism). `nworkers` actually includes both the user thread and\n+ *  the worker threads; that is, it is one greater than the number of true\n+ *  \u201cworker threads\u201d.\n+ *\n+ *  @note\n+ *  Setting `nworkers = 1` produces serial behavior. Cilk spawns and syncs will\n+ *  be executed, but with only one worker, continuations will never be stolen,\n+ *  so all code will execute in serial.\n+ *\n+ *  @warning\n+ *  The number of worker threads can only be set *before* the runtime has \n+ *  started. Attempting to set it when the runtime is running will have no \n+ *  effect, and will return an error code. You can call __cilkrts_end_cilk() \n+ *  to shut down the runtime to change the number of workers.\n+ *\n+ *  @warning\n+ *  The default Cilk scheduler behavior is usually pretty good. The ability\n+ *  to override `nworkers` can be useful for experimentation, but it won\u2019t\n+ *  usually be necessary for getting good performance.\n+ *\n+ *  @par The \"force reduce\" parameter\n+ *\n+ *  This parameter controls whether the runtime should allocate a new view\n+ *  for a reducer for every parallel strand that it is accessed on. (See \n+ *  @ref pagereducers.) @a Value must be `\"1\"` or `\"true\"` to enable the \n+ *  \u201cforce reduce\u201d behavior, or `\"0\"` or `\"false\"` to disable it.\n+ *\n+ *  \u201cForce reduce\u201d behavior will also be enabled if \n+ *  `__cilkrts_set_param(\"force reduce\")` is not called, but the\n+ *  `CILK_FORCE_REDUCE` environment variable is defined.\n+ *\n+ *  @warning\n+ *  When this option is enabled, `nworkers` should be set to `1`. Using \u201cforce\n+ *  reduce\u201d with more than one worker may result in runtime errors.\n+ *  \n+ *  @warning\n+ *  Enabling this option can significantly reduce performance. It should\n+ *  _only_ be used as a debugging tool.\n+ */\n+CILK_API(int) __cilkrts_set_param(const char *param, const char *value);\n+\n+#ifdef _WIN32\n+/**\n+ * Set user controllable parameters using wide strings\n+ *\n+ * @note This variant of __cilkrts_set_param() is only available\n+ * on Windows.\n+ *\n+ * @copydetails __cilkrts_set_param\n+ */\n+CILK_API(int) __cilkrts_set_param_w(const wchar_t *param, const wchar_t *value);\n+#endif\n+\n+/** Shut down and deallocate all Cilk state.  The runtime will abort the\n+ *  application if Cilk is still in use by this thread.  Otherwise the runtime\n+ *  will wait for all other threads using Cilk to exit.\n+ */\n+CILK_API(void) __cilkrts_end_cilk(void);\n+\n+/** Initialize the Cilk data structures and start the runtime.\n+ */\n+CILK_API(void) __cilkrts_init(void);\n+\n+/** Return the runtime `nworkers` parameter. (See the discussion of `nworkers`\n+ *  in the documentation for __cilkrts_set_param().)\n+ */\n+CILK_API(int) __cilkrts_get_nworkers(void);\n+\n+/** Return the number of thread data structures.\n+ *\n+ *  This function returns the number of data structures that has been allocated \n+ *  allocated by the runtime to hold information about user and worker threads.\n+ *\n+ *  If you don\u2019t already know what this is good for, then you probably don\u2019t\n+ *  need it.\n+ */\n+CILK_API(int) __cilkrts_get_total_workers(void);\n+\n+/** What thread is the function running on?\n+ *\n+ *  Return a small integer identifying the current thread. Each worker thread\n+ *  started by the Cilk runtime library has a unique worker number in the range \n+ *  `1 .. nworkers - 1`.\n+ *\n+ *  All _user_ threads (threads started by the user, or by other libraries) are\n+ *  identified as worker number 0. Therefore, the worker number is not unique\n+ *  across multiple user threads.\n+ */\n+CILK_API(int) __cilkrts_get_worker_number(void);\n+\n+/** Test whether \u201cforce reduce\u201d behavior is enabled.\n+ *  \n+ *  @return Non-zero if force-reduce mode is on, zero if it is off.\n+ */\n+CILK_API(int) __cilkrts_get_force_reduce(void);\n+\n+/** Interact with tools\n+ */\n+CILK_API(void)\n+    __cilkrts_metacall(unsigned int tool, unsigned int code, void *data);\n+\n+#ifdef _WIN32\n+/// Windows exception description record.\n+typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD;\n+\n+/** Function signature for Windows exception notification callbacks.\n+ */\n+typedef void (*__cilkrts_pfn_seh_callback)(const _EXCEPTION_RECORD *exception);\n+\n+/** Specify a function to call when a non-C++ exception is caught.\n+ *\n+ *  Cilk Plus parallelism plays nicely with C++ exception handling, but the \n+ *  Cilk Plus runtime has no way to unwind the stack across a strand boundary \n+ *  for Microsoft SEH (\u201cStructured Exception Handling\u201d) exceptions. Therefore, \n+ *  when the runtime catches such an exception, it must abort the application.\n+ *\n+ *  If an SEH callback has been set, the runtime will call it before aborting.\n+ *\n+ *  @param  pfn A pointer to a callback function to be called before the\n+ *              runtime aborts the program because of an SEH exception.\n+ */\n+CILK_API(int) __cilkrts_set_seh_callback(__cilkrts_pfn_seh_callback pfn);\n+#endif /* _WIN32 */\n+\n+#if __CILKRTS_ABI_VERSION >= 1\n+/* Pedigree API is available only for compilers that use ABI version >= 1. */\n+\n+\n+/** @name Pedigrees\n+ */\n+//@{\n+\n+// @cond internal\n+\n+/** Support for __cilkrts_get_pedigree.\n+ */\n+CILK_API(__cilkrts_pedigree)\n+__cilkrts_get_pedigree_internal(__cilkrts_worker *w);\n+\n+/** Support for __cilkrts_bump_worker_rank.\n+ */\n+CILK_API(int)\n+__cilkrts_bump_worker_rank_internal(__cilkrts_worker* w);\n+\n+/// @endcond\n+\n+\n+/** Get the current pedigree, in a linked list representation.\n+ *\n+ *  This routine returns a copy of the last node in the pedigree list.\n+ *  For example, if the current pedigree (in order) is <1, 2, 3, 4>,\n+ *  then this method returns a node with rank == 4, and whose parent\n+ *  field points to the node with rank of 3.  In summary, following the\n+ *  nodes in the chain visits the terms of the pedigree in reverse.\n+ * \n+ *  The returned node is guaranteed to be valid only until the caller\n+ *  of this routine has returned.\n+ */\n+__CILKRTS_INLINE\n+__cilkrts_pedigree __cilkrts_get_pedigree(void) \n+{\n+    return __cilkrts_get_pedigree_internal(__cilkrts_get_tls_worker());    \n+}\n+\n+/** Context used by __cilkrts_get_pedigree_info.\n+ *\n+ *  @deprecated\n+ *  This data structure is only used by the deprecated \n+ *  __cilkrts_get_pedigree_info function.\n+ *\n+ *  Callers should initialize the `data` array to NULL and set the `size`\n+ *  field to `sizeof(__cilkrts_pedigree_context_t)` before the first call\n+ *  to __cilkrts_get_pedigree_info(), and should not examine or modify it\n+ *  thereafter.\n+ */\n+typedef struct\n+{\n+    __STDNS size_t size;    /**< Size of the struct in bytes */\n+    void *data[3];          /**< Opaque context data */\n+} __cilkrts_pedigree_context_t;\n+\n+/** Get pedigree information.\n+ *\n+ *  @deprecated\n+ *  Use __cilkrts_get_pedigree() instead.\n+ *\n+ *  This routine allows code to walk up the stack of Cilk frames to gather\n+ *  the pedigree.\n+ *\n+ *  Initialize the pedigree walk by filling the pedigree context with NULLs\n+ *  and setting the size field to sizeof(__cilkrts_pedigree_context).\n+ *  Other than initialization to NULL to start the walk, user coder should\n+ *  consider the pedigree context data opaque and should not examine or\n+ *  modify it.\n+ *\n+ * @returns  0 - Success - birthrank is valid\n+ * @returns >0 - End of pedigree walk\n+ * @returns -1 - Failure - No worker bound to thread\n+ * @returns -2 - Failure - Sanity check failed,\n+ * @returns -3 - Failure - Invalid context size\n+ * @returns -4 - Failure - Internal error - walked off end of chain of frames\n+ */\n+CILK_API(int)\n+__cilkrts_get_pedigree_info(/* In/Out */ __cilkrts_pedigree_context_t *context,\n+                            /* Out */    uint64_t *sf_birthrank);\n+\n+/** Get the rank of the currently executing worker.\n+ *\n+ *  @deprecated\n+ *  Use `__cilkrts_get_pedigree().rank` instead.\n+ *\n+ * @returns  0 - Success - *rank is valid\n+ * @returns <0 - Failure - *rank is not changed\n+ */\n+CILK_EXPORT_AND_INLINE\n+int __cilkrts_get_worker_rank(uint64_t *rank) \n+{\n+    *rank = __cilkrts_get_pedigree().rank;\n+    return 0;\n+}\n+\n+/** Increment the pedigree rank of the currently executing worker.\n+ *\n+ * @returns 0 - Success - rank was incremented\n+ * @returns-1 - Failure\n+ */\n+CILK_EXPORT_AND_INLINE\n+int __cilkrts_bump_worker_rank(void)\n+{\n+    return __cilkrts_bump_worker_rank_internal(__cilkrts_get_tls_worker());\n+}\n+\n+/** Increment the pedigree rank for a cilk_for loop. \n+ *  Obsolete.\n+ *\n+ *  @deprecated\n+ *  This function was provided to allow the user to manipulate the pedigree\n+ *  rank of a `cilk_for` loop. The compiler now generates code to do that\n+ *  manipulation automatically, so this function is now unnecessary. It may\n+ *  be called, but will have no effect.\n+ */\n+CILK_EXPORT_AND_INLINE\n+int __cilkrts_bump_loop_rank(void) \n+{\n+    return 0;\n+}\n+\n+//@}\n+\n+#endif /* __CILKRTS_ABI_VERSION >= 1 */\n+\n+__CILKRTS_END_EXTERN_C\n+\n+#else /* CILK_STUB */\n+\n+// Programs compiled with CILK_STUB are not linked with the Cilk runtime \n+// library, so they should not have external references to runtime functions.\n+// Therefore, the functions are replaced with stubs.\n+\n+#ifdef _WIN32\n+#define __cilkrts_set_param_w(name,value) ((value), 0)\n+#define __cilkrts_set_seh_callback(pfn) (0)\n+#endif\n+#define __cilkrts_set_param(name,value) ((value), 0)\n+#define __cilkrts_end_cilk() ((void) 0)\n+#define __cilkrts_init() ((void) 0)\n+#define __cilkrts_get_nworkers() (1)\n+#define __cilkrts_get_total_workers() (1)\n+#define __cilkrts_get_worker_number() (0)\n+#define __cilkrts_get_force_reduce() (0)\n+#define __cilkrts_metacall(tool,code,data) ((tool), (code), (data), 0)\n+\n+#if __CILKRTS_ABI_VERSION >= 1\n+/* Pedigree stubs */\n+#define __cilkrts_get_pedigree_info(context, sf_birthrank) (-1)\n+#define __cilkrts_get_worker_rank(rank) (*(rank) = 0)\n+#define __cilkrts_bump_worker_rank() (-1)\n+#define __cilkrts_bump_loop_rank() (-1)\n+\n+/*\n+ * A stub method for __cilkrts_get_pedigree.\n+ * Returns an empty __cilkrts_pedigree. \n+ */ \n+__CILKRTS_INLINE\n+__cilkrts_pedigree __cilkrts_get_pedigree_stub(void)\n+{\n+    __cilkrts_pedigree ans;\n+    ans.rank = 0;\n+    ans.parent = NULL;\n+    return ans;\n+}\n+\n+/* Renamed to an actual stub method. */\n+#define __cilkrts_get_pedigree() __cilkrts_get_pedigree_stub()\n+\n+#endif /* __CILKRTS_ABI_VERSION >= 1 */\n+\n+#endif /* CILK_STUB */\n+\n+//@}\n+\n+#endif /* INCLUDED_CILK_API_H */"}, {"sha": "ed9e70635f62df6359201bd40839e965833f95ea", "filename": "libcilkrts/include/cilk/cilk_api_linux.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,38 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+/* THIS FILE IS DEPRECATED.  USE cilk_api.h INSTEAD. */\n+#include <cilk/cilk_api.h>"}, {"sha": "116e3ff55419cf12b0972ed00f5a1213489d22a4", "filename": "libcilkrts/include/cilk/cilk_stub.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,55 @@\n+/*  cilk_stub.h                  -*-C++-*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+#ifndef INCLUDED_CILK_STUB_DOT_H\n+#define INCLUDED_CILK_STUB_DOT_H\n+\n+/* Definitions for creating a serialization from a Cilk program.\n+ * These definitions are suitable for use by a compiler that is not\n+ * Cilk-enabled.\n+ */\n+\n+/* Pretend we are a non-Cilk compiler */\n+#undef __cilk\n+#define CILK_STUB\n+\n+/* Replace Cilk keywords with serial equivalents */\n+#define _Cilk_spawn\n+#define _Cilk_sync\n+#define _Cilk_for for\n+\n+#endif /* ! defined(INCLUDED_CILK_STUB_DOT_H) */"}, {"sha": "81cdd64bb8907fef2f62ca5d9d38acba67f72b31", "filename": "libcilkrts/include/cilk/cilk_undocumented.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,131 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ******************************************************************************\n+ *\n+ * cilk_undocumented.h\n+ *\n+ * This file defines exported functions that are not included in the standard\n+ * documentation.\n+ */\n+\n+#ifndef INCLUDED_CILK_UNDOCUMENTED_H\n+#define INCLUDED_CILK_UNDOCUMENTED_H\n+\n+#include <cilk/common.h>\n+\n+#ifndef CILK_STUB\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/*\n+ * __cilkrts_synched\n+ *\n+ * Allows an application to determine if there are any outstanding children at\n+ * this instant. This function will examine the current full frame to\n+ * determine this. This function will return a valid result only when called\n+ * within a spawn continuation, within the stack frame of the continuation\n+ * itself.\n+ */\n+\n+CILK_EXPORT __CILKRTS_NOTHROW\n+int __cilkrts_synched(void);\n+\n+/*\n+ * __cilkrts_cilkscreen_puts\n+ *\n+ * Allows an application to write a string to the Cilkscreen log.\n+ * The standard error stream will be flushed after the write.\n+ */\n+\n+CILK_EXPORT __CILKRTS_NOTHROW\n+void __cilkrts_cilkscreen_puts(const char *);\n+\n+/*\n+ * __cilkrts_get_sf\n+ *\n+ * A debugging aid that allows an application to get the __cilkrts_stack_frame\n+ * for the current function.  Only compiled into the DLL in debug builds.\n+ */\n+\n+CILK_EXPORT __CILKRTS_NOTHROW\n+void *__cilkrts_get_sf(void);\n+\n+/**\n+ * Returns the size of stacks created by Cilk.\n+ */\n+CILK_EXPORT __CILKRTS_NOTHROW\n+size_t __cilkrts_get_stack_size(void);\n+\n+/** \n+ * Dumps runtime statistics to stderr.\n+ * Undocumented API for debugging. \n+ */\n+CILK_EXPORT __CILKRTS_NOTHROW\n+void __cilkrts_dump_stats(void);\n+\n+CILK_EXPORT __CILKRTS_NOTHROW\n+int __cilkrts_irml_version(void);\n+\n+struct __cilk_tbb_unwatch_thunk;\n+struct __cilk_tbb_stack_op_thunk;\n+\n+CILK_EXPORT __CILKRTS_NOTHROW\n+int __cilkrts_watch_stack(struct __cilk_tbb_unwatch_thunk *u,\n+                          struct __cilk_tbb_stack_op_thunk o);\n+\n+#ifndef IN_CILK_RUNTIME\n+#ifdef _WIN32\n+/* Do not use CILK_API because __cilkrts_worker_stub must be __stdcall */\n+CILK_EXPORT unsigned __CILKRTS_NOTHROW __stdcall\n+__cilkrts_worker_stub(void *arg);\n+#else\n+/* Do not use CILK_API because __cilkrts_worker_stub have default visibility */\n+CILK_EXPORT void* __CILKRTS_NOTHROW\n+__cilkrts_worker_stub(void *arg);\n+#endif /* _WIN32 */\n+#endif /* IN_CILK_RUNTIME */\n+\n+__CILKRTS_END_EXTERN_C\n+\n+#else /* CILK_STUB */\n+\n+/* Stubs for the api functions */\n+\n+#define __cilkrts_get_stack_size() (0)\n+#define __cilkrts_synched() (1)\n+\n+#endif /* CILK_STUB */\n+\n+#endif /* INCLUDED_CILK_UNDOCUMENTED_H */"}, {"sha": "8ec19afa9222e88ea3ddc8374016d79659981647", "filename": "libcilkrts/include/cilk/common.h", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcommon.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,376 @@\n+/** common.h\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2010-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+ \n+/** @file common.h\n+ *\n+ * @brief Defines common macros and structures used by the Intel Cilk Plus\n+ * runtime.\n+ *\n+ *  @ingroup common\n+ */\n+\n+/** @defgroup common Common Definitions\n+ *  Macro, structure, and class definitions used elsewhere in the runtime.\n+ *  @{\n+ */\n+ \n+#ifndef INCLUDED_CILK_COMMON\n+#define INCLUDED_CILK_COMMON\n+\n+#ifdef __cplusplus\n+/** Namespace for all Cilk definitions that can be included in user code.\n+ */\n+namespace cilk {\n+    \n+    /** Namespace for definitions that are primarily intended for use\n+     *  in other Cilk definitions.\n+     */\n+    namespace internal {}\n+}\n+#endif\n+\n+/** Cilk library version = 1.01\n+ */\n+#define CILK_LIBRARY_VERSION 102\n+\n+#ifdef __cplusplus\n+#   include <cassert>\n+#else\n+#   include <assert.h>\n+#endif\n+\n+/**\n+ * Prefix standard library function and type names with __STDNS in order to\n+ * get correct lookup in both C and C++.\n+ */\n+#ifdef __cplusplus\n+#   define __STDNS std::\n+#else\n+#   define __STDNS\n+#endif\n+\n+/**\n+ * @def CILK_EXPORT\n+ * Define export of runtime functions from shared library.\n+ * Should be exported only from cilkrts*.dll/cilkrts*.so\n+ * @def CILK_EXPORT_DATA\n+ * Define export of runtime data from shared library.\n+ */\n+#ifdef _WIN32\n+#   ifdef IN_CILK_RUNTIME\n+#       define CILK_EXPORT      __declspec(dllexport)\n+#       define CILK_EXPORT_DATA __declspec(dllexport)\n+#   else\n+#       define CILK_EXPORT      __declspec(dllimport)\n+#       define CILK_EXPORT_DATA __declspec(dllimport)\n+#   endif  /* IN_CILK_RUNTIME */\n+#elif defined(__CYGWIN__) || defined(__APPLE__) || defined(_DARWIN_C_SOURCE)\n+#   define CILK_EXPORT      /* nothing */\n+#   define CILK_EXPORT_DATA /* nothing */\n+#else /* Unix/gcc */\n+#   ifdef IN_CILK_RUNTIME\n+#       define CILK_EXPORT      __attribute__((visibility(\"protected\")))\n+#       define CILK_EXPORT_DATA __attribute__((visibility(\"protected\")))\n+#   else\n+#       define CILK_EXPORT      /* nothing */\n+#       define CILK_EXPORT_DATA /* nothing */\n+#   endif  /* IN_CILK_RUNTIME */\n+#endif /* Unix/gcc */\n+\n+/**\n+ * @def __CILKRTS_BEGIN_EXTERN_C\n+ * Macro to denote the start of a section in which all names have \"C\" linkage.\n+ * That is, none of the names are to be mangled.\n+ * @see __CILKRTS_END_EXTERN_C\n+ * @see __CILKRTS_EXTERN_C\n+ *\n+ * @def __CILKRTS_END_EXTERN_C\n+ * Macro to denote the end of a section in which all names have \"C\" linkage.\n+ * That is, none of the names are to be mangled.\n+ * @see __CILKRTS_BEGIN_EXTERN_C\n+ * @see __CILKRTS_EXTERN_C\n+ *\n+ * @def __CILKRTS_EXTERN_C\n+ * Macro to prefix a single definition which has \"C\" linkage.\n+ * That is, the defined name is not to be mangled.\n+ * @see __CILKRTS_BEGIN_EXTERN_C\n+ * @see __CILKRTS_END_EXTERN_C\n+ */\n+#ifdef __cplusplus\n+#   define __CILKRTS_BEGIN_EXTERN_C     extern \"C\" {\n+#   define __CILKRTS_END_EXTERN_C       }\n+#   define __CILKRTS_EXTERN_C           extern \"C\"\n+#else\n+#   define __CILKRTS_BEGIN_EXTERN_C\n+#   define __CILKRTS_END_EXTERN_C\n+#   define __CILKRTS_EXTERN_C\n+#endif\n+\n+/**\n+ * OS-independent macro to specify a function which is known to not throw\n+ * an exception.\n+ */ \n+#ifdef __cplusplus\n+#   ifdef _WIN32\n+#       define __CILKRTS_NOTHROW __declspec(nothrow)\n+#   else /* Unix/gcc */\n+#       define __CILKRTS_NOTHROW __attribute__((nothrow))\n+#   endif /* Unix/gcc */\n+#else\n+#   define __CILKRTS_NOTHROW /* nothing */\n+#endif /* __cplusplus */\n+\n+/** Cache alignment. (Good enough for most architectures.)\n+ */\n+#define __CILKRTS_CACHE_LINE__ 64\n+\n+/**\n+ * Macro to specify alignment of a data member in a structure.\n+ * Because of the way that gcc\u2019s alignment attribute is defined, @a n must\n+ * be a numeric literal, not just a compile-time constant expression.\n+ */\n+#ifdef _WIN32\n+#   define CILK_ALIGNAS(n) __declspec(align(n))\n+#else /* Unix/gcc */\n+#   define CILK_ALIGNAS(n) __attribute__((__aligned__(n)))\n+#endif\n+\n+/**\n+ * Macro to specify cache-line alignment of a data member in a structure.\n+ */\n+#define __CILKRTS_CACHE_ALIGN CILK_ALIGNAS(__CILKRTS_CACHE_LINE__)\n+\n+/**\n+ * Macro to specify a class as being at least as strictly aligned as some\n+ * type on Windows. gcc does not provide a way of doing this, so on Unix, \n+ * this just specifies the largest natural type alignment. Put the macro\n+ * between the `class` keyword and the class name:\n+ *\n+ *      class CILK_ALIGNAS_TYPE(foo) bar { ... };\n+ */\n+#ifdef _WIN32\n+#   define CILK_ALIGNAS_TYPE(t) __declspec(align(__alignof(t)))\n+#else /* Unix/gcc */\n+#   define CILK_ALIGNAS_TYPE(t) __attribute__((__aligned__))\n+#endif\n+\n+/**\n+ * @def CILK_API(RET_TYPE)\n+ * A function called explicitly by the programmer.\n+ * @def CILK_ABI(RET_TYPE)\n+ * A function called by compiler-generated code.\n+ * @def CILK_ABI_THROWS(RET_TYPE)\n+ * An ABI function that may throw an exception\n+ *\n+ * Even when these are the same definitions, they should be separate macros so\n+ * that they can be easily found in the code.\n+ */\n+\n+#ifdef _WIN32\n+#   define CILK_API(RET_TYPE) CILK_EXPORT RET_TYPE __CILKRTS_NOTHROW __cdecl\n+#   define CILK_ABI(RET_TYPE) CILK_EXPORT RET_TYPE __CILKRTS_NOTHROW __cdecl\n+#   define CILK_ABI_THROWS(RET_TYPE) CILK_EXPORT RET_TYPE __cdecl\n+#else\n+#   define CILK_API(RET_TYPE) CILK_EXPORT RET_TYPE __CILKRTS_NOTHROW\n+#   define CILK_ABI(RET_TYPE) CILK_EXPORT RET_TYPE __CILKRTS_NOTHROW\n+#   define CILK_ABI_THROWS(RET_TYPE) CILK_EXPORT RET_TYPE\n+#endif\n+\n+/**\n+ * __CILKRTS_ASSERT should be defined for debugging only, otherwise it\n+ * interferes with vectorization.  Since NDEBUG is not reliable (it must be\n+ * set by the user), we must use a platform-specific detection of debug mode.\n+ */\n+#if defined(_WIN32) && defined(_DEBUG)\n+    /* Windows debug */\n+#   define __CILKRTS_ASSERT(e) assert(e)\n+#elif (! defined(_WIN32)) && ! defined(__OPTIMIZE__)\n+    /* Unix non-optimized */\n+#   define __CILKRTS_ASSERT(e) assert(e)\n+#elif defined __cplusplus\n+    /* C++ non-debug */\n+#   define __CILKRTS_ASSERT(e) static_cast<void>(0)\n+#else\n+    /* C non-debug */\n+#   define __CILKRTS_ASSERT(e) ((void) 0)\n+#endif\n+\n+/**\n+ * OS-independent macro to specify a function that should be inlined\n+ */\n+#ifdef __cpluspus\n+    // C++\n+#   define __CILKRTS_INLINE inline\n+#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n+    // C99\n+#   define __CILKRTS_INLINE static inline\n+#elif defined(_MSC_VER)\n+    // C89 on Windows\n+#   define __CILKRTS_INLINE __inline\n+#else\n+    // C89 on GCC-compatible systems\n+#   define __CILKRTS_INLINE extern __inline__\n+#endif\n+\n+/**\n+ * Functions marked as CILK_EXPORT_AND_INLINE have both\n+ * inline versions defined in the Cilk API, as well as\n+ * non-inlined versions that are exported (for\n+ * compatibility with previous versions that did not\n+ * inline the functions).\n+ */\n+#ifdef COMPILING_CILK_API_FUNCTIONS\n+#   define CILK_EXPORT_AND_INLINE  CILK_EXPORT\n+#else\n+#   define CILK_EXPORT_AND_INLINE  __CILKRTS_INLINE\n+#endif\n+\n+/**\n+ * Try to determine if compiler supports rvalue references.\n+ */\n+#if defined(__cplusplus) && !defined(__CILKRTS_RVALUE_REFERENCES)\n+#   if __cplusplus >= 201103L // C++11\n+#       define __CILKRTS_RVALUE_REFERENCES 1\n+#   elif defined(__GXX_EXPERIMENTAL_CXX0X__)\n+#       define __CILKRTS_RVALUE_REFERENCES 1\n+#   elif __cplusplus >= 199711L && __cplusplus < 201103L\n+        // Compiler recognizes a language version prior to C++11\n+#   elif __INTEL_COMPILER == 1200 && defined(__STDC_HOSTED__)\n+        // Intel compiler version 12.0\n+        // __cplusplus has a non-standard definition.  In the absence of a\n+        // proper definition, look for the C++0x macro, __STDC_HOSTED__.\n+#       define __CILKRTS_RVALUE_REFERENCES 1\n+#   elif __INTEL_COMPILER > 1200 && defined(CHAR16T)\n+        // Intel compiler version >= 12.1\n+        // __cplusplus has a non-standard definition.  In the absence of a\n+        // proper definition, look for the Intel macro, CHAR16T\n+#       define __CILKRTS_RVALUE_REFERENCES 1\n+#   endif\n+#endif\n+\n+/*\n+ * Include stdint.h to define the standard integer types.\n+ *\n+ * Unfortunately Microsoft doesn't provide stdint.h until Visual Studio 2010,\n+ * so use our own definitions until those are available\n+ */\n+\n+#if ! defined(_MSC_VER) || (_MSC_VER >= 1600)\n+#   include <stdint.h>\n+#else\n+#   ifndef __MS_STDINT_TYPES_DEFINED__\n+#       define __MS_STDINT_TYPES_DEFINED__\n+        typedef signed char int8_t;\n+        typedef short int16_t;\n+        typedef int int32_t;\n+        typedef __int64 int64_t;\n+\n+        typedef unsigned char uint8_t;\n+        typedef unsigned short uint16_t;\n+        typedef unsigned int uint32_t;\n+        typedef unsigned __int64 uint64_t;\n+#   endif  /* __MS_STDINT_TYPES_DEFINED__ */\n+#endif  /* ! defined(_MSC_VER) || (_MSC_VER >= 1600) */\n+\n+/**\n+ * @brief Application Binary Interface version of the Cilk runtime library.\n+ *\n+ * The ABI version is determined by the compiler used.  An object file\n+ * compiled with a higher ABI version is not compatible with a library that is\n+ * compiled with a lower ABI version.  An object file compiled with a lower\n+ * ABI version, however, can be used with a library compiled with a higher ABI\n+ * version unless otherwise stated.\n+ */\n+#ifndef __CILKRTS_ABI_VERSION\n+#   ifdef IN_CILK_RUNTIME\n+#       define __CILKRTS_ABI_VERSION 1\n+#   elif __INTEL_COMPILER > 1200\n+        // Intel compiler version >= 12.1\n+#       define __CILKRTS_ABI_VERSION 1\n+#   else\n+        // Compiler does not support ABI version 1\n+        // (Non-Intel compiler or Intel compiler prior to version 12.1).\n+#       define __CILKRTS_ABI_VERSION 0\n+#   endif\n+#endif\n+\n+// These structs are exported because the inlining of\n+// the internal version of API methods require a worker\n+// structure as parameter. \n+__CILKRTS_BEGIN_EXTERN_C\n+    /// Worker struct, exported for inlined API methods\n+    /// @ingroup api\n+    struct __cilkrts_worker;\n+\n+    /// Worker struct, exported for inlined API methods\n+    /// @ingroup api\n+    typedef struct __cilkrts_worker __cilkrts_worker;     \n+\n+    /// Worker struct pointer, exported for inlined API methods\n+    /// @ingroup api\n+    typedef struct __cilkrts_worker *__cilkrts_worker_ptr; \n+    \n+    \n+    /// Fetch the worker out of TLS.\n+    CILK_ABI(__cilkrts_worker_ptr) __cilkrts_get_tls_worker(void);\n+\n+    /// void *, defined to work around complaints from the compiler\n+    /// about using __declspec(nothrow) after the \"void *\" return type\n+    typedef void * __cilkrts_void_ptr;\n+\n+__CILKRTS_END_EXTERN_C\n+\n+                                   \n+#if __CILKRTS_ABI_VERSION >= 1\n+// Pedigree API is available only for compilers that use ABI version >= 1.\n+\n+/** Pedigree information kept in the worker and stack frame.\n+ *  @ingroup api\n+ */\n+typedef struct __cilkrts_pedigree\n+{\n+    /** Rank at start of spawn helper. Saved rank for spawning functions */\n+    uint64_t rank;\n+                                         \n+    /** Link to next in chain */\n+    const struct __cilkrts_pedigree *parent;\n+} __cilkrts_pedigree;\n+\n+#endif // __CILKRTS_ABI_VERSION >= 1\n+\n+/// @}\n+\n+#endif /* INCLUDED_CILK_COMMON */"}, {"sha": "8620c052f53e7940bd59f49a36e991c52d3a1f79", "filename": "libcilkrts/include/cilk/holder.h", "status": "added", "additions": 1000, "deletions": 0, "changes": 1000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fholder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fholder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fholder.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,1000 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2011-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+/*\n+ * holder.h\n+ *\n+ * Purpose: hyperobject to provide different views of an object to each\n+ * parallel strand.\n+ */\n+\n+#ifndef HOLDER_H_INCLUDED\n+#define HOLDER_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+#include <memory>\n+#include <utility>\n+\n+#ifdef __cplusplus\n+\n+/* C++ Interface\n+ *\n+ * Classes: holder<Type>\n+ *\n+ * Description:\n+ * ============\n+ * This component provides a hyperobject that isolates a parallel uses of a\n+ * common variable where it is not necessary to preserve changes from\n+ * different parallel strands.  In effect, a holder acts a bit like\n+ * thread-local storage, but has qualities that work better with the\n+ * fork-join structure of Cilk.  In particular, a holder has the following\n+ * qualities:\n+ *\n+ * - The view of a holder before the first spawn within a function is the same\n+ *   as the view after each sync (as in the case of a reducer).\n+ * - The view of a holder within the first spawned child of a function (or the\n+ *   first child spawned after a sync) is the same as the view on entry to the\n+ *   function.\n+ * - The view of a holder before entering a _Cilk_for loop is the same as the\n+ *   view during the first iteration of the loop and the view at the end of\n+ *   the loop.\n+ * - The view of a holder in the continuation of a spawn or in an arbitrary\n+ *   iteration of a _Cilk_for loop is *non-deterministic*.  It is generally\n+ *   recommended that the holder be explicitly put into a known state in these\n+ *   situations.\n+ *\n+ * A holder can be used as an alternative to parameter-passing.  They are most\n+ * useful for replacing non-local variables without massive refactoring.  A\n+ * holder takes advantage of the fact that, most of the time, a holder view\n+ * does not change after a spawn or from one iteration of a parallel for loop\n+ * to the next (i.e., stealing is the exception, not the rule).  When the\n+ * holder view is a large object that is expensive to construct, this\n+ * optimization can save significant time versus creating a separate local\n+ * object for each view.  In addition, a holder using the \"keep last\" policy\n+ * will have the same value after a sync as the serialization of the same\n+ * program.  The last quality will often allow the program to avoid\n+ * recomputing a value.\n+ *\n+ * Usage Example:\n+ * ==============\n+ * Function 'compute()' is a complex function that computes a value using a\n+ * memoized algorithm, storing intermediate results in a hash table.  Compute\n+ * calls several other functions, each of which calls several other functions,\n+ * all of which share a global hash table.  In all, there are over a dozen\n+ * functions with a total of about 60 references to the hash table.  \n+ *..\n+ *  hash_table<int, X> memos;\n+ *\n+ *  void h(const X& x);  // Uses memos\n+ *\n+ *  double compute(const X& x)\n+ *  {\n+ *     memos.clear();\n+ *     // ...\n+ *     memos[i] = x;\n+ *     ...\n+ *     g(i);  // Uses memos\n+ *     // ...\n+ *     std::for_each(c.begin(), c.end(), h);  // Call h for each element of c\n+ *  }\n+ *\n+ *  int main()\n+ *  {\n+ *      const std::size_t ARRAY_SIZE = 1000000;\n+ *      extern X myArray[ARRAY_SIZE];\n+ *\n+ *      for (std::size_t i = 0; i < ARRAY_SIZE; ++i)\n+ *      {\n+ *          compute(myArray[i]);\n+ *      }\n+ *  }\n+ *..\n+ * We would like to replace the 'for' loop in 'main' with a 'cilk_for'.\n+ * Although the hash table is cleared on entry to each call to 'compute()',\n+ * and although the values stored in the hash table are no longer used after\n+ * 'compute()' returns, the use of the hash table as a global variable\n+ * prevents 'compute()' from being called safely in parallel.  One way to do\n+ * this would be to make 'memos' a private variable within the cilk_for loop\n+ * and pass it down to the actual computation, so that each loop iteration has\n+ * its own private copy:\n+ *..\n+ *      cilk_for (std::size_t i = 0; i < ARRAY_SIZE; ++i)\n+ *      {\n+ *          hash_table<int, X> memos;\n+ *          compute(myArray[i], memos);\n+ *      }\n+ *..\n+ * The problem with this approach is that it requires changing the signature\n+ * of 'compute', 'h', 'g', and every one of the dozen or so functions that\n+ * reference 'memos' as well as any function that calls those functions.  This\n+ * may break the abstraction of 'compute' and other functions, exposing an\n+ * implementation detail that was not part of the interface.  In addition, the\n+ * function 'h' is called through a templated algorithm, 'for_each', which\n+ * requires a fixed interface.  Finally, there is constructor and destructor\n+ * overhead for 'hash_table' each time through the loop.\n+ *\n+ * The alternative approach is to replace 'memos' with a holder.  The holder\n+ * would be available to all of the functions involved, but would not cause a\n+ * race between parallel loop iterations.  In order to make this work, each\n+ * use of the 'memos' variable must be (mechanically) replaced by a use of the\n+ * holder:\n+ *..\n+ *  cilk::holder<hash_table<int, X> > memos_h;\n+ *\n+ *  void h(const X& x);  // Uses memos_h\n+ *\n+ *  double compute(const X& x)\n+ *  {\n+ *     memos_h().clear();  // operator() used to \"dereference\" the holder\n+ *     // ...\n+ *     memos_h()[i] = x;   // operator() used to \"dereference\" the holder\n+ *     ...\n+ *     g(i);  // Uses memos_h\n+ *     // ...\n+ *     std::for_each(c.begin(), c.end(), h);  // Call h for each element of c\n+ *  }\n+ *..\n+ * Note that each reference to the holder must be modified with an empty pair\n+ * of parenthesis.  This syntax is needed because there is no facility in C++\n+ * for a \"smart reference\" that would allow 'memos_h' to be a perfect\n+ * replacement for 'memos'.  One way that a user can avoid this syntax change\n+ * is to wrap the holder in a class that has the same inteface as\n+ * 'hash_table' but redirects all calls to the holder:\n+ *..\n+ *  template <typename K, typename V>\n+ *  class hash_table_holder\n+ *  {\n+ *    private:\n+ *      cilk::holder<hash_table<K, V> > m_holder;\n+ *    public:\n+ *      void clear() { m_holder().clear(); }\n+ *      V& operator[](const K& x) { return m_holder()[x]; }\n+ *      std::size_t size() const { return m_holder().size(); }\n+ *      // etc. ...\n+ *  };\n+ *..\n+ * Using the above wrapper, the original code can be left unchanged except for\n+ * replacing 'hash_table' with 'hash_table_holder' and replacing 'for' with\n+ * 'cilk_for':\n+ *..\n+ *  hash_table_holder<int, X> memos;\n+ *\n+ *  void h(const X& x);  // Uses memos\n+ *\n+ *  double compute(const X& x)\n+ *  {\n+ *     memos.clear();  // Calls hash_table_holder::clear().\n+ *     // ...\n+ *  }\n+ *..\n+ * The above changes have no benefit over the use of thread-local storage.\n+ * What if one of the functions has a 'cilk_spawn', however?\n+ *..\n+ *  void h(const X& x)\n+ *  {\n+ *      Y y = x.nested();\n+ *      double d, w;\n+ *      if (y)\n+ *      {\n+ *          w = cilk_spawn compute_width(y); // May use 'memos'\n+ *          d = compute_depth(y);            // Does not use 'memos'\n+ *          cilk_sync;\n+ *          compute(y);  // recursive call.  Uses 'memos'.\n+ *      }\n+ *  }\n+ *..\n+ * In the above example, the view of the holder within 'compute_width' is the\n+ * same as the view on entry to 'h'.  More importantly, the view of the holder\n+ * within the recursive call to 'compute' is the same as the view on entry to\n+ * 'h', even if a different worker is executing the recursive call.  Thus, the\n+ * holder view within a Cilk program has useful qualities not found in\n+ * thread-local storage.\n+ */\n+\n+namespace cilk {\n+    \n+    /**\n+     * After a sync, the value stored in a holder matches the most recent\n+     * value stored into the holder by one of the starnds entering the sync.\n+     * The holder policy used to instantiate the holder determines which of\n+     * the entering strands determines the final value of the holder. A policy\n+     * of 'holder_keep_indeterminate' (the default) is the most efficient, and\n+     * results in an indeterminate value depending on the runtime schedule\n+     * (see below for more specifics).  An indeterminate value after a sync is\n+     * often acceptable, especially if the value of the holder is not reused\n+     * after the sync.  All of the remaining policies retain the value of the\n+     * last strand that would be executed in the serialization of the program.\n+     * They differ in the mechanism used to move the value from one view to\n+     * another.  A policy of 'holder_keep_last_copy' moves values by\n+     * copy-assignment.  A policy of 'holder_keep_last_swap' moves values by\n+     * calling 'swap'.  A policy of 'holder_keep_last_move' is available only\n+     * for compilers that support C++0x rvalue references and moves values by\n+     * move-assignment.  A policy of 'holder_keep_last' attempts to choose the\n+     * most efficient mechanism: member-function 'swap' if the view type\n+     * supports it, otherwise move-assignment if supported, otherwise\n+     * copy-assignment.  (The swap member function for a class that provides\n+     * one is almost always as fast or faster than move-assignment or\n+     * copy-assignment.)\n+     *\n+     * The behavior of 'holder_keep_indeterminate', while indeterminate, is\n+     * not random and can be used for advanced programming or debugging.  With\n+     * a policy of 'holder_keep_intermediate', values are never copied or\n+     * moved between views.  The value of the view after a sync is the same as\n+     * the value set in the last spawned child before a steal occurs or the\n+     * last value set in the continuation if no steal occurs.  Using this\n+     * knowledge, a programmer can use a holder to detect the earliest steal\n+     * in a piece of code.  An indeterminate holder is also useful for keeping\n+     * cached data similar to the way some applications might use thread-local\n+     * storage.\n+     */\n+    enum holder_policy {\n+        holder_keep_indeterminate,\n+        holder_keep_last,\n+        holder_keep_last_copy,\n+        holder_keep_last_swap,\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        holder_keep_last_move\n+#endif\n+    };\n+\n+    namespace internal {\n+\n+        // Private special-case holder policy using the swap member-function\n+        const holder_policy holder_keep_last_member_swap =\n+            (holder_policy) (holder_keep_last_swap | 0x10);\n+\n+        /* The constant, 'has_member_swap<T>::value', will be 'true' if 'T'\n+         * has a non-static member function with prototype 'void swap(T&)'.\n+         * The mechanism used to detect 'swap' is the most portable among\n+         * present-day compilers, but is not the most robust.  Specifically,\n+         * the prototype for 'swap' must exactly match 'void swap(T&)'.\n+         * Near-matches like a 'swap' function that returns 'int' instead of\n+         * 'void' will not be detected.  Detection will also fail if 'T'\n+         * inherits 'swap' from a base class.\n+         */\n+        template <typename T>\n+        class has_member_swap\n+        {\n+            // This technique for detecting member functions was described by\n+            // Rani Sharoni in comp.lang.c++.moderated:\n+            // http://groups.google.com/group/comp.lang.c++.moderated/msg/2b06b2432fddfb60\n+\n+            // sizeof(notchar) is guaranteed larger than 1\n+            struct notchar { char x[2]; };\n+\n+            // Instantiationg Q<U, &U::swap> will fail unless U contains a\n+            // non-static member with prototype 'void swap(U&)'.\n+            template <class U, void (U::*)(U&)> struct Q { };\n+\n+            // First 'test' is preferred overload if U::swap exists with the\n+            // correct prototype.  Second 'test' is preferred overload\n+            // otherwise.\n+            template <typename U> static char test(Q<U,&U::swap>*);\n+            template <typename U> static notchar test(...);\n+\n+        public:\n+            /// 'value' will be true if T has a non-static member function\n+            /// with prototype 'void swap(T&)'.\n+            static const bool value = (1 == sizeof(test<T>(0)));\n+        };\n+\n+        template <typename T> const bool has_member_swap<T>::value;\n+\n+        /**\n+         * @brief Utility class for exception safety.\n+         *\n+         * The constuctor for this class takes a pointer and an allocator and\n+         * holds on to them.  The destructor deallocates the pointed-to\n+         * object, without calling its destructor, typically to recover memory\n+         * in case an exception is thrown. The release member clears the\n+         * pointer so that the deallocation is prevented, i.e., when the\n+         * exception danger has passed.  The behavior of this class is similar\n+         * to auto_ptr and unique_ptr.\n+         */\n+        template <typename Type, typename Allocator = std::allocator<Type> >\n+        class auto_deallocator\n+        {\n+            Allocator m_alloc;\n+            Type*     m_ptr;\n+\n+            // Non-copiable\n+            auto_deallocator(const auto_deallocator&);\n+            auto_deallocator& operator=(const auto_deallocator&);\n+\n+        public:\n+            /// Constructor\n+            explicit auto_deallocator(Type* p, const Allocator& a = Allocator())\n+                : m_alloc(a), m_ptr(p) { }\n+\n+            /// Destructor - free allocated resources\n+            ~auto_deallocator() { if (m_ptr) m_alloc.deallocate(m_ptr, 1); }\n+\n+            /// Remove reference to resource\n+            void release() { m_ptr = 0; }\n+        };\n+\n+        /**\n+         * Pure-abstract base class to initialize holder views\n+         */\n+        template <typename Type, typename Allocator>\n+        class init_base\n+        {\n+        public:\n+            virtual ~init_base() { }\n+            virtual init_base* clone_self(Allocator& a) const = 0;\n+            virtual void delete_self(Allocator& a) = 0;\n+            virtual void construct_view(Type* p, Allocator& a) const = 0;\n+        };\n+\n+        /**\n+         * Class to default-initialize a holder view\n+         */\n+        template <typename Type, typename Allocator>\n+        class default_init : public init_base<Type, Allocator>\n+        {\n+            typedef init_base<Type, Allocator> base;\n+\n+            /// Private constructor (called from static make() function).\n+            default_init() { }\n+\n+            // Non-copiable\n+            default_init(const default_init&);\n+            default_init& operator=(const default_init&);\n+\n+        public:\n+            // Static factory function\n+            static default_init* make(Allocator& a);\n+\n+            // Virtual function overrides\n+            virtual ~default_init();\n+            virtual base* clone_self(Allocator& a) const;\n+            virtual void delete_self(Allocator& a);\n+            virtual void construct_view(Type* p, Allocator& a) const;\n+        };\n+\n+        template <typename Type, typename Allocator>\n+        default_init<Type, Allocator>*\n+        default_init<Type, Allocator>::make(Allocator&)\n+        {\n+            // Return a pointer to a singleton.  All instances of this class\n+            // are identical, so we need only one.\n+            static default_init self;\n+            return &self;\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        default_init<Type, Allocator>::~default_init()\n+        {\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        init_base<Type, Allocator>*\n+        default_init<Type, Allocator>::clone_self(Allocator& a) const\n+        {\n+            return make(a);\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        void default_init<Type, Allocator>::delete_self(Allocator&)\n+        {\n+            // Since make() returned a shared singleton, there is nothing to\n+            // delete here.\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        void\n+        default_init<Type, Allocator>::construct_view(Type* p,\n+                                                      Allocator&) const\n+        {\n+            ::new((void*) p) Type();\n+            // TBD: In a C++0x library, this should be rewritten\n+            // std::allocator_traits<Allocator>::construct(a, p);\n+        }\n+\n+        /**\n+         * Class to copy-construct a view from a stored exemplar.\n+         */\n+        template <typename Type, typename Allocator>\n+        class exemplar_init : public init_base<Type, Allocator>\n+        {\n+            typedef init_base<Type, Allocator> base;\n+\n+            Type* m_exemplar;\n+\n+            // Private constructors (called from make() functions).\n+            exemplar_init(const Type& val, Allocator& a);\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+            exemplar_init(Type&& val,      Allocator& a);\n+#endif\n+\n+            // Non-copyiable\n+            exemplar_init(const exemplar_init&);\n+            exemplar_init& operator=(const exemplar_init&);\n+\n+        public:\n+            // Static factory functions\n+            static exemplar_init* make(const Type& val,\n+                                       Allocator& a = Allocator());\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+            static exemplar_init* make(Type&& val,\n+                                       Allocator& a = Allocator());\n+#endif\n+\n+            // Virtual function overrides\n+            virtual ~exemplar_init();\n+            virtual base* clone_self(Allocator& a) const;\n+            virtual void delete_self(Allocator& a);\n+            virtual void construct_view(Type* p, Allocator& a) const;\n+        };\n+\n+        template <typename Type, typename Allocator>\n+        exemplar_init<Type, Allocator>::exemplar_init(const Type& val,\n+                                                      Allocator&  a)\n+        {\n+            m_exemplar = a.allocate(1);\n+            auto_deallocator<Type, Allocator> guard(m_exemplar, a);\n+            a.construct(m_exemplar, val);\n+            guard.release();\n+        }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        template <typename Type, typename Allocator>\n+        exemplar_init<Type, Allocator>::exemplar_init(Type&&     val,\n+                                                      Allocator& a)\n+        {\n+            m_exemplar = a.allocate(1);\n+            auto_deallocator<Type, Allocator> guard(m_exemplar, a);\n+            a.construct(m_exemplar, std::forward<Type>(val));\n+            guard.release();\n+        }\n+#endif\n+\n+        template <typename Type, typename Allocator>\n+        exemplar_init<Type, Allocator>*\n+        exemplar_init<Type, Allocator>::make(const Type& val,\n+                                             Allocator&  a)\n+        {\n+            typedef typename Allocator::template rebind<exemplar_init>::other\n+                self_alloc_t;\n+            self_alloc_t alloc(a);\n+\n+            exemplar_init *self = alloc.allocate(1);\n+            auto_deallocator<exemplar_init, self_alloc_t> guard(self, alloc);\n+\n+            // Don't use allocator to construct self.  Allocator should be\n+            // used only on elements of type 'Type'.\n+            ::new((void*) self) exemplar_init(val, a);\n+\n+            guard.release();\n+\n+            return self;\n+        }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        template <typename Type, typename Allocator>\n+        exemplar_init<Type, Allocator>*\n+        exemplar_init<Type, Allocator>::make(Type&&           val,\n+                                             Allocator& a)\n+        {\n+            typedef typename Allocator::template rebind<exemplar_init>::other\n+                self_alloc_t;\n+            self_alloc_t alloc(a);\n+\n+            exemplar_init *self = alloc.allocate(1);\n+            auto_deallocator<exemplar_init, self_alloc_t> guard(self, alloc);\n+\n+            // Don't use allocator to construct self.  Allocator should be\n+            // used only on elements of type 'Type'.\n+            ::new((void*) self) exemplar_init(std::forward<Type>(val), a);\n+\n+            guard.release();\n+\n+            return self;\n+        }\n+#endif\n+\n+        template <typename Type, typename Allocator>\n+        exemplar_init<Type, Allocator>::~exemplar_init()\n+        {\n+            // Called only by delete_self, which deleted the exemplar using an\n+            // allocator.\n+            __CILKRTS_ASSERT(0 == m_exemplar);\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        init_base<Type, Allocator>*\n+        exemplar_init<Type, Allocator>::clone_self(Allocator& a) const\n+        {\n+            return make(*m_exemplar, a);\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        void exemplar_init<Type, Allocator>::delete_self(Allocator& a)\n+        {\n+            typename Allocator::template rebind<exemplar_init>::other alloc(a);\n+\n+            a.destroy(m_exemplar);\n+            a.deallocate(m_exemplar, 1);\n+            m_exemplar = 0;\n+\n+            this->~exemplar_init();\n+            alloc.deallocate(this, 1);\n+        }\n+\n+        template <typename Type, typename Allocator>\n+        void\n+        exemplar_init<Type, Allocator>::construct_view(Type*            p,\n+                                                       Allocator& a) const\n+        {\n+            a.construct(p, *m_exemplar);\n+            // TBD: In a C++0x library, this should be rewritten\n+            // std::allocator_traits<Allocator>::construct(a, p, *m_exemplar);\n+        }\n+\n+        /**\n+         * Class to construct a view using a stored functor.  The functor,\n+         * 'f', must be be invokable using the expression 'Type x = f()'.\n+         */\n+        template <typename Func, typename Allocator>\n+        class functor_init :\n+            public init_base<typename Allocator::value_type, Allocator>\n+        {\n+            typedef typename Allocator::value_type            value_type;\n+            typedef init_base<value_type, Allocator>          base;\n+            typedef typename Allocator::template rebind<Func>::other f_alloc;\n+\n+            Func *m_functor;\n+\n+            /// Private constructors (called from make() functions\n+            functor_init(const Func& f, Allocator& a);\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+            functor_init(Func&& f, Allocator& a);\n+#endif\n+\n+            // Non-copiable\n+            functor_init(const functor_init&);\n+            functor_init& operator=(const functor_init&);\n+\n+        public:\n+            // Static factory functions\n+            static functor_init* make(const Func& val,\n+                                      Allocator& a = Allocator());\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+            static functor_init* make(Func&& val,\n+                                      Allocator& a = Allocator());\n+#endif\n+\n+            // Virtual function overrides\n+            virtual ~functor_init();\n+            virtual base* clone_self(Allocator& a) const;\n+            virtual void delete_self(Allocator& a);\n+            virtual void\n+                construct_view(value_type* p, Allocator& a) const;\n+        };\n+\n+        /// Specialization to strip off reference from 'Func&'.\n+        template <typename Func, typename Allocator>\n+        struct functor_init<Func&, Allocator>\n+            : functor_init<Func, Allocator> { };\n+\n+        /// Specialization to strip off reference and cvq from 'const Func&'.\n+        template <typename Func, typename Allocator>\n+        struct functor_init<const Func&, Allocator>\n+            : functor_init<Func, Allocator> { };\n+\n+        template <typename Func, typename Allocator>\n+        functor_init<Func, Allocator>::functor_init(const Func& f,\n+                                                    Allocator&  a)\n+        {\n+            f_alloc alloc(a);\n+\n+            m_functor = alloc.allocate(1);\n+            auto_deallocator<Func, f_alloc> guard(m_functor, alloc);\n+            alloc.construct(m_functor, f);\n+            guard.release();\n+        }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        template <typename Func, typename Allocator>\n+        functor_init<Func, Allocator>::functor_init(Func&&     f,\n+                                                    Allocator& a)\n+        {\n+            f_alloc alloc(a);\n+\n+            m_functor = alloc.allocate(1);\n+            auto_deallocator<Func, f_alloc> guard(m_functor, alloc);\n+            alloc.construct(m_functor, std::forward<Func>(f));\n+            guard.release();\n+        }\n+#endif\n+\n+        template <typename Func, typename Allocator>\n+        functor_init<Func, Allocator>*\n+        functor_init<Func, Allocator>::make(const Func& f, Allocator& a)\n+        {\n+            typedef typename Allocator::template rebind<functor_init>::other\n+                self_alloc_t;\n+            self_alloc_t alloc(a);\n+\n+            functor_init *self = alloc.allocate(1);\n+            auto_deallocator<functor_init, self_alloc_t> guard(self, alloc);\n+\n+            // Don't use allocator to construct self.  Allocator should be\n+            // used only on elements of type 'Func'.\n+            ::new((void*) self) functor_init(f, a);\n+\n+            guard.release();\n+\n+            return self;\n+        }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        template <typename Func, typename Allocator>\n+        functor_init<Func, Allocator>*\n+        functor_init<Func, Allocator>::make(Func&& f, Allocator& a)\n+        {\n+            typedef typename Allocator::template rebind<functor_init>::other\n+                self_alloc_t;\n+            self_alloc_t alloc(a);\n+\n+            functor_init *self = alloc.allocate(1);\n+            auto_deallocator<functor_init, self_alloc_t> guard(self, alloc);\n+\n+            // Don't use allocator to construct self.  Allocator should be\n+            // used only on elements of type 'Func'.\n+            ::new((void*) self) functor_init(std::forward<Func>(f), a);\n+\n+            guard.release();\n+\n+            return self;\n+        }\n+#endif\n+\n+        template <typename Func, typename Allocator>\n+        functor_init<Func, Allocator>::~functor_init()\n+        {\n+            // Called only by delete_self, which deleted the functor using an\n+            // allocator.\n+            __CILKRTS_ASSERT(0 == m_functor);\n+        }\n+\n+        template <typename Func, typename Allocator>\n+        init_base<typename Allocator::value_type, Allocator>*\n+        functor_init<Func, Allocator>::clone_self(Allocator& a) const\n+        {\n+            return make(*m_functor, a);\n+        }\n+\n+        template <typename Func, typename Allocator>\n+        inline\n+        void functor_init<Func, Allocator>::delete_self(Allocator& a)\n+        {\n+            typename Allocator::template rebind<functor_init>::other alloc(a);\n+            f_alloc fa(a);\n+\n+            fa.destroy(m_functor);\n+            fa.deallocate(m_functor, 1);\n+            m_functor = 0;\n+\n+            this->~functor_init();\n+            alloc.deallocate(this, 1);\n+        }\n+\n+        template <typename Func, typename Allocator>\n+        void functor_init<Func, Allocator>::construct_view(value_type* p,\n+                                                           Allocator& a) const\n+        {\n+            a.construct(p, (*m_functor)());\n+            // In C++0x, the above should be written\n+            // std::allocator_traits<Allocator>::construct(a, p, m_functor());\n+        }\n+\n+        /**\n+         * Functor called to reduce a holder\n+         */\n+        template <typename Type, holder_policy Policy>\n+        struct holder_reduce_functor;\n+\n+        /**\n+         * Specialization to keep the left (first) value.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_indeterminate>\n+        {\n+            void operator()(Type* left, Type* right) const { }\n+        };\n+\n+        /**\n+         * Specialization to copy-assign from the right (last) value.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_last_copy>\n+        {\n+            void operator()(Type* left, Type* right) const {\n+                *left = *right;\n+            }\n+        };\n+\n+        /*\n+         * Specialization to keep the right (last) value via swap.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_last_swap>\n+        {\n+            void operator()(Type* left, Type* right) const {\n+                using std::swap;\n+                swap(*left, *right);\n+            }\n+        };\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        /*\n+         * Specialization to move-assign from the right (last) value.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_last_move>\n+        {\n+            void operator()(Type* left, Type* right) const {\n+                *left = std::move(*right);\n+            }\n+        };\n+#endif\n+\n+        /*\n+         * Specialization to keep the right (last) value via the swap member\n+         * function.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_last_member_swap>\n+        {\n+            void operator()(Type* left, Type* right) const {\n+                left->swap(*right);\n+            }\n+        };\n+\n+        /*\n+         * Specialization to keep the right (last) value by the most efficient\n+         * means detectable.\n+         */\n+        template <typename Type>\n+        struct holder_reduce_functor<Type, holder_keep_last> :\n+            holder_reduce_functor<Type,\n+                                  (holder_policy)\n+                                  (has_member_swap<Type>::value ?\n+                                  holder_keep_last_member_swap :\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+                                  holder_keep_last_move\n+#else\n+                                  holder_keep_last_copy\n+#endif\n+                                  )>\n+        {\n+        };\n+    } // end namespace internal\n+\n+    /**\n+     * Monoid for holders.\n+     * Allocator type is required to be thread-safe.\n+     */\n+    template <typename Type,\n+              holder_policy Policy = holder_keep_indeterminate,\n+              typename Allocator = std::allocator<Type> >\n+    class holder_monoid : public monoid_base<Type>\n+    {\n+        // Allocator is mutable because the copy of the monoid inside the\n+        // reducer is const (to avoid races on the shared state).  However,\n+        // the allocator is required to be thread-safe, so it is ok (and\n+        // necessary) to modify.\n+        mutable Allocator                     m_allocator;\n+        internal::init_base<Type, Allocator> *m_initializer;\n+\n+    public:\n+        /// This constructor uses default-initialization for both the leftmost\n+        /// view and each identity view.\n+        holder_monoid(const Allocator& a = Allocator())\n+            : m_allocator(a)\n+            , m_initializer(\n+                internal::default_init<Type, Allocator>::make(m_allocator))\n+            { }\n+\n+        /// These constructors use 'val' as an exemplar to copy-construct both\n+        /// the leftmost view and each identity view.\n+        holder_monoid(const Type& val, const Allocator& a = Allocator())\n+            : m_allocator(a)\n+            , m_initializer(internal::exemplar_init<Type, Allocator>::make(\n+                                val, m_allocator)) { }\n+        /// This constructor uses 'f' as a functor to construct both\n+        /// the leftmost view and each identity view.\n+        template <typename Func>\n+        holder_monoid(const Func& f, const Allocator& a = Allocator())\n+            : m_allocator(a)\n+            , m_initializer(\n+                internal::functor_init<Func, Allocator>::make(f,m_allocator))\n+            { }\n+\n+        /// Copy constructor\n+        holder_monoid(const holder_monoid& rhs)\n+            : m_allocator(rhs.m_allocator)\n+            , m_initializer(rhs.m_initializer->clone_self(m_allocator)) { }\n+\n+        /// \"Extended\" copy constructor with allocator\n+        holder_monoid(const holder_monoid& rhs, const Allocator& a)\n+            : m_allocator(a)\n+            , m_initializer(rhs.m_initializer->clone_self(m_allocator)) { }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        /// Move constructor\n+        holder_monoid(holder_monoid&& rhs)\n+            : m_allocator(rhs.m_allocator)\n+            , m_initializer(rhs.m_initializer) {\n+            rhs.m_initializer =\n+                internal::default_init<Type, Allocator>::make(m_allocator);\n+        }\n+\n+        /// \"Extended\" move constructor with allocator\n+        holder_monoid(holder_monoid&& rhs, const Allocator& a)\n+            : m_allocator(a)\n+            , m_initializer(0) {\n+            if (a != rhs.m_allocator)\n+                m_initializer = rhs.m_initializer->clone_self(a);\n+            else {\n+                m_initializer = rhs.m_initializer;\n+                rhs.m_initializer =\n+                    internal::default_init<Type, Allocator>::make(m_allocator);\n+            }\n+        }\n+#endif\n+        /// Destructor\n+        ~holder_monoid() { m_initializer->delete_self(m_allocator); }\n+\n+        holder_monoid& operator=(const holder_monoid& rhs) {\n+            if (this == &rhs) return *this;\n+            m_initializer->delete_self(m_allocator);\n+            m_initializer = rhs.m_initializer->clone_self(m_allocator);\n+        }\n+\n+#ifdef __CILKRTS_RVALUE_REFERENCES\n+        holder_monoid& operator=(holder_monoid&& rhs) {\n+            if (m_allocator != rhs.m_allocator)\n+                // Delegate to copy-assignment on unequal allocators\n+                return operator=(static_cast<const holder_monoid&>(rhs));\n+            std::swap(m_initializer, rhs.m_initializer);\n+            return *this;\n+        }\n+#endif\n+\n+        /// Constructs IDENTITY value into the uninitilized '*p'\n+        void identity(Type* p) const\n+            { m_initializer->construct_view(p, m_allocator); }\n+\n+        /// Calls the destructor on the object pointed-to by 'p'\n+        void destroy(Type* p) const\n+            { m_allocator.destroy(p); }\n+\n+        /// Return a pointer to size bytes of raw memory\n+        void* allocate(std::size_t s) const {\n+            __CILKRTS_ASSERT(sizeof(Type) == s);\n+            return m_allocator.allocate(1);\n+        }\n+\n+        /// Deallocate the raw memory at p\n+        void deallocate(void* p) const {\n+            m_allocator.deallocate(static_cast<Type*>(p), sizeof(Type));\n+        }\n+\n+        void reduce(Type* left, Type* right) const {\n+            internal::holder_reduce_functor<Type, Policy>()(left, right);\n+        }\n+\n+        void swap(holder_monoid& other) {\n+            __CILKRTS_ASSERT(m_allocator == other.m_allocator);\n+            std::swap(m_initializer, other.m_initializer);\n+        }\n+\n+        Allocator get_allocator() const {\n+            return m_allocator;\n+        }\n+    };\n+\n+    // Namespace-scope swap\n+    template <typename Type, holder_policy Policy, typename Allocator>\n+    inline void swap(holder_monoid<Type, Policy, Allocator>& a,\n+                     holder_monoid<Type, Policy, Allocator>& b)\n+    {\n+        a.swap(b);\n+    }\n+\n+   /**\n+    * Hyperobject to provide different views of an object to each\n+    * parallel strand.\n+    */\n+    template <typename Type,\n+              holder_policy Policy = holder_keep_indeterminate,\n+              typename Allocator = std::allocator<Type> >\n+    class holder : public reducer<holder_monoid<Type, Policy, Allocator> >\n+    {\n+        typedef holder_monoid<Type, Policy, Allocator> monoid_type;\n+        typedef reducer<monoid_type> imp;\n+\n+        // Return a value of Type constructed using the functor Func.\n+        template <typename Func>\n+        Type make_value(const Func& f) const {\n+            struct obj {\n+                union {\n+                    char buf[sizeof(Type)];\n+                    void* align1;\n+                    double align2;\n+                };\n+\n+                obj(const Func& f) { f(static_cast<Type*>(buf)); }\n+                ~obj() { static_cast<Type*>(buf)->~Type(); }\n+\n+                operator Type&() { return *static_cast<Type*>(buf); }\n+            };\n+\n+            return obj(f);\n+        }\n+\n+    public:\n+        /// Default constructor uses default-initialization for both the\n+        /// leftmost view and each identity view.\n+        holder(const Allocator& alloc = Allocator())\n+            : imp(monoid_type(alloc)) { }\n+\n+        /// Construct from an exemplar that is used to initialize both the\n+        /// leftmost view and each identity view.\n+        holder(const Type& v, const Allocator& alloc = Allocator())\n+            // Alas, cannot use an rvalue reference for 'v' because it is used\n+            // twice in the same expression for initializing imp.\n+            : imp(monoid_type(v, alloc), v) { }\n+\n+        /// Construct from a functor that is used to initialize both the\n+        /// leftmost view and each identity view.  The functor, 'f', must be be\n+        /// invokable using the expression 'Type x = f()'.\n+        template <typename Func>\n+        holder(const Func& f, const Allocator& alloc = Allocator())\n+            // Alas, cannot use an rvalue for 'f' because it is used twice in\n+            // the same expression for initializing imp.\n+            : imp(monoid_type(f, alloc), make_value(f)) { }\n+    };\n+\n+} // end namespace cilk\n+\n+#else /* C */\n+# error Holders are currently available only for C++\n+#endif /* __cplusplus */\n+\n+#endif /* HOLDER_H_INCLUDED */"}, {"sha": "484bf5f01ea2286127967fab6a7e12ca1758996e", "filename": "libcilkrts/include/cilk/hyperobject_base.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,172 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+#ifndef INCLUDED_CILK_HYPEROBJECT_BASE\n+#define INCLUDED_CILK_HYPEROBJECT_BASE\n+\n+#ifdef __cplusplus\n+# include <cstdlib>\n+# include <cstddef>\n+#else\n+# include <stdlib.h>\n+# include <stddef.h>\n+#endif\n+\n+#include <cilk/common.h>\n+\n+#if defined _WIN32 || defined _WIN64\n+# if !defined CILK_STUB && !defined IN_CILK_RUNTIME\n+    /* bring in the Cilk library, which has definitions for some of these\n+     * functions. */\n+#   pragma comment(lib, \"cilkrts\")\n+# endif\n+#endif\n+\n+/* The __CILKRTS_STRAND_PURE attribute tells the compiler that the value\n+ * returned by 'func' for a given argument to 'func' will remain valid until\n+ * the next strand boundary (spawn or sync) or until the next call to a\n+ * function with the __CILKRTS_STRAND_STALE attribute using the same function\n+ * argument.\n+ */\n+#if 0 && defined __cilk && (defined __GNUC__ && !defined _WIN32) && defined __cilkartsrev\n+# define __CILKRTS_STRAND_PURE(func) \\\n+    func __attribute__((__cilk_hyper__(\"lookup\")))\n+# define __CILKRTS_STRAND_STALE(func) \\\n+    func __attribute__((__cilk_hyper__(\"flush\")))\n+#else\n+# define __CILKRTS_STRAND_PURE(func) func\n+# define __CILKRTS_STRAND_STALE(func) func\n+#endif\n+\n+/*****************************************************************************\n+ * C runtime interface to the hyperobject subsystem\n+ *****************************************************************************/\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/* Callback function signatures.  The 'r' argument always points to the\n+ * reducer itself and is commonly ignored. */\n+typedef void (*cilk_c_reducer_reduce_fn_t)(void* r, void* lhs, void* rhs);\n+typedef void (*cilk_c_reducer_identity_fn_t)(void* r, void* view);\n+typedef void (*cilk_c_reducer_destroy_fn_t)(void* r, void* view);\n+typedef void* (*cilk_c_reducer_allocate_fn_t)(void* r, __STDNS size_t bytes);\n+typedef void (*cilk_c_reducer_deallocate_fn_t)(void* r, void* view);\n+\n+/** Representation of the monoid */\n+typedef struct cilk_c_monoid {\n+    cilk_c_reducer_reduce_fn_t          reduce_fn;\n+    cilk_c_reducer_identity_fn_t        identity_fn;\n+    cilk_c_reducer_destroy_fn_t         destroy_fn;\n+    cilk_c_reducer_allocate_fn_t        allocate_fn;\n+    cilk_c_reducer_deallocate_fn_t      deallocate_fn;\n+} cilk_c_monoid;\n+\n+/** Base of the hyperobject */\n+typedef struct __cilkrts_hyperobject_base\n+{\n+    cilk_c_monoid       __c_monoid;\n+    unsigned long long  __flags;\n+    __STDNS ptrdiff_t   __view_offset;  /* offset (in bytes) to leftmost view */\n+    __STDNS size_t      __view_size;    /* Size of each view */\n+} __cilkrts_hyperobject_base;\n+\n+\n+#ifndef CILK_STUB\n+\n+/* Library functions. */\n+CILK_EXPORT\n+    void __cilkrts_hyper_create(__cilkrts_hyperobject_base *key);\n+CILK_EXPORT void __CILKRTS_STRAND_STALE(\n+    __cilkrts_hyper_destroy(__cilkrts_hyperobject_base *key));\n+CILK_EXPORT void* __CILKRTS_STRAND_PURE(\n+    __cilkrts_hyper_lookup(__cilkrts_hyperobject_base *key));\n+\n+CILK_EXPORT\n+    void* __cilkrts_hyperobject_alloc(void* ignore, __STDNS size_t bytes);\n+CILK_EXPORT\n+    void __cilkrts_hyperobject_dealloc(void* ignore, void* view);\n+\n+/* No-op destroy function */\n+CILK_EXPORT\n+    void __cilkrts_hyperobject_noop_destroy(void* ignore, void* ignore2);\n+\n+\n+#else // CILK_STUB\n+\n+// Programs compiled with CILK_STUB are not linked with the Cilk runtime \n+// library, so they should not have external references to cilkrts functions.\n+// Furthermore, they don't need the hyperobject functionality, so the\n+// functions can be stubbed.\n+\n+#define __cilkrts_hyperobject_create __cilkrts_hyperobject_create__stub\n+__CILKRTS_INLINE\n+    void __cilkrts_hyper_create(__cilkrts_hyperobject_base *key) \n+    {}\n+\n+#define __cilkrts_hyperobject_destroy __cilkrts_hyperobject_destroy__stub\n+__CILKRTS_INLINE\n+    void __cilkrts_hyper_destroy(__cilkrts_hyperobject_base *key) \n+    {}\n+\n+#define __cilkrts_hyperobject_lookup __cilkrts_hyperobject_lookup__stub\n+__CILKRTS_INLINE\n+    void* __cilkrts_hyper_lookup(__cilkrts_hyperobject_base *key)\n+    { return (char*)(key) + key->__view_offset; }\n+\n+// Pointers to these functions are stored into monoids, so real functions\n+// are needed.\n+\n+#define __cilkrts_hyperobject_alloc __cilkrts_hyperobject_alloc__stub\n+__CILKRTS_INLINE\n+    void* __cilkrts_hyperobject_alloc(void* ignore, __STDNS size_t bytes)\n+    { assert(0); return __STDNS malloc(bytes); }\n+\n+#define __cilkrts_hyperobject_dealloc __cilkrts_hyperobject_dealloc__stub\n+__CILKRTS_INLINE\n+    void __cilkrts_hyperobject_dealloc(void* ignore, void* view)\n+    { assert(0); __STDNS free(view); }\n+\n+#define __cilkrts_hyperobject_noop_destroy \\\n+            __cilkrts_hyperobject_noop_destroy__stub\n+__CILKRTS_INLINE\n+    void __cilkrts_hyperobject_noop_destroy(void* ignore, void* ignore2)\n+    {}\n+    \n+#endif\n+\n+__CILKRTS_END_EXTERN_C\n+\n+#endif /* INCLUDED_CILK_HYPEROBJECT_BASE */"}, {"sha": "5f6f29df87b9edb3f45a83b90e14166cd74948da", "filename": "libcilkrts/include/cilk/metaprogramming.h", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,606 @@\n+/*  metaprogramming.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2012-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file metaprogramming.h\n+ *\n+ *  @brief Defines metaprogramming utility classes used in the Cilk library.\n+ *\n+ *  @ingroup common\n+ */\n+\n+#ifndef METAPROGRAMMING_H_INCLUDED\n+#define METAPROGRAMMING_H_INCLUDED\n+\n+#ifdef __cplusplus\n+\n+#include <functional>\n+#include <new>\n+#include <cstdlib>\n+#ifdef _WIN32\n+#include <malloc.h>\n+#endif\n+#include <algorithm>\n+\n+namespace cilk {\n+\n+namespace internal {\n+\n+/** Test if a class is empty.\n+ *\n+ *  If @a Class is an empty (and therefore necessarily stateless) class, then\n+ *  the \u201cempty base-class optimization\u201d guarantees that\n+ *  `sizeof(check_for_empty_class<Class>) == sizeof(char)`. Conversely, if\n+ *  `sizeof(check_for_empty_class<Class>) > sizeof(char)`, then @a Class is not\n+ *  empty, and we must discriminate distinct instances of @a Class.\n+ *\n+ *  Typical usage:\n+ *\n+ *      // General definition of A<B> for non-empty B:\n+ *      template <typename B, bool BIsEmpty = class_is_empty<B>::value> >\n+ *      class A { ... };\n+ *\n+ *      // Specialized definition of A<B> for empty B:\n+ *      template <typename B>\n+ *      class A<B, true> { ... };\n+ *\n+ *  @tparam Class   The class to be tested for emptiness.\n+ *\n+ *  @result         The `value` member will be `true` if @a Class is empty,\n+ *                  `false` otherwise.\n+ *\n+ *  @ingroup common\n+ */\n+template <class Class>\n+class class_is_empty { \n+    class check_for_empty_class : public Class\n+    {\n+        char m_data;\n+    public:\n+        // Declared but not defined\n+        check_for_empty_class();\n+        check_for_empty_class(const check_for_empty_class&);\n+        check_for_empty_class& operator=(const check_for_empty_class&);\n+        ~check_for_empty_class();\n+    };\n+public:\n+\n+    /** Constant is true if and only if @a Class is empty.\n+     */\n+    static const bool value = (sizeof(check_for_empty_class) == sizeof(char));\n+};\n+\n+\n+/** Get the alignment of a type.\n+ *\n+ *  For example:\n+ *\n+ *      align_of<double>::value == 8\n+ *\n+ *  @tparam Tp  The type whose alignment is to be computed.\n+ *\n+ *  @result     The `value` member of an instantiation of this class template\n+ *              will hold the integral alignment requirement of @a Tp.\n+ *\n+ *  @pre        @a Tp shall be a complete type.\n+ *\n+ *  @ingroup common\n+ */\n+template <typename Tp>\n+struct align_of\n+{\n+private:\n+    struct imp {\n+        char m_padding;\n+        Tp   m_val;\n+\n+        // The following declarations exist to suppress compiler-generated\n+        // definitions, in case @a Tp does not have a public default\n+        // constructor, copy constructor, or destructor.\n+        imp(const imp&); // Declared but not defined\n+        ~imp();          // Declared but not defined\n+    };\n+\n+public:\n+    /// The integral alignment requirement of @a Tp.\n+    static const std::size_t    value = (sizeof(imp) - sizeof(Tp));\n+};\n+\n+\n+/** A class containing raw bytes with a specified alignment and size.\n+ *\n+ *  An object of type `aligned_storage<S, A>` will have alignment `A` and\n+ *  size at least `S`. Its contents will be uninitialized bytes.\n+ *\n+ *  @tparam Size        The required minimum size of the resulting class.\n+ *  @tparam Alignment   The required alignment of the resulting class.\n+ *\n+ *  @pre    @a Alignment shall be a power of 2 no greater then 64.\n+ *\n+ *  @note   This is implemented using the `CILK_ALIGNAS` macro, which uses\n+ *          the non-standard, implementation-specific features\n+ *          `__declspec(align(N))` on Windows, and \n+ *          `__attribute__((__aligned__(N)))` on Unix. The `gcc` implementation\n+ *          of `__attribute__((__aligned__(N)))` requires a numeric literal `N`\n+ *          (_not_ an arbitrary compile-time constant expression). Therefore,\n+ *          this class is implemented using specialization on the required\n+ *          alignment.\n+ *\n+ *  @note   The template class is specialized only for the supported\n+ *          alignments. An attempt to instantiate it for an unsupported\n+ *          alignment will result in a compilation error.\n+ */\n+template <std::size_t Size, std::size_t Alignment>\n+struct aligned_storage;\n+\n+template<std::size_t Size> class aligned_storage<Size,  1> \n+    { CILK_ALIGNAS( 1) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size,  2> \n+    { CILK_ALIGNAS( 2) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size,  4> \n+    { CILK_ALIGNAS( 4) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size,  8> \n+    { CILK_ALIGNAS( 8) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size, 16> \n+    { CILK_ALIGNAS(16) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size, 32> \n+    { CILK_ALIGNAS(32) char m_bytes[Size]; };\n+template<std::size_t Size> class aligned_storage<Size, 64> \n+    { CILK_ALIGNAS(64) char m_bytes[Size]; };\n+\n+\n+/** A buffer of uninitialized bytes with the same size and alignment as a\n+ *  specified type.\n+ *\n+ *  The class `storage_for_object<Type>` will have the same size and alignment\n+ *  properties as `Type`, but it will contain only raw (uninitialized) bytes.\n+ *  This allows the definition of a data member which can contain a `Type`\n+ *  object which is initialized explicitly under program control, rather\n+ *  than implicitly as part of the initialization of the containing class. \n+ *  For example:\n+ *\n+ *      class C {\n+ *          storage_for_object<MemberClass> _member;\n+ *      public:\n+ *          C() ... // Does NOT initialize _member\n+ *          void initialize(args) \n+ *              { new (_member.pointer()) MemberClass(args); }\n+ *          const MemberClass& member() const { return _member.object(); }\n+ *                MemberClass& member()       { return _member.object(); }\n+ *\n+ *  @tparam Type    The type whose size and alignment are to be reflected\n+ *                  by this class.\n+ */\n+template <typename Type>\n+class storage_for_object : \n+    aligned_storage< sizeof(Type), align_of<Type>::value >\n+{\n+public:\n+    /// Return a typed reference to the buffer.\n+    const Type& object() const { return *reinterpret_cast<Type*>(this); }\n+          Type& object()       { return *reinterpret_cast<Type*>(this); }\n+};\n+\n+\n+/** Get the functor class corresponding to a binary function type.\n+ *\n+ *  The `binary_functor` template class class can be instantiated with a binary\n+ *  functor class or with a real binary function, and will yield an equivalent\n+ *  binary functor class class in either case.\n+ *\n+ *  @tparam F   A binary functor class, a binary function type, or a pointer to\n+ *              binary function type.\n+ *\n+ *  @result     `binary_functor<F>::%type` will be the same as @a F if @a F is\n+ *              a class. It will be a `std::pointer_to_binary_function` wrapper\n+ *              if @a F is a binary function or binary function pointer type.\n+ *              (It will _not_ necessarily be an `Adaptable Binary Function`\n+ *              class, since @a F might be a non-adaptable binary functor\n+ *              class.)\n+ *\n+ *  @ingroup common\n+ */\n+template <typename F>\n+struct binary_functor {\n+     /// The binary functor class equivalent to @a F.\n+     typedef F type;\n+};\n+\n+/// @copydoc binary_functor\n+/// Specialization for binary function.\n+template <typename R, typename A, typename B>\n+struct binary_functor<R(A,B)> {\n+     /// The binary functor class equivalent to @a F.\n+    typedef std::pointer_to_binary_function<A, B, R> type;\n+};\n+\n+/// @copydoc binary_functor\n+/// Specialization for pointer to binary function.\n+template <typename R, typename A, typename B>\n+struct binary_functor<R(*)(A,B)> {\n+     /// The binary functor class equivalent to @a F.\n+    typedef std::pointer_to_binary_function<A, B, R> type;\n+};\n+\n+\n+/** Indirect binary function class with specified types.\n+ *\n+ *  `typed_indirect_binary_function<F>` is an `Adaptable Binary Function` class\n+ *  based on an existing binary functor class or binary function type @a F. If\n+ *  @a F is a stateless class, then this class will be empty, and its\n+ *  `operator()` will invoke @a F\u2019s `operator()`. Otherwise, an object of this\n+ *  class will hold a pointer to an object of type @a F, and will refer its\n+ *  `operator()` calls to the pointed-to @a F object.\n+ *\n+ *  That is, suppose that we have the declarations:\n+ *\n+ *      F *p;\n+ *      typed_indirect_binary_function<F, int, int, bool> ibf(p);\n+ *\n+ *  Then:\n+ *\n+ *  -   `ibf(x, y) == (*p)(x, y)`.\n+ *  -   `ibf(x, y)` will not do a pointer dereference if `F` is an empty class.\n+ *\n+ *  @note       Just to repeat: if `F` is an empty class, then\n+ *              `typed_indirect_binary_function\\<F\\>' is also an empty class.\n+ *              This is critical for its use in the @ref min_max::view_base\n+ *              \"min/max reducer view classes\", where it allows the view to\n+ *              call a comparison functor in the monoid without actually\n+ *              having to allocate a pointer in the view class when the \n+ *              comparison class is empty.\n+ *\n+ *  @note       If you have an `Adaptable Binary Function` class or a binary\n+ *              function type, then you can use the \n+ *              @ref indirect_binary_function class, which derives the\n+ *              argument and result types parameter type instead of requiring\n+ *              you to specify them as template arguments.\n+ *\n+ *  @tparam F   A binary functor class, a binary function type, or a pointer to\n+ *              binary function type.\n+ *  @param A1   The first argument type.\n+ *  @param A2   The second argument type.\n+ *  @param R    The result type.\n+ *\n+ *  @see min_max::comparator_base\n+ *  @see indirect_binary_function\n+ *\n+ *  @ingroup common\n+ */\n+template <  typename F\n+         ,  typename A1\n+         ,  typename A2\n+         ,  typename R\n+         ,  typename Functor    = typename binary_functor<F>::type\n+         ,  bool FunctorIsEmpty = class_is_empty<Functor>::value\n+         >\n+class typed_indirect_binary_function : std::binary_function<A1, A2, R>\n+{\n+    const F* f;\n+public:\n+    /// Constructor captures a pointer to the wrapped function.\n+    typed_indirect_binary_function(const F* f) : f(f) {}\n+    \n+    /// Return the comparator pointer, or `NULL` if the comparator is stateless.\n+    const F* pointer() const { return f; }\n+\n+    /// Apply the pointed-to functor to the arguments.\n+    R operator()(const A1& a1, const A2& a2) const { return (*f)(a1, a2); }\n+};\n+\n+\n+/// @copydoc typed_indirect_binary_function\n+/// Specialization for an empty functor class. (This is only possible if @a F\n+/// itself is an empty class. If @a F is a function or pointer-to-function \n+/// type, then the functor will contain a pointer.)\n+template <typename F, typename A1, typename A2, typename R, typename Functor>\n+class typed_indirect_binary_function<F, A1, A2, R, Functor, true> : \n+    std::binary_function<A1, A2, R>\n+{\n+public:\n+    /// Return `NULL` for the comparator pointer of a stateless comparator.\n+    const F* pointer() const { return 0; }\n+\n+    /// Constructor discards the pointer to a stateless functor class.\n+    typed_indirect_binary_function(const F* f) {}\n+    \n+    /// Create an instance of the stateless functor class and apply it to the arguments.\n+    R operator()(const A1& a1, const A2& a2) const { return F()(a1, a2); }\n+};\n+\n+\n+/** Indirect binary function class with inferred types.\n+ *\n+ *  This is identical to @ref typed_indirect_binary_function, except that it\n+ *  derives the binary function argument and result types from the parameter\n+ *  type @a F instead of taking them as additional template parameters. If @a F\n+ *  is a class type, then it must be an `Adaptable Binary Function`.\n+ *\n+ *  @see typed_indirect_binary_function\n+ *\n+ *  @ingroup common\n+ */\n+template <typename F, typename Functor = typename binary_functor<F>::type>\n+class indirect_binary_function : \n+    typed_indirect_binary_function< F\n+                                  , typename Functor::first_argument_type\n+                                  , typename Functor::second_argument_type\n+                                  , typename Functor::result_type\n+                                  > \n+{\n+    typedef     typed_indirect_binary_function< F\n+                                  , typename Functor::first_argument_type\n+                                  , typename Functor::second_argument_type\n+                                  , typename Functor::result_type\n+                                  > \n+                base;\n+public:\n+    indirect_binary_function(const F* f) : base(f) {} ///< Constructor\n+};\n+\n+\n+/** Choose a type based on a boolean constant.\n+ *\n+ *  This metafunction is identical to C++11\u2019s condition metafunction.\n+ *  It needs to be here until we can reasonably assume that users will be\n+ *  compiling with C++11.\n+ *\n+ *  @tparam Cond    A boolean constant.\n+ *  @tparam IfTrue  A type.\n+ *  @tparam IfFalse A type.\n+ *  @result         The `type` member will be a typedef of @a IfTrue if @a Cond\n+ *                  is true, and a typedef of @a IfFalse if @a Cond is false.\n+ *\n+ *  @ingroup common\n+ */\n+template <bool Cond, typename IfTrue, typename IfFalse>\n+struct condition\n+{\n+    typedef IfTrue type;    ///< The type selected by the condition.\n+};\n+\n+/// @copydoc condition\n+/// Specialization for @a Cond == `false`.\n+template <typename IfTrue, typename IfFalse>\n+struct condition<false, IfTrue, IfFalse>\n+{\n+    typedef IfFalse type;   ///< The type selected by the condition.\n+};\n+\n+\n+/** @def __CILKRTS_STATIC_ASSERT\n+ *\n+ *  @brief Compile-time assertion.\n+ *\n+ *  Causes a compilation error if a compile-time constant expression is false.\n+ *\n+ *  @par    Usage example.\n+ *          This assertion  is used in reducer_min_max.h to avoid defining \n+ *          legacy reducer classes that would not be binary-compatible with the\n+ *          same classes compiled with earlier versions of the reducer library.\n+ *\n+ *              __CILKRTS_STATIC_ASSERT(\n+ *                  internal::class_is_empty< internal::binary_functor<Compare> >::value, \n+ *                  \"cilk::reducer_max<Value, Compare> only works with an empty Compare class\");\n+ *\n+ *  @note   In a C++11 compiler, this is just the language predefined\n+ *          `static_assert` macro.\n+ *\n+ *  @note   In a non-C++11 compiler, the @a Msg string is not directly included\n+ *          in the compiler error message, but it may appear if the compiler\n+ *          prints the source line that the error occurred on.\n+ *\n+ *  @param  Cond    The expression to test.\n+ *  @param  Msg     A string explaining the failure.\n+ *\n+ *  @ingroup common\n+ */\n+#if defined(__INTEL_CXX11_MODE__) || defined(__GXX_EXPERIMENTAL_CXX0X__)\n+#   define  __CILKRTS_STATIC_ASSERT(Cond, Msg) static_assert(Cond, Msg)\n+#else\n+#   define __CILKRTS_STATIC_ASSERT(Cond, Msg)                               \\\n+        typedef int __CILKRTS_STATIC_ASSERT_DUMMY_TYPE                      \\\n+            [::cilk::internal::static_assert_failure<(Cond)>::Success]\n+\n+/// @cond internal\n+    template <bool> struct static_assert_failure { };\n+    template <> struct static_assert_failure<true> { enum { Success = 1 }; };\n+\n+#   define  __CILKRTS_STATIC_ASSERT_DUMMY_TYPE \\\n+            __CILKRTS_STATIC_ASSERT_DUMMY_TYPE1(__cilkrts_static_assert_, __LINE__)\n+#   define  __CILKRTS_STATIC_ASSERT_DUMMY_TYPE1(a, b) \\\n+            __CILKRTS_STATIC_ASSERT_DUMMY_TYPE2(a, b)\n+#   define  __CILKRTS_STATIC_ASSERT_DUMMY_TYPE2(a, b) a ## b\n+/// @endcond\n+\n+#endif\n+\n+/// @cond internal\n+\n+/** @name Aligned heap management.\n+ */\n+//@{\n+\n+/** Implementation-specific aligned memory allocation function.\n+ *\n+ *  @param  size        The minimum number of bytes to allocate.\n+ *  @param  alignment   The required alignment (must be a power of 2).\n+ *  @return             The address of a block of memory of at least @a size\n+ *                      bytes. The address will be a multiple of @a alignment.\n+ *                      `NULL` if the allocation fails.\n+ *\n+ *  @see                deallocate_aligned()\n+ */\n+inline void* allocate_aligned(std::size_t size, std::size_t alignment)\n+{\n+#ifdef _WIN32\n+    return _aligned_malloc(size, alignment);\n+#else\n+#if defined(ANDROID) || defined(__ANDROID__)\n+    return memalign(std::max(alignment, sizeof(void*)), size);\n+#else\n+    void* ptr;\n+    return (posix_memalign(&ptr, std::max(alignment, sizeof(void*)), size) == 0) ? ptr : 0;\n+#endif\n+#endif        \n+}\n+\n+/** Implementation-specific aligned memory deallocation function.\n+ *\n+ *  @param  ptr A pointer which was returned by a call to alloc_aligned().\n+ */\n+inline void deallocate_aligned(void* ptr)\n+{\n+#ifdef _WIN32\n+    _aligned_free(ptr);\n+#else\n+    std::free(ptr);\n+#endif        \n+}\n+\n+/** Class to allocate and guard an aligned pointer.\n+ *\n+ *  A new_aligned_pointer object allocates aligned heap-allocated memory when\n+ *  it is created, and automatically deallocates it when it is destroyed \n+ *  unless its `ok()` function is called.\n+ *\n+ *  @tparam T   The type of the object to allocate on the heap. The allocated\n+ *              will have the size and alignment of an object of type T.\n+ */\n+template <typename T>\n+class new_aligned_pointer {\n+    void* m_ptr;\n+public:\n+    /// Constructor allocates the pointer.\n+    new_aligned_pointer() : \n+        m_ptr(allocate_aligned(sizeof(T), internal::align_of<T>::value)) {}\n+    /// Destructor deallocates the pointer.\n+    ~new_aligned_pointer() { if (m_ptr) deallocate_aligned(m_ptr); }\n+    /// Get the pointer.\n+    operator void*() { return m_ptr; }\n+    /// Return the pointer and release the guard.\n+    T* ok() { \n+        T* ptr = static_cast<T*>(m_ptr);\n+        m_ptr = 0;\n+        return ptr;\n+    }\n+};\n+\n+//@}\n+\n+/// @endcond\n+\n+} // namespace internal\n+\n+//@{\n+\n+/** Allocate an aligned data structure on the heap.\n+ *\n+ *  `cilk::aligned_new<T>([args])` is equivalent to `new T([args])`, except\n+ *  that it guarantees that the returned pointer will be at least as aligned\n+ *  as the alignment requirements of type `T`.\n+ *\n+ *  @ingroup common\n+ */\n+template <typename T>\n+T* aligned_new()\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T();\n+    return ptr.ok();\n+}\n+\n+template <typename T, typename T1>\n+T* aligned_new(const T1& x1)\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T(x1);\n+    return ptr.ok();\n+}\n+\n+template <typename T, typename T1, typename T2>\n+T* aligned_new(const T1& x1, const T2& x2)\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T(x1, x2);\n+    return ptr.ok();\n+}\n+\n+template <typename T, typename T1, typename T2, typename T3>\n+T* aligned_new(const T1& x1, const T2& x2, const T3& x3)\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T(x1, x2, x3);\n+    return ptr.ok();\n+}\n+\n+template <typename T, typename T1, typename T2, typename T3, typename T4>\n+T* aligned_new(const T1& x1, const T2& x2, const T3& x3, const T4& x4)\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T(x1, x2, x3, x4);\n+    return ptr.ok();\n+}\n+\n+template <typename T, typename T1, typename T2, typename T3, typename T4, typename T5>\n+T* aligned_new(const T1& x1, const T2& x2, const T3& x3, const T4& x4, const T5& x5)\n+{\n+    internal::new_aligned_pointer<T> ptr;\n+    new (ptr) T(x1, x2, x3, x4, x5);\n+    return ptr.ok();\n+}\n+\n+//@}\n+\n+\n+/** Deallocate an aligned data structure on the heap.\n+ *\n+ *  `cilk::aligned_delete(ptr)` is equivalent to `delete ptr`, except that it\n+ *  operates on a pointer that was allocated by aligned_new().\n+ *\n+ *  @ingroup common\n+ */\n+template <typename T>\n+void aligned_delete(const T* ptr)\n+{\n+    ptr->~T();\n+    internal::deallocate_aligned((void*)ptr);\n+}\n+\n+} // namespace cilk\n+\n+#endif // __cplusplus\n+\n+#endif // METAPROGRAMMING_H_INCLUDED"}, {"sha": "a22651e1e6f9db577882a979247e9a9d267b54dd", "filename": "libcilkrts/include/cilk/reducer.h", "status": "added", "additions": 1900, "deletions": 0, "changes": 1900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,1900 @@\n+/*  reducer.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+ \n+/** @file reducer.h\n+ *\n+ *  @brief Defines foundation classes for creating Cilk reducers.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  @see @ref pagereducers\n+ *\n+ *  @defgroup Reducers Reducers\n+ */\n+ \n+#ifndef REDUCER_H_INCLUDED\n+#define REDUCER_H_INCLUDED\n+\n+#include \"cilk/hyperobject_base.h\"\n+#include \"cilk/metaprogramming.h\"\n+\n+#ifdef __cplusplus\n+\n+//===================== C++ interfaces ===================================\n+\n+#include <new>\n+\n+namespace cilk {\n+\n+/** Base class for defining monoids.\n+ *\n+ *  The monoid_base class template is useful for creating classes that model\n+ *  the monoid concept. It provides the core type and memory management\n+ *  functionality.  A subclass of monoid_base need only declare and implement\n+ *  the `identity` and `reduce` functions. \n+ *\n+ *  The monoid_base class also manages the integration between the monoid, the\n+ *  reducer class that is based on it, and an optional view class which wraps\n+ *  value objects and restricts access to their operations.\n+ *\n+ *  @tparam Value   The value type for the monoid.\n+ *  @tparam View    An optional view class that serves as a proxy for the value\n+ *                  type.\n+ *\n+ *  @see monoid_with_view\n+ */\n+template <typename Value, typename View = Value>\n+class monoid_base\n+{\n+protected:\n+\n+    /** Class for provisionally constructed objects.\n+     *\n+     *  The monoid_base::construct() functions manually construct both a monoid\n+     *  and a view. If one of these is constructed successfully, and the\n+     *  construction of the other (or some other initialization) fails, then \n+     *  the first one must be destroyed to avoid a memory leak. Because the\n+     *  construction is explicit, the destruction must be explicit, too.\n+     *\n+     *  A provisional_guard object wraps a pointer to a newly constructed\n+     *  object. A call to its confirm() function confirms that the object is\n+     *  really going to be used. If the guard is destroyed without being\n+     *  confirmed, then the pointed-to object is destroyed (but not\n+     *  deallocated).\n+     *  \n+     *  Expected usage:\n+     *\n+     *      provisional_guard<T1> x1_provisional( new (x1) T1() );\n+     *      \u2026 more initialization \u2026\n+     *      x1_provisional.confirm();\n+     *\n+     *  or\n+     *\n+     *      provisional_guard<T1> x1_provisional( new (x1) T1() );\n+     *      x1_provisional.confirm_if( new (x2) T2() );\n+     *\n+     *  If an exception is thrown in the \u201cmore initialization\u201d code in the \n+     *  first example, or in the `T2` constructor in the second example, then\n+     *  `x1_provisional` will not be confirmed, so when its destructor is \n+     *  called during exception unwinding, the `T1` object that was constructed\n+     *  in `x1` will be destroyed.\n+     *\n+     *  @see provisional()\n+     *\n+     *  @tparam Type    The type of the provisionally constructed object.\n+     */\n+    template <typename Type>\n+    class provisional_guard {\n+        Type* m_ptr;\n+    \n+    public:\n+    \n+        /** Constructor. Creates a guard for a provisionally constructed object.\n+         *\n+         *  @param ptr  A pointer to the provisionally constructed object.\n+         */\n+        provisional_guard(Type* ptr) : m_ptr(ptr) {}\n+        \n+        /** Destructor. Destroy the object pointed to by the contained pointer\n+         *  if it has not been confirmed.\n+         */\n+        ~provisional_guard() { if (m_ptr) m_ptr->~Type(); }\n+        \n+        /** Confirm the provisional construction. Do *not* delete the contained\n+         *  pointer when the guard is destroyed.\n+         */\n+        void confirm() { m_ptr = 0; }\n+        \n+        /** Confirm provisional construction if argument is non-null. Note that\n+         *  if an exception is thrown during evaluation of the argument\n+         *  expression, then this function will not be called, and the\n+         *  provisional object will not be confirmed. This allows the usage:\n+         *\n+         *      x1_provisional.confirm_if( new (x2) T2() );\n+         *\n+         *  @param cond An arbitrary pointer. The provisional object will be\n+         *              confirmed if @a cond is not null.\n+         * \n+         *  @returns    The value of the @a cond argument.\n+         */\n+        template <typename Cond>\n+        Cond* confirm_if(Cond* cond) { if (cond) m_ptr = 0; return cond; }\n+    };\n+\n+    \n+    /** Create a provisional_guard object. This function allows simpler code\n+     *  when the only use of a provisional_guard is in a\n+     *  provisional_guard::confirm_if() call immediately following its\n+     *  creation. Instead of\n+     *\n+     *      provisional_guard<T>guard( new (ptr_to_T) T() );\n+     *      guard.confirm_if( new (ptr_to_U) U() );\n+     *\n+     *  you can just write\n+     *\n+     *      provisional( new (ptr_to_T) T() ).confirm_if( new (ptr_to_U) U() );\n+     *\n+     *  @tparam Type    The type of the provisionally constructed object.\n+     *\n+     *  @param  ptr     A pointer to a provisionally constructed object.\n+     *\n+     *  @returns        A @ref provisional_guard object that guards the\n+     *                  provisionally constructed object pointed to by @a ptr.\n+     */\n+    template <typename Type> \n+    static provisional_guard<Type> provisional(Type* ptr) \n+        { return provisional_guard<Type>(ptr); }\n+\n+public:\n+\n+    /** Value type of the monoid.\n+     */\n+    typedef Value   value_type;\n+    \n+    /** View type of the monoid. Defaults to be the same as the value type.\n+     *  @see monoid_with_view\n+     */\n+    typedef View    view_type;\n+    \n+    enum { \n+        /** Should reducers created with this monoid be aligned?\n+         *\n+         *  @details\n+         *  \u201cAligned\u201d means that the view is allocated at a cache-line aligned\n+         *  offset in the reducer, and the reducer must be cache-line aligned.\n+         *  \u201cUnaligned\u201d means that the reducer as a whole is just naturally \n+         *  aligned, but it contains a large enough block of uninitialized \n+         *  storage for a cache-line aligned view to be allocated in it at\n+         *  reducer construction time.\n+         *\n+         *  Since the standard heap allocator (new reducer) does not allocate \n+         *  cache-line aligned storage, only unaligned reducers can be safely\n+         *  allocated on the heap.\n+         *  \n+         *  Default is false (unaligned) unless overridden in a subclass.\n+         *\n+         *  @since 1.02\n+         *  (In Cilk library versions 1.0 and 1.01, the default was true.\n+         *  In Cilk library versions prior to 1.0, reducers were always aligned,\n+         *  and this data member did not exist.)\n+         */\n+        align_reducer = false \n+    };\n+    \n+    /** Destroy a view. Destroys (without deallocating) the @a View object\n+     *  pointed to by @a p.\n+     *\n+     *  @param p    The address of the @a View object to be destroyed.\n+     */\n+    void destroy(view_type* p) const { p->~view_type(); }\n+\n+    /** Allocate raw memory. Allocate @a s bytes of memory with no\n+     *  initialization.\n+     *\n+     *  @param s    The number of bytes of memory to allocate.\n+     *  @return     An untyped pointer to the allocated memory.\n+     */\n+    void* allocate(size_t s) const { return operator new(s); }\n+\n+    /** Deallocate raw memory. Deallocates the memory pointed to by @a p \n+     *  without doing any destruction.\n+     *\n+     *  @param p    Pointer to the memory to be deallocated.\n+     *\n+     *  @pre        @a p points to a block of memory that was allocated by a\n+     *              call to allocate().\n+     */\n+    void deallocate(void* p) const { operator delete(p); }\n+\n+    /** Create the identity value. Constructs (without allocating) a @a View\n+     *  object representing the default value of the @a Value type.\n+     *\n+     *  @param p    A pointer to a block of raw memory large enough to hold a \n+     *              @a View object.\n+     *\n+     *  @post       The memory pointed to by @a p contains a @a View object that\n+     *              represents the default value of the @a View type.\n+     *\n+     *  @deprecated This function constructs the @a View object with its default\n+     *              constructor, which will often, but not always, yield the\n+     *              appropriate identity value. Monoid classes should declare\n+     *              their identity function explicitly, rather than relying on\n+     *              this default definition.\n+     */\n+    void identity(View* p) const { new ((void*) p) View(); }\n+    \n+    \n+    /** @name Construct the monoid and the view with arbitrary arguments.\n+     *\n+     *  A @ref reducer object contains monoid and view data members, which are\n+     *  declared as raw storage (byte arrays), so that they are not implicitly\n+     *  constructed when the reducer is constructed. Instead, a reducer\n+     *  constructor calls one of the monoid class\u2019s static construct() \n+     *  functions with the addresses of the monoid and the view, and the\n+     *  construct() function uses placement `new` to construct them.\n+     *\n+     *  This allows the monoid to determine the order in which the monoid and\n+     *  view are constructed, and to make one of them dependent on the other.\n+     *\n+     *  Any arguments to the reducer constructor are just passed on as \n+     *  additional arguments to the construct() function (after the monoid\n+     *  and view addresses).\n+     *\n+     *  Any monoid whose needs are satisfied by the suite of construct() \n+     *  functions below, such as @ref monoid_with_view, can just inherit them\n+     *  from monoid_base. Other monoids will need to provide their own versions\n+     *  to override the monoid_base functions.\n+     */\n+    //@{\n+    \n+    /** Default-construct the monoid, and pass zero to five const reference\n+     *  arguments to the view constructor.\n+     */\n+    //@{\n+    \n+    template <typename Monoid>\n+    static void construct(Monoid* monoid, View* view)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            (monoid->identity(view), view) ); }\n+\n+    template <typename Monoid, typename T1>\n+    static void construct(Monoid* monoid, View* view, const T1& x1)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1) ); }\n+\n+    template <typename Monoid, typename T1, typename T2>\n+    static void construct(Monoid* monoid, View* view, \n+                            const T1& x1, const T2& x2)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1, x2) ); }\n+\n+    template <typename Monoid, typename T1, typename T2, typename T3>\n+    static void construct(Monoid* monoid, View* view, \n+                            const T1& x1, const T2& x2, const T3& x3)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1, x2, x3) ); }\n+\n+    template <typename Monoid, typename T1, typename T2, typename T3, \n+                typename T4>\n+    static void construct(Monoid* monoid, View* view, \n+                            const T1& x1, const T2& x2, const T3& x3, \n+                            const T4& x4)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1, x2, x3, x4) ); }\n+\n+    template <typename Monoid, typename T1, typename T2, typename T3, \n+                typename T4, typename T5>\n+    static void construct(Monoid* monoid, View* view, \n+                            const T1& x1, const T2& x2, const T3& x3, \n+                            const T4& x4, const T5& x5)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1, x2, x3, x4, x5) ); }\n+        \n+    //@}\n+    \n+    /** Default-construct the monoid, and pass one non-const reference argument\n+     *  to the view constructor.\n+     */\n+    //@{\n+    template <typename Monoid, typename T1>\n+    static void construct(Monoid* monoid, View* view, T1& x1)\n+        { provisional( new ((void*)monoid) Monoid() ).confirm_if( \n+            new ((void*)view) View(x1) ); }\n+    //@}\n+\n+    /** Copy-construct the monoid, and pass zero to four const reference\n+     *  arguments to the view constructor.\n+     */\n+    //@{\n+\n+    template <typename Monoid>\n+    static void construct(Monoid* monoid, View* view, const Monoid& m)\n+        { provisional( new ((void*)monoid) Monoid(m) ).confirm_if( \n+            new ((void*)view) View() ); }\n+\n+    template <typename Monoid, typename T1>\n+    static void construct(Monoid* monoid, View* view, const Monoid& m, \n+                            const T1& x1)\n+        { provisional( new ((void*)monoid) Monoid(m) ).confirm_if( \n+            new ((void*)view) View(x1) ); }\n+        \n+    template <typename Monoid, typename T1, typename T2>\n+    static void construct(Monoid* monoid, View* view, const Monoid& m, \n+                            const T1& x1, const T2& x2)\n+    { provisional( new ((void*)monoid) Monoid(m) ).confirm_if( \n+        new ((void*)view) View(x1, x2) ); }\n+        \n+    template <typename Monoid, typename T1, typename T2, typename T3>\n+    static void construct(Monoid* monoid, View* view, const Monoid& m, \n+                            const T1& x1, const T2& x2, const T3& x3)\n+    {\n+        provisional( new ((void*)monoid) Monoid(m) ).confirm_if(\n+            new ((void*)view) View(x1, x2, x3) );\n+    }\n+        \n+    template <typename Monoid, typename T1, typename T2, typename T3, \n+                typename T4>\n+    static void construct(Monoid* monoid, View* view, const Monoid& m, \n+                            const T1& x1, const T2& x2, const T3& x3, \n+                            const T4& x4)\n+    {\n+        provisional( new ((void*)monoid) Monoid(m) ).confirm_if(\n+            new ((void*)view) View(x1, x2, x3, x4) );\n+    }\n+        \n+    //@}\n+    \n+    //@}\n+};\n+\n+\n+/** Monoid class that gets its value type and identity and reduce operations\n+ *  from its view.\n+ *\n+ *  A simple implementation of the monoid-view-reducer architecture would\n+ *  distribute knowledge about the type and operations for the reduction \n+ *  between the monoid and the view \u2014 the identity and reduction operations are\n+ *  specified in the monoid, the reduction operations are implemented in the\n+ *  view, and the value type is specified in both the monoid and the view.\n+ *  This is inelegant.\n+ *\n+ *  monoid_with_view is a subclass of @ref monoid_base that gets its value type\n+ *  and its identity and reduction operations from its view class. No\n+ *  customization of the monoid_with_view class itself is needed beyond\n+ *  instantiating it with an appropriate view class. (Customized subclasses of\n+ *  monoid_with_view may be needed for other reasons, such as to keep some\n+ *   state for the reducer.) All of the Cilk predefined reducers use\n+ *  monoid_with_view or one of its subclasses.\n+ *  \n+ *  The view class `View` of a monoid_with_view must provide the following public definitions:\n+ *\n+ *  Definition                       | Meaning\n+ *  ---------------------------------|--------\n+ *  `value_type`                     | a typedef of the value type for the reduction\n+ *  `View()`                         | a default constructor which constructs the identity value for the reduction\n+ *  `void\u00a0reduce(const\u00a0View*\u00a0other)` | a member function which applies the reduction operation to the values of `this` view and the `other` view, leaving the result as the value of `this` view, and leaving the value of the `other` view undefined (but valid)\n+ *\n+ *  @tparam View    The view class for the monoid.\n+ *  @tparam Align   If true, reducers instantiated on this monoid will be\n+ *                  cache-aligned. By default, library reducers (unlike legacy\n+ *                  library reducer _wrappers_) are aligned only as required by\n+ *                  contents.\n+ */\n+template <class View, bool Align = false>\n+class monoid_with_view : public monoid_base<typename View::value_type, View>\n+{\n+public:\n+    /** Should reducers created with this monoid be aligned?\n+     */\n+    enum { align_reducer = Align };\n+    \n+    /** Create the identity value.\n+     *\n+     *  Implements the monoid `identity` operation by using the @a View class\u2019s\n+     *  default constructor.\n+     *\n+     *  @param  p   A pointer to a block of raw memory large enough to hold a \n+     *              @p View object.\n+     */\n+    void identity(View* p) const { new ((void*)p) View(); }\n+    \n+    /** Reduce the values of two views.\n+     *\n+     *  Implements the monoid `reduce` operation by calling the left view\u2019s\n+     *  `%reduce()` function with the right view as an operand.\n+     *\n+     *  @param  left    The left operand of the reduce operation.\n+     *  @param  right   The right operand of the reduce operation.\n+     *  @post           The left view contains the result of the reduce\n+     *                  operation, and the right view is undefined.\n+     */\n+    void reduce(View* left, View* right) const { left->reduce(right); }\n+};\n+\n+\n+/** Base class for simple views with (usually) scalar values.\n+ *\n+ *  The scalar_view class is intended as a base class which provides about half\n+ *  of the required definitions for simple views. It defines the `value_type`\n+ *  required by a @ref monoid_with_view (but not the identity constructor and\n+ *  reduce operation, which are inherently specific to a particular kind of\n+ *  reduction). It also defines the value access functions which will be called\n+ *  by the corresponding @ref reducer functions. (It uses copy semantics for \n+ *  the view_move_in() and view_move_out() functions, which is appropriate\n+ *  for simple scalar types, but not necessarily for more complex types like\n+ *  STL containers.\n+ *\n+ *  @tparam Type    The type of value wrapped by the view.\n+ */\n+template <typename Type>\n+class scalar_view\n+{\n+protected:\n+    Type m_value;       ///< The wrapped accumulator variable.\n+\n+public:\n+    /** Value type definition required by @ref monoid_with_view.\n+     */\n+    typedef Type value_type;\n+    \n+    /** Default constructor.\n+     */\n+    scalar_view() : m_value() {}    \n+    \n+    /** Value constructor.\n+     */\n+    scalar_view(const Type& v) : m_value(v) {}\n+    \n+    /** @name Value functions required by the reducer class.\n+     *\n+     *  Note that the move in/out functions use simple assignment semantics.\n+     */\n+    //@{\n+\n+    /** Set the value of the view.\n+     */\n+    void view_move_in(Type& v) { m_value = v; }\n+\n+    /** Get the value of the view.\n+     */\n+    void view_move_out(Type& v) { v = m_value; }\n+\n+    /** Set the value of the view.\n+     */\n+    void view_set_value(const Type& v) { m_value = v; }\n+\n+    /** Get the value of the view.\n+     */\n+    Type const& view_get_value() const { return m_value; }\n+    \n+    /** Get a reference to the value contained in the view. For legacy\n+     *  reducer support only.\n+     */\n+    Type      & view_get_reference()       { return m_value; }\n+    \n+    /** Get a reference to the value contained in the view. For legacy\n+     *  reducer support only.\n+     */\n+    Type const& view_get_reference() const { return m_value; }\n+    //@}\n+};\n+\n+\n+/** Wrapper class for move-in construction.\n+ *\n+ *  Some types allow their values to be _moved_ as an alternative to copying.\n+ *  Moving a value may be much faster than copying it, but may leave the value\n+ *  of the move\u2019s source undefined. Consider the `swap` operation provided by\n+ *  many STL container classes:\n+ *\n+ *      list<T> x, y;\n+ *      x = y;      // Copy\n+ *      x.swap(y);  // Move\n+ *\n+ *  The assignment _copies_ the value of `y` into `x` in time linear in the \n+ *  size of `y`, leaving `y` unchanged. The `swap` _moves_ the  value of `y`\n+ *  into `x` in constant time, but it also moves the value of `x` into `y`,\n+ *  potentially leaving `y` undefined.\n+ *  \n+ *  A move_in_wrapper simply wraps a pointer to an object. It is created by a\n+ *  call to cilk::move_in(). Passing a move_in_wrapper to a view constructor\n+ *  (actually, passing it to a reducer constructor, which passes it to the\n+ *  monoid `construct()` function, which passes it to the view constructor)\n+ *  allows, but does not require, the value pointed to by the wrapper to be\n+ *  moved into the view instead of copied.\n+ *\n+ *  A view class exercises this option by defining a _move-in constructor_,\n+ *  i.e., a constructor with a move_in_wrapper parameter. The constructor calls\n+ *  the wrapper\u2019s `value()` function to get a reference to its pointed-to \n+ *  value, and can then use that reference in a move operation.\n+ *\n+ *  A move_in_wrapper also has an implicit conversion to its pointed-to value,\n+ *  so if a view class does not define a move-in constructor, its ordinary \n+ *  value constructor will be called with the wrapped value. For example, an\n+ *  @ref ReducersAdd \"op_add\" view does not have a move-in constructor, so\n+ *\n+ *      int x;\n+ *      reducer< op_add<int> > xr(move_in(x));\n+ *\n+ *  will simply call the `op_add_view(const int &)` constructor. But an \n+ *  @ref ReducersList \"op_list_append\" view does have a move-in  constructor,\n+ *  so\n+ *\n+ *      list<int> x;\n+ *      reducer< op_list_append<int> > xr(move_in(x));\n+ *\n+ *  will call the `op_list_append_view(move_in_wrapper<int>)` constructor,\n+ *  which can `swap` the value of `x` into the view.\n+ *\n+ *  @note   Remember that passing the value of a variable to a reducer\n+ *          constructor using a move_in_wrapper leaves the variable undefined.\n+ *          You cannot assume that the constructor either will or will not copy\n+ *          or move the value.\n+ *\n+ *  @tparam Type    The type of the wrapped value.\n+ *\n+ *  @see cilk::move_in()\n+ */\n+template <typename Type>\n+class move_in_wrapper\n+{\n+    Type *m_pointer;\n+public:\n+    \n+    /** Constructor that captures the address of its argument. This is almost\n+     *  always called from the @ref move_in function.\n+     */\n+    explicit move_in_wrapper(Type& ref) : m_pointer(&ref) { }\n+    \n+    /** Implicit conversion to the wrapped value. This allows a move_in_wrapper\n+     *  to be used where a value of the wrapped type is expected, in which case\n+     *  the wrapper is completely transparent.\n+     */\n+    operator Type&() const { return *m_pointer; }\n+    \n+    /** Get a reference to the pointed-to value. This has the same effect as \n+     *  the implicit conversion, but makes the intent clearer in a move-in\n+     *  constructor.\n+     */\n+    Type& value() const { return *m_pointer; }\n+};\n+\n+/** Function to create a move_in_wrapper for a value.\n+ *\n+ *  @tparam Type    The type of the argument, which will be the `type` of the \n+ *                  created wrapper.\n+ *\n+ *  @see move_in_wrapper\n+ */\n+template <typename Type>\n+inline\n+move_in_wrapper<Type> move_in(Type& ref)\n+    { return move_in_wrapper<Type>(ref); }\n+\n+\n+/** @copydoc move_in(Type&)\n+ *\n+ *  @note   Applying a function that is explicitly specified as modifying its\n+ *          argument to a const argument is obviously an irrational thing to \n+ *          do. This move_in() variant is just provided to allow calling a\n+ *          move-in constructor with a function return value, which the \n+ *          language treats as a const. Using it for any other purpose will\n+ *          probably end in tears.\n+ */\n+template <typename Type>\n+inline\n+move_in_wrapper<Type> move_in(const Type& ref)\n+    { return move_in_wrapper<Type>(ref); }\n+\n+\n+/** Wrapper class to allow implicit downcasts to reducer subclasses.\n+ *\n+ *  The Cilk library contains a collection of reducer wrapper classes which \n+ *  were created before the `cilk::reducer<Monoid>` style was developed. For \n+ *  example, `cilk::reducer_opadd<Type>` provided essentially the same\n+ *  functionality that is now provided by \n+ *  `cilk::reducer< cilk::op_add<Type> >`. These legacy reducer classes are \n+ *  deprecated, but still supported, and they have been reimplemented as \n+ *  subclasses of the corresponding `cilk::reducer` classes. For example:\n+ *\n+ *      template <class T>\n+ *      reducer_opadd<T> : public reducer< op_add<T> > { ... };\n+ *\n+ *  This reimplementation allows transparent conversion between legacy and \n+ *  new reducers. That is, a `reducer<op_add>*` or `reducer<op_add>&` can be \n+ *  used anywhere that a `reducer_opadd*` or `reducer_opadd&` is expected, \n+ *  and vice versa. \n+ *\n+ *  The conversion from the legacy reducer to the new reducer is just an \n+ *  up-cast, which is provided for free by C++. The conversion from the new \n+ *  reducer to the legacy reducer is a down-cast, though, which requires an \n+ *  explicit conversion member function in the `reducer` class. The challenge\n+ *  is to define a function in the reducer template class which will convert\n+ *  each cilk::reducer specialization to the corresponding legacy reducer, \n+ *  if there is one.\n+ *\n+ *  The trick is in the legacy_reducer_downcast template class, which provides\n+ *  a mapping from  `cilk::reducer` specializations to legacy reducer classes.\n+ *  `reducer<Monoid>` has a conversion function to convert itself to \n+ *  `legacy_reducer_downcast< reducer<Monoid> >::%type`. By default,\n+ *  `legacy_reducer_downcast<Reducer>::%type` is just a trivial subclass of\n+ *  `Reducer`, which is uninteresting, but a reducer with a legacy counterpart\n+ *  will have a specialization of `legacy_reducer_downcast` whose `type` is \n+ *  the corresponding legacy reducer. For example:\n+ *\n+ *      template <typename Type>\n+ *      struct legacy_reducer_downcast< reducer< op_add<Type> > >\n+ *      {\n+ *          typedef reducer_opadd<Type> type;\n+ *      };\n+ *\n+ *\n+ *  @tparam Reducer The new-style reducer class whose corresponding legacy reducer class\n+ *                  is `type`, if there is such a legacy reducer class.\n+ */\n+template <typename Reducer>\n+struct legacy_reducer_downcast\n+{\n+    /** The related legacy reducer class.\n+     *\n+     *  By default, this is just a trivial subclass of Reducer, but it can be \n+     *  overridden in the specialization of legacy_reducer_downcast for \n+     *  a reducer that has a corresponding legacy reducers.\n+     */\n+    struct type : Reducer { };\n+};\n+\n+\n+namespace internal {\n+/// @cond internal\n+\n+template <typename Value, typename View>\n+struct reducer_set_get\n+{\n+    static View theView;  // Declared but not defined\n+\n+    // sizeof(notchar) is guaranteed larger than 1\n+    struct notchar { char x[2]; };\n+\n+    // check_for_ref returns char if 'get_value' returns by value and notchar\n+    // if 'get_value' returns by reference.\n+    static char    check_for_ref(Value,  ...);\n+    static notchar check_for_ref(Value&, int);\n+\n+    enum { GET_VALUE_BY_VALUE =\n+           (1 == sizeof(check_for_ref(theView.view_get_value(), 0))) } ;\n+\n+    typedef typename condition<GET_VALUE_BY_VALUE,\n+                               Value, const Value&>::type get_value_type;\n+\n+    static void move_in(View& view, Value& v)   { view.view_move_in(v); }\n+    static void move_out(View& view,  Value& v) { view.view_move_out(v); }\n+\n+    static void set_value(View& view, const Value& v)\n+        { view.view_set_value(v); }\n+\n+    static get_value_type get_value(const View& view)\n+        { return view.view_get_value(); }\n+};\n+\n+template <typename Value>\n+struct reducer_set_get<Value, Value>\n+{\n+    typedef const Value& get_value_type;\n+\n+    static void move_in(Value& view, Value& v)   { view = v; }\n+    static void move_out(Value& view,  Value& v) { v = view; }\n+\n+    static void set_value(Value& view, const Value& v) { view = v; }\n+\n+    static get_value_type get_value(const Value& view) { return view; }\n+};\n+\n+/// @endcond\n+\n+\n+/** Base class defining the data layout that is common to all reducers.\n+ */\n+template <typename Monoid> \n+class reducer_base {\n+    typedef typename Monoid::view_type view_type;\n+\n+    // This makes the reducer a hyper-object. (Partially initialized in\n+    // the derived reducer_content class.)\n+    //\n+    __cilkrts_hyperobject_base      m_base;\n+\n+    // The monoid is allocated here as raw bytes, and is constructed explicitly\n+    // by a call to the monoid_type::construct() function in the constructor of\n+    // the `reducer` subclass.\n+    //\n+    storage_for_object<Monoid>      m_monoid;\n+\n+    // Used for sanity checking at destruction.\n+    //\n+    void*                           m_initialThis;\n+    \n+    // The leftmost view comes next. It is defined in the derived\n+    // reducer_content class.\n+    \n+    /** @name C-callable wrappers for the C++-coded monoid dispatch functions.\n+     */\n+    //@{\n+    \n+    static void reduce_wrapper(void* r, void* lhs, void* rhs);\n+    static void identity_wrapper(void* r, void* view);\n+    static void destroy_wrapper(void* r, void* view);\n+    static void* allocate_wrapper(void* r, __STDNS size_t bytes);\n+    static void deallocate_wrapper(void* r, void* view);\n+    \n+    //@}\n+\n+protected:\n+\n+    /** Constructor.\n+     *\n+     *  @param  leftmost    The address of the leftmost view in the reducer.\n+     */\n+    reducer_base(char* leftmost) \n+    {\n+        static const cilk_c_monoid c_monoid_initializer = {\n+            (cilk_c_reducer_reduce_fn_t)     &reduce_wrapper,\n+            (cilk_c_reducer_identity_fn_t)   &identity_wrapper,\n+            (cilk_c_reducer_destroy_fn_t)    &destroy_wrapper,\n+            (cilk_c_reducer_allocate_fn_t)   &allocate_wrapper,\n+            (cilk_c_reducer_deallocate_fn_t) &deallocate_wrapper\n+        };\n+\n+        m_base.__c_monoid = c_monoid_initializer;\n+        m_base.__flags = 0;\n+        m_base.__view_offset = (char*)leftmost - (char*)this;\n+        m_base.__view_size = sizeof(view_type);\n+        m_initialThis = this;\n+        \n+        __cilkrts_hyper_create(&m_base);\n+    }\n+    \n+    /** Destructor.\n+     */\n+    __CILKRTS_STRAND_STALE(~reducer_base())\n+    {\n+        // Make sure we haven't been memcopy'd or corrupted\n+        __CILKRTS_ASSERT(\n+            this == m_initialThis ||\n+            // Allow for a layout bug that may put the initialThis field one \n+            // word later in 1.0 reducers than in 0.9  and 1.1 reducers.\n+            this == *(&m_initialThis + 1)\n+        );\n+        __cilkrts_hyper_destroy(&m_base);\n+    }\n+\n+    /** Monoid data member.\n+     *\n+     *  @return A pointer to the reducer\u2019s monoid data member.\n+     */\n+    Monoid* monoid_ptr() { return &m_monoid.object(); }\n+\n+    /** Leftmost view data member.\n+     *\n+     *  @return A pointer to the reducer\u2019s leftmost view data member.\n+     *\n+     *  @note   This function returns the address of the *leftmost* view, \n+     *          which is unique for the lifetime of the reducer. It is \n+     *          intended to be used in constructors and destructors. \n+     *          Use the reducer::view() function to access the per-strand \n+     *          view instance.\n+     */\n+    view_type* leftmost_ptr() \n+    {\n+        char* view_addr = (char*)this + m_base.__view_offset;\n+        return reinterpret_cast<view_type*>(view_addr);\n+    }\n+    \n+public:\n+\n+    /** @name Access the current view.\n+     *\n+     *  These functions return a reference to the instance of the reducer\u2019s \n+     *  view that was created for the current strand of a parallel computation\n+     *  (and create it if it doesn\u2019t already exist). Note the difference from\n+     *  the (private) leftmost_ptr() function, which returns a pointer to the\n+     *  _leftmost_ view, which is the same in all strands.\n+     */\n+    //@{\n+    \n+    /** Per-strand view instance.\n+     *\n+     *  @return A reference to the per-strand view instance.\n+     */\n+    view_type& view() \n+    {\n+        return *static_cast<view_type *>(__cilkrts_hyper_lookup(&m_base)); \n+    }\n+    \n+    /** @copydoc view()\n+     */\n+    const view_type& view() const \n+    { \n+        return const_cast<reducer_base*>(this)->view(); \n+    }\n+    \n+    //@}\n+    \n+    /** Initial view pointer field.\n+     *\n+     *  @internal\n+     *\n+     *  @return a reference to the m_initialThis field.\n+     *\n+     *  @note   This function is provided for \u201cwhite-box\u201d testing of the\n+     *          reducer layout code. There is never any reason for user code\n+     *          to call it.\n+     */\n+    const void* const & initial_this() const { return m_initialThis; }\n+};\n+\n+template <typename Monoid>\n+void reducer_base<Monoid>::reduce_wrapper(void* r, void* lhs, void* rhs)\n+{\n+    Monoid* monoid = static_cast<reducer_base*>(r)->monoid_ptr();\n+    monoid->reduce(static_cast<view_type*>(lhs),\n+                         static_cast<view_type*>(rhs));\n+}\n+\n+template <typename Monoid>\n+void reducer_base<Monoid>::identity_wrapper(void* r, void* view)\n+{\n+    Monoid* monoid = static_cast<reducer_base*>(r)->monoid_ptr();\n+    monoid->identity(static_cast<view_type*>(view));\n+}\n+\n+template <typename Monoid>\n+void reducer_base<Monoid>::destroy_wrapper(void* r, void* view)\n+{\n+    Monoid* monoid = static_cast<reducer_base*>(r)->monoid_ptr();\n+    monoid->destroy(static_cast<view_type*>(view));\n+}\n+\n+template <typename Monoid>\n+void* reducer_base<Monoid>::allocate_wrapper(void* r, __STDNS size_t bytes)\n+{\n+    Monoid* monoid = static_cast<reducer_base*>(r)->monoid_ptr();\n+    return monoid->allocate(bytes);\n+}\n+\n+template <typename Monoid>\n+void reducer_base<Monoid>::deallocate_wrapper(void* r, void* view)\n+{\n+    Monoid* monoid = static_cast<reducer_base*>(r)->monoid_ptr();\n+    monoid->deallocate(static_cast<view_type*>(view));\n+}\n+\n+\n+/** Base class defining the data members of a reducer.\n+ *\n+ *  @tparam Aligned The `m_view` data member, and therefore the entire \n+ *                  structure, are cache-line aligned if this parameter\n+ *                  is `true'.\n+ */\n+template <typename Monoid, bool Aligned = Monoid::align_reducer>\n+class reducer_content;\n+\n+/** Base class defining the data members of an aligned reducer.\n+ */\n+template <typename Monoid>\n+class reducer_content<Monoid, true> : public reducer_base<Monoid>\n+{\n+    typedef typename Monoid::view_type view_type;\n+    \n+    // The leftmost view is defined as raw bytes. It will be constructed\n+    // by the monoid `construct` function. It is cache-aligned, which \n+    // will push it into a new cache line. Furthermore, its alignment causes\n+    // the reducer as a whole to be cache-aligned, which makes the reducer \n+    // size a multiple of a cache line. Since there is nothing in the reducer \n+    // after the view, all this means that the leftmost view gets one or more\n+    // cache lines all to itself, which prevents false sharing.\n+    //\n+    __CILKRTS_CACHE_ALIGN\n+    char m_leftmost[sizeof(view_type)];\n+\n+    /** Test if the reducer is cache-line-aligned.\n+     *\n+     *  Used in assertions.\n+     */\n+    bool reducer_is_cache_aligned() const\n+        { return 0 == ((std::size_t) this & (__CILKRTS_CACHE_LINE__ - 1)); }\n+        \n+protected:\n+\n+    /** Constructor.\n+     */\n+    reducer_content() : reducer_base<Monoid>((char*)&m_leftmost)\n+    {\n+#ifndef CILK_IGNORE_REDUCER_ALIGNMENT\n+    assert(reducer_is_cache_aligned() &&\n+           \"Reducer should be cache aligned. Please see comments following this assertion for explanation and fixes.\");\n+#endif\n+    /*  \"REDUCER SHOULD BE CACHE ALIGNED\" ASSERTION.\n+     *\n+     *  This Reducer class instantiation specifies cache-line alignment of the \n+     *  leftmost view field (and, implicitly, of the reducer itself). You got\n+     *  this assertion because a reducer with this class was allocated at a\n+     *  non-cache-aligned address, probably because it was allocated on the \n+     *  heap with `new`. This can be a problem for two reasons:\n+     *\n+     *  1.  If the leftmost view is not on a cache line by itself, there might\n+     *      be a slowdown resulting from accesses to the same cache line from\n+     *      different threads.\n+     *\n+     *  2.  The compiler thinks that reducer is cache-line aligned, but it\n+     *      really isn't. If the reducer is contained in a structure, then the\n+     *      compiler will believe that the containing structure, and other\n+     *      fields contained in it, are also more aligned than they really\n+     *      are. In particular, if the structure contains a numeric array that\n+     *      is used in a vectorizable loop, then the compiler might generate\n+     *      invalid vector instructions, resulting in a runtime error.\n+     *\n+     *  The compiler will always allocate reducer variables, and structure\n+     *  variables containing reducers, with their required alignment.\n+     *  Reducers, and structures containing a reducer, which are allocated\n+     *  on the heap with `new` will _not_ be properly aligned.\n+     *\n+     *  There are three ways that you can fix this assertion failure.\n+     *\n+     *  A.  Rewrite your code to use the new-style `reducer< op_XXX<Type> >` \n+     *      instead of the legacy `reducer_XXX<type>`. The new-style reducers\n+     *      are not declared to be cache-aligned, and will work properly if\n+     *      they are not cache-aligned.\n+     *\n+     *  B.  If you must allocate an old-style reducer or a structure containing\n+     *      a reducer on the heap, figure out how to align it correctly. The\n+     *      suggested fix is to use `cilk::aligned_new()` and \n+     *      `cilk::aligned_delete()` instead of `new` and `delete`, as follows:\n+     *\n+     *          Type* ptr = cilk::aligned_new<Type>(constructor-arguments);\n+     *          cilk::aligned_delete(ptr);\n+     *\n+     *  C.  Define the macro CILK_IGNORE_REDUCER_ALIGNMENT, which will suppress\n+     *      the assertion check. Do this only if you are comfortable that\n+     *      problem (2) above will not occur.\n+     */\n+    }\n+};\n+\n+/** Base class defining the data members of an unaligned reducer.\n+ */\n+template <typename Monoid>\n+class reducer_content<Monoid, false> : public reducer_base<Monoid>\n+{\n+    typedef typename Monoid::view_type view_type;      ///< The view type.\n+\n+    // Reserve space for the leftmost view. The view will be allocated at an\n+    // aligned offset in this space at runtime, to guarantee that the view\n+    // will get one or more cache lines all to itself, to prevent false \n+    // sharing.\n+    //\n+    // The number of bytes to reserve is determined as follows:\n+    // * Start with the view size.\n+    // * Round up to a multiple of the cache line size, to get the total size\n+    //   of the cache lines that will be dedicated to the view.\n+    // * Add (cache line size - 1) filler bytes to guarantee that the reserved\n+    //   area will contain a cache-aligned block of the required cache lines,\n+    //   no matter where the reserved area starts.\n+    //\n+    char m_leftmost[\n+        // View size rounded up to multiple cache lines\n+        (   (sizeof(view_type) + __CILKRTS_CACHE_LINE__ - 1)\n+            & ~ (__CILKRTS_CACHE_LINE__ - 1)\n+        )\n+        // plus filler to allow alignment.\n+        + __CILKRTS_CACHE_LINE__ - 1\n+        ];\n+\n+protected:\n+\n+    /** Constructor. Find the first cache-aligned position in the reserved\n+     *  area, and pass it to the base constructor as the leftmost view \n+     *  address.\n+     */\n+    reducer_content() : \n+        reducer_base<Monoid>(\n+            (char*)( ((std::size_t)&m_leftmost + __CILKRTS_CACHE_LINE__ - 1)\n+                     & ~ (__CILKRTS_CACHE_LINE__ - 1) ) )\n+    {}\n+};\n+\n+\n+} // namespace internal\n+\n+\n+// The __cilkrts_hyperobject_ functions are defined differently depending on\n+// whether a file is compiled with or without the CILK_STUB option. Therefore,\n+// reducers compiled in the two modes should be link-time incompatible, so that\n+// object files compiled with stubbed reducers won't be linked into an\n+// unstubbed program, or vice versa. We achieve this by putting the reducer\n+// class definition into the cilk::stub namespace in a stubbed compilation.\n+\n+#ifdef CILK_STUB\n+namespace stub {\n+#endif\n+\n+/** Reducer class.\n+ *\n+ *  A reducer is instantiated on a Monoid.  The Monoid provides the value\n+ *  type, associative reduce function, and identity for the reducer.\n+ *\n+ *  @tparam Monoid  The monoid class that the reducer is instantiated on. It must model\n+ *                  the @ref reducers_monoid_concept \"monoid concept\".\n+ *\n+ *  @see @ref pagereducers\n+ */\n+template <class Monoid>\n+class reducer : public internal::reducer_content<Monoid>\n+{\n+    typedef internal::reducer_content<Monoid> base;\n+    using base::monoid_ptr;\n+    using base::leftmost_ptr;\n+  public:\n+    typedef Monoid                          monoid_type;    ///< The monoid type.\n+    typedef typename Monoid::value_type     value_type;     ///< The value type.\n+    typedef typename Monoid::view_type      view_type;      ///< The view type.\n+\n+  private:\n+    typedef internal::reducer_set_get<value_type, view_type> set_get;\n+    \n+    reducer(const reducer&);                ///< Disallow copying.\n+    reducer& operator=(const reducer&);     ///< Disallow assignment.\n+\n+  public:\n+  \n+    /** @name Constructors\n+     *\n+     *  All reducer constructors call the static `construct()` function of the monoid class to\n+     *  construct the reducer's monoid and leftmost view. \n+     *\n+     *  The reducer constructor arguments are simply passed through to the construct() function.\n+     *  Thus, the constructor parameters accepted by a particular reducer class are determined\n+     *  by its monoid class.\n+     */\n+    //@{\n+\n+    /** 0 \u2013 6 const reference parameters.\n+     */\n+    //@{\n+    \n+    reducer()\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr());\n+    }\n+\n+    template <typename T1>\n+    reducer(const T1& x1)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1);\n+    }\n+\n+    template <typename T1, typename T2>\n+    reducer(const T1& x1, const T2& x2)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1, x2);\n+    }\n+\n+    template <typename T1, typename T2, typename T3>\n+    reducer(const T1& x1, const T2& x2, const T3& x3)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1, x2, x3);\n+    }\n+\n+    template <typename T1, typename T2, typename T3, typename T4>\n+    reducer(const T1& x1, const T2& x2, const T3& x3, const T4& x4)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1, x2, x3, x4);\n+    }\n+\n+    template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+    reducer(const T1& x1, const T2& x2, const T3& x3, const T4& x4, const T5& x5)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1, x2, x3, x4, x5);\n+    }\n+\n+    template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n+    reducer(const T1& x1, const T2& x2, const T3& x3, const T4& x4, const T5& x5, const T6& x6)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1, x2, x3, x4, x5, x6);\n+    }\n+    \n+    //@}\n+    \n+    /** 1 non-const reference parameter.\n+     */\n+    //@{\n+\n+    template <typename T1>\n+    reducer(T1& x1)\n+    {\n+        monoid_type::construct(monoid_ptr(), leftmost_ptr(), x1);\n+    }\n+    \n+    //@}\n+\n+    /** Destructor.\n+     */\n+    __CILKRTS_STRAND_STALE(~reducer())\n+    {\n+        leftmost_ptr()->~view_type();\n+        monoid_ptr()->~monoid_type();\n+    }\n+\n+    //@{\n+    /** Get the monoid.\n+     *\n+     *  @return A reference to the monoid object belonging to this reducer.\n+     */\n+    Monoid& monoid() { return *monoid_ptr(); }\n+    \n+    const Monoid& monoid() const \n+    { return const_cast<reducer*>(this)->monoid(); }\n+    //@}\n+\n+    //@{\n+    /** Access the current view.\n+     *\n+     *  Return a reference to the instance of the reducer\u2019s view that was \n+     *  created for the current strand of a parallel computation (and create\n+     *  it if it doesn\u2019t already exist).\n+     */\n+          view_type& view()       { return base::view(); }\n+    const view_type& view() const { return base::view(); }\n+    //@}\n+        \n+\n+    /** @name Dereference the reducer to get the view.\n+     *\n+     *  \u201cDereferencing\u201d a reducer yields the view for the current strand. The\n+     *  view, in turn, acts as a proxy for its contained value, exposing only\n+     *  those operations which are consistent with the reducer\u2019s monoid. Thus,\n+     *  all modifications of the reducer\u2019s accumulator variable are written as\n+     *\n+     *      *reducer OP ...\n+     *\n+     *  or\n+     *\n+     *      reducer->func(...)\n+     *\n+     *  (The permitted operations on a reducer\u2019s accumulator are listed in the\n+     *  documentation for that particular kind of reducer.)\n+     *\n+     *  @note   `*r` is a synonym for `r.view()`. Recommended style is to use\n+     *          `*r` (or `r->`) in the common case where code is simply\n+     *          updating the accumulator variable wrapped in the view, and to\n+     *          use `r.view()` in the unusual case where it is desirable to\n+     *          call attention to the view itself.\n+     */\n+    //@{\n+    \n+    //@{\n+    /** Dereference operator.\n+     *\n+     *  @return A reference to the per-strand view instance.\n+     */\n+    view_type&       operator*()       { return view(); }\n+    view_type const& operator*() const { return view(); }\n+    //@}\n+\n+    //@{\n+    /** Pointer operator.\n+     *\n+     *  @return A pointer to the per-strand view instance.\n+     */\n+    view_type*       operator->()       { return &view(); }\n+    view_type const* operator->() const { return &view(); }\n+    //@}\n+    \n+    //@{\n+    /** Deprecated view access.\n+     *\n+     *  `r()` is a synonym for `*r` which was used with early versions of Cilk\n+     *  reducers. `*r` is now the preferred usage.\n+     *\n+     *  @deprecated Use operator*() instead of operator()().\n+     *\n+     *  @return A reference to the per-strand view instance.\n+     */\n+    view_type&       operator()()       { return view(); }\n+    view_type const& operator()() const { return view(); }\n+    //@}\n+    \n+    //@}\n+    \n+    /** @name Set and get the value.\n+     *\n+     *  These functions are used to set an initial value for the reducer before\n+     *  starting the reduction, or to get the final value after the reduction\n+     *  is complete.\n+     *\n+     *  @note   These functions are completely different from the view\n+     *          operations that are made available via operator*() and\n+     *          operator->(), which are used to _modify_ the reducer\u2019s value\n+     *          _during_ the reduction.\n+     *\n+     *  @warning    These functions _can_ be called at any time, and in \n+     *              general, they will refer to the value contained in the view\n+     *              for the current strand. However, using them other than to\n+     *              set the reduction\u2019s initial value or get its final value\n+     *              will almost always result in undefined behavior.\n+     */\n+    //@{\n+\n+    /** Move a value into the reducer.\n+     *\n+     *  This function is used to set the initial value of the reducer\u2019s\n+     *  accumulator variable by either copying or _moving_ the value of @a obj\n+     *  into it. Moving a value can often be performed in constant time, even\n+     *  for large container objects, but has the side effect of leaving the\n+     *  value of @a obj undefined. (See the description of the \n+     *  @ref move_in_wrapper class for a discussion of moving values.) \n+     *\n+     *  @par    Usage\n+     *          A move_in() call to initialize a reducer is often paired with a\n+     *          move_out() call to get its final value:\n+     *\n+     *              reducer<Type> xr;\n+     *              xr.move_in(x);\n+     *              \u2026 do the reduction \u2026\n+     *              xr.move_out(x);\n+     *\n+     *  @par Assumptions\n+     *      -   You cannot assume either that this will function will copy its\n+     *          value or that it will move it. \n+     *      -   You must assume that the value of @a obj will be undefined \n+     *          after the call to move_in(). \n+     *      -   You can assume that move_in() will be at least as efficient as\n+     *          set_value(), and you should therefore prefer move_in() unless\n+     *          you need the value of @a obj to be unchanged after the call.\n+     *          (But you should usually prefer the move-in constructor over a\n+     *          move_in() call \u2014 see the note below.)\n+     *\n+     *  @note   The behavior of a default constructor followed by move-in\n+     *          initialization:\n+     *\n+     *              reducer<Type> xr;\n+     *              xr.move_in(x);\n+     *\n+     *  @note   is not necessarily the same as a move-in constructor:\n+     *\n+     *      reducer<Type> xr(move_in(x));\n+     * \n+     *  @note   In particular, when @a Type is a container type with a \n+     *          non-empty allocator, the move-in constructor will create the\n+     *          accumulator variable with the same allocator as the input\n+     *          argument @a x, while the default constructor will create the\n+     *          accumulator variable with a default allocator. The mismatch of\n+     *          allocators in the latter case means that the input argument \n+     *          @a x may have to be copied in linear time instead of being \n+     *          moved in constant time.\n+     *\n+     *  @note   Best practice is to prefer the move-in constructor over the\n+     *          move-in function unless the move-in function is required for\n+     *          some specific reason.\n+     *\n+     *  @warning    Calling this function other than to set the initial value\n+     *              for a reduction will almost always result in undefined\n+     *              behavior.\n+     *\n+     *  @param  obj The object containing the value that will be moved into the\n+     *              reducer.\n+     *\n+     *  @post   The reducer contains the value that was initially in @a obj.\n+     *  @post   The value of @a obj is undefined.\n+     *\n+     *  @see set_value()\n+     */\n+    void move_in(value_type& obj) { set_get::move_in(view(), obj);}\n+\n+    /** Move the value out of the reducer.\n+     *\n+     *  This function is used to retrieve the final value of the reducer\u2019s\n+     *  accumulator variable by either copying or _moving_ the value of @a obj\n+     *  into it. Moving a value can often be performed in constant time, even\n+     *  for large container objects, but has the side effect of leaving the\n+     *  value of the reducer\u2019s accumulator variable undefined. (See the\n+     *  description of the @ref move_in_wrapper class for a discussion of \n+     *  moving values.) \n+     *\n+     *  @par    Usage\n+     *          A move_in() call to initialize a reducer is often paired with a\n+     *          move_out() call to get its final value:\n+     *\n+     *              reducer<Type> xr;\n+     *              xr.move_in(x);\n+     *              \u2026 do the reduction \u2026\n+     *              xr.move_out(x);\n+     *\n+     *  @par Assumptions\n+     *      -   You cannot assume either that this will function will copy its\n+     *          value or that it will move it. \n+     *      -   You must assume that the value of the reducer\u2019s accumulator\n+     *          variable will be undefined after the call to move_out().\n+     *      -   You can assume that move_out() will be at least as efficient as\n+     *          get_value(), and you should therefore prefer move_out() unless\n+     *          you need the accumulator variable to be preserved after the\n+     *          call.\n+     *\n+     *  @warning    Calling this function other than to retrieve the final \n+     *              value of a reduction will almost always result in undefined\n+     *              behavior.\n+     *\n+     *  @param  obj The object that the value of the reducer will be moved into.\n+     *\n+     *  @post   @a obj contains the value that was initially in the reducer.\n+     *  @post   The value of the reducer is undefined.\n+     *\n+     *  @see get_value()\n+     */\n+    void move_out(value_type& obj) { set_get::move_out(view(), obj); }\n+\n+    /** Set the value of the reducer.\n+     *\n+     *  This function sets the initial value of the reducer\u2019s accumulator\n+     *  variable to the value of @a obj.\n+     *\n+     *  @note   The behavior of a default constructor followed by\n+     *          initialization:\n+     *\n+     *      reducer<Type> xr;\n+     *      xr.set_value(x);\n+     *\n+     *  @note   is not necessarily the same as a value constructor:\n+     *\n+     *      reducer<Type> xr(x);\n+     * \n+     *  @note   In particular, when @a Type is a container type with a \n+     *          non-empty allocator, the value constructor will create the\n+     *          accumulator variable with the same allocator as the input\n+     *          argument @a x, while the default constructor will create the\n+     *          accumulator variable with a default allocator.\n+     *\n+     *  @warning    Calling this function other than to set the initial value\n+     *              for a reduction will almost always result in undefined\n+     *              behavior.\n+     *\n+     *  @param  obj The object containing the value that will be copied into \n+     *              the reducer.\n+     *\n+     *  @post   The reducer contains a copy of the value in @a obj.\n+     *\n+     *  @see move_in()\n+     */\n+    void set_value(const value_type& obj) { set_get::set_value(view(), obj); }\n+\n+    /** Get the value of the reducer.\n+     *\n+     *  This function gets the final value of the reducer\u2019s accumulator\n+     *  variable.\n+     *\n+     *  @warning    Calling this function other than to retrieve the final \n+     *              value of a reduction will almost always result in undefined\n+     *              behavior.\n+     *\n+     *  @return     A reference to the value contained in the reducer.\n+     *\n+     *  @see move_out()\n+     */\n+    typename set_get::get_value_type get_value() const \n+        { return set_get::get_value(view()); }\n+    \n+    //@}\n+\n+    /** Implicit downcast to legacy reducer wrapper, if any.\n+     *\n+     *  @see legacy_reducer_downcast\n+     */\n+    operator typename legacy_reducer_downcast<reducer>::type& ()\n+    {\n+        typedef typename legacy_reducer_downcast<reducer>::type downcast_type;\n+        return *reinterpret_cast<downcast_type*>(this);\n+    }\n+\n+\n+    /** Implicit downcast to legacy reducer wrapper, if any.\n+     *\n+     *  @see legacy_reducer_downcast\n+     */\n+    operator const typename legacy_reducer_downcast<reducer>::type& () const\n+    {\n+        typedef typename legacy_reducer_downcast<reducer>::type downcast_type;\n+        return *reinterpret_cast<const downcast_type*>(this);\n+    }\n+};\n+\n+#ifdef CILK_STUB\n+} // namespace stub\n+using stub::reducer;\n+#endif\n+\n+} // end namespace cilk\n+\n+#endif /* __cplusplus */\n+\n+/** @page page_reducers_in_c Creating and Using Reducers in C\n+ *\n+ *  @tableofcontents\n+ *  \n+ *  The Cilk runtime supports reducers written in C as well as in C++. The basic logic is the\n+ *  same, but the implementation details are very different. The C++ reducer implementation uses\n+ *  templates heavily to create very generic components. The C reducer implementation uses\n+ *  macros, which are a much blunter instrument. The most immediate consequence is that the \n+ *  monoid/view/reducer architecture is mostly implicit rather than explicit in C reducers.\n+ *  \n+ *  @section reducers_c_overview Overview of Using Reducers in C\n+ *  \n+ *  The basic usage pattern for C reducers is:\n+ *  \n+ *  1.  Create and initialize a reducer object.\n+ *  2.  Tell the Cilk runtime about the reducer.\n+ *  3.  Update the value contained in the reducer in a parallel computation.\n+ *  4.  Tell the Cilk runtime that you are done with the reducer.\n+ *  5.  Retrieve the value from the reducer.\n+ *  \n+ *  @subsection reducers_c_creation Creating and Initializing a C Reducer\n+ *  \n+ *  The basic pattern for creating and initializing a reducer object in C is\n+ *  \n+ *      CILK_C_DECLARE_REDUCER(value-type) reducer-name =\n+ *          CILK_C_INIT_REDUCER(value-type,\n+ *                              reduce-function,\n+ *                              identity-function,\n+ *                              destroy-function,\n+ *                              initial-value);\n+ *                              \n+ *  This is simply an initialized definition of a variable named _reducer-name_. The\n+ *  @ref CILK_C_DECLARE_REDUCER macro expands to an anonymous `struct` declaration for a reducer \n+ *  object containing a view of type _value-type_, and the @ref CILK_C_INIT_REDUCER macro\n+ *  expands to a struct initializer.\n+ *  \n+ *  @subsection reducers_c_reduce_func Reduce Functions\n+ *  \n+ *  The reduce function for a reducer is called when a parallel execution strand terminates, to\n+ *  combine the values computed by the terminating strand and the strand to its left. It takes\n+ *  three arguments:\n+ *  \n+ *  -   `void* reducer` \u2014 the address of the reducer.\n+ *  -   `void* left` \u2014 the address of the value for the left strand.\n+ *  -   `void* right` \u2014 the address of the value for the right (terminating) strand.\n+ *  \n+ *  It must apply the reducer\u2019s reduction operation to the `left` and `right` values, leaving\n+ *  the result in the `left` value. The `right` value is undefined after the reduce function\n+ *  call.\n+ *  \n+ *  @subsection reducers_c_identity_func Identity Functions\n+ *  \n+ *  The identity function for a reducer is called when a parallel execution strand begins, to\n+ *  initialize its value to the reducer\u2019s identity value. It takes two arguments:\n+ *  \n+ *  -   `void* reducer` \u2014 the address of the reducer.\n+ *  -   `void* v` \u2014 the address of a freshly allocated block of memory of size\n+ *      `sizeof(value-type)`.\n+ *  \n+ *  It must initialize the memory pointed to by `v` so that it contains the reducer\u2019s identity \n+ *  value.\n+ *  \n+ *  @subsection reducers_c_destroy_func Destroy Functions\n+ *  \n+ *  The destroy function for a reducer is called when a parallel execution strand terminates, to\n+ *  do any necessary cleanup before its value is deallocated. It takes two arguments:\n+ *  \n+ *  -   `void* reducer` \u2014 the address of the reducer.\n+ *  -   `void* p` \u2014 the address of the value for the terminating strand.\n+ *  \n+ *  It must release any resources belonging to the value pointed to by `p`, to avoid a resource \n+ *  leak when the memory containing the value is deallocated.\n+ *  \n+ *  The runtime function `__cilkrts_hyperobject_noop_destroy` can be used for the destructor \n+ *  function if the reducer\u2019s values do not need any cleanup.\n+ *  \n+ *  @subsection reducers_c_register Tell the Cilk Runtime About the Reducer\n+ *  \n+ *  Call the @ref CILK_C_REGISTER_REDUCER macro to register the reducer with the Cilk runtime:\n+ *  \n+ *      CILK_C_REGISTER_REDUCER(reducer-name);\n+ *  \n+ *  The runtime will manage reducer values for all registered reducers when parallel execution \n+ *  strands begin and end.\n+ *  \n+ *  @subsection reducers_c_update Update the Value Contained in the Reducer\n+ *  \n+ *  The @ref REDUCER_VIEW macro returns a reference to the reducer\u2019s value for the  current\n+ *  parallel strand:\n+ *  \n+ *      REDUCER_VIEW(reducer-name) = REDUCER_VIEW(reducer-name) OP x;\n+ *      \n+ *  C++ reducer views restrict access to the wrapped value so that it can only be modified in\n+ *  ways consistent with the reducer\u2019s operation. No such protection is provided for C reducers.\n+ *  It is\n+ *  entirely the responsibility of the user to avoid modifying the value in any\n+ *  inappropriate way.\n+ *  \n+ *  @subsection c_reducers_unregister Tell the Cilk Runtime That You Are Done with the Reducer\n+ *  \n+ *  When the parallel computation is complete, call the @ref CILK_C_UNREGISTER_REDUCER macro to \n+ *  unregister the reducer with the Cilk runtime:\n+ *  \n+ *      CILK_C_UNREGISTER_REDUCER(reducer-name);\n+ *  \n+ *  The runtime will stop managing reducer values for the reducer.\n+ *  \n+ *  @subsection c_reducers_retrieve Retrieve the Value from the Reducer\n+ *  \n+ *  When the parallel computation is complete, use the @ref REDUCER_VIEW macro to retrieve the\n+ *  final value computed by the reducer.\n+ *  \n+ *  @subsection reducers_c_example_custom Example \u2014 Creating and Using a Custom C Reducer\n+ *  \n+ *  The `IntList` type represents a simple list of integers.\n+ *  \n+ *      struct _intListNode {\n+ *          int value;\n+ *          _intListNode* next;\n+ *      } IntListNode;\n+ *      typedef struct { IntListNode* head; IntListNode* tail; } IntList;\n+ *      \n+ *      // Initialize a list to be empty\n+ *      void IntList_init(IntList* list) { list->head = list->tail = 0; }\n+ *      \n+ *      // Append an integer to the list\n+ *      void IntList_append(IntList* list, int x) \n+ *      { \n+ *          IntListNode* node = (IntListNode*) malloc(sizeof(IntListNode));\n+ *          if (list->tail) list->tail->next = node; else list->head = node;\n+ *          list->tail = node;\n+ *      }\n+ *      \n+ *      // Append the right list to the left list, and leave the right list empty\n+ *      void IntList_concat(IntList* left, IntList* right)\n+ *      {\n+ *          if (left->head) {\n+ *              left->tail->next = right->head;\n+ *              if (right->tail) left->tail = right->tail;\n+ *          }\n+ *          else {\n+ *              *left = *right;\n+ *          }\n+ *          IntList_init(*right);\n+ *      }\n+ *      \n+ *  This code creates a reducer that supports creating an `IntList` by appending values to it.\n+ *  \n+ *      void identity_IntList(void* reducer, void* list)\n+ *      {\n+ *          IntList_init((IntList*)list);\n+ *      }\n+ *      \n+ *      void reduce_IntList(void* reducer, void* left, void* right)\n+ *      {\n+ *          IntList_concat((IntList*)left, (IntList*)right);\n+ *      }\n+ *          \n+ *      CILK_C_DECLARE_REDUCER(IntList) my_list_int_reducer =\n+ *          CILK_C_INIT_REDUCER(IntList,\n+ *                              reduce_int_list,\n+ *                              identity_int_list,\n+ *                              __cilkrts_hyperobject_noop_destroy);\n+ *                              // Initial value omitted //\n+ *      ListInt_init(&REDUCER_VIEW(my_int_list_reducer));\n+ *\n+ *      CILK_C_REGISTER_REDUCER(my_int_list_reducer);\n+ *      cilk_for (int i = 0; i != n; ++i) {\n+ *          IntList_append(&REDUCER_VIEW(my_int_list_reducer), a[i]);\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(my_int_list_reducer);\n+ *      \n+ *      IntList result = REDUCER_VIEW(my_int_list_reducer);\n+ *\n+ *  @section reducers_c_predefined Predefined C Reducers\n+ *\n+ *  Some of the predefined reducer classes in the Cilk library come with a set of predefined\n+ *  macros to provide the same capabilities in C. In general, two macros are provided for each\n+ *  predefined reducer family:\n+ *\n+ *  -   `CILK_C_REDUCER_operation(reducer-name, type-name, initial-value)` \u2014 Declares a\n+ *      reducer object named _reducer-name_ with initial value _initial-value_ to perform\n+ *      a reduction using the _operation_ on values of the type specified by _type-name_.\n+ *      This is the equivalent of the general code described in @ref reducers_c_creation :\n+ *\n+ *          CILK_C_DECLARE_REDUCER(type) reducer-name =\n+ *              CILK_C_INIT_REDUCER(type, ..., initial-value);\n+ *\n+ *      where _type_ is the C type corresponding to _type_name_. See @ref reducers_c_type_names\n+ *      below for the _type-names_ that you can use.\n+ *\n+ *  -   `CILK_C_REDUCER_operation_TYPE(type-name)` \u2014 Expands to the `typedef` name for the type\n+ *      of the reducer object declared by\n+ *      `CILK_C_REDUCER_operation(reducer-name, type-name, initial-value)`.\n+ *\n+ *  See @ref reducers_c_example_predefined.\n+ *\n+ *  The predefined C reducers are:\n+ *\n+ *  |   Operation       |   Name        |   Documentation               |\n+ *  |-------------------|---------------|-------------------------------|\n+ *  |   addition        |   `OPADD`     |   @ref ReducersAdd            |\n+ *  |   bitwise and     |   `OPAND`     |   @ref ReducersAnd            |\n+ *  |   bitwise or      |   `OPOR`      |   @ref ReducersOr             |\n+ *  |   bitwise xor     |   `OPXOR`     |   @ref ReducersXor            |\n+ *  |   multiplication  |   `OPMUL`     |   @ref ReducersMul            |\n+ *  |   minimum         |   `MIN`       |   @ref ReducersMinMax         |\n+ *  |   minimum & index |   `MIN_INDEX` |   @ref ReducersMinMax         |\n+ *  |   maximum         |   `MIN`       |   @ref ReducersMinMax         |\n+ *  |   maximum & index |   `MIN_INDEX` |   @ref ReducersMinMax         |\n+ *      \n+ *  @subsection reducers_c_type_names Numeric Type Names\n+ *  \n+ *  The type and function names created by the C reducer definition macros incorporate both the\n+ *  reducer kind (`opadd`, `opxor`, etc.) and the value type of the reducer (`int`, `double`, \n+ *  etc.). The value type is represented by a _numeric type name_ string. The types supported \n+ *  in C reducers, and their corresponding numeric type names, are given in the following table:\n+ *  \n+ *  |   Type                |   Numeric Type Name           |\n+ *  |-----------------------|-------------------------------|\n+ *  |  `char`               |  `char`                       |\n+ *  |  `unsigned char`      |  `uchar`                      |\n+ *  |  `signed char`        |  `schar`                      |\n+ *  |  `wchar_t`            |  `wchar_t`                    |\n+ *  |  `short`              |  `short`                      |\n+ *  |  `unsigned short`     |  `ushort`                     |\n+ *  |  `int`                |  `int`                        |\n+ *  |  `unsigned int`       |  `uint`                       |\n+ *  |  `unsigned int`       |  `unsigned` (alternate name)  |\n+ *  |  `long`               |  `long`                       |\n+ *  |  `unsigned long`      |  `ulong`                      |\n+ *  |  `long long`          |  `longlong`                   |\n+ *  |  `unsigned long long` |  `ulonglong`                  |\n+ *  |  `float`              |  `float`                      |\n+ *  |  `double`             |  `double`                     |\n+ *  |  `long double`        |  `longdouble`                 |\n+ *  \n+ *  @subsection reducers_c_example_predefined Example \u2014 Using a Predefined C Reducer\n+ *\n+ *  To compute the sum of all the values in an array of `unsigned int`:\n+ *\n+ *      CILK_C_REDUCER_OPADD(sum, uint, 0);\n+ *      CILK_C_REGISTER_REDUCER(sum);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(sum) += a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(sum);\n+ *      printf(\"The sum is %u\\n\", REDUCER_VIEW(sum));\n+ */\n+\n+ \n+ /** @name C language reducer macros\n+ *\n+ *  These macros are used to declare and work with reducers in C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+\n+/// @cond internal\n+\n+/** @name Compound identifier macros.\n+ *\n+ *  These macros are used to construct an identifier by concatenating two or three identifiers.\n+ */\n+//@{\n+\n+/** Expand to an identifier formed by concatenating two identifiers.\n+ */\n+#define __CILKRTS_MKIDENT(a,b) __CILKRTS_MKIDENT_IMP(a,b,)\n+\n+/** Expand to an identifier formed by concatenating three identifiers.\n+ */\n+#define __CILKRTS_MKIDENT3(a,b,c) __CILKRTS_MKIDENT_IMP(a,b,c)\n+\n+/** Helper macro to do the concatenation.\n+ */\n+#define __CILKRTS_MKIDENT_IMP(a,b,c) a ## b ## c\n+\n+//@}\n+\n+/** Compiler-specific keyword for the \u201ctype of\u201d operator.\n+ */\n+#if defined(__GNUC__) && !defined(__INTEL_COMPILER)\n+# define _Typeof __typeof__\n+#endif\n+\n+/** @name Predefined reducer function declaration macros.\n+ *\n+ *  These macros are used to create the function headers for the identity, reduction,\n+ *  and destructor functions for a builtin reducer family. The macro can be followed by\n+ *  a semicolon to create a declaration, or by a brace-enclosed body to create a definition.\n+ */\n+//@{\n+\n+/** Create an identity function header.\n+ *\n+ *  @note   The name of the function\u2019s value pointer parameter will always be `v`.\n+ *\n+ *  @param name The reducer family name.\n+ *  @param tn   The type name.\n+ */\n+#define __CILKRTS_DECLARE_REDUCER_IDENTITY(name,tn)  CILK_EXPORT         \\\n+    void __CILKRTS_MKIDENT3(name,_identity_,tn)(void* key, void* v)\n+\n+/** Create a reduction function header.\n+ *\n+ *  @param name The reducer family name.\n+ *  @param tn   The type name.\n+ *  @param l    The name to use for the function\u2019s left value pointer parameter.\n+ *  @param r    The name to use for the function\u2019s right value pointer parameter.\n+ */\n+#define __CILKRTS_DECLARE_REDUCER_REDUCE(name,tn,l,r) CILK_EXPORT        \\\n+    void __CILKRTS_MKIDENT3(name,_reduce_,tn)(void* key, void* l, void* r)\n+\n+/** Create a destructor function header.\n+ *\n+ *  @param name The reducer family name.\n+ *  @param tn   The type name.\n+ *  @param p    The name to use for the function\u2019s value pointer parameter.\n+ */\n+#define __CILKRTS_DECLARE_REDUCER_DESTROY(name,tn,p) CILK_EXPORT         \\\n+    void __CILKRTS_MKIDENT3(name,_destroy_,tn)(void* key, void* p)\n+\n+//@}\n+\n+/// @endcond\n+\n+\n+/***************************************************************************\n+ *              Real implementation\n+ ***************************************************************************/\n+\n+/** Declaration of a C reducer structure type.\n+ *\n+ *  This macro expands into an anonymous structure declaration for a C reducer structure\n+ *  which contains a @a Type value. For example:\n+ *\n+ *      CILK_C_DECLARE_REDUCER(int) my_add_int_reducer =\n+ *          CILK_C_INIT_REDUCER(int, \u2026);\n+ *\n+ *  @param Type The type of the value contained in the reducer object.\n+ *\n+ *  @see @ref reducers_c_creation\n+ */\n+#define CILK_C_DECLARE_REDUCER(Type) struct {                      \\\n+        __cilkrts_hyperobject_base   __cilkrts_hyperbase;          \\\n+        __CILKRTS_CACHE_ALIGN Type   value;                        \\\n+    }\n+\n+/** Initializer for a C reducer structure.\n+ *\n+ *  This macro expands into a brace-enclosed structure initializer for a C reducer structure\n+ *  that was declared with `CILK_C_DECLARE_REDUCER(Type)`. For example:\n+ *\n+ *      CILK_C_DECLARE_REDUCER(int) my_add_int_reducer =\n+ *          CILK_C_INIT_REDUCER(int, \n+ *                              add_int_reduce, \n+ *                              add_int_identity, \n+ *                              __cilkrts_hyperobject_noop_destroy,\n+ *                              0);\n+ *\n+ *  @param Type     The type of the value contained in the reducer object. Must be the same as\n+ *                  the @a Type argument of the CILK_C_DECLARE_REDUCER macro call that created\n+ *                  the reducer.\n+ *  @param Reduce   The address of the @ref reducers_c_reduce_func \"reduce function\" for the\n+ *                  reducer.\n+ *  @param Identity The address of the @ref reducers_c_identity_func \"identity function\" for\n+ *                  the reducer.\n+ *  @param Destroy  The address of the @ref reducers_c_destroy_func \"destroy function\" for the\n+ *                  reducer.\n+ *  @param ...      The initial value for the reducer. (A single expression if @a Type is a\n+ *                  scalar type; a list of values if @a Type is a struct or array type.)\n+ *\n+ *  @see @ref reducers_c_creation\n+ */\n+\n+#define CILK_C_INIT_REDUCER(Type, Reduce, Identity, Destroy, ...)       \\\n+    {   {   {   Reduce                                                  \\\n+            ,   Identity                                                \\\n+            ,   Destroy                                                 \\\n+            ,   __cilkrts_hyperobject_alloc                             \\\n+            ,   __cilkrts_hyperobject_dealloc                           \\\n+            }                                                           \\\n+        ,   0                                                           \\\n+        ,   __CILKRTS_CACHE_LINE__                                      \\\n+        ,   sizeof(Type)                                                \\\n+        }                                                               \\\n+    ,   __VA_ARGS__                                                     \\\n+    }\n+\n+/** Register a reducer with the Cilk runtime.\n+ *\n+ *  The runtime will manage reducer values for all registered reducers when parallel execution \n+ *  strands begin and end. For example:\n+ *\n+ *      CILK_C_REGISTER_REDUCER(my_add_int_reducer);\n+ *      cilk_for (int i = 0; i != n; ++i) {\n+ *          \u2026\n+ *      }\n+ *\n+ *  @param Expr The reducer to be registered.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+#define CILK_C_REGISTER_REDUCER(Expr) \\\n+    __cilkrts_hyper_create(&(Expr).__cilkrts_hyperbase)\n+\n+/** Unregister a reducer with the Cilk runtime.\n+ *\n+ *  The runtime will stop managing reducer values for a reducer after it is unregistered. For\n+ *  example:\n+ *\n+ *      cilk_for (int i = 0; i != n; ++i) {\n+ *          \u2026\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(my_add_int_reducer);\n+ *\n+ *  @param Expr The reducer to be unregistered.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+#define CILK_C_UNREGISTER_REDUCER(Expr) \\\n+    __cilkrts_hyper_destroy(&(Expr).__cilkrts_hyperbase)\n+\n+/** Get the current view for a reducer.\n+ *\n+ *  The `REDUCER_VIEW(reducer-name)` returns a reference to the reducer\u2019s value for the \n+ *  current parallel strand. This can be used to initialize thevalue of the  reducer before it\n+ *  is used, to modify the value of the reducer on the current parallel strand, or to retrieve\n+ *  the final value of the reducer at the end of the parallel computation.\n+ *\n+ *      REDUCER_VIEW(my_add_int_reducer) = REDUCER_VIEW(my_add_int_reducer) + x;\n+ *\n+ *  @note   C++ reducer views restrict access to the wrapped value so that it can only be\n+ *  modified in ways consistent with the reducer\u2019s operation. No such protection is provided \n+ *  for C reducers. It is entirely the responsibility of the user to refrain from modifying the\n+ *  value in any inappropriate way.\n+ *\n+ *  @param Expr The reducer whose value is to be returned.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+#define REDUCER_VIEW(Expr) (*(_Typeof((Expr).value)*)               \\\n+    __cilkrts_hyper_lookup(&(Expr).__cilkrts_hyperbase))\n+\n+//@} C language reducer macros\n+\n+#endif // CILK_REDUCER_H_INCLUDED"}, {"sha": "75af994e9d49241f2c32ad7d3019669b6f2a333c", "filename": "libcilkrts/include/cilk/reducer_file.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,37 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+"}, {"sha": "fc0be1e03d3fa518c764b5e979b72ff00c29a556", "filename": "libcilkrts/include/cilk/reducer_list.h", "status": "added", "additions": 1127, "deletions": 0, "changes": 1127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,1127 @@\n+/*  reducer_list.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_list.h\n+ *\n+ *  @brief Defines classes for doing parallel list creation by appending or\n+ *  prepending.\n+ *\n+ *  @ingroup ReducersList\n+ *\n+ *  @see ReducersList\n+ */\n+\n+#ifndef REDUCER_LIST_H_INCLUDED\n+#define REDUCER_LIST_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+#include <list>\n+\n+/** @defgroup ReducersList List Reducers\n+ *\n+ *  List append and prepend reducers allow the creation of a standard list by\n+ *  concatenating a set of lists or values in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redlist_usage Usage Example\n+ *\n+ *      // Create a list containing the labels of the nodes of a tree in\n+ *      // \u201cinorder\u201d (left subtree, root, right subtree).\n+ *\n+ *      struct Tree { Tree* left; Tree* right; string label; ... };\n+ *\n+ *      list<string> x;\n+ *      cilk::reducer< cilk::op_list_append<string> > xr(cilk::move_in(x));\n+ *      collect_labels(tree, xr);\n+ *      xr.move_out(x);\n+ *      \n+ *      void collect_labels(Tree* node, \n+ *                          cilk::reducer< cilk::op_list_append<string> >& xr)\n+ *      {\n+ *          if (node) {\n+ *              cilk_spawn collect_labels(node->left, xr);\n+ *              xr->push_back(node->label);\n+ *              collect_labels(node->right, xr);\n+ *              cilk_sync;\n+ *          }\n+ *      }\n+ *\n+ *  @section redlist_monoid The Monoid\n+ *\n+ *  @subsection redlist_monoid_values Value Set\n+ *\n+ *  The value set of a list reducer is the set of values of the class \n+ *  `std::list<Type, Allocator>`, which we refer to as \u201cthe reducer\u2019s list \n+ *  type\u201d.\n+ *\n+ *  @subsection redlist_monoid_operator Operator\n+ *\n+ *  The operator of a list append reducer is defined as\n+ *\n+ *      x CAT y == (every element of x, followed by every element of y)\n+ *\n+ *  The operator of a list prepend reducer is defined as\n+ *\n+ *      x RCAT y == (every element of y, followed by every element of x)\n+ *\n+ *  @subsection redlist_monoid_identity Identity\n+ *\n+ *  The identity value of a list reducer is the empty list, which is the value \n+ *  of the expression `std::list<Type, Allocator>([allocator])`.\n+ *\n+ *  @section redlist_operations Operations\n+ *\n+ *  In the operation descriptions below, the type name `List` refers to the \n+ *  reducer\u2019s string type, `std::list<Type, Allocator>`.\n+ *\n+ *  @subsection redlist_constructors Constructors\n+ *\n+ *  Any argument list which is valid for a `std::list` constructor is valid for \n+ *  a list reducer constructor. The usual move-in constructor is also provided:\n+ *\n+ *      reducer(move_in(List& variable))\n+ *\n+ *  A list reducer with no constructor arguments, or with only an allocator \n+ *  argument, will initially contain the identity value, an empty list. \n+ *\n+ *  @subsection redlist_get_set Set and Get\n+ *\n+ *      r.set_value(const List& value)\n+ *      const List& = r.get_value() const\n+ *      r.move_in(List& variable)\n+ *      r.move_out(List& variable)\n+ *\n+ *  @subsection redlist_view_ops View Operations\n+ *\n+ *  The view of a list append reducer provides the following member functions:\n+ *\n+ *      void push_back(const Type& element) \n+ *      void insert_back(List::size_type n, const Type& element) \n+ *      template <typename Iter> void insert_back(Iter first, Iter last)\n+ *      void splice_back(List& x)\n+ *      void splice_back(List& x, List::iterator i)\n+ *      void splice_back(List& x, List::iterator first, List::iterator last)\n+ *  \n+ *  The view of a list prepend reducer provides the following member functions:\n+ *\n+ *      void push_front(const Type& element) \n+ *      void insert_front(List::size_type n, const Type& element) \n+ *      template <typename Iter> void insert_front(Iter first, Iter last)\n+ *      void splice_front(List& x)\n+ *      void splice_front(List& x, List::iterator i)\n+ *      void splice_front(List& x, List::iterator first, List::iterator last)\n+ *\n+ *  The `push_back` and `push_front` functions are the same as the\n+ *  corresponding `std::list` functions. The `insert_back`, `splice_back`,\n+ *  `insert_front`, and `splice_front` functions are the same as the \n+ *  `std::list` `insert` and `splice` functions, with the first parameter\n+ *  fixed to the end or beginning of the list, respectively.\n+ *\n+ *  @section redlist_performance Performance Considerations\n+ *\n+ *  An efficient reducer requires that combining the values of two views (using \n+ *  the view `reduce()` function) be a constant-time operations. Two lists can\n+ *  be merged in constant time using the `splice()` function if they have the\n+ *  same allocator. Therefore, the lists for new views are created (by the view\n+ *  identity constructor) using the same allocator as the list that was created\n+ *  when the reducer was constructed.\n+ *\n+ *  The performance of adding elements to a list reducer depends on the view \n+ *  operations that are used:\n+ *\n+ *  *   The `push` functions add a single element to the list, and therefore\n+ *      take constant time.\n+ *  *   An `insert` function that inserts _N_ elements adds each of them\n+ *      individually, and therefore takes _O(N)_ time. \n+ *  *   A `splice` function that inserts _N_ elements just adjusts a couple of\n+ *      pointers, and therefore takes constant time, _if the splice is from a\n+ *      list with the same allocator as the reducer_. Otherwise, it is\n+ *      equivalent to an `insert`, and takes _O(N)_ time.\n+ *\n+ *  This means that for best performance, if you will be adding elements to a\n+ *  list reducer in batches, you should `splice` them from a list having the\n+ *  same allocator as the reducer.\n+ *\n+ *  The reducer `move_in` and `move_out` functions do a constant-time `swap` if\n+ *  the variable has the same allocator as the reducer, and a linear-time copy\n+ *  otherwise.\n+ *  \n+ *  Note that the allocator of a list reducer is determined when the reducer is\n+ *  constructed. The following two examples may have very different behavior:\n+ *\n+ *      list<Element, Allocator> a_list;\n+ *\n+ *      reducer< list_append<Element, Allocator> reducer1(move_in(a_list));\n+ *      ... parallel computation ...\n+ *      reducer1.move_out(a_list);\n+ *\n+ *      reducer< list_append<Element, Allocator> reducer2;\n+ *      reducer2.move_in(a_list);\n+ *      ... parallel computation ...\n+ *      reducer2.move_out(a_list);\n+ *\n+ *  *   `reducer1` will be constructed with the same allocator as `a_list`,\n+ *      because the list was was specified in the constructor. The `move_in`\n+ *      and`move_out` can therefore be done with a `swap` in constant time.\n+ *  *   `reducer2` will be constructed with a _default_ allocator,\n+ *      \u201c`Allocator()`\u201d, which may or may not be the same as the allocator of\n+ *      `a_list`. Therefore, the `move_in` and `move_out` may have to be done\n+ *      with a copy in _O(N)_ time.\n+ *  \n+ *  (All instances of an allocator type with no internal state (like\n+ *  `std::allocator`) are \u201cthe same\u201d. You only need to worry about the \u201csame\n+ *  allocator\u201d issue when you create list reducers with custom allocator types.)\n+ *\n+ *  @section redlist_types Type and Operator Requirements\n+ *\n+ *  `std::list<Type, Allocator>` must be a valid type.\n+ */\n+\n+\n+namespace cilk {\n+\n+namespace internal {\n+\n+/** @ingroup ReducersList */\n+//@{\n+\n+/** Base class for list append and prepend view classes.\n+ *\n+ *  @note   This class provides the definitions that are required for a class\n+ *          that will be used as the parameter of a @ref list_monoid_base\n+ *          specialization. \n+ *\n+ *  @tparam Type        The list element type (not the list type).\n+ *  @tparam Allocator   The list's allocator class.\n+ *\n+ *  @see ReducersList\n+ *  @see list_monoid_base\n+ */\n+template <typename Type, typename Allocator>\n+class list_view_base\n+{\n+protected:\n+    /// The type of the contained list.\n+    typedef std::list<Type, Allocator>  list_type;\n+\n+    /// The list accumulator variable.\n+    list_type m_value;\n+\n+public:\n+\n+    /** @name Monoid support.\n+     */\n+    //@{\n+    \n+    /// Required by @ref monoid_with_view\n+    typedef list_type   value_type;\n+\n+    /// Required by @ref list_monoid_base\n+    Allocator get_allocator() const\n+    { \n+        return m_value.get_allocator(); \n+    }\n+    \n+    //@}\n+    \n+    \n+    /** @name Constructors.\n+     */\n+    //@{\n+    \n+    /// Standard list constructor.\n+    explicit list_view_base(const Allocator& a = Allocator()) : m_value(a) {}\n+    explicit list_view_base(\n+        typename list_type::size_type n, \n+        const Type& value = Type(), \n+        const Allocator& a = Allocator() ) : m_value(n, value, a) {}\n+    template <typename Iter> \n+    list_view_base(Iter first, Iter last, const Allocator& a = Allocator()) : \n+        m_value(first, last, a) {}\n+    list_view_base(const list_type& list) : m_value(list) {}\n+\n+    /// Move-in constructor.\n+    explicit list_view_base(move_in_wrapper<value_type> w)\n+        : m_value(w.value().get_allocator())\n+    {\n+        m_value.swap(w.value());\n+    }\n+    \n+    //@}\n+    \n+    /** @name Reducer support.\n+     */\n+    //@{\n+    \n+    /// Required by reducer::move_in()\n+    void view_move_in(value_type& v)\n+    {\n+        if (m_value.get_allocator() == v.get_allocator())\n+            // Equal allocators. Do a (fast) swap.\n+            m_value.swap(v);\n+        else\n+            // Unequal allocators. Do a (slow) copy.\n+            m_value = v;\n+        v.clear();\n+    }\n+    \n+    /// Required by reducer::move_out()\n+    void view_move_out(value_type& v)\n+    {\n+        if (m_value.get_allocator() == v.get_allocator())\n+            // Equal allocators.  Do a (fast) swap.\n+            m_value.swap(v);\n+        else\n+            // Unequal allocators.  Do a (slow) copy.\n+            v = m_value;\n+        m_value.clear();\n+    }\n+    \n+    /// Required by reducer::set_value()\n+    void view_set_value(const value_type& v) { m_value = v; }\n+\n+    /// Required by reducer::get_value()\n+    value_type const& view_get_value()     const { return m_value; }\n+    \n+    // Required by legacy wrapper get_reference()\n+    value_type      & view_get_reference()       { return m_value; }\n+    value_type const& view_get_reference() const { return m_value; }\n+    \n+    //@}\n+};\n+\n+\n+/** Base class for list append and prepend monoid classes.\n+ *\n+ *  The key to efficient reducers is that the `identity` operation, which\n+ * creates a new per-strand view, and the `reduce` operation, which combines\n+ *  two per-strand views, must be constant-time operations. Two lists can be\n+ *  concatenated in constant time only if they have the same allocator.\n+ *  Therefore, all the per-strand list accumulator variables must be created\n+ *   with the same allocator as the leftmost view list. \n+ *\n+ *  This means that a list reduction monoid must have a copy of the allocator\n+ *  of the leftmost view\u2019s list, so that it can use it in the `identity`\n+ *  operation. This, in turn, requires that list reduction monoids have a\n+ *  specialized `construct()` function, which constructs the leftmost view\n+ *  before the monoid, and then passes the leftmost view\u2019s allocator to the\n+ *  monoid constructor.\n+ *\n+ *  @tparam View    The list append or prepend view class.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersList\n+ *  @see list_view_base\n+ */\n+template <typename View, bool Align>\n+class list_monoid_base : public monoid_with_view<View, Align>\n+{\n+    typedef typename View::value_type           list_type;\n+    typedef typename list_type::allocator_type  allocator_type;\n+    allocator_type                              m_allocator;\n+    \n+    using monoid_base<list_type, View>::provisional;\n+    \n+public:\n+\n+    /** Constructor.\n+     *\n+     *  There is no default constructor for list monoids, because the allocator \n+     *  must always be specified.\n+     *\n+     *  @param  allocator   The list allocator to be used when\n+     *                      identity-constructing new views.\n+     */\n+    list_monoid_base(const allocator_type& allocator = allocator_type()) :\n+        m_allocator(allocator) {}\n+\n+    /** Create an identity view.\n+     *\n+     *  List view identity constructors take the list allocator as an argument.\n+     *\n+     *  @param v    The address of the uninitialized memory in which the view\n+     *              will be constructed.\n+     */\n+    void identity(View *v) const { ::new((void*) v) View(m_allocator); }\n+    \n+    /** @name construct functions\n+     *\n+     *  All `construct()` functions first construct the leftmost view, using \n+     *  the optional @a x1, @a x2, and @a x3 arguments that were passed in from\n+     *  the reducer constructor. They then call the view\u2019s `get_allocator()`\n+     *  function to get the list allocator from its contained list, and pass it\n+     *  to the monoid constructor.\n+     */\n+    //@{\n+\n+    template <typename Monoid>\n+    static void construct(Monoid* monoid, View* view)\n+        { provisional( new ((void*)view) View() ).confirm_if( \n+            new ((void*)monoid) Monoid(view->get_allocator()) ); }\n+\n+    template <typename Monoid, typename T1>\n+    static void construct(Monoid* monoid, View* view, const T1& x1)\n+        { provisional( new ((void*)view) View(x1) ).confirm_if( \n+            new ((void*)monoid) Monoid(view->get_allocator()) ); }\n+\n+    template <typename Monoid, typename T1, typename T2>\n+    static void construct(Monoid* monoid, View* view, const T1& x1, const T2& x2)\n+        { provisional( new ((void*)view) View(x1, x2) ).confirm_if( \n+            new ((void*)monoid) Monoid(view->get_allocator()) ); }\n+\n+    template <typename Monoid, typename T1, typename T2, typename T3>\n+    static void construct(Monoid* monoid, View* view, const T1& x1, const T2& x2, \n+                            const T3& x3)\n+        { provisional( new ((void*)view) View(x1, x2, x3) ).confirm_if( \n+            new ((void*)monoid) Monoid(view->get_allocator()) ); }\n+\n+    //@}\n+};\n+\n+//@}\n+\n+} // namespace internal\n+\n+\n+/** @ingroup ReducersList */\n+//@{\n+\n+/** The list append reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_list_append<Type, Allocator> >`. It holds the\n+ *  accumulator variable for the reduction, and allows only append operations\n+ *  to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `push_back` operation would be used in an expression like\n+ *          `r->push_back(a)`, where `r` is a list append reducer variable.\n+ *\n+ *  @tparam Type        The list element type (not the list type).\n+ *  @tparam Allocator   The list allocator type.\n+ *\n+ *  @see ReducersList\n+ *  @see op_list_append\n+ */\n+template <class Type, \n+          class Allocator = typename std::list<Type>::allocator_type>\n+class op_list_append_view : public internal::list_view_base<Type, Allocator>\n+{\n+    typedef internal::list_view_base<Type, Allocator>   base;\n+    typedef std::list<Type, Allocator>                  list_type;\n+    typedef typename list_type::iterator                iterator;\n+    \n+    iterator end() { return this->m_value.end(); }\n+\n+public:\n+\n+    /** @name Constructors.\n+     *\n+     *  All op_list_append_view constructors simply pass their arguments on to\n+     *  the @ref internal::list_view_base base class constructor.\n+     *\n+     *  @ref internal::list_view_base supports all the std::list constructor\n+     *  forms, as well as the reducer move_in constructor form.\n+     */\n+    //@{\n+    \n+    op_list_append_view() : base() {}\n+    \n+    template <typename T1>\n+    op_list_append_view(const T1& x1) : base(x1) {}\n+    \n+    template <typename T1, typename T2>\n+    op_list_append_view(const T1& x1, const T2& x2) : base(x1, x2) {}\n+    \n+    template <typename T1, typename T2, typename T3>\n+    op_list_append_view(const T1& x1, const T2& x2, const T3& x3) : \n+        base(x1, x2, x3) {}\n+\n+    //@}    \n+\n+    /** @name View modifier operations.\n+     */\n+    //@{\n+    \n+    /** Add an element at the end of the list.\n+     *\n+     *  This is equivalent to `list.push_back(element)`\n+     */\n+    void push_back(const Type& element) \n+        { this->m_value.push_back(element); }\n+\n+    /** Insert elements at the end of the list.\n+     *\n+     *  This is equivalent to `list.insert(list.end(), n, element)`\n+     */\n+    void insert_back(typename list_type::size_type n, const Type& element) \n+        { this->m_value.insert(end(), n, element); }\n+\n+    /** Insert elements at the end of the list.\n+     *\n+     *  This is equivalent to `list.insert(list.end(), first, last)`\n+     */\n+    template <typename Iter>\n+    void insert_back(Iter first, Iter last)\n+        { this->m_value.insert(end(), first, last); }\n+\n+    /** Splice elements at the end of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.end(), x)`\n+     */\n+    void splice_back(list_type& x) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(end(), x);\n+        else {\n+            insert_back(x.begin(), x.end());\n+            x.clear();\n+        }\n+    }\n+\n+    /** Splice elements at the end of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.end(), x, i)`\n+     */\n+    void splice_back(list_type& x, iterator i) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(end(), x, i);\n+        else {\n+            push_back(*i);\n+            x.erase(i);\n+        }\n+    }\n+\n+    /** Splice elements at the end of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.end(), x, first, last)`\n+     */\n+    void splice_back(list_type& x, iterator first, iterator last) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(end(), x, first, last);\n+        else {\n+            insert_back(first, last);\n+            x.erase(first, last);\n+        }\n+    }\n+    \n+    //@}\n+\n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_list_append monoid to combine\n+     *  the views of two strands when the right strand merges with the left \n+     *  one. It appends the value contained in the right-strand view to the \n+     *  value contained in the left-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_list_append monoid to implement the\n+     *          monoid reduce operation.\n+     */\n+    void reduce(op_list_append_view* right)\n+    {\n+        __CILKRTS_ASSERT(\n+            this->m_value.get_allocator() == right->m_value.get_allocator());\n+        this->m_value.splice(end(), right->m_value);\n+    }\n+};\n+\n+\n+/** The list prepend reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_list_prepend<Type, Allocator> >`. It holds the\n+ *  accumulator variable for the reduction, and allows only prepend operations\n+ *  to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `push_front` operation would be used in an expression like\n+ *          `r->push_front(a)`, where `r` is a list prepend reducer variable.\n+ *\n+ *  @tparam Type        The list element type (not the list type).\n+ *  @tparam Allocator   The list allocator type.\n+ *\n+ *  @see ReducersList\n+ *  @see op_list_prepend\n+ */\n+template <class Type, \n+          class Allocator = typename std::list<Type>::allocator_type>\n+class op_list_prepend_view : public internal::list_view_base<Type, Allocator>\n+{\n+    typedef internal::list_view_base<Type, Allocator>   base;\n+    typedef std::list<Type, Allocator>                  list_type;\n+    typedef typename list_type::iterator                iterator;\n+    \n+    iterator begin() { return this->m_value.begin(); }\n+\n+public:\n+\n+    /** @name Constructors.\n+     *\n+     *  All op_list_prepend_view constructors simply pass their arguments on to\n+     *  the @ref internal::list_view_base base class constructor.\n+     *\n+     *  @ref internal::list_view_base supports all the std::list constructor\n+     *  forms, as well as the reducer move_in constructor form.\n+     *\n+     */\n+    //@{\n+    \n+    op_list_prepend_view() : base() {}\n+    \n+    template <typename T1>\n+    op_list_prepend_view(const T1& x1) : base(x1) {}\n+    \n+    template <typename T1, typename T2>\n+    op_list_prepend_view(const T1& x1, const T2& x2) : base(x1, x2) {}\n+    \n+    template <typename T1, typename T2, typename T3>\n+    op_list_prepend_view(const T1& x1, const T2& x2, const T3& x3) : \n+        base(x1, x2, x3) {}\n+\n+    //@}    \n+\n+    /** @name View modifier operations.\n+     */\n+    //@{\n+    \n+    /** Add an element at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.push_front(element)`\n+     */\n+    void push_front(const Type& element) \n+        { this->m_value.push_front(element); }\n+\n+    /** Insert elements at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.insert(list.begin(), n, element)`\n+     */\n+    void insert_front(typename list_type::size_type n, const Type& element) \n+        { this->m_value.insert(begin(), n, element); }\n+\n+    /** Insert elements at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.insert(list.begin(), first, last)`\n+     */\n+    template <typename Iter>\n+    void insert_front(Iter first, Iter last)\n+        { this->m_value.insert(begin(), first, last); }\n+\n+    /** Splice elements at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.begin(), x)`\n+     */\n+    void splice_front(list_type& x) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(begin(), x);\n+        else {\n+            insert_front(x.begin(), x.begin());\n+            x.clear();\n+        }\n+    }\n+\n+    /** Splice elements at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.begin(), x, i)`\n+     */\n+    void splice_front(list_type& x, iterator i) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(begin(), x, i);\n+        else {\n+            push_front(*i);\n+            x.erase(i);\n+        }\n+    }\n+\n+    /** Splice elements at the beginning of the list.\n+     *\n+     *  This is equivalent to `list.splice(list.begin(), x, first, last)`\n+     */\n+    void splice_front(list_type& x, iterator first, iterator last) {\n+        if (x.get_allocator() == this->m_value.get_allocator())\n+            this->m_value.splice(begin(), x, first, last);\n+        else {\n+            insert_front(first, last);\n+            x.erase(first, last);\n+        }\n+    }\n+    \n+    //@}\n+\n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_list_prepend monoid to combine\n+     *  the views of two strands when the right strand merges with the left \n+     *  one. It prepends the value contained in the right-strand view to the \n+     *  value contained in the left-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_list_prepend monoid to implement the\n+     *          monoid reduce operation.\n+     */\n+    /** Reduce operation.\n+     *\n+     *  Required by @ref monoid_base.\n+     */\n+    void reduce(op_list_prepend_view* right)\n+    {\n+        __CILKRTS_ASSERT(\n+            this->m_value.get_allocator() == right->m_value.get_allocator());\n+        this->m_value.splice(begin(), right->m_value);\n+    }\n+};\n+\n+\n+\n+/** Monoid class for list append reductions. Instantiate the cilk::reducer\n+ *  template class with a op_list_append monoid to create a list append reducer\n+ *  class. For example, to create a list of strings:\n+ *\n+ *      cilk::reducer< cilk::op_list_append<std::string> > r;\n+ *\n+ *  @tparam Type    The list element type (not the list type).\n+ *  @tparam Alloc   The list allocator type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersList\n+ *  @see op_list_append_view\n+ */\n+template <typename Type, \n+          typename Allocator = typename std::list<Type>::allocator_type,\n+          bool Align = false>\n+struct op_list_append : \n+    public internal::list_monoid_base<op_list_append_view<Type, Allocator>, Align> \n+{\n+    /// Construct with default allocator.\n+    op_list_append() {}\n+    /// Construct with specified allocator.\n+    op_list_append(const Allocator& alloc) : \n+        internal::list_monoid_base<op_list_append_view<Type, Allocator>, Align>(alloc) {}\n+};\n+\n+/** Monoid class for list prepend reductions. Instantiate the cilk::reducer\n+ *  template class with a op_list_prepend monoid to create a list prepend\n+ *  reducer class. For example, to create a list of strings:\n+ *\n+ *      cilk::reducer< cilk::op_list_prepend<std::string> > r;\n+ *\n+ *  @tparam Type    The list element type (not the list type).\n+ *  @tparam Alloc   The list allocator type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersList\n+ *  @see op_list_prepend_view\n+ */\n+template <typename Type, \n+          typename Allocator = typename std::list<Type>::allocator_type,\n+          bool Align = false>\n+struct op_list_prepend : \n+    public internal::list_monoid_base<op_list_prepend_view<Type, Allocator>, Align> \n+{\n+    /// Construct with default allocator.\n+    op_list_prepend() {}\n+    /// Construct with specified allocator.\n+    op_list_prepend(const Allocator& alloc) : \n+        internal::list_monoid_base<op_list_prepend_view<Type, Allocator>, Align>(alloc) {}\n+};\n+\n+\n+/** Deprecated list append reducer wrapper class.\n+ *\n+ *  reducer_list_append is the same as \n+ *  @ref reducer<@ref op_list_append>, except that reducer_list_append is a\n+ *  proxy for the contained view, so that accumulator variable update \n+ *  operations can be applied directly to the reducer. For example, an element\n+ *  is appended to a `reducer<%op_list_append>` with `r->push_back(a)`, but an\n+ *  element can be appended to a `%reducer_list_append` with `r.push_back(a)`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_list_append. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_list_append` \n+ *          and `reducer<%op_list_append>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_list_append` can pass a\n+ *          `%reducer_list_append` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_list_append>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type        The value type of the list.\n+ *  @tparam Allocator   The allocator type of the list.\n+ *\n+ *  @see op_list_append\n+ *  @see reducer\n+ *  @see ReducersList\n+ */\n+template <class Type, class Allocator = std::allocator<Type> >\n+class reducer_list_append : \n+    public reducer<op_list_append<Type, Allocator, true> >\n+{\n+    typedef reducer<op_list_append<Type, Allocator, true> > base;\n+    using base::view;\n+public:\n+\n+    /// The reducer\u2019s list type.\n+    typedef typename base::value_type list_type;\n+\n+    /// The list\u2019s element type.\n+    typedef Type list_value_type;\n+\n+    /// The reducer\u2019s primitive component type.\n+    typedef Type basic_value_type;\n+\n+    /// The monoid type.\n+    typedef typename base::monoid_type Monoid;\n+\n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Construct a reducer with an empty list.\n+     */\n+    reducer_list_append() {}\n+\n+    /** Construct a reducer with a specified initial list value.\n+     */\n+    reducer_list_append(const std::list<Type, Allocator> &initial_value) : \n+        base(initial_value) {}\n+        \n+    //@}\n+        \n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_and_view. */\n+    //@{\n+\n+    /// @copydoc op_list_append_view::push_back(const Type&)\n+    void push_back(const Type& element) { view().push_back(element); }\n+    \n+    //@}\n+\n+    /** Allow mutable access to the list within the current view.\n+     * \n+     *  @warning    If this method is called before the parallel calculation is\n+     *              complete, the list returned by this method will be a partial\n+     *              result.\n+     * \n+     *  @returns    A mutable reference to the list within the current view.\n+     */\n+    list_type &get_reference() { return view().view_get_reference(); }\n+\n+    /** Allow read-only access to the list within the current view.\n+     * \n+     *  @warning    If this method is called before the parallel calculation is\n+     *              complete, the list returned by this method will be a partial\n+     *              result.\n+     * \n+     *  @returns    A const reference to the list within the current view.\n+     */\n+    list_type const &get_reference() const { return view().view_get_reference(); }\n+\n+    /// @name Dereference\n+    //@{\n+    /** Dereferencing a wrapper is a no-op. It simply returns the wrapper.\n+     *  Combined with the rule that a wrapper forwards view operations to the\n+     *  view, this means that view operations can be written the same way on\n+     *  reducers and wrappers, which is convenient for incrementally\n+     *  converting code using wrappers to code using reducers. That is:\n+     *\n+     *      reducer< op_list_append<int> > r;\n+     *      r->push_back(a);    // *r returns the view\n+     *                          // push_back is a view member function\n+     *\n+     *      reducer_list_append<int> w;\n+     *      w->push_back(a);    // *w returns the wrapper\n+     *                          // push_back is a wrapper member function that\n+     *                          // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_list_append&       operator*()       { return *this; }\n+    reducer_list_append const& operator*() const { return *this; }\n+\n+    reducer_list_append*       operator->()       { return this; }\n+    reducer_list_append const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_list_append<Type, Allocator, false> >& ()\n+    {\n+        return *reinterpret_cast<\n+            reducer< op_list_append<Type, Allocator, false> >*\n+            >(this);\n+    }\n+    operator const reducer< op_list_append<Type, Allocator, false> >& () const\n+    {\n+        return *reinterpret_cast< \n+            const reducer< op_list_append<Type, Allocator, false> >* \n+            >(this);\n+    }\n+    //@}\n+    \n+};\n+\n+\n+/** Deprecated list prepend reducer wrapper class.\n+ *\n+ *  reducer_list_prepend is the same as \n+ *  @ref reducer<@ref op_list_prepend>, except that reducer_list_prepend is a\n+ *  proxy for the contained view, so that accumulator variable update operations\n+ *  can be applied directly to the reducer. For example, an element is prepended\n+ *  to a `reducer<op_list_prepend>` with `r->push_back(a)`, but an element is\n+ *  prepended to a `reducer_list_prepend` with `r.push_back(a)`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_list_prepend. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_list_prepend` \n+ *          and `reducer<%op_list_prepend>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_list_prepend` can pass a\n+ *          `%reducer_list_prepend` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_list_prepend>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type        The value type of the list.\n+ *  @tparam Allocator   The allocator type of the list.\n+ *\n+ *  @see op_list_prepend\n+ *  @see reducer\n+ *  @see ReducersList\n+ */\n+template <class Type, class Allocator = std::allocator<Type> >\n+class reducer_list_prepend : \n+    public reducer<op_list_prepend<Type, Allocator, true> >\n+{\n+    typedef reducer<op_list_prepend<Type, Allocator, true> > base;\n+    using base::view;\n+public:\n+\n+    /** The reducer\u2019s list type.\n+     */\n+    typedef typename base::value_type list_type;\n+\n+    /** The list\u2019s element type.\n+     */\n+    typedef Type list_value_type;\n+\n+    /** The reducer\u2019s primitive component type.\n+     */\n+    typedef Type basic_value_type;\n+\n+    /** The monoid type.\n+     */\n+    typedef typename base::monoid_type Monoid;\n+\n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Construct a reducer with an empty list.\n+     */\n+    reducer_list_prepend() {}\n+\n+    /** Construct a reducer with a specified initial list value.\n+     */\n+    reducer_list_prepend(const std::list<Type, Allocator> &initial_value) : \n+        base(initial_value) {}\n+        \n+    //@}\n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_and_view. \n+     */\n+    //@{\n+\n+    /// @copydoc op_list_prepend_view::push_front(const Type&)\n+    void push_front(const Type& element) { view().push_front(element); }\n+    \n+    //@}\n+\n+    /** Allow mutable access to the list within the current view.\n+     * \n+     *  @warning    If this method is called before the parallel calculation is\n+     *              complete, the list returned by this method will be a partial\n+     *              result.\n+     * \n+     *  @returns    A mutable reference to the list within the current view.\n+     */\n+    list_type &get_reference() { return view().view_get_reference(); }\n+\n+    /** Allow read-only access to the list within the current view.\n+     * \n+     *  @warning    If this method is called before the parallel calculation is\n+     *              complete, the list returned by this method will be a partial\n+     *              result.\n+     * \n+     *  @returns    A const reference to the list within the current view.\n+     */\n+    list_type const &get_reference() const { return view().view_get_reference(); }\n+\n+    /// @name Dereference\n+    /** Dereferencing a wrapper is a no-op. It simply returns the wrapper.\n+     *  Combined with the rule that a wrapper forwards view operations to the\n+     *  view, this means that view operations can be written the same way on\n+     *  reducers and wrappers, which is convenient for incrementally\n+     *  converting code using wrappers to code using reducers. That is:\n+     *\n+     *      reducer< op_list_prepend<int> > r;\n+     *      r->push_front(a);    // *r returns the view\n+     *                           // push_front is a view member function\n+     *\n+     *      reducer_list_prepend<int> w;\n+     *      w->push_front(a);    // *w returns the wrapper\n+     *                           // push_front is a wrapper member function that\n+     *                           // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_list_prepend&       operator*()       { return *this; }\n+    reducer_list_prepend const& operator*() const { return *this; }\n+\n+    reducer_list_prepend*       operator->()       { return this; }\n+    reducer_list_prepend const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_list_prepend<Type, Allocator, false> >& ()\n+    {\n+        return *reinterpret_cast<\n+            reducer< op_list_prepend<Type, Allocator, false> >* \n+            >(this);\n+    }\n+    operator const reducer< op_list_prepend<Type, Allocator, false> >& () const\n+    {\n+        return *reinterpret_cast<\n+            const reducer< op_list_prepend<Type, Allocator, false> >* \n+            >(this);\n+    }\n+    //@}\n+    \n+};\n+\n+/// @cond internal\n+\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class\n+ *  defined in reducer.h causes the `reducer< op_list_append<Type, Allocator> >`\n+ *  class to have an `operator reducer_list_append<Type, Allocator>& ()`\n+ *  conversion operator that statically downcasts the `reducer<op_list_append>`\n+ *  to the corresponding `reducer_list_append` type. (The reverse conversion,\n+ *  from `reducer_list_append` to `reducer<op_list_append>`, is just an upcast,\n+ *  which is provided for free by the language.)\n+ */\n+template <class Type, class Allocator, bool Align>\n+struct legacy_reducer_downcast<reducer<op_list_append<Type, Allocator, Align> > >\n+{\n+    typedef reducer_list_append<Type, Allocator> type;\n+};\n+\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class\n+ *  defined in reducer.h causes the\n+ *  `reducer< op_list_prepend<Type, Allocator> >` class to have an \n+ *  `operator reducer_list_prepend<Type, Allocator>& ()` conversion operator\n+ *  that statically downcasts the `reducer<op_list_prepend>` to the\n+ *  corresponding `reducer_list_prepend` type. (The reverse conversion, from\n+ *  `reducer_list_prepend` to `reducer<op_list_prepend>`, is just an upcast,\n+ *  which is provided for free by the language.)\n+ */\n+template <class Type, class Allocator, bool Align>\n+struct legacy_reducer_downcast<reducer<op_list_prepend<Type, Allocator, Align> > >\n+{\n+    typedef reducer_list_prepend<Type, Allocator> type;\n+};\n+\n+/// @endcond\n+\n+//@}\n+\n+} // Close namespace cilk\n+\n+#endif //  REDUCER_LIST_H_INCLUDED"}, {"sha": "3ba3a0bc8ac0ba5f23809cc7a4382353e55f5468", "filename": "libcilkrts/include/cilk/reducer_max.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,46 @@\n+/*  reducer_max.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_max.h\n+ *\n+ *  @brief Defines classes for doing parallel maximum reductions.\n+ *\n+ *  @ingroup ReducersMinMax\n+ *\n+ *  @see ReducersMinMax\n+ */\n+\n+#include \"reducer_min_max.h\""}, {"sha": "f5a3910850edea91da1b891a7c48ef9d523b819f", "filename": "libcilkrts/include/cilk/reducer_min.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,46 @@\n+/*  reducer_min.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_min.h\n+ *\n+ *  @brief Defines classes for doing parallel minimum reductions.\n+ *\n+ *  @ingroup ReducersMinMax\n+ *\n+ *  @see ReducersMinMax\n+ */\n+\n+#include \"reducer_min_max.h\""}, {"sha": "55f068c34a39c1ccceb770ca18ef8b5d8933866a", "filename": "libcilkrts/include/cilk/reducer_min_max.h", "status": "added", "additions": 3606, "deletions": 0, "changes": 3606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "4b7a83f845d2be92e16edf69b9a5a4707a70e17d", "filename": "libcilkrts/include/cilk/reducer_opadd.h", "status": "added", "additions": 690, "deletions": 0, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,690 @@\n+/*  reducer_opadd.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_opadd.h\n+ *\n+ *  @brief Defines classes for doing parallel addition reductions.\n+ *\n+ *  @ingroup ReducersAdd\n+ *\n+ *  @see ReducersAdd\n+ */\n+\n+#ifndef REDUCER_OPADD_H_INCLUDED\n+#define REDUCER_OPADD_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+\n+/** @defgroup ReducersAdd Addition Reducers\n+ *\n+ *  Addition reducers allow the computation of the sum of a set of values in\n+ *  parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redopadd_usage Usage Example\n+ *\n+ *      cilk::reducer< cilk::op_add<int> > r;\n+ *      cilk_for (int i = 0; i != N; ++i) {\n+ *          *r += a[i];\n+ *      }\n+ *      return r.get_value();\n+ *\n+ *  @section redopadd_monoid The Monoid\n+ *\n+ *  @subsection redopadd_monoid_values Value Set\n+ *\n+ *  The value set of an addition reducer is the set of values of `Type`, which\n+ *  is expected to be a builtin numeric type (or something like it, such as\n+ *  `std::complex`).\n+ *\n+ *  @subsection redopadd_monoid_operator Operator\n+ *\n+ *  The operator of an addition reducer is the addition operator, defined by\n+ *  the \u201c`+`\u201d binary operator on `Type`.\n+ *\n+ *  @subsection redopadd_monoid_identity Identity\n+ *\n+ *  The identity value of the reducer is the numeric value \u201c`0`\u201d. This is\n+ *  expected to be the value of the default constructor `Type()`.\n+ *\n+ *  @section redopadd_operations Operations\n+ *\n+ *  @subsection redopadd_constructors Constructors\n+ *\n+ *      reducer()   // identity\n+ *      reducer(const Type& value)\n+ *      reducer(move_in(Type& variable))\n+ *\n+ *  @subsection redopadd_get_set Set and Get\n+ *\n+ *      r.set_value(const Type& value)\n+ *      const Type& = r.get_value() const\n+ *      r.move_in(Type& variable)\n+ *      r.move_out(Type& variable)\n+ *\n+ *  @subsection redopadd_initial Initial Values\n+ *\n+ *  If an addition reducer is constructed without an explicit initial value,\n+ *  then its initial value will be its identity value, as long as `Type`\n+ *  satisfies the requirements of @ref redopadd_types.\n+ *\n+ *  @subsection redopadd_view_ops View Operations\n+ *\n+ *      *r += a\n+ *      *r -= a\n+ *      ++*r\n+ *      --*r\n+ *      (*r)++\n+ *      (*r)--\n+ *      *r = *r + a\n+ *      *r = *r - a\n+ *      *r = *r \u00b1 a1 \u00b1 a2 \u2026 \u00b1 an\n+ *\n+ *  The post-increment and post-decrement operations do not return a value. (If\n+ *  they did, they would expose the value contained in the view, which is\n+ *  non-deterministic in the middle of a reduction.)\n+ *\n+ *  Note that subtraction operations are allowed on an addition reducer because\n+ *  subtraction is equivalent to addition with a negated operand. It is true\n+ *  that `(x - y) - z` is not equivalent to `x - (y - z)`, but\n+ *  `(x + (-y)) + (-z)` _is_ equivalent to `x + ((-y) + (-z))`.\n+ *\n+ *  @section redopadd_floating_point Issues with Floating-Point Types\n+ *\n+ *  Because of precision and round-off issues, floating-point addition is not\n+ *  really associative. For example, `(1e30 + -1e30) + 1 == 1`, but \n+ *  `1e30 + (-1e30 + 1) == 0`.\n+ *\n+ *  In many cases, this won\u2019t matter, but computations which have been\n+ *  carefully ordered to control round-off errors may not deal well with\n+ *  being reassociated. In general, you should be sure to understand the\n+ *  floating-point behavior of your program before doing any transformation \n+ *  that will reassociate its computations. \n+ *\n+ *  @section redopadd_types Type and Operator Requirements\n+ *\n+ *  `Type` must be `Copy Constructible`, `Default Constructible`, and\n+ *  `Assignable`.\n+ *\n+ *  The operator \u201c`+=`\u201d must be defined on `Type`, with `x += a` having the\n+ *  same meaning as `x = x + a`. In addition, if the code uses the \u201c`-=`\u201d,\n+ *  pre-increment, post-increment, pre-decrement, or post-decrement operators,\n+ *  then the corresponding operators must be defined on `Type`.\n+ *\n+ *  The expression `Type()` must be a valid expression which yields the\n+ *  identity value (the value of `Type` whose numeric value is zero).\n+ *\n+ *  @section redopadd_in_c Addition Reducers in C\n+ *\n+ *  The @ref CILK_C_REDUCER_OPADD and @ref CILK_C_REDUCER_OPADD_TYPE macros can\n+ *  be used to do addition reductions in C. For example:\n+ *\n+ *      CILK_C_REDUCER_OPADD(r, double, 0);\n+ *      CILK_C_REGISTER_REDUCER(r);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(r) += a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(r);\n+ *      printf(\"The sum of the elements of a is %f\\n\", REDUCER_VIEW(r));\n+ *\n+ *  See @ref reducers_c_predefined.\n+ */\n+\n+#ifdef __cplusplus\n+\n+namespace cilk {\n+\n+/** The addition reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_add<Type> >`. It holds the accumulator variable \n+ *  for the reduction, and allows only addition and subtraction operations to \n+ *  be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `+=` operation would be used in an expression like `*r += a`, where\n+ *          `r` is an op_add reducer variable.\n+ *\n+ *  @tparam Type    The type of the contained accumulator variable. This will \n+ *                  be the value type of a monoid_with_view that is \n+ *                  instantiated with this view.\n+ *\n+ *  @see ReducersAdd\n+ *  @see op_add\n+ *\n+ *  @ingroup ReducersAdd\n+ */\n+template <typename Type>\n+class op_add_view : public scalar_view<Type>\n+{\n+    typedef scalar_view<Type> base;\n+    \n+public:\n+    /** Class to represent the right-hand side of \n+     *  `*reducer = *reducer \u00b1 value`.\n+     *\n+     *  The only assignment operator for the op_add_view class takes an\n+     *  rhs_proxy as its operand. This results in the syntactic restriction\n+     *  that the only expressions that can be assigned to an op_add_view are\n+     *  ones which generate an rhs_proxy \u2014 that is, expressions of the form\n+     *  `op_add_view \u00b1 value ... \u00b1 value`.\n+     *\n+     *  @warning\n+     *  The lhs and rhs views in such an assignment must be the same; \n+     *  otherwise, the behavior will be undefined. (I.e., `v1 = v1 + x` is\n+     *  legal; `v1 = v2 + x` is illegal.) This condition will be checked with a\n+     *  runtime assertion when compiled in debug mode.\n+     *\n+     *  @see op_add_view\n+     */\n+    class rhs_proxy {\n+        friend class op_add_view;\n+\n+        const op_add_view* m_view;\n+        Type               m_value;\n+\n+        // Constructor is invoked only from op_add_view::operator+() and \n+        // op_add_view::operator-().\n+        //\n+        rhs_proxy(const op_add_view* view, const Type& value) :\n+            m_view(view), m_value(value) {}\n+\n+        rhs_proxy& operator=(const rhs_proxy&); // Disable assignment operator\n+        rhs_proxy();                            // Disable default constructor\n+\n+    public:\n+        //@{\n+        /** Add or subtract an additional rhs value. If `v` is an op_add_view\n+         *  and `a1` is a value, then the expression `v + a1` invokes the view\u2019s\n+         *  `operator+()` to create an rhs_proxy for `(v, a1)`; then \n+         *  `v + a1 + a2` invokes the rhs_proxy\u2019s `operator+()` to create a new\n+         *  rhs_proxy for `(v, a1+a2)`. This allows the right-hand side of an\n+         *  assignment to be not just `view \u00b1 value`, but \n+         *  `view \u00b1 value \u00b1 value ... \u00b1 value`. The effect is that\n+         *\n+         *      v = v \u00b1 a1 \u00b1 a2 ... \u00b1 an;\n+         *\n+         *  is evaluated as\n+         *\n+         *      v = v \u00b1 (\u00b1a1 \u00b1 a2 ... \u00b1 an);\n+         */\n+        rhs_proxy& operator+(const Type& x) { m_value += x; return *this; }\n+        rhs_proxy& operator-(const Type& x) { m_value -= x; return *this; }\n+        //@}\n+    };\n+\n+    \n+    /** Default/identity constructor. This constructor initializes the \n+     *  contained value to `Type()`, which is expected to be the identity value\n+     *  for addition on `Type`.\n+     */\n+    op_add_view() : base() {}\n+\n+    /** Construct with a specified initial value.\n+     */\n+    explicit op_add_view(const Type& v) : base(v) {}\n+    \n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_add monoid to combine the views\n+     *  of two strands when the right strand merges with the left one. It adds\n+     *  the value contained in the right-strand view to the value contained in\n+     *  the left-strand view, and leaves the value in the right-strand view\n+     *  undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_add monoid to implement the monoid\n+     *          reduce operation.\n+     */\n+    void reduce(op_add_view* right) { this->m_value += right->m_value; }\n+\n+    /** @name Accumulator variable updates.\n+     *\n+     *  These functions support the various syntaxes for incrementing or\n+     *  decrementing the accumulator variable contained in the view.\n+     */\n+    //@{\n+\n+    /** Increment the accumulator variable by @a x.\n+     */\n+    op_add_view& operator+=(const Type& x) { this->m_value += x; return *this; }\n+\n+    /** Decrement the accumulator variable by @a x.\n+     */\n+    op_add_view& operator-=(const Type& x) { this->m_value -= x; return *this; }\n+\n+    /** Pre-increment.\n+     */\n+    op_add_view& operator++() { ++this->m_value; return *this; }\n+\n+    /** Post-increment.\n+     *\n+     *  @note   Conventionally, post-increment operators return the old value\n+     *          of the incremented variable. However, reducer views do not\n+     *          expose their contained values, so `view++` does not have a\n+     *          return value.\n+     */\n+    void operator++(int) { this->m_value++; }\n+\n+    /** Pre-decrement.\n+     */\n+    op_add_view& operator--() { --this->m_value; return *this; }\n+\n+    /** Post-decrement.\n+     *\n+     *  @note   Conventionally, post-decrement operators return the old value\n+     *          of the decremented variable. However, reducer views do not\n+     *          expose their contained values, so `view--` does not have a\n+     *          return value.\n+     */\n+    void operator--(int) { this->m_value--; }\n+\n+    /** Create an object representing `*this + x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator+(const Type& x) const { return rhs_proxy(this, x); }\n+\n+    /** Create an object representing `*this - x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator-(const Type& x) const { return rhs_proxy(this, -x); }\n+\n+    /** Assign the result of a `view \u00b1 value` expression to the view. Note that\n+     *  this is the only assignment operator for this class.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    op_add_view& operator=(const rhs_proxy& rhs) {\n+        __CILKRTS_ASSERT(this == rhs.m_view);\n+        this->m_value += rhs.m_value;\n+        return *this;\n+    }\n+    \n+    //@}\n+};\n+\n+\n+/** Monoid class for addition reductions. Instantiate the cilk::reducer \n+ *  template class with an op_add monoid to create an addition reducer class.\n+ *  For example, to compute\n+ *  the sum of a set of `int` values:\n+ *\n+ *      cilk::reducer< cilk::op_add<int> > r;\n+ *\n+ *  @tparam Type    The reducer value type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersAdd\n+ *  @see op_add_view\n+ *\n+ *  @ingroup ReducersAdd\n+ */\n+template <typename Type, bool Align = false>\n+struct op_add : public monoid_with_view<op_add_view<Type>, Align> {};\n+\n+/** **Deprecated** addition reducer wrapper class.\n+ *\n+ *  reducer_opadd is the same as @ref reducer<@ref op_add>, except that\n+ *  reducer_opadd is a proxy for the contained view, so that accumulator\n+ *  variable update operations can be applied directly to the reducer. For\n+ *  example, a value is added to a `reducer<%op_add>` with `*r += a`, but a\n+ *  value can be added to a `%reducer_opadd` with `r += a`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_opadd. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_opadd` \n+ *          and `reducer<%op_add>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_opadd` can pass a\n+ *          `%reducer_opadd` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_add>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type    The value type of the reducer.\n+ *\n+ *  @see op_add\n+ *  @see reducer\n+ *  @see ReducersAdd\n+ *\n+ *  @ingroup ReducersAdd\n+ */\n+template <typename Type>\n+class reducer_opadd : public reducer< op_add<Type, true> >\n+{\n+    typedef reducer< op_add<Type, true> > base;\n+    using base::view;\n+\n+  public:\n+    /// The view type for the reducer.\n+    typedef typename base::view_type        view_type;\n+    \n+    /// The view\u2019s rhs proxy type.\n+    typedef typename view_type::rhs_proxy   rhs_proxy;\n+\n+    /// The view type for the reducer.\n+    typedef view_type                       View;\n+\n+    /// The monoid type for the reducer.\n+    typedef typename base::monoid_type      Monoid;\n+\n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Default (identity) constructor.\n+     *\n+     * Constructs the wrapper with the default initial value of `Type()`.\n+     */\n+    reducer_opadd() {}\n+\n+    /** Value constructor.\n+     *\n+     *  Constructs the wrapper with a specified initial value.\n+     */\n+    explicit reducer_opadd(const Type& initial_value) : base(initial_value) {}\n+    \n+    //@}\n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_add_view. */\n+    //@{\n+    \n+    /// @copydoc op_add_view::operator+=(const Type&)\n+    reducer_opadd& operator+=(const Type& x)    { view() += x; return *this; }\n+    \n+    /// @copydoc op_add_view::operator-=(const Type&)\n+    reducer_opadd& operator-=(const Type& x)    { view() -= x; return *this; }\n+    \n+    /// @copydoc op_add_view::operator++()\n+    reducer_opadd& operator++()                 { ++view(); return *this; }\n+    \n+    /// @copydoc op_add_view::operator++(int)\n+    void operator++(int)                        { view()++; }\n+    \n+    /// @copydoc op_add_view::operator-\\-()\n+    reducer_opadd& operator--()                 { --view(); return *this; }\n+    \n+    /// @copydoc op_add_view::operator-\\-(int)\n+    void operator--(int)                        { view()--; }\n+\n+    // The legacy definitions of reducer_opadd::operator+() and\n+    // reducer_opadd::operator-() have different behavior and a different\n+    // return type than this definition. The legacy version is defined as a\n+    // member function, so this new version is defined as a free function to\n+    // give it a different signature, so that they won\u2019t end up sharing a\n+    // single object file entry.\n+\n+    /// @copydoc op_add_view::operator+(const Type&) const\n+    friend rhs_proxy operator+(const reducer_opadd& r, const Type& x)\n+    { \n+        return r.view() + x; \n+    }\n+    /// @copydoc op_add_view::operator-(const Type&) const\n+    friend rhs_proxy operator-(const reducer_opadd& r, const Type& x)\n+    { \n+        return r.view() - x; \n+    }\n+    /// @copydoc op_add_view::operator=(const rhs_proxy&)\n+    reducer_opadd& operator=(const rhs_proxy& temp) \n+    {\n+        view() = temp;\n+        return *this; \n+    }\n+    //@}\n+\n+    /** @name Dereference\n+     *  @details Dereferencing a wrapper is a no-op. It simply returns the\n+     *  wrapper. Combined with the rule that the wrapper forwards view\n+     *  operations to its contained view, this means that view operations can\n+     *  be written the same way on reducers and wrappers, which is convenient\n+     *  for incrementally converting old code using wrappers to use reducers\n+     *  instead. That is:\n+     *\n+     *      reducer< op_add<int> > r;\n+     *      *r += a;    // *r returns the view\n+     *                  // operator += is a view member function\n+     *\n+     *      reducer_opadd<int> w;\n+     *      *w += a;    // *w returns the wrapper\n+     *                  // operator += is a wrapper member function that\n+     *                  // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_opadd&       operator*()       { return *this; }\n+    reducer_opadd const& operator*() const { return *this; }\n+\n+    reducer_opadd*       operator->()       { return this; }\n+    reducer_opadd const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_add<Type, false> >& ()\n+    {\n+        return *reinterpret_cast< reducer< op_add<Type, false> >* >(this);\n+    }\n+    operator const reducer< op_add<Type, false> >& () const\n+    {\n+        return *reinterpret_cast< const reducer< op_add<Type, false> >* >(this);\n+    }\n+    //@}\n+};\n+\n+/// @cond internal\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class \n+ *  defined in reducer.h causes the `reducer< op_add<Type> >` class to have an \n+ *  `operator reducer_opadd<Type>& ()` conversion operator that statically \n+ *  downcasts the `reducer<op_add>` to the corresponding `reducer_opadd` type.\n+ *  (The reverse conversion, from `reducer_opadd` to `reducer<op_add>`, is just\n+ *  an upcast, which is provided for free by the language.)\n+ *\n+ *  @ingroup ReducersAdd\n+ */\n+template <typename Type, bool Align>\n+struct legacy_reducer_downcast<reducer<op_add<Type, Align> > >\n+{\n+    typedef reducer_opadd<Type> type;\n+};\n+/// @endcond\n+\n+} // namespace cilk\n+\n+#endif // __cplusplus\n+\n+\n+/** @ingroup ReducersAdd\n+ */\n+//@{\n+\n+/** @name C Language Reducer Macros\n+ *\n+ *  These macros are used to declare and work with numeric op_add reducers in \n+ *  C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+ \n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Opadd reducer type name.\n+ *\n+ *  This macro expands into the identifier which is the name of the op_add\n+ *  reducer type for a specified numeric type.\n+ *\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersAdd\n+ */\n+#define CILK_C_REDUCER_OPADD_TYPE(tn)                                         \\\n+    __CILKRTS_MKIDENT(cilk_c_reducer_opadd_,tn)\n+\n+/** Declare an op_add reducer object.\n+ *\n+ *  This macro expands into a declaration of an op_add reducer object for a\n+ *  specified numeric type. For example:\n+ *\n+ *      CILK_C_REDUCER_OPADD(my_reducer, double, 0.0);\n+ *\n+ *  @param  obj The variable name to be used for the declared reducer object.\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *  @param  v   The initial value for the reducer. (A value which can be\n+ *              assigned to the numeric type represented by @a tn.)\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersAdd\n+ */\n+#define CILK_C_REDUCER_OPADD(obj,tn,v)                                        \\\n+    CILK_C_REDUCER_OPADD_TYPE(tn) obj =                                       \\\n+        CILK_C_INIT_REDUCER(_Typeof(obj.value),                               \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opadd_reduce_,tn),   \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opadd_identity_,tn), \\\n+                        __cilkrts_hyperobject_noop_destroy, v)\n+\n+/// @cond internal\n+\n+/** Declare the op_add reducer functions for a numeric type.\n+ *\n+ *  This macro expands into external function declarations for functions which\n+ *  implement the reducer functionality for the op_add reducer type for a\n+ *  specified numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPADD_DECLARATION(t,tn)                             \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPADD_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opadd,tn,l,r);         \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opadd,tn);\n+ \n+/** Define the op_add reducer functions for a numeric type.\n+ *\n+ *  This macro expands into function definitions for functions which implement\n+ *  the reducer functionality for the op_add reducer type for a specified\n+ *  numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPADD_DEFINITION(t,tn)                              \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPADD_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opadd,tn,l,r)          \\\n+        { *(t*)l += *(t*)r; }                                              \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opadd,tn)            \\\n+        { *(t*)v = 0; }\n+ \n+//@{\n+/** @def CILK_C_REDUCER_OPADD_INSTANCE \n+ *  @brief Declare or define implementation functions for a reducer type.\n+ *\n+ *  In the runtime source file c_reducers.c, the macro `CILK_C_DEFINE_REDUCERS`\n+ *  will be defined, and this macro will generate reducer implementation \n+ *  functions. Everywhere else, `CILK_C_DEFINE_REDUCERS` will be undefined,\n+ *  and this macro will expand into external declarations for the functions.\n+ */\n+#ifdef CILK_C_DEFINE_REDUCERS\n+#   define CILK_C_REDUCER_OPADD_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPADD_DEFINITION(t,tn)\n+#else\n+#   define CILK_C_REDUCER_OPADD_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPADD_DECLARATION(t,tn)\n+#endif\n+//@}\n+\n+/*  Declare or define an instance of the reducer type and its functions for each \n+ *  numeric type.\n+ */\n+CILK_C_REDUCER_OPADD_INSTANCE(char,                 char)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned char,        uchar)\n+CILK_C_REDUCER_OPADD_INSTANCE(signed char,          schar)\n+CILK_C_REDUCER_OPADD_INSTANCE(wchar_t,              wchar_t)\n+CILK_C_REDUCER_OPADD_INSTANCE(short,                short)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned short,       ushort)\n+CILK_C_REDUCER_OPADD_INSTANCE(int,                  int)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned int,         uint)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned int,         unsigned) /* alternate name */\n+CILK_C_REDUCER_OPADD_INSTANCE(long,                 long)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned long,        ulong)\n+CILK_C_REDUCER_OPADD_INSTANCE(long long,            longlong)\n+CILK_C_REDUCER_OPADD_INSTANCE(unsigned long long,   ulonglong)\n+CILK_C_REDUCER_OPADD_INSTANCE(float,                float)\n+CILK_C_REDUCER_OPADD_INSTANCE(double,               double)\n+CILK_C_REDUCER_OPADD_INSTANCE(long double,          longdouble)\n+\n+//@endcond\n+\n+__CILKRTS_END_EXTERN_C\n+\n+//@}\n+\n+//@}\n+\n+#endif /*  REDUCER_OPADD_H_INCLUDED */"}, {"sha": "8a086c91818d3a120686cec69f9d97a18114a4f2", "filename": "libcilkrts/include/cilk/reducer_opand.h", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,604 @@\n+/*  reducer_opand.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_opand.h\n+ *\n+ *  @brief Defines classes for doing parallel bitwise and reductions.\n+ *\n+ *  @ingroup ReducersAnd\n+ *\n+ *  @see ReducersAnd\n+ */\n+\n+#ifndef REDUCER_OPAND_H_INCLUDED\n+#define REDUCER_OPAND_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+\n+/** @defgroup ReducersAnd Bitwise And Reducers\n+ *\n+ *  Bitwise and reducers allow the computation of the bitwise and of a set of\n+ *  values in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redopand_usage Usage Example\n+ *\n+ *      cilk::reducer< cilk::op_and<unsigned> > r;\n+ *      cilk_for (int i = 0; i != N; ++i) {\n+ *          *r &= a[i];\n+ *      }\n+ *      unsigned result;\n+ *      r.move_out(result);\n+ *\n+ *  @section redopand_monoid The Monoid\n+ *\n+ *  @subsection redopand_monoid_values Value Set\n+ *\n+ *  The value set of a bitwise and reducer is the set of values of `Type`, \n+ *  which is expected to be a builtin integer type which has a representation\n+ *  as a sequence of bits (or something like it, such as `bool` or\n+ *  `std::bitset`).\n+ *\n+ *  @subsection redopand_monoid_operator Operator\n+ *\n+ *  The operator of a bitwise and reducer is the bitwise and operator, defined\n+ *  by the \u201c`&`\u201d binary operator on `Type`.\n+ *\n+ *  @subsection redopand_monoid_identity Identity\n+ *\n+ *  The identity value of the reducer is the value whose representation \n+ *  contains all 1-bits. This is expected to be the value of the expression\n+ *  `~Type()` (i.e., the bitwise negation operator applied to the default value\n+ *  of the value type).\n+ *\n+ *  @section redopand_operations Operations\n+ *\n+ *  @subsection redopand_constructors Constructors\n+ *\n+ *      reducer()   // identity\n+ *      reducer(const Type& value)\n+ *      reducer(move_in(Type& variable))\n+ *\n+ *  @subsection redopand_get_set Set and Get\n+ *\n+ *      r.set_value(const Type& value)\n+ *      const Type& = r.get_value() const\n+ *      r.move_in(Type& variable)\n+ *      r.move_out(Type& variable)\n+ *\n+ *  @subsection redopand_initial Initial Values\n+ *\n+ *  If a bitwise and reducer is constructed without an explicit initial value,\n+ *  then its initial value will be its identity value, as long as `Type`\n+ *  satisfies the requirements of @ref redopand_types.\n+ *\n+ *  @subsection redopand_view_ops View Operations\n+ *\n+ *      *r &= a\n+ *      *r = *r & a\n+ *      *r = *r & a1 & a2 \u2026 & an\n+ *\n+ *  @section redopand_types Type and Operator Requirements\n+ *\n+ *  `Type` must be `Copy Constructible`, `Default Constructible`, and\n+ *  `Assignable`.\n+ *\n+ *  The operator \u201c`&=`\u201d must be defined on `Type`, with `x &= a` having the \n+ *  same meaning as `x = x & a`.\n+ *\n+ *  The expression `~ Type()` must be a valid expression which yields the\n+ *  identity value (the value of `Type` whose representation consists of all\n+ *  1-bits).\n+ *\n+ *  @section redopand_in_c Bitwise And Reducers in C\n+ *\n+ *  The @ref CILK_C_REDUCER_OPAND and @ref CILK_C_REDUCER_OPAND_TYPE macros can\n+ *  be used to do bitwise and reductions in C. For example:\n+ *\n+ *      CILK_C_REDUCER_OPAND(r, uint, ~0);\n+ *      CILK_C_REGISTER_REDUCER(r);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(r) &= a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(r);\n+ *      printf(\"The bitwise AND of the elements of a is %x\\n\", REDUCER_VIEW(r));\n+ *\n+ *  See @ref reducers_c_predefined.\n+ */\n+\n+#ifdef __cplusplus\n+\n+namespace cilk {\n+\n+/** The bitwise and reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_and<Type> >`. It holds the accumulator variable \n+ *  for the reduction, and allows only `and` operations to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`)\n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `&=` operation would be used in an expression like `*r &= a`, where\n+ *          `r` is an opmod reducer variable.\n+ *\n+ *  @tparam Type    The type of the contained accumulator variable. This will\n+ *                  be the value type of a monoid_with_view that is\n+ *                  instantiated with this view.\n+ *\n+ *  @see ReducersAnd\n+ *  @see op_and\n+ *\n+ *  @ingroup ReducersAnd\n+ */\n+template <typename Type>\n+class op_and_view : public scalar_view<Type>\n+{\n+    typedef scalar_view<Type> base;\n+    \n+public:\n+    /** Class to represent the right-hand side of `*reducer = *reducer & value`.\n+     *\n+     *  The only assignment operator for the op_and_view class takes an\n+     *  rhs_proxy as its operand. This results in the syntactic restriction \n+     *  that the only expressions that can be assigned to an op_and_view are\n+     *  ones which generate an rhs_proxy \u2014 that is, expressions of the form\n+     *  `op_and_view & value ... & value`.\n+     *\n+     *  @warning\n+     *  The lhs and rhs views in such an assignment must be the same; \n+     *  otherwise, the behavior will be undefined. (I.e., `v1 = v1 & x` is\n+     *  legal; `v1 = v2 & x` is illegal.)  This condition will be checked with\n+     *  a runtime assertion when compiled in debug mode.\n+     *\n+     *  @see op_and_view\n+     */\n+    class rhs_proxy {\n+    private:\n+        friend class op_and_view;\n+\n+        const op_and_view* m_view;\n+        Type               m_value;\n+\n+        // Constructor is invoked only from op_and_view::operator&().\n+        //\n+        rhs_proxy(const op_and_view* view, const Type& value) : m_view(view), m_value(value) {}\n+\n+        rhs_proxy& operator=(const rhs_proxy&); // Disable assignment operator\n+        rhs_proxy();                            // Disable default constructor\n+\n+    public:\n+        /** Bitwise and with an additional rhs value. If `v` is an op_and_view\n+         *  and `a1` is a value, then the expression `v & a1` invokes the\n+         *  view\u2019s `operator&()` to create an rhs_proxy for `(v, a1)`; then\n+         *  `v & a1 & a2` invokes the rhs_proxy\u2019s `operator&()` to create a new\n+         *  rhs_proxy for `(v, a1&a2)`. This allows the right-hand side of an\n+         *  assignment to be not just `view & value`, but \n+         *  `view & value & value ... & value`. The effect is that\n+         *\n+         *      v = v & a1 & a2 ... & an;\n+         *\n+         *  is evaluated as\n+         *\n+         *      v = v & (a1 & a2 ... & an);\n+         */\n+        rhs_proxy& operator&(const Type& x) { m_value &= x; return *this; }\n+    };\n+\n+\n+    /** Default/identity constructor. This constructor initializes the\n+     *  contained value to `~ Type()`.\n+     */\n+    op_and_view() : base(~Type()) {}\n+\n+    /** Construct with a specified initial value.\n+     */\n+    explicit op_and_view(const Type& v) : base(v) {}\n+    \n+    \n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_and monoid to combine the views\n+     *  of two strands when the right strand merges with the left one. It\n+     *  \u201cands\u201d the value contained in the left-strand view with the value\n+     *  contained in the right-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_and monoid to implement the monoid\n+     *          reduce operation.\n+     */\n+    void reduce(op_and_view* right) { this->m_value &= right->m_value; }\n+    \n+    /** @name Accumulator variable updates.\n+     *\n+     *  These functions support the various syntaxes for \u201canding\u201d the\n+     *  accumulator variable contained in the view with some value.\n+     */\n+    //@{\n+\n+    /** And the accumulator variable with @a x.\n+     */\n+    op_and_view& operator&=(const Type& x) { this->m_value &= x; return *this; }\n+\n+    /** Create an object representing `*this & x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator&(const Type& x) const { return rhs_proxy(this, x); }\n+\n+    /** Assign the result of a `view & value` expression to the view. Note that\n+     *  this is the only assignment operator for this class.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    op_and_view& operator=(const rhs_proxy& rhs) {\n+        __CILKRTS_ASSERT(this == rhs.m_view);\n+        this->m_value &= rhs.m_value;\n+        return *this;\n+    }\n+    \n+    //@}\n+};\n+\n+/** Monoid class for bitwise and reductions. Instantiate the cilk::reducer\n+ *  template class with an op_and monoid to create a bitwise and reducer\n+ *  class. For example, to compute the bitwise and of a set of `unsigned long`\n+ *  values:\n+ *\n+ *      cilk::reducer< cilk::op_and<unsigned long> > r;\n+ *\n+ *  @tparam Type    The reducer value type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersAnd\n+ *  @see op_and_view\n+ *\n+ *  @ingroup ReducersAnd\n+ */\n+template <typename Type, bool Align = false>\n+struct op_and : public monoid_with_view<op_and_view<Type>, Align> {};\n+\n+/** Deprecated bitwise and reducer class.\n+ *\n+ *  reducer_opand is the same as @ref reducer<@ref op_and>, except that\n+ *  reducer_opand is a proxy for the contained view, so that accumulator\n+ *  variable update operations can be applied directly to the reducer. For\n+ *  example, a value is anded with  a `reducer<%op_and>` with `*r &= a`, but a\n+ *  value can be anded with a `%reducer_opand` with `r &= a`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_opand. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_opand` \n+ *          and `reducer<%op_and>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_opand` can pass a\n+ *          `%reducer_opand` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_and>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type    The value type of the reducer.\n+ *\n+ *  @see op_and\n+ *  @see reducer\n+ *  @see ReducersAnd\n+ *\n+ *  @ingroup ReducersAnd\n+ */\n+template <typename Type>\n+class reducer_opand : public reducer< op_and<Type, true> >\n+{\n+    typedef reducer< op_and<Type, true> > base;\n+    using base::view;\n+\n+public:\n+    /// The view type for the reducer.\n+    typedef typename base::view_type        view_type;\n+    \n+    /// The view\u2019s rhs proxy type.\n+    typedef typename view_type::rhs_proxy   rhs_proxy;\n+    \n+    /// The view type for the reducer.\n+    typedef view_type                       View;\n+\n+    /// The monoid type for the reducer.\n+    typedef typename base::monoid_type      Monoid;\n+    \n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Default constructor.\n+     *\n+     *  Constructs the wrapper with the default initial value of `Type()`\n+     *  (not the identity value).\n+     */\n+    reducer_opand() : base(Type()) {}\n+\n+    /** Value constructor.\n+     *\n+     *  Constructs the wrapper with a specified initial value.\n+     */\n+    explicit reducer_opand(const Type& initial_value) : base(initial_value) {}\n+    \n+    //@}\n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_and_view. */\n+    //@{\n+\n+    /// @copydoc op_and_view::operator&=(const Type&)\n+    reducer_opand& operator&=(const Type& x)\n+    {\n+        view() &= x;\n+        return *this;\n+    }\n+    \n+    // The legacy definition of reducer_opand::operator&() has different\n+    // behavior and a different return type than this definition. The legacy\n+    // version is defined as a member function, so this new version is defined\n+    // as a free function to give it a different signature, so that they won\u2019t \n+    // end up sharing a single object file entry.\n+    \n+    /// @copydoc op_and_view::operator&(const Type&) const\n+    friend rhs_proxy operator&(const reducer_opand& r, const Type& x)\n+    { \n+        return r.view() & x; \n+    }\n+\n+    /// @copydoc op_and_view::operator=(const rhs_proxy&)\n+    reducer_opand& operator=(const rhs_proxy& temp) \n+    { \n+        view() = temp;\n+        return *this; \n+    }\n+    //@}\n+\n+    /** @name Dereference\n+     *  @details Dereferencing a wrapper is a no-op. It simply returns the\n+     *  wrapper. Combined with the rule that the wrapper forwards view\n+     *  operations to its contained view, this means that view operations can\n+     *  be written the same way on reducers and wrappers, which is convenient\n+     *  for incrementally converting old code using wrappers to use reducers\n+     *  instead. That is:\n+     *\n+     *      reducer< op_and<int> > r;\n+     *      *r &= a;    // *r returns the view\n+     *                  // operator &= is a view member function\n+     *\n+     *      reducer_opand<int> w;\n+     *      *w &= a;    // *w returns the wrapper\n+     *                  // operator &= is a wrapper member function that\n+     *                  // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_opand&       operator*()       { return *this; }\n+    reducer_opand const& operator*() const { return *this; }\n+\n+    reducer_opand*       operator->()       { return this; }\n+    reducer_opand const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_and<Type, false> >& ()\n+    {\n+        return *reinterpret_cast< reducer< op_and<Type, false> >* >(this);\n+    }\n+    operator const reducer< op_and<Type, false> >& () const\n+    {\n+        return *reinterpret_cast< const reducer< op_and<Type, false> >* >(this);\n+    }\n+    //@}\n+};\n+\n+/// @cond internal\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class \n+ *  defined in reducer.h causes the `reducer< op_and<Type> >` class to have an \n+ *  `operator reducer_opand<Type>& ()` conversion operator that statically\n+ *  downcasts the `reducer<op_and>` to the corresponding `reducer_opand` type.\n+ *  (The reverse conversion, from `reducer_opand` to `reducer<op_and>`, is just\n+ *  an upcast, which is provided for free by the language.)\n+ *\n+ *  @ingroup ReducersAnd\n+ */\n+template <typename Type, bool Align>\n+struct legacy_reducer_downcast<reducer<op_and<Type, Align> > >\n+{\n+    typedef reducer_opand<Type> type;\n+};\n+/// @endcond\n+\n+} // namespace cilk\n+\n+#endif // __cplusplus\n+\n+\n+/** @ingroup ReducersAdd\n+ */\n+//@{\n+\n+/** @name C language reducer macros\n+ *\n+ *  These macros are used to declare and work with op_and reducers in C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+ \n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Opand reducer type name.\n+ *\n+ *  This macro expands into the identifier which is the name of the op_and \n+ *  reducer type for a specified numeric type.\n+ *\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersAnd\n+ */\n+#define CILK_C_REDUCER_OPAND_TYPE(tn)                                         \\\n+    __CILKRTS_MKIDENT(cilk_c_reducer_opand_,tn)\n+\n+/** Declare an op_and reducer object.\n+ *\n+ *  This macro expands into a declaration of an op_and reducer object for a\n+ *  specified numeric type. For example:\n+ *\n+ *      CILK_C_REDUCER_OPAND(my_reducer, ulong, ~0UL);\n+ *\n+ *  @param  obj The variable name to be used for the declared reducer object.\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *  @param  v   The initial value for the reducer. (A value which can be\n+ *              assigned to the numeric type represented by @a tn.)\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersAnd\n+ */\n+#define CILK_C_REDUCER_OPAND(obj,tn,v)                                        \\\n+    CILK_C_REDUCER_OPAND_TYPE(tn) obj =                                       \\\n+        CILK_C_INIT_REDUCER(_Typeof(obj.value),                               \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opand_reduce_,tn),   \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opand_identity_,tn), \\\n+                        __cilkrts_hyperobject_noop_destroy, v)\n+\n+/// @cond internal\n+\n+/** Declare the op_and reducer functions for a numeric type.\n+ *\n+ *  This macro expands into external function declarations for functions which\n+ *  implement the reducer functionality for the op_and reducer type for a\n+ *  specified numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPAND_DECLARATION(t,tn)                             \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPAND_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opand,tn,l,r);         \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opand,tn);\n+ \n+/** Define the op_and reducer functions for a numeric type.\n+ *\n+ *  This macro expands into function definitions for functions which implement\n+ *  the reducer functionality for the op_and reducer type for a specified\n+ *  numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPAND_DEFINITION(t,tn)                              \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPAND_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opand,tn,l,r)          \\\n+        { *(t*)l &= *(t*)r; }                                              \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opand,tn)            \\\n+        { *(t*)v = ~((t)0); }\n+ \n+//@{\n+/** @def CILK_C_REDUCER_OPAND_INSTANCE \n+ *  @brief Declare or define implementation functions for a reducer type.\n+ *\n+ *  In the runtime source file c_reducers.c, the macro `CILK_C_DEFINE_REDUCERS`\n+ *  will be defined, and this macro will generate reducer implementation\n+ *  functions. Everywhere else, `CILK_C_DEFINE_REDUCERS` will be undefined, and\n+ *  this macro will expand into external declarations for the functions.\n+ */\n+#ifdef CILK_C_DEFINE_REDUCERS\n+#   define CILK_C_REDUCER_OPAND_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPAND_DEFINITION(t,tn)\n+#else\n+#   define CILK_C_REDUCER_OPAND_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPAND_DECLARATION(t,tn)\n+#endif\n+//@}\n+\n+/*  Declare or define an instance of the reducer type and its functions for\n+ *  each numeric type.\n+ */\n+CILK_C_REDUCER_OPAND_INSTANCE(char,                 char)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned char,        uchar)\n+CILK_C_REDUCER_OPAND_INSTANCE(signed char,          schar)\n+CILK_C_REDUCER_OPAND_INSTANCE(wchar_t,              wchar_t)\n+CILK_C_REDUCER_OPAND_INSTANCE(short,                short)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned short,       ushort)\n+CILK_C_REDUCER_OPAND_INSTANCE(int,                  int)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned int,         uint)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned int,         unsigned) /* alternate name */\n+CILK_C_REDUCER_OPAND_INSTANCE(long,                 long)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned long,        ulong)\n+CILK_C_REDUCER_OPAND_INSTANCE(long long,            longlong)\n+CILK_C_REDUCER_OPAND_INSTANCE(unsigned long long,   ulonglong)\n+\n+//@endcond\n+\n+__CILKRTS_END_EXTERN_C\n+\n+//@}\n+\n+//@}\n+\n+#endif /*  REDUCER_OPAND_H_INCLUDED */"}, {"sha": "271529d787b4da5a46d0e48a0346e010ae51394e", "filename": "libcilkrts/include/cilk/reducer_opmul.h", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,442 @@\n+/*  reducer_opmul.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2012-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_opmul.h\n+ *\n+ *  @brief Defines classes for doing parallel multiplication reductions.\n+ *\n+ *  @ingroup ReducersMul\n+ *\n+ *  @see ReducersMul\n+ */\n+\n+#ifndef REDUCER_OPMUL_H_INCLUDED\n+#define REDUCER_OPMUL_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+\n+/** @defgroup ReducersMul Multiplication Reducers\n+ *\n+ *  Multiplication reducers allow the computation of the product of a set of\n+ *  values in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redopmul_usage Usage Example\n+ *\n+ *      cilk::reducer< cilk::op_mul<double> > r;\n+ *      cilk_for (int i = 0; i != N; ++i) {\n+ *          *r *= a[i];\n+ *      }\n+ *      double product;\n+ *      r.move_out(product);\n+ *\n+ *  @section redopmul_monoid The Monoid\n+ *\n+ *  @subsection redopmul_monoid_values Value Set\n+ *\n+ *  The value set of a multiplication reducer is the set of values of `Type`,\n+ *  which is expected to be a builtin numeric type (or something like it, such\n+ *  as `std::complex`).\n+ *\n+ *  @subsection redopmul_monoid_operator Operator\n+ *\n+ *  The operator of a multiplication reducer is the multiplication operation,\n+ *  defined by the \u201c`*`\u201d binary operator on `Type`.\n+ *\n+ *  @subsection redopmul_monoid_identity Identity\n+ *\n+ *  The identity value of the reducer is the numeric value \u201c`1`\u201d. This is\n+ *  expected to be the value of the expression `Type(1)`.\n+ *\n+ *  @section redopmul_operations Operations\n+ *\n+ *  @subsection redopmul_constructors Constructors\n+ *\n+ *      reducer()   // identity\n+ *      reducer(const Type& value)\n+ *      reducer(move_in(Type& variable))\n+ *\n+ *  @subsection redopmul_get_set Set and Get\n+ *\n+ *      r.set_value(const Type& value)\n+ *      const Type& = r.get_value() const\n+ *      r.move_in(Type& variable)\n+ *      r.move_out(Type& variable)\n+ *\n+ *  @subsection redopmul_initial Initial Values\n+ *\n+ *  If a multiplication reducer is constructed without an explicit initial\n+ *  value, then its initial value will be its identity value, as long as `Type`\n+ *  satisfies the requirements of @ref redopmul_types.\n+ *\n+ *  @subsection redopmul_view_ops View Operations\n+ *\n+ *      *r *= a\n+ *      *r = *r * a\n+ *      *r = *r * a1 * a2 \u2026 * an\n+ *\n+ *  @section redopmul_floating_point Issues with Floating-Point Types\n+ *\n+ *  Because of overflow and underflow issues, floating-point multiplication is\n+ *  not really associative. For example, `(1e200 * 1e-200) * 1e-200 == 1e-200`,\n+ *  but `1e200 * (1e-200 * 1e-200 == 0.\n+ *\n+ *  In many cases, this won\u2019t matter, but computations which have been\n+ *  carefully ordered to control overflow and underflow may not deal well with\n+ *  being reassociated. In general, you should be sure to understand the\n+ *  floating-point behavior of your program before doing any transformation \n+ *  that will reassociate its computations. \n+ *\n+ *  @section redopmul_types Type and Operator Requirements\n+ *\n+ *  `Type` must be `Copy Constructible`, `Default Constructible`, and \n+ *  `Assignable`.\n+ *\n+ *  The operator \u201c`*=`\u201d must be defined on `Type`, with `x *= a` having the same\n+ *  meaning as `x = x * a`.\n+ *\n+ *  The expression `Type(1)` must be a valid expression which yields the\n+ *  identity value (the value of `Type` whose numeric value is `1`).\n+ *\n+ *  @section redopmul_in_c Multiplication Reducers in C\n+ *\n+ *  The @ref CILK_C_REDUCER_OPMUL and @ref CILK_C_REDUCER_OPMUL_TYPE macros can\n+ *  be used to do multiplication reductions in C. For example:\n+ *\n+ *      CILK_C_REDUCER_OPMUL(r, double, 1);\n+ *      CILK_C_REGISTER_REDUCER(r);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(r) *= a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(r);\n+ *      printf(\"The product of the elements of a is %f\\n\", REDUCER_VIEW(r));\n+ *\n+ *  See @ref reducers_c_predefined.\n+ */\n+\n+#ifdef __cplusplus\n+\n+namespace cilk {\n+\n+/** The multiplication reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_mul<Type> >`. It holds the accumulator variable \n+ *  for the reduction, and allows only multiplication operations to be \n+ *  performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `*=` operation would be used in an expression like `*r *= a`, where\n+ *          `r` is an op_mul reducer variable.\n+ *\n+ *  @tparam Type    The type of the contained accumulator variable. This will \n+ *                  be the value type of a monoid_with_view that is \n+ *                  instantiated with this view.\n+ *\n+ *  @see ReducersMul\n+ *  @see op_mul\n+ *\n+ *  @ingroup ReducersMul\n+ */\n+template <typename Type>\n+class op_mul_view : public scalar_view<Type>\n+{\n+    typedef scalar_view<Type> base;\n+    \n+public:\n+    /** Class to represent the right-hand side of `*reducer = *reducer * value`.\n+     *\n+     *  The only assignment operator for the op_mul_view class takes an \n+     *  rhs_proxy as its operand. This results in the syntactic restriction \n+     *  that the only expressions that can be assigned to an op_mul_view are\n+     *  ones which generate an rhs_proxy \u2014 that is, expressions of the form\n+     *  `op_mul_view * value ... * value`.\n+     *\n+     *  @warning\n+     *  The lhs and rhs views in such an assignment must be the same; \n+     *  otherwise, the behavior will be undefined. (I.e., `v1 = v1 * x` is\n+     *  legal; `v1 = v2 * x` is illegal.) This condition will be checked with a\n+     *  runtime assertion when compiled in debug mode.\n+     *\n+     *  @see op_mul_view\n+     */\n+    class rhs_proxy {\n+        friend class op_mul_view;\n+\n+        const op_mul_view* m_view;\n+        Type               m_value;\n+\n+        // Constructor is invoked only from op_mul_view::operator*().\n+        //\n+        rhs_proxy(const op_mul_view* view, const Type& value) : m_view(view), m_value(value) {}\n+\n+        rhs_proxy& operator=(const rhs_proxy&); // Disable assignment operator\n+        rhs_proxy();                            // Disable default constructor\n+\n+    public:\n+        /** Multiply by an additional rhs value. If `v` is an op_mul_view and \n+         *  `a1` is a value, then the expression `v * a1` invokes the view\u2019s\n+         *  `operator*()` to create an rhs_proxy for `(v, a1)`; then \n+         *  `v * a1 * a2` invokes the rhs_proxy\u2019s `operator*()` to create a\n+         *  new rhs_proxy for `(v, a1*a2)`. This allows the right-hand side of\n+         *  an assignment to be not just `view * value`, but \n+         *  `view * value * value ... * value`. The effect is that\n+         *\n+         *      v = v * a1 * a2 ... * an;\n+         *\n+         *  is evaluated as\n+         *\n+         *      v = v * (a1 * a2 ... * an);\n+         */\n+        rhs_proxy& operator*(const Type& x) { m_value *= x; return *this; }\n+    };\n+\n+\n+    /** Default/identity constructor. This constructor initializes the \n+     *  contained value to `Type(1)`, which is expected to be the identity\n+     *  value for multiplication on `Type`.\n+     */\n+    op_mul_view() : base(Type(1)) {}\n+\n+    /** Construct with a specified initial value.\n+     */\n+    explicit op_mul_view(const Type& v) : base(v) {}\n+    \n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_mul monoid to combine the views\n+     *  of two strands when the right strand merges with the left one. It\n+     *  multiplies the value contained in the left-strand view by the value\n+     *  contained in the right-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_mul monoid to implement the monoid\n+     *          reduce operation.\n+     */\n+    void reduce(op_mul_view* right) { this->m_value *= right->m_value; }\n+    \n+    /** @name Accumulator variable updates.\n+     *\n+     *  These functions support the various syntaxes for multiplying the\n+     *  accumulator variable contained in the view by some value.\n+     */\n+    //@{\n+\n+    /** Multiply the accumulator variable by @a x.\n+     */\n+    op_mul_view& operator*=(const Type& x) { this->m_value *= x; return *this; }\n+\n+    /** Create an object representing `*this * x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator*(const Type& x) const { return rhs_proxy(this, x); }\n+\n+    /** Assign the result of a `view * value` expression to the view. Note that\n+     *  this is the only assignment operator for this class.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    op_mul_view& operator=(const rhs_proxy& rhs) {\n+        __CILKRTS_ASSERT(this == rhs.m_view);\n+        this->m_value *= rhs.m_value;\n+        return *this;\n+    }\n+    \n+    //@}\n+};\n+\n+/** Monoid class for multiplication reductions. Instantiate the cilk::reducer\n+ *  template class with an op_mul monoid to create a multiplication reducer\n+ *  class. For example, to compute the product of a set of `double` values:\n+ *\n+ *      cilk::reducer< cilk::op_mul<double> > r;\n+ *\n+ *  @see ReducersMul\n+ *  @see op_mul_view\n+ *\n+ *  @ingroup ReducersMul\n+ */\n+template <typename Type>\n+struct op_mul : public monoid_with_view< op_mul_view<Type> > {};\n+\n+} // namespace cilk\n+\n+#endif // __cplusplus\n+\n+\n+/** @ingroup ReducersAdd\n+ */\n+//@{\n+\n+/** @name C language reducer macros\n+ *\n+ *  These macros are used to declare and work with numeric op_mul reducers in\n+ *  C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+ \n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Opmul reducer type name.\n+ *\n+ *  This macro expands into the identifier which is the name of the op_mul\n+ *  reducer type for a specified numeric type.\n+ *\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersMul\n+ */\n+#define CILK_C_REDUCER_OPMUL_TYPE(tn)                                         \\\n+    __CILKRTS_MKIDENT(cilk_c_reducer_opmul_,tn)\n+\n+/** Declare an op_mul reducer object.\n+ *\n+ *  This macro expands into a declaration of an op_mul reducer object for a\n+ *  specified numeric type. For example:\n+ *\n+ *      CILK_C_REDUCER_OPMUL(my_reducer, double, 1.0);\n+ *\n+ *  @param  obj The variable name to be used for the declared reducer object.\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *  @param  v   The initial value for the reducer. (A value which can be\n+ *              assigned to the numeric type represented by @a tn.)\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersMul\n+ */\n+#define CILK_C_REDUCER_OPMUL(obj,tn,v)                                        \\\n+    CILK_C_REDUCER_OPMUL_TYPE(tn) obj =                                       \\\n+        CILK_C_INIT_REDUCER(_Typeof(obj.value),                               \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opmul_reduce_,tn),   \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opmul_identity_,tn), \\\n+                        __cilkrts_hyperobject_noop_destroy, v)\n+\n+/// @cond internal\n+\n+/** Declare the op_mul reducer functions for a numeric type.\n+ *\n+ *  This macro expands into external function declarations for functions which \n+ *  implement the reducer functionality for the op_mul reducer type for a\n+ *  specified numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPMUL_DECLARATION(t,tn)                             \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPMUL_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opmul,tn,l,r);         \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opmul,tn);\n+ \n+/** Define the op_mul reducer functions for a numeric type.\n+ *\n+ *  This macro expands into function definitions for functions which implement\n+ *  the reducer functionality for the op_mul reducer type for a specified\n+ *  numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPMUL_DEFINITION(t,tn)                              \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPMUL_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opmul,tn,l,r)          \\\n+        { *(t*)l *= *(t*)r; }                                              \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opmul,tn)            \\\n+        { *(t*)v = 1; }\n+ \n+//@{\n+/** @def CILK_C_REDUCER_OPMUL_INSTANCE \n+ *  @brief Declare or define implementation functions for a reducer type.\n+ *\n+ *  In the runtime source file c_reducers.c, the macro `CILK_C_DEFINE_REDUCERS`\n+ *  will be defined, and this macro will generate reducer implementation\n+ *  functions. Everywhere else, `CILK_C_DEFINE_REDUCERS` will be undefined, and\n+ *  this macro will expand into external declarations for the functions.\n+ */\n+#ifdef CILK_C_DEFINE_REDUCERS\n+#   define CILK_C_REDUCER_OPMUL_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPMUL_DEFINITION(t,tn)\n+#else\n+#   define CILK_C_REDUCER_OPMUL_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPMUL_DECLARATION(t,tn)\n+#endif\n+//@}\n+\n+/*  Declare or define an instance of the reducer type and its functions for each \n+ *  numeric type.\n+ */\n+CILK_C_REDUCER_OPMUL_INSTANCE(char,                 char)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned char,        uchar)\n+CILK_C_REDUCER_OPMUL_INSTANCE(signed char,          schar)\n+CILK_C_REDUCER_OPMUL_INSTANCE(wchar_t,              wchar_t)\n+CILK_C_REDUCER_OPMUL_INSTANCE(short,                short)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned short,       ushort)\n+CILK_C_REDUCER_OPMUL_INSTANCE(int,                  int)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned int,         uint)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned int,         unsigned) /* alternate name */\n+CILK_C_REDUCER_OPMUL_INSTANCE(long,                 long)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned long,        ulong)\n+CILK_C_REDUCER_OPMUL_INSTANCE(long long,            longlong)\n+CILK_C_REDUCER_OPMUL_INSTANCE(unsigned long long,   ulonglong)\n+CILK_C_REDUCER_OPMUL_INSTANCE(float,                float)\n+CILK_C_REDUCER_OPMUL_INSTANCE(double,               double)\n+CILK_C_REDUCER_OPMUL_INSTANCE(long double,          longdouble)\n+\n+//@endcond\n+\n+__CILKRTS_END_EXTERN_C\n+\n+//@}\n+\n+//@}\n+\n+#endif /*  REDUCER_OPMUL_H_INCLUDED */"}, {"sha": "5c8e7bd972ea22e78b7150d733c9dfe42e9fd5d6", "filename": "libcilkrts/include/cilk/reducer_opor.h", "status": "added", "additions": 598, "deletions": 0, "changes": 598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,598 @@\n+/*  reducer_opor.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_opor.h\n+ *\n+ *  @brief Defines classes for doing parallel bitwise or reductions.\n+ *\n+ *  @ingroup ReducersOr\n+ *\n+ *  @see ReducersOr\n+ */\n+\n+#ifndef REDUCER_OPOR_H_INCLUDED\n+#define REDUCER_OPOR_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+\n+/** @defgroup ReducersOr Bitwise Or Reducers\n+ *\n+ *  Bitwise and reducers allow the computation of the bitwise and of a set of\n+ *  values in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redopor_usage Usage Example\n+ *\n+ *      cilk::reducer< cilk::op_or<unsigned> > r;\n+ *      cilk_for (int i = 0; i != N; ++i) {\n+ *          *r |= a[i];\n+ *      }\n+ *      unsigned result;\n+ *      r.move_out(result);\n+ *\n+ *  @section redopor_monoid The Monoid\n+ *\n+ *  @subsection redopor_monoid_values Value Set\n+ *\n+ *  The value set of a bitwise or reducer is the set of values of `Type`, which\n+ *  is expected to be a builtin integer type which has a representation as a\n+ *  sequence of bits (or something like it, such as `bool` or `std::bitset`).\n+ *\n+ *  @subsection redopor_monoid_operator Operator\n+ *\n+ *  The operator of a bitwise or reducer is the bitwise or operator, defined by\n+ *  the \u201c`|`\u201d binary operator on `Type`.\n+ *\n+ *  @subsection redopor_monoid_identity Identity\n+ *\n+ *  The identity value of the reducer is the value whose representation \n+ *  contains all 0-bits. This is expected to be the value of the default\n+ *  constructor `Type()`.\n+ *\n+ *  @section redopor_operations Operations\n+ *\n+ *  @subsection redopor_constructors Constructors\n+ *\n+ *      reducer()   // identity\n+ *      reducer(const Type& value)\n+ *      reducer(move_in(Type& variable))\n+ *\n+ *  @subsection redopor_get_set Set and Get\n+ *\n+ *      r.set_value(const Type& value)\n+ *      const Type& = r.get_value() const\n+ *      r.move_in(Type& variable)\n+ *      r.move_out(Type& variable)\n+ *\n+ *  @subsection redopor_initial Initial Values\n+ *\n+ *  If a bitwise or reducer is constructed without an explicit initial value, \n+ *  then its initial value will be its identity value, as long as `Type` \n+ *  satisfies the requirements of @ref redopor_types.\n+ *\n+ *  @subsection redopor_view_ops View Operations\n+ *\n+ *      *r |= a\n+ *      *r = *r | a\n+ *      *r = *r | a1 | a2 \u2026 | an\n+ *\n+ *  @section redopor_types Type and Operator Requirements\n+ *\n+ *  `Type` must be `Copy Constructible`, `Default Constructible`, and\n+ *  `Assignable`.\n+ *\n+ *  The operator \u201c`|=`\u201d must be defined on `Type`, with `x |= a` having the \n+ *  same meaning as `x = x | a`.\n+ *\n+ *  The expression `Type()` must be a valid expression which yields the\n+ *  identity value (the value of `Type` whose representation consists of all\n+ *  0-bits).\n+ *\n+ *  @section redopor_in_c Bitwise Or Reducers in C\n+ *\n+ *  The @ref CILK_C_REDUCER_OPOR and @ref CILK_C_REDUCER_OPOR_TYPE macros can\n+ *  be used to do bitwise or reductions in C. For example:\n+ *\n+ *      CILK_C_REDUCER_OPOR(r, uint, 0);\n+ *      CILK_C_REGISTER_REDUCER(r);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(r) |= a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(r);\n+ *      printf(\"The bitwise OR of the elements of a is %x\\n\", REDUCER_VIEW(r));\n+ *\n+ *  See @ref reducers_c_predefined.\n+ */\n+\n+#ifdef __cplusplus\n+\n+namespace cilk {\n+\n+/** The bitwise or reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_or<Type> >`. It holds the accumulator variable for\n+ *  the reduction, and allows only `or` operations to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `|=` operation would be used in an expression like `*r |= a`, where\n+ *          `r` is an opmod reducer variable.\n+ *\n+ *  @tparam Type    The type of the contained accumulator variable. This will\n+ *                  be the value type of a monoid_with_view that is\n+ *                  instantiated with this view.\n+ *\n+ *  @see ReducersOr\n+ *  @see op_or\n+ *\n+ *  @ingroup ReducersOr\n+ */\n+template <typename Type>\n+class op_or_view : public scalar_view<Type>\n+{\n+    typedef scalar_view<Type> base;\n+    \n+public:\n+    /** Class to represent the right-hand side of `*reducer = *reducer | value`.\n+     *\n+     *  The only assignment operator for the op_or_view class takes an \n+     *  rhs_proxy as its operand. This results in the syntactic restriction\n+     *  that the only expressions that can be assigned to an op_or_view are\n+     *  ones which generate an rhs_proxy \u2014 that is, expressions of the form\n+     *  `op_or_view | value ... | value`.\n+     *\n+     *  @warning\n+     *  The lhs and rhs views in such an assignment must be the same; \n+     *  otherwise, the behavior will be undefined. (I.e., `v1 = v1 | x` is\n+     *  legal; `v1 = v2 | x` is illegal.) This condition will be checked with\n+     *  a runtime assertion when compiled in debug mode.\n+     *\n+     *  @see op_or_view\n+     */\n+    class rhs_proxy {\n+        friend class op_or_view;\n+\n+        const op_or_view* m_view;\n+        Type              m_value;\n+\n+        // Constructor is invoked only from op_or_view::operator|().\n+        //\n+        rhs_proxy(const op_or_view* view, const Type& value) : m_view(view), m_value(value) {}\n+\n+        rhs_proxy& operator=(const rhs_proxy&); // Disable assignment operator\n+        rhs_proxy();                            // Disable default constructor\n+\n+    public:\n+        /** Bitwise or with an additional rhs value. If `v` is an op_or_view\n+         *  and `a1` is a value, then the expression `v | a1` invokes the \n+         *  view\u2019s `operator|()` to create an rhs_proxy for `(v, a1)`; then \n+         *  `v | a1 | a2` invokes the rhs_proxy\u2019s `operator|()` to create a new\n+         *  rhs_proxy for `(v, a1|a2)`. This allows the right-hand side of an\n+         *  assignment to be not just `view | value`, but \n+         (  `view | value | value ... | value`. The effect is that\n+         *\n+         *      v = v | a1 | a2 ... | an;\n+         *\n+         *  is evaluated as\n+         *\n+         *      v = v | (a1 | a2 ... | an);\n+         */\n+        rhs_proxy& operator|(const Type& x) { m_value |= x; return *this; }\n+    };\n+\n+\n+    /** Default/identity constructor. This constructor initializes the\n+     *  contained value to `Type()`.\n+     */\n+    op_or_view() : base() {}\n+\n+    /** Construct with a specified initial value.\n+     */\n+    explicit op_or_view(const Type& v) : base(v) {}\n+    \n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_or monoid to combine the views\n+     *  of two strands when the right strand merges with the left one. It\n+     *  \u201cors\u201d the value contained in the left-strand view by the value\n+     *  contained in the right-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_or monoid to implement the monoid\n+     *          reduce operation.\n+     */\n+    void reduce(op_or_view* right) { this->m_value |= right->m_value; }\n+    \n+    /** @name Accumulator variable updates.\n+     *\n+     *  These functions support the various syntaxes for \u201coring\u201d the\n+     *  accumulator variable contained in the view with some value.\n+     */\n+    //@{\n+\n+    /** Or the accumulator variable with @a x.\n+     */\n+    op_or_view& operator|=(const Type& x) { this->m_value |= x; return *this; }\n+\n+    /** Create an object representing `*this | x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator|(const Type& x) const { return rhs_proxy(this, x); }\n+\n+    /** Assign the result of a `view | value` expression to the view. Note that\n+     *  this is the only assignment operator for this class.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    op_or_view& operator=(const rhs_proxy& rhs) {\n+        __CILKRTS_ASSERT(this == rhs.m_view);\n+        this->m_value |= rhs.m_value;\n+        return *this;\n+    }\n+    \n+    //@}\n+};\n+\n+/** Monoid class for bitwise or reductions. Instantiate the cilk::reducer \n+ *  template class with an op_or monoid to create a bitwise or reducer\n+ *  class. For example, to compute the bitwise or of a set of `unsigned long`\n+ *  values:\n+ *\n+ *      cilk::reducer< cilk::op_or<unsigned long> > r;\n+ *\n+ *  @tparam Type    The reducer value type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersOr\n+ *  @see op_or_view\n+ *\n+ *  @ingroup ReducersOr\n+ */\n+template <typename Type, bool Align = false>\n+struct op_or : public monoid_with_view<op_or_view<Type>, Align> {};\n+\n+/** Deprecated bitwise or reducer class.\n+ *\n+ *  reducer_opor is the same as @ref reducer<@ref op_or>, except that\n+ *  reducer_opor is a proxy for the contained view, so that accumulator\n+ *  variable update operations can be applied directly to the reducer. For\n+ *  example, a value is ored with  a `reducer<%op_or>` with `*r |= a`, but a\n+ *  value can be ored with a `%reducer_opor` with `r |= a`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_opor. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_opor` \n+ *          and `reducer<%op_or>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_opor` can pass a\n+ *          `%reducer_opor` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_or>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type    The value type of the reducer.\n+ *\n+ *  @see op_or\n+ *  @see reducer\n+ *  @see ReducersOr\n+ *\n+ *  @ingroup ReducersOr\n+ */\n+template <typename Type>\n+class reducer_opor : public reducer< op_or<Type, true> >\n+{\n+    typedef reducer< op_or<Type, true> > base;\n+    using base::view;\n+\n+  public:\n+    /// The view type for the reducer.\n+    typedef typename base::view_type        view_type;\n+    \n+    /// The view\u2019s rhs proxy type.\n+    typedef typename view_type::rhs_proxy   rhs_proxy;\n+    \n+    /// The view type for the reducer.\n+    typedef view_type                       View;\n+\n+    /// The monoid type for the reducer.\n+    typedef typename base::monoid_type      Monoid;\n+    \n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Default (identity) constructor.\n+     *\n+     * Constructs the wrapper with the default initial value of `Type()`.\n+     */\n+    reducer_opor() {}\n+\n+    /** Value constructor.\n+     *\n+     *  Constructs the wrapper with a specified initial value.\n+     */\n+    explicit reducer_opor(const Type& initial_value) : base(initial_value) {}\n+    \n+    //@}\n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_and_view. */\n+    //@{\n+\n+    /// @copydoc op_or_view::operator|=(const Type&)\n+    reducer_opor& operator|=(const Type& x)\n+    {\n+        view() |= x; return *this; \n+    }\n+    \n+    // The legacy definition of reducer_opor::operator|() has different\n+    // behavior and a different return type than this definition. The legacy\n+    // version is defined as a member function, so this new version is defined\n+    // as a free function to give it a different signature, so that they won\u2019t \n+    // end up sharing a single object file entry.\n+\n+    /// @copydoc op_or_view::operator|(const Type&) const\n+    friend rhs_proxy operator|(const reducer_opor& r, const Type& x)\n+    { \n+        return r.view() | x; \n+    }\n+\n+    /// @copydoc op_and_view::operator=(const rhs_proxy&)\n+    reducer_opor& operator=(const rhs_proxy& temp)\n+    {\n+        view() = temp; return *this; \n+    }\n+    //@}\n+\n+    /** @name Dereference\n+     *  @details Dereferencing a wrapper is a no-op. It simply returns the\n+     *  wrapper. Combined with the rule that the wrapper forwards view\n+     *  operations to its contained view, this means that view operations can\n+     *  be written the same way on reducers and wrappers, which is convenient\n+     *  for incrementally converting old code using wrappers to use reducers\n+     *  instead. That is:\n+     *\n+     *      reducer< op_and<int> > r;\n+     *      *r &= a;    // *r returns the view\n+     *                  // operator &= is a view member function\n+     *\n+     *      reducer_opand<int> w;\n+     *      *w &= a;    // *w returns the wrapper\n+     *                  // operator &= is a wrapper member function that\n+     *                  // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_opor&       operator*()       { return *this; }\n+    reducer_opor const& operator*() const { return *this; }\n+\n+    reducer_opor*       operator->()       { return this; }\n+    reducer_opor const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_or<Type, false> >& ()\n+    {\n+        return *reinterpret_cast< reducer< op_or<Type, false> >* >(this);\n+    }\n+    operator const reducer< op_or<Type, false> >& () const\n+    {\n+        return *reinterpret_cast< const reducer< op_or<Type, false> >* >(this);\n+    }\n+    //@}\n+    \n+};\n+\n+/// @cond internal\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class \n+ *  defined in reducer.h causes the `reducer< op_or<Type> >` class to have an \n+ *  `operator reducer_opor<Type>& ()` conversion operator that statically\n+ *  downcasts the `reducer<op_or>` to the corresponding `reducer_opor` type.\n+ *  (The reverse conversion, from `reducer_opor` to `reducer<op_or>`, is just\n+ *  an upcast, which is provided for free by the language.)\n+ *\n+ *  @ingroup ReducersOr\n+ */\n+template <typename Type, bool Align>\n+struct legacy_reducer_downcast<reducer<op_or<Type, Align> > >\n+{\n+    typedef reducer_opor<Type> type;\n+};\n+/// @endcond\n+\n+} // namespace cilk\n+\n+#endif /* __cplusplus */\n+\n+\n+/** @ingroup ReducersOr\n+ */\n+//@{\n+\n+/** @name C language reducer macros\n+ *\n+ *  These macros are used to declare and work with op_or reducers in C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+ \n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Opor reducer type name.\n+ *\n+ *  This macro expands into the identifier which is the name of the op_or\n+ *  reducer type for a specified numeric type.\n+ *\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersOr\n+ */\n+#define CILK_C_REDUCER_OPOR_TYPE(tn)                                         \\\n+    __CILKRTS_MKIDENT(cilk_c_reducer_opor_,tn)\n+\n+/** Declare an op_or reducer object.\n+ *\n+ *  This macro expands into a declaration of an op_or reducer object for a\n+ *  specified numeric type. For example:\n+ *\n+ *      CILK_C_REDUCER_OPOR(my_reducer, ulong, 0);\n+ *\n+ *  @param  obj The variable name to be used for the declared reducer object.\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *  @param  v   The initial value for the reducer. (A value which can be\n+ *              assigned to the numeric type represented by @a tn.)\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersOr\n+ */\n+#define CILK_C_REDUCER_OPOR(obj,tn,v)                                        \\\n+    CILK_C_REDUCER_OPOR_TYPE(tn) obj =                                       \\\n+        CILK_C_INIT_REDUCER(_Typeof(obj.value),                               \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opor_reduce_,tn),   \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opor_identity_,tn), \\\n+                        __cilkrts_hyperobject_noop_destroy, v)\n+\n+/// @cond internal\n+\n+/** Declare the op_or reducer functions for a numeric type.\n+ *\n+ *  This macro expands into external function declarations for functions which\n+ *  implement the reducer functionality for the op_or reducer type for a\n+ *  specified numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPOR_DECLARATION(t,tn)                             \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPOR_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opor,tn,l,r);         \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opor,tn);\n+ \n+/** Define the op_or reducer functions for a numeric type.\n+ *\n+ *  This macro expands into function definitions for functions which implement\n+ *  the reducer functionality for the op_or reducer type for a specified \n+ *  numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPOR_DEFINITION(t,tn)                              \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPOR_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opor,tn,l,r)          \\\n+        { *(t*)l |= *(t*)r; }                                              \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opor,tn)            \\\n+        { *(t*)v = 0; }\n+ \n+//@{\n+/** @def CILK_C_REDUCER_OPOR_INSTANCE \n+ *  @brief Declare or define implementation functions for a reducer type.\n+ *\n+ *  In the runtime source file c_reducers.c, the macro `CILK_C_DEFINE_REDUCERS`\n+ *  will be defined, and this macro will generate reducer implementation\n+ *  functions. Everywhere else, `CILK_C_DEFINE_REDUCERS` will be undefined, and\n+ *  this macro will expand into external declarations for the functions.\n+ */\n+#ifdef CILK_C_DEFINE_REDUCERS\n+#   define CILK_C_REDUCER_OPOR_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPOR_DEFINITION(t,tn)\n+#else\n+#   define CILK_C_REDUCER_OPOR_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPOR_DECLARATION(t,tn)\n+#endif\n+//@}\n+\n+/*  Declare or define an instance of the reducer type and its functions for each \n+ *  numeric type.\n+ */\n+CILK_C_REDUCER_OPOR_INSTANCE(char,                 char)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned char,        uchar)\n+CILK_C_REDUCER_OPOR_INSTANCE(signed char,          schar)\n+CILK_C_REDUCER_OPOR_INSTANCE(wchar_t,              wchar_t)\n+CILK_C_REDUCER_OPOR_INSTANCE(short,                short)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned short,       ushort)\n+CILK_C_REDUCER_OPOR_INSTANCE(int,                  int)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned int,         uint)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned int,         unsigned) /* alternate name */\n+CILK_C_REDUCER_OPOR_INSTANCE(long,                 long)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned long,        ulong)\n+CILK_C_REDUCER_OPOR_INSTANCE(long long,            longlong)\n+CILK_C_REDUCER_OPOR_INSTANCE(unsigned long long,   ulonglong)\n+\n+//@endcond\n+\n+__CILKRTS_END_EXTERN_C\n+\n+//@}\n+\n+//@}\n+\n+#endif /*  REDUCER_OPOR_H_INCLUDED */"}, {"sha": "fed49943ef696eb5051c91781fd682dceeab7eec", "filename": "libcilkrts/include/cilk/reducer_opxor.h", "status": "added", "additions": 598, "deletions": 0, "changes": 598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,598 @@\n+/*  reducer_opxor.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_opxor.h\n+ *\n+ *  @brief Defines classes for doing parallel bitwise or reductions.\n+ *\n+ *  @ingroup ReducersXor\n+ *\n+ *  @see ReducersXor\n+ */\n+\n+#ifndef REDUCER_OPXOR_H_INCLUDED\n+#define REDUCER_OPXOR_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+\n+/** @defgroup ReducersXor Bitwise Xor Reducers\n+ *\n+ *  Bitwise and reducers allow the computation of the bitwise and of a set of\n+ *  values in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file `reducers.md`, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redopxor_usage Usage Example\n+ *\n+ *      cilk::reducer< cilk::op_xor<unsigned> > r;\n+ *      cilk_for (int i = 0; i != N; ++i) {\n+ *          *r ^= a[i];\n+ *      }\n+ *      unsigned result;\n+ *      r.move_out(result);\n+ *\n+ *  @section redopxor_monoid The Monoid\n+ *\n+ *  @subsection redopxor_monoid_values Value Set\n+ *\n+ *  The value set of a bitwise xor reducer is the set of values of `Type`, which\n+ *  is expected to be a builtin integer type which has a representation as a\n+ *  sequence of bits (or something like it, such as `bool` or `std::bitset`).\n+ *\n+ *  @subsection redopxor_monoid_operator Operator\n+ *\n+ *  The operator of a bitwise xor reducer is the bitwise xor operator, defined\n+ *  by the \u201c`^`\u201d binary operator on `Type`.\n+ *\n+ *  @subsection redopxor_monoid_identity Identity\n+ *\n+ *  The identity value of the reducer is the value whose representation \n+ *  contains all 0-bits. This is expected to be the value of the default\n+ *  constructor `Type()`.\n+ *\n+ *  @section redopxor_operations Operations\n+ *\n+ *  @subsection redopxor_constructors Constructors\n+ *\n+ *      reducer()   // identity\n+ *      reducer(const Type& value)\n+ *      reducer(move_in(Type& variable))\n+ *\n+ *  @subsection redopxor_get_set Set and Get\n+ *\n+ *      r.set_value(const Type& value)\n+ *      const Type& = r.get_value() const\n+ *      r.move_in(Type& variable)\n+ *      r.move_out(Type& variable)\n+ *\n+ *  @subsection redopxor_initial Initial Values\n+ *\n+ *  If a bitwise xor reducer is constructed without an explicit initial value, \n+ *  then its initial value will be its identity value, as long as `Type` \n+ *  satisfies the requirements of @ref redopxor_types.\n+ *\n+ *  @subsection redopxor_view_ops View Operations\n+ *\n+ *      *r ^= a\n+ *      *r = *r ^ a\n+ *      *r = *r ^ a1 ^ a2 \u2026 ^ an\n+ *\n+ *  @section redopxor_types Type and Operator Requirements\n+ *\n+ *  `Type` must be `Copy Constructible`, `Default Constructible`, and\n+ *  `Assignable`.\n+ *\n+ *  The operator \u201c`^=`\u201d must be defined on `Type`, with `x ^= a` having the \n+ *  same meaning as `x = x ^ a`.\n+ *\n+ *  The expression `Type()` must be a valid expression which yields the\n+ *  identity value (the value of `Type` whose representation consists of all\n+ *  0-bits).\n+ *\n+ *  @section redopxor_in_c Bitwise Xor Reducers in C\n+ *\n+ *  The @ref CILK_C_REDUCER_OPXOR and @ref CILK_C_REDUCER_OPXOR_TYPE macros can\n+ *  be used to do bitwise xor reductions in C. For example:\n+ *\n+ *      CILK_C_REDUCER_OPXOR(r, uint, 0);\n+ *      CILK_C_REGISTER_REDUCER(r);\n+ *      cilk_for(int i = 0; i != n; ++i) {\n+ *          REDUCER_VIEW(r) ^= a[i];\n+ *      }\n+ *      CILK_C_UNREGISTER_REDUCER(r);\n+ *      printf(\"The bitwise XOR of the elements of a is %x\\n\", REDUCER_VIEW(r));\n+ *\n+ *  See @ref reducers_c_predefined.\n+ */\n+\n+#ifdef __cplusplus\n+\n+namespace cilk {\n+\n+/** The bitwise xor reducer view class.\n+ *\n+ *  This is the view class for reducers created with \n+ *  `cilk::reducer< cilk::op_xor<Type> >`. It holds the accumulator variable \n+ *  for the reduction, and allows only `xor` operations to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `^=` operation would be used in an expression like `*r ^= a`, where\n+ *          `r` is an opmod reducer variable.\n+ *\n+ *  @tparam Type    The type of the contained accumulator variable. This will\n+ *                  be the value type of a monoid_with_view that is\n+ *                  instantiated with this view.\n+ *\n+ *  @see ReducersXor\n+ *  @see op_xor\n+ *\n+ *  @ingroup ReducersXor\n+ */\n+template <typename Type>\n+class op_xor_view : public scalar_view<Type>\n+{\n+    typedef scalar_view<Type> base;\n+    \n+public:\n+    /** Class to represent the right-hand side of `*reducer = *reducer ^ value`.\n+     *\n+     *  The only assignment operator for the op_xor_view class takes an \n+     *  rhs_proxy as its operand. This results in the syntactic restriction\n+     *  that the only expressions that can be assigned to an op_xor_view are\n+     *  ones which generate an rhs_proxy \u2014 that is, expressions of the form\n+     *  `op_xor_view ^ value ... ^ value`.\n+     *\n+     *  @warning\n+     *  The lhs and rhs views in such an assignment must be the same; \n+     *  otherwise, the behavior will be undefined. (I.e., `v1 = v1 ^ x` is\n+     *  legal; `v1 = v2 ^ x` is illegal.) This condition will be checked with\n+     *  a runtime assertion when compiled in debug mode.\n+     *\n+     *  @see op_xor_view\n+     */\n+    class rhs_proxy {\n+        friend class op_xor_view;\n+\n+        const op_xor_view* m_view;\n+        Type              m_value;\n+\n+        // Constructor is invoked only from op_xor_view::operator^().\n+        //\n+        rhs_proxy(const op_xor_view* view, const Type& value) : m_view(view), m_value(value) {}\n+\n+        rhs_proxy& operator=(const rhs_proxy&); // Disable assignment operator\n+        rhs_proxy();                            // Disable default constructor\n+\n+    public:\n+        /** Bitwise xor with an additional rhs value. If `v` is an op_xor_view\n+         *  and `a1` is a value, then the expression `v ^ a1` invokes the \n+         *  view\u2019s `operator^()` to create an rhs_proxy for `(v, a1)`; then \n+         *  `v ^ a1 ^ a2` invokes the rhs_proxy\u2019s `operator^()` to create a new\n+         *  rhs_proxy for `(v, a1^a2)`. This allows the right-hand side of an\n+         *  assignment to be not just `view ^ value`, but \n+         (  `view ^ value ^ value ... ^ value`. The effect is that\n+         *\n+         *      v = v ^ a1 ^ a2 ... ^ an;\n+         *\n+         *  is evaluated as\n+         *\n+         *      v = v ^ (a1 ^ a2 ... ^ an);\n+         */\n+        rhs_proxy& operator^(const Type& x) { m_value ^= x; return *this; }\n+    };\n+\n+\n+    /** Default/identity constructor. This constructor initializes the\n+     *  contained value to `Type()`.\n+     */\n+    op_xor_view() : base() {}\n+\n+    /** Construct with a specified initial value.\n+     */\n+    explicit op_xor_view(const Type& v) : base(v) {}\n+    \n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_xor monoid to combine the views\n+     *  of two strands when the right strand merges with the left one. It\n+     *  \u201cxors\u201d the value contained in the left-strand view by the value\n+     *  contained in the right-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_xor monoid to implement the monoid\n+     *          reduce operation.\n+     */\n+    void reduce(op_xor_view* right) { this->m_value ^= right->m_value; }\n+    \n+    /** @name Accumulator variable updates.\n+     *\n+     *  These functions support the various syntaxes for \u201cxoring\u201d the\n+     *  accumulator variable contained in the view with some value.\n+     */\n+    //@{\n+\n+    /** Xor the accumulator variable with @a x.\n+     */\n+    op_xor_view& operator^=(const Type& x) { this->m_value ^= x; return *this; }\n+\n+    /** Create an object representing `*this ^ x`.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    rhs_proxy operator^(const Type& x) const { return rhs_proxy(this, x); }\n+\n+    /** Assign the result of a `view ^ value` expression to the view. Note that\n+     *  this is the only assignment operator for this class.\n+     *\n+     *  @see rhs_proxy\n+     */\n+    op_xor_view& operator=(const rhs_proxy& rhs) {\n+        __CILKRTS_ASSERT(this == rhs.m_view);\n+        this->m_value ^= rhs.m_value;\n+        return *this;\n+    }\n+    \n+    //@}\n+};\n+\n+/** Monoid class for bitwise xor reductions. Instantiate the cilk::reducer \n+ *  template class with an op_xor monoid to create a bitwise xor reducer\n+ *  class. For example, to compute the bitwise xor of a set of `unsigned long`\n+ *  values:\n+ *\n+ *      cilk::reducer< cilk::op_xor<unsigned long> > r;\n+ *\n+ *  @tparam Type    The reducer value type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersXor\n+ *  @see op_xor_view\n+ *\n+ *  @ingroup ReducersXor\n+ */\n+template <typename Type, bool Align = false>\n+struct op_xor : public monoid_with_view<op_xor_view<Type>, Align> {};\n+\n+/** Deprecated bitwise xor reducer class.\n+ *\n+ *  reducer_opxor is the same as @ref reducer<@ref op_xor>, except that\n+ *  reducer_opxor is a proxy for the contained view, so that accumulator\n+ *  variable update operations can be applied directly to the reducer. For\n+ *  example, a value is xored with  a `reducer<%op_xor>` with `*r ^= a`, but a\n+ *  value can be xored with a `%reducer_opxor` with `r ^= a`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_opand. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_opxor` \n+ *          and `reducer<%op_xor>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_opxor` can pass a\n+ *          `%reducer_opxor` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_xor>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Type    The value type of the reducer.\n+ *\n+ *  @see op_xor\n+ *  @see reducer\n+ *  @see ReducersXor\n+ *\n+ *  @ingroup ReducersXor\n+ */\n+template <typename Type>\n+class reducer_opxor : public reducer< op_xor<Type, true> >\n+{\n+    typedef reducer< op_xor<Type, true> > base;\n+    using base::view;\n+\n+  public:\n+    /// The view type for the reducer.\n+    typedef typename base::view_type        view_type;\n+    \n+    /// The view\u2019s rhs proxy type.\n+    typedef typename view_type::rhs_proxy   rhs_proxy;\n+    \n+    /// The view type for the reducer.\n+    typedef view_type                       View;\n+\n+    /// The monoid type for the reducer.\n+    typedef typename base::monoid_type      Monoid;\n+    \n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** Default (identity) constructor.\n+     *\n+     * Constructs the wrapper with the default initial value of `Type()`.\n+     */\n+    reducer_opxor() {}\n+\n+    /** Value constructor.\n+     *\n+     *  Constructs the wrapper with a specified initial value.\n+     */\n+    explicit reducer_opxor(const Type& initial_value) : base(initial_value) {}\n+    \n+    //@}\n+\n+    /** @name Forwarded functions\n+     *  @details Functions that update the contained accumulator variable are\n+     *  simply forwarded to the contained @ref op_and_view. */\n+    //@{\n+\n+    /// @copydoc op_xor_view::operator^=(const Type&)\n+    reducer_opxor& operator^=(const Type& x)\n+    {\n+        view() ^= x; return *this; \n+    }\n+    \n+    // The legacy definition of reducer_opxor::operator^() has different\n+    // behavior and a different return type than this definition. The legacy\n+    // version is defined as a member function, so this new version is defined\n+    // as a free function to give it a different signature, so that they won\u2019t \n+    // end up sharing a single object file entry.\n+\n+    /// @copydoc op_xor_view::operator^(const Type&) const\n+    friend rhs_proxy operator^(const reducer_opxor& r, const Type& x)\n+    { \n+        return r.view() ^ x; \n+    }\n+\n+    /// @copydoc op_and_view::operator=(const rhs_proxy&)\n+    reducer_opxor& operator=(const rhs_proxy& temp)\n+    {\n+        view() = temp; return *this; \n+    }\n+    //@}\n+\n+    /** @name Dereference\n+     *  @details Dereferencing a wrapper is a no-op. It simply returns the\n+     *  wrapper. Combined with the rule that the wrapper forwards view\n+     *  operations to its contained view, this means that view operations can\n+     *  be written the same way on reducers and wrappers, which is convenient\n+     *  for incrementally converting old code using wrappers to use reducers\n+     *  instead. That is:\n+     *\n+     *      reducer< op_and<int> > r;\n+     *      *r &= a;    // *r returns the view\n+     *                  // operator &= is a view member function\n+     *\n+     *      reducer_opand<int> w;\n+     *      *w &= a;    // *w returns the wrapper\n+     *                  // operator &= is a wrapper member function that\n+     *                  // calls the corresponding view function\n+     */\n+    //@{\n+    reducer_opxor&       operator*()       { return *this; }\n+    reducer_opxor const& operator*() const { return *this; }\n+\n+    reducer_opxor*       operator->()       { return this; }\n+    reducer_opxor const* operator->() const { return this; }\n+    //@}\n+    \n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_xor<Type, false> >& ()\n+    {\n+        return *reinterpret_cast< reducer< op_xor<Type, false> >* >(this);\n+    }\n+    operator const reducer< op_xor<Type, false> >& () const\n+    {\n+        return *reinterpret_cast< const reducer< op_xor<Type, false> >* >(this);\n+    }\n+    //@}\n+    \n+};\n+\n+/// @cond internal\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class \n+ *  defined in reducer.h causes the `reducer< op_xor<Type> >` class to have an \n+ *  `operator reducer_opxor<Type>& ()` conversion operator that statically\n+ *  downcasts the `reducer<op_xor>` to the corresponding `reducer_opxor` type.\n+ *  (The reverse conversion, from `reducer_opxor` to `reducer<op_xor>`, is just\n+ *  an upcast, which is provided for free by the language.)\n+ *\n+ *  @ingroup ReducersXor\n+ */\n+template <typename Type, bool Align>\n+struct legacy_reducer_downcast<reducer<op_xor<Type, Align> > >\n+{\n+    typedef reducer_opxor<Type> type;\n+};\n+/// @endcond\n+\n+} // namespace cilk\n+\n+#endif /* __cplusplus */\n+\n+\n+/** @ingroup ReducersXor\n+ */\n+//@{\n+\n+/** @name C language reducer macros\n+ *\n+ *  These macros are used to declare and work with op_xor reducers in C code.\n+ *\n+ *  @see @ref page_reducers_in_c\n+ */\n+ //@{\n+ \n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** Opxor reducer type name.\n+ *\n+ *  This macro expands into the identifier which is the name of the op_xor\n+ *  reducer type for a specified numeric type.\n+ *\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersXor\n+ */\n+#define CILK_C_REDUCER_OPXOR_TYPE(tn)                                         \\\n+    __CILKRTS_MKIDENT(cilk_c_reducer_opxor_,tn)\n+\n+/** Declare an op_xor reducer object.\n+ *\n+ *  This macro expands into a declaration of an op_xor reducer object for a\n+ *  specified numeric type. For example:\n+ *\n+ *      CILK_C_REDUCER_OPXOR(my_reducer, ulong, 0);\n+ *\n+ *  @param  obj The variable name to be used for the declared reducer object.\n+ *  @param  tn  The @ref reducers_c_type_names \"numeric type name\" specifying\n+ *              the type of the reducer.\n+ *  @param  v   The initial value for the reducer. (A value which can be\n+ *              assigned to the numeric type represented by @a tn.)\n+ *\n+ *  @see @ref reducers_c_predefined\n+ *  @see ReducersXor\n+ */\n+#define CILK_C_REDUCER_OPXOR(obj,tn,v)                                        \\\n+    CILK_C_REDUCER_OPXOR_TYPE(tn) obj =                                       \\\n+        CILK_C_INIT_REDUCER(_Typeof(obj.value),                               \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opxor_reduce_,tn),   \\\n+                        __CILKRTS_MKIDENT(cilk_c_reducer_opxor_identity_,tn), \\\n+                        __cilkrts_hyperobject_noop_destroy, v)\n+\n+/// @cond internal\n+\n+/** Declare the op_xor reducer functions for a numeric type.\n+ *\n+ *  This macro expands into external function declarations for functions which\n+ *  implement the reducer functionality for the op_xor reducer type for a\n+ *  specified numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPXOR_DECLARATION(t,tn)                             \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPXOR_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opxor,tn,l,r);         \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opxor,tn);\n+ \n+/** Define the op_xor reducer functions for a numeric type.\n+ *\n+ *  This macro expands into function definitions for functions which implement\n+ *  the reducer functionality for the op_xor reducer type for a specified \n+ *  numeric type.\n+ *\n+ *  @param  t   The value type of the reducer.\n+ *  @param  tn  The value \u201ctype name\u201d identifier, used to construct the reducer\n+ *              type name, function names, etc.\n+ */\n+#define CILK_C_REDUCER_OPXOR_DEFINITION(t,tn)                              \\\n+    typedef CILK_C_DECLARE_REDUCER(t) CILK_C_REDUCER_OPXOR_TYPE(tn);       \\\n+    __CILKRTS_DECLARE_REDUCER_REDUCE(cilk_c_reducer_opxor,tn,l,r)          \\\n+        { *(t*)l ^= *(t*)r; }                                              \\\n+    __CILKRTS_DECLARE_REDUCER_IDENTITY(cilk_c_reducer_opxor,tn)            \\\n+        { *(t*)v = 0; }\n+ \n+//@{\n+/** @def CILK_C_REDUCER_OPXOR_INSTANCE \n+ *  @brief Declare or define implementation functions for a reducer type.\n+ *\n+ *  In the runtime source file c_reducers.c, the macro `CILK_C_DEFINE_REDUCERS`\n+ *  will be defined, and this macro will generate reducer implementation\n+ *  functions. Everywhere else, `CILK_C_DEFINE_REDUCERS` will be undefined, and\n+ *  this macro will expand into external declarations for the functions.\n+ */\n+#ifdef CILK_C_DEFINE_REDUCERS\n+#   define CILK_C_REDUCER_OPXOR_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPXOR_DEFINITION(t,tn)\n+#else\n+#   define CILK_C_REDUCER_OPXOR_INSTANCE(t,tn)  \\\n+        CILK_C_REDUCER_OPXOR_DECLARATION(t,tn)\n+#endif\n+//@}\n+\n+/*  Declare or define an instance of the reducer type and its functions for each \n+ *  numeric type.\n+ */\n+CILK_C_REDUCER_OPXOR_INSTANCE(char,                 char)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned char,        uchar)\n+CILK_C_REDUCER_OPXOR_INSTANCE(signed char,          schar)\n+CILK_C_REDUCER_OPXOR_INSTANCE(wchar_t,              wchar_t)\n+CILK_C_REDUCER_OPXOR_INSTANCE(short,                short)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned short,       ushort)\n+CILK_C_REDUCER_OPXOR_INSTANCE(int,                  int)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned int,         uint)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned int,         unsigned) /* alternate name */\n+CILK_C_REDUCER_OPXOR_INSTANCE(long,                 long)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned long,        ulong)\n+CILK_C_REDUCER_OPXOR_INSTANCE(long long,            longlong)\n+CILK_C_REDUCER_OPXOR_INSTANCE(unsigned long long,   ulonglong)\n+\n+//@endcond\n+\n+__CILKRTS_END_EXTERN_C\n+\n+//@}\n+\n+//@}\n+\n+#endif /*  REDUCER_OPXOR_H_INCLUDED */"}, {"sha": "d9addeee89f865f8569a889aafe4dffff2d556ef", "filename": "libcilkrts/include/cilk/reducer_ostream.h", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,293 @@\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ */\n+\n+/*\n+ * reducer_ostream.h\n+ *\n+ * Purpose: Hyper-object to write to 'std::ostream's\n+ *\n+ * Classes: reducer_ostream\n+ *\n+ * Description:\n+ * ============\n+ * Output streams ('std::ostream's) are a convenient means of writing text to\n+ * files, the user console, or sockets.  In a serial program, text is written\n+ * to an ostream in a specific, logical order.  For example, computing while\n+ * traversing a data structure and printing them to an 'ostream' will result\n+ * in the values being printed in the order of traversal.  In a parallel\n+ * version of the same program, however, different parts of the data structure\n+ * may be traversed in a different order, resulting in a non-deterministic\n+ * ordering of the stream.  Worse, multiple strands may write to the same\n+ * stream simultaneously, resulting in a data race.  Replacing the\n+ * 'std::ostream' with a 'cilk::reducer_ostream' will solve both problems: Data\n+ * will appeaer in the stream in the same order as it would for the serial\n+ * program, and there will be no races (no locks) on the common stream.\n+ *\n+ * Usage Example:\n+ * ==============\n+ * Assume we wish to traverse an array of objects, performing an operation on\n+ * each object and writing the result to a file.  Without a reducer_ostream,\n+ * we have a race on the 'output' file stream:\n+ *..\n+ *  void compute(std::ostream& os, double x)\n+ *  {\n+ *      // Perform some significant computation and print the result:\n+ *      os << std::asin(x);\n+ *  }\n+ *\n+ *  int test()\n+ *  {\n+ *      const std::size_t ARRAY_SIZE = 1000000;\n+ *      extern double myArray[ARRAY_SIZE];\n+ *\n+ *      std::ofstream output(\"output.txt\");\n+ *      cilk_for (std::size_t i = 0; i < ARRAY_SIZE; ++i)\n+ *      {\n+ *          compute(output, myArray[i]);\n+ *      }\n+ *\n+ *      return 0;\n+ *  }\n+ *..\n+ * The race is solved by using a reducer_ostream to proxy the 'output' file:\n+ *..\n+ *  void compute(cilk::reducer_ostream& os, double x)\n+ *  {\n+ *      // Perform some significant computation and print the result:\n+ *      *os << std::asin(x);\n+ *  }\n+ *\n+ *  int test()\n+ *  {\n+ *      const std::size_t ARRAY_SIZE = 1000000;\n+ *      extern double myArray[ARRAY_SIZE];\n+ *\n+ *      std::ofstream output(\"output.txt\");\n+ *      cilk::reducer_ostream hyper_output(output);\n+ *      cilk_for (std::size_t i = 0; i < ARRAY_SIZE; ++i)\n+ *      {\n+ *          compute(hyper_output, myArray[i]);\n+ *      }\n+ *\n+ *      return 0;\n+ *  }\n+ *..\n+ *\n+ * Limitations:\n+ * ============\n+ * There are two possible values for the formatting flags immediately after a\n+ * 'cilk_spawn' statement: they may either have the value that was set by the\n+ * spawn function, or they may have default values.  Because of\n+ * non-determinism in the processor scheduling, there is no way to determine\n+ * which it will be.  Similarly, the formatting flags after a 'cilk_sync' may\n+ * or may not have the same value as before the sync.  Therefore, one must use\n+ * a disciplined coding style to avoid formatting errors.  There are two\n+ * approaches to mitigating the problem: The first is to eliminate the\n+ * difference between the two possible outcomes by ensuring that the spawned\n+ * function always returns the flags to their initial state:\n+ *..\n+ *  void compute(cilk::reducer_ostream& os, double x)\n+ *  {\n+ *      // Perform some significant computation and print the result:\n+ *      int saveprec = os.precision(5);\n+ *      os << std::asin(x);\n+ *      os.precision(saveprec);\n+ *  }\n+ *..\n+ * The second approach is to write your streaming operations such that they\n+ * don't depend on the previous state of the formatting flags by setting any\n+ * important flags before every block of output:\n+ *..\n+ *      cilk_spawn compute(hyper_output, value);\n+ *\n+ *      hyper_output->precision(2);  // Don't depend on previous precision\n+ *      *hyper_output << f();\n+ *      *hyper_output << g();\n+ *..\n+ * Another concern is memory usage.  A reducer_ostream will buffer as much text\n+ * as necessary to ensure that the order of output matches that of the serial\n+ * version of the program.  If all spawn branches perform an equal amount of\n+ * output, then one can expect that half of the output before a sync will be\n+ * buffered in memory.  This hyperobject is therefore not well suited for\n+ * serializing very large quantities of text output.\n+ */\n+\n+#ifndef REDUCER_OSTREAM_H_INCLUDED\n+#define REDUCER_OSTREAM_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+#include <iostream>\n+#include <sstream>\n+\n+namespace cilk {\n+\n+/**\n+ * @brief Class 'reducer_ostream' is the representation of a hyperobject for\n+ * output text streaming.\n+ */\n+class reducer_ostream\n+{\n+public:\n+    /// Internal representation of the per-strand view of the data for reducer_ostream\n+    class View: public std::ostream\n+    {\n+    public:\n+        /// Type of the std::stream reducer_ostream is based on\n+        typedef std::ostream Base;\n+\n+        friend class reducer_ostream;\n+\n+        View():\n+            std::ostream(0)\n+        {\n+            Base::rdbuf(&strbuf_);\n+        };\n+\n+    private:\n+        void use_ostream (const std::ostream &os)\n+        {\n+            Base::rdbuf(os.rdbuf());\n+            Base::flags(os.flags());       // Copy formatting flags\n+            Base::setstate(os.rdstate());  // Copy error state\n+        }\n+\n+    private:\n+        std::stringbuf  strbuf_;\n+    };\n+\n+public:\n+    /// Definition of data view, operation, and identity for reducer_ostream\n+    struct Monoid: monoid_base< View >\n+    {\n+        static void reduce (View *left, View *right);\n+    };\n+\n+private:\n+    // Hyperobject to serve up views\n+    reducer<Monoid> imp_;\n+\n+    // Methods that provide the API for the reducer\n+public:\n+\n+    // Construct an initial 'reducer_ostream' from an 'std::ostream'.  The\n+    // specified 'os' stream is used as the eventual destination for all\n+    // text streamed to this hyperobject.\n+    explicit reducer_ostream(const std::ostream &os);\n+\n+    // Return a modifiable reference to the underlying 'ostream' object.\n+    std::ostream& get_reference();\n+\n+    /**\n+     * Append data from some type to the reducer_ostream\n+     *\n+     * @param v Value to be appended to the reducer_ostream\n+     */\n+    template<typename T>\n+    std::ostream &\n+    operator<< (const T &v)\n+    {\n+        return imp_.view() << v;\n+    }\n+\n+    /**\n+     * Append data from a std::ostream to the reducer_ostream\n+     *\n+     * @param _Pfn std::ostream to copy from\n+     */\n+    std::ostream &\n+    operator<< (std::ostream &(*_Pfn)(std::ostream &))\n+    {\n+        View &v = imp_.view();\n+\n+        return ((*_Pfn)(v));\n+    }\n+\n+    reducer_ostream&       operator*()       { return *this; }\n+    reducer_ostream const& operator*() const { return *this; }\n+\n+    reducer_ostream*       operator->()       { return this; }\n+    reducer_ostream const* operator->() const { return this; }\n+};\n+\n+\n+// -------------------------------------------\n+// class reducer_ostream::Monoid\n+// -------------------------------------------\n+\n+/**\n+ * Appends string from \"right\" reducer_basic_string onto the end of\n+ * the \"left\". When done, the \"right\" reducer_basic_string is empty.\n+ */\n+void\n+reducer_ostream::Monoid::reduce(View *left, View *right)\n+{\n+    left->operator<< (&right->strbuf_);\n+}\n+\n+// --------------------------\n+// class reducer_ostream\n+// --------------------------\n+\n+/**\n+ * Construct a reducer_ostream which will write to the specified std::ostream\n+ *\n+ * @param os std::ostream to write to\n+ */\n+inline\n+reducer_ostream::reducer_ostream(const std::ostream &os) :\n+    imp_()\n+{\n+    View &v = imp_.view();\n+\n+    v.use_ostream(os);\n+}\n+\n+/**\n+ * Get a reference to the std::ostream\n+ */\n+inline\n+std::ostream &\n+reducer_ostream::get_reference()\n+{\n+    View &v = imp_.view();\n+\n+    return v;\n+}\n+\n+} // namespace cilk\n+\n+#endif //  REDUCER_OSTREAM_H_INCLUDED\n+"}, {"sha": "0d70dd8b30a2bde0b6c4aa56a1fa3da1052a524a", "filename": "libcilkrts/include/cilk/reducer_string.h", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,729 @@\n+/*  reducer_string.h                  -*- C++ -*-\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/** @file reducer_string.h\n+ *\n+ *  @brief Defines classes for doing parallel string creation by appending.\n+ *\n+ *  @ingroup ReducersString\n+ *\n+ *  @see ReducersString\n+ */\n+\n+#ifndef REDUCER_STRING_H_INCLUDED\n+#define REDUCER_STRING_H_INCLUDED\n+\n+#include <cilk/reducer.h>\n+#include <string>\n+#include <list>\n+\n+/** @defgroup ReducersString String Reducers\n+ *\n+ *  String reducers allow the creation of a string by concatenating a set of \n+ *  strings or characters in parallel.\n+ *\n+ *  @ingroup Reducers\n+ *\n+ *  You should be familiar with @ref pagereducers \"Cilk reducers\", described in\n+ *  file reducers.md, and particularly with @ref reducers_using, before trying\n+ *  to use the information in this file.\n+ *\n+ *  @section redstring_usage Usage Example\n+ *\n+ *      vector<Data> data;\n+ *      void expensive_string_computation(const Data& x, string& s);\n+ *      cilk::reducer<cilk::op_string> r;\n+ *      cilk_for (int i = 0; i != data.size(); ++i) {\n+ *          string temp;\n+ *          expensive_string_computation(data[i], temp);\n+ *          *r += temp;\n+ *      }\n+ *      string result;\n+ *      r.move_out(result);\n+ *\n+ *  @section redstring_monoid The Monoid\n+ *\n+ *  @subsection redstring_monoid_values Value Set\n+ *\n+ *  The value set of a string reducer is the set of values of the class\n+ *  `std::basic_string<Char, Traits, Alloc>`, which we refer to as \u201cthe\n+ *  reducer\u2019s string type\u201d.\n+ *\n+ *  @subsection redstring_monoid_operator Operator\n+ *\n+ *  The operator of a string reducer is the string concatenation operator, \n+ *  defined by the \u201c`+`\u201d binary operator on the reducer\u2019s string type.\n+ *\n+ *  @subsection redstring_monoid_identity Identity\n+ *\n+ *  The identity value of a string reducer is the empty string, which is the \n+ *  value of the expression\n+ *  `std::basic_string<Char, Traits, Alloc>([allocator])`.\n+ *\n+ *  @section redstring_operations Operations\n+ *\n+ *  In the operation descriptions below, the type name `String` refers to the\n+ *  reducer\u2019s string type, `std::basic_string<Char, Traits, Alloc>`.\n+ *\n+ *  @subsection redstring_constructors Constructors\n+ *\n+ *  Any argument list which is valid for a `std::basic_string` constructor is\n+ *  valid for a string reducer constructor. The usual move-in constructor is\n+ *  also provided:\n+ *\n+ *      reducer(move_in(String& variable))\n+ *\n+ *  @subsection redstring_get_set Set and Get\n+ *\n+ *      r.set_value(const String& value)\n+ *      const String& = r.get_value() const\n+ *      r.move_in(String& variable)\n+ *      r.move_out(String& variable)\n+ *\n+ *  @subsection redstring_initial Initial Values\n+ *\n+ *  A string reducer with no constructor arguments, or with only an allocator\n+ *  argument, will initially contain the identity value, an empty string.\n+ *\n+ *  @subsection redstring_view_ops View Operations\n+ *\n+ *      *r += a\n+ *      r->append(a)\n+ *      r->append(a, b)\n+ *      r->push_back(a)\n+ *\n+ *  These operations on string reducer views are the same as the corresponding\n+ *  operations on strings.\n+ *\n+ *  @section redstring_performance Performance Considerations\n+ *\n+ *  String reducers work by creating a string for each view, collecting those\n+ *  strings in a list, and then concatenating them into a single result string\n+ *  at the end of the computation. This last step takes place in serial code,\n+ *  and necessarily takes time proportional to the length of the result string.\n+ *  Thus, a parallel string reducer cannot actually speed up the time spent\n+ *  directly creating the string. This trivial example would probably be slower\n+ *  (because of reducer overhead) than the corresponding serial code:\n+ *\n+ *      vector<string> a;\n+ *      reducer<op_string> r;\n+ *      cilk_for (int i = 0; i != a.length(); ++i) {\n+ *          *r += a[i];\n+ *      }\n+ *      string result;\n+ *      r.move_out(result);\n+ *\n+ *  What a string reducer _can_ do is to allow the _remainder_ of the\n+ *  computation to be done in parallel, without having to worry about managing\n+ *  the string computation.\n+ *\n+ *  The strings for new views are created (by the view identity constructor)\n+ *  using the same allocator as the string that was created when the reducer \n+ *  was constructed. Note that this allocator is determined when the reducer is \n+ *  constructed. The following two examples may have very different behavior:\n+ *\n+ *      string<Char, Traits, Allocator> a_string;\n+ *\n+ *      reducer< op_string<Char, Traits, Allocator> reducer1(move_in(a_string));\n+ *      ... parallel computation ...\n+ *      reducer1.move_out(a_string);\n+ *\n+ *      reducer< op_string<Char, Traits, Allocator> reducer2;\n+ *      reducer2.move_in(a_string);\n+ *      ... parallel computation ...\n+ *      reducer2.move_out(a_string);\n+ *\n+ *  *   `reducer1` will be constructed with the same allocator as `a_string`, \n+ *      because the string was specified in the constructor. The `move_in`\n+ *      and `move_out` can therefore be done with a `swap` in constant time.\n+ *  *   `reducer2` will be constructed with a _default_ allocator of type\n+ *      `Allocator`, which may not be the same as the allocator of `a_string`.\n+ *      Therefore, the `move_in` and `move_out` may have to be done with a copy\n+ *      in _O(N)_ time.\n+ *\n+ *  (All instances of an allocator type with no internal state (like\n+ *  `std::allocator`) are \u201cthe same\u201d. You only need to worry about the \u201csame\n+ *  allocator\u201d issue when you create string reducers with custom allocator\n+ *  types.)\n+ *\n+ *  @section redstring_types Type and Operator Requirements\n+ *\n+ *  `std::basic_string<Char, Traits, Alloc>` must be a valid type.\n+*/\n+\n+namespace cilk {\n+\n+/** @ingroup ReducersString */\n+//@{\n+\n+/** The string append reducer view class.\n+ *\n+ *  This is the view class for reducers created with\n+ *  `cilk::reducer< cilk::op_basic_string<Type, Traits, Allocator> >`. It holds\n+ *  the accumulator variable for the reduction, and allows only append\n+ *  operations to be performed on it.\n+ *\n+ *  @note   The reducer \u201cdereference\u201d operation (`reducer::operator *()`) \n+ *          yields a reference to the view. Thus, for example, the view class\u2019s\n+ *          `append` operation would be used in an expression like\n+ *          `r->append(a)`, where `r` is a string append reducer variable.\n+ *\n+ *  @tparam Char        The string element type (not the string type).\n+ *  @tparam Traits      The character traits type.\n+ *  @tparam Alloc       The string allocator type.\n+ *\n+ *  @see ReducersString\n+ *  @see op_basic_string\n+ */\n+template<typename Char, typename Traits, typename Alloc>\n+class op_basic_string_view\n+{\n+    typedef std::basic_string<Char, Traits, Alloc>  string_type;\n+    typedef std::list<string_type>                  list_type;\n+    typedef typename string_type::size_type         size_type;\n+\n+    // The view's value is represented by a list of strings and a single \n+    // string. The value is the concatenation of the strings in the list with\n+    // the single string at the end. All string operations apply to the single\n+    // string; reduce operations cause lists of partial strings from multiple\n+    // strands to be combined.\n+    //\n+    mutable string_type                             m_string;\n+    mutable list_type                               m_list;\n+\n+    // Before returning the value of the reducer, concatenate all the strings \n+    // in the list with the single string.\n+    //\n+    void flatten() const\n+    {\n+        if (m_list.empty()) return;\n+\n+        typename list_type::iterator i;\n+\n+        size_type len = m_string.size();\n+        for (i = m_list.begin(); i != m_list.end(); ++i)\n+            len += i->size();\n+\n+        string_type result(get_allocator());\n+        result.reserve(len);\n+\n+        for (i = m_list.begin(); i != m_list.end(); ++i)\n+            result += *i;\n+        m_list.clear();\n+\n+        result += m_string;\n+        result.swap(m_string);\n+    }\n+\n+public:\n+\n+    /** @name Monoid support.\n+     */\n+    //@{\n+\n+    /// Required by @ref monoid_with_view\n+    typedef string_type value_type;\n+\n+    /// Required by @ref op_string\n+    Alloc get_allocator() const\n+    {\n+        return m_string.get_allocator();\n+    }\n+\n+    /** Reduction operation.\n+     *\n+     *  This function is invoked by the @ref op_basic_string monoid to combine\n+     *  the views of two strands when the right strand merges with the left \n+     *  one. It appends the value contained in the right-strand view to the \n+     *  value contained in the left-strand view, and leaves the value in the\n+     *  right-strand view undefined.\n+     *\n+     *  @param  right   A pointer to the right-strand view. (`this` points to\n+     *                  the left-strand view.)\n+     *\n+     *  @note   Used only by the @ref op_basic_string monoid to implement the\n+     *          monoid reduce operation.\n+     */\n+    void reduce(op_basic_string_view* right)\n+    {\n+        if (!right->m_string.empty() || !right->m_list.empty()) {\n+            // (list, string) + (right_list, right_string) =>\n+            //      (list + {string} + right_list, right_string)\n+            if (!m_string.empty()) {\n+                // simulate m_list.push_back(std::move(m_string))\n+                m_list.push_back(string_type(get_allocator()));\n+                m_list.back().swap(m_string);\n+            }\n+            m_list.splice(m_list.end(), right->m_list);\n+            m_string.swap(right->m_string);\n+        }\n+    }\n+\n+    //@}\n+\n+    /** @name Pass constructor arguments through to the string constructor.\n+     */\n+    //@{\n+\n+    op_basic_string_view() : m_string() {}\n+\n+    template <typename T1>\n+    op_basic_string_view(const T1& x1) : m_string(x1) {}\n+\n+    template <typename T1, typename T2>\n+    op_basic_string_view(const T1& x1, const T2& x2) : m_string(x1, x2) {}\n+\n+    template <typename T1, typename T2, typename T3>\n+    op_basic_string_view(const T1& x1, const T2& x2, const T3& x3) : m_string(x1, x2, x3) {}\n+\n+    template <typename T1, typename T2, typename T3, typename T4>\n+    op_basic_string_view(const T1& x1, const T2& x2, const T3& x3, const T4& x4) :\n+        m_string(x1, x2, x3, x4) {}\n+\n+    //@}\n+\n+    /** Move-in constructor.\n+     */\n+    explicit op_basic_string_view(move_in_wrapper<value_type> w)\n+        : m_string(w.value().get_allocator())\n+    {\n+        m_string.swap(w.value());\n+    }\n+\n+    /** @name @ref reducer support.\n+     */\n+    //@{\n+\n+    void view_move_in(string_type& s)\n+    {\n+        m_list.clear();\n+        if (m_string.get_allocator() == s.get_allocator())\n+            // Equal allocators. Do a (fast) swap.\n+            m_string.swap(s);\n+        else\n+            // Unequal allocators. Do a (slow) copy.\n+            m_string = s;\n+        s.clear();\n+    }\n+\n+    void view_move_out(string_type& s)\n+    {\n+        flatten();\n+        if (m_string.get_allocator() == s.get_allocator())\n+            // Equal allocators.  Do a (fast) swap.\n+            m_string.swap(s);\n+        else\n+            // Unequal allocators.  Do a (slow) copy.\n+            s = m_string;\n+        m_string.clear();\n+    }\n+\n+    void view_set_value(const string_type& s) \n+        { m_list.clear(); m_string = s; }\n+\n+    string_type const& view_get_value()     const \n+        { flatten(); return m_string; }\n+\n+    string_type      & view_get_reference()       \n+        { flatten(); return m_string; }\n+\n+    string_type const& view_get_reference() const \n+        { flatten(); return m_string; }\n+\n+    //@}\n+\n+    /** @name View modifier operations.\n+     *\n+     *  @details These simply wrap the corresponding operations on the underlying string.\n+     */\n+    //@{\n+\n+    template <typename T>\n+    op_basic_string_view& operator +=(const T& x)\n+        { m_string += x; return *this; }\n+\n+    template <typename T1>\n+    op_basic_string_view& append(const T1& x1)\n+        { m_string.append(x1); return *this; }\n+\n+    template <typename T1, typename T2>\n+    op_basic_string_view& append(const T1& x1, const T2& x2)\n+        { m_string.append(x1, x2); return *this; }\n+\n+    template <typename T1, typename T2, typename T3>\n+    op_basic_string_view& append(const T1& x1, const T2& x2, const T3& x3)\n+        { m_string.append(x1, x2, x3); return *this; }\n+\n+    void push_back(const Char x) { m_string.push_back(x); }\n+\n+    //@}\n+};\n+\n+\n+/** String append monoid class. Instantiate the cilk::reducer template class\n+ *  with an op_basic_string monoid to create a string append reducer class. For\n+ *  example, to concatenate a collection of standard strings:\n+ *\n+ *      cilk::reducer< cilk::op_basic_string<char> > r;\n+ *\n+ *  @tparam Char    The string element type (not the string type).\n+ *  @tparam Traits  The character traits type.\n+ *  @tparam Alloc   The string allocator type.\n+ *  @tparam Align   If `false` (the default), reducers instantiated on this\n+ *                  monoid will be naturally aligned (the Cilk library 1.0\n+ *                  behavior). If `true`, reducers instantiated on this monoid\n+ *                  will be cache-aligned for binary compatibility with \n+ *                  reducers in Cilk library version 0.9.\n+ *\n+ *  @see ReducersString\n+ *  @see op_basic_string_view\n+ *  @see reducer_basic_string\n+ *  @see op_string\n+ *  @see op_wstring\n+ */\n+template<typename Char,\n+         typename Traits = std::char_traits<Char>,\n+         typename Alloc = std::allocator<Char>,\n+         bool     Align = false>\n+class op_basic_string : \n+    public monoid_with_view< op_basic_string_view<Char, Traits, Alloc>, Align >\n+{\n+    typedef monoid_with_view< op_basic_string_view<Char, Traits, Alloc>, Align >\n+            base;\n+    Alloc m_allocator;\n+\n+public:\n+\n+    /** View type of the monoid.\n+     */\n+    typedef typename base::view_type view_type;\n+\n+    /** Constructor.\n+     *\n+     *  There is no default constructor for string monoids, because the\n+     *  allocator must always be specified.\n+     *\n+     *  @param  allocator   The list allocator to be used when\n+     *                      identity-constructing new views.\n+     */\n+    op_basic_string(const Alloc& allocator = Alloc()) : m_allocator(allocator)\n+    {}\n+\n+    /** Create an identity view.\n+     *\n+     *  String view identity constructors take the string allocator as an\n+     *  argument.\n+     *\n+     *  @param v    The address of the uninitialized memory in which the view\n+     *              will be constructed.\n+     */\n+    void identity(view_type *v) const { ::new((void*) v) view_type(m_allocator); }\n+\n+    /** @name Construct functions\n+     *\n+     *  A string append reduction monoid must have a copy of the allocator of\n+     *  the leftmost view\u2019s string, so that it can use it in the `identity`\n+     *  operation. This, in turn, requires that string reduction monoids have a\n+     *  specialized `construct()` function.\n+     *\n+     *  All string reducer monoid `construct()` functions first construct the\n+     *  leftmost view, using the arguments that were passed in from the reducer\n+     *  constructor. They then call the view\u2019s `get_allocator()` function to\n+     *  get the string allocator from the string in the leftmost view, and pass\n+     *  that to the monoid constructor.\n+     */\n+    //@{\n+\n+    static void construct(op_basic_string* monoid, view_type* view)\n+        { provisional( new ((void*)view) view_type() ).confirm_if(\n+            new ((void*)monoid) op_basic_string(view->get_allocator()) ); }\n+\n+    template <typename T1>\n+    static void construct(op_basic_string* monoid, view_type* view, const T1& x1)\n+        { provisional( new ((void*)view) view_type(x1) ).confirm_if(\n+            new ((void*)monoid) op_basic_string(view->get_allocator()) ); }\n+\n+    template <typename T1, typename T2>\n+    static void construct(op_basic_string* monoid, view_type* view, const T1& x1, const T2& x2)\n+        { provisional( new ((void*)view) view_type(x1, x2) ).confirm_if(\n+            new ((void*)monoid) op_basic_string(view->get_allocator()) ); }\n+\n+    template <typename T1, typename T2, typename T3>\n+    static void construct(op_basic_string* monoid, view_type* view, const T1& x1, const T2& x2,\n+                            const T3& x3)\n+        { provisional( new ((void*)view) view_type(x1, x2, x3) ).confirm_if(\n+            new ((void*)monoid) op_basic_string(view->get_allocator()) ); }\n+\n+    template <typename T1, typename T2, typename T3, typename T4>\n+    static void construct(op_basic_string* monoid, view_type* view, const T1& x1, const T2& x2,\n+                            const T3& x3, const T4& x4)\n+        { provisional( new ((void*)view) view_type(x1, x2, x3, x4) ).confirm_if(\n+            new ((void*)monoid) op_basic_string(view->get_allocator()) ); }\n+\n+    //@}\n+};\n+\n+\n+/** Convenience typedef for 8-bit strings\n+ */\n+typedef op_basic_string<char> op_string;\n+    \n+/** Convenience typedef for 16-bit strings\n+ */\n+typedef op_basic_string<wchar_t> op_wstring;\n+\n+\n+/** Deprecated string append reducer class.\n+ *\n+ *  reducer_basic_string is the same as @ref reducer<@ref op_basic_string>,\n+ *  except that reducer_basic_string is a proxy for the contained view, so that\n+ *  accumulator variable update operations can be applied directly to the\n+ *  reducer. For example, a value is appended to a `reducer<%op_basic_string>`\n+ *  with `r->push_back(a)`, but a value can be appended to  a `%reducer_opand`\n+ *  with `r.push_back(a)`.\n+ *\n+ *  @deprecated Users are strongly encouraged to use `reducer<monoid>`\n+ *              reducers rather than the old wrappers like reducer_basic_string. \n+ *              The `reducer<monoid>` reducers show the reducer/monoid/view\n+ *              architecture more clearly, are more consistent in their\n+ *              implementation, and present a simpler model for new\n+ *              user-implemented reducers.\n+ *\n+ *  @note   Implicit conversions are provided between `%reducer_basic_string` \n+ *          and `reducer<%op_basic_string>`. This allows incremental code\n+ *          conversion: old code that used `%reducer_basic_string` can pass a\n+ *          `%reducer_basic_string` to a converted function that now expects a\n+ *          pointer or reference to a `reducer<%op_basic_string>`, and vice\n+ *          versa.\n+ *\n+ *  @tparam Char        The string element type (not the string type).\n+ *  @tparam Traits      The character traits type.\n+ *  @tparam Alloc       The string allocator type.\n+ *\n+ *  @see op_basic_string\n+ *  @see reducer\n+ *  @see ReducersString\n+ */\n+template<typename Char,\n+         typename Traits = std::char_traits<Char>,\n+         typename Alloc = std::allocator<Char> >\n+class reducer_basic_string : \n+    public reducer< op_basic_string<Char, Traits, Alloc, true> >\n+{\n+    typedef reducer< op_basic_string<Char, Traits, Alloc, true> > base;\n+    using base::view;\n+public:\n+\n+    /// The reducer\u2019s string type.\n+    typedef typename base::value_type       string_type;\n+\n+    /// The reducer\u2019s primitive component type.\n+    typedef Char                            basic_value_type;\n+\n+    /// The string size type.\n+    typedef typename string_type::size_type size_type;\n+\n+    /// The view type for the reducer.\n+    typedef typename base::view_type        View;\n+\n+    /// The monoid type for the reducer.\n+    typedef typename base::monoid_type      Monoid;\n+\n+\n+    /** @name Constructors\n+     */\n+    //@{\n+    \n+    /** @name Forward constructor calls to the base class.\n+     *\n+     *  All basic_string constructor forms are supported.\n+     */\n+    //@{\n+    reducer_basic_string() {}\n+\n+    template <typename T1>\n+    reducer_basic_string(const T1& x1) : \n+        base(x1) {}\n+\n+    template <typename T1, typename T2>\n+    reducer_basic_string(const T1& x1, const T2& x2) : \n+        base(x1, x2) {}\n+\n+    template <typename T1, typename T2, typename T3>\n+    reducer_basic_string(const T1& x1, const T2& x2, const T3& x3) : \n+        base(x1, x2, x3) {}\n+\n+    template <typename T1, typename T2, typename T3, typename T4>\n+    reducer_basic_string(const T1& x1, const T2& x2, const T3& x3, const T4& x4) :\n+        base(x1, x2, x3, x4) {}\n+    //@}\n+\n+    /** Allow mutable access to the string within the current view.\n+     *\n+     *  @warning    If this method is called before the parallel calculation is \n+     *              complete, the string returned by this method will be a\n+     *              partial result.\n+     *\n+     *  @returns    A mutable reference to the string within the current view.\n+     */\n+    string_type &get_reference() \n+        { return view().view_get_reference(); }\n+\n+    /** Allow read-only access to the string within the current view.\n+     *\n+     *  @warning    If this method is called before the parallel calculation is\n+     *              complete, the string returned by this method will be a\n+     *              partial result.\n+     *\n+     *  @returns    A const reference to the string within the current view.\n+     */\n+    string_type const &get_reference() const \n+        { return view().view_get_reference(); }\n+\n+    /** @name Append to the string.\n+     *\n+     *  These operations are simply forwarded to the view.\n+     */\n+    //@{\n+    void append(const Char *ptr)\n+        { view().append(ptr); }\n+    void append(const Char *ptr, size_type count)\n+        { view().append(ptr, count); }\n+    void append(const string_type &str, size_type offset, size_type count)\n+        { view().append(str, offset, count); }\n+    void append(const string_type &str)\n+        { view().append(str); }\n+    void append(size_type count, Char ch)\n+        { view().append(count, ch); }\n+\n+    // Append to the string\n+    reducer_basic_string<Char, Traits, Alloc> &operator+=(Char ch)\n+        { view() += ch; return *this; }\n+    reducer_basic_string<Char, Traits, Alloc> &operator+=(const Char *ptr)\n+        { view() += ptr; return *this; }\n+    reducer_basic_string<Char, Traits, Alloc> &operator+=(const string_type &right)\n+        { view() += right; return *this; }\n+    //@}\n+\n+    /** @name Dereference\n+     *  @details Dereferencing a wrapper is a no-op. It simply returns the\n+     *  wrapper. Combined with the rule that the wrapper forwards view\n+     *  operations to its contained view, this means that view operations can\n+     *  be written the same way on reducers and wrappers, which is convenient\n+     *  for incrementally converting old code using wrappers to use reducers\n+     *  instead. That is:\n+     *\n+     *      reducer<op_string> r;\n+     *      r->push_back(a);    // r-> returns the view\n+     *                          // push_back() is a view member function\n+     *\n+     *      reducer_string w;\n+     *      w->push_back(a);    // *w returns the wrapper\n+     *                          // push_back() is a wrapper member function\n+     *                          // that calls the corresponding view function\n+     */\n+    //@{\n+    reducer_basic_string&       operator*()       { return *this; }\n+    reducer_basic_string const& operator*() const { return *this; }\n+\n+    reducer_basic_string*       operator->()       { return this; }\n+    reducer_basic_string const* operator->() const { return this; }\n+    //@}\n+\n+    /** @name Upcast\n+     *  @details In Cilk library 0.9, reducers were always cache-aligned. In\n+     *  library  1.0, reducer cache alignment is optional. By default, reducers\n+     *  are unaligned (i.e., just naturally aligned), but legacy wrappers\n+     *  inherit from cache-aligned reducers for binary compatibility.\n+     *\n+     *  This means that a wrapper will automatically be upcast to its aligned\n+     *  reducer base class. The following conversion operators provide\n+     *  pseudo-upcasts to the corresponding unaligned reducer class.\n+     */\n+    //@{\n+    operator reducer< op_basic_string<Char, Traits, Alloc, false> >& ()\n+    {\n+        return *reinterpret_cast< reducer< \n+            op_basic_string<Char, Traits, Alloc, false> >* \n+        >(this);\n+    }\n+    operator const reducer< op_basic_string<Char, Traits, Alloc, false> >& () const\n+    {\n+        return *reinterpret_cast< const reducer<\n+            op_basic_string<Char, Traits, Alloc, false> >* \n+        >(this);\n+    }\n+    //@}\n+};\n+\n+\n+/** Convenience typedef for 8-bit strings\n+ */\n+typedef reducer_basic_string<char> reducer_string;\n+\n+/** Convenience typedef for 16-bit strings\n+ */\n+typedef reducer_basic_string<wchar_t> reducer_wstring;\n+\n+/// @cond internal\n+\n+/// @cond internal\n+/** Metafunction specialization for reducer conversion.\n+ *\n+ *  This specialization of the @ref legacy_reducer_downcast template class \n+ *  defined in reducer.h causes the `reducer< op_basic_string<Char> >` class to\n+ *  have an `operator reducer_basic_string<Char>& ()` conversion operator that\n+ *  statically downcasts the `reducer<op_basic_string>` to the corresponding\n+ *  `reducer_basic_string` type. (The reverse conversion, from \n+ *  `reducer_basic_string` to `reducer<op_basic_string>`, is just an upcast,\n+ *  which is provided for free by the language.)\n+ *\n+ *  @ingroup ReducersString\n+ */\n+template<typename Char, typename Traits, typename Alloc, bool Align>\n+struct legacy_reducer_downcast<\n+    reducer<op_basic_string<Char, Traits, Alloc, Align> > >\n+{\n+    typedef reducer_basic_string<Char, Traits, Alloc> type;\n+};\n+\n+/// @endcond\n+\n+//@}\n+\n+} // namespace cilk\n+\n+#endif //  REDUCER_STRING_H_INCLUDED"}, {"sha": "c6986ae7b0875da28fcea643c65220a0b7f6170c", "filename": "libcilkrts/include/cilktools/cilkscreen.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,108 @@\n+/* cilkscreen.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ * @copyright\n+ * Copyright (C) 2010-2013, Intel Corporation\n+ * All rights reserved.\n+ * \n+ * @copyright\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * \n+ *   * Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *   * Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in\n+ *     the documentation and/or other materials provided with the\n+ *     distribution.\n+ *   * Neither the name of Intel Corporation nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ * \n+ * @copyright\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+\n+#ifndef INCLUDED_CILKSCREEN_H\n+#define INCLUDED_CILKSCREEN_H\n+\n+#include <cilk/cilk_api.h>\n+\n+/*\n+ * Cilkscreen \"functions\".  These macros generate metadata in your application\n+ * to notify Cilkscreen of program state changes\n+ */\n+\n+#if ! defined(CILK_STUB) && defined(__INTEL_COMPILER)\n+#  define __cilkscreen_metacall(annotation,expr) \\\n+    __notify_zc_intrinsic((char *)annotation, expr)\n+#else\n+#  define __cilkscreen_metacall(annotation,expr) ((void)annotation, (void)(expr))\n+#endif\n+\n+/* Call once when a user thread enters a spawning function */\n+#define __cilkscreen_enable_instrumentation() \\\n+    __cilkscreen_metacall(\"cilkscreen_enable_instrumentation\", 0)\n+\n+/* Call once when a user thread exits a spawning function */\n+#define  __cilkscreen_disable_instrumentation() \\\n+    __cilkscreen_metacall(\"cilkscreen_disable_instrumentation\", 0)\n+\n+/* Call to temporarily disable cilkscreen instrumentation */\n+#define __cilkscreen_enable_checking() \\\n+    __cilkscreen_metacall(\"cilkscreen_enable_checking\", 0)\n+\n+/* Call to re-enable temporarily-disabled cilkscreen instrumentation */\n+#define __cilkscreen_disable_checking() \\\n+    __cilkscreen_metacall(\"cilkscreen_disable_checking\", 0)\n+\n+/* Inform cilkscreen that memory from begin to end can be reused without\n+ * causing races (e.g., for memory that comes from a memory allocator) */\n+#define __cilkscreen_clean(begin, end)                      \\\n+    do {                                                    \\\n+        void *__data[2] = { (begin), (end) };               \\\n+        __cilkscreen_metacall(\"cilkscreen_clean\", &__data); \\\n+    } while(0)\n+\n+/* Inform cilkscreen that a lock is being acquired.\n+ * If the lock type is not a handle, then the caller should take its address\n+ * and pass the pointer to the lock.  Otherwise, the caller should pass the\n+ * lock handle directly.\n+ */\n+#define __cilkscreen_acquire_lock(lock) \\\n+    __cilkscreen_metacall(\"cilkscreen_acquire_lock\", (lock))\n+\n+#define __cilkscreen_release_lock(lock) \\\n+    __cilkscreen_metacall(\"cilkscreen_release_lock\", (lock))\n+\n+/*\n+ * Metacall data\n+ *\n+ * A metacall is a way to pass data to a function implemented by a tool.\n+ * Metacalls are always instrumented when the tool is loaded.\n+ */\n+\n+// Tool code for Cilkscreen\n+#define METACALL_TOOL_CILKSCREEN 1\n+\n+// Metacall codes implemented by Cilkscreen\n+#define CS_METACALL_PUTS 0  // Write string to the Cilkscreen log\n+\n+#define __cilkscreen_puts(text) \\\n+    __cilkrts_metacall(METACALL_TOOL_CILKSCREEN, CS_METACALL_PUTS, (void *)(const char *)text)\n+\n+#endif /* defined(INCLUDED_CILKSCREEN_H) */"}, {"sha": "eb7d9d8c0e44402707ac4e24465be44354537717", "filename": "libcilkrts/include/cilktools/cilkview.h", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,278 @@\n+/* cilkview.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ * @copyright\n+ * Copyright (C) 2010-2013, Intel Corporation\n+ * All rights reserved.\n+ * \n+ * @copyright\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * \n+ *   * Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *   * Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in\n+ *     the documentation and/or other materials provided with the\n+ *     distribution.\n+ *   * Neither the name of Intel Corporation nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ * \n+ * @copyright\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+\n+#ifndef INCLUDED_CILKVIEW_H\n+#define INCLUDED_CILKVIEW_H\n+\n+#include <cilk/cilk_api.h>\n+\n+#ifdef _WIN32\n+#   ifndef _WINBASE_\n+__CILKRTS_BEGIN_EXTERN_C\n+unsigned long __stdcall GetTickCount();\n+__CILKRTS_END_EXTERN_C\n+#   endif\n+#endif  // _WIN32\n+\n+#if defined __unix__ || defined __APPLE__ || defined __VXWORKS__\n+#   include <sys/time.h>\n+#endif  // defined __unix__ || defined __APPLE__\n+\n+/// @brief Return the system clock with millisecond resolution\n+///\n+/// This function returns a long integer representing the number of\n+/// milliseconds since an arbitrary starting point, e.g., since the system was\n+/// started or since the Unix Epoch.  The result is meaningless by itself, but\n+/// the difference between two sequential calls to __cilkview_getticks()\n+/// represents the time interval that elapsed between them (in ms).\n+static inline unsigned long long __cilkview_getticks()\n+{\n+#if __INTEL_COMPILER > 1200\n+    // When inlined, prevent code motion around this call\n+    __notify_zc_intrinsic((void*) \"test_getticks_start\", 0);\n+#endif\n+\n+#ifdef _WIN32\n+    // Return milliseconds elapsed since the system started\n+    return GetTickCount();\n+#elif defined(__unix__) || defined(__APPLE__) || defined __VXWORKS__\n+    // Return milliseconds elapsed since the Unix Epoch\n+    // (1-Jan-1970 00:00:00.000 UTC)\n+    struct timeval t;\n+    gettimeofday(&t, 0);\n+    return t.tv_sec * 1000ULL + t.tv_usec / 1000;\n+#else\n+#   error test_getticks() not implemented for this OS\n+#endif\n+\n+#if __INTEL_COMPILER > 1200\n+    // When inlined, prevent code motion around this call\n+    __notify_zc_intrinsic((void*) \"test_getticks_end\", 0);\n+#endif\n+}\n+\n+typedef struct\n+{\n+    unsigned int        size;           // Size of structure in bytes\n+    unsigned int        status;         // 1 = success, 0 = failure\n+    unsigned long long  time;           // Time in milliseconds\n+    unsigned long long  work;\n+    unsigned long long  span;\n+    unsigned long long  burdened_span;\n+    unsigned long long  spawns;\n+    unsigned long long  syncs;\n+    unsigned long long  strands;\n+    unsigned long long  atomic_ins;\n+    unsigned long long  frames;\n+} cilkview_data_t;\n+\n+typedef struct\n+{\n+    cilkview_data_t *start;     // Values at start of interval\n+    cilkview_data_t *end;       // Values at end of interval\n+    const char *label;          // Name for this interval\n+    unsigned int flags;         // What to do - see flags below\n+} cilkview_report_t;\n+\n+// What __cilkview_report should do.  The flags can be ORed together\n+enum\n+{\n+    CV_REPORT_WRITE_TO_LOG = 1,     // Write parallelism report to the log (xml or text)\n+    CV_REPORT_WRITE_TO_RESULTS = 2  // Write parallelism data to results file\n+};\n+\n+#ifndef CILKVIEW_NO_REPORT\n+static void __cilkview_do_report(cilkview_data_t *start,\n+                          cilkview_data_t *end,\n+                          const char *label,\n+                          unsigned int flags);\n+#endif /* CILKVIEW_NO_REPORT */\n+\n+/*\n+ * Metacall data\n+ *\n+ * A metacall is a way to pass data to a function implemented by a tool.\n+ * Metacalls are always instrumented when the tool is loaded.\n+ */\n+\n+// Tool code for Cilkview\n+#define METACALL_TOOL_CILKVIEW 2\n+\n+// Metacall codes implemented by Cilkview\n+enum\n+{\n+    CV_METACALL_PUTS,\n+    CV_METACALL_QUERY,\n+    CV_METACALL_START,\n+    CV_METACALL_STOP,\n+    CV_METACALL_RESET,\n+    CV_METACALL_USE_DEFAULT_GRAIN,\n+    CV_METACALL_CONNECTED,\n+    CV_METACALL_SUSPEND,\n+    CV_METACALL_RESUME,\n+    CV_METACALL_REPORT\n+};\n+\n+#if ! defined(CILK_STUB) && defined(__INTEL_COMPILER)\n+#  define __cilkview_metacall(code,data) \\\n+    __cilkrts_metacall(METACALL_TOOL_CILKVIEW, code, data)\n+#else\n+#  define __cilkview_metacall(annotation,expr) (annotation, (void) (expr))\n+#endif\n+\n+// Write arbitrary string to the log\n+#define __cilkview_puts(arg) \\\n+    __cilkview_metacall(CV_METACALL_PUTS, arg)\n+\n+// Retrieve the Cilkview performance counters.  The parameter must be a \n+// cilkview_data_t\n+#define __cilkview_query(d)                             \\\n+    do {                                                \\\n+        d.size = sizeof(d);                             \\\n+        d.status = 0;                                   \\\n+        __cilkview_metacall(CV_METACALL_QUERY, &d);     \\\n+        if (0 == d.status)                              \\\n+            d.time = __cilkview_getticks();             \\\n+    } while (0)\n+\n+// Write report to log or results file. If end is NULL, Cilkview will\n+// use the current values.\n+#define __cilkview_report(start, end, label, flags) \\\n+    __cilkview_do_report(start, end, label, flags)\n+\n+// Control the workspan performance counters for the final report\n+#define __cilkview_workspan_start() \\\n+    __cilkview_metacall(CV_METACALL_START, 0)\n+#define __cilkview_workspan_stop() \\\n+    __cilkview_metacall(CV_METACALL_STOP, 0)\n+#define __cilkview_workspan_reset() \\\n+    __cilkview_metacall(CV_METACALL_RESET, 0)\n+#define __cilkview_workspan_suspend() \\\n+    __cilkview_metacall(CV_METACALL_SUSPEND, 0)\n+#define __cilkview_workspan_resume() \\\n+    __cilkview_metacall(CV_METACALL_RESUME, 0)\n+\n+#define __cilkview_use_default_grain_size() \\\n+    __cilkview_metacall(CV_METACALL_USE_DEFAULT, 0)\n+\n+// Sets the int is_connected to 1 if Cilkview is active\n+#define __cilkview_connected(is_connected) \\\n+    __cilkview_metacall(CV_METACALL_CONNECTED, &is_connected)\n+\n+\n+#ifndef CILKVIEW_NO_REPORT\n+\n+// Stop Microsoft include files from complaining about getenv and fopen\n+#define _CRT_SECURE_NO_WARNINGS\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#ifdef _WIN32\n+#pragma warning(push)\n+#pragma warning(disable: 1786)\t// Suppress warnings that getenv, fopen are deprecated\n+#endif\n+\n+static void __cilkview_do_report(cilkview_data_t *start,\n+                                 cilkview_data_t *end,\n+                                 const char *label,\n+                                 unsigned int flags)\n+{\n+    int under_cilkview = 0;\n+    unsigned long long elapsed_ms;\n+    int worker_count = 0;\n+    char *nworkers;\n+    char *outfile;\n+    FILE *f;\n+\n+    // Check whether we're running under Cilkview\n+    __cilkview_connected(under_cilkview);\n+\n+    // If we're running under Cilkview, let it do those things that need\n+    // to be done\n+    if (under_cilkview)\n+    {\n+        cilkview_report_t d = {start, end, label, flags};\n+        __cilkview_metacall(CV_METACALL_REPORT, &d);\n+        return;\n+    }\n+\n+    // We're not running under Cilkview.\n+    //\n+    // If we weren't asked to write to the results file, we're done.\n+    if (0 == (flags & CV_REPORT_WRITE_TO_RESULTS))\n+        return;\n+\n+    // Calculate the elapse milliseconds\n+    if (NULL == end)\n+        elapsed_ms = __cilkview_getticks() - start->time;\n+    else\n+        elapsed_ms = end->time - start->time;\n+\n+    // Determine how many workers we're using for this trial run\n+    nworkers = getenv(\"CILK_NWORKERS\");\n+    if (NULL != nworkers)\n+        worker_count = atoi(nworkers);\n+    if (0 == worker_count)\n+        worker_count = 16;\n+\n+    // Open the output file and write the trial data to it\n+    outfile = getenv(\"CILKVIEW_OUTFILE\");\n+    if (NULL == outfile)\n+        outfile = (char *)\"cilkview.out\";\n+\n+    f = fopen(outfile, \"a\");\n+    if (NULL == f)\n+        fprintf(stderr, \"__cilkview_do_report: unable to append to file %s\\n\", outfile);\n+    else\n+    {\n+        fprintf(f, \"%s trial %d %f\\n\", label,\n+                worker_count,\n+                ((float)elapsed_ms) / 1000.0f);\n+        fclose(f);\n+    }\n+}\n+#ifdef _WIN32\n+#pragma warning(pop)\n+#endif\n+\n+#endif  // CILKVIEW_NO_REPORT\n+\n+\n+#endif /* ! defined(INCLUDED_CILKVIEW_H) */"}, {"sha": "9ae0678112f7c9e10aa7dc7d8c34533008cc6d31", "filename": "libcilkrts/include/cilktools/fake_mutex.h", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,92 @@\n+/* fake_mutex.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ * @copyright\n+ * Copyright (C) 2013, Intel Corporation\n+ * All rights reserved.\n+ * \n+ * @copyright\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * \n+ *   * Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *   * Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in\n+ *     the documentation and/or other materials provided with the\n+ *     distribution.\n+ *   * Neither the name of Intel Corporation nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ * \n+ * @copyright\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************\n+ *\n+ * Cilkscreen fake mutexes are provided to indicate to the Cilkscreen race\n+ * detector that a race should be ignored.\n+ *\n+ * NOTE: This class does not provide mutual exclusion.  You should use the\n+ * mutual exclusion constructs provided by TBB or your operating system to\n+ * protect against real data races.\n+ */\n+\n+#ifndef FAKE_MUTEX_H_INCLUDED\n+#define FAKE_MUTEX_H_INCLUDED\n+\n+#include <cilktools/cilkscreen.h>\n+\n+namespace cilkscreen\n+{\n+    class fake_mutex\n+    {\n+    public:\n+\tfake_mutex() : locked(false)\n+\t{\n+\t}\n+\n+\t~fake_mutex()\n+\t{\n+\t    __CILKRTS_ASSERT(! locked);\n+\t}\n+\n+        // Wait until mutex is available, then enter\n+        void lock()\n+        {\n+            __cilkscreen_acquire_lock(&locked);\n+\t    __CILKRTS_ASSERT(! locked);\n+\t    locked = true;\n+        }\n+\n+        // A fake mutex is always available\n+        bool try_lock() { lock(); return true; }\n+\n+        // Releases the mutex\n+        void unlock()\n+        {\n+\t    __CILKRTS_ASSERT(locked);\n+\t    locked = false;\n+            __cilkscreen_release_lock(&locked);\n+        }\n+\n+    private:\n+        bool locked;\n+    };\n+\n+} // namespace cilk\n+\n+#endif  // FAKE_MUTEX_H_INCLUDED"}, {"sha": "d513e2b97340fb99a82e2044cb9215e9d968efca", "filename": "libcilkrts/include/cilktools/lock_guard.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,86 @@\n+/* lock_guard.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ * @copyright\n+ * Copyright (C) 2011-2013, Intel Corporation\n+ * All rights reserved.\n+ * \n+ * @copyright\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * \n+ *   * Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *   * Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in\n+ *     the documentation and/or other materials provided with the\n+ *     distribution.\n+ *   * Neither the name of Intel Corporation nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ * \n+ * @copyright\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************\n+ *\n+ * Lock guard patterned after the std::lock_guard class template proposed in\n+ * the C++ 0x draft standard.\n+ *\n+ * An object of type lock_guard controls the ownership of a mutex object\n+ * within a scope. A lock_guard object maintains ownership of a mutex object\n+ * throughout the lock_guard object's lifetime. The behavior of a program is\n+ * undefined if the mutex referenced by pm does not exist for the entire\n+ * lifetime of the lock_guard object.\n+ */\n+\n+#ifndef LOCK_GUARD_H_INCLUDED\n+#define LOCK_GUARD_H_INCLUDED\n+\n+#include <cilk/cilk.h>\n+\n+namespace cilkscreen\n+{\n+    template <class Mutex>\n+    class lock_guard\n+    {\n+    public:\n+        typedef Mutex mutex_type;\n+\n+        explicit lock_guard(mutex_type &m) : pm(m)\n+        {\n+            pm.lock();\n+            locked = true;\n+        }\n+\n+        ~lock_guard()\n+        {\n+            locked = false;\n+            pm.unlock();\n+        }\n+\n+    private:\n+        lock_guard(lock_guard const&);\n+        lock_guard& operator=(lock_guard const&);\n+\n+    private:\n+        // exposition only:\n+        mutex_type &pm;\n+        bool locked;\n+    };\n+}\n+\n+#endif  // LOCK_GUARD_H_INCLUDED"}, {"sha": "f45b5bcb178ed46b510d2341ccf88d9d8e811e2a", "filename": "libcilkrts/include/internal/abi.h", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fabi.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,639 @@\n+/*\n+ *  abi.h\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ******************************************************************************/\n+\n+/**\n+ * @file abi.h\n+ *\n+ * @brief Defines the application binary interface between the compiler and\n+ * the Intel Cilk Plus runtime.\n+ */\n+\n+#ifndef CILK_INTERNAL_ABI_H\n+#define CILK_INTERNAL_ABI_H\n+\n+\n+#include <cilk/common.h>\n+#include <stddef.h>  // Needed to define size_t\n+\n+/**\n+ * Jump buffers are OS and architecture dependent\n+ */\n+#if ! defined(_MSC_VER)\n+/* Non-Windows - only need 5 registers for the jump buffer for both IA32 and Intel64 */\n+typedef void *__CILK_JUMP_BUFFER[5];\n+\n+/** OS-specific implementation of setjmp */\n+#   define CILK_SETJMP(X) __builtin_setjmp(X)\n+/** OS-specific implementation of longjmp */\n+#   define CILK_LONGJMP(X) __builtin_longjmp(X,1)\n+#else\n+/* Windows - things are a little more complicated */\n+#   if defined(_M_X64)\n+/* Intel64 - Use an OS-defined jump buffer */\n+#       include <setjmp.h>\n+typedef jmp_buf __CILK_JUMP_BUFFER;\n+\n+#       define CILK_SETJMP(X) setjmp(X)\n+#       define CILK_LONGJMP(X) longjmp(X, 1)\n+#   elif defined(_M_IX86)\n+/**\n+ * Windows x86 - Use a simplified version of the Windows jump buffer for x86\n+ * setjmp is provided by __cilkrts_setjmp which passes jump buffer in EAX and\n+ * destination in EDX longjmp is provided by an internal routine which uses\n+ * this structure\n+ */\n+typedef struct\n+{\n+    unsigned long Ebp;\n+    unsigned long Ebx;\n+    unsigned long Edi;\n+    unsigned long Esi;\n+    unsigned long Esp;\n+    unsigned long Eip;\n+    unsigned long Registration;\n+    unsigned long TryLevel;\n+} __CILK_JUMP_BUFFER;\n+\n+#    else\n+#    error Unexpected architecture - Need to define __CILK_JUMP_BUFFER\n+#    endif  /* _M_X64 */\n+\n+#endif  /* defined(_MSC_VER) */\n+\n+/* struct tags */\n+typedef struct __cilkrts_stack_frame __cilkrts_stack_frame; ///< struct tag for stack frame\n+\n+// Forwarded declarations\n+typedef struct global_state_t        global_state_t;  ///< Forwarded declaration for global state\n+typedef struct local_state           local_state;     ///< Forwarded declaration for local state\n+typedef struct cilkred_map           cilkred_map;     ///< Forward declaration for reducer map\n+\n+/// Forwarded declaration for system-dependent worker state\n+typedef struct __cilkrts_worker_sysdep_state\n+                                     __cilkrts_worker_sysdep_state;\n+\n+/**\n+ * The worker struct contains per-worker information that needs to be\n+ * visible to the compiler, or rooted here.\n+ *\n+ * For 32-bit Windows we need to be aligning the structures on 4-byte\n+ * boundaries to match where ICL is allocating the birthrank and rank\n+ * in the __cilkrts_stack_frame.  It's 4-byte aligned instead of 8-byte\n+ * aligned.  This is OK because the compiler is dealing with the 64-bit\n+ * quantities as two 32-bit values.  So change the packing to be on\n+ * 4-byte boundaries.\n+ *\n+ * The fields of the worker struct can be classified as either local\n+ * or shared.\n+ *\n+ *  Local: This field is only accessed by the thread bound to this\n+ *    worker struct.  Local fields can be freely accessed without\n+ *    acquiring locks.\n+ *  \n+ *  Shared: This field may be accessed by multiple worker threads.\n+ *    Accesses to shared fields usually requires locks, except in\n+ *    special situations where one can prove that locks are\n+ *    unnecessary.\n+ *\n+ * The fields of the worker struct can also be classified as\n+ * \"read-only\" if the field does not change after it is initialized.\n+ * Otherwise, the field is \"read/write\".  Read-only fields do not\n+ * require locks to access (ignoring the synchronization that might be\n+ * needed for initialization if this can occur in parallel).\n+ *\n+ * Finally, we explicitly classify some fields as \"synchronization\"\n+ * fields if they are used as part of a synchronization protocol in\n+ * the runtime.  These variables are generally shared and read/write.\n+ * Mostly, this category includes lock variables and other variables\n+ * that are involved in synchronization protocols (i.e., the THE\n+ * protocol).\n+ */\n+#if defined(_MSC_VER) && defined(_M_IX86)\n+#pragma pack(push, 4)\n+#endif\n+\n+struct __cilkrts_worker {\n+    /**\n+     * T, H, and E pointers in the THE protocol See \"The implementation of\n+     * the Cilk-5 multithreaded language\", PLDI 1998:\n+     * http://portal.acm.org/citation.cfm?doid=277652.277725\n+     *\n+     * Synchronization fields.  [shared read/write]\n+     */\n+    __cilkrts_stack_frame *volatile *volatile tail;\n+    __cilkrts_stack_frame *volatile *volatile head;  /**< @copydoc tail */\n+    __cilkrts_stack_frame *volatile *volatile exc;   /**< @copydoc tail */\n+\n+    /**\n+     * Addition to the THE protocol to allow us to protect some set of\n+     * entries in the tail queue from stealing.  Normally, this is set\n+     * beyond the end of the task queue, indicating that all entries are\n+     * available for stealing.  During exception handling, protected_tail\n+     * may be set to the first entry in the task queue, indicating that\n+     * stealing is not allowed.\n+     *\n+     * Synchronization field.\n+     */\n+    __cilkrts_stack_frame *volatile *volatile protected_tail;\n+\n+    /**\n+     * Limit of the Lazy Task Queue, to detect queue overflow\n+     * [local read-only]\n+     */\n+    __cilkrts_stack_frame *volatile *ltq_limit;\n+\n+    /**\n+     * Worker id.\n+     * [local read-only]\n+     */\n+    int32_t self;\n+\n+    /**\n+     * Global state of the runtime system, opaque to the client.\n+     * [local read-only]\n+     */\n+    global_state_t *g;\n+\n+    /**\n+     * Additional per-worker state of the runtime system that we want\n+     * to maintain hidden from the client.\n+     * [shared read-only]\n+     */\n+    local_state *l;\n+\n+    /**\n+     * Map from reducer names to reducer values.\n+     * [local read/write]\n+     */\n+    cilkred_map *reducer_map;\n+\n+    /**\n+     * A slot that points to the currently executing Cilk frame.\n+     * [local read/write]\n+     */\n+    __cilkrts_stack_frame *current_stack_frame;\n+\n+    /**\n+     * Reserved space for a pointer.\n+     * Used to be __cilkrts_stack_frame *volatile *volatile saved_protected_tail; \n+     */\n+    void* reserved;\n+\n+    /**\n+     * System-dependent part of the worker state\n+     * [local read-only]\n+     */\n+    __cilkrts_worker_sysdep_state *sysdep;\n+\n+#if __CILKRTS_ABI_VERSION >= 1\n+    /**\n+     * Per-worker pedigree information used to support scheduling-independent\n+     * pseudo-random numbers.\n+     * [local read/write]\n+     */\n+    __cilkrts_pedigree   pedigree;    \n+#endif  /* __CILKRTS_ABI_VERSION >= 1 */\n+};\n+\n+\n+/**\n+ * Every spawning function has a frame descriptor.  A spawning function\n+ * is a function that spawns or detaches.  Only spawning functions\n+ * are visible to the Cilk runtime.\n+ */\n+struct __cilkrts_stack_frame\n+{\n+    /**\n+     * flags is an integer with values defined below.  Client code\n+     * initializes flags to CILK_FRAME_VERSION before the first Cilk\n+     * operation.\n+     *\n+     * The low 24-bits of the 'flags' field are the flags, proper.  The high\n+     * 8-bits are the version number.\n+     *\n+     * IMPORTANT: bits in this word are set and read by the PARENT ONLY,\n+     * not by a spawned child.  In particular, the STOLEN and UNSYNCHED\n+     * bits are set on a steal and are read before a sync.  Since there\n+     * is no synchronization (locking) on this word, any attempt to set\n+     * or read these bits asynchronously in a child would result in a race.\n+     */\n+    uint32_t flags;\n+\n+    /** Not currently used.  Not initialized by Intel compiler. */\n+    int32_t size;\n+\n+    /** \n+     * call_parent points to the __cilkrts_stack_frame of the closest\n+     * ancestor spawning function, including spawn helpers, of this frame.\n+     * It forms a linked list ending at the first stolen frame.\n+     */\n+    __cilkrts_stack_frame *call_parent;\n+\n+    /**\n+     * The client copies the worker from TLS here when initializing\n+     * the structure.  The runtime ensures that the field always points\n+     * to the __cilkrts_worker which currently \"owns\" the frame.\n+     */\n+    __cilkrts_worker *worker;\n+\n+    /**\n+     * Unix: Pending exception after sync.  The sync continuation\n+     * must call __cilkrts_rethrow to handle the pending exception.\n+     *\n+     * Windows: the handler that _would_ have been registered if our\n+     * handler were not there.  We maintain this for unwinding purposes.\n+     * Win32: the value of this field is only defined in spawn helper\n+     * functions\n+     *\n+     * Win64: except_data must be filled in  for all functions with a\n+     * __cilkrts_stack_frame\n+     */\n+    void *except_data;\n+\n+    /**\n+     * Before every spawn and nontrivial sync the client function\n+     * saves its continuation here.\n+     */\n+    __CILK_JUMP_BUFFER ctx;\n+\n+#if __CILKRTS_ABI_VERSION >= 1\n+    /**\n+     * Architecture-specific floating point state.  mxcsr and fpcsr should be\n+     * set when CILK_SETJMP is called in client code.  Note that the Win64\n+     * jmpbuf for the Intel64 architecture already contains this information\n+     * so there is no need to use these fields on that OS/architecture.\n+     */\n+    uint32_t mxcsr;\n+    uint16_t fpcsr;         /**< @copydoc mxcsr */\n+\n+\n+    /**\n+     * reserved is not used at this time.  Client code should initialize it\n+     * to 0 before the first Cilk operation\n+     */\n+    uint16_t reserved;\n+\n+    /**\n+     * Pedigree information to support scheduling-independent pseudo-random\n+     * numbers.  There are two views of this information.  The copy in a\n+     * spawning function is used to stack the rank and communicate to the\n+     * runtime on a steal or continuation.  The copy in a spawn helper is\n+     * immutable once the function is detached and is a node in the pedigree.\n+     * The union is used to make clear which view we're using.\n+     *\n+     * In the detach sequence Client code should:\n+     *    - copy the worker pedigree into the spawn helper's pedigree\n+     *    - copy the worker pedigree into the call parent's pedigree\n+     *    - set the worker's rank to 0\n+     *    - set the worker's pedigree.next to the spawn helper's pedigree\n+     */\n+    union\n+    {\n+        __cilkrts_pedigree spawn_helper_pedigree; /* Used in spawn helpers */\n+        __cilkrts_pedigree parent_pedigree;       /* Used in spawning funcs */\n+    };\n+#endif  /* __CILKRTS_ABI_VERSION >= 1 */\n+};\n+\n+/*\n+ * Restore previous structure packing for 32-bit Windows\n+ */\n+#if defined(_MSC_VER) && defined(_M_IX86)\n+#pragma pack(pop)\n+#endif\n+\n+/* Values of the flags bitfield */\n+/** CILK_FRAME_STOLEN is set if the frame has ever been stolen. */\n+#define CILK_FRAME_STOLEN    0x01\n+\n+/**\n+ * CILK_FRAME_UNSYNCHED is set if the frame has been stolen and\n+ * is has not yet executed _Cilk_sync.  It is technically a misnomer in that a\n+ * frame can have this flag set even if all children have returned.\n+ */\n+#define CILK_FRAME_UNSYNCHED 0x02\n+\n+/**\n+ * Is this frame detached (spawned)?  If so the runtime needs\n+ * to undo-detach in the slow path epilogue.\n+ */\n+#define CILK_FRAME_DETACHED  0x04\n+\n+/**\n+ * CILK_FRAME_EXCEPTION_PROBED is set if the frame has been probed in the\n+ * exception handler first pass\n+ */\n+#define CILK_FRAME_EXCEPTION_PROBED 0x08\n+\n+/** Is this frame receiving an exception after sync? */\n+#define CILK_FRAME_EXCEPTING 0x10\n+\n+/**\n+ * Is the pedigree unsynched?  That is, has a synch occurred that is not\n+ * yet represented in the pedigree?\n+ */\n+#define CILK_FRAME_SF_PEDIGREE_UNSYNCHED 0x20\n+\n+/** Is this the last (oldest) Cilk frame? */\n+#define CILK_FRAME_LAST\t     0x80\n+\n+/**\n+ * Is this frame in the epilogue, or more generally after the last\n+ * sync when it can no longer do any Cilk operations?\n+ */\n+#define CILK_FRAME_EXITING   0x0100\n+\n+/** Is this frame suspended? (used for debugging) */\n+#define CILK_FRAME_SUSPENDED 0x8000\n+\n+/** Used by Windows exception handling to indicate that __cilkrts_leave_frame should do nothing */\n+#define CILK_FRAME_UNWINDING 0x10000\n+\n+/*\n+ * The low 24-bits of the 'flags' field are the flags, proper.  The high 8-bits\n+ * are the version number.\n+ */\n+\n+/** ABI version left shifted to the high byte */\n+#define CILK_FRAME_VERSION (__CILKRTS_ABI_VERSION << 24)\n+\n+/** Mask for the flags field to isolate the version bits */\n+#define CILK_FRAME_VERSION_MASK  0xFF000000\n+\n+/** Mask for the flags field to isolate the flag bits */\n+#define CILK_FRAME_FLAGS_MASK    0x00FFFFFF\n+\n+/** Convenience macro to provide access the version portion of the flags field */\n+#define CILK_FRAME_VERSION_VALUE(_flags) (((_flags) & CILK_FRAME_VERSION_MASK) >> 24)\n+\n+/** Any undefined bits are reserved and must be zero (\"MBZ\" = \"Must Be Zero\") */\n+#define CILK_FRAME_MBZ  (~ (CILK_FRAME_STOLEN | \\\n+                            CILK_FRAME_UNSYNCHED | \\\n+                            CILK_FRAME_DETACHED | \\\n+                            CILK_FRAME_EXCEPTION_PROBED | \\\n+                            CILK_FRAME_EXCEPTING | \\\n+                            CILK_FRAME_SF_PEDIGREE_UNSYNCHED | \\\n+                            CILK_FRAME_LAST | \\\n+                            CILK_FRAME_EXITING | \\\n+                            CILK_FRAME_SUSPENDED | \\\n+                            CILK_FRAME_UNWINDING | \\\n+                            CILK_FRAME_VERSION_MASK))\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/**\n+ * Call __cilkrts_enter_frame to initialize an ABI 0 frame descriptor.\n+ * Initialize the frame descriptor before spawn or detach.  A function that\n+ * conditionally does Cilk operations need not initialize the frame descriptor\n+ * in a code path that never uses it.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be initialized.\n+ */\n+CILK_ABI(void) __cilkrts_enter_frame(__cilkrts_stack_frame* sf);\n+\n+/**\n+ * Call __cilkrts_enter_frame to initialize an ABI 1 frame descriptor.\n+ * Initialize the frame descriptor before spawn or detach.  A function that\n+ * conditionally does Cilk operations need not initialize the frame descriptor\n+ * in a code path that never uses it.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be initialized.\n+ */\n+CILK_ABI(void) __cilkrts_enter_frame_1(__cilkrts_stack_frame* sf);\n+\n+/**\n+ * __cilkrts_enter_frame_fast is the same as __cilkrts_enter_frame, except it\n+ * assumes that the thread has already been bound to a worker.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be initialized.\n+ */\n+CILK_ABI(void) __cilkrts_enter_frame_fast(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * __cilkrts_enter_frame_fast_1 is the same as __cilkrts_enter_frame_1,\n+ * except it assumes that the thread has already been bound to a worker.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be initialized.\n+ */\n+CILK_ABI(void) __cilkrts_enter_frame_fast_1(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * Call leave_frame before leaving a frame, after sync.  This function\n+ * returns except in a spawn wrapper where the parent has been stolen.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be left.\n+ */\n+CILK_ABI(void) __cilkrts_leave_frame(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * Wait for any spawned children of this function to complete before\n+ * continuing.  This function will only return when the join counter\n+ * has gone to 0.  Other workers will re-enter the scheduling loop to\n+ * attempt to steal additional work.\n+ *\n+ * @param sf The __cilkrts_stack_frame that is to be synched.\n+ */\n+CILK_ABI(void) __cilkrts_sync(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * Called when an exception is escaping a spawn * wrapper.\n+ * The stack frame's except_data field is the C++ runtime\n+ * exception object.  If NULL (temporary workaround) the\n+ * currently caught exception should be rethrown.  If this\n+ * function returns normal exit functions must be called;\n+ * undo-detach will have been done.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the function that\n+ * is raising an exception.\n+ */\n+CILK_ABI_THROWS(void)\n+    __cilkrts_return_exception(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * Called to re-raise an exception.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the function that\n+ * is raising an exception.\n+ */\n+CILK_ABI_THROWS(void) __cilkrts_rethrow(__cilkrts_stack_frame *sf);\n+\n+/**\n+ * Called at the beginning of a spawning function to get the worker\n+ * that this function is running on.  This worker will be used to\n+ * initialize the __cilkrts_stack_frame.\n+ *\n+ * @return The __cilkrts_worker that the function is running on.\n+ * @return NULL if this thread is not yet bound to a worker.\n+ */\n+CILK_ABI(__cilkrts_worker_ptr) __cilkrts_get_tls_worker(void);\n+\n+/**\n+ * Similar to __cilkrts_get_tls_worker, but assumes that TLS has been\n+ * initialized.\n+ *\n+ * @return The __cilkrts_worker that the function is running on.\n+ * @return NULL if this thread is not yet bound to a worker.\n+ */\n+CILK_ABI(__cilkrts_worker_ptr) __cilkrts_get_tls_worker_fast(void);\n+\n+/**\n+ * Binds a thread to the runtime by associating a __cilkrts_worker with\n+ * it.  Called if __cilkrts_get_tls_worker returns NULL.  This function will\n+ * initialize the runtime the first time it is called.\n+ *\n+ * This function is versioned by the ABI version number.  The runtime\n+ * will export all previous versions.  This prevents using an application\n+ * built with a newer compiler against an old runtime.\n+ *\n+ * @return The __cilkrts_worker bound to the thread the function is running\n+ * on.\n+ */\n+CILK_ABI(__cilkrts_worker_ptr) __cilkrts_bind_thread_1(void);\n+\n+typedef uint32_t cilk32_t;  /**< 32-bit unsigned type for cilk_for loop indicies */\n+\n+typedef uint64_t cilk64_t;  /**< 64-bit unsigned type for cilk_for loop indicies */\n+\n+/**\n+ * Signature for the lambda function generated for the body of a cilk_for loop\n+ * which uses 32-bit indicies\n+ */\n+typedef void (*__cilk_abi_f32_t)(void *data, cilk32_t low, cilk32_t high);\n+\n+/**\n+ * Signature for the lambda function generated for the body of a cilk_for lop\n+ * which uses 64-bit indicies\n+ */\n+typedef void (*__cilk_abi_f64_t)(void *data, cilk64_t low, cilk64_t high);\n+\n+/**\n+ * @brief cilk_for implementation for 32-bit indexes.\n+ *\n+ * @param body The lambda function for the body of the cilk_for.  The lambda\n+ * function will be called to execute each grain of work.\n+ * @param data Data passed by the compiler into the lambda function.  Provides\n+ * access to data outside the cilk_for body.\n+ * @param count Number of steps in the loop.\n+ * @param grain This parameter allows the compiler to pass a value from a\n+ * \\#pragam(grainsize) statement to allow the user to control the grainsize.  If\n+ * there isn't a \\#pragma(grainsize) immediately preceeding cilk_for loop, Pass\n+ * 0 to specify that the runtime should calculate the grainsize using its own\n+ * hueristicts.\n+ */\n+CILK_ABI_THROWS(void) __cilkrts_cilk_for_32(__cilk_abi_f32_t body,\n+                                            void *data,\n+                                            cilk32_t count,\n+                                            int grain);\n+\n+/**\n+ * @brief cilk_for implementation for 64-bit indexes.\n+ *\n+ * @copydetails __cilkrts_cilk_for_32\n+ */\n+CILK_ABI_THROWS(void) __cilkrts_cilk_for_64(__cilk_abi_f64_t body,\n+                                            void *data,\n+                                            cilk64_t count,\n+                                            int grain);\n+\n+/**\n+ * @brief Allocate memory for variable length arrays. If the frame is\n+ * sync'd, the memory will be allocated on the stack, otherwise it will\n+ * be allocated from the heap.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the function allocating the\n+ * memory.\n+ * @param size The number of bytes requested.\n+ * @param distance_from_sp_to_alloca_area ?.\n+ * @param align Alignment required.  Always >= minimum stack alignment,\n+ * >= ptr_size, and always a power of 2.\n+ * @param needs_tag Non-zero if the pointer being returned needs to be\n+ * tagged\n+ *\n+ * @return The address of the memory block allocated.\n+ */\n+\n+CILK_ABI(__cilkrts_void_ptr)\n+__cilkrts_stack_alloc(__cilkrts_stack_frame *sf,\n+                      size_t size,\n+                      size_t distance_from_sp_to_alloca_area,\n+                      uint32_t align,\n+                      uint32_t needs_tag);\n+\n+/**\n+ * @brief Free memory allocated by _cilkrts_stack_alloc() for variable length\n+ * arrays.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the function allocating the\n+ * memory.\n+ * @param p Pointer to the memory block to be freed.\n+ * @param size The number of bytes requested.\n+ * @param distance_from_sp_to_alloca_area ?.\n+ * @param align Alignment required.  Always >= minimum stack alignment,\n+ * >= ptr_size, and always a power of 2.\n+ * @param know_from_stack Non-zero if the pointer is known to have been\n+ * allocated on the stack and has no tag.\n+ */\n+CILK_ABI(void)\n+__cilkrts_stack_free(__cilkrts_stack_frame *sf,\n+                     void *p,\n+                     size_t size,\n+                     size_t distance_from_sp_to_alloca_area,\n+                     uint32_t align,\n+                     uint32_t known_from_stack);\n+\n+/**\n+ * @brief System-dependent code to save floating point control information\n+ * to an ABI 1 or higher @c __cilkrts_stack_frame.  If possible (and necessary)\n+ * the code to save the floating point control information should be inlined.\n+ *\n+ * Note that this function does *not* save the current floating point\n+ * registers.  It saves the floating point control words that control\n+ * precision and rounding and stuff like that.\n+ *\n+ * This function will be a noop for architectures that don't have warts\n+ * like the floating point control words, or where the information is\n+ * already being saved by the setjmp.\n+ *\n+ * @param sf  @c __cilkrts_stack_frame for the frame we're saving the\n+ * floating point control information in.\n+ */\n+CILK_ABI(void)\n+__cilkrts_save_fp_ctrl_state(__cilkrts_stack_frame *sf);\n+\n+__CILKRTS_END_EXTERN_C\n+#endif /* include guard */"}, {"sha": "2386dd6bffa07eae4661f7a2164c4d66fef198bb", "filename": "libcilkrts/include/internal/cilk_fake.h", "status": "added", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,477 @@\n+/* cilk_fake.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2011-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/**\n+ * @file cilk_fake.h\n+ *\n+ * @brief Macros to simulate a compiled Cilk program.\n+ *\n+ * Used carefully, these macros can be used to create a Cilk program with a\n+ * non-Cilk compiler by manually inserting the code necessary for interacting\n+ * with the Cilk runtime library.  They are not intended to be pretty (you\n+ * wouldn't want to write a whole program using these macros), but they are\n+ * useful for experiments.  They also work well as an illustration of what the\n+ * compiler generates.\n+ *\n+ * Details of the mechanisms used in these macros are described in\n+ * design-notes/CilkPlusABI.docx\n+ *\n+ * Example 1: fib in C++\n+ * ---------------------\n+ *\n+ *  #include <internal/cilk_fake.h>\n+ *  \n+ *  int fib(int n)\n+ *  {\n+ *      CILK_FAKE_PROLOG();\n+ *  \n+ *      if (n < 2)\n+ *          return n;\n+ *  \n+ *      int a, b;\n+ *      CILK_FAKE_SPAWN_R(a, fib(n - 1));\n+ *      b = fib(n - 2);\n+ *      CILK_FAKE_SYNC();\n+ *  \n+ *      return a + b;\n+ *  }\n+ *  \n+ *\n+ * Example 2: fib in C\n+ * -------------------\n+ *\n+ *  #include <internal/cilk_fake.h>\n+ *  \n+ *  int fib(int n);\n+ *  \n+ *  void fib_spawn_helper(__cilkrts_stack_frame* parent_sf, int* a, int n)\n+ *  {\n+ *      CILK_FAKE_SPAWN_HELPER_PROLOG(*parent_sf);\n+ *      *a = fib(n - 1);\n+ *      CILK_FAKE_SPAWN_HELPER_EPILOG();\n+ *  }\n+ *  \n+ *  int fib(int n)\n+ *  {\n+ *      CILK_FAKE_PROLOG();\n+ *  \n+ *      if (n < 2)\n+ *          return n;\n+ *  \n+ *      int a, b;\n+ *      CILK_FAKE_CALL_SPAWN_HELPER(fib_spawn_helper(&__cilk_sf, &a, n));\n+ *      b = fib(n - 2);\n+ *      CILK_FAKE_SYNC();\n+ *  \n+ *      CILK_FAKE_EPILOG();\n+ *      return a + b;\n+ *  }\n+ */\n+\n+#ifndef INCLUDED_CILK_FAKE_DOT_H\n+#define INCLUDED_CILK_FAKE_DOT_H\n+\n+// This header implements ABI version 1.  If __CILKRTS_ABI_VERSION is already\n+// defined but is less than 1, then the data structures in <internal/abi.h>\n+// will not match the expectations of facilities in this header.  Therefore,\n+// for successful compilation, __CILKRTS_ABI_VERSION must either be not\n+// defined, or defined to be 1 or greater.\n+#ifndef __CILKRTS_ABI_VERSION\n+    // ABI version was not specified.  Set it to 1.\n+#   define __CILKRTS_ABI_VERSION 1\n+#elif __CILKRTS_ABI_VERSION < 1\n+    // ABI version was specified but was too old.  Fail compilation.\n+#   error cilk_fake.h requirs an ABI version of 1 or greater\n+#endif\n+\n+#include <internal/abi.h>\n+\n+// alloca is defined in malloc.h on Windows, alloca.h on Linux\n+#ifndef _MSC_VER\n+#include <alloca.h>\n+#else\n+#include <malloc.h>\n+// Define offsetof\n+#include <stddef.h>\n+#endif\n+\n+// Allows use of a different version that the one defined in abi.h\n+#define CILK_FAKE_VERSION_FLAG (__CILKRTS_ABI_VERSION << 24)\n+    \n+/* Initialize frame. To be called when worker is known */\n+__CILKRTS_INLINE void __cilk_fake_enter_frame_fast(__cilkrts_stack_frame *sf,\n+                                                   __cilkrts_worker      *w)\n+{\n+    sf->call_parent = w->current_stack_frame;\n+    sf->worker      = w;\n+    sf->flags       = CILK_FAKE_VERSION_FLAG;\n+    w->current_stack_frame = sf;\n+}\n+\n+/* Initialize frame. To be called when worker is not known */\n+__CILKRTS_INLINE void __cilk_fake_enter_frame(__cilkrts_stack_frame *sf)\n+{\n+    __cilkrts_worker* w = __cilkrts_get_tls_worker();\n+    uint32_t          last_flag = 0;\n+    if (! w) {\n+        w = __cilkrts_bind_thread_1();\n+        last_flag = CILK_FRAME_LAST;\n+    }\n+    __cilk_fake_enter_frame_fast(sf, w);\n+    sf->flags |= last_flag;\n+}\n+\n+/* Initialize frame. To be called within the spawn helper */\n+__CILKRTS_INLINE void __cilk_fake_helper_enter_frame(\n+    __cilkrts_stack_frame *sf,\n+    __cilkrts_stack_frame *parent_sf)\n+{\n+    sf->worker      = 0;\n+    sf->call_parent = parent_sf;\n+}\n+\n+/* Called from the spawn helper to push the parent continuation on the task\n+ * deque so that it can be stolen.\n+ */\n+__CILKRTS_INLINE void __cilk_fake_detach(__cilkrts_stack_frame *sf)\n+{\n+    /* Initialize spawn helper frame.\n+     * call_parent was saved in __cilk_fake_helper_enter_frame */\n+    __cilkrts_stack_frame *parent = sf->call_parent;\n+    __cilkrts_worker *w = parent->worker;\n+    __cilk_fake_enter_frame_fast(sf, w);\n+\n+    /* Append a node to the pedigree */\n+    sf->spawn_helper_pedigree = w->pedigree;\n+    parent->parent_pedigree = w->pedigree;\n+    w->pedigree.rank = 0;\n+    w->pedigree.parent = &sf->spawn_helper_pedigree;\n+\n+    /* Push parent onto the task deque */\n+    __cilkrts_stack_frame *volatile *tail = w->tail;\n+    *tail++ = sf->call_parent;\n+    /* The stores must be separated by a store fence (noop on x86)\n+     * or the second store is a release (st8.rel on Itanium)   */\n+    w->tail = tail;\n+    sf->flags |= CILK_FRAME_DETACHED;\n+}\n+\n+/* This variable is used in CILK_FAKE_FORCE_FRAME_PTR(), below */\n+static int __cilk_fake_dummy = 8;\n+\n+/* The following macro is used to force the compiler into generating a frame\n+ * pointer.  We never change the value of __cilk_fake_dummy, so the alloca()\n+ * is never called, but we need the 'if' statement and the __cilk_fake_dummy\n+ * variable so that the compiler does not attempt to optimize it away.\n+ */\n+#define CILK_FAKE_FORCE_FRAME_PTR(sf) do {                              \\\n+    if (__builtin_expect(1 & __cilk_fake_dummy, 0))                     \\\n+        (sf).worker = (__cilkrts_worker*) alloca(__cilk_fake_dummy);    \\\n+} while (0)\n+\n+#ifndef CILK_FAKE_NO_SHRINKWRAP\n+    /* \"shrink-wrap\" optimization enabled.  Do not initialize frame on entry,\n+     * except to clear worker pointer.  Instead, defer initialization until\n+     * the first spawn.\n+     */\n+#   define CILK_FAKE_INITIAL_ENTER_FRAME(sf) ((void) ((sf).worker = 0))\n+#   define CILK_FAKE_DEFERRED_ENTER_FRAME(sf) do {            \\\n+        if (! (sf).worker) __cilk_fake_enter_frame(&(sf));    \\\n+    } while (0)\n+#else\n+    /* \"shrink-wrap\" optimization disabled.  Initialize frame immediately on\n+     * entry.  Do not initialize frame on spawn.\n+     */\n+#   define CILK_FAKE_INITIAL_ENTER_FRAME(sf) \\\n+        __cilk_fake_enter_frame(&(sf))\n+#   define CILK_FAKE_DEFERRED_ENTER_FRAME(sf) ((void) &(sf))\n+#endif\n+\n+/* Prologue of a spawning function.  Declares and initializes the stack\n+ * frame.\n+ */\n+#define CILK_FAKE_PROLOG()                                           \\\n+    __cilk_fake_stack_frame __cilk_sf;                               \\\n+    CILK_FAKE_FORCE_FRAME_PTR(__cilk_sf);                            \\\n+    CILK_FAKE_INITIAL_ENTER_FRAME(__cilk_sf)\n+\n+/* Prologue of a spawning function where the current worker is already known.\n+ * Declares and initializes the stack frame without looking up the worker from\n+ * TLS.\n+ */\n+#define CILK_FAKE_PROLOG_FAST(w)                                     \\\n+    __cilk_fake_stack_frame __cilk_sf;                               \\\n+    CILK_FAKE_FORCE_FRAME_PTR(__cilk_sf);                            \\\n+    __cilk_fake_enter_frame_fast(&__cilk_sf, (w))\n+\n+/* Simulate a cilk_sync */\n+#define CILK_FAKE_SYNC() CILK_FAKE_SYNC_IMP(__cilk_sf)\n+\n+/* Epilog at the end of a spawning function.  Does a sync and calls the\n+ * runtime for leaving the frame.\n+ */\n+#ifdef __cplusplus\n+    // Epilogue is run automatically by __cilk_fake_stack_frame destructor.\n+#   define CILK_FAKE_EPILOG() ((void) __cilk_sf)\n+#else\n+#   define CILK_FAKE_EPILOG() CILK_FAKE_CLEANUP_FRAME(__cilk_sf)\n+#endif // C\n+\n+/* Implementation of spawning function epilog.  See CILK_FAKE_EPILOG macro and\n+ * __cilk_fake_stack_frame destructor body.\n+ */\n+#define CILK_FAKE_CLEANUP_FRAME(sf) do {                     \\\n+    if (! (sf).worker) break;                                \\\n+    CILK_FAKE_SYNC_IMP(sf);                                  \\\n+    CILK_FAKE_POP_FRAME(sf);                                 \\\n+    if ((sf).flags != CILK_FAKE_VERSION_FLAG)                \\\n+        __cilkrts_leave_frame(&(sf));                        \\\n+} while (0)\n+\n+/* Implementation of CILK_FAKE_SYNC with sf argument */\n+#define CILK_FAKE_SYNC_IMP(sf) do {                                       \\\n+    if (__builtin_expect((sf).flags & CILK_FRAME_UNSYNCHED, 0))      {    \\\n+        (sf).parent_pedigree = (sf).worker->pedigree;                     \\\n+        CILK_FAKE_SAVE_FP(sf);                                            \\\n+        if (! CILK_SETJMP((sf).ctx))                                      \\\n+            __cilkrts_sync(&(sf));                                        \\\n+    }                                                                     \\\n+    ++(sf).worker->pedigree.rank;                                         \\\n+} while (0)\n+\n+/* Save the floating-point control registers.\n+ * The definition of CILK_FAKE_SAVE_FP is compiler specific (and\n+ * architecture specific on Windows)\n+ */\n+#ifdef _MSC_VER\n+#   define MXCSR_OFFSET offsetof(struct __cilkrts_stack_frame, mxcsr)\n+#   define FPCSR_OFFSET offsetof(struct __cilkrts_stack_frame, fpcsr)\n+#   if defined(_M_IX86)\n+/* Windows x86 */\n+#       define CILK_FAKE_SAVE_FP(sf) do {                               \\\n+            __asm                                                       \\\n+            {                                                           \\\n+                mov eax, sf                                             \\\n+                stmxcsr [eax+MXCSR_OFFSET]                              \\\n+                fnstcw  [eax+FPCSR_OFFSET]                              \\\n+            }                                                           \\\n+        } while (0)\n+#   elif defined(_M_X64)\n+/* Windows Intel64 - Not needed - saved by setjmp call */\n+#       define CILK_FAKE_SAVE_FP(sf) ((void) sf)\n+#   else\n+#       error \"Unknown architecture\"\n+#   endif /* Microsoft architecture specifics */\n+#else\n+/* Non-Windows */\n+#   define CILK_FAKE_SAVE_FP(sf) do {                                   \\\n+        __asm__ ( \"stmxcsr %0\\n\\t\"                                      \\\n+                  \"fnstcw %1\" : : \"m\" ((sf).mxcsr), \"m\" ((sf).fpcsr));  \\\n+    } while (0)\n+#endif\n+\n+/* Call the spawn helper as part of a fake spawn */\n+#define CILK_FAKE_CALL_SPAWN_HELPER(helper) do {                    \\\n+    CILK_FAKE_DEFERRED_ENTER_FRAME(__cilk_sf);                      \\\n+    CILK_FAKE_SAVE_FP(__cilk_sf);                                   \\\n+    if (__builtin_expect(! CILK_SETJMP(__cilk_sf.ctx), 1)) {        \\\n+        helper;                                                     \\\n+    }                                                               \\\n+} while (0)\n+\n+/* Body of a spawn helper function.  In addition to the worker and the\n+ * expression to spawn, pass it any number of statements to be executed before\n+ * detaching.\n+ */\n+#define CILK_FAKE_SPAWN_HELPER_BODY(parent_sf, expr, ...)                   \\\n+    CILK_FAKE_SPAWN_HELPER_PROLOG(parent_sf);                               \\\n+    __VA_ARGS__;                                                            \\\n+    __cilk_fake_detach(&__cilk_sf);                                         \\\n+    expr;                                                                   \\\n+    CILK_FAKE_SPAWN_HELPER_EPILOG()\n+\n+/* Prolog for a spawn helper function */\n+#define CILK_FAKE_SPAWN_HELPER_PROLOG(parent_sf)                     \\\n+    __cilk_fake_spawn_helper_stack_frame __cilk_sf;                  \\\n+    __cilk_fake_helper_enter_frame(&__cilk_sf, &(parent_sf))\n+\n+/* Implementation of spawn helper epilog.  See CILK_FAKE_SPAWN_HELPER_EPILOG\n+ * and the __cilk_fake_spawn_helper_frame destructor.\n+ */\n+#define CILK_FAKE_SPAWN_HELPER_CLEANUP_FRAME(sf) do {                \\\n+    if (! (sf).worker) break;                                        \\\n+    CILK_FAKE_POP_FRAME(sf);                                         \\\n+    __cilkrts_leave_frame(&(sf));                                    \\\n+} while (0)\n+\n+/* Epilog to execute at the end of a spawn helper */\n+#ifdef __cplusplus\n+    // Epilog handled by __cilk_fake_spawn_helper_stack_frame destructor\n+#   define CILK_FAKE_SPAWN_HELPER_EPILOG() ((void) __cilk_sf)\n+#else\n+#   define CILK_FAKE_SPAWN_HELPER_EPILOG() \\\n+        CILK_FAKE_SPAWN_HELPER_CLEANUP_FRAME(__cilk_sf)\n+#endif\n+\n+/* Pop the current frame off of the call chain */\n+#define CILK_FAKE_POP_FRAME(sf) do {                       \\\n+    (sf).worker->current_stack_frame = (sf).call_parent;   \\\n+    (sf).call_parent = 0;                                  \\\n+} while (0)\n+\n+#ifdef _WIN32\n+/* define macros for synching functions before allowing them to propagate. */\n+#   define CILK_FAKE_EXCEPT_BEGIN                              \\\n+    if (0 == CILK_SETJMP(__cilk_sf.except_ctx)) {\n+\n+#   define CILK_FAKE_EXCEPT_END                                               \\\n+    } else {                                                                  \\\n+        assert((__cilk_sf.flags & (CILK_FRAME_UNSYNCHED|CILK_FRAME_EXCEPTING))\\\n+                == CILK_FRAME_EXCEPTING);                                     \\\n+        __cilkrts_rethrow(&__cilk_sf);                                        \\\n+        exit(0);                                                              \\\n+    }\n+#else\n+#   define CILK_EXCEPT_BEGIN {\n+#   define CILK_EXCEPT_END   }\n+#endif\n+\n+#ifdef __cplusplus\n+// The following definitions depend on C++ features.\n+\n+// Wrap a functor (probably a lambda), so that a call to it cannot be\n+// inlined.\n+template <typename F>\n+class __cilk_fake_noinline_wrapper\n+{\n+    F&& m_fn;\n+public:\n+    __cilk_fake_noinline_wrapper(F&& fn) : m_fn(static_cast<F&&>(fn)) { }\n+\n+#ifdef _WIN32\n+    __declspec(noinline) void operator()(__cilkrts_stack_frame *sf);\n+#else\n+    void operator()(__cilkrts_stack_frame *sf) __attribute__((noinline));\n+#endif\n+\n+};\n+\n+template <typename F>\n+void __cilk_fake_noinline_wrapper<F>::operator()(__cilkrts_stack_frame *sf)\n+{\n+    m_fn(sf);\n+}\n+\n+template <typename F>\n+inline\n+__cilk_fake_noinline_wrapper<F> __cilk_fake_make_noinline_wrapper(F&& fn)\n+{\n+    return __cilk_fake_noinline_wrapper<F>(static_cast<F&&>(fn));\n+}\n+\n+// Simulate \"_Cilk_spawn expr\", where expr must be a function call.\n+//\n+// Note: this macro does not correctly construct function arguments.\n+// According to the ABI specification, function arguments should be evaluated\n+// before the detach and destroyed after the detach.  This macro both\n+// evaluates and destroys them after the detach.  This means that if any part\n+// of the function argument expression depends on a value that is modified in\n+// the continuation of the spawn, race will occur between the continuation and\n+// the argument evaluation.\n+//\n+// To work around this problem, this macro accepts an arbitrary list of\n+// declarations and statements (separated by semicolons) that are evaluated\n+// before the detach.  Thus, to simulate:\n+//\n+//    _Cilk_spawn f(expr);\n+//\n+// one would write:\n+//\n+//    CILK_FAKE_SPAWN(f(arg), auto arg = expr);\n+//\n+// Despite appearing in the reverse order, the 'arg' variable is created and\n+// initialized before the detach and the call to f(arg) occurs after the\n+// detach.\n+#define CILK_FAKE_SPAWN(expr, ...)                                  \\\n+    CILK_FAKE_CALL_SPAWN_HELPER(                                    \\\n+        CILK_FAKE_SPAWN_HELPER(expr, __VA_ARGS__)(&__cilk_sf))\n+\n+// Simulate \"ret = cilk_spawn expr\".  See CILK_FAKE_SPAWN for constraints.\n+#define CILK_FAKE_SPAWN_R(ret, expr, ...) \\\n+    CILK_FAKE_SPAWN(((ret) = (expr)), __VA_ARGS__)\n+\n+// Create a spawn helper as a C++11 lambda function.  In addition to the\n+// expression to spawn, this macro takes a any number of statements to be\n+// executed before detaching.\n+#define CILK_FAKE_SPAWN_HELPER(expr, ...)                                     \\\n+    __cilk_fake_make_noinline_wrapper([&](__cilkrts_stack_frame *parent_sf) { \\\n+        CILK_FAKE_SPAWN_HELPER_BODY(*parent_sf, expr, __VA_ARGS__);           \\\n+    })\n+\n+// C++ version of a __cilkrts_stack_frame for a spawning function.\n+// This struct is identical to __cilkrts_stack_frame except that the\n+// destructor automatically does frame cleanup.\n+struct __cilk_fake_stack_frame : __cilkrts_stack_frame\n+{\n+    // Extension of __cilkrts_stack_frame with constructor and destructor\n+    __cilk_fake_stack_frame() { }\n+    __forceinline ~__cilk_fake_stack_frame() {\n+        CILK_FAKE_CLEANUP_FRAME(*this);\n+    }\n+};\n+\n+// C++ version of a __cilkrts_stack_frame for a spawn helper.\n+// This struct is identical to __cilkrts_stack_frame except that the\n+// destructor automatically does frame cleanup.\n+struct __cilk_fake_spawn_helper_stack_frame : __cilkrts_stack_frame\n+{\n+    // Extension of __cilkrts_stack_frame with constructor and destructor\n+    __cilk_fake_spawn_helper_stack_frame() { worker = 0; }\n+    __forceinline ~__cilk_fake_spawn_helper_stack_frame() {\n+        CILK_FAKE_SPAWN_HELPER_CLEANUP_FRAME(*this);            \n+    }\n+};\n+#else\n+// For C, __cilk_fake_stack_frame and __cilk_fake_spawn_helper_stack_frame are\n+// identical to __cilkrts_stack_frame.  Frame cleanup must be performed\n+// excplicitly (in CILK_FAKE_EPILOG and CILK_FAKE_SPAWN_HELPER_EPILOG)\n+typedef __cilkrts_stack_frame __cilk_fake_stack_frame;\n+typedef __cilkrts_stack_frame __cilk_fake_spawn_helper_stack_frame;\n+#endif\n+\n+#endif // ! defined(INCLUDED_CILK_FAKE_DOT_H)"}, {"sha": "f628338f7d227c05a0a67826700df17dbfdbf18d", "filename": "libcilkrts/include/internal/cilk_version.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,47 @@\n+// cilk_version.h\n+//\n+//  @copyright\n+//  Copyright (C) 2009-2013, Intel Corporation\n+//  All rights reserved.\n+//  \n+//  @copyright\n+//  Redistribution and use in source and binary forms, with or without\n+//  modification, are permitted provided that the following conditions\n+//  are met:\n+//  \n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in\n+//      the documentation and/or other materials provided with the\n+//      distribution.\n+//    * Neither the name of Intel Corporation nor the names of its\n+//      contributors may be used to endorse or promote products derived\n+//      from this software without specific prior written permission.\n+//  \n+//  @copyright\n+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+//  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+//  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+//  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+//  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+//  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+//  POSSIBILITY OF SUCH DAMAGE.\n+// DO NOT EDIT THIS FILE!\n+//\n+// It was automatically generated by cilkrts/include/internal/Makefile\n+\n+#define VERSION_MAJOR 2\n+#define VERSION_MINOR 0\n+#define VERSION_BUILD 3902\n+#define VERSION_REV 0\n+#define VERSION_STRING \"2,0,3902,0\"\n+#define VERSION_HASH \"b4e38f4f7e3e\"\n+#define VERSION_BRANCH \"v14.0\"\n+#define TBB_REV_NUMBER \"\"\n+#define VERSION_YEAR \"2013\""}, {"sha": "886f49f9f830caeaed28c90e0e349dfbb9a098d5", "filename": "libcilkrts/include/internal/metacall.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fmetacall.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Fmetacall.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fmetacall.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,99 @@\n+// -*- C++ -*-\n+\n+/*\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ ******************************************************************************\n+ *\n+ * metacall.h\n+ *\n+ * This is an internal header file defining part of the metacall\n+ * interface used by Cilkscreen.  It is not a stable API and is\n+ * subject to change without notice.\n+ */\n+\n+// Provides the enum of metacall kinds.  This is used by Cilkscreen and the\n+// runtime, and will probably be used by any future ptools.\n+\n+#pragma once\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+enum\n+{\n+    // Notify Cilkscreen to stop/start instrumenting code\n+    HYPER_DISABLE_INSTRUMENTATION = 0,\n+    HYPER_ENABLE_INSTRUMENTATION = 1,\n+\n+    // Write 0 in *(char *)arg if the p-tool is sequential.  The Cilk runtime\n+    // system invokes this metacall to know whether to spawn worker threads.\n+    HYPER_ZERO_IF_SEQUENTIAL_PTOOL = 2,\n+\n+    // Write 0 in *(char *)arg if the runtime must force reducers to\n+    // call the reduce() method even if no actual stealing occurs.\n+    HYPER_ZERO_IF_FORCE_REDUCE = 3,\n+\n+    // Inform cilkscreen about the current stack pointer.\n+    HYPER_ESTABLISH_C_STACK = 4,\n+\n+    // Inform Cilkscreen about the current worker\n+    HYPER_ESTABLISH_WORKER = 5,\n+\n+    // Tell tools to ignore a block of memory.  Parameter is a 2 element\n+    // array: void *block[2] = {_begin, _end};  _end is 1 beyond the end\n+    // of the block to be ignored.  Essentially, if p is a pointer to an\n+    // array, _begin = &p[0], _end = &p[max]\n+    HYPER_IGNORE_MEMORY_BLOCK = 6\n+\n+    // If you add metacalls here, remember to update BOTH workspan.cpp AND\n+    // cilkscreen-common.cpp!\n+};\n+\n+typedef struct\n+{\n+    unsigned int tool;  // Specifies tool metacall is for\n+                        // (eg. system=0, cilkscreen=1, cilkview=2).\n+                        // All tools should understand system codes.\n+                        // Tools should ignore all other codes, except\n+                        // their own.\n+\n+    unsigned int code;  // Tool-specific code specifies what to do and how to\n+                        // interpret data\n+\n+    void        *data;\n+} metacall_data_t;\n+\n+#define METACALL_TOOL_SYSTEM 0\n+\n+///////////////////////////////////////////////////////////////////////////////"}, {"sha": "f65ad6d57d0c6e3fd1115714ef7959703c4996e5", "filename": "libcilkrts/include/internal/rev.mk", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Frev.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Finclude%2Finternal%2Frev.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Frev.mk?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,41 @@\n+#########################################################################\n+#\n+#  @copyright\n+#  Copyright (C) 2011-2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+###########################################################################\n+\n+# DO NOT EDIT THIS FILE!\n+#\n+# It was automatically generated by cilkrts/include/internal/Makefile\n+\n+CILK_REVISION = 3902"}, {"sha": "76f3f4ee38e2ffdbdb0bc09a875fec36d4bcbfb9", "filename": "libcilkrts/mk/cilk-version.mk", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fmk%2Fcilk-version.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fmk%2Fcilk-version.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fmk%2Fcilk-version.mk?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,61 @@\n+#########################################################################\n+#\n+#  @copyright\n+#  Copyright (C) 2009-2013, Intel Corporation\n+#  All rights reserved.\n+#  \n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#  \n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#  \n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+###########################################################################\n+# cilk-version.mk\n+#\n+# The one place we look up information from the code management system\n+#\n+# Note that the build number is *only* valid on the build machines\n+\n+ifeq ($(wildcard $(TOP)/../.hg),)\n+  # If this is the open source release, there is no Mercurial repository,\n+  # so set some reasonable defaults.\n+  CILK_VERSION_MAJOR := 2\n+  CILK_VERSION_MINOR := 0\n+  CILK_VERSION_BUILD := 1\n+  CILK_VERSION_REV   := 0\n+\n+  CILK_VERSION_HASH  := 000000000000\n+  CILK_VERSION_BRANCH := oss\n+else\n+  CILK_VERSION_MAJOR := 2\n+  CILK_VERSION_MINOR := 0\n+  CILK_VERSION_BUILD := $(firstword $(subst +, ,$(shell hg id --num)))\n+  CILK_VERSION_REV   := 0\n+\n+  CILK_VERSION_HASH := $(firstword $(subst +, ,$(shell hg id --id)))\n+  CILK_VERSION_BRANCH := $(shell hg id --branch)\n+endif\n+"}, {"sha": "79b5d876f3342348106cb9dfba06c79a47709649", "filename": "libcilkrts/runtime/acknowledgements.dox", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Facknowledgements.dox", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Facknowledgements.dox", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Facknowledgements.dox?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,51 @@\n+/* acknowledgements.dox\r\n+ *\r\n+ *************************************************************************\r\n+ *\r\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\r\n+\r\n+/*\r\n+ * This file contains acknowledgements of community contributions to the\r\n+ * Cilk Plus runtime.\r\n+ */\r\n+\r\n+/**\r\n+ * @mainpage\r\n+ *\r\n+ * @section Acknowledgements Acknowledgements\r\n+ *\r\n+ * Modifications to build the Cilk Plus runtime for VxWorks provided by\r\n+ * Brian Kuhl of Wind River.\r\n+ */\r"}, {"sha": "dbdf1fd32163d41f4660d6d946d013fdbc37a150", "filename": "libcilkrts/runtime/bug.cpp", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fbug.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fbug.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fbug.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,139 @@\n+/* bug.cpp                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+#include \"bug.h\"\n+\n+#include <exception>\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#ifdef _WIN32\n+#   include \"windows-clean.h\"\n+#   include \"internal/abi.h\"\n+#   include \"cilktools/cilkscreen.h\"\n+#   include <crtdbg.h>\n+#endif\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+COMMON_PORTABLE const char *const __cilkrts_assertion_failed =\n+    \"%s:%d: cilk assertion failed: %s\\n\";\n+\n+COMMON_PORTABLE void __cilkrts_bug(const char *fmt,...) cilk_nothrow\n+{\n+#if defined (_WIN32) && defined(_DEBUG)\n+    _CRTIMP void __cdecl _wassert(__in_z const wchar_t * _Message,\n+                                  __in_z const wchar_t *_File,\n+                                  __in unsigned _Line);\n+    char message[256];\n+    wchar_t wmessage[256];\n+    va_list l;\n+    va_start(l, fmt);\n+    _vsnprintf_s(message, 256, _TRUNCATE, fmt, l);\n+    va_end(l);\n+    _snwprintf_s(wmessage, 256, _TRUNCATE, _CRT_WIDE(\"%S\"),\n+                 message); /* widen */\n+\n+    // Force asserts to go to stderr and the debugger.  This isn't polite, but\n+    // we're about to kill the app anyway and it will prevent our tests from\n+    // hanging\n+    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE| _CRTDBG_MODE_DEBUG);\n+    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n+\n+    _wassert(wmessage, _CRT_WIDE(__FILE__), __LINE__);\n+\n+    // If there's a debugger attached, give it a chance to look at the failure\n+    if (IsDebuggerPresent())\n+        DebugBreak();\n+\n+    abort();\n+/*    __asm int 3 */\n+#else\n+    /* To reduce user confusion, write all user-generated output\n+       before the system-generated error message. */\n+    va_list l;\n+    fflush(NULL);\n+    va_start(l, fmt);\n+    vfprintf(stderr, fmt, l);\n+    va_end(l);\n+    fflush(stderr);\n+\n+#ifndef _WIN32\n+    abort();\n+#endif\n+\n+#endif\n+\n+    exit(1);\n+}\n+\n+COMMON_PORTABLE void cilkbug_assert_no_uncaught_exception(void)\n+{\n+    bool uncaught = std::uncaught_exception();\n+    CILK_ASSERT(!uncaught);\n+}\n+\n+COMMON_SYSDEP void abort_because_rts_is_corrupted(void)\n+{\n+    __cilkrts_bug(\"The Cilk Plus runtime system detected a corruption \"\n+                  \"in its data structures.  This is most likely caused \"\n+                  \"by an application bug.  Aborting execution.\\n\");\n+}\n+\n+#ifdef WIN32\n+COMMON_SYSDEP void __cilkrts_dbgprintf(const char *fmt,...)\n+{\n+    char message[2048];\n+    va_list l;\n+\n+    // Cilkscreen shouldn't watch this\n+    __cilkscreen_disable_checking();\n+\n+    va_start(l, fmt);\n+    _vsnprintf_s(message, 2048, _TRUNCATE, fmt, l);\n+    va_end(l);\n+    OutputDebugStringA (message);\n+\n+    // Re-enable Cilkscreen\n+    __cilkscreen_enable_checking();\n+}\n+#endif\n+\n+__CILKRTS_END_EXTERN_C\n+\n+/* End bug.cpp */"}, {"sha": "bb18913787de704ce722d2c77f23e5083168b318", "filename": "libcilkrts/runtime/bug.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fbug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fbug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fbug.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,141 @@\n+/* bug.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/**\n+ * @file bug.h\n+ *\n+ * @brief Support for reporting bugs and debugging.\n+ */\n+\n+#ifndef INCLUDED_BUG_DOT_H\n+#define INCLUDED_BUG_DOT_H\n+\n+#include \"rts-common.h\"\n+#include <cilk/common.h>\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/**\n+ * Flush all output, write error message to stderr and abort the execution.\n+ * On Windows the error is also written to the debugger.\n+ *\n+ * @param fmt printf-style format string.  Any remaining parameters will be\n+ * be interpreted based on the format string text.\n+ */\n+COMMON_PORTABLE NORETURN __cilkrts_bug(const char *fmt,...) cilk_nothrow;\n+\n+#ifndef CILK_ASSERT\n+\n+/** Standard text for failed assertion */\n+COMMON_PORTABLE extern const char *const __cilkrts_assertion_failed;\n+\n+/**\n+ * Macro to assert an invariant that must be true.  If the statement evalutes\n+ * to false, __cilkrts_bug will be called to report the failure and terminate\n+ * the application.\n+ */\n+#define CILK_ASSERT(ex)                                                 \\\n+    (__builtin_expect((ex) != 0, 1) ? (void)0 :                         \\\n+     __cilkrts_bug(__cilkrts_assertion_failed, __FILE__, __LINE__,  #ex))\n+\n+#define CILK_ASSERT_MSG(ex, msg)                                        \\\n+    (__builtin_expect((ex) != 0, 1) ? (void)0 :                         \\\n+     __cilkrts_bug(__cilkrts_assertion_failed, __FILE__, __LINE__,      \\\n+                   #ex \"\\n    \" msg))\n+#endif  // CILK_ASSERT\n+\n+/**\n+ * Assert that there is no uncaught exception.\n+ *\n+ * Not valid on Windows or Android.\n+ *\n+ * On Android, calling std::uncaught_exception with the stlport library causes\n+ * a seg fault.  Since we're not supporting exceptions there at this point,\n+ * just don't do the check.  It works with the GNU STL library, but that's\n+ * GPL V3 licensed.\n+ */\n+COMMON_PORTABLE void cilkbug_assert_no_uncaught_exception(void);\n+#if defined(_WIN32) || defined(ANDROID)\n+#  define CILKBUG_ASSERT_NO_UNCAUGHT_EXCEPTION()\n+#else\n+#  define CILKBUG_ASSERT_NO_UNCAUGHT_EXCEPTION() \\\n+    cilkbug_assert_no_uncaught_exception()\n+#endif\n+\n+\n+/**\n+ * Call __cilkrts_bug with a standard message that the runtime state is\n+ * corrupted and the application is being terminated.\n+ */\n+COMMON_SYSDEP void abort_because_rts_is_corrupted(void);\n+\n+// Debugging aids\n+#ifndef _DEBUG\n+#       define DBGPRINTF(_fmt, ...)\n+#elif defined(_WIN32)\n+\n+/**\n+ * Write debugging output.  On windows this is written to the debugger.\n+ *\n+ * @param fmt printf-style format string.  Any remaining parameters will be\n+ * be interpreted based on the format string text.\n+ */\n+COMMON_SYSDEP void __cilkrts_dbgprintf(const char *fmt,...) cilk_nothrow;\n+\n+/**\n+ * Macro to write debugging output which will be elided if this is not a\n+ * debug build.  The macro is currently always elided on non-Windows builds.\n+ *\n+ * @param _fmt printf-style format string.  Any remaining parameters will be\n+ * be interpreted based on the format string text.\n+ */\n+#       define DBGPRINTF(_fmt, ...) __cilkrts_dbgprintf(_fmt, __VA_ARGS__)\n+\n+#else /* if _DEBUG && !_WIN32 */\n+    /* Non-Windows debug logging.  Someday we should make GetCurrentFiber()\n+     * and GetWorkerFiber() do something.\n+     */\n+#   include <stdio.h>\n+    __CILKRTS_INLINE void* GetCurrentFiber() { return 0; }\n+    __CILKRTS_INLINE void* GetWorkerFiber(__cilkrts_worker* w) { return 0; }\n+#       define DBGPRINTF(_fmt, ...) fprintf(stderr, _fmt, __VA_ARGS__)\n+#endif  // _DEBUG\n+\n+__CILKRTS_END_EXTERN_C\n+\n+#endif // ! defined(INCLUDED_BUG_DOT_H)"}, {"sha": "52615e93f4345bf636159e054ec671c0fd4cc933", "filename": "libcilkrts/runtime/c_reducers.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fc_reducers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fc_reducers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fc_reducers.c?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,57 @@\n+/* c_reducers.c                  -*-C-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2010-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+\n+/* Implementation of C reducers */\n+\n+// Disable warning about integer conversions losing significant bits.\n+// The code is correct as is.\n+#ifdef __INTEL_COMPILER\n+#pragma warning(disable:2259)\n+#endif\n+\n+#define CILK_C_DEFINE_REDUCERS\n+\n+#include <cilk/reducer_opadd.h>\n+#include <cilk/reducer_opand.h>\n+#include <cilk/reducer_opmul.h>\n+#include <cilk/reducer_opor.h>\n+#include <cilk/reducer_opxor.h>\n+#include <cilk/reducer_min_max.h>\n+\n+/* End reducer_opadd.c */"}, {"sha": "4fa6dcec82a400f9465b24b6f716b26f120aea56", "filename": "libcilkrts/runtime/cilk-abi-cilk-for.cpp", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,406 @@\n+/* cilk-abi-cilk-for.cpp                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2011, 2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+\n+/* Implementation of cilk_for ABI.\n+ *\n+ * This file must be C++, not C, in order to handle C++ exceptions correctly\n+ * from within the body of the cilk_for loop\n+ */\n+\n+#include \"internal/abi.h\"\n+#include \"metacall_impl.h\"\n+#include \"global_state.h\"\n+\n+// Icky macros to determine if we're compiled with optimization.  Based on\n+// the declaration of __CILKRTS_ASSERT in common.h\n+#if defined(_WIN32)\n+# if defined (_DEBUG)\n+#   define CILKRTS_OPTIMIZED 0    // Assumes /MDd is always used with /Od\n+# else\n+#   define CILKRTS_OPTIMIZED 1\n+# endif // defined(_DEBUG)\n+#else\n+# if defined(__OPTIMIZE__)\n+#   define CILKRTS_OPTIMIZED 1\n+# else\n+#   define CILKRTS_OPTIMIZED 0\n+# endif\n+#endif\n+\n+template <typename count_t>\n+static inline int grainsize(int req, count_t count)\n+{\n+    // A positive requested grain size comes from the user.  A very high grain\n+    // size risks losing parallelism, but the user told us what they want for\n+    // grainsize.  Who are we to argue?\n+    if (req > 0)\n+        return req;\n+\n+    // At present, a negative requested grain size is treated the same way as\n+    // a zero grain size, i.e., the runtime computes the actual grainsize\n+    // using a hueristic.  In the future, the compiler may give us additional\n+    // information about the size of the cilk_for body by passing a negative\n+    // grain size.\n+\n+    // Avoid generating a zero grainsize, even for empty loops.\n+    if (count < 1)\n+        return 1;\n+\n+    global_state_t* g = cilkg_get_global_state();\n+    if (g->under_ptool)\n+    {\n+        // Grainsize = 1, when running under PIN, and when the grainsize has\n+        // not explicitly been set by the user.\n+        return 1;\n+    }\n+    else\n+    {\n+        // Divide loop count by 8 times the worker count and round up.\n+        const int Px8 = g->P * 8;\n+        count_t n = (count + Px8 - 1) / Px8;\n+\n+        // 2K should be enough to amortize the cost of the cilk_for. Any\n+        // larger grainsize risks losing parallelism.\n+        if (n > 2048)\n+            return 2048;\n+        return (int) n;  // n <= 2048, so no loss of precision on cast to int\n+    }\n+}\n+\n+/*\n+ * call_cilk_for_loop_body\n+ *\n+ * Centralizes the code to call the loop body.  The compiler should be\n+ * inlining this code\n+ *\n+ * low   - Low loop index we're considering in this portion of the algorithm\n+ * high  - High loop index we're considering in this portion of the algorithm\n+ * body  - lambda function for the cilk_for loop body\n+ * data  - data used by the lambda function\n+ * w     - __cilkrts_worker we're currently executing on\n+ * loop_root_pedigree - __cilkrts_pedigree node we generated for the root of\n+ *         the cilk_for loop to flatten out the internal nodes\n+ */\n+template <typename count_t, typename F>\n+inline static\n+void call_cilk_for_loop_body(count_t low, count_t high,\n+                             F body, void *data,\n+                             __cilkrts_worker *w,\n+                             __cilkrts_pedigree *loop_root_pedigree)\n+{\n+    // Cilkscreen should not report this call in a stack trace\n+    NOTIFY_ZC_INTRINSIC((char *)\"cilkscreen_hide_call\", 0);\n+\n+    // The worker is only valid until the first spawn.  Fetch the\n+    // __cilkrts_stack_frame out of the worker, since it will be stable across\n+    // steals.  The sf pointer actually points to the *parent's*\n+    // __cilkrts_stack_frame, since this function is a non-spawning function\n+    // and therefore has no cilk stack frame of its own.\n+    __cilkrts_stack_frame *sf = w->current_stack_frame;\n+\n+    // Save the pedigree node pointed to by the worker.  We'll need to restore\n+    // that when we exit since the spawn helpers in the cilk_for call tree\n+    // will assume that it's valid\n+    const __cilkrts_pedigree *saved_next_pedigree_node = w->pedigree.parent;\n+\n+    // Add the leaf pedigree node to the chain. The parent is the root node\n+    // to flatten the tree regardless of the DAG branches in the cilk_for\n+    // divide-and-conquer recursion.\n+    //\n+    // The rank is initialized to the low index.  The user is\n+    // expected to call __cilkrts_bump_loop_rank at the end of the cilk_for\n+    // loop body.\n+    __cilkrts_pedigree loop_leaf_pedigree;\n+\n+    loop_leaf_pedigree.rank = (uint64_t)low;\n+    loop_leaf_pedigree.parent = loop_root_pedigree;\n+\n+    // The worker's pedigree always starts with a rank of 0\n+    w->pedigree.rank = 0;\n+    w->pedigree.parent = &loop_leaf_pedigree;\n+\n+    // Call the compiler generated cilk_for loop body lambda function\n+    body(data, low, high);\n+\n+    // The loop body may have included spawns, so we must refetch the worker\n+    // from the __cilkrts_stack_frame, which is stable regardless of which\n+    // worker we're executing on.\n+    w = sf->worker;\n+\n+    // Restore the pedigree chain. It must be valid because the spawn helpers\n+    // generated by the cilk_for implementation will access it.\n+    w->pedigree.parent = saved_next_pedigree_node;\n+}\n+\n+/* capture_spawn_arg_stack_frame\n+ *\n+ * Efficiently get the address of the caller's __cilkrts_stack_frame.  The\n+ * preconditons are that 'w' is the worker at the time of the call and\n+ * 'w->current_stack_frame' points to the __cilkrts_stack_frame within the\n+ * spawn helper.  This function should be called only within the argument list\n+ * of a function that is being spawned because that is the only situation in\n+ * which these preconditions hold.  This function returns the worker\n+ * (unchanged) after storing the captured stack frame pointer is stored in the\n+ * sf argument.\n+ *\n+ * The purpose of this function is to get the caller's stack frame in a\n+ * context where the caller's worker is known but its stack frame is not\n+ * necessarily initialized.  The \"shrink wrap\" optimization delays\n+ * initializing the contents of a spawning function's '__cilkrts_stack_frame'\n+ * as well as the 'current_stack_frame' pointer within the worker.  By calling\n+ * this function within a spawning function's argument list, we can ensure\n+ * that these initializations have occured but that a detach (which would\n+ * invalidate the worker pointer in the caller) has not yet occured.  Once the\n+ * '__cilkrts_stack_frame' has been retrieved in this way, it is stable for the\n+ * remainder of the caller's execution, and becomes an efficient way to get\n+ * the worker (much more efficient than calling '__cilkrts_get_tls_worker()'),\n+ * even after a spawn or sync.\n+ */\n+inline __cilkrts_worker* \n+capture_spawn_arg_stack_frame(__cilkrts_stack_frame* &sf, __cilkrts_worker* w)\n+{\n+    // Get current stack frame\n+    sf = w->current_stack_frame;\n+#ifdef __INTEL_COMPILER\n+#   if __INTEL_COMPILER <= 1300 && __INTEL_COMPILER_BUILD_DATE < 20130101\n+    // In older compilers 'w->current_stack_frame' points to the\n+    // spawn-helper's stack frame.  In newer compiler's however, it points\n+    // directly to the pointer's stack frame.  (This change was made to avoid\n+    // having the spawn helper in the frame list when evaluating function\n+    // arguments, thus avoiding corruption when those arguments themselves\n+    // contain cilk_spawns.)\n+    \n+    // w->current_stack_frame is the spawn helper's stack frame.\n+    // w->current_stack_frame->call_parent is the caller's stack frame.\n+    sf = sf->call_parent;\n+#   endif\n+#endif\n+    return w;\n+}\n+\n+/*\n+ * cilk_for_recursive\n+ *\n+ * Templatized function to implement the recursive divide-and-conquer\n+ * algorithm that's how we implement a cilk_for.\n+ *\n+ * low   - Low loop index we're considering in this portion of the algorithm\n+ * high  - High loop index we're considering in this portion of the algorithm\n+ * body  - lambda function for the cilk_for loop body\n+ * data  - data used by the lambda function\n+ * grain - grain size (0 if it should be computed)\n+ * w     - __cilkrts_worker we're currently executing on\n+ * loop_root_pedigree - __cilkrts_pedigree node we generated for the root of\n+ *         the cilk_for loop to flatten out the internal nodes\n+ */\n+template <typename count_t, typename F>\n+static\n+void cilk_for_recursive(count_t low, count_t high,\n+                        F body, void *data, int grain,\n+                        __cilkrts_worker *w,\n+                        __cilkrts_pedigree *loop_root_pedigree)\n+{\n+tail_recurse:\n+    // Cilkscreen should not report this call in a stack trace\n+    // This needs to be done everytime the worker resumes\n+    NOTIFY_ZC_INTRINSIC((char *)\"cilkscreen_hide_call\", 0);\n+\n+    count_t count = high - low;\n+    // Invariant: count > 0, grain >= 1\n+    if (count > grain)\n+    {\n+        // Invariant: count >= 2\n+        count_t mid = low + count / 2;\n+        // The worker is valid only until the first spawn and is expensive to\n+        // retrieve (using '__cilkrts_get_tls_worker') after the spawn.  The\n+        // '__cilkrts_stack_frame' is more stable, but isn't initialized until\n+        // the first spawn.  Thus, we want to grab the address of the\n+        // '__cilkrts_stack_frame' after it is initialized but before the\n+        // spawn detaches.  The only place we can do that is within the\n+        // argument list of the spawned function, hence the call to\n+        // capture_spawn_arg_stack_frame().\n+        __cilkrts_stack_frame *sf;\n+        _Cilk_spawn cilk_for_recursive(low, mid, body, data, grain,\n+                                       capture_spawn_arg_stack_frame(sf, w),\n+                                       loop_root_pedigree);\n+        w = sf->worker;\n+        low = mid;\n+\n+        goto tail_recurse;\n+    }\n+\n+    // Call the cilk_for loop body lambda function passed in by the compiler to\n+    // execute one grain\n+    call_cilk_for_loop_body(low, high, body, data, w, loop_root_pedigree);\n+}\n+\n+static void noop() { }\n+\n+/*\n+ * cilk_for_root\n+ *\n+ * Templatized function to implement the top level of a cilk_for loop.\n+ *\n+ * body  - lambda function for the cilk_for loop body\n+ * data  - data used by the lambda function\n+ * count - trip count for loop\n+ * grain - grain size (0 if it should be computed)\n+ */\n+template <typename count_t, typename F>\n+static void cilk_for_root(F body, void *data, count_t count, int grain)\n+{\n+    // Cilkscreen should not report this call in a stack trace\n+    NOTIFY_ZC_INTRINSIC((char *)\"cilkscreen_hide_call\", 0);\n+\n+    // Pedigree computation:\n+    //\n+    //    If the last pedigree node on entry to the _Cilk_for has value X,\n+    //    then at the start of each iteration of the loop body, the value of\n+    //    the last pedigree node should be 0, the value of the second-to-last\n+    //    node should equal the loop counter, and the value of the\n+    //    third-to-last node should be X.  On return from the _Cilk_for, the\n+    //    value of the last pedigree should be incremented to X+2. The\n+    //    pedigree within the loop is thus flattened, such that the depth of\n+    //    recursion does not affect the results either inside or outside of\n+    //    the loop.  Note that the pedigree after the loop exists is the same\n+    //    as if a single spawn and sync were executed within this function.\n+\n+    // TBD: Since the shrink-wrap optimization was turned on in the compiler,\n+    // it is not possible to get the current stack frame without actually\n+    // forcing a call to bind-thread.  This spurious spawn is a temporary\n+    // stopgap until the correct intrinsics are added to give us total control\n+    // over frame initialization.\n+    _Cilk_spawn noop();\n+\n+    // Fetch the current worker.  From that we can get the current stack frame\n+    // which will be constant even if we're stolen\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+    __cilkrts_stack_frame *sf = w->current_stack_frame;\n+\n+    // Decrement the rank by one to undo the pedigree change from the\n+    // _Cilk_spawn\n+    --w->pedigree.rank;\n+\n+    // Save the current worker pedigree into loop_root_pedigree, which will be\n+    // the root node for our flattened pedigree.\n+    __cilkrts_pedigree loop_root_pedigree = w->pedigree;\n+\n+    // Don't splice the loop_root node in yet.  It will be done when we\n+    // call the loop body lambda function\n+//    w->pedigree.rank = 0;\n+//    w->pedigree.next = &loop_root_pedigree;\n+\n+    /* Spawn is necessary at top-level to force runtime to start up.\n+     * Runtime must be started in order to call the grainsize() function.\n+     */\n+    int gs = grainsize(grain, count);\n+    cilk_for_recursive((count_t) 0, count, body, data, gs, w,\n+                       &loop_root_pedigree);\n+\n+    // Need to refetch the worker after calling a spawning function.\n+    w = sf->worker;\n+\n+    // Restore the pedigree in the worker.\n+    w->pedigree = loop_root_pedigree;\n+\n+    // Bump the worker pedigree.\n+    ++w->pedigree.rank;\n+\n+    // Implicit sync will increment the pedigree leaf rank again, for a total\n+    // of two increments.  If the noop spawn above is removed, then we'll need\n+    // to re-enable the following code:\n+//     // If this is an optimized build, then the compiler will have optimized\n+//     // out the increment of the worker's pedigree in the implied sync.  We\n+//     // need to add one to make the pedigree_loop test work correctly.\n+// #if CILKRTS_OPTIMIZED\n+//     ++sf->worker->pedigree.rank;\n+// #endif\n+}\n+\n+// Use extern \"C\" to suppress name mangling of __cilkrts_cilk_for_32 and\n+// __cilkrts_cilk_for_64.\n+extern \"C\" {\n+\n+/*\n+ * __cilkrts_cilk_for_32\n+ *\n+ * Implementation of cilk_for for 32-bit trip counts (regardless of processor\n+ * word size).  Assumes that the range is 0 - count.\n+ *\n+ * body  - lambda function for the cilk_for loop body\n+ * data  - data used by the lambda function\n+ * count - trip count for loop\n+ * grain - grain size (0 if it should be computed)\n+ */\n+\n+CILK_ABI_THROWS_VOID __cilkrts_cilk_for_32(__cilk_abi_f32_t body, void *data,\n+                                            cilk32_t count, int grain)\n+{\n+    // Cilkscreen should not report this call in a stack trace\n+    NOTIFY_ZC_INTRINSIC((char *)\"cilkscreen_hide_call\", 0);\n+\n+    // Check for an empty range here as an optimization - don't need to do any\n+    // __cilkrts_stack_frame initialization\n+    if (count > 0)\n+        cilk_for_root(body, data, count, grain);\n+}\n+\n+/*\n+ * __cilkrts_cilk_for_64\n+ *\n+ * Implementation of cilk_for for 64-bit trip counts (regardless of processor\n+ * word size).  Assumes that the range is 0 - count.\n+ *\n+ * body  - lambda function for the cilk_for loop body\n+ * data  - data used by the lambda function\n+ * count - trip count for loop\n+ * grain - grain size (0 if it should be computed)\n+ */\n+CILK_ABI_THROWS_VOID __cilkrts_cilk_for_64(__cilk_abi_f64_t body, void *data,\n+                                            cilk64_t count, int grain)\n+{\n+    // Check for an empty range here as an optimization - don't need to do any\n+    // __cilkrts_stack_frame initialization\n+    if (count > 0)\n+        cilk_for_root(body, data, count, grain);\n+}\n+\n+} // end extern \"C\"\n+\n+/* End cilk-abi-cilk-for.cpp */"}, {"sha": "6fb92677ad0876bedd4250975b5972aa7e0a99bc", "filename": "libcilkrts/runtime/cilk-abi-vla-internal.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.c?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,83 @@\n+/* cilk-abi-vla-internal.c        -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/*\n+ * These functions are provided in their own compilation unit so I can debug\n+ * them.  cilk-abi-vla.c must always be compiled with optimization on so that\n+ * inlining occurs.\n+ */\n+\n+#include \"internal/abi.h\"\n+#include \"cilk-abi-vla-internal.h\"\n+#include \"bug.h\"\n+#include \"full_frame.h\"\n+#include \"local_state.h\"\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+#include \"bug.h\"\n+\n+void *vla_internal_heap_alloc(__cilkrts_stack_frame *sf,\n+                              size_t full_size,\n+                              uint32_t align)\n+{\n+    return malloc(full_size);\n+}\n+\n+void vla_internal_heap_free(void *t, size_t size)\n+{\n+    free(t);\n+}\n+\n+void vla_free_from_original_stack(__cilkrts_stack_frame *sf,\n+                                  size_t full_size)\n+{\n+    // The __cilkrts_stack_frame must be initialized\n+    CILK_ASSERT(sf->worker);\n+\n+#if 1\n+    // Add full_size to ff->sync_sp so that when we return, the VLA will no\n+    // longer be allocated on the stack\n+    __cilkrts_adjust_stack(sf->worker->l->frame_ff, full_size);\n+#else\n+    // Inline __cilkrts_adjust_stack for Kevin\n+    full_frame *ff = sf->worker->l->frame_ff;\n+    ff->sync_sp = ff->sync_sp + full_size;\n+#endif\n+}"}, {"sha": "909f08fa4714a24efafd30c51dd6c63f152367fd", "filename": "libcilkrts/runtime/cilk-abi-vla-internal.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-abi-vla-internal.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,90 @@\n+/* cilk-abi-vla-internal.h        -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/**\n+ * @file cilk-abi-vla-internal.h\n+ *\n+ * @brief Allocation/deallocation function for use with Variable Length\n+ * Arrays in spawning functions.\n+ *\n+ * These should be the only functions in the Cilk runtime allocating memory\n+ * from the standard C runtime heap.  This memory will be provided to user\n+ * code for use in VLAs, when the memory cannot be allocated from the stack.\n+ *\n+ * While these functions are simply passthroughs to malloc and free at the\n+ * moment, once we've got the basics of VLA allocations working we'll make\n+ * them do fancier tricks.\n+ */\n+\n+/**\n+ * @brief Allocate memory from the heap for use by a Variable Length Array in\n+ * a spawning function.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the spawning function containing\n+ * the VLA.\n+ * @param full_size The number of bytes to be allocated, including any tags\n+ * needed to identify this as allocated from the heap.\n+ * @param align Any alignment necessary for the allocation.\n+ */\n+\n+void *vla_internal_heap_alloc(__cilkrts_stack_frame *sf,\n+                              size_t full_size,\n+                              uint32_t align);\n+\n+/**\n+ * @brief Deallocate memory from the heap used by a Variable Length Array in\n+ * a spawning function.\n+ *\n+ * @param t The address of the memory block to be freed.\n+ * @param size The size of the memory block to be freed.\n+ */\n+\n+void vla_internal_heap_free(void *t,\n+                            size_t size);\n+\n+/**\n+ * @brief Deallocate memory from the original stack.  We'll do this by adding\n+ * full_size to ff->sync_sp.  So after the sync, the Variable Length Array\n+ * will no longer be allocated on the stack.\n+ *\n+ * @param sf The __cilkrts_stack_frame for the spawning function that is\n+ * deallocating a VLA.\n+ * @param full_size The size of the VLA, including any alignment and tags.\n+ */\n+void vla_free_from_original_stack(__cilkrts_stack_frame *sf,\n+                                  size_t full_size);"}, {"sha": "1da05239ebc886cb6e2f9738eba53f8f8567225d", "filename": "libcilkrts/runtime/cilk-abi.c", "status": "added", "additions": 733, "deletions": 0, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-abi.c?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,733 @@\n+/* Cilk_abi.c                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2010-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+\n+/**\n+ * @file cilk-abi.c\n+ *\n+ * @brief cilk-abi.c implements all of the entrypoints to the Intel Cilk\n+ * Plus runtime.\n+ */\n+\n+/*\n+ * Define this macro so that compiliation of this file generates the\n+ * non-inlined versions of certain functions in cilk_api.h.\n+ */\n+#include \"internal/abi.h\"\n+#include \"cilk/cilk_api.h\"\n+#include \"cilk/cilk_undocumented.h\"\n+#include \"cilktools/cilkscreen.h\"\n+\n+#include \"global_state.h\"\n+#include \"os.h\"\n+#include \"os_mutex.h\"\n+#include \"bug.h\"\n+#include \"local_state.h\"\n+#include \"full_frame.h\"\n+#include \"pedigrees.h\"\n+#include \"scheduler.h\"\n+#include \"sysdep.h\"\n+#include \"except.h\"\n+#include \"cilk_malloc.h\"\n+#include \"record-replay.h\"\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#ifdef _MSC_VER\n+/* Some versions of icc don't support limits.h on Linux if\n+   gcc 4.3 or newer is installed. */\n+#include <limits.h>\n+\n+/* Declare _ReturnAddress compiler intrinsic */\n+void * _ReturnAddress(void);\n+#pragma intrinsic(_ReturnAddress)\n+\n+#include \"sysdep-win.h\"     // Needed for sysdep_init_module()\n+#endif  /* _WIN32 */\n+\n+#include \"metacall_impl.h\"\n+#include \"reducer_impl.h\"\n+#include \"cilk-ittnotify.h\"\n+#include \"cilk-tbb-interop.h\"\n+\n+#define TBB_INTEROP_DATA_DELAYED_UNTIL_BIND (void *)-1\n+\n+/**\n+ * __cilkrts_bind_thread is a versioned entrypoint.  The runtime should be\n+ * exporting copies of __cilkrts_bind_version for the current and all previous\n+ * versions of the ABI.\n+ *\n+ * This macro should always be set to generate a version to match the current\n+ * version; __CILKRTS_ABI_VERSION.\n+ */\n+#define BIND_THREAD_RTN __cilkrts_bind_thread_1\n+\n+static inline\n+void enter_frame_internal(__cilkrts_stack_frame *sf, uint32_t version)\n+{\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+    if (w == 0) { /* slow path */\n+        w = BIND_THREAD_RTN();\n+\n+        sf->flags = CILK_FRAME_LAST | (version << 24);\n+        CILK_ASSERT((sf->flags & CILK_FRAME_FLAGS_MASK) == CILK_FRAME_LAST);\n+    } else {\n+        sf->flags = (version << 24);\n+        CILK_ASSERT((sf->flags & CILK_FRAME_FLAGS_MASK) == 0);\n+    }\n+    sf->call_parent = w->current_stack_frame;\n+    sf->worker = w;\n+    w->current_stack_frame = sf;\n+}\n+\n+CILK_ABI_VOID __cilkrts_enter_frame(__cilkrts_stack_frame *sf)\n+{\n+    enter_frame_internal(sf, 0);\n+}\n+\n+CILK_ABI_VOID __cilkrts_enter_frame_1(__cilkrts_stack_frame *sf)\n+{\n+    enter_frame_internal(sf, 1);\n+    sf->reserved = 0;\n+}\n+\n+static inline\n+void enter_frame_fast_internal(__cilkrts_stack_frame *sf, uint32_t version)\n+{\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker_fast();\n+    sf->flags = version << 24;\n+    sf->call_parent = w->current_stack_frame;\n+    sf->worker = w;\n+    w->current_stack_frame = sf;\n+}\n+\n+CILK_ABI_VOID __cilkrts_enter_frame_fast(__cilkrts_stack_frame *sf)\n+{\n+    enter_frame_fast_internal(sf, 0);\n+}\n+\n+CILK_ABI_VOID __cilkrts_enter_frame_fast_1(__cilkrts_stack_frame *sf)\n+{\n+    enter_frame_fast_internal(sf, 1);\n+    sf->reserved = 0;\n+}\n+\n+/**\n+ * A component of the THE protocol.  __cilkrts_undo_detach checks whether\n+ * this frame's parent has been stolen.  If it hasn't, the frame can return\n+ * normally.  If the parent has been stolen, of if we suspect it might be,\n+ * then __cilkrts_leave_frame() needs to call into the runtime.\n+ *\n+ * @note __cilkrts_undo_detach() is comparing the exception pointer against\n+ * the tail pointer.  The exception pointer is modified when another worker\n+ * is considering whether it can steal a frame.  The head pointer is updated\n+ * to match when the worker lock is taken out and the thief is sure that\n+ * it can complete the steal.  If the steal cannot be completed, the thief\n+ * will restore the exception pointer.\n+ *\n+ * @return true if undo-detach failed.\n+ */\n+static int __cilkrts_undo_detach(__cilkrts_stack_frame *sf)\n+{\n+    __cilkrts_worker *w = sf->worker;\n+    __cilkrts_stack_frame *volatile *t = w->tail;\n+\n+/*    DBGPRINTF(\"%d - __cilkrts_undo_detach - sf %p\\n\", w->self, sf); */\n+\n+    --t;\n+    w->tail = t;\n+    /* On x86 the __sync_fetch_and_<op> family includes a\n+       full memory barrier.  In theory the sequence in the\n+       second branch of the #if should be faster, but on\n+       most x86 it is not.  */\n+#if defined __i386__ || defined __x86_64__\n+    __sync_fetch_and_and(&sf->flags, ~CILK_FRAME_DETACHED);\n+#else\n+    __cilkrts_fence(); /* membar #StoreLoad */\n+    sf->flags &= ~CILK_FRAME_DETACHED;\n+#endif\n+\n+    return __builtin_expect(t < w->exc, 0);\n+}\n+\n+CILK_ABI_VOID __cilkrts_leave_frame(__cilkrts_stack_frame *sf)\n+{\n+    __cilkrts_worker *w = sf->worker;\n+\n+/*    DBGPRINTF(\"%d-%p __cilkrts_leave_frame - sf %p, flags: %x\\n\", w->self, GetWorkerFiber(w), sf, sf->flags); */\n+\n+#ifdef _WIN32\n+    /* if leave frame was called from our unwind handler, leave_frame should\n+       proceed no further. */\n+    if (sf->flags & CILK_FRAME_UNWINDING)\n+    {\n+/*        DBGPRINTF(\"%d - __cilkrts_leave_frame - aborting due to UNWINDING flag\\n\", w->self); */\n+\n+        // If this is the frame of a spawn helper (indicated by the\n+        // CILK_FRAME_DETACHED flag) we must update the pedigree.  The pedigree\n+        // points to nodes allocated on the stack.  Failing to update it will\n+        // result in a accvio/segfault if the pedigree is walked.  This must happen\n+        // for all spawn helper frames, even if we're processing an exception\n+        if ((sf->flags & CILK_FRAME_DETACHED))\n+        {\n+\t    update_pedigree_on_leave_frame(w, sf);\n+        }\n+        return;\n+    }\n+#endif\n+\n+#if CILK_LIB_DEBUG\n+    /* ensure the caller popped itself */\n+    CILK_ASSERT(w->current_stack_frame != sf);\n+#endif\n+\n+    /* The exiting function should have checked for zero flags,\n+       so there is no check for flags == 0 here. */\n+\n+#if CILK_LIB_DEBUG\n+    if (__builtin_expect(sf->flags & (CILK_FRAME_EXITING|CILK_FRAME_UNSYNCHED), 0))\n+        __cilkrts_bug(\"W%u: function exiting with invalid flags %02x\\n\",\n+                      w->self, sf->flags);\n+#endif\n+\n+    /* Must return normally if (1) the active function was called\n+       and not spawned, or (2) the parent has never been stolen. */\n+    if ((sf->flags & CILK_FRAME_DETACHED)) {\n+/*        DBGPRINTF(\"%d - __cilkrts_leave_frame - CILK_FRAME_DETACHED\\n\", w->self); */\n+\n+#ifndef _WIN32\n+        if (__builtin_expect(sf->flags & CILK_FRAME_EXCEPTING, 0)) {\n+// Pedigree will be updated in __cilkrts_leave_frame.  We need the\n+// pedigree before the update for record/replay\n+//\t    update_pedigree_on_leave_frame(w, sf);\n+            __cilkrts_return_exception(sf);\n+            /* If return_exception returns the caller is attached.\n+               leave_frame is called from a cleanup (destructor)\n+               for the frame object.  The caller will reraise the\n+               exception. */\n+\t    return;\n+        }\n+#endif\n+\n+        // During replay, check whether w was the last worker to continue\n+        replay_wait_for_steal_if_parent_was_stolen(w);\n+\n+        // Attempt to undo the detach\n+        if (__builtin_expect(__cilkrts_undo_detach(sf), 0)) {\n+\t        // The update of pedigree for leaving the frame occurs\n+\t        // inside this call if it does not return.\n+            __cilkrts_c_THE_exception_check(w, sf);\n+        }\n+\n+        update_pedigree_on_leave_frame(w, sf);\n+\n+        /* This path is taken when undo-detach wins the race with stealing.\n+           Otherwise this strand terminates and the caller will be resumed\n+           via setjmp at sync. */\n+        if (__builtin_expect(sf->flags & CILK_FRAME_FLAGS_MASK, 0))\n+            __cilkrts_bug(\"W%u: frame won undo-detach race with flags %02x\\n\",\n+                          w->self, sf->flags);\n+\n+        return;\n+    }\n+\n+#if CILK_LIB_DEBUG\n+    sf->flags |= CILK_FRAME_EXITING;\n+#endif\n+\n+    if (__builtin_expect(sf->flags & CILK_FRAME_LAST, 0))\n+        __cilkrts_c_return_from_initial(w); /* does return */\n+    else if (sf->flags & CILK_FRAME_STOLEN)\n+        __cilkrts_return(w); /* does return */\n+\n+/*    DBGPRINTF(\"%d-%p __cilkrts_leave_frame - returning, StackBase: %p\\n\", w->self, GetWorkerFiber(w)); */\n+}\n+\n+/* Caller must have called setjmp. */\n+CILK_ABI_VOID __cilkrts_sync(__cilkrts_stack_frame *sf)\n+{\n+    __cilkrts_worker *w = sf->worker;\n+/*    DBGPRINTF(\"%d-%p __cilkrts_sync - sf %p\\n\", w->self, GetWorkerFiber(w), sf); */\n+    if (__builtin_expect(!(sf->flags & CILK_FRAME_UNSYNCHED), 0))\n+        __cilkrts_bug(\"W%u: double sync %p\\n\", w->self, sf);\n+#ifndef _WIN32\n+    if (__builtin_expect(sf->flags & CILK_FRAME_EXCEPTING, 0)) {\n+        __cilkrts_c_sync_except(w, sf);\n+    }\n+#endif\n+\n+    __cilkrts_c_sync(w, sf);\n+}\n+\n+/*\n+ * __cilkrts_get_sf\n+ *\n+ * Debugging aid to provide access to the current __cilkrts_stack_frame.\n+ *\n+ * Not documented!\n+ */\n+\n+CILK_API_VOID_PTR\n+__cilkrts_get_sf(void)\n+{\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+    if (0 == w)\n+        return NULL;\n+\n+    return w->current_stack_frame;\n+}\n+\n+/* Call with global lock held */\n+static __cilkrts_worker *find_free_worker(global_state_t *g)\n+{\n+    __cilkrts_worker *w = 0;\n+    int i;\n+\n+    // Scan the non-system workers looking for one which is free so we can\n+    // use it.\n+    for (i = g->P - 1; i < g->total_workers; ++i) {\n+        w = g->workers[i];\n+        CILK_ASSERT(WORKER_SYSTEM != w->l->type);\n+        if (w->l->type == WORKER_FREE) {\n+            w->l->type = WORKER_USER;\n+            w->l->team = w;\n+            return w;\n+        }\n+    }\n+\n+    // If we ran out of workers, create a new one.  It doesn't actually belong\n+    // to the Cilk global state so nobody will ever try to steal from it.\n+    w = (__cilkrts_worker *)__cilkrts_malloc(sizeof(*w));\n+    __cilkrts_cilkscreen_ignore_block(w, w+1);\n+    make_worker(g, -1, w);\n+    w->l->type = WORKER_USER;\n+    w->l->team = w;\n+    return w;\n+}\n+\n+/*\n+ * __cilkrts_bind_thread\n+ *\n+ * Exported function to bind a thread to the runtime.\n+ *\n+ * This function name should always have a trailing suffix for the latest ABI\n+ * version. This means that code built with a new compiler will not load\n+ * against an old copy of the runtime.\n+ *\n+ * Symbols for the function called by code compiled with old versions of the\n+ * compiler are created in an OS-specific manner:\n+ *  - On Windows the old symbols are defined in the cilk-exports.def linker\n+ *    definitions file as aliases of BIND_THREAD_RTN\n+ *  - On Linux aliased symbols are created for BIND_THREAD_RTN in this file\n+ *  - On MacOS the alternate entrypoints are implemented and simply call\n+ *    BIND_THREAD_RTN.\n+ */\n+CILK_ABI_WORKER_PTR BIND_THREAD_RTN(void)\n+{\n+    __cilkrts_worker *w;\n+    int start_cilkscreen = 0;\n+#ifdef USE_ITTNOTIFY\n+    static int unique_obj;\n+#endif\n+\n+    // Cannot set this pointer until after __cilkrts_init_internal() call:\n+    global_state_t* g;\n+\n+    ITT_SYNC_CREATE (&unique_obj, \"Initialization\");\n+    ITT_SYNC_PREPARE(&unique_obj);\n+    ITT_SYNC_ACQUIRED(&unique_obj);\n+\n+\n+    /* 1: Initialize and start the Cilk runtime */\n+    __cilkrts_init_internal(1);\n+\n+    /*\n+     * 2: Choose a worker for this thread (fail if none left).  The table of\n+     *    user workers is protected by the global OS mutex lock.\n+     */\n+    g = cilkg_get_global_state();\n+    global_os_mutex_lock();\n+    if (__builtin_expect(g->work_done, 0))\n+        __cilkrts_bug(\"Attempt to enter Cilk while Cilk is shutting down\");\n+    w = find_free_worker(g);\n+    CILK_ASSERT(w);\n+\n+    __cilkrts_set_tls_worker(w);\n+    __cilkrts_cilkscreen_establish_worker(w);\n+    {\n+        full_frame *ff = __cilkrts_make_full_frame(w, 0);\n+\n+        ff->fiber_self = cilk_fiber_allocate_from_thread();\n+        CILK_ASSERT(ff->fiber_self);\n+\n+        cilk_fiber_set_owner(ff->fiber_self, w);\n+        cilk_fiber_tbb_interop_use_saved_stack_op_info(ff->fiber_self);\n+\t\n+        CILK_ASSERT(ff->join_counter == 0);\n+        ff->join_counter = 1;\n+        w->l->frame_ff = ff;\n+        w->reducer_map = __cilkrts_make_reducer_map(w);\n+        __cilkrts_set_leftmost_reducer_map(w->reducer_map, 1);\n+        load_pedigree_leaf_into_user_worker(w);\n+    }\n+\n+    // Make sure that the head and tail are reset, and saved_protected_tail\n+    // allows all frames to be stolen.\n+    //\n+    // Note that we must NOT check w->exc, since workers that are trying to\n+    // steal from it will be updating w->exc and we don't own the worker lock.\n+    // It's not worth taking out the lock just for an assertion.\n+    CILK_ASSERT(w->head == w->l->ltq);\n+    CILK_ASSERT(w->tail == w->l->ltq);\n+    CILK_ASSERT(w->protected_tail  == w->ltq_limit);\n+\n+    // There may have been an old pending exception which was freed when the\n+    // exception was caught outside of Cilk\n+    w->l->pending_exception = NULL;\n+\n+    w->reserved = NULL;\n+\n+    // If we've already created a scheduling fiber for this worker, we'll just\n+    // reuse it.  If w->self < 0, it means that this is an ad-hoc user worker\n+    // not known to the global state.  Thus, we need to create a scheduling\n+    // stack only if we don't already have one and w->self >= 0.\n+    if (NULL == w->l->scheduling_fiber && w->self >= 0)\n+    {\n+        START_INTERVAL(w, INTERVAL_FIBER_ALLOCATE) {\n+            // Create a scheduling fiber for this worker.\n+            w->l->scheduling_fiber =\n+                cilk_fiber_allocate_from_heap(CILK_SCHEDULING_STACK_SIZE);\n+            cilk_fiber_reset_state(w->l->scheduling_fiber,\n+                                   scheduler_fiber_proc_for_user_worker);\n+            cilk_fiber_set_owner(w->l->scheduling_fiber, w);\n+        } STOP_INTERVAL(w, INTERVAL_FIBER_ALLOCATE);\n+    }\n+    \n+    // If the scheduling fiber is NULL, we've either exceeded our quota for\n+    // fibers or workers or we're out of memory, so we should lose parallelism\n+    // by disallowing stealing.\n+    if (NULL == w->l->scheduling_fiber)\n+        __cilkrts_disallow_stealing(w, NULL);\n+\n+    start_cilkscreen = (0 == w->g->Q);\n+\n+    if (w->self != -1) {\n+        // w->self != -1, means that w is a normal user worker and must be\n+        // accounted for by the global state since other workers can steal from\n+        // it.\n+\n+        // w->self == -1, means that w is an overflow worker and was created on\n+        // demand.  I.e., it does not need to be accounted for by the global\n+        // state.\n+\n+        __cilkrts_enter_cilk(w->g);\n+    }\n+\n+    global_os_mutex_unlock();\n+\n+    /* If there's only 1 worker, the counts will be started in\n+     * __cilkrts_scheduler */\n+    if (g->P > 1)\n+    {\n+        START_INTERVAL(w, INTERVAL_IN_SCHEDULER);\n+        START_INTERVAL(w, INTERVAL_WORKING);\n+    }\n+\n+    ITT_SYNC_RELEASING(&unique_obj);\n+\n+    /* Turn on Cilkscreen if this is the first worker.  This needs to be done\n+     * when we are NOT holding the os mutex. */\n+    if (start_cilkscreen)\n+        __cilkrts_cilkscreen_enable_instrumentation();\n+\n+    return w;\n+}\n+\n+#ifndef _MSC_VER\n+/*\n+ * Define old version-specific symbols for binding threads (since they exist in\n+ * all Cilk code).  These aliases prohibit newly compiled code from loading an\n+ * old version of the runtime.  We can handle old code with a new runtime, but\n+ * new code with an old runtime is verboten!\n+ *\n+ * For Windows, the aliased symbol is exported in cilk-exports.def.\n+ */\n+#if defined(_DARWIN_C_SOURCE) || defined(__APPLE__)\n+/**\n+ * Mac OS X: Unfortunately, Darwin doesn't allow aliasing, so we just make a\n+ * call and hope the optimizer does the right thing.\n+ */\n+CILK_ABI_WORKER_PTR __cilkrts_bind_thread (void) {\n+    return BIND_THREAD_RTN();\n+}\n+#else\n+\n+/**\n+ * Macro to convert a parameter to a string.  Used on Linux or BSD.\n+ */\n+#define STRINGIFY(x) #x\n+\n+/**\n+ * Macro to generate an __attribute__ for an aliased name\n+ */\n+#define ALIASED_NAME(x) __attribute__ ((alias (STRINGIFY(x))))\n+\n+/**\n+ * Linux or BSD: Use the alias attribute to make the labels for the versioned\n+ * functions point to the same place in the code as the original.  Using\n+ * the two macros is annoying but required.\n+ */\n+\n+CILK_ABI_WORKER_PTR __cilkrts_bind_thread(void)\n+    ALIASED_NAME(BIND_THREAD_RTN);\n+\n+#endif // defined _DARWIN_C_SOURCE || defined __APPLE__\n+#endif // !defined _MSC_VER\n+\n+CILK_API_SIZET\n+__cilkrts_get_stack_size(void) {\n+    return cilkg_get_stack_size();\n+}\n+\n+// Method for debugging.\n+CILK_API_VOID __cilkrts_dump_stats(void)\n+{\n+    // While the stats aren't protected by the global OS mutex, the table\n+    // of workers is, so take out the global OS mutex while we're doing this\n+    global_os_mutex_lock();\n+    if (cilkg_is_published()) {\n+        global_state_t *g = cilkg_get_global_state();\n+\t__cilkrts_dump_stats_to_stderr(g);\n+    }\n+    else {\n+\t__cilkrts_bug(\"Attempting to report Cilk stats before the runtime has started\\n\");\n+    }    \n+    global_os_mutex_unlock();\n+}\n+\n+#ifndef _WIN32\n+CILK_ABI_THROWS_VOID __cilkrts_rethrow(__cilkrts_stack_frame *sf)\n+{\n+    __cilkrts_gcc_rethrow(sf);\n+}\n+#endif\n+\n+/*\n+ * __cilkrts_unwatch_stack\n+ *\n+ * Callback for TBB to tell us they don't want to watch the stack anymore\n+ */\n+\n+static __cilk_tbb_retcode __cilkrts_unwatch_stack(void *data)\n+{\n+    __cilk_tbb_stack_op_thunk o;\n+\n+    // If the cilk_fiber wasn't available fetch it now\n+    if (TBB_INTEROP_DATA_DELAYED_UNTIL_BIND == data)\n+    {\n+        full_frame *ff;\n+        __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+        if (NULL == w)\n+        {\n+            // Free any saved stack op information\n+            cilk_fiber_tbb_interop_free_stack_op_info();\n+\n+            return 0;       /* Success! */\n+        }\n+\n+        __cilkrts_worker_lock(w);\n+        ff = w->l->frame_ff;\n+        __cilkrts_frame_lock(w,ff);\n+        data = ff->fiber_self;\n+        __cilkrts_frame_unlock(w,ff);\n+        __cilkrts_worker_unlock(w);\n+    }\n+\n+#if CILK_LIB_DEBUG /* Debug code */\n+    /* Get current stack */\n+    full_frame *ff;\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+    __cilkrts_worker_lock(w);\n+    ff = w->l->frame_ff;\n+    __cilkrts_frame_lock(w,ff);\n+    CILK_ASSERT (data == ff->fiber_self);\n+    __cilkrts_frame_unlock(w,ff);\n+    __cilkrts_worker_unlock(w);\n+#endif\n+\n+    /* Clear the callback information */\n+    o.data = NULL;\n+    o.routine = NULL;\n+    cilk_fiber_set_stack_op((cilk_fiber*)data, o);\n+    \n+    // Note. Do *NOT* free any saved stack information here.   If they want to\n+    // free the saved stack op information, they'll do it when the thread is\n+    // unbound\n+\n+    return 0;       /* Success! */\n+}\n+\n+/*\n+ * __cilkrts_watch_stack\n+ *\n+ * Called by TBB, defined by Cilk.\n+ *\n+ * Requests that Cilk invoke the stack op routine when it orphans a stack. \n+ * Cilk sets *u to a thunk that TBB should call when it is no longer interested\n+ * in watching the stack.\n+ */\n+\n+CILK_API_TBB_RETCODE\n+__cilkrts_watch_stack(__cilk_tbb_unwatch_thunk *u,\n+                      __cilk_tbb_stack_op_thunk o)\n+{\n+    cilk_fiber* current_fiber;\n+    __cilkrts_worker *w;\n+\n+#ifdef _MSC_VER\n+    // This may be called by TBB *before* the OS has given us our\n+    // initialization call.  Make sure the module is initialized.\n+    sysdep_init_module();\n+#endif\n+\n+    // Fetch the __cilkrts_worker bound to this thread\n+    w = __cilkrts_get_tls_worker();\n+    if (NULL == w)\n+    {\n+        // Save data for later.  We'll deal with it when/if this thread binds\n+        // to the runtime\n+        cilk_fiber_tbb_interop_save_stack_op_info(o);\n+        \n+        u->routine = __cilkrts_unwatch_stack;\n+        u->data = TBB_INTEROP_DATA_DELAYED_UNTIL_BIND;\n+\n+        return 0;\n+    }\n+\n+    /* Get current stack */\n+    __cilkrts_worker_lock(w);\n+    current_fiber = w->l->frame_ff->fiber_self;\n+    __cilkrts_worker_unlock(w);\n+\n+/*    CILK_ASSERT( !sd->stack_op_data ); */\n+/*    CILK_ASSERT( !sd->stack_op_routine ); */\n+\n+    /* Give TBB our callback */\n+    u->routine = __cilkrts_unwatch_stack;\n+    u->data = current_fiber;\n+    /* Save the callback information */\n+    cilk_fiber_set_stack_op(current_fiber, o);\n+\n+    return 0;   /* Success! */\n+}\n+\n+\n+// This function must be called only within a continuation, within the stack\n+// frame of the continuation itself.\n+CILK_API_INT __cilkrts_synched(void)\n+{\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+\n+    // If we don't have a worker, then we're synched by definition :o)\n+    if (NULL == w)\n+        return 1;\n+\n+    // Check to see if we are in a stolen continuation.  If not, then\n+    // we are synched.\n+    uint32_t flags = w->current_stack_frame->flags;\n+    if (0 == (flags & CILK_FRAME_UNSYNCHED))\n+        return 1;\n+\n+    // We are in a stolen continutation, but the join counter might have been\n+    // decremented to one, making us synched again.  Get the full frame so\n+    // that we can check the join counter.  ASSUME: frame_ff is stable (can be\n+    // read without a lock) in a stolen continuation -- it can't be stolen\n+    // while it's currently executing.\n+    full_frame *ff = w->l->frame_ff;\n+\n+    // Make sure we have a full frame\n+    // TBD: Don't think that we should ever not have a full frame here.\n+    // CILK_ASSERT(NULL != ff); ?\n+    if (NULL == ff)\n+        return 1;\n+\n+    // We're synched if there are no outstanding children at this instant in\n+    // time.  Note that this is a known race, but it's ok since we're only\n+    // reading.  We can get false negatives, but not false positives. (I.e.,\n+    // we can read a non-one join_counter just before it goes to one, but the\n+    // join_counter cannot go from one to greater than one while we're\n+    // reading.)\n+    return 1 == ff->join_counter;\n+}\n+\n+\n+\n+\n+CILK_API_INT\n+__cilkrts_bump_loop_rank_internal(__cilkrts_worker* w)\n+{\n+    // If we don't have a worker, then the runtime is not bound to this\n+    // thread and there is no rank to increment\n+    if (NULL == w)\n+        return -1;\n+\n+    // We're at the start of the loop body.  Advance the cilk_for loop\n+    // body pedigree by following the parent link and updating its\n+    // rank.\n+\n+    // Normally, we'd just write \"w->pedigree.parent->rank++\"\n+    // But we need to cast away the \"const\".\n+    ((__cilkrts_pedigree*) w->pedigree.parent)->rank++;\n+\n+    // Zero the worker's pedigree rank since this is the start of a new\n+    // pedigree domain.\n+    w->pedigree.rank = 0;\n+\n+    return 0;\n+}\n+\n+CILK_ABI_VOID\n+__cilkrts_save_fp_ctrl_state(__cilkrts_stack_frame *sf)\n+{\n+    // Pass call onto OS/architecture dependent function\n+    sysdep_save_fp_ctrl_state(sf);\n+}\n+\n+/* end cilk-abi.c */"}, {"sha": "ff995db6fbb9af4212a0b52d00b16d77296644c3", "filename": "libcilkrts/runtime/cilk-ittnotify.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-ittnotify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-ittnotify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-ittnotify.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,100 @@\n+/* cilk-ittnotify.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+#ifndef INCLUDED_CILK_ITTNOTIFY_DOT_H\n+#define INCLUDED_CILK_ITTNOTIFY_DOT_H\n+\n+#ifdef __INTEL_COMPILER\n+#endif\n+#include <stdio.h>\n+\n+// ITTNOTIFY does not support ARM at this time\n+#ifdef __arm__\n+#undef USE_ITTNOTIFY\n+#endif\n+\n+#ifdef USE_ITTNOTIFY\n+#include <ittnotify.h>\n+\n+#ifdef _WIN32\n+# define ITT_SYNC_CREATE(_address, _description)        \\\n+    __itt_sync_createA(_address,                        \\\n+                       \"Intel Cilk Plus \" _description, \\\n+                       \"\",                              \\\n+                       __itt_attr_barrier)\n+#else\n+# define ITT_SYNC_CREATE(_address, _description)        \\\n+    __itt_sync_create(_address,                         \\\n+                      \"Intel Cilk Plus \" _description,  \\\n+                      \"\",                               \\\n+                      __itt_attr_barrier)\n+#endif\n+\n+#define ITT_SYNC_PREPARE(_address) __itt_sync_prepare(_address)\n+#define ITT_SYNC_ACQUIRED(_address) __itt_sync_acquired(_address)\n+#define ITT_SYNC_RELEASING(_address) __itt_sync_releasing(_address)\n+#define ITT_SYNC_DESTROY(_address) __itt_sync_destroy(_address)\n+// Note that we subtract 5 from the return address to find the CALL instruction\n+// to __cilkrts_sync\n+#if 1   // Disable renaming for now.  Piersol isn't ready yet\n+#define ITT_SYNC_SET_NAME_AND_PREPARE(_address, _sync_ret_address) __itt_sync_prepare(_address)\n+#else\n+#define ITT_SYNC_SET_NAME_AND_PREPARE(_address, _sync_ret_address) \\\n+    if (NULL != __itt_sync_prepare_ptr) {   \\\n+        if (0 == _sync_ret_address) \\\n+            __itt_sync_renameA(_address, \"\");  \\\n+        else    \\\n+        {   \\\n+            char buf[128];  \\\n+            sprintf_s(buf, 128, \"IP:0x%p\", (DWORD_PTR)_sync_ret_address - 5); \\\n+            __itt_sync_renameA(_address, buf); \\\n+            _sync_ret_address = 0;  \\\n+         }  \\\n+        __itt_sync_prepare(_address);  \\\n+    }\n+#endif\n+#else   // USE_ITTNOTIFY not defined, compile out all calls\n+#define ITT_SYNC_CREATE(_address, _description)\n+#define ITT_SYNC_PREPARE(_address)\n+#define ITT_SYNC_ACQUIRED(_address)\n+#define ITT_SYNC_RELEASING(_addresss)\n+#define ITT_SYNC_DESTROY(_address)\n+#define ITT_SYNC_SET_NAME_AND_PREPARE(_sync_address, _wait_address)\n+#endif\n+\n+#endif // ! defined(INCLUDED_CILK_ITTNOTIFY_DOT_H)"}, {"sha": "cc5cff4b57e8bdf107510f3582a1f57859b3dec3", "filename": "libcilkrts/runtime/cilk-tbb-interop.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-tbb-interop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk-tbb-interop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-tbb-interop.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,192 @@\n+/* cilk-tbb-interop.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/**\n+ * @file cilk-tbb-interop.h\n+ *\n+ * @brief Interface between TBB and Cilk to allow TBB to associate it's\n+ * per-thread data with Cilk workers, and maintain the association as work\n+ * moves between worker threads.  This handles the case where TBB calls\n+ * into a Cilk function which may later call back to a function making\n+ * TBB calls.\n+ *\n+ * Each thunk structure has two pointers: \\\"routine\\\" and \\\"data\\\".\n+ * The caller of the thunk invokes *routine, passing \\\"data\\\" as the void*\n+ * parameter.\n+ */\n+\n+#ifndef INCLUDED_CILK_TBB_INTEROP_DOT_H\n+#define INCLUDED_CILK_TBB_INTEROP_DOT_H\n+\n+#include <cilk/common.h>  // for CILK_EXPORT\n+\n+__CILKRTS_BEGIN_EXTERN_C\n+\n+/** A return code.  0 indicates success. */\n+typedef int __cilk_tbb_retcode;\n+\n+/**\n+ * Enumeration of reasons that Cilk will call the TBB stack operation\n+ * function.\n+ *\n+ * When a non-empty stack is transfered between threads, the first thread must\n+ * orphan it and the second thread must adopt it.\n+ *\n+ * An empty stack can be transfered similarly, or simply released by the first\n+ * thread.\n+ *\n+ * Here is a summary of the actions as transitions on a state machine.\n+@verbatim\n+                       watch                                    ORPHAN\n+                       -->-->                                   -->--\n+                      /      \\                                 /     \\\n+   (freed empty stack)       (TBB sees stack running on thread)      (stack in limbo)\n+                      \\     /                                  \\     / \n+                       --<--                                    --<--\n+                       RELEASE or                               ADOPT\n+                       unwatch\n+@endverbatim\n+ */\n+typedef enum __cilk_tbb_stack_op {\n+   /**\n+    * Disconnecting stack from a thread.\n+    *\n+    * The thunk must be invoked on the thread disconnecting itself from the\n+    * stack.  Must \\\"happen before\\\" the stack is adopted elsewhere.\n+    */\n+    CILK_TBB_STACK_ORPHAN,\n+\n+    /**\n+     * Reconnecting orphaned stack to a thread.\n+     *\n+     * The thunk must be invoked on the thread adopting the stack.\n+     */\n+    CILK_TBB_STACK_ADOPT,\n+\n+   /**\n+    * Releasing stack.\n+    *\n+    * The thunk must be invoked on the thread doing the releasing, Must\n+    * \\\"happen before\\\" the stack is used elsewhere.\n+    */\n+    CILK_TBB_STACK_RELEASE\n+} __cilk_tbb_stack_op;\n+\n+/**\n+ * Function that will be called by the Cilk runtime to inform TBB of a change\n+ * in the stack associated with the current thread.\n+ *\n+ * It does not matter what stack the thunk runs on.\n+ * The thread (not fiber) on which the thunk runs is important.\n+ *\n+ * @param op Enumerated value indicating what type of change is ocurring.\n+ * @param data Context value provided by TBB in the __cilkrts_watch_stack\n+ * call.  This data is opaque to Cilk.\n+ *\n+ * @return 0 indicates success.\n+ */\n+typedef __cilk_tbb_retcode (*__cilk_tbb_pfn_stack_op)(enum __cilk_tbb_stack_op op,\n+                                                      void* data);\n+\n+/**\n+ * Function that will be called by TBB to inform the Cilk runtime that TBB\n+ * is no longer interested in watching the stack bound to the current thread.\n+ *\n+ * @param data Context value provided to TBB by the __cilkrts_watch_stack\n+ * call.  This data is opaque to TBB.\n+ *\n+ * @return 0 indicates success.\n+ */\n+typedef __cilk_tbb_retcode (*__cilk_tbb_pfn_unwatch_stacks)(void *data);\n+\n+/**\n+ * Thunk invoked by Cilk to call back to TBB to tell it about a change in\n+ * the stack bound to the current thread.\n+ */\n+typedef struct __cilk_tbb_stack_op_thunk {\n+    /// Function in TBB the Cilk runtime should call when something\n+    // \"interesting\" happens involving a stack\n+    __cilk_tbb_pfn_stack_op routine;\n+\n+    /// TBB context data to pass with the call to the stack_op routine\n+    void* data;\n+} __cilk_tbb_stack_op_thunk;\n+\n+/**\n+ * Thunk invoked by TBB when it is no longer interested in watching the stack\n+ * bound to the current thread.\n+ */\n+typedef struct __cilk_tbb_unwatch_thunk {\n+    /// Function in Cilk runtime to call when TBB no longer wants to watch\n+    // stacks\n+    __cilk_tbb_pfn_unwatch_stacks routine;\n+\n+    /// Cilk runtime context data to pass with the call to the unwatch_stacks\n+    /// routine\n+    void* data;\n+} __cilk_tbb_unwatch_thunk;\n+\n+/**\n+ * Requests that Cilk invoke __cilk_tbb_orphan_thunk when it orphans a stack.\n+ * Cilk sets *u to a thunk that TBB should call when it is no longer\n+ * interested in watching the stack.\n+ *\n+ * If the thread is not yet bound to the Cilk runtime, the Cilk runtime should\n+ * save this data in thread-local storage until __cilkrts_bind_thread is called.\n+ *\n+ * Called by TBB, defined by Cilk.  This function is exported from the Cilk\n+ * runtime DLL/shared object.  This declaration also appears in\n+ * cilk/cilk_undocumented.h -- don't change one declaration without also\n+ * changing the other.\n+ *\n+ * @param u __cilk_tbb_unwatch_thunk.  This structure will be filled in by\n+ * the Cilk runtime to allow TBB to register that it is no longer interested\n+ * in watching the stack bound to the current thread.\n+ * @param o __cilk_tbb_stack_op_thunk.  This structure specifies the routine\n+ * that the Cilk runtime should call when an \"interesting\" change in the stack\n+ * associate with the current worker occurs.\n+ *\n+ * @return 0 indicates success.\n+ */\n+CILK_EXPORT\n+__cilk_tbb_retcode __cilkrts_watch_stack(__cilk_tbb_unwatch_thunk* u,\n+                                         __cilk_tbb_stack_op_thunk o);\n+\n+__CILKRTS_END_EXTERN_C\n+\n+#endif // ! defined(INCLUDED_CILK_TBB_INTEROP_DOT_H)"}, {"sha": "bbca984bc03fd2d60084a280f584407ff01b0a25", "filename": "libcilkrts/runtime/cilk_api.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_api.c?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,255 @@\n+/* cilk_api.c                  -*-C-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2009-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/*\n+ * Implementation of functions declared in cilk_api.h\n+ */\n+\n+/*\n+ * Define the COMPILING_CILK_ABI_FUNCTIONS macro, so that\n+ * compilation of this file generates non-inlined definitions for the\n+ * functions marked as CILK_EXPORT_AND_INLINE in cilk_api.h.\n+ *\n+ * We must deal with these functions differently because we need to\n+ * continue to ship nonlined versions of these functions.\n+ *\n+ *   CILK_EXPORT_AND_INLINE int __cilkrts_get_worker_rank(uint64_t *rank);\n+ *   CILK_EXPORT_AND_INLINE int __cilkrts_bump_worker_rank();\n+ *   CILK_EXPORT_AND_INLINE int __cilkrts_bump_loop_rank();\n+ */\n+#define COMPILING_CILK_API_FUNCTIONS\n+\n+#include <internal/abi.h>\n+#include <cilk/cilk_api.h>\n+\n+#include \"os.h\"\n+#include \"os_mutex.h\"\n+#include \"bug.h\"\n+#include \"global_state.h\"\n+#include \"local_state.h\"\n+#include \"scheduler.h\"\n+#include \"sysdep.h\"\n+\n+CILK_API_VOID __cilkrts_init(void)\n+{\n+    // Initialize, but don't start, the cilk runtime.\n+    __cilkrts_init_internal(0);\n+}\n+\n+CILK_API_VOID __cilkrts_end_cilk(void)\n+{\n+    // Take out the global OS mutex while we do this to protect against\n+    // another thread attempting to bind while we do this\n+    global_os_mutex_lock();\n+\n+    if (cilkg_is_published()) {\n+        global_state_t *g = cilkg_get_global_state();\n+        if (g->Q || __cilkrts_get_tls_worker())\n+            __cilkrts_bug(\"Attempt to shut down Cilk while Cilk is still \"\n+                          \"running\");\n+        __cilkrts_stop_workers(g);\n+        __cilkrts_deinit_internal(g);\n+    }\n+\n+    global_os_mutex_unlock();\n+}\n+\n+CILK_API_INT\n+__cilkrts_get_nworkers()\n+{\n+    return cilkg_get_nworkers();\n+}\n+\n+CILK_API_INT\n+__cilkrts_get_total_workers()\n+{\n+    return cilkg_get_total_workers();\n+}\n+\n+CILK_API_INT __cilkrts_get_force_reduce(void)\n+{\n+    return cilkg_get_force_reduce();\n+}\n+\n+CILK_API_INT __cilkrts_set_param(const char* param, const char* value)\n+{\n+    return cilkg_set_param(param, value);\n+}\n+\n+#ifdef _WIN32\n+CILK_API_INT __cilkrts_set_param_w(const wchar_t* param, const wchar_t* value)\n+{\n+    return cilkg_set_param_w(param, value);\n+}\n+#endif // _WIN32\n+\n+/* Return a small integer indicating which Cilk worker the function is\n+ * currently running on.  Each thread started by the Cilk runtime library\n+ * (system worker) has a unique worker number in the range 1..P-1, where P is\n+ * the valued returned by __cilkrts_get_nworkers().  All threads started by\n+ * the user or by other libraries (user workers) share the worker number 0.\n+ * Therefore, the worker number is not unique across multiple user threads.\n+ *\n+ * Implementor's note: The value returned from this function is different from\n+ * the value, w->self, used in most debug messages.\n+ */\n+CILK_API_INT\n+__cilkrts_get_worker_number(void)\n+{\n+    __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+\n+    if (0 == w)\n+        /* A non-worker always has a worker number of zero. */\n+        return 0;\n+    else if (WORKER_USER == w->l->type)\n+        /* User worker was once a non-worker, so its number should still be\n+         * zero. */\n+        return 0;\n+    else\n+        /* w->self for a system worker is in range 0..(P-1); adjust to 1..P\n+         * to avoid conflicting with the user thread's worker number. */\n+        return w->self + 1;\n+}\n+\n+/**\n+ * Internal definition of the pedigree context.  The size of the\n+ * structure must match __cilkrts_pedigree_context_t defined in abi.i\n+ */\n+typedef struct pedigree_context_t\n+{\n+    /** Size of the structure, in bytes */\n+    size_t size;\n+\n+    /** Next __cilkrts_pedigree to return */\n+    const __cilkrts_pedigree *pedigree;\n+\n+    /** Unused.  Left over from previous implementation */\n+    void *unused1;\n+\n+    /** Unused.  Left over from previous implementation */\n+    void *unused2;\n+\n+    // // Debugging aid for pedigree-test:\n+    // __cilkrts_stack_frame *expected_sf;\n+} pedigree_context_t;\n+\n+/*\n+ * __cilkrts_get_pedigree_info\n+ *\n+ * Fetch the birthrank for a stack frame.  To initialize the walk, both sf_in\n+ * and frame_in should be NULL.  parent_sf_ptr and parent_frame_ptr provide\n+ * context for the stackwalk and should be returned as sf_in and frame_in on\n+ * the next call.\n+ *\n+ * Returns:\n+ *   0 - Success - birthrank, parent_sf_out and parent_frame_out are valid\n+ *   >1 - Pedigree walk completed\n+ *   <1 - Failure - -1: No worker bound to thread, -2: Sanity check failed\n+ */\n+\n+#define PEDIGREE_WALK_COMPLETE (__cilkrts_pedigree *)-1\n+\n+CILK_API_INT\n+__cilkrts_get_pedigree_info(__cilkrts_pedigree_context_t *external_context,\n+                            uint64_t *sf_birthrank)\n+{\n+    pedigree_context_t *context = (pedigree_context_t *)external_context;\n+\n+    CILK_ASSERT(sizeof(__cilkrts_pedigree_context_t) ==\n+                sizeof(pedigree_context_t));\n+    if (context->size != sizeof(pedigree_context_t))\n+        return -3;  // Invalid size\n+\n+    // If the pointer to the last __cilkrts_pedigree is -1, we've\n+    // finished the walk.  We're still done.\n+    if (PEDIGREE_WALK_COMPLETE == context->pedigree)\n+        return 1;\n+\n+    // The passed in context value contains a pointer to the last\n+    // __cilkrts_pedigree returned, or NULL if we're starting a\n+    // new walk\n+    if (NULL == context->pedigree)\n+    {\n+        __cilkrts_worker *w = __cilkrts_get_tls_worker();\n+\t__cilkrts_pedigree* pedigree_node;\n+        if (NULL != w) {\n+\t    pedigree_node = &w->pedigree;\n+\t}\n+\telse {\n+\t    pedigree_node = __cilkrts_get_tls_pedigree_leaf(1);\n+\t}\n+\tcontext->pedigree = pedigree_node->parent;\n+    }\n+    else\n+        context->pedigree = context->pedigree->parent;\n+\n+    // Note: If we want to omit the user root node,\n+    // stop at context->pedigree->parent instead.\n+    if (NULL == context->pedigree)\n+    {\n+\tcontext->pedigree = PEDIGREE_WALK_COMPLETE;\n+        return 1;\n+    }\n+\n+    *sf_birthrank = context->pedigree->rank;\n+    return 0;\n+}\n+\n+CILK_API_PEDIGREE\n+__cilkrts_get_pedigree_internal(__cilkrts_worker *w)\n+{\n+    if (NULL != w) {\n+\treturn w->pedigree;\n+    }\n+    else {\n+\tconst __cilkrts_pedigree *pedigree =\n+            __cilkrts_get_tls_pedigree_leaf(1);\n+\treturn *pedigree;\n+    }\n+}\n+\n+\n+CILK_API_INT __cilkrts_bump_worker_rank_internal(__cilkrts_worker *w)\n+{\n+    __cilkrts_pedigree *pedigree;\n+    pedigree = (w ? &w->pedigree : __cilkrts_get_tls_pedigree_leaf(1));\n+    pedigree->rank++;\n+    return 0;\n+}\n+\n+/* End cilk_api.c */"}, {"sha": "b9b47e364a5ecb41a90bb6e90221a30808459f02", "filename": "libcilkrts/runtime/cilk_fiber-unix.cpp", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber-unix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber-unix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_fiber-unix.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,273 @@\n+/* cilk_fiber-unix.cpp                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2012-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+#include \"cilk_fiber-unix.h\"\n+#include \"cilk_malloc.h\"\n+#include \"bug.h\"\n+#include \"os.h\"\n+\n+#include <cstdio>\n+#include <cstdlib>\n+\n+#include <alloca.h>\n+#include <errno.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+// MAP_ANON is deprecated on Linux, but seems to be required on Mac...\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+// Magic number for sanity checking fiber structure\n+const unsigned magic_number = 0x5afef00d;\n+\n+int cilk_fiber_sysdep::s_page_size = getpagesize();\n+\n+cilk_fiber_sysdep::cilk_fiber_sysdep(std::size_t stack_size)\n+    : cilk_fiber(stack_size)\n+    , m_magic(magic_number)\n+{\n+    // Set m_stack and m_stack_base.\n+    make_stack(stack_size);\n+\n+    // Get high-address of stack, with 32-bytes of spare space, and rounded\n+    // down to the nearest 32-byte boundary.\n+    const uintptr_t align_mask = 32 - 1;\n+    m_stack_base -= ((std::size_t) m_stack_base) & align_mask;\n+}\n+\n+cilk_fiber_sysdep::cilk_fiber_sysdep(from_thread_t)\n+    : cilk_fiber()\n+    , m_magic(magic_number)\n+{\n+    this->set_allocated_from_thread(true);\n+\n+    // Dummy stack data for thread-main fiber\n+    m_stack      = NULL;\n+    m_stack_base = NULL;\n+}\n+\n+void cilk_fiber_sysdep::convert_fiber_back_to_thread()\n+{\n+    // Does nothing on Linux.\n+}\n+\n+cilk_fiber_sysdep::~cilk_fiber_sysdep()\n+{\n+    CILK_ASSERT(magic_number == m_magic);\n+    if (!this->is_allocated_from_thread())\n+        free_stack();\n+}\n+\n+#if SUPPORT_GET_CURRENT_FIBER\n+cilk_fiber_sysdep* cilk_fiber_sysdep::get_current_fiber_sysdep()\n+{\n+    return cilkos_get_tls_cilk_fiber();\n+}\n+#endif\n+\n+// Jump to resume other fiber.  We may or may not come back.\n+inline void cilk_fiber_sysdep::resume_other_sysdep(cilk_fiber_sysdep* other)\n+{\n+    if (other->is_resumable()) {\n+        other->set_resumable(false);\n+        // Resume by longjmp'ing to the place where we suspended.\n+        CILK_LONGJMP(other->m_resume_jmpbuf);\n+    }\n+    else {\n+        // Otherwise, we've never ran this fiber before.  Start the\n+        // proc method.\n+        other->run();\n+    }\n+}\n+\n+void cilk_fiber_sysdep::suspend_self_and_resume_other_sysdep(cilk_fiber_sysdep* other)\n+{\n+#if SUPPORT_GET_CURRENT_FIBER\n+    cilkos_set_tls_cilk_fiber(other);\n+#endif\n+    CILK_ASSERT(this->is_resumable());\n+\n+\n+    // Jump to the other fiber.  We expect to come back.\n+    if (! CILK_SETJMP(m_resume_jmpbuf)) {\n+        resume_other_sysdep(other);\n+    }\n+\n+    // Return here when another fiber resumes me.\n+    // If the fiber that switched to me wants to be deallocated, do it now.\n+    do_post_switch_actions();\n+}\n+\n+NORETURN cilk_fiber_sysdep::jump_to_resume_other_sysdep(cilk_fiber_sysdep* other)\n+{\n+#if SUPPORT_GET_CURRENT_FIBER\n+    cilkos_set_tls_cilk_fiber(other);\n+#endif\n+    CILK_ASSERT(!this->is_resumable());\n+\n+    // Jump to the other fiber.  But we are never coming back because\n+    // this fiber is being reset.\n+    resume_other_sysdep(other);\n+\n+    // We should never come back here...\n+    __cilkrts_bug(\"Should not get here\");\n+}\n+\n+\n+NORETURN cilk_fiber_sysdep::run()\n+{\n+    // Only fibers created from a pool have a proc method to run and execute. \n+    CILK_ASSERT(m_start_proc);\n+    CILK_ASSERT(!this->is_allocated_from_thread());\n+    CILK_ASSERT(!this->is_resumable());\n+\n+    // TBD: This setjmp/longjmp pair simply changes the stack pointer.\n+    // We could probably replace this code with some assembly.\n+    if (! CILK_SETJMP(m_resume_jmpbuf))\n+    {\n+        // Calculate the size of the current stack frame (i.e., this\n+        // run() function.  \n+        size_t frame_size = (size_t)JMPBUF_FP(m_resume_jmpbuf) - (size_t)JMPBUF_SP(m_resume_jmpbuf);\n+\n+        // Macs require 16-byte alignment.  Do it always because it just\n+        // doesn't matter\n+        if (frame_size & (16-1))\n+            frame_size += 16 - (frame_size  & (16-1));\n+\n+        // Assert that we are getting a reasonable frame size out of\n+        // it.  If this run() function is using more than 4096 bytes\n+        // of space for its local variables / any state that spills to\n+        // registers, something is probably *very* wrong here...\n+        //\n+        // 4096 bytes just happens to be a number that seems \"large\n+        // enough\" --- for an example GCC 32-bit compilation, the\n+        // frame size was 48 bytes.\n+        CILK_ASSERT(frame_size < 4096);\n+\n+        // Change stack pointer to fiber stack.  Offset the\n+        // calculation by the frame size, so that we've allocated\n+        // enough extra space from the top of the stack we are\n+        // switching to for any temporaries required for this run()\n+        // function.\n+        JMPBUF_SP(m_resume_jmpbuf) = m_stack_base - frame_size;\n+        CILK_LONGJMP(m_resume_jmpbuf);\n+    }\n+\n+    // Note: our resetting of the stack pointer is valid only if the\n+    // compiler has not saved any temporaries onto the stack for this\n+    // function before the longjmp that we still care about at this\n+    // point.\n+    \n+    // Verify that 1) 'this' is still valid and 2) '*this' has not been\n+    // corrupted.\n+    CILK_ASSERT(magic_number == m_magic);\n+\n+    // If the fiber that switched to me wants to be deallocated, do it now.\n+    do_post_switch_actions();\n+\n+    // Now call the user proc on the new stack\n+    m_start_proc(this);\n+\n+    // alloca() to force generation of frame pointer.  The argument to alloca\n+    // is contrived to prevent the compiler from optimizing it away.  This\n+    // code should never actually be executed.\n+    int* dummy = (int*) alloca((sizeof(int) + (std::size_t) m_start_proc) & 0x1);\n+    *dummy = 0xface;\n+\n+    // User proc should never return.\n+    __cilkrts_bug(\"Should not get here\");\n+}\n+\n+void cilk_fiber_sysdep::make_stack(size_t stack_size)\n+{\n+    char* p;\n+    // We've already validated that the stack size is page-aligned and\n+    // is a reasonable value.  No need to do any extra rounding here.\n+    size_t rounded_stack_size = stack_size;\n+\n+    // Normally, we have already validated that the stack size is\n+    // aligned to 4K.  In the rare case that pages are huge though, we\n+    // need to do some extra checks.\n+    if (rounded_stack_size < 3 * (size_t)s_page_size) {\n+        // If the specified stack size is too small, round up to 3\n+        // pages.  We need at least 2 extra for the guard pages.\n+        rounded_stack_size = 3 * (size_t)s_page_size;\n+    }\n+    else {\n+        // Otherwise, the stack size is large enough, but might not be\n+        // a multiple of page size.  Round up to nearest multiple of\n+        // s_page_size, just to be safe.\n+        size_t remainder = rounded_stack_size % s_page_size;\n+        if (remainder) {\n+            rounded_stack_size += s_page_size - remainder;\n+        }\n+    }\n+\n+    p = (char*)mmap(0, rounded_stack_size,\n+                    PROT_READ|PROT_WRITE,\n+                    MAP_PRIVATE|MAP_ANONYMOUS,\n+                    -1, 0);\n+    if (MAP_FAILED == p) {\n+        // For whatever reason (probably ran out of memory), mmap() failed.\n+        // There is no stack to return, so the program loses parallelism.\n+        m_stack = NULL;\n+        m_stack_base = NULL;\n+        return;\n+    }\n+\n+    // mprotect guard pages.\n+    mprotect(p + rounded_stack_size - s_page_size, s_page_size, PROT_NONE);\n+    mprotect(p, s_page_size, PROT_NONE);\n+\n+    m_stack = p;\n+    m_stack_base = p + rounded_stack_size - s_page_size;\n+}\n+\n+\n+void cilk_fiber_sysdep::free_stack()\n+{\n+    if (m_stack) {\n+        size_t rounded_stack_size = m_stack_base - m_stack + s_page_size;\n+        if (munmap(m_stack, rounded_stack_size) < 0)\n+            __cilkrts_bug(\"Cilk: stack munmap failed error %d\\n\", errno);\n+    }\n+}\n+\n+/* End cilk_fiber-unix.cpp */"}, {"sha": "9f47d5b04373ee0d63106ff4ca16c2e8c34d861f", "filename": "libcilkrts/runtime/cilk_fiber-unix.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber-unix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber-unix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_fiber-unix.h?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,149 @@\n+/* cilk_fiber-unix.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2012-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+#ifndef INCLUDED_CILK_FIBER_UNIX_DOT_H\n+#define INCLUDED_CILK_FIBER_UNIX_DOT_H\n+\n+#ifndef __cplusplus\n+#   error cilk_fiber-unix.h is a C++-only header\n+#endif\n+\n+#include \"cilk_fiber.h\"\n+#include \"jmpbuf.h\"\n+\n+/**\n+ * @file cilk_fiber-unix.h\n+ *\n+ * @brief Unix-specific implementation for cilk_fiber.\n+ */\n+\n+/**\n+ * @brief Unix-specific fiber class derived from portable fiber class\n+ */\n+struct cilk_fiber_sysdep : public cilk_fiber\n+{\n+  public:\n+\n+#if SUPPORT_GET_CURRENT_FIBER\n+    /**\n+     * @brief Gets the current fiber from TLS.\n+     */\n+    static cilk_fiber_sysdep* get_current_fiber_sysdep();\n+#endif\n+\n+    /**\n+     * @brief Construct the system-dependent portion of a fiber.\n+     *\n+     * @param stack_size  The size of the stack for this fiber.\n+     */ \n+    cilk_fiber_sysdep(std::size_t stack_size);\n+\n+    /**\n+     * @brief Construct the system-dependent of a fiber created from a\n+     * thread.\n+     */ \n+    cilk_fiber_sysdep(from_thread_t);\n+\n+    /**\n+     * @brief Destructor\n+     */ \n+    ~cilk_fiber_sysdep();\n+\n+    /**\n+     * @brief OS-specific calls to convert this fiber back to thread.\n+     *\n+     * Nothing to do for Linux.\n+     */\n+    void convert_fiber_back_to_thread();\n+\n+    /**\n+     * @brief System-dependent function to suspend self and resume execution of \"other\".\n+     *\n+     * This fiber is suspended.\n+     *          \n+     * @pre @c is_resumable() should be true. \n+     *\n+     * @param other              Fiber to resume.\n+     */\n+    void suspend_self_and_resume_other_sysdep(cilk_fiber_sysdep* other);\n+\n+    /**\n+     * @brief System-dependent function called to jump to @p other\n+     * fiber.\n+     *\n+     * @pre @c is_resumable() should be false.\n+     *\n+     * @param other  Fiber to resume.\n+     */\n+    NORETURN jump_to_resume_other_sysdep(cilk_fiber_sysdep* other);\n+    \n+    /**\n+     * @brief Runs the start_proc.\n+     * @pre is_resumable() should be false.\n+     * @pre is_allocated_from_thread() should be false.\n+     * @pre m_start_proc must be valid.\n+     */\n+    NORETURN run();\n+\n+    /**\n+     * @brief Returns the base of this fiber's stack.\n+     */\n+    inline char* get_stack_base_sysdep() { return m_stack_base; }\n+\n+  private:\n+    char*                       m_stack_base;     ///< The base of this fiber's stack.\n+    char*                       m_stack;          // Stack memory (low address)\n+    __CILK_JUMP_BUFFER          m_resume_jmpbuf;  // Place to resume fiber\n+    unsigned                    m_magic;          // Magic number for checking\n+\n+    static int                  s_page_size;      // Page size for\n+                                                  // stacks.\n+\n+    // Allocate memory for a stack.  This method\n+    // initializes m_stack and m_stack_base.\n+    void make_stack(size_t stack_size);\n+\n+    // Deallocates memory for the stack.\n+    void free_stack();\n+\n+    // Common helper method for implementation of resume_other_sysdep\n+    // variants.\n+    inline void resume_other_sysdep(cilk_fiber_sysdep* other);\n+};\n+\n+#endif // ! defined(INCLUDED_CILK_FIBER_UNIX_DOT_H)"}, {"sha": "0c66f234d3bae6baf64c6309c44b2fc2e9d6277d", "filename": "libcilkrts/runtime/cilk_fiber.cpp", "status": "added", "additions": 1078, "deletions": 0, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_fiber.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b", "patch": "@@ -0,0 +1,1078 @@\n+/* cilk_fiber.cpp                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2012-2013, Intel Corporation\n+ *  All rights reserved.\n+ *  \n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *  \n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *  \n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ **************************************************************************/\n+\n+/* Implementations of non-platform-specific aspects of cilk_fiber, especially\n+ * the cilk_fiber_pool interface.\n+ */\n+#include \"cilk_fiber.h\"\n+#ifdef _WIN32\n+#   include \"cilk_fiber-win.h\"\n+#else\n+#   include \"cilk_fiber-unix.h\"\n+#endif\n+#include \"cilk_malloc.h\"\n+#include \"bug.h\"\n+#include <new>\n+\n+#include <climits>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+\n+#include \"sysdep.h\"\n+\n+\n+extern \"C\" {\n+\n+inline int cilk_fiber_pool_sanity_check(cilk_fiber_pool *pool, const char* desc)\n+{\n+    int errors = 0;\n+#if FIBER_DEBUG >= 1    \n+    if ((NULL != pool) && pool->total > 0) {\n+\n+        // Root pool should not allocate more fibers than alloc_max\n+        errors += ((pool->parent == NULL) &&\n+                   (pool->total > pool->alloc_max));\n+        errors += (pool->total > pool->high_water);\n+\n+        if (errors) {\n+            fprintf(stderr, \"ERROR at %s: pool=%p has max_size=%u, total=%d, high_water=%d\\n\",\n+                    desc,\n+                    pool, pool->max_size, pool->total, pool->high_water);\n+        }\n+    }\n+#endif\n+    return (errors == 0);\n+}\n+\n+inline void increment_pool_total(cilk_fiber_pool* pool)\n+{\n+    ++pool->total;\n+    if (pool->high_water < pool->total)\n+        pool->high_water = pool->total;\n+}\n+\n+inline void decrement_pool_total(cilk_fiber_pool* pool, int fibers_freed)\n+{\n+    pool->total -= fibers_freed;\n+}\n+\n+\n+/**\n+ * @brief Free fibers from this pool until we have at most @c\n+ * num_to_keep fibers remaining, and then put a fiber back.\n+ *\n+ * @pre   We do not hold @c pool->lock \n+ * @post  After completion, we do not hold @c pool->lock\n+ */\n+static void cilk_fiber_pool_free_fibers_from_pool(cilk_fiber_pool* pool,\n+                                                  unsigned num_to_keep,\n+                                                  cilk_fiber* fiber_to_return)\n+{\n+    // Free our own fibers, until we fall below our desired threshold.\n+    // Each iteration of this loop proceeds in the following stages:\n+    //   1.  Acquire the pool lock,\n+    //   2.  Grabs up to B fibers from the pool, stores them into a buffer.\n+    //   3.  Check if pool is empty enough.  If yes, put the last fiber back,\n+    //       and remember that we should quit.\n+    //   4.  Release the pool lock, and actually free any buffered fibers.\n+    //   5.  Check if we are done and should exit the loop.  Otherwise, try again.\n+    // \n+    const bool need_lock = pool->lock;\n+    bool last_fiber_returned = false;\n+    \n+    do {\n+        const int B = 10;   // Pull at most this many fibers from the\n+                            // parent for one lock acquisition.  Make\n+                            // this value large enough to amortize\n+                            // against the cost of acquiring and\n+                            // releasing the lock.\n+        int num_to_free = 0;\n+        cilk_fiber* fibers_to_free[B];\n+\n+        // Stage 1: Grab the lock.\n+        if (need_lock) {\n+            spin_mutex_lock(pool->lock);\n+        }\n+        \n+        // Stage 2: Grab up to B fibers to free.\n+        int fibers_freed = 0;\n+        while ((pool->size > num_to_keep) && (num_to_free < B)) {\n+            fibers_to_free[num_to_free++] = pool->fibers[--pool->size];\n+            fibers_freed++;\n+        }\n+        decrement_pool_total(pool, fibers_freed);\n+\n+        // Stage 3.  Pool is below threshold.  Put extra fiber back.\n+        if (pool->size <= num_to_keep) {\n+            // Put the last fiber back into the pool.\n+            if (fiber_to_return) {\n+                CILK_ASSERT(pool->size < pool->max_size);\n+                pool->fibers[pool->size] = fiber_to_return;\n+                pool->size++;\n+            }\n+            last_fiber_returned = true;\n+        }\n+        \n+        // Stage 4: Release the lock, and actually free any fibers\n+        // buffered.\n+        if (need_lock) {\n+            spin_mutex_unlock(pool->lock);\n+        }\n+\n+        for (int i = 0; i < num_to_free; ++i) {\n+            fibers_to_free[i]->deallocate_to_heap();\n+        }\n+        \n+    } while (!last_fiber_returned);\n+}\n+\n+\n+/******************************************************************\n+ * TBD: We want to simplify / rework the logic for allocating and\n+ * deallocating fibers, so that they are hopefully simpler and work\n+ * more elegantly for more than two levels.\n+ ******************************************************************/\n+\n+/**\n+ * @brief Transfer fibers from @c pool to @c pool->parent.\n+ *\n+ * @pre   Must hold @c pool->lock if it exists.\n+ * @post  After completion, some number of fibers\n+ *        have been moved from this pool to the parent.\n+ *        The lock @c pool->lock is still held.\n+ *\n+ * TBD: Do we wish to guarantee that the lock has never been\n+ * released?  It may depend on the implementation...\n+ */\n+static void cilk_fiber_pool_move_fibers_to_parent_pool(cilk_fiber_pool* pool,\n+                                                       unsigned num_to_keep)\n+{\n+    // ASSERT: We should hold the lock on pool (if it has one).\n+    CILK_ASSERT(pool->parent);\n+    cilk_fiber_pool* parent_pool = pool->parent;\n+\n+    // Move fibers from our pool to the parent until we either run out\n+    // of space in the parent, or hit our threshold.\n+    //\n+    // This operation must be done while holding the parent lock.\n+\n+    // If the parent pool appears to be full, just return early.\n+    if (parent_pool->size >= parent_pool->max_size)\n+        return;\n+\n+    spin_mutex_lock(pool->parent->lock);\n+    while ((parent_pool->size < parent_pool->max_size) &&\n+           (pool->size > num_to_keep)) {\n+        parent_pool->fibers[parent_pool->size++] =\n+            pool->fibers[--pool->size];\n+    }\n+\n+    // If the child pool has deallocated more than fibers to the heap\n+    // than it has allocated, then transfer this \"surplus\" to the\n+    // parent, so that the parent is free to allocate more from the\n+    // heap.\n+    // \n+    // This transfer means that the total in the parent can\n+    // temporarily go negative.\n+    if (pool->total < 0) {\n+        // Reduce parent total by the surplus we have in the local\n+        // pool.\n+        parent_pool->total += pool->total;\n+        pool->total = 0;\n+    }\n+\n+    spin_mutex_unlock(pool->parent->lock);\n+}\n+    \n+void cilk_fiber_pool_init(cilk_fiber_pool* pool,\n+                          cilk_fiber_pool* parent,\n+                          size_t           stack_size,\n+                          unsigned         buffer_size,\n+                          int              alloc_max,\n+                          int              is_shared)\n+{\n+#if FIBER_DEBUG >= 1    \n+    fprintf(stderr, \"fiber_pool_init, pool=%p, parent=%p, alloc_max=%u\\n\",\n+            pool, parent, alloc_max);\n+#endif\n+\n+    pool->lock       = (is_shared ? spin_mutex_create() : NULL);\n+    pool->parent     = parent;\n+    pool->stack_size = stack_size;\n+    pool->max_size   = buffer_size;\n+    pool->size       = 0;\n+    pool->total      = 0;\n+    pool->high_water = 0;\n+    pool->alloc_max  = alloc_max;\n+    pool->fibers     =\n+        (cilk_fiber**) __cilkrts_malloc(buffer_size * sizeof(cilk_fiber*));\n+    CILK_ASSERT(NULL != pool->fibers);\n+\n+#ifdef __MIC__\n+#define PREALLOCATE_FIBERS\n+#endif\n+    \n+#ifdef PREALLOCATE_FIBERS\n+    // Pre-allocate 1/4 of fibers in the pools ahead of time.  This\n+    // value is somewhat arbitrary.  It was chosen to be less than the\n+    // threshold (of about 3/4) of fibers to keep in the pool when\n+    // transferring fibers to the parent.\n+    \n+    int pre_allocate_count = buffer_size/4;\n+    for (pool->size = 0; pool->size < pre_allocate_count; pool->size++) {\n+        pool->fibers[pool->size] = cilk_fiber::allocate_from_heap(pool->stack_size);\n+    }\n+#endif\n+}\n+\n+\n+void cilk_fiber_pool_set_fiber_limit(cilk_fiber_pool* root_pool,\n+                                     unsigned max_fibers_to_allocate)\n+{\n+    // Should only set limit on root pool, not children.\n+    CILK_ASSERT(NULL == root_pool->parent);\n+    root_pool->alloc_max = max_fibers_to_allocate;\n+}\n+                                   \n+void cilk_fiber_pool_destroy(cilk_fiber_pool* pool)\n+{\n+    CILK_ASSERT(cilk_fiber_pool_sanity_check(pool, \"pool_destroy\"));\n+\n+    // Lock my own pool, if I need to.\n+    if (pool->lock) {\n+        spin_mutex_lock(pool->lock);\n+    }\n+\n+    // Give any remaining fibers to parent pool.\n+    if (pool->parent) {\n+        cilk_fiber_pool_move_fibers_to_parent_pool(pool, 0);\n+    }\n+\n+    // Unlock pool.\n+    if (pool->lock) {\n+        spin_mutex_unlock(pool->lock);\n+    }\n+\n+    // If I have any left in my pool, just free them myself.\n+    // This method may acquire the pool lock.\n+    cilk_fiber_pool_free_fibers_from_pool(pool, 0, NULL);\n+\n+    // Destroy the lock if there is one.\n+    if (pool->lock) {\n+        spin_mutex_destroy(pool->lock);\n+    }\n+    __cilkrts_free(pool->fibers);\n+}\n+\n+\n+cilk_fiber* cilk_fiber_allocate(cilk_fiber_pool* pool)\n+{\n+    CILK_ASSERT(cilk_fiber_pool_sanity_check(pool, \"allocate\"));\n+    return cilk_fiber::allocate(pool);\n+}\n+\n+cilk_fiber* cilk_fiber_allocate_from_heap(size_t stack_size)\n+{\n+    return cilk_fiber::allocate_from_heap(stack_size);\n+}\n+\n+void cilk_fiber_reset_state(cilk_fiber* fiber, cilk_fiber_proc start_proc) \n+{\n+    fiber->reset_state(start_proc);\n+}\n+\n+int cilk_fiber_remove_reference(cilk_fiber *fiber, cilk_fiber_pool *pool)\n+{\n+    return fiber->remove_reference(pool);\n+}\n+\n+cilk_fiber* cilk_fiber_allocate_from_thread()\n+{\n+    return cilk_fiber::allocate_from_thread();\n+}\n+\n+int cilk_fiber_deallocate_from_thread(cilk_fiber *fiber)\n+{\n+    return fiber->deallocate_from_thread();\n+}\n+\n+int cilk_fiber_remove_reference_from_thread(cilk_fiber *fiber)\n+{\n+    return fiber->remove_reference_from_thread();\n+}\n+\n+int cilk_fiber_is_allocated_from_thread(cilk_fiber *fiber)\n+{\n+    return fiber->is_allocated_from_thread();\n+}\n+\n+#if SUPPORT_GET_CURRENT_FIBER\n+cilk_fiber* cilk_fiber_get_current_fiber(void)\n+{\n+    return cilk_fiber::get_current_fiber();\n+}\n+#endif\n+\n+void cilk_fiber_suspend_self_and_resume_other(cilk_fiber* self,\n+                                              cilk_fiber* other)\n+{\n+    self->suspend_self_and_resume_other(other);\n+}\n+\n+\n+void cilk_fiber::reset_state(cilk_fiber_proc start_proc)\n+{\n+    // Setup the fiber and return.\n+    this->m_start_proc = start_proc;\n+    \n+    CILK_ASSERT(!this->is_resumable());\n+    CILK_ASSERT(NULL == this->m_pending_remove_ref);\n+    CILK_ASSERT(NULL == this->m_pending_pool);\n+}\n+\n+NORETURN\n+cilk_fiber_remove_reference_from_self_and_resume_other(cilk_fiber*      self,\n+                                                       cilk_fiber_pool* self_pool,\n+                                                       cilk_fiber*      other)\n+{\n+#if FIBER_DEBUG >= 3\n+    __cilkrts_worker* w = __cilkrts_get_tls_worker();\n+    fprintf(stderr, \"W=%d: cilk_fiber_deactivate_self_and_resume_other: self=%p, other=%p\\n\",\n+            w->self,\n+            self, other);\n+#endif\n+    CILK_ASSERT(cilk_fiber_pool_sanity_check(self_pool, \"remove_reference_from_self_resume_other\"));\n+    self->remove_reference_from_self_and_resume_other(self_pool, other);\n+    \n+    // We should never return here. \n+}\n+\n+void cilk_fiber_set_post_switch_proc(cilk_fiber *self,\n+                                     cilk_fiber_proc post_switch_proc)\n+{\n+    self->set_post_switch_proc(post_switch_proc);\n+}\n+\n+void cilk_fiber_invoke_tbb_stack_op(cilk_fiber* fiber,\n+                                    __cilk_tbb_stack_op op)\n+{\n+    fiber->invoke_tbb_stack_op(op);\n+}\n+\n+cilk_fiber_data* cilk_fiber_get_data(cilk_fiber* fiber)\n+{\n+    return fiber->get_data();\n+\n+    /// TBD: Change this code to \"return (cilk_fiber_data*)fiber;\"\n+    //       plus a static assert, so that this function is \n+    //       more easily inlined by the compiler.\n+}\n+\n+int cilk_fiber_is_resumable(cilk_fiber *fiber)\n+{\n+    return fiber->is_resumable();\n+}\n+\n+char* cilk_fiber_get_stack_base(cilk_fiber *fiber)\n+{\n+    return fiber->get_stack_base();\n+}\n+\n+\n+#if defined(_WIN32) && 0 // Only works on Windows.  Disable debugging for now.\n+#define DBG_STACK_OPS(_fmt, ...) __cilkrts_dbgprintf(_fmt, __VA_ARGS__)\n+#else\n+#define DBG_STACK_OPS(_fmt, ...)\n+#endif\n+\n+void cilk_fiber_set_stack_op(cilk_fiber *fiber,\n+                             __cilk_tbb_stack_op_thunk o)\n+{\n+    cilk_fiber_data *fdata = cilk_fiber_get_data(fiber);\n+    DBG_STACK_OPS (\"cilk_fiber_set_stack_op - cilk_fiber %p, routine: %p, data: %p\\n\",\n+                   fiber,\n+                   o.routine,\n+                   o.data);\n+    fdata->stack_op_routine = o.routine;\n+    fdata->stack_op_data = o.data;\n+}\n+\n+#if 0    // Debugging function\n+static\n+const char *NameStackOp (enum __cilk_tbb_stack_op op)\n+{\n+    switch(op)\n+    {\n+        case CILK_TBB_STACK_ORPHAN: return \"CILK_TBB_STACK_ORPHAN\";\n+        case CILK_TBB_STACK_ADOPT: return \"CILK_TBB_STACK_ADOPT\";\n+        case CILK_TBB_STACK_RELEASE: return \"CILK_TBB_STACK_RELEASE\";\n+        default: return \"Unknown\";\n+    }\n+}\n+#endif\n+\n+/*\n+ * Save TBB interop information for an unbound thread.  It will get picked\n+ * up when the thread is bound to the runtime.\n+ */\n+void cilk_fiber_tbb_interop_save_stack_op_info(__cilk_tbb_stack_op_thunk o)\n+{\n+    __cilk_tbb_stack_op_thunk *saved_thunk =\n+        __cilkrts_get_tls_tbb_interop();\n+\n+    DBG_STACK_OPS(\"Calling save_stack_op; o.routine=%p, o.data=%p, saved_thunk=%p\\n\",\n+                  o.routine, o.data, saved_thunk);\n+\n+    // If there is not already space allocated, allocate some.\n+    if (NULL == saved_thunk) {\n+        saved_thunk = (__cilk_tbb_stack_op_thunk*)\n+            __cilkrts_malloc(sizeof(__cilk_tbb_stack_op_thunk));\n+        __cilkrts_set_tls_tbb_interop(saved_thunk);\n+    }\n+\n+    *saved_thunk = o;\n+\n+    DBG_STACK_OPS (\"Unbound Thread %04x: tbb_interop_save_stack_op_info - saved info\\n\",\n+                   cilkos_get_current_thread_id());\n+}\n+\n+/*\n+ * Save TBB interop information from the cilk_fiber.  It will get picked\n+ * up when the thread is bound to the runtime next time.\n+ */\n+void cilk_fiber_tbb_interop_save_info_from_stack(cilk_fiber *fiber)\n+{\n+    __cilk_tbb_stack_op_thunk *saved_thunk;\n+    cilk_fiber_data* fdata;\n+\n+    if (NULL == fiber)\n+        return;\n+\n+    fdata = cilk_fiber_get_data(fiber);\n+    // If there is no TBB interop data, just return\n+    if (NULL == fdata->stack_op_routine)\n+        return;\n+    \n+    saved_thunk = __cilkrts_get_tls_tbb_interop();\n+\n+    // If there is not already space allocated, allocate some.\n+    if (NULL == saved_thunk) {\n+        saved_thunk = (__cilk_tbb_stack_op_thunk*)\n+            __cilkrts_malloc(sizeof(__cilk_tbb_stack_op_thunk));\n+        __cilkrts_set_tls_tbb_interop(saved_thunk);\n+    }\n+\n+    saved_thunk->routine = fdata->stack_op_routine;\n+    saved_thunk->data = fdata->stack_op_data;\n+}\n+\n+/*\n+ * If there's TBB interop information that was saved before the thread was\n+ * bound, apply it now\n+ */\n+void cilk_fiber_tbb_interop_use_saved_stack_op_info(cilk_fiber* fiber)\n+{\n+    __cilk_tbb_stack_op_thunk *saved_thunk =\n+        __cilkrts_get_tls_tbb_interop();\n+\n+    CILK_ASSERT(fiber);\n+    // If we haven't allocated a TBB interop index, we don't have any saved info\n+    if (NULL == saved_thunk) {\n+        DBG_STACK_OPS (\"cilk_fiber %p: tbb_interop_use_saved_stack_op_info - no saved info\\n\",\n+                       fiber);\n+        return;\n+    }\n+\n+    DBG_STACK_OPS (\"cilk_fiber %p: tbb_interop_use_saved_stack_op_info - using saved info\\n\",\n+                   fiber);\n+\n+     // Associate the saved info with the __cilkrts_stack\n+    cilk_fiber_set_stack_op(fiber, *saved_thunk);\n+    \n+    // Free the saved data.  We'll save it again if needed when the code\n+    // returns from the initial function\n+    cilk_fiber_tbb_interop_free_stack_op_info();\n+}\n+\n+/*\n+ * Free saved TBB interop memory.  Should only be called when the thread is\n+ * not bound.\n+ */\n+void cilk_fiber_tbb_interop_free_stack_op_info(void)\n+{\n+    __cilk_tbb_stack_op_thunk *saved_thunk =\n+        __cilkrts_get_tls_tbb_interop();\n+\n+    // If we haven't allocated a TBB interop index, we don't have any saved info\n+    if (NULL == saved_thunk)\n+        return;\n+\n+    DBG_STACK_OPS (\"tbb_interop_free_stack_op_info - freeing saved info\\n\");\n+\n+    // Free the memory and wipe out the TLS value\n+    __cilkrts_free(saved_thunk);\n+    __cilkrts_set_tls_tbb_interop(NULL);\n+}\n+\n+\n+\n+#if NEED_FIBER_REF_COUNTS\n+int cilk_fiber_has_references(cilk_fiber *fiber) \n+{\n+    return (fiber->get_ref_count() > 0);\n+}\n+\n+int cilk_fiber_get_ref_count(cilk_fiber *fiber)\n+{\n+    return fiber->get_ref_count();\n+}\n+\n+void cilk_fiber_add_reference(cilk_fiber *fiber)\n+{\n+    fiber->inc_ref_count();\n+}\n+#endif // NEED_FIBER_REF_COUNTS\n+\n+\n+} // End extern \"C\"\n+\n+\n+cilk_fiber_sysdep* cilk_fiber::sysdep()\n+{\n+    return static_cast<cilk_fiber_sysdep*>(this);\n+}\n+\n+\n+cilk_fiber::cilk_fiber()\n+    : m_start_proc(NULL)\n+    , m_post_switch_proc(NULL)\n+    , m_pending_remove_ref(NULL)\n+    , m_pending_pool(NULL)\n+    , m_flags(0)\n+{\n+    // Clear cilk_fiber_data base-class data members\n+    std::memset((cilk_fiber_data*) this, 0, sizeof(cilk_fiber_data));\n+\n+    // cilk_fiber data members\n+    init_ref_count(0);\n+}\n+\n+cilk_fiber::cilk_fiber(std::size_t stack_size)\n+{\n+    *this = cilk_fiber();  // A delegating constructor would be nice here\n+    this->stack_size = stack_size;\n+}\n+\n+cilk_fiber::~cilk_fiber() \n+{\n+    // Empty destructor.\n+}\n+\n+\n+char* cilk_fiber::get_stack_base()\n+{\n+    return this->sysdep()->get_stack_base_sysdep();\n+}\n+\n+cilk_fiber* cilk_fiber::allocate_from_heap(std::size_t stack_size)\n+{\n+    // Case 1: pool is NULL. create a new fiber from the heap\n+    // No need for locks here.\n+    cilk_fiber_sysdep* ret =\n+        (cilk_fiber_sysdep*) __cilkrts_malloc(sizeof(cilk_fiber_sysdep));\n+\n+    // Error condition. If we failed to allocate a fiber from the\n+    // heap, we are in trouble though...\n+    if (!ret)\n+        return NULL;\n+\n+    ::new(ret) cilk_fiber_sysdep(stack_size);\n+\n+    CILK_ASSERT(0 == ret->m_flags);\n+    CILK_ASSERT(NULL == ret->m_pending_remove_ref);\n+    CILK_ASSERT(NULL == ret->m_pending_pool);\n+    ret->init_ref_count(1);\n+    return ret;\n+}\n+\n+\n+#if USE_FIBER_TRY_ALLOCATE_FROM_POOL\n+/**\n+ * Helper method: try to allocate a fiber from this pool or its\n+ * ancestors without going to the OS / heap.\n+ *\n+ * Returns allocated pool, or NULL if no pool is found.\n+ *\n+ * If pool contains a suitable fiber. Return it.  Otherwise, try to\n+ * recursively grab a fiber from the parent pool, if there is one.\n+ *\n+ * This method will not allocate a fiber from the heap.\n+ *\n+ * This method could be written either recursively or iteratively.\n+ * It probably does not matter which one we do.\n+ *\n+ * @note This method is compiled, but may not be used unless the\n+ * USE_FIBER_TRY_ALLOCATE_FROM_POOL switch is set.\n+ */\n+cilk_fiber* cilk_fiber::try_allocate_from_pool_recursive(cilk_fiber_pool* pool)\n+{\n+    cilk_fiber* ret = NULL;\n+\n+    if (pool->size > 0) {\n+        // Try to get the lock.\n+        if (pool->lock) {\n+            // For some reason, it seems to be better to just block on the parent\n+            // pool lock, instead of using a try-lock?\n+#define USE_TRY_LOCK_IN_FAST_ALLOCATE 0\n+#if USE_TRY_LOCK_IN_FAST_ALLOCATE\n+            int got_lock = spin_mutex_trylock(pool->lock);\n+            if (!got_lock) {\n+                // If we fail, skip to the parent.\n+                if (pool->parent) {\n+                    return try_allocate_from_pool_recursive(pool->parent);\n+                }\n+            }\n+#else\n+            spin_mutex_lock(pool->lock);\n+#endif\n+        }\n+\n+        // Check in the pool if we have the lock.\n+        if (pool->size > 0) {\n+            ret = pool->fibers[--pool->size];\n+        }\n+\n+        // Release the lock once we are done updating pool fields.\n+        if (pool->lock) {\n+            spin_mutex_unlock(pool->lock);\n+        }\n+    }\n+\n+    if ((!ret) && (pool->parent)) {\n+        return try_allocate_from_pool_recursive(pool->parent);\n+    }\n+\n+    if (ret) {\n+        // When we pull a fiber out of the pool, set its reference\n+        // count before we return it.\n+        ret->init_ref_count(1);\n+    }\n+    return ret;\n+}\n+#endif // USE_FIBER_TRY_ALLOCATE_FROM_POOL\n+\n+\n+cilk_fiber* cilk_fiber::allocate(cilk_fiber_pool* pool)\n+{\n+    // Pool should not be NULL in this method.  But I'm not going to\n+    // actually assert it, because we are likely to seg fault anyway\n+    // if it is.\n+    // CILK_ASSERT(NULL != pool);\n+\n+    cilk_fiber *ret = NULL;\n+\n+#if USE_FIBER_TRY_ALLOCATE_FROM_POOL\n+    // \"Fast\" path, which doesn't go to the heap or OS until checking\n+    // the ancestors first.\n+    ret = try_allocate_from_pool_recursive(pool);\n+    if (ret)\n+        return ret;\n+#endif\n+\n+    // If we don't get anything from the \"fast path\", then go through\n+    // a slower path to look for a fiber.\n+    //\n+    //  1. Lock the pool if it is shared.\n+    //  2. Look in our local pool.  If we find one, release the lock\n+    //     and quit searching.\n+    //  3. Otherwise, check whether we can allocate from heap.\n+    //  4. Release the lock if it was acquired.\n+    //  5. Try to allocate from the heap, if step 3 said we could.\n+    //     If we find a fiber, then quit searching.\n+    //  6. If none of these steps work, just recursively try again\n+    //     from the parent.\n+\n+    // 1. Lock the pool if it is shared.\n+    if (pool->lock) {\n+        spin_mutex_lock(pool->lock);\n+    }\n+\n+    // 2. Look in local pool.\n+    if (pool->size > 0) {\n+        ret = pool->fibers[--pool->size];\n+        if (ret) {\n+            // If we found one, release the lock once we are\n+            // done updating pool fields, and break out of the\n+            // loop.\n+            if (pool->lock) {\n+                spin_mutex_unlock(pool->lock);\n+            }\n+\n+            // When we pull a fiber out of the pool, set its reference\n+            // count just in case.\n+            ret->init_ref_count(1);\n+            return ret;\n+        }\n+    }\n+\n+    // 3. Check whether we can allocate from the heap.\n+    bool can_allocate_from_heap = false;\n+    if (pool->total < pool->alloc_max) {\n+        // Track that we are allocating a new fiber from the\n+        // heap, originating from this pool.\n+        // This increment may be undone if we happen to fail to\n+        // allocate from the heap.\n+        increment_pool_total(pool);\n+        can_allocate_from_heap = true;\n+    }\n+\n+    // 4. Unlock the pool, and then allocate from the heap.\n+    if (pool->lock) {\n+        spin_mutex_unlock(pool->lock);\n+    }\n+\n+    // 5. Actually try to allocate from the heap / OS.\n+    if (can_allocate_from_heap) {\n+        ret = allocate_from_heap(pool->stack_size);\n+        // If we got something from the heap, just return it.\n+        if (ret) {\n+            return ret;\n+        }\n+\n+        // Otherwise, we failed in our attempt to allocate a\n+        // fiber from the heap.  Grab the lock and decrement\n+        // the total again.\n+        if (pool->lock) {\n+            spin_mutex_lock(pool->lock);\n+        }\n+        decrement_pool_total(pool, 1);\n+        if (pool->lock) {\n+            spin_mutex_unlock(pool->lock);\n+        }\n+    }\n+\n+    // 6. If we get here, then searching this pool failed.  Go search\n+    // the parent instead if we have one.\n+    if (pool->parent) {\n+        return allocate(pool->parent);\n+    }\n+    \n+    return ret;\n+}\n+\n+int cilk_fiber::remove_reference(cilk_fiber_pool* pool)\n+{\n+    int ref_count = this->dec_ref_count();\n+    if (ref_count == 0) {\n+        if (pool) {\n+            deallocate_self(pool);\n+        }\n+        else {\n+            deallocate_to_heap();\n+        }\n+    }\n+    return ref_count;\n+}\n+\n+cilk_fiber* cilk_fiber::allocate_from_thread()\n+{\n+    void* retmem = __cilkrts_malloc(sizeof(cilk_fiber_sysdep));\n+    CILK_ASSERT(retmem);\n+    cilk_fiber_sysdep* ret = ::new(retmem) cilk_fiber_sysdep(from_thread);\n+\n+    // A fiber allocated from a thread begins with a reference count\n+    // of 2.  The first is for being created, and the second is for\n+    // being running.\n+    //\n+    // Suspending this fiber will decrement the count down to 1.\n+    ret->init_ref_count(2);\n+\n+#if SUPPORT_GET_CURRENT_FIBER    \n+    // We're creating the main fiber for this thread. Set this fiber as the\n+    // current fiber.\n+    cilkos_set_tls_cilk_fiber(ret);\n+#endif\n+    return ret;\n+}\n+\n+int cilk_fiber::deallocate_from_thread()\n+{\n+    CILK_ASSERT(this->is_allocated_from_thread());\n+#if SUPPORT_GET_CURRENT_FIBER\n+    CILK_ASSERT(this == cilkos_get_tls_cilk_fiber());\n+    // Reverse of \"allocate_from_thread\".\n+    cilkos_set_tls_cilk_fiber(NULL);\n+#endif\n+\n+    this->assert_ref_count_at_least(2);\n+\n+    // Suspending the fiber should conceptually decrement the ref\n+    // count by 1.\n+    cilk_fiber_sysdep* self = this->sysdep();\n+    self->convert_fiber_back_to_thread();\n+\n+    // Then, freeing the fiber itself decrements the ref count again.\n+    int ref_count = this->sub_from_ref_count(2);\n+    if (ref_count == 0) {\n+        self->~cilk_fiber_sysdep();\n+        __cilkrts_free(self);\n+    }\n+    return ref_count;\n+}\n+\n+int cilk_fiber::remove_reference_from_thread()\n+{\n+    int ref_count = dec_ref_count();\n+    if (ref_count == 0) {\n+        cilk_fiber_sysdep* self = this->sysdep();\n+        self->~cilk_fiber_sysdep();\n+        __cilkrts_free(self);\n+    }\n+    return ref_count;\n+}\n+\n+\n+#if SUPPORT_GET_CURRENT_FIBER\n+cilk_fiber* cilk_fiber::get_current_fiber()\n+{\n+    return cilk_fiber_sysdep::get_current_fiber_sysdep();\n+}\n+#endif\n+\n+void cilk_fiber::do_post_switch_actions()\n+{\n+    if (m_post_switch_proc) \n+    {\n+        cilk_fiber_proc proc = m_post_switch_proc;\n+        m_post_switch_proc = NULL;\n+        proc(this);\n+    }\n+\n+    if (m_pending_remove_ref)\n+    {\n+        m_pending_remove_ref->remove_reference(m_pending_pool);\n+\n+        // Even if we don't free it, \n+        m_pending_remove_ref = NULL;\n+        m_pending_pool   = NULL;\n+    }\n+}\n+\n+void cilk_fiber::suspend_self_and_resume_other(cilk_fiber* other)\n+{\n+#if FIBER_DEBUG >=1\n+    fprintf(stderr, \"suspend_self_and_resume_other: self =%p, other=%p [owner=%p, resume_sf=%p]\\n\",\n+            this, other, other->owner, other->resume_sf);\n+#endif\n+\n+    // Decrement my reference count (to suspend)\n+    // Increment other's count (to resume)\n+    // Suspended fiber should have a reference count of at least 1.  (It is not in a pool).\n+    this->dec_ref_count();\n+    other->inc_ref_count();\n+    this->assert_ref_count_at_least(1);\n+\n+    // Pass along my owner.\n+    other->owner = this->owner;\n+    this->owner  = NULL;\n+\n+    // Change this fiber to resumable.\n+    CILK_ASSERT(!this->is_resumable());\n+    this->set_resumable(true);\n+\n+    // Normally, I'd assert other->is_resumable().  But this flag may\n+    // be false the first time we try to \"resume\" a fiber.\n+    cilk_fiber_sysdep* self = this->sysdep();\n+    self->suspend_self_and_resume_other_sysdep(other->sysdep());\n+\n+    // HAVE RESUMED EXECUTION\n+    // When we come back here, we should have at least two references:\n+    // one for the fiber being allocated / out of a pool, and one for it being active.\n+    this->assert_ref_count_at_least(2);\n+}\n+\n+NORETURN\n+cilk_fiber::remove_reference_from_self_and_resume_other(cilk_fiber_pool* self_pool,\n+                                                        cilk_fiber*      other)\n+{\n+    // Decrement my reference count once (to suspend)\n+    // Increment other's count (to resume)\n+    // Suspended fiber should have a reference count of at least 1.  (It is not in a pool).\n+    this->dec_ref_count();\n+    other->inc_ref_count();\n+\n+    // Set a pending remove reference for this fiber, once we have\n+    // actually switched off.\n+    other->m_pending_remove_ref = this;\n+    other->m_pending_pool   = self_pool;\n+\n+    // Pass along my owner.\n+    other->owner = this->owner;\n+    this->owner  = NULL;\n+\n+    // Since we are deallocating self, this fiber does not become\n+    // resumable.\n+    CILK_ASSERT(!this->is_resumable());\n+\n+    cilk_fiber_sysdep* self = this->sysdep();\n+    self->jump_to_resume_other_sysdep(other->sysdep());\n+\n+    __cilkrts_bug(\"Deallocating fiber.  We should never come back here.\");\n+    std::abort();\n+}\n+\n+\n+void cilk_fiber::deallocate_to_heap()\n+{\n+    cilk_fiber_sysdep* self = this->sysdep();\n+    self->~cilk_fiber_sysdep();\n+    __cilkrts_free(self);\n+}\n+\n+void cilk_fiber::deallocate_self(cilk_fiber_pool* pool)\n+{\n+    this->set_resumable(false);\n+\n+    CILK_ASSERT(NULL != pool);\n+    CILK_ASSERT(!this->is_allocated_from_thread());\n+    this->assert_ref_count_equals(0);\n+    \n+    // Cases: \n+    //\n+    // 1. pool has space:  Add to this pool.\n+    // 2. pool is full:    Give some fibers to parent, and then free\n+    //                     enough to make space for the fiber we are deallocating.\n+    //                     Then put the fiber back into the pool.\n+    \n+    const bool need_lock = pool->lock;\n+    // Grab the lock for the remaining cases.\n+    if (need_lock) {\n+        spin_mutex_lock(pool->lock);\n+    }\n+\n+    // Case 1: this pool has space.  Return the fiber.\n+    if (pool->size < pool->max_size)\n+    {\n+        // Add this fiber to pool\n+        pool->fibers[pool->size++] = this;\n+        if (need_lock) {\n+            spin_mutex_unlock(pool->lock);\n+        }\n+        return;\n+    }\n+\n+    // Case 2: Pool is full.\n+    //\n+    // First free up some space by giving fibers to the parent.\n+    if (pool->parent)\n+    {\n+        // Pool is full.  Move all but \"num_to_keep\" fibers to parent,\n+        // if we can.\n+        unsigned num_to_keep = pool->max_size/2 + pool->max_size/4;\n+        cilk_fiber_pool_move_fibers_to_parent_pool(pool, num_to_keep);\n+    }\n+\n+    if (need_lock) {\n+        spin_mutex_unlock(pool->lock);\n+    }\n+\n+    // Now, free a fiber to make room for the one we need to put back,\n+    // and then put this fiber back.  This step may actually return\n+    // fibers to the heap.\n+    cilk_fiber_pool_free_fibers_from_pool(pool, pool->max_size -1, this);\n+}\n+\n+\n+// NOTE: Except for print-debug, this code is the same as in Windows. \n+void cilk_fiber::invoke_tbb_stack_op(__cilk_tbb_stack_op op)\n+{\n+    cilk_fiber_data *fdata = this->get_data();\n+\n+    if (0 == fdata->stack_op_routine)\n+    {\n+        if  (CILK_TBB_STACK_RELEASE != op)\n+            DBG_STACK_OPS (\"Wkr %p: invoke_tbb_stack_op - %s (%d) for cilk_fiber %p, fiber %p, thread id %04x - No stack op routine\\n\",\n+                           fdata->owner, \n+                           NameStackOp(op),\n+                           op,\n+                           fdata,\n+                           this,\n+                           cilkos_get_current_thread_id());\n+        return;\n+    }\n+\n+    // Call TBB to do it's thing\n+    DBG_STACK_OPS (\"Wkr %p: invoke_tbb_stack_op - op %s data %p for cilk_fiber %p, fiber %p, thread id %04x\\n\",\n+                   fdata->owner, \n+                   NameStackOp(op),\n+                   fdata->stack_op_data,\n+                   fdata,\n+                   this, \n+                   cilkos_get_current_thread_id());\n+\n+    (*fdata->stack_op_routine)(op, fdata->stack_op_data);\n+    if (op == CILK_TBB_STACK_RELEASE)\n+    {\n+        fdata->stack_op_routine = 0;\n+        fdata->stack_op_data = 0;\n+    }\n+}\n+\n+\n+\n+#if NEED_FIBER_REF_COUNTS\n+\n+void cilk_fiber::atomic_inc_ref_count()\n+{\n+    cilkos_atomic_add(&m_outstanding_references, 1);\n+}\n+\n+long cilk_fiber::atomic_dec_ref_count()\n+{\n+    return cilkos_atomic_add(&m_outstanding_references, -1);\n+}\n+\n+long cilk_fiber::atomic_sub_from_ref_count(long v)\n+{\n+    return cilkos_atomic_add(&m_outstanding_references, -v);\n+}\n+\n+#endif // NEED_FIBER_REF_COUNTS\n+\n+/* End cilk_fibers.cpp */"}, {"sha": "2671f924681af9fd0b32d61bc670fecbc933eb48", "filename": "libcilkrts/runtime/cilk_fiber.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_fiber.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_fiber.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "9d02c52d0377c1f20d9fb313ab15b8ab912f310d", "filename": "libcilkrts/runtime/cilk_malloc.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_malloc.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "fa0fa6d5c9d3480457855f1b7388eded20022508", "filename": "libcilkrts/runtime/cilk_malloc.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_malloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcilk_malloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk_malloc.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "64ff3e5fc42343521d210708787d528528d1d1e2", "filename": "libcilkrts/runtime/component.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcomponent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fcomponent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcomponent.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "98fefa101bdd3dfe4b554116c0ce7d64d8adffd0", "filename": "libcilkrts/runtime/config/generic/cilk-abi-vla.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fcilk-abi-vla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fcilk-abi-vla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fcilk-abi-vla.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "841307a52961b46b3f131a0154af679862d53640", "filename": "libcilkrts/runtime/config/generic/os-fence.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-fence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-fence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-fence.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "fda7fc414bc03a0a46550c6d64de594f202bdc32", "filename": "libcilkrts/runtime/config/generic/os-unix-sysdep.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-unix-sysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-unix-sysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fgeneric%2Fos-unix-sysdep.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "2d38e7f9a56d26fba1932bcf7fd2b6355056503b", "filename": "libcilkrts/runtime/config/x86/cilk-abi-vla.c", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fcilk-abi-vla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fcilk-abi-vla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fcilk-abi-vla.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "ec704e94ef229015dfd85d9ba5192358e148dcb4", "filename": "libcilkrts/runtime/config/x86/os-fence.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-fence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-fence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-fence.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "881bc3f4283e7eaee58dc055ce8ca61b7e1ca77f", "filename": "libcilkrts/runtime/config/x86/os-unix-sysdep.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-unix-sysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-unix-sysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fconfig%2Fx86%2Fos-unix-sysdep.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "fabe0ab3cd80121d8c181ea97f2ffcd5eb350b6c", "filename": "libcilkrts/runtime/doxygen-layout.xml", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fdoxygen-layout.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fdoxygen-layout.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fdoxygen-layout.xml?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "684dcb51b519032eee2fef4c1ec3f26eb148f6ba", "filename": "libcilkrts/runtime/doxygen.cfg", "status": "added", "additions": 1774, "deletions": 0, "changes": 1774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fdoxygen.cfg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fdoxygen.cfg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fdoxygen.cfg?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "bd08d1826b3f981fec67e50df2fb257d08915010", "filename": "libcilkrts/runtime/except-gcc.cpp", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept-gcc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept-gcc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fexcept-gcc.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "aa76adbc2333aef89306c83a663fd60b07fbecb0", "filename": "libcilkrts/runtime/except-gcc.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept-gcc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept-gcc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fexcept-gcc.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "58e2238c5815256bcd18e9f7d5dd57c93c49100d", "filename": "libcilkrts/runtime/except.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fexcept.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "0b38bd209a90f480c9671ffcb3c8ca30acfe3976", "filename": "libcilkrts/runtime/frame_malloc.c", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fframe_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fframe_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fframe_malloc.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "d412fb620fe01e2d143357f69c4f0136d27bd1e4", "filename": "libcilkrts/runtime/frame_malloc.h", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fframe_malloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fframe_malloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fframe_malloc.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "9ccfd110d6b9a871edc7ce222e7f46efc6c423c4", "filename": "libcilkrts/runtime/full_frame.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Ffull_frame.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Ffull_frame.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Ffull_frame.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "327a3337afe2d5b24473399fa103c11cbf156dea", "filename": "libcilkrts/runtime/full_frame.h", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Ffull_frame.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Ffull_frame.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Ffull_frame.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "02de54f43b10079c8b5ae3224629bb1f3ca5df8b", "filename": "libcilkrts/runtime/global_state.cpp", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fglobal_state.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fglobal_state.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fglobal_state.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "ef455e479d597c37dbc1eb7d3bbea6b8b2679650", "filename": "libcilkrts/runtime/global_state.h", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fglobal_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fglobal_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fglobal_state.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "39b51a593ce124f2827d4556e1b476bd7faac4d1", "filename": "libcilkrts/runtime/jmpbuf.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fjmpbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fjmpbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fjmpbuf.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "60573f3a5fa7b71b5f00e44c6d72787f98d41a1c", "filename": "libcilkrts/runtime/jmpbuf.h", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fjmpbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fjmpbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fjmpbuf.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "aeb4a5fb13d7d535d0d13b02dcde8e1121db77c5", "filename": "libcilkrts/runtime/linux-symbols.ver", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flinux-symbols.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flinux-symbols.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Flinux-symbols.ver?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "14ac82719364e96ce3851bee422dda773f1d9e5f", "filename": "libcilkrts/runtime/local_state.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flocal_state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flocal_state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Flocal_state.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "03f39897f51bb64ba35e418a0e7dd0753ccd8ae1", "filename": "libcilkrts/runtime/local_state.h", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flocal_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Flocal_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Flocal_state.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "38d83a8675df018bac439f42b73d722adb36dd62", "filename": "libcilkrts/runtime/mac-symbols.txt", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmac-symbols.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmac-symbols.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fmac-symbols.txt?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "ce1c51a202b1d109740dfdfec16262ec08dac7f4", "filename": "libcilkrts/runtime/metacall_impl.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmetacall_impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmetacall_impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fmetacall_impl.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "90cc7f9516857f470b7b335ab89cd3d788951246", "filename": "libcilkrts/runtime/metacall_impl.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmetacall_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fmetacall_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fmetacall_impl.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "b48fd623c6e365d9155df4b4a4b47bb695292198", "filename": "libcilkrts/runtime/os-unix.c", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fos-unix.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "8066f0313c2d03f5e6040e5f44f1b3d256765f9f", "filename": "libcilkrts/runtime/os.h", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fos.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "af398cdd089ff17c9be8c09e1a7da38831e8ecc4", "filename": "libcilkrts/runtime/os_mutex-unix.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos_mutex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos_mutex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fos_mutex-unix.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "71d9eb14e51b81819a6c91f648e68f1e37b9da8a", "filename": "libcilkrts/runtime/os_mutex.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fos_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fos_mutex.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "dee4d9cb4112777b9d25171b84c3bbc93266f27a", "filename": "libcilkrts/runtime/pedigrees.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fpedigrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fpedigrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fpedigrees.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "3f6ebb977f9f61d89df77f89ec81fd181674ce29", "filename": "libcilkrts/runtime/pedigrees.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fpedigrees.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fpedigrees.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fpedigrees.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "bc5a79f24119b762e8120cd841f67356dd8f80bb", "filename": "libcilkrts/runtime/record-replay.cpp", "status": "added", "additions": 770, "deletions": 0, "changes": 770, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frecord-replay.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frecord-replay.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Frecord-replay.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "c1c5a68f5798f39ec1659bcfc982adfa2bd703f0", "filename": "libcilkrts/runtime/record-replay.h", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frecord-replay.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frecord-replay.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Frecord-replay.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "f20b9bc459274684763689d599b65ed73e287973", "filename": "libcilkrts/runtime/reducer_impl.cpp", "status": "added", "additions": 1012, "deletions": 0, "changes": 1012, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Freducer_impl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Freducer_impl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Freducer_impl.cpp?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "3425967ad8d1190e6d6142646cf9b3d9f64da9f0", "filename": "libcilkrts/runtime/reducer_impl.h", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Freducer_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Freducer_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Freducer_impl.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "4ffde7ccb1eccf1adf53862727173053131ea348", "filename": "libcilkrts/runtime/rts-common.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frts-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Frts-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Frts-common.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "bab6430d9db7db3848b07de94b7ab61db66f4f5d", "filename": "libcilkrts/runtime/scheduler.c", "status": "added", "additions": 3940, "deletions": 0, "changes": 3940, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fscheduler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fscheduler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fscheduler.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "543adaf68e03831b2c0349fc536880fa736e65c5", "filename": "libcilkrts/runtime/scheduler.h", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fscheduler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fscheduler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fscheduler.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "92c404b482c5bc8800674ef362a02dd73b4051e3", "filename": "libcilkrts/runtime/signal_node.c", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsignal_node.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsignal_node.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fsignal_node.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "0a1fe2002013e7771e52fdf2e4d0b2dd3e718da7", "filename": "libcilkrts/runtime/signal_node.h", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsignal_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsignal_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fsignal_node.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "03908f2632235f618e751b4c1d2cb876aebe06f4", "filename": "libcilkrts/runtime/spin_mutex.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fspin_mutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fspin_mutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fspin_mutex.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "b0045ab93136558695225a48946f402de9c618e8", "filename": "libcilkrts/runtime/spin_mutex.h", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fspin_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fspin_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fspin_mutex.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "3a420745039d93cc9b624679c60625beef812df6", "filename": "libcilkrts/runtime/stats.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fstats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fstats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fstats.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "aaa992747650da6f925b7acc8f3eac01c489a102", "filename": "libcilkrts/runtime/stats.h", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fstats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fstats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fstats.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "1113ecd44cd4ae80a256d1d33c0f283ab81f28cd", "filename": "libcilkrts/runtime/symbol_test.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsymbol_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsymbol_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fsymbol_test.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "194681fffc500b0c16f7ccc72dd520779cc74b4b", "filename": "libcilkrts/runtime/sysdep-unix.c", "status": "added", "additions": 794, "deletions": 0, "changes": 794, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsysdep-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsysdep-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fsysdep-unix.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "ea939acc124eda78668ddc59b7adbcfc291b42e1", "filename": "libcilkrts/runtime/sysdep.h", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsysdep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fsysdep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fsysdep.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "380d6255a0c36eda59e5bc20c84c5ed08abf45f3", "filename": "libcilkrts/runtime/worker_mutex.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fworker_mutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fworker_mutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fworker_mutex.c?ref=3038054c687e9400976012eea70333db70ad6a7b"}, {"sha": "c2c68247e0b36b888340479919f153e0c2a35f58", "filename": "libcilkrts/runtime/worker_mutex.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fworker_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3038054c687e9400976012eea70333db70ad6a7b/libcilkrts%2Fruntime%2Fworker_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fworker_mutex.h?ref=3038054c687e9400976012eea70333db70ad6a7b"}]}