{"sha": "98c1c668807d74ad4dfab8c0413499b31f638258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMWM2Njg4MDdkNzRhZDRkZmFiOGMwNDEzNDk5YjMxZjYzODI1OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-06T08:10:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-06T08:10:07Z"}, "message": "class.c (grow_method): Remove check for redeclaration.\n\n\t* class.c (grow_method): Remove check for redeclaration.\n\nFri Sep  5 01:37:17 1997  Mark Mitchell  <mmitchell@usa.net>\n\n\t* cp-tree.h (INNERMOST_TEMPLATE_PARMS): New macro.\n\t(DECL_INNERMOST_TEMPLATE_PARMS): Likewise.\n\t(PRIMARY_TEMPLATE_P): Use it.\n\t* call.c (build_overload_call_real): Use it.\n\t* class.c (instantiate_type): Likewise.\n\t* decl.c (decls_match): Likewise.\n\t* method.c (build_overload_identifier): Likewise.\n\t* pt.c (push_template_decl): Likewise.\n\t(classtype_mangled_name): Likewise.\n\t(lookup_template_class): Likewise.\n\n\t* cp-tree.h (DECL_NTPARMS): Change name from DECL_NT_PARMS to\n\tDECL_NTPARMS to conform to usage elsewhere.\n\t* call.c (add_template_candidate): Likewise.\n\t* class.c (instantiate_type): Likewise.\n\t* pt.c (instantiate_template): Likewise.\n\t(get_bindings): Likewise.\n\n\t* class.c (grow_method): Use DECL_FUNCTION_TEMPLATE_P instead of\n\tis_member_template.\n\n\t* pt.c (unify): Undo changes to allow multiple levels of template\n\tparameters.\n\t(type_unification): Likewise.\n\t(fn_type_unification): Likewise.\n\t(get_class_bindings): Likewise.\n\t* cp-tree.h (Likewise).\n\n\t* decl.c (replace_defarg): Check that the type of the default\n\tparameter does not invlove a template type before complaining\n\tabout the initialization.\n\n\t* error.c (dump_expr): Deal with template constant parameters in\n\tmember templates correctly.\n\n\t* pt.c (is_member_template): Deal with class specializations\n\tcorrectly.\n\t(tsubst): Handle \"partial instantiation\" of member templates\n\tcorrectly.\n\nWed Sep  3 12:30:24 1997  Mark Mitchell  <mmitchell@usa.net>\n\n\t* pt.c (type_unification): Change calling squence to allow for\n\tmultiple levels of template parameters.\n\t(tsubst_expr): Likewise.\n\t(tsubst): Likewise.\n\t(tsubst_copy): Likewise.\n\t(instantiate_template): Likewise.\n\t(unify): Likewise.\n\t* call.c (build_overload_call_real): Use it.\n\t(add_builtin_candidate): Use it.\n\t(build_new_method_call): Use it.\n\t* class.c (instantiate_type): Use it.\n\t* decl.c (grokdeclarator): Use it.\n\t* decl2.c (finish_file): Use it.\n\t* method.c (build_overload_identifier): Use it.\n\n\t* call.c (add_template_candidate):  Add additional parameter for\n\tthe function return type.  Call fn_type_unification istead of\n\ttype_unification.\n\t(build_user_type_conversion_1): Handle member templates.\n\t(build_new_function_call): Likewise.\n\t(build_new_op): Likewise.\n\t(build_new_method_call): Likewise.\n\n\t* class.c (grow_method): Don't give an error message indicating\n \tthat two member templates with the same name are ambiguous.\n\t(finish_struct): Treat member template functions just like member\n \tfunctions.\n\n\t* cp-tree.h (check_member_template): Add declaration.\n\t(begin_member_template_processing): Likewise.\n\t(end_member_template_processing): Likewise.\n\t(fn_type_unification): Likewise.\n\t(is_member_template): Likewise.\n\t(tsubst): Change prototype.\n\t(tsubst_expr): Likewise.\n\t(tsubst_copy): Likewise.\n\t(instantiate_template): Likewise.\n\t(get_bindings): Likewise.\n\n\t* decl.c (decls_match): Handle multiple levels of template\n\tparameters.\n\t(pushdecl): Handle template type params just like other type\n\tdeclarations.\n\t(push_class_level_binding): Return immediately if the\n\tclass_binding_level is NULL.\n\t(grokfndecl): If check_classfn() returns a member_template, use\n\tthe result of the template, not the template itself.\n\n\t* decl2.c (check_member_template): New function.  Check to see\n\tthat the entity declared to be a member template can be one.\n\t(check_classfn): Allow redeclaration of member template functions\n\twith different types; the new functions can be specializations or\n\texplicit instantiations.\n\n\t* error.c (dump_decl): Handle multiple levels of template\n\tparameters.\n\t(dump_function_decl): Update to handle function\ttemplates.\n\n\t* lex.c (do_pending_inlines): Set up template parameter context\n\tfor member templates.\n\t(process_next_inline): Likewise.\n\n\t* method. (build_overload_identifier): Adjust for multiple levels\n\tof template parameters.\n\n\t* parse.y (fn.def2): Add member templates.\n\t(component_decl_1): Likewise.\n\n\t* pt.c (begin_member_template_processing): New function.\n\t(end_member_template_processing): Likewise.\n\t(is_member_template): Likewise.\n\t(fn_type_unification): Likewise.\n\t(current_template_parms): Return a vector of all the template\n\tparms, not just the innermost level of parms.\n\t(push_template_decl): Deal with the possibility of member\n\ttemplates.\n\t(lookup_template_class): Likewise.\n\t(uses_template_parms): Likewise.\n\t(tsubst): Modify processing to TEMPLATE_TYPE_PARM and\n\tTEMPLATE_CONST_PARM to deal with multiple levels of template\n\targuments.   Add processing of TEMPLATE_DECL to produce new\n\tTEMPLATE_DECLs from old ones.\n\t(do_decl_instantiation): Handle member templates.\n\n\t* search.c (lookup_fnfields_1): Handle member template conversion\n\toperators.\n\n\t* tree.c (cp_tree_equal): Check the levels, as well as the\n\tindices, of TEMPLATE_CONST_PARMs.\n\n\t* typeck.c (comptypes): Check the levels, as well as the indices,\n\tfo TEMPLATE_TYPE_PARMs.\n\t(build_x_function_call): Treat member templates like member\n\tfunctions.\n\nMember templates.\n\nFrom-SVN: r15130", "tree": {"sha": "770f6f78bc4ec8479312fa2a69e6db566c0ed9b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/770f6f78bc4ec8479312fa2a69e6db566c0ed9b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c1c668807d74ad4dfab8c0413499b31f638258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c1c668807d74ad4dfab8c0413499b31f638258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c1c668807d74ad4dfab8c0413499b31f638258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c1c668807d74ad4dfab8c0413499b31f638258/comments", "author": null, "committer": null, "parents": [{"sha": "dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56"}], "stats": {"total": 1155, "additions": 925, "deletions": 230}, "files": [{"sha": "effd43423c1d859a996dde963235e4764468e87a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1,3 +1,104 @@\n+Fri Sep  5 17:27:38 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (grow_method): Remove check for redeclaration.\n+\n+Wed Sep  3 12:30:24 1997  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* pt.c (type_unification): Change calling squence to allow for\n+\tmultiple levels of template parameters.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(instantiate_template): Likewise.\n+\t(unify): Likewise.\n+\t* call.c (build_overload_call_real): Use it.\n+\t(add_builtin_candidate): Use it.\n+\t(build_new_method_call): Use it.\n+\t* class.c (instantiate_type): Use it.\n+\t* decl.c (grokdeclarator): Use it.\n+\t* decl2.c (finish_file): Use it.\n+\t* method.c (build_overload_identifier): Use it.\n+\t\n+\t* call.c (add_template_candidate):  Add additional parameter for\n+\tthe function return type.  Call fn_type_unification istead of\n+\ttype_unification.\n+\t(build_user_type_conversion_1): Handle member templates.\n+\t(build_new_function_call): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t\n+\t* class.c (grow_method): Don't give an error message indicating\n+ \tthat two member templates with the same name are ambiguous.\n+\t(finish_struct): Treat member template functions just like member\n+ \tfunctions.\n+\t\n+\t* cp-tree.h (check_member_template): Add declaration.\n+\t(begin_member_template_processing): Likewise.\n+\t(end_member_template_processing): Likewise.\n+\t(fn_type_unification): Likewise.\n+\t(is_member_template): Likewise.\n+\t(tsubst): Change prototype.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(instantiate_template): Likewise.\n+\t(get_bindings): Likewise.\n+\n+\t* decl.c (decls_match): Handle multiple levels of template\n+\tparameters. \n+\t(pushdecl): Handle template type params just like other type\n+\tdeclarations. \n+\t(push_class_level_binding): Return immediately if the\n+\tclass_binding_level is NULL.\n+\t(grokfndecl): If check_classfn() returns a member_template, use\n+\tthe result of the template, not the template itself.\n+\t\n+\t* decl2.c (check_member_template): New function.  Check to see\n+\tthat the entity declared to be a member template can be one.\n+\t(check_classfn): Allow redeclaration of member template functions\n+\twith different types; the new functions can be specializations or\n+\texplicit instantiations.\n+\t\n+\t* error.c (dump_decl): Handle multiple levels of template\n+\tparameters. \n+\t(dump_function_decl): Update to handle function\ttemplates.\n+\n+\t* lex.c (do_pending_inlines): Set up template parameter context\n+\tfor member templates.\n+\t(process_next_inline): Likewise.\n+\n+\t* method. (build_overload_identifier): Adjust for multiple levels\n+\tof template parameters.\n+\t\n+\t* parse.y (fn.def2): Add member templates.\n+\t(component_decl_1): Likewise.\n+\n+\t* pt.c (begin_member_template_processing): New function.\n+\t(end_member_template_processing): Likewise.\n+\t(is_member_template): Likewise.\n+\t(fn_type_unification): Likewise.\n+\t(current_template_parms): Return a vector of all the template\n+\tparms, not just the innermost level of parms.\n+\t(push_template_decl): Deal with the possibility of member\n+\ttemplates. \n+\t(lookup_template_class): Likewise.\n+\t(uses_template_parms): Likewise.\n+\t(tsubst): Modify processing to TEMPLATE_TYPE_PARM and\n+\tTEMPLATE_CONST_PARM to deal with multiple levels of template\n+\targuments.   Add processing of TEMPLATE_DECL to produce new\n+\tTEMPLATE_DECLs from old ones.\n+\t(do_decl_instantiation): Handle member templates.\n+\n+\t* search.c (lookup_fnfields_1): Handle member template conversion\n+\toperators. \n+\n+\t* tree.c (cp_tree_equal): Check the levels, as well as the\n+\tindices, of TEMPLATE_CONST_PARMs.\n+\n+\t* typeck.c (comptypes): Check the levels, as well as the indices,\n+\tfo TEMPLATE_TYPE_PARMs.\n+\t(build_x_function_call): Treat member templates like member\n+\tfunctions. \n+\t\n Wed Sep  3 11:09:25 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (c_expand_return): Always convert_for_initialization"}, {"sha": "06316143a2ba35acb5138fc137a6de6233cdc334", "filename": "gcc/cp/call.c", "status": "modified", "additions": 107, "deletions": 36, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -77,7 +77,7 @@ static tree build_this PROTO((tree));\n static struct z_candidate * splice_viable PROTO((struct z_candidate *));\n static int any_viable PROTO((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPROTO((struct z_candidate *, tree, tree, int));\n+\tPROTO((struct z_candidate *, tree, tree, tree, int));\n static struct z_candidate * add_builtin_candidates\n \tPROTO((struct z_candidate *, enum tree_code, enum tree_code,\n \t       tree, tree *, int));\n@@ -2838,11 +2838,12 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \t}\n       if (TREE_CODE (function) == TEMPLATE_DECL)\n \t{\n-\t  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (function));\n-\t  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+\t  int ntparms = DECL_NTPARMS (function);\n+\t  tree targs = make_tree_vec (ntparms);\n \t  int i;\n \n-\t  i = type_unification (DECL_TEMPLATE_PARMS (function), targs,\n+\t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (function),\n+\t\t\t\t&TREE_VEC_ELT (targs, 0),\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n \t\t\t\tparms, &template_cost, 0, 0);\n \t  if (i == 0)\n@@ -4144,20 +4145,19 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n }\n \n static struct z_candidate *\n-add_template_candidate (candidates, tmpl, arglist, flags)\n+add_template_candidate (candidates, tmpl, arglist, return_type, flags)\n      struct z_candidate *candidates;\n-     tree tmpl, arglist;\n+     tree tmpl, arglist, return_type;\n      int flags;\n {\n-  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n-  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+  int ntparms = DECL_NTPARMS (tmpl);\n+  tree targs = make_tree_vec (ntparms);\n   struct z_candidate *cand;\n-  int i, dummy = 0;\n+  int i;\n   tree fn;\n \n-  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n-\t\t\targlist, &dummy, 0, 0);\n+  i = fn_type_unification (tmpl, targs, arglist, return_type, 0);\n+\n   if (i != 0)\n     return candidates;\n \n@@ -4253,6 +4253,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n   tree fromtype = TREE_TYPE (expr);\n   tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n   tree args;\n+  tree templates = NULL_TREE;\n \n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n@@ -4279,9 +4280,22 @@ build_user_type_conversion_1 (totype, expr, flags)\n       if (DECL_NONCONVERTING_P (ctors))\n \tcontinue;\n \n-      candidates = add_function_candidate (candidates, ctors, args, flags);\n-      candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n-      candidates->basetype_path = TYPE_BINFO (totype);\n+      if (TREE_CODE (ctors) == TEMPLATE_DECL) \n+\t{\n+\t  templates = decl_tree_cons (NULL_TREE, ctors, templates);\n+\t  candidates = \n+\t    add_template_candidate (candidates, ctors,\n+\t\t\t\t    args, NULL_TREE, flags);\n+\t} \n+      else \n+\tcandidates = add_function_candidate (candidates, ctors,\n+\t\t\t\t\t     args, flags); \n+\n+      if (candidates) \n+\t{\n+\t  candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n+\t  candidates->basetype_path = TYPE_BINFO (totype);\n+\t} \n     }\n \n   if (convs)\n@@ -4308,11 +4322,24 @@ build_user_type_conversion_1 (totype, expr, flags)\n       else if (ics)\n \tfor (; fn; fn = DECL_CHAIN (fn))\n \t  {\n-\t    candidates = add_function_candidate (candidates, fn, args, flags);\n-\t    candidates->second_conv = ics;\n-\t    candidates->basetype_path = TREE_PURPOSE (convs);\n-\t    if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n-\t      candidates->viable = -1;\n+\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t      {\n+\t\ttemplates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t\tcandidates = \n+\t\t  add_template_candidate (candidates, fn, args,\n+\t\t\t\t\t  totype, flags);\n+\t      } \n+\t    else \n+\t      candidates = add_function_candidate (candidates, fn,\n+\t\t\t\t\t\t   args, flags); \n+\n+\t    if (candidates) \n+\t      {\n+\t\tcandidates->second_conv = ics;\n+\t\tcandidates->basetype_path = TREE_PURPOSE (convs);\n+\t\tif (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n+\t\t  candidates->viable = -1;\n+\t      }\n \t  }\n     }\n \n@@ -4354,6 +4381,13 @@ build_user_type_conversion_1 (totype, expr, flags)\n   for (p = &(cand->second_conv); TREE_CODE (*p) != IDENTITY_CONV; )\n     p = &(TREE_OPERAND (*p, 0));\n \n+  /* Pedantically, normal function declarations are never considered\n+     to refer to template instantiations, but we won't implement that\n+     until we implement full template instantiation syntax.  */\n+  if (templates && ! cand->template && ! DECL_INITIAL (cand->fn)\n+      && TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE)\n+    add_maybe_template (cand->fn, templates);\n+\n   *p = build\n     (USER_CONV,\n      (DECL_CONSTRUCTOR_P (cand->fn)\n@@ -4427,7 +4461,7 @@ build_new_function_call (fn, args, obj)\n \t    {\n \t      templates = decl_tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n-\t\t(candidates, t, args, LOOKUP_NORMAL);\n+\t\t(candidates, t, args, NULL_TREE, LOOKUP_NORMAL);\n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -4713,7 +4747,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t{\n \t  templates = decl_tree_cons (NULL_TREE, fns, templates);\n \t  candidates = add_template_candidate\n-\t    (candidates, fns, arglist, flags);\n+\t    (candidates, fns, arglist, TREE_TYPE (fnname), flags);\n \t}\n       else\n \tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n@@ -4730,13 +4764,27 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n       for (; fn; fn = DECL_CHAIN (fn))\n \t{\n+\t  tree this_arglist;\n+\n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n-\t    candidates = add_function_candidate\n-\t      (candidates, fn, mem_arglist, flags);\n+\t    this_arglist = mem_arglist;\n \t  else\n-\t    candidates = add_function_candidate (candidates, fn, arglist, flags);\n-\t  \n-\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t    this_arglist = arglist;\n+\n+\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    {\n+\t      /* A member template. */\n+\t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t      candidates = add_template_candidate\n+\t\t(candidates, fn, this_arglist, \n+\t\t TREE_TYPE (fnname), LOOKUP_NORMAL);\n+\t    }\n+\t  else\n+\t    candidates = add_function_candidate\n+\t      (candidates, fn, this_arglist, flags);\n+\n+\t  if (candidates) \n+\t    candidates->basetype_path = TREE_PURPOSE (fns);\n \t}\n     }\n \n@@ -4827,9 +4875,9 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       if (DECL_FUNCTION_MEMBER_P (cand->fn))\n \tenforce_access (cand->basetype_path, cand->fn);\n \n-      /* Pedantically, it is ill-formed to define a function that could\n-\t also be a template instantiation, but we won't implement that\n-\t until things settle down.  */\n+      /* Pedantically, normal function declarations are never considered\n+\t to refer to template instantiations, but we won't implement that\n+\t until we implement full template instantiation syntax.  */\n       if (templates && ! cand->template && ! DECL_INITIAL (cand->fn)\n \t  && TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE)\n \tadd_maybe_template (cand->fn, templates);\n@@ -5188,8 +5236,7 @@ build_over_call (fn, convs, args, flags)\n       if (DECL_TEMPLATE_INFO (fn))\n \t/* This came from a template.  Instantiate the default arg here,\n \t   not in tsubst.  */\n-\targ = tsubst_expr (arg,\n-\t\t\t   &TREE_VEC_ELT (DECL_TI_ARGS (fn), 0),\n+\targ = tsubst_expr (arg, DECL_TI_ARGS (fn),\n \t\t\t   TREE_VEC_LENGTH (DECL_TI_ARGS (fn)), NULL_TREE);\n       converted_args = tree_cons\n \t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),\n@@ -5332,6 +5379,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n   tree basetype, mem_args, fns, instance_ptr;\n   tree pretty_name;\n   tree user_args = args;\n+  tree templates = NULL_TREE;\n \n   /* If there is an extra argument for controlling virtual bases,\n      remove it for error reporting.  */\n@@ -5412,17 +5460,34 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n       for (; t; t = DECL_CHAIN (t))\n \t{\n+\t  tree this_arglist;\n+\n \t  /* We can end up here for copy-init of same or base class.  */\n \t  if (name == ctor_identifier\n \t      && (flags & LOOKUP_ONLYCONVERTING)\n \t      && DECL_NONCONVERTING_P (t))\n \t    continue;\n \t  if (TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)\n-\t    candidates = add_function_candidate\n-\t      (candidates, t, mem_args, flags);\n+\t    this_arglist = mem_args;\n \t  else\n-\t    candidates = add_function_candidate (candidates, t, args, flags);\n-\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t    this_arglist = args;\n+\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    {\n+\t      /* A member template. */\n+\t      templates = decl_tree_cons (NULL_TREE, t, templates);\n+\t      candidates = \n+\t\tadd_template_candidate (candidates, t,\n+\t\t\t\t\tthis_arglist,\n+\t\t\t\t\tTREE_TYPE (name), \n+\t\t\t\t\tLOOKUP_NORMAL); \n+\t    }\n+\t  else \n+\t    candidates = add_function_candidate (candidates, t,\n+\t\t\t\t\t\t this_arglist, flags);\n+\n+\t  if (candidates)\n+\t    candidates->basetype_path = TREE_PURPOSE (fns);\n \t}\n     }\n \n@@ -5464,6 +5529,12 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  || resolves_to_fixed_type_p (instance, 0)))\n     flags |= LOOKUP_NONVIRTUAL;\n \n+  /* Pedantically, normal function declarations are never considered\n+     to refer to template instantiations, but we won't implement that\n+     until we implement full template instantiation syntax.  */\n+  if (templates && ! cand->template && ! DECL_INITIAL (cand->fn))\n+    add_maybe_template (cand->fn, templates);\n+\n   return build_over_call\n     (cand->fn, cand->convs,\n      TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE ? mem_args : args,"}, {"sha": "af735e98fcf4df2042a52a11ace322add4e02885", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1872,33 +1872,10 @@ grow_method (fndecl, method_vec_ptr)\n \n   if (testp < (tree *) obstack_next_free (&class_obstack))\n     {\n-      tree x, prev_x;\n-\n-      for (x = *testp; x; x = DECL_CHAIN (x))\n-\t{\n-\t  if (DECL_NAME (fndecl) == ansi_opname[(int) DELETE_EXPR]\n-\t      || DECL_NAME (fndecl) == ansi_opname[(int) VEC_DELETE_EXPR])\n-\t    {\n-\t      /* ANSI C++ June 5 1992 WP 12.5.5.1 */\n-\t      cp_error_at (\"`%D' overloaded\", fndecl);\n-\t      cp_error_at (\"previous declaration as `%D' here\", x);\n-\t    }\n-\t  if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (x))\n-\t    {\n-\t      /* Friend-friend ambiguities are warned about outside\n-\t\t this loop.  */\n-\t      cp_error_at (\"ambiguous method `%#D' in structure\", fndecl);\n-\t      break;\n-\t    }\n-\t  prev_x = x;\n-\t}\n-      if (x == 0)\n-\t{\n-\t  if (*testp)\n-\t    DECL_CHAIN (prev_x) = fndecl;\n-\t  else\n-\t    *testp = fndecl;\n-\t}\n+      tree *p;\n+      for (p = testp; *p; )\n+\tp = &DECL_CHAIN (*p);\n+      *p = fndecl;\n     }\n   else\n     {\n@@ -4384,7 +4361,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t\t}\n \t    }\n \n-\t  if (TREE_CODE (x) == FUNCTION_DECL)\n+\t  if (TREE_CODE (x) == FUNCTION_DECL \n+\t      || DECL_FUNCTION_TEMPLATE_P (x))\n \t    {\n \t      DECL_CLASS_CONTEXT (x) = t;\n \t      if (last_x)\n@@ -5062,12 +5040,13 @@ instantiate_type (lhstype, rhs, complain)\n \t      for (elem = get_first_fn (rhs); elem; elem = DECL_CHAIN (elem))\n \t\tif (TREE_CODE (elem) == TEMPLATE_DECL)\n \t\t  {\n-\t\t    int n = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (elem));\n-\t\t    tree *t = (tree *) alloca (sizeof (tree) * n);\n+\t\t    int n = DECL_NTPARMS (elem);\n+\t\t    tree t = make_tree_vec (n);\n \t\t    int i, d = 0;\n-\t\t    i = type_unification (DECL_TEMPLATE_PARMS (elem), t,\n-\t\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t\t\t\t  TYPE_ARG_TYPES (lhstype), &d, 0, 1);\n+\t\t    i = type_unification\n+\t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), \n+\t\t       &TREE_VEC_ELT (t, 0), TYPE_ARG_TYPES (TREE_TYPE (elem)),\n+\t\t       TYPE_ARG_TYPES (lhstype), &d, 0, 1);\n \t\t    if (i == 0)\n \t\t      {\n \t\t\tif (save_elem)"}, {"sha": "6c6dff78c5cf70adb50394b06a020bd7d5763d32", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -91,7 +91,7 @@ DEFTREECODE (TYPENAME_TYPE, \"typename_type\", \"t\", 0)\n \n /* Index into a template parameter list.  This parameter must not be a\n    type.  */\n-DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 2)\n+DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 3)\n \n /* A thunk is a stub function.\n "}, {"sha": "0daf874dde4077cf5f815a15a12aed9330597a29", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1091,6 +1091,7 @@ struct lang_decl\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_SPEC_INFO(NODE) TI_SPEC_INFO (CLASSTYPE_TEMPLATE_INFO (NODE))\n+#define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE(NODE)\n \n #define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -1334,6 +1335,10 @@ extern int flag_new_for_scope;\n \n /* Accessor macros for C++ template decl nodes.  */\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n+#define DECL_INNERMOST_TEMPLATE_PARMS(NODE) \\\n+   INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (NODE))\n+#define DECL_NTPARMS(NODE) \\\n+   TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (NODE))\n /* For class templates.  */\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n /* For function, method, class-data templates.  */\n@@ -1346,7 +1351,7 @@ extern int flag_new_for_scope;\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n #define PRIMARY_TEMPLATE_P(NODE) \\\n-  (TREE_TYPE (DECL_TEMPLATE_PARMS (NODE)) == (NODE))\n+  (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)) == (NODE))\n \n #define CLASSTYPE_TEMPLATE_LEVEL(NODE) \\\n   (TREE_INT_CST_HIGH (TREE_PURPOSE (CLASSTYPE_TI_TEMPLATE (NODE))))\n@@ -2112,6 +2117,7 @@ extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n extern tree check_classfn\t\t\tPROTO((tree, tree));\n+extern void check_member_template               PROTO((tree));\n extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n@@ -2299,10 +2305,12 @@ extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((char *, tree));\n \n /* in pt.c */\n-extern tree tsubst\t\t\t\tPROTO ((tree, tree*, int, tree));\n-extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree*, int, tree));\n-extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree*, int, tree));\n+extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n+extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, int, tree));\n+extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n+extern void begin_member_template_processing    PROTO((tree));\n+extern void end_member_template_processing      PROTO((void));\n extern void begin_template_parm_list\t\tPROTO((void));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n@@ -2312,8 +2320,9 @@ extern void push_template_decl\t\t\tPROTO((tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n-extern tree instantiate_template\t\tPROTO((tree, tree *));\n+extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n+extern int fn_type_unification                  PROTO((tree, tree, tree, tree, int));\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n@@ -2324,7 +2333,7 @@ extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n-extern tree *get_bindings\t\t\tPROTO((tree, tree));\n+extern tree get_bindings\t\t\tPROTO((tree, tree));\n /* CONT ... */\n extern void add_tree\t\t\t\tPROTO((tree));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n@@ -2333,6 +2342,7 @@ extern tree most_specialized\t\t\tPROTO((tree, tree));\n extern tree most_specialized_class\t\tPROTO((tree, tree));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n+extern int is_member_template                   PROTO((tree));\n \n /* in repo.c */\n extern void repo_template_used\t\t\tPROTO((tree));"}, {"sha": "c77dac80396cfca91286f6abf28aaaf2a2419a97", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -2306,23 +2306,40 @@ decls_match (newdecl, olddecl)\n     {\n \ttree newargs = DECL_TEMPLATE_PARMS (newdecl);\n \ttree oldargs = DECL_TEMPLATE_PARMS (olddecl);\n-\tint i, len = TREE_VEC_LENGTH (newargs);\n+\tint i;\n \n-\tif (TREE_VEC_LENGTH (oldargs) != len)\n-\t  return 0;\n-\t\n-\tfor (i = 0; i < len; i++)\n+\t/* Run through all the levels of template parmaters, checking\n+\t   that they match.  */\n+\twhile (newargs && oldargs) \n \t  {\n-\t    tree newarg = TREE_VALUE (TREE_VEC_ELT (newargs, i));\n-\t    tree oldarg = TREE_VALUE (TREE_VEC_ELT (oldargs, i));\n-\t    if (TREE_CODE (newarg) != TREE_CODE (oldarg))\n-\t      return 0;\n-\t    else if (TREE_CODE (newarg) == TYPE_DECL)\n-\t      /* continue */;\n-\t    else if (! comptypes (TREE_TYPE (newarg), TREE_TYPE (oldarg), 1))\n+\t    int len = TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (newargs));\n+\n+\t    if (TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (oldargs)) != len)\n \t      return 0;\n+\t    \n+\t    for (i = 0; i < len; i++)\n+\t      {\n+\t\ttree newarg = \n+\t\t  TREE_VALUE (TREE_VEC_ELT \n+\t\t\t      (INNERMOST_TEMPLATE_PARMS (newargs), i));\n+\t\ttree oldarg = \n+\t\t  TREE_VALUE (TREE_VEC_ELT \n+\t\t\t      (INNERMOST_TEMPLATE_PARMS (oldargs), i));\n+\t\tif (TREE_CODE (newarg) != TREE_CODE (oldarg))\n+\t\t  return 0;\n+\t\telse if (TREE_CODE (newarg) == TYPE_DECL)\n+\t\t  /* continue */;\n+\t\telse if (! comptypes (TREE_TYPE (newarg), TREE_TYPE (oldarg), 1))\n+\t\t  return 0;\n+\t      }\n+\t    newargs = TREE_CHAIN (newargs);\n+\t    oldargs = TREE_CHAIN (oldargs);\n \t  }\n \n+\tif ((newargs == NULL_TREE) != (oldargs == NULL_TREE))\n+\t  /* One declaration has more levels that the other. */\n+\t  return 0;\n+\n \tif (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \t  types_match = 1;\n \telse\n@@ -3003,7 +3020,7 @@ pushdecl (x)\n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use.  */\n   if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n-      || TREE_CODE (x) == NAMESPACE_DECL)\n+      || TREE_CODE (x) == NAMESPACE_DECL || TREE_CODE (x) == TEMPLATE_TYPE_PARM)\n     name = DECL_NAME (x);\n \n   if (name)\n@@ -3493,6 +3510,11 @@ push_class_level_binding (name, x)\n      tree name;\n      tree x;\n {\n+  /* The class_binding_level will be NULL if x is a template \n+     parameter name in a member template.  */\n+  if (!class_binding_level)\n+    return;\n+\n   if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n       && purpose_member (name, class_binding_level->class_shadowed))\n     return;\n@@ -7232,6 +7254,10 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       if (check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n+\n+\t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n+\t    tmp = DECL_TEMPLATE_RESULT(tmp);\n+\n \t  if (tmp && DECL_ARTIFICIAL (tmp))\n \t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n \t  if (tmp && duplicate_decls (decl, tmp))\n@@ -7270,6 +7296,10 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       if (ctype != NULL_TREE && check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n+\n+\t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n+\t    tmp = DECL_TEMPLATE_RESULT(tmp);\n+\t      \n \t  if (tmp && DECL_STATIC_FUNCTION_P (tmp)\n \t      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n \t    {\n@@ -8934,8 +8964,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    && uses_template_parms (current_class_type))\n \t\t  {\n \t\t    tree args = current_template_args ();\n-\t\t    type = tsubst (type, &TREE_VEC_ELT (args, 0),\n-\t\t\t\t   TREE_VEC_LENGTH (args), NULL_TREE);\n+\t\t    type = tsubst (type, args,\n+\t\t\t\t   TREE_VEC_LENGTH (TREE_VEC_ELT\n+\t\t\t\t\t\t    (args, 0)),\n+\t\t\t\t   NULL_TREE);\n \t\t  }\n \n \t\t/* This pop_nested_class corresponds to the\n@@ -10038,7 +10070,7 @@ void\n replace_defarg (arg, init)\n      tree arg, init;\n {\n-  if (! processing_template_decl\n+  if (! processing_template_decl && ! uses_template_parms (TREE_VALUE (arg))\n       && ! can_convert_arg (TREE_VALUE (arg), TREE_TYPE (init), init))\n     cp_pedwarn (\"invalid type `%T' for default argument to `%T'\",\n \t\tTREE_TYPE (init), TREE_VALUE (arg));"}, {"sha": "2de7fcede6e93add4039894841523f823e9ad500", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1282,6 +1282,59 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n     }\n }\n \n+/* Report an error if the indicated template declaration is not the\n+   sort of thing that should be a member template.  */\n+\n+void\n+check_member_template (tmpl)\n+     tree tmpl;\n+{\n+  tree decl;\n+\n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+  decl = DECL_TEMPLATE_RESULT (tmpl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL) \n+    {\n+      if (current_function_decl)\n+\t/* 14.5.2.2 [temp.mem]\n+\t   \n+\t   A local class shall not have member templates. */\n+\tcp_error (\"declaration of of member template `%#D' in local class\",\n+\t\t  decl);\n+      \n+      if (DECL_VIRTUAL_P (decl)) \n+\t{\n+\t  /* 14.5.2.3 [temp.mem]\n+\n+\t     A member function template shall not be virtual.  */\n+\t  cp_error \n+\t    (\"invalid use of `virtual' in template declaration of `%#D'\",\n+\t     decl);\n+\t  DECL_VIRTUAL_P (decl) = 0;\n+\t}\n+\n+      /* The debug-information generating code doesn't know what to do\n+\t with member templates.  */ \n+      DECL_IGNORED_P (tmpl) = 1;\n+    } \n+  else if (TREE_CODE (decl) == TYPE_DECL &&\n+\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      if (current_function_decl)\n+\t/* 14.5.2.2 [temp.mem]\n+\n+\t   A local class shall not have member templates.  */\n+\tcp_error (\"declaration of of member template `%#D' in local class\",\n+\t\t  decl);\n+\n+      /* We don't handle member template classes yet. */\n+      sorry (\"member templates classes\");\n+    }\n+  else\n+    cp_error (\"template declaration of `%#D'\", decl);\n+}\n+\n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n    CNAME is the same here as it is for grokclassfn above.  */\n@@ -1295,6 +1348,7 @@ check_classfn (ctype, function)\n   tree method_vec = CLASSTYPE_METHOD_VEC (complete_type (ctype));\n   tree *methods = 0;\n   tree *end = 0;\n+  tree templates = NULL_TREE;\n \n   if (method_vec != 0)\n     {\n@@ -1311,6 +1365,7 @@ check_classfn (ctype, function)\n \n       while (++methods != end)\n \t{\n+\t  fndecl = *methods;\n \t  if (fn_name == DECL_NAME (*methods))\n \t    {\n \t    got_it:\n@@ -1342,14 +1397,39 @@ check_classfn (ctype, function)\n \t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n \t\t\t  && compparms (p1, p2, 3))\n \t\t\treturn fndecl;\n+\n+\t\t      if (is_member_template (fndecl)) \n+\t\t\t/* This function might be an instantiation\n+\t\t\t   or specialization of fndecl.  */\n+\t\t\ttemplates = \n+\t\t\t  tree_cons (NULL_TREE, fndecl, templates);\n \t\t    }\n #endif\n \t\t  fndecl = DECL_CHAIN (fndecl);\n \t\t}\n \t      break;\t\t/* loser */\n \t    }\n-\t}\n-    }\n+\t  else if (TREE_CODE (fndecl) == TEMPLATE_DECL \n+\t\t   && IDENTIFIER_TYPENAME_P (DECL_NAME (fndecl))\n+\t\t   && IDENTIFIER_TYPENAME_P (fn_name))\n+\t    /* The method in the class is a member template\n+\t       conversion operator.  We are declaring another\n+\t       conversion operator.  It is possible that even though\n+\t       the names don't match, there is some specialization\n+\t       occurring.  */\n+\t    templates = \n+\t      tree_cons (NULL_TREE, fndecl, templates);\n+\t}\n+    }\n+\n+  if (templates)\n+    /* This function might be an instantiation or a specialization.\n+       We should verify that this is possible.  If it is, we must\n+       somehow add the new declaration to the method vector for the\n+       class.  Perhaps we should use add_method?  For now, we simply\n+       return NULL_TREE, which lets the caller know that this\n+       function is new, but we don't print an error message.  */\n+    return NULL_TREE;\n \n   if (methods != end)\n     {\n@@ -2792,15 +2872,14 @@ finish_file ()\n \n   for (fnname = maybe_templates; fnname; fnname = TREE_CHAIN (fnname))\n     {\n-      tree *args, fn, decl = TREE_VALUE (fnname);\n+      tree args, fn, decl = TREE_VALUE (fnname);\n \n       if (DECL_INITIAL (decl))\n \tcontinue;\n \n       fn = TREE_PURPOSE (fnname);\n       args = get_bindings (fn, decl);\n       fn = instantiate_template (fn, args);\n-      free (args);\n       instantiate_decl (fn);\n     }\n "}, {"sha": "ce2bc3b88dc59d72395c0fb327b1d167acf2074f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -722,33 +722,42 @@ dump_decl (t, v)\n \n     case TEMPLATE_DECL:\n       {\n-\ttree args = DECL_TEMPLATE_PARMS (t);\n-\tint i, len = args ? TREE_VEC_LENGTH (args) : 0;\n-\tOB_PUTS (\"template <\");\n-\tfor (i = 0; i < len; i++)\n+\ttree orig_args = DECL_TEMPLATE_PARMS (t);\n+\ttree args;\n+\tint i; \n+\tfor (args = orig_args = nreverse (orig_args); \n+\t     args;\n+\t     args = TREE_CHAIN (args))\n \t  {\n-\t    tree arg = TREE_VEC_ELT (args, i);\n-\t    tree defval = TREE_PURPOSE (arg);\n-\t    arg = TREE_VALUE (arg);\n-\t    if (TREE_CODE (arg) == TYPE_DECL)\n-\t      {\n-\t\tOB_PUTS (\"class \");\n-\t\tOB_PUTID (DECL_NAME (arg));\n-\t      }\n-\t    else\n-\t      dump_decl (arg, 1);\n+\t    int len = TREE_VEC_LENGTH (TREE_VALUE (args));\n \n-\t    if (defval)\n+\t    OB_PUTS (\"template <\");\n+\t    for (i = 0; i < len; i++)\n \t      {\n-\t\tOB_PUTS (\" = \");\n-\t\tdump_decl (defval, 1);\n-\t      }\n+\t\ttree arg = TREE_VEC_ELT (TREE_VALUE (args), i);\n+\t\ttree defval = TREE_PURPOSE (arg);\n+\t\targ = TREE_VALUE (arg);\n+\t\tif (TREE_CODE (arg) == TYPE_DECL)\n+\t\t  {\n+\t\t    OB_PUTS (\"class \");\n+\t\t    OB_PUTID (DECL_NAME (arg));\n+\t\t  }\n+\t\telse\n+\t\t  dump_decl (arg, 1);\n+\t\t\n+\t\tif (defval)\n+\t\t  {\n+\t\t    OB_PUTS (\" = \");\n+\t\t    dump_decl (defval, 1);\n+\t\t  }\n \t\t\n-\t    OB_PUTC2 (',', ' ');\n+\t\tOB_PUTC2 (',', ' ');\n+\t      }\n+\t    if (len != 0)\n+\t      OB_UNPUT (2);\n+\t    OB_PUTC2 ('>', ' ');\n \t  }\n-\tif (len != 0)\n-\t  OB_UNPUT (2);\n-\tOB_PUTC2 ('>', ' ');\n+\tnreverse(orig_args);\n \n \tif (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n \t  dump_type (TREE_TYPE (t), v);\n@@ -801,11 +810,18 @@ dump_function_decl (t, v)\n      tree t;\n      int v;\n {\n-  tree name = DECL_ASSEMBLER_NAME (t);\n-  tree fntype = TREE_TYPE (t);\n-  tree parmtypes = TYPE_ARG_TYPES (fntype);\n+  tree name;\n+  tree fntype;\n+  tree parmtypes;\n   tree cname = NULL_TREE;\n \n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+\n+  name = DECL_ASSEMBLER_NAME (t);\n+  fntype = TREE_TYPE (t);\n+  parmtypes = TYPE_ARG_TYPES (fntype);\n+\n   /* Friends have DECL_CLASS_CONTEXT set, but not DECL_CONTEXT.  */\n   if (DECL_CONTEXT (t))\n     cname = DECL_CLASS_CONTEXT (t);\n@@ -1349,8 +1365,17 @@ dump_expr (t, nop)\n     case TEMPLATE_CONST_PARM:\n       if (current_template_parms)\n \t{\n-\t  tree r = TREE_VEC_ELT (TREE_VALUE (current_template_parms),\n-\t\t\t\t TEMPLATE_CONST_IDX (t));\n+\t  int i;\n+\t  tree parms;\n+\t  tree r;\n+\n+\t  for (parms = current_template_parms;\n+\t       TREE_CHAIN (parms);\n+\t       parms = TREE_CHAIN (parms))\n+\t    ;\n+\n+\t  r = TREE_VEC_ELT (TREE_VALUE (parms),\n+\t\t\t    TEMPLATE_CONST_IDX (t));\n \t  dump_decl (TREE_VALUE (r), -1);\n \t}\n       else"}, {"sha": "7fca8a2138d430913d03940d50d772aa1b347db8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1190,6 +1190,8 @@ do_pending_inlines ()\n   context = hack_decl_function_context (t->fndecl);\n   if (context)\n     push_cp_function_context (context);\n+  if (is_member_template (t->fndecl))\n+    begin_member_template_processing (DECL_TI_ARGS (t->fndecl));\n   if (t->len > 0)\n     {\n       feed_input (t->buf, t->len);\n@@ -1226,7 +1228,9 @@ process_next_inline (t)\n {\n   tree context;\n   struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n-  context = hack_decl_function_context (i->fndecl);\n+  context = hack_decl_function_context (i->fndecl);  \n+  if (is_member_template (i->fndecl))\n+    end_member_template_processing ();\n   if (context)\n     pop_cp_function_context (context);\n   i = i->next;\n@@ -1249,6 +1253,8 @@ process_next_inline (t)\n       context = hack_decl_function_context (i->fndecl);\n       if (context)\n \tpush_cp_function_context (context);\n+      if (is_member_template (i->fndecl))\n+\tbegin_member_template_processing (DECL_TI_ARGS (i->fndecl));\n       feed_input (i->buf, i->len);\n       lineno = i->lineno;\n       input_filename = i->filename;"}, {"sha": "8a50dabac993941a6de554295837bf3fb1a8bcbc", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -648,7 +648,7 @@ build_overload_identifier (name)\n       arglist = TREE_VALUE (template);\n       template = TREE_PURPOSE (template);\n       tname = DECL_NAME (template);\n-      parmlist = DECL_ARGUMENTS (template);\n+      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n       nparms = TREE_VEC_LENGTH (parmlist);\n       OB_PUTC ('t');\n       icat (IDENTIFIER_LENGTH (tname));\n@@ -666,7 +666,7 @@ build_overload_identifier (name)\n \t    }\n \t  else\n \t    {\n-\t      parm = tsubst (parm, &TREE_VEC_ELT (arglist, 0),\n+\t      parm = tsubst (parm, arglist,\n \t\t\t     TREE_VEC_LENGTH (arglist), NULL_TREE);\n \t      /* It's a PARM_DECL.  */\n \t      build_overload_name (TREE_TYPE (parm), 0, 0);"}, {"sha": "7d9d5db7a343d8294e17ea4eff0052042c7db017", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -699,6 +699,22 @@ fn.def2:\n \t\t  $$ = start_method (specs, $2); goto rest_of_mdef; }\n \t| constructor_declarator\n \t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n+        | template_header fn.def2 \n+                { \n+\t\t  end_template_decl (); \n+\t\t  if ($2 && DECL_TEMPLATE_INFO ($2))\n+\t\t    {\n+\t\t      $$ = DECL_TI_TEMPLATE ($2); \n+\t\t      check_member_template ($$);\n+\t\t    }\n+\t\t  else if ($2)\n+\t\t    $$ = $2;\n+\t\t  else \n+\t\t    {\n+\t\t      cp_error(\"invalid member template declaration\");\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t}\n \t;\n \n return_id:\n@@ -2711,7 +2727,22 @@ component_decl_1:\n \t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n-\t;\n+        | template_header component_decl_1 \n+                { \n+\t\t  end_template_decl (); \n+\t\t  if ($2 && DECL_TEMPLATE_INFO ($2))\n+\t\t    {\n+\t\t      $$ = DECL_TI_TEMPLATE ($2); \n+\t\t      check_member_template ($$);\n+\t\t    }\n+\t\t  else if ($2)\n+\t\t    $$ = $2;\n+\t\t  else\n+\t\t    {\n+\t\t      cp_error(\"invalid member template declaration\");\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t}\n \n /* The case of exactly one component is handled directly by component_decl.  */\n /* ??? Huh? ^^^ */"}, {"sha": "3620253a6b5848f9247c73a683777b8a2c65d529", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 441, "deletions": 100, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -76,7 +76,148 @@ static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree));\n-static tree tsubst_enum\tPROTO((tree, tree *, int));\n+static tree tsubst_enum\tPROTO((tree, tree, int));\n+static tree add_to_template_args PROTO((tree, tree));\n+\n+/* Restore the template parameter context. */\n+\n+void \n+begin_member_template_processing (parms)\n+     tree parms;\n+{\n+  int i;\n+\n+  ++processing_template_decl;\n+  current_template_parms \n+    = tree_cons (build_int_2 (0, processing_template_decl),\n+\t\t parms, current_template_parms);\n+  for (i = 0; i < TREE_VEC_LENGTH (parms); ++i) \n+    {\n+      tree parm = TREE_VEC_ELT (parms, i);\n+\n+      switch (TREE_CODE (parm))\n+\t{\n+\tcase TEMPLATE_TYPE_PARM:\n+\t  pushdecl (TYPE_NAME (parm));\n+\t  break;\n+\n+\tcase TEMPLATE_CONST_PARM:\n+\t  pushdecl (parm);\n+\t  break;\n+\t  \n+\tdefault:\n+\t  my_friendly_abort (0);\n+\t}\n+    }\n+}\n+\n+/* Undo the effects of begin_member_template_processing. */\n+\n+void \n+end_member_template_processing ()\n+{\n+  if (! processing_template_decl)\n+    return;\n+\n+  --processing_template_decl;\n+  current_template_parms = TREE_CHAIN (current_template_parms);\n+}\n+\n+/* Returns non-zero iff T is a member template function.  Works if T\n+   is either a FUNCTION_DECL or a TEMPLATE_DECL.  */\n+\n+int\n+is_member_template (t)\n+     tree t;\n+{\n+  int r = 0;\n+\n+  if (DECL_FUNCTION_MEMBER_P (t) ||\n+      (TREE_CODE (t) == TEMPLATE_DECL && \n+       DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n+    {\n+      tree tmpl = NULL_TREE;\n+\n+      if (DECL_FUNCTION_TEMPLATE_P (t))\n+\ttmpl = t;\n+      else if (DECL_TEMPLATE_INFO (t) \n+\t       && DECL_FUNCTION_TEMPLATE_P (DECL_TI_TEMPLATE (t)))\n+\ttmpl = DECL_TI_TEMPLATE (t);\n+\n+      if (tmpl) \n+\t{\n+\t  tree parms = DECL_TEMPLATE_PARMS (tmpl);\n+\t  int parm_levels = list_length (parms);\n+\t  int template_class_levels = 0;\n+\t  tree ctx = DECL_CLASS_CONTEXT (t);\n+\n+\t  if (CLASSTYPE_TEMPLATE_INFO (ctx))\n+\t    {\n+\t      tree args;\n+\n+\t      /* Here, we should really count the number of levels\n+\t\t deep ctx is, making sure not to count any levels that\n+\t\t are just specializations.  Since there are no member\n+\t\t template classes yet, we don't have to do all that.  */\n+\n+\t      if (!CLASSTYPE_TEMPLATE_SPECIALIZATION (ctx))\n+\t\ttemplate_class_levels = 1;\n+\t      else\n+\t\t{\n+\t\t  int i;\n+\n+\t\t  args = CLASSTYPE_TI_ARGS (ctx);\n+\n+\t\t  if (args == NULL_TREE)\n+\t\t    template_class_levels = 1;\n+\t\t  else \n+\t\t    for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+\t\t      if (uses_template_parms (TREE_VEC_ELT (args, i)))\n+\t\t\t{\n+\t\t\t  template_class_levels++;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t}\n+\t    }\n+\n+\t  if (parm_levels > template_class_levels)\n+\t    r = 1;\n+\t}\n+    }\n+\n+  return r;\n+}\n+\n+/* Return a new template argument vector which contains all of ARGS,\n+   but has as its innermost set of arguments the EXTRA_ARGS.  */\n+\n+tree\n+add_to_template_args (args, extra_args)\n+     tree args;\n+     tree extra_args;\n+{\n+  tree new_args;\n+\n+  if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n+    {\n+      new_args = make_tree_vec (2);\n+      TREE_VEC_ELT (new_args, 0) = args;\n+    }\n+  else \n+    {\n+      int i;\n+\n+      new_args = make_tree_vec (TREE_VEC_LENGTH (args) - 1);\n+\n+      for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+\tTREE_VEC_ELT (new_args, i) = TREE_VEC_ELT (args, i);\n+    }\n+\t  \n+  TREE_VEC_ELT (new_args, \n+\t\tTREE_VEC_LENGTH (new_args) - 1) = extra_args;\n+\n+  return new_args;\n+}\n \n /* We've got a template header coming up; push to a new level for storing\n    the parms.  */\n@@ -216,28 +357,37 @@ tree\n current_template_args ()\n {\n   tree header = current_template_parms;\n-  tree args = NULL_TREE;\n+  int length = list_length (header);\n+  tree args = make_tree_vec (length);\n+  int l = length;\n+\n   while (header)\n     {\n       tree a = copy_node (TREE_VALUE (header));\n       int i = TREE_VEC_LENGTH (a);\n       TREE_TYPE (a) = NULL_TREE;\n       while (i--)\n \t{\n-\t  tree t = TREE_VALUE (TREE_VEC_ELT (a, i));\n-\t  if (TREE_CODE (t) == TYPE_DECL)\n-\t    t = TREE_TYPE (t);\n-\t  else\n-\t    t = DECL_INITIAL (t);\n+\t  tree t = TREE_VEC_ELT (a, i);\n+\n+\t  /* t will be a list if we are called from within a\n+\t     begin/end_template_parm_list pair, but a vector directly\n+\t     if within a begin/end_member_template_processing pair.  */\n+\t  if (TREE_CODE (t) == TREE_LIST) \n+\t    {\n+\t      t = TREE_VALUE (t);\n+\t      \n+\t      if (TREE_CODE (t) == TYPE_DECL)\n+\t\tt = TREE_TYPE (t);\n+\t      else\n+\t\tt = DECL_INITIAL (t);\n+\t    }\n+\n \t  TREE_VEC_ELT (a, i) = t;\n \t}\n-      args = tree_cons (TREE_PURPOSE (header), a, args);\n+      TREE_VEC_ELT (args, --l) = a;\n       header = TREE_CHAIN (header);\n     }\n-  args = nreverse (args);\n-\n-  /* FIXME Remove this when we support member templates.  */\n-  args = TREE_VALUE (args);\n \n   return args;\n }\n@@ -290,12 +440,15 @@ push_template_decl (decl)\n   if (! ctx || TYPE_BEING_DEFINED (ctx))\n     {\n       tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n-      DECL_TEMPLATE_PARMS (tmpl) = TREE_VALUE (current_template_parms);\n+      DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n       DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n+      if (DECL_LANG_SPECIFIC (decl))\n+\tDECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n     }\n   else\n     {\n       tree t;\n+      tree a;\n \n       if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n \tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n@@ -309,19 +462,54 @@ push_template_decl (decl)\n \t}\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n+      \n+      if (is_member_template (tmpl))\n+\t{\n+\t  a = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+\t  t = DECL_INNERMOST_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl));\n+\t  if (TREE_VEC_LENGTH (t) \n+\t      != TREE_VEC_LENGTH (a))\n+\t    {\n+\t      cp_error (\"got %d template parameters for `%#D'\",\n+\t\t\tTREE_VEC_LENGTH (a), decl);\n+\t      cp_error (\"  but %d required\", TREE_VEC_LENGTH (t));\n+\t    }\n+\t  if (TREE_VEC_LENGTH (args) > 1)\n+\t    /* Get the template parameters for the enclosing template\n+\t       class.  */ \n+\t    a = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 2);\n+\t  else\n+\t    a = NULL_TREE;\n+\t}\n+      else \n+\ta = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+\n+      t = NULL_TREE;\n \n       if (CLASSTYPE_TEMPLATE_SPECIALIZATION (ctx))\n-\tt = TREE_VALUE (CLASSTYPE_TI_SPEC_INFO (ctx));\n-      else\n-\tt = DECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (ctx));\n+\t{\n+\t  /* When processing an inline member template of a\n+\t     specialized class, there is no CLASSTYPE_TI_SPEC_INFO.  */\n+\t  if (CLASSTYPE_TI_SPEC_INFO (ctx))\n+\t    t = TREE_VALUE (CLASSTYPE_TI_SPEC_INFO (ctx));\n+\t}\n+      else if (CLASSTYPE_TEMPLATE_INFO (ctx))\n+\tt = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (ctx));\n+\n+      /* There should be template arguments if and only if there is a\n+\t template class.  */\n+      my_friendly_assert((a != NULL_TREE) == (t != NULL_TREE), 0);\n \n-      if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (args))\n+      if (t != NULL_TREE \n+\t  && TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t{\n \t  cp_error (\"got %d template parameters for `%#D'\",\n-\t\t    TREE_VEC_LENGTH (args), decl);\n+\t\t    TREE_VEC_LENGTH (a), decl);\n \t  cp_error (\"  but `%#T' has %d\", ctx, TREE_VEC_LENGTH (t));\n \t}\n     }\n+  /* Get the innermost set of template arguments. */\n+  args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n \n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   TREE_TYPE (tmpl) = TREE_TYPE (decl);\n@@ -330,7 +518,7 @@ push_template_decl (decl)\n     tmpl = pushdecl_top_level (tmpl);\n \n   if (primary)\n-    TREE_TYPE (DECL_TEMPLATE_PARMS (tmpl)) = tmpl;\n+    TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (tmpl)) = tmpl;\n \n   info = perm_tree_cons (tmpl, args, NULL_TREE);\n \n@@ -345,8 +533,6 @@ push_template_decl (decl)\n     DECL_TEMPLATE_INFO (decl) = info;\n }\n \n-tree tsubst\t\tPROTO ((tree, tree*, int, tree));\n-\n /* Convert all template arguments to their appropriate types, and return\n    a vector containing the resulting values.  If any error occurs, return\n    error_mark_node.  */\n@@ -401,10 +587,10 @@ coerce_template_parms (parms, arglist, in_decl)\n \t  else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n \t\t   == TYPE_DECL)\n \t    arg = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t  &TREE_VEC_ELT (vec, 0), i, in_decl);\n+\t\t\t  vec, i, in_decl);\n \t  else\n \t    arg = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t       &TREE_VEC_ELT (vec, 0), i, in_decl);\n+\t\t\t       vec, i, in_decl);\n \n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n@@ -460,7 +646,7 @@ coerce_template_parms (parms, arglist, in_decl)\n \t}\n       else\n \t{\n-\t  tree t = tsubst (TREE_TYPE (parm), &TREE_VEC_ELT (vec, 0),\n+\t  tree t = tsubst (TREE_TYPE (parm), vec,\n \t\t\t   TREE_VEC_LENGTH (vec), in_decl);\n \t  if (processing_template_decl)\n \t    val = arg;\n@@ -656,7 +842,7 @@ classtype_mangled_name (t)\n       tree name = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n       char *mangled_name = mangle_class_name_for_template\n \t(IDENTIFIER_POINTER (name),\n-\t DECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (t)),\n+\t DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (t)),\n \t CLASSTYPE_TI_ARGS (t));\n       tree id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = name;\n@@ -740,7 +926,7 @@ lookup_template_class (d1, arglist, in_decl)\n \n   if (PRIMARY_TEMPLATE_P (template))\n     {\n-      parmlist = DECL_TEMPLATE_PARMS (template);\n+      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n       arglist = coerce_template_parms (parmlist, arglist, template);\n       if (arglist == error_mark_node)\n@@ -1209,7 +1395,7 @@ instantiate_class_template (type)\n \t    tree elt;\n \n \t    TREE_VEC_ELT (bases, i) = elt\n-\t      = tsubst (TREE_VEC_ELT (pbases, i), &TREE_VEC_ELT (args, 0),\n+\t      = tsubst (TREE_VEC_ELT (pbases, i), args,\n \t\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n \t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n \n@@ -1241,7 +1427,7 @@ instantiate_class_template (type)\n       /* These will add themselves to CLASSTYPE_TAGS for the new type.  */\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \t{\n-\t  tree e, newtag = tsubst_enum (tag, &TREE_VEC_ELT (args, 0),\n+\t  tree e, newtag = tsubst_enum (tag, args, \n \t\t\t\t\tTREE_VEC_LENGTH (args));\n \n \t  *field_chain = grok_enum_decls (newtag, NULL_TREE);\n@@ -1252,15 +1438,15 @@ instantiate_class_template (type)\n \t    }\n \t}\n       else\n-\ttsubst (tag, &TREE_VEC_ELT (args, 0),\n+\ttsubst (tag, args,\n \t\tTREE_VEC_LENGTH (args), NULL_TREE);\n     }\n \n   /* Don't replace enum constants here.  */\n   for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n     if (TREE_CODE (t) != CONST_DECL)\n       {\n-\ttree r = tsubst (t, &TREE_VEC_ELT (args, 0),\n+\ttree r = tsubst (t, args,\n \t\t\t TREE_VEC_LENGTH (args), NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n@@ -1288,18 +1474,18 @@ instantiate_class_template (type)\n \n   DECL_FRIENDLIST (TYPE_MAIN_DECL (type))\n     = tsubst (DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern)),\n-\t      &TREE_VEC_ELT (args, 0), TREE_VEC_LENGTH (args), NULL_TREE);\n+\t      args, TREE_VEC_LENGTH (args), NULL_TREE);\n \n   {\n     tree d = CLASSTYPE_FRIEND_CLASSES (type)\n-      = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), &TREE_VEC_ELT (args, 0),\n+      = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args,\n \t\tTREE_VEC_LENGTH (args), NULL_TREE);\n \n     /* This does injection for friend classes.  */\n     for (; d; d = TREE_CHAIN (d))\n       TREE_VALUE (d) = xref_tag_from_type (TREE_VALUE (d), NULL_TREE, 1);\n \n-    d = tsubst (DECL_TEMPLATE_INJECT (template), &TREE_VEC_ELT (args, 0),\n+    d = tsubst (DECL_TEMPLATE_INJECT (template), args,\n \t\tTREE_VEC_LENGTH (args), NULL_TREE);\n \n     for (; d; d = TREE_CHAIN (d))\n@@ -1382,7 +1568,7 @@ lookup_nested_type_by_name (ctype, name)\n \n tree\n tsubst (t, args, nargs, in_decl)\n-     tree t, *args;\n+     tree t, args;\n      int nargs;\n      tree in_decl;\n {\n@@ -1471,15 +1657,108 @@ tsubst (t, args, nargs, in_decl)\n       }\n \n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_CONST_PARM:\n       {\n-\ttree arg = args[TEMPLATE_TYPE_IDX (t)];\n-\treturn cp_build_type_variant\n-\t  (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n-\t   TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\tint idx;\n+\tint level;\n+\n+\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\t  {\n+\t    idx = TEMPLATE_TYPE_IDX (t);\n+\t    level = TEMPLATE_TYPE_LEVEL (t);\n+\t  }\n+\telse\n+\t  {\n+\t    idx = TEMPLATE_CONST_IDX (t);\n+\t    level = TEMPLATE_CONST_LEVEL (t);\n+\t  }\n+\n+\tif (TREE_VEC_LENGTH (args) > 0) \n+\t  {\n+\t    tree arg = NULL_TREE;\n+\n+\t    if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t      {\n+\t\tif (TREE_VEC_LENGTH (args) >= level - 1)\n+\t\t  arg = TREE_VEC_ELT\n+\t\t    (TREE_VEC_ELT (args, level - 1), idx);\n+\t      }\n+\t    else if (level == 1)\n+\t      arg = TREE_VEC_ELT (args, idx);\n+\n+\t    if (arg != NULL_TREE)\n+\t      {\n+\t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\t\t  return cp_build_type_variant\n+\t\t    (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n+\t\t     TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\telse\n+\t\t  return arg;\n+\t      }\n+\t  }\n+\n+\t/* If we get here, we must have been looking at a parm for a\n+\t   more deeply nested template.  */\n+\tmy_friendly_assert((TREE_CODE (t) == TEMPLATE_CONST_PARM \n+\t\t\t    && TEMPLATE_CONST_LEVEL (t) > 1) \n+\t\t\t   || (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t\t\t       && TEMPLATE_TYPE_LEVEL (t) > 1),\n+\t\t\t   0);\n+\treturn t;\n       }\n \n-    case TEMPLATE_CONST_PARM:\n-      return args[TEMPLATE_CONST_IDX (t)];\n+    case TEMPLATE_DECL:\n+      {\n+\t/* We can get here when processing a member template function\n+\t   of a template class.  */\n+\ttree tmpl;\n+\ttree decl = DECL_TEMPLATE_RESULT (t);\n+\ttree new_decl;\n+\ttree parms;\n+\tint i;\n+\n+\t/* We might already have an instance of this template. */\n+\ttree instances = DECL_TEMPLATE_INSTANTIATIONS (t);\n+\ttree ctx = tsubst (DECL_CLASS_CONTEXT (t), args, nargs, in_decl); \n+\t  \n+\tfor (; instances; instances = TREE_CHAIN (instances))\n+\t  if (DECL_CLASS_CONTEXT (TREE_VALUE (instances)) == ctx)\n+\t    return TREE_VALUE (instances);\n+\n+\t/* Make a new template decl.  It will be similar to the\n+\t   original, but will record the current template arguments. \n+\t   We also create a new function declaration, which is just\n+\t   like the old one, but points to this new template, rather\n+\t   than the old one.  */\n+\ttmpl = copy_node (t);\n+\tcopy_lang_decl (tmpl);\n+\tmy_friendly_assert (DECL_LANG_SPECIFIC (tmpl) != 0, 0);\n+\tDECL_CHAIN (tmpl) = NULL_TREE;\n+\tTREE_CHAIN (tmpl) = NULL_TREE;\n+\tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n+\tnew_decl = tsubst (decl, args, nargs, in_decl);\n+\tDECL_RESULT (tmpl) = new_decl;\n+\tDECL_INITIAL (new_decl) = DECL_INITIAL (decl);\n+\tDECL_TI_TEMPLATE (new_decl) = tmpl;\n+\tTREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n+\tDECL_TEMPLATE_INSTANTIATIONS(tmpl) = NULL_TREE;\n+\n+\t/* The template parameters for this new template are all the\n+\t   template parameters for the old template, except the\n+\t   outermost level of parameters. */\n+\tDECL_TEMPLATE_PARMS (tmpl)\n+\t  = copy_node (DECL_TEMPLATE_PARMS (tmpl));\n+\tfor (parms = DECL_TEMPLATE_PARMS (tmpl);\n+\t     TREE_CHAIN (parms) != NULL_TREE;\n+\t     parms = TREE_CHAIN (parms))\n+\t  TREE_CHAIN (parms) = copy_node (TREE_CHAIN (parms));\n+\n+\t/* Record this partial instantiation. */\n+\tDECL_TEMPLATE_INSTANTIATIONS (t)\n+\t  = perm_tree_cons (NULL_TREE, tmpl,\n+\t\t\t    DECL_TEMPLATE_INSTANTIATIONS (t));\n+\treturn tmpl;\n+      }\n \n     case FUNCTION_DECL:\n       {\n@@ -1516,7 +1795,7 @@ tsubst (t, args, nargs, in_decl)\n \t/* Do we already have this instantiation?  */\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n-\t    tree tmpl = TREE_PURPOSE (DECL_TEMPLATE_INFO (t));\n+\t    tree tmpl = DECL_TI_TEMPLATE (t);\n \t    tree decls = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n \n \t    for (; decls; decls = TREE_CHAIN (decls))\n@@ -1622,8 +1901,10 @@ tsubst (t, args, nargs, in_decl)\n \t  {\n \t    tree tmpl = DECL_TI_TEMPLATE (t);\n \t    tree *declsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n-\t    tree argvec = tsubst (TREE_VALUE (DECL_TEMPLATE_INFO (t)),\n-\t\t\t\t  args, nargs, in_decl);\n+\t    tree argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n+\n+\t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n+\t      argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n \n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \t    *declsp = perm_tree_cons (argvec, r, *declsp);\n@@ -1727,8 +2008,7 @@ tsubst (t, args, nargs, in_decl)\n \t  {\n \t    tree tmpl = DECL_TI_TEMPLATE (t);\n \t    tree *declsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n-\t    tree argvec = tsubst (TREE_VALUE (DECL_TEMPLATE_INFO (t)),\n-\t\t\t\t  args, nargs, in_decl);\n+\t    tree argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n \n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \t    *declsp = perm_tree_cons (argvec, r, *declsp);\n@@ -2013,7 +2293,7 @@ do_poplevel ()\n \n tree\n tsubst_copy (t, args, nargs, in_decl)\n-     tree t, *args;\n+     tree t, args;\n      int nargs;\n      tree in_decl;\n {\n@@ -2048,6 +2328,12 @@ tsubst_copy (t, args, nargs, in_decl)\n       mark_used (t);\n       return t;\n \n+    case TEMPLATE_DECL:\n+      if (is_member_template (t))\n+\treturn tsubst (t, args, nargs, in_decl);\n+      else\n+\treturn t;\n+\n #if 0\n     case IDENTIFIER_NODE:\n       return do_identifier (t, 0);\n@@ -2241,7 +2527,7 @@ tsubst_copy (t, args, nargs, in_decl)\n \n tree\n tsubst_expr (t, args, nargs, in_decl)\n-     tree t, *args;\n+     tree t, args;\n      int nargs;\n      tree in_decl;\n {\n@@ -2543,7 +2829,7 @@ tsubst_expr (t, args, nargs, in_decl)\n \n tree\n instantiate_template (tmpl, targ_ptr)\n-     tree tmpl, *targ_ptr;\n+     tree tmpl, targ_ptr;\n {\n   tree fndecl;\n   int i, len;\n@@ -2555,12 +2841,12 @@ instantiate_template (tmpl, targ_ptr)\n   function_maybepermanent_obstack = &permanent_obstack;\n \n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n-  len = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n+  len = DECL_NTPARMS (tmpl);\n \n   i = len;\n   while (i--)\n     {\n-      tree t = targ_ptr [i];\n+      tree t = TREE_VEC_ELT (targ_ptr, i);\n       if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n \t{\n \t  tree nt = target_type (t);\n@@ -2572,9 +2858,12 @@ instantiate_template (tmpl, targ_ptr)\n \t      goto out;\n \t    }\n \t}\n-      targ_ptr[i] = copy_to_permanent (t);\n+      TREE_VEC_ELT (targ_ptr, i) = copy_to_permanent (t);\n     }\n \n+  if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n+    targ_ptr = add_to_template_args (DECL_TI_ARGS (tmpl), targ_ptr);\n+\n   /* substitute template parameters */\n   fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr, len, tmpl);\n \n@@ -2606,6 +2895,42 @@ overload_template_name (type)\n   pushdecl_class_level (decl);\n }\n \n+/* Like type_unfication but designed specially to handle conversion\n+   operators.  */\n+\n+int\n+fn_type_unification (fn, targs, args, return_type, strict)\n+     tree fn, targs, args, return_type;\n+     int strict;\n+{\n+  int i, dummy = 0;\n+  tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  tree decl_arg_types = args;\n+\n+  my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n+\n+  if (IDENTIFIER_TYPENAME_P (DECL_NAME (fn))) \n+    {\n+      /* This is a template conversion operator.  Use the return types\n+         as well as the argument types.  */\n+      fn_arg_types = tree_cons (NULL_TREE, \n+\t\t\t\tTREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t\tfn_arg_types);\n+      decl_arg_types = tree_cons (NULL_TREE,\n+\t\t\t\t  return_type,\n+\t\t\t\t  decl_arg_types);\n+    }\n+\n+  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n+\t\t\t&TREE_VEC_ELT (targs, 0), \n+\t\t\tfn_arg_types,\n+\t\t\tdecl_arg_types,\n+\t\t\t&dummy, 0, strict);\n+\n+  return i;\n+}\n+\n+\n /* Type unification.\n \n    We have a function template signature with one or more references to\n@@ -2718,10 +3043,11 @@ type_unification (tparms, targs, parms, args, nsubsts, subr, strict)\n \t      /* Have to back unify here */\n \t      arg = TREE_VALUE (arg);\n \t      nsubsts = 0;\n-\t      ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (arg));\n+\t      ntparms = DECL_NTPARMS (arg);\n \t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n \t      parm = tree_cons (NULL_TREE, parm, NULL_TREE);\n-\t      return type_unification (DECL_TEMPLATE_PARMS (arg), targs,\n+\t      return type_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n+\t\t\t\t       targs,\n \t\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (arg)),\n \t\t\t\t       parm, &nsubsts, 0, strict);\n \t    }\n@@ -3022,20 +3348,18 @@ int\n more_specialized (pat1, pat2)\n      tree pat1, pat2;\n {\n-  tree *targs;\n+  tree targs;\n   int winner = 0;\n \n   targs = get_bindings (pat1, pat2);\n   if (targs)\n     {\n-      free (targs);\n       --winner;\n     }\n \n   targs = get_bindings (pat2, pat1);\n   if (targs)\n     {\n-      free (targs);\n       ++winner;\n     }\n \n@@ -3071,20 +3395,21 @@ more_specialized_class (pat1, pat2)\n /* Return the template arguments that will produce the function signature\n    DECL from the function template FN.  */\n \n-tree *\n+tree \n get_bindings (fn, decl)\n      tree fn, decl;\n {\n-  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n-  tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n-  int i, dummy = 0;\n-  i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (fn)),\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t&dummy, 0, 1);\n+  int ntparms = DECL_NTPARMS (fn);\n+  tree targs = make_tree_vec (ntparms);\n+  int i;\n+\n+  i = fn_type_unification (fn, targs, \n+\t\t\t   TYPE_ARG_TYPES (TREE_TYPE (decl)), \n+\t\t\t   TREE_TYPE (TREE_TYPE (decl)),\n+\t\t\t   1);\n+\n   if (i == 0)\n     return targs;\n-  free (targs);\n   return 0;\n }\n \n@@ -3122,15 +3447,14 @@ tree\n most_specialized (fns, decl)\n      tree fns, decl;\n {\n-  tree fn, champ, *args, *p;\n+  tree fn, champ, args, *p;\n   int fate;\n \n   for (p = &fns; *p; )\n     {\n       args = get_bindings (TREE_VALUE (*p), decl);\n       if (args)\n \t{\n-\t  free (args);\n \t  p = &TREE_CHAIN (*p);\n \t}\n       else\n@@ -3234,6 +3558,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n   tree fn;\n   tree result = NULL_TREE;\n   int extern_p = 0;\n+  tree templates = NULL_TREE;\n \n   if (! DECL_LANG_SPECIFIC (decl))\n     {\n@@ -3261,43 +3586,61 @@ do_decl_instantiation (declspecs, declarator, storage)\n \t       fn = IDENTIFIER_GLOBAL_VALUE (name),\n \t       fn && DECL_TEMPLATE_INSTANTIATION (fn))\n \tresult = fn;\n+      else \n+\t{\n+\t  /* Maybe this is an instantiation of a member template\n+\t     function.  */\n+\t  tree ctype = DECL_CONTEXT (decl);\n+\n+\t  name = DECL_NAME (decl);\n+\t  fn = lookup_fnfields (TYPE_BINFO (ctype), name, 1);\n+\t  if (fn)\n+\t    fn = TREE_VALUE (fn);\n+\n+\t  for (; fn; fn = DECL_CHAIN (fn))\n+\t    if (decls_match (fn, decl) && DECL_DEFER_OUTPUT (fn))\n+\t      {\n+\t\tresult = fn;\n+\t\tbreak;\n+\t      }\n+\t    else if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t}\n     }\n   else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n     {\n-      tree templates = NULL_TREE;\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n-\tif (decls_match (fn, decl)\n-\t    && DECL_DEFER_OUTPUT (fn))\n+\tif (decls_match (fn, decl) && DECL_DEFER_OUTPUT (fn))\n \t  {\n \t    result = fn;\n \t    break;\n \t  }\n \telse if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t  templates = decl_tree_cons (NULL_TREE, fn, templates);\n+    }\n \n-      if (! result)\n+  if (templates && !result)\n+    {\n+      tree args;\n+      result = most_specialized (templates, decl);\n+      if (result == error_mark_node)\n \t{\n-\t  tree *args;\n-\t  result = most_specialized (templates, decl);\n-\t  if (result == error_mark_node)\n+\t  char *str = \"candidates are:\";\n+\t  cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n+\t  for (fn = templates; fn; fn = TREE_CHAIN (fn))\n \t    {\n-\t      char *str = \"candidates are:\";\n-\t      cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n-\t      for (fn = templates; fn; fn = TREE_CHAIN (fn))\n-\t\t{\n-\t\t  cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n-\t\t  str = \"               \";\n-\t\t}\n-\t      return;\n-\t    }\n-\t  else if (result)\n-\t    {\n-\t      args = get_bindings (result, decl);\n-\t      result = instantiate_template (result, args);\n-\t      free (args);\n+\t      cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n+\t      str = \"               \";\n \t    }\n+\t  return;\n+\t}\n+      else if (result)\n+\t{\n+\t  args = get_bindings (result, decl);\n+\t  result = instantiate_template (result, args);\n \t}\n     }\n+\n   if (! result)\n     {\n       cp_error (\"no matching template for `%D' found\", decl);\n@@ -3477,7 +3820,7 @@ instantiate_decl (d)\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n       DECL_INITIAL (d) = tsubst_expr\n-\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+\t(DECL_INITIAL (pattern), args,\n \t TREE_VEC_LENGTH (args), tmpl);\n       popclass (1);\n     }\n@@ -3527,15 +3870,15 @@ instantiate_decl (d)\n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n   save_ti = DECL_TEMPLATE_INFO (pattern);\n   DECL_TEMPLATE_INFO (pattern) = NULL_TREE;\n-  td = tsubst (pattern, &TREE_VEC_ELT (args, 0), TREE_VEC_LENGTH (args), tmpl);\n+  td = tsubst (pattern, args, TREE_VEC_LENGTH (args), tmpl);\n   DECL_TEMPLATE_INFO (pattern) = save_ti;\n \n   /* And set up DECL_INITIAL, since tsubst doesn't.  */\n   if (TREE_CODE (td) == VAR_DECL)\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n       DECL_INITIAL (td) = tsubst_expr\n-\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+\t(DECL_INITIAL (pattern), args,\n \t TREE_VEC_LENGTH (args), tmpl);\n       popclass (1);\n     }\n@@ -3570,7 +3913,7 @@ instantiate_decl (d)\n \t{\n \t  store_return_init\n \t    (TREE_OPERAND (t, 0),\n-\t     tsubst_expr (TREE_OPERAND (t, 1), &TREE_VEC_ELT (args, 0),\n+\t     tsubst_expr (TREE_OPERAND (t, 1), args,\n \t\t\t  TREE_VEC_LENGTH (args), tmpl));\n \t  t = TREE_CHAIN (t);\n \t}\n@@ -3591,8 +3934,7 @@ instantiate_decl (d)\n       keep_next_level ();\n \n       my_friendly_assert (TREE_CODE (t) == COMPOUND_STMT, 42);\n-      tsubst_expr (t, &TREE_VEC_ELT (args, 0),\n-\t\t   TREE_VEC_LENGTH (args), tmpl);\n+      tsubst_expr (t, args, TREE_VEC_LENGTH (args), tmpl);\n \n       finish_function (lineno, 0, nested);\n     }\n@@ -3613,14 +3955,13 @@ tsubst_chain (t, argvec)\n {\n   if (t)\n     {\n-      tree first = tsubst (t, &TREE_VEC_ELT (argvec, 0),\n+      tree first = tsubst (t, argvec,\n \t\t\t   TREE_VEC_LENGTH (argvec), NULL_TREE);\n       tree last = first;\n \n       for (t = TREE_CHAIN (t); t; t = TREE_CHAIN (t))\n \t{\n-\t  tree x = tsubst (t, &TREE_VEC_ELT (argvec, 0),\n-\t\t\t   TREE_VEC_LENGTH (argvec), NULL_TREE);\n+\t  tree x = tsubst (t, argvec, TREE_VEC_LENGTH (argvec), NULL_TREE);\n \t  TREE_CHAIN (last) = x;\n \t  last = x;\n \t}\n@@ -3639,9 +3980,9 @@ tsubst_expr_values (t, argvec)\n \n   for (; t; t = TREE_CHAIN (t))\n     {\n-      tree pur = tsubst_copy (TREE_PURPOSE (t), &TREE_VEC_ELT (argvec, 0),\n+      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec,\n \t\t\t      TREE_VEC_LENGTH (argvec), NULL_TREE);\n-      tree val = tsubst_expr (TREE_VALUE (t), &TREE_VEC_ELT (argvec, 0),\n+      tree val = tsubst_expr (TREE_VALUE (t), argvec,\n \t\t\t      TREE_VEC_LENGTH (argvec), NULL_TREE);\n       *p = build_tree_list (pur, val);\n       p = &TREE_CHAIN (*p);\n@@ -3691,7 +4032,7 @@ add_maybe_template (d, fns)\n \n static tree\n tsubst_enum (tag, args, nargs)\n-     tree tag, *args;\n+     tree tag, args;\n      int nargs;\n {\n   tree newtag = start_enum (TYPE_IDENTIFIER (tag));"}, {"sha": "078793c8cfa454eaeb92bdf239a63f82a53c4775", "filename": "gcc/cp/search.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -1637,6 +1637,23 @@ lookup_fnfields_1 (type, name)\n \t  if (DECL_NAME (*methods) == name)\n \t    break;\n \t}\n+\n+      /* If we didn't find it, it might have been a template\n+\t conversion operator.  (Note that we don't look for this case\n+\t above so that we will always find specializations first.)  */\n+      if (methods == end \n+\t  && IDENTIFIER_TYPENAME_P (name)) \n+\t{\n+\t  methods = &TREE_VEC_ELT (method_vec, 0) + 1;\n+\t  \n+\t  while (++methods != end)\n+\t    {\n+\t      if (TREE_CODE (*methods) == TEMPLATE_DECL \n+\t\t  && IDENTIFIER_TYPENAME_P (DECL_NAME (*methods)))\n+\t\tbreak;\n+\t    }\n+\t}\n+\n       if (methods != end)\n \treturn methods - &TREE_VEC_ELT (method_vec, 0);\n     }"}, {"sha": "bf542af547ff2047eef11e354262e2c535c85674", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -2005,7 +2005,8 @@ cp_tree_equal (t1, t2)\n       return 0;\n \n     case TEMPLATE_CONST_PARM:\n-      return TEMPLATE_CONST_IDX (t1) == TEMPLATE_CONST_IDX (t2);\n+      return TEMPLATE_CONST_IDX (t1) == TEMPLATE_CONST_IDX (t2)\n+\t&& TEMPLATE_CONST_LEVEL (t1) == TEMPLATE_CONST_LEVEL (t2);\n \n     case SIZEOF_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t1, 0)) != TREE_CODE (TREE_OPERAND (t2, 0)))"}, {"sha": "b000efbead5abe8954e02b41054a9e7d80168abb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1c668807d74ad4dfab8c0413499b31f638258/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=98c1c668807d74ad4dfab8c0413499b31f638258", "patch": "@@ -832,7 +832,8 @@ comptypes (type1, type2, strict)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2);\n+      return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n+\t&& TEMPLATE_TYPE_LEVEL (t1) == TEMPLATE_TYPE_LEVEL (t2);\n \n     case TYPENAME_TYPE:\n       if (TYPE_IDENTIFIER (t1) != TYPE_IDENTIFIER (t2))\n@@ -2296,7 +2297,8 @@ build_x_function_call (function, params, decl)\n     {\n       tree basetype = NULL_TREE;\n \n-      if (TREE_CODE (function) == FUNCTION_DECL)\n+      if (TREE_CODE (function) == FUNCTION_DECL\n+\t  || DECL_FUNCTION_TEMPLATE_P (function))\n \t{\n \t  basetype = DECL_CLASS_CONTEXT (function);\n "}]}