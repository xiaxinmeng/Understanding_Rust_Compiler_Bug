{"sha": "32de079ac5d2f7deea7a1cbd2422c1fb87016766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJkZTA3OWFjNWQyZjdkZWVhN2ExY2JkMjQyMmMxZmI4NzAxNjc2Ng==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "message": "(arm_increase_location, get_prologue_size): Delete.\n\n(arm_naked_function_p): Add declaration.\n(arm_pic_register): Define.\n(all_procs): Delete entries for arm{60,620,70,7d,7di,700i,710c}; add\nentries for arm{7m,7500fe,8}, strongarm and strongarm110.\n(arm_override_options): Rework so that configure can properly set\nthe default processor type. Add a warning that PIC code is not yet\nsupported.\n(legitimate_pic_operand_p, legitimize_pic_address): New functions.\n(is_pic, arm_finalize_pic): New functions.\n(arm_adjust_cost): New function.\n(const_pool_offset, arm_backwards_branch, short_branch): Delete.\n(arm_insn_not_targeted): Delete.\n(add_constant): If generating AOF syntax, then handle pic specially.\n(output_ascii_pseudo_op): Delete calls to arm_increase_location.\n(function_really_clobbers_lr): Calls followed by a barrier don't\nclobber the link register.\n(output_func_prologue): Handle AOF syntax pic code.\n(output_func_epilogue): Handle cases where lr_save_eliminated is set.\nDelete call to arm_increase_location.\n(arm_asm_output_label): Simplify, since we no-longer need to cache the\nlabel's address.\n(aof_pic_entry): New function to keep track of pic symbols.\n(aof_dump_pic_table): New function.\n\nFrom-SVN: r14049", "tree": {"sha": "36d8e7b4b4db6897642edd7a7658cfab46c19af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d8e7b4b4db6897642edd7a7658cfab46c19af3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32de079ac5d2f7deea7a1cbd2422c1fb87016766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32de079ac5d2f7deea7a1cbd2422c1fb87016766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32de079ac5d2f7deea7a1cbd2422c1fb87016766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32de079ac5d2f7deea7a1cbd2422c1fb87016766/comments", "author": null, "committer": null, "parents": [{"sha": "858a9ffcb70e7fbf3c28baee571ef2785d8b798f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858a9ffcb70e7fbf3c28baee571ef2785d8b798f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858a9ffcb70e7fbf3c28baee571ef2785d8b798f"}], "stats": {"total": 508, "additions": 363, "deletions": 145}, "files": [{"sha": "931a938a545568ffae572d3c346f87b5bfdd6027", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 363, "deletions": 145, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32de079ac5d2f7deea7a1cbd2422c1fb87016766/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32de079ac5d2f7deea7a1cbd2422c1fb87016766/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=32de079ac5d2f7deea7a1cbd2422c1fb87016766", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for ARM/RISCiX.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    \t      and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -46,12 +46,11 @@ Boston, MA 02111-1307, USA.  */\n /* Some function declarations.  */\n extern FILE *asm_out_file;\n extern char *output_multi_immediate ();\n-extern void arm_increase_location ();\n \n HOST_WIDE_INT int_log2 PROTO ((HOST_WIDE_INT));\n-static int get_prologue_size PROTO ((void));\n static int arm_gen_constant PROTO ((enum rtx_code, enum machine_mode,\n \t\t\t\t    HOST_WIDE_INT, rtx, rtx, int, int));\n+static int arm_naked_function_p PROTO ((tree func));\n \n /*  Define the information needed to generate branch insns.  This is\n    stored from the compare operation. */\n@@ -74,7 +73,7 @@ char *target_fpe_name = NULL;\n /* Nonzero if this is an \"M\" variant of the processor.  */\n int arm_fast_multiply = 0;\n \n-/* Nonzero if this chip support the ARM Architecture 4 extensions */\n+/* Nonzero if this chip supports the ARM Architecture 4 extensions */\n int arm_arch4 = 0;\n \n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n@@ -85,26 +84,16 @@ enum machine_mode output_memory_reference_mode;\n /* Nonzero if the prologue must setup `fp'.  */\n int current_function_anonymous_args;\n \n+/* The register number to be used for the PIC offset register.  */\n+int arm_pic_register = 9;\n+\n /* Location counter of .text segment.  */\n int arm_text_location = 0;\n \n /* Set to one if we think that lr is only saved because of subroutine calls,\n    but all of these can be `put after' return insns */\n int lr_save_eliminated;\n \n-/* A hash table is used to store text segment labels and their associated\n-   offset from the start of the text segment.  */\n-struct label_offset\n-{\n-  char *name;\n-  int offset;\n-  struct label_offset *cdr;\n-};\n-\n-#define LABEL_HASH_SIZE  257\n-\n-static struct label_offset *offset_table[LABEL_HASH_SIZE];\n-\n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed. */\n \n@@ -144,6 +133,7 @@ struct arm_cpu_select arm_select[3] =\n #define FL_MODE32     0x08            /* 32-bit mode support */\n #define FL_ARCH4      0x10            /* Architecture rel 4 */\n #define FL_THUMB      0x20            /* Thumb aware */\n+\n struct processors\n {\n   char *name;\n@@ -159,26 +149,33 @@ static struct processors all_procs[] =\n   {\"arm250\",\tPROCESSOR_ARM2, FL_CO_PROC | FL_MODE26},\n   {\"arm3\",\tPROCESSOR_ARM2, FL_CO_PROC | FL_MODE26},\n   {\"arm6\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm60\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm600\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm610\",\tPROCESSOR_ARM6, FL_MODE32 | FL_MODE26},\n-  {\"arm620\",\tPROCESSOR_ARM6, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm7\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm70\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm7d\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm7di\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n+  /* arm7m doesn't exist on its own, only in conjuction with D, (and I), but\n+     those don't alter the code, so it is sometimes known as the arm7m */\n+  {\"arm7m\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n+\t\t\t\t | FL_MODE26)},\n   {\"arm7dm\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n \t\t\t\t | FL_MODE26)},\n   {\"arm7dmi\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n \t\t\t\t | FL_MODE26)},\n   {\"arm700\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n-  {\"arm700i\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm710\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n-  {\"arm710c\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n   {\"arm7100\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n   {\"arm7500\",\tPROCESSOR_ARM7, FL_MODE32 | FL_MODE26},\n+  /* Doesn't really have an external co-proc, but does have embedded fpu */\n+  {\"arm7500fe\",\tPROCESSOR_ARM7, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n   {\"arm7tdmi\",\tPROCESSOR_ARM7, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n \t\t\t\t | FL_ARCH4 | FL_THUMB)},\n+  {\"arm8\",\tPROCESSOR_ARM8, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n+\t\t\t\t | FL_ARCH4)},\n+  {\"arm810\",\tPROCESSOR_ARM8, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n+\t\t\t\t | FL_ARCH4)},\n+  {\"strongarm\",\tPROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n+\t\t\t\t  | FL_ARCH4)},\n+  {\"strongarm110\", PROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n+\t\t\t\t     | FL_ARCH4)},\n   {NULL, 0, 0}\n };\n \n@@ -191,9 +188,31 @@ arm_override_options ()\n   int flags = 0;\n   int i;\n   struct arm_cpu_select *ptr;\n+  static struct cpu_default {\n+    int cpu;\n+    char *name;\n+  } cpu_defaults[] = {\n+    { TARGET_CPU_arm2, \"arm2\" },\n+    { TARGET_CPU_arm6, \"arm6\" },\n+    { TARGET_CPU_arm610, \"arm610\" },\n+    { TARGET_CPU_arm7dm, \"arm7dm\" },\n+    { TARGET_CPU_arm7500fe, \"arm7500fe\" },\n+    { TARGET_CPU_arm7tdmi, \"arm7tdmi\" },\n+    { TARGET_CPU_arm8, \"arm8\" },\n+    { TARGET_CPU_arm810, \"arm810\" },\n+    { TARGET_CPU_strongarm, \"strongarm\" },\n+    { 0, 0 }\n+  };\n+  struct cpu_default *def;\n+\n+  /* Set the default.  */\n+  for (def = &cpu_defaults[0]; def->name; ++def)\n+    if (def->cpu == TARGET_CPU_DEFAULT)\n+      break;\n+  if (! def->name)\n+    abort ();\n \n-  arm_cpu = PROCESSOR_DEFAULT;\n-  arm_select[0].string = TARGET_CPU_DEFAULT;\n+  arm_select[0].string = def->name;\n \n   for (i = 0; i < sizeof (arm_select) / sizeof (arm_select[0]); i++)\n     {\n@@ -225,25 +244,26 @@ arm_override_options ()\n     target_flags |= ARM_FLAG_APCS_FRAME;\n \n   if (TARGET_6)\n-    {\n-      warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu=<proc>\");\n-      target_flags |= ARM_FLAG_APCS_32;\n-      arm_cpu = PROCESSOR_ARM6;\n-    }\n+    warning (\"Option '-m6' deprecated.  Use: '-mapcs-32' or -mcpu=<proc>\");\n \n   if (TARGET_3)\n-    {\n-      warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu=<proc>\");\n-      target_flags &= ~ARM_FLAG_APCS_32;\n-      arm_cpu = PROCESSOR_ARM2;\n-    }\n+    warning (\"Option '-m3' deprecated.  Use: '-mapcs-26' or -mcpu=<proc>\");\n \n   if (TARGET_APCS_REENT && flag_pic)\n     fatal (\"-fpic and -mapcs-reent are incompatible\");\n \n   if (TARGET_APCS_REENT)\n-    warning (\"APCS reentrant code not supported.  Ignored\");\n+    warning (\"APCS reentrant code not supported.\");\n+\n+  /* If stack checking is disabled, we can use r10 as the PIC register,\n+     which keeps r9 available.  */\n+  if (flag_pic && ! TARGET_APCS_STACK)\n+    arm_pic_register = 10;\n \n+  /* Well, I'm about to have a go, but pic is NOT going to be compatible\n+     with APCS reentrancy, since that requires too much support in the\n+     assembler and linker, and the ARMASM assembler seems to lack some\n+     required directives.  */\n   if (flag_pic)\n     warning (\"Position independent code not supported.  Ignored\");\n \n@@ -297,6 +317,7 @@ arm_override_options ()\n   arm_prog_mode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n }\n \f\n+\n /* Return 1 if it is possible to return using a single instruction */\n \n int\n@@ -1071,6 +1092,178 @@ arm_return_in_memory (type)\n   return 1;\n }\n \n+int\n+legitimate_pic_operand_p (x)\n+     rtx x;\n+{\n+  if (CONSTANT_P (x) && flag_pic\n+      && (GET_CODE (x) == SYMBOL_REF\n+\t  || (GET_CODE (x) == CONST\n+\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+rtx\n+legitimize_pic_address (orig, mode, reg)\n+     rtx orig;\n+     enum machine_mode mode;\n+     rtx reg;\n+{\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      rtx pic_ref, address;\n+      rtx insn;\n+      int subregs = 0;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress || reload_completed)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\n+\t  subregs = 1;\n+\t}\n+\n+#ifdef AOF_ASSEMBLER\n+      /* The AOF assembler can generate relocations for these directly, and\n+\t understands that the PIC register has to be added into the offset.\n+\t */\n+      insn = emit_insn (gen_pic_load_addr_based (reg, orig));\n+#else\n+      if (subregs)\n+\taddress = gen_reg_rtx (Pmode);\n+      else\n+\taddress = reg;\n+\n+      emit_insn (gen_pic_load_addr (address, orig));\n+\n+      pic_ref = gen_rtx (MEM, Pmode,\n+\t\t\t gen_rtx (PLUS, Pmode, pic_offset_table_rtx, address));\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      insn = emit_move_insn (reg, pic_ref);\n+#endif\n+      current_function_uses_pic_offset_table = 1;\n+      /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+\t by loop.  */\n+      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+\t\t\t\t  REG_NOTES (insn));\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress || reload_completed)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t\t   base == reg ? 0 : reg);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (GET_CODE (offset) == CONST_INT)\n+\t{\n+\t  /* The base register doesn't really matter, we only want to\n+\t     test the index for the appropriate mode.  */\n+\t  GO_IF_LEGITIMATE_INDEX (mode, 0, offset, win);\n+\n+\t  if (! reload_in_progress && ! reload_completed)\n+\t    offset = force_reg (Pmode, offset);\n+\t  else\n+\t    abort ();\n+\n+\twin:\n+\t  if (GET_CODE (offset) == CONST_INT)\n+\t    return plus_constant_for_output (base, INTVAL (offset));\n+\t}\n+\n+      if (GET_MODE_SIZE (mode) > 4\n+\t  && (GET_MODE_CLASS (mode) == MODE_INT\n+\t      || TARGET_SOFT_FLOAT))\n+\t{\n+\t  emit_insn (gen_addsi3 (reg, base, offset));\n+\t  return reg;\n+\t}\n+\n+      return gen_rtx (PLUS, Pmode, base, offset);\n+    }\n+  else if (GET_CODE (orig) == LABEL_REF)\n+    current_function_uses_pic_offset_table = 1;\n+\n+  return orig;\n+}\n+\n+static rtx pic_rtx;\n+\n+int\n+is_pic(x)\n+     rtx x;\n+{\n+  if (x == pic_rtx)\n+    return 1;\n+  return 0;\n+}\n+\n+void\n+arm_finalize_pic ()\n+{\n+#ifndef AOF_ASSEMBLER\n+  rtx l1, pic_tmp, pic_tmp2, seq;\n+  rtx global_offset_table;\n+\n+  if (current_function_uses_pic_offset_table == 0)\n+    return;\n+\n+  if (! flag_pic)\n+    abort ();\n+\n+  start_sequence ();\n+  l1 = gen_label_rtx ();\n+\n+  global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  pic_tmp = gen_rtx (CONST, VOIDmode, \n+\t\t     gen_rtx (PLUS, Pmode, \n+\t\t\t      gen_rtx (LABEL_REF, VOIDmode, l1),\n+\t\t\t      GEN_INT (8)));\n+  pic_tmp2 = gen_rtx (CONST, VOIDmode,\n+\t\t      gen_rtx (PLUS, Pmode,\n+\t\t\t       global_offset_table,\n+\t\t\t       pc_rtx));\n+\n+  pic_rtx = gen_rtx (CONST, Pmode,\n+\t\t     gen_rtx (MINUS, Pmode, pic_tmp2, pic_tmp));\n+\n+  emit_insn (gen_pic_load_addr (pic_offset_table_rtx, pic_rtx));\n+  emit_jump_insn (gen_pic_add_dot_plus_eight(l1, pic_offset_table_rtx));\n+  emit_label (l1);\n+\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_after (seq, get_insns ());\n+\n+  /* Need to emit this whether or not we obey regdecls,\n+     since setjmp/longjmp can cause life info to screw up.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+#endif /* AOF_ASSEMBLER */\n+}\n+\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n    || (GET_CODE (X) == SUBREG && GET_CODE (SUBREG_REG (X)) == REG))\n@@ -1295,7 +1488,45 @@ arm_rtx_costs (x, code, outer_code)\n       return 99;\n     }\n }\n-     \n+\n+int\n+arm_adjust_cost (insn, link, dep, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep;\n+     int cost;\n+{\n+  rtx i_pat, d_pat;\n+\n+  if ((i_pat = single_set (insn)) != NULL\n+      && GET_CODE (SET_SRC (i_pat)) == MEM\n+      && (d_pat = single_set (dep)) != NULL\n+      && GET_CODE (SET_DEST (d_pat)) == MEM)\n+    {\n+      /* This is a load after a store, there is no conflict if the load reads\n+\t from a cached area.  Assume that loads from the stack, and from the\n+\t constant pool are cached, and that others will miss.  This is a \n+\t hack. */\n+      \n+/*       debug_rtx (insn);\n+      debug_rtx (dep);\n+      debug_rtx (link);\n+      fprintf (stderr, \"costs %d\\n\", cost); */\n+\n+      if (CONSTANT_POOL_ADDRESS_P (XEXP (SET_SRC (i_pat), 0))\n+\t  || reg_mentioned_p (stack_pointer_rtx, XEXP (SET_SRC (i_pat), 0))\n+\t  || reg_mentioned_p (frame_pointer_rtx, XEXP (SET_SRC (i_pat), 0))\n+\t  || reg_mentioned_p (hard_frame_pointer_rtx, \n+\t\t\t      XEXP (SET_SRC (i_pat), 0)))\n+\t{\n+/* \t  fprintf (stderr, \"***** Now 1\\n\"); */\n+\t  return 1;\n+\t}\n+    }\n+\n+  return cost;\n+}\n+\n /* This code has been fixed for cross compilation. */\n \n static int fpa_consts_inited = 0;\n@@ -2409,13 +2640,6 @@ multi_register_push (op, mode)\n \f\n /* Routines for use with attributes */\n \n-int\n-const_pool_offset (symbol)\n-     rtx symbol;\n-{\n-  return get_pool_offset (symbol) - get_pool_size () - get_prologue_size ();\n-}\n-\n /* Return nonzero if ATTR is a valid attribute for DECL.\n    ATTRIBUTES are any existing attributes and ARGS are the arguments\n    supplied with ATTR.\n@@ -2947,37 +3171,6 @@ arm_reload_out_hi (operands)\n \t\t\t    gen_rtx (SUBREG, QImode, operands[2], 0)));\n     }\n }\n-\f\n-/* Check to see if a branch is forwards or backwards.  Return TRUE if it\n-   is backwards.  */\n-\n-int\n-arm_backwards_branch (from, to)\n-     int from, to;\n-{\n-  return insn_addresses[to] <= insn_addresses[from];\n-}\n-\n-/* Check to see if a branch is within the distance that can be done using\n-   an arithmetic expression. */\n-int\n-short_branch (from, to)\n-     int from, to;\n-{\n-  int delta = insn_addresses[from] + 8 - insn_addresses[to];\n-\n-  return abs (delta) < 980;\t/* A small margin for safety */\n-}\n-\n-/* Check to see that the insn isn't the target of the conditionalizing\n-   code */\n-int\n-arm_insn_not_targeted (insn)\n-     rtx insn;\n-{\n-  return insn != arm_target_insn;\n-}\n-\n \f\n /* Routines for manipulation of the constant pool.  */\n /* This is unashamedly hacked from the version in sh.c, since the problem is\n@@ -3071,6 +3264,13 @@ add_constant (x, mode)\n     x = XVECEXP (x, 0, 0);\n #endif\n \n+#ifdef AOF_ASSEMBLER\n+  /* PIC Symbol references need to be converted into offsets into the \n+     based area.  */\n+  if (flag_pic && GET_CODE (x) == SYMBOL_REF)\n+    x = aof_pic_entry (x);\n+#endif /* AOF_ASSEMBLER */\n+\n   /* First see if we've already got it */\n   for (i = 0; i < pool_size; i++)\n     {\n@@ -4106,7 +4306,6 @@ output_ascii_pseudo_op (stream, p, len)\n \t    fputs (\"\\\"\\n\", stream);\n \t  fputs (\"\\t.ascii\\t\\\"\", stream);\n \t  len_so_far = 0;\n-\t  arm_increase_location (chars_so_far);\n \t  chars_so_far = 0;\n \t}\n \n@@ -4131,7 +4330,6 @@ output_ascii_pseudo_op (stream, p, len)\n     }\n \n   fputs (\"\\\"\\n\", stream);\n-  arm_increase_location (chars_so_far);\n }\n \f\n \n@@ -4255,6 +4453,10 @@ function_really_clobbers_lr (first)\n \t  if ((next = next_nonnote_insn (insn)) == NULL)\n \t    return 1;\n \n+\t  /* No need to worry about lr if the call never returns */\n+\t  if (GET_CODE (next) == BARRIER)\n+\t    break;\n+\n \t  if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == USE\n \t      && (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n \t      && (REGNO (SET_DEST (XVECEXP (PATTERN (insn), 0, 0)))\n@@ -4380,15 +4582,6 @@ arm_volatile_func ()\n   return (optimize > 0 && TREE_THIS_VOLATILE (current_function_decl));\n }\n \n-/* Return the size of the prologue.  It's not too bad if we slightly \n-   over-estimate.  */\n-\n-static int\n-get_prologue_size ()\n-{\n-  return profile_flag ? 12 : 0;\n-}\n-\n /* The amount of stack adjustment that happens here, in output_return and in\n    output_epilogue must be exactly the same as was calculated during reload,\n    or things will point to the wrong place.  The only time we can safely\n@@ -4464,6 +4657,12 @@ output_func_prologue (f, frame_size)\n   if (lr_save_eliminated)\n     fprintf (f,\"\\t%s I don't think this function clobbers lr\\n\",\n \t     ASM_COMMENT_START);\n+\n+#ifdef AOF_ASSEMBLER\n+  if (flag_pic)\n+    fprintf (f, \"\\tmov\\t%sip, %s%s\\n\", REGISTER_PREFIX, REGISTER_PREFIX,\n+\t     reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+#endif\n }\n \n \n@@ -4544,41 +4743,46 @@ output_func_epilogue (f, frame_size)\n \t  }\n       if (current_function_pretend_args_size == 0 && regs_ever_live[14])\n \t{\n-\t  print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x8000,\n-\t\t\t   TARGET_APCS_32 ? FALSE : TRUE);\n+\t  if (lr_save_eliminated)\n+\t    fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n+\t\t\t : \"\\tmovs\\t%spc, %slr\\n\"),\n+\t\t     REGISTER_PREFIX, REGISTER_PREFIX, f);\n+\t  else\n+\t    print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x8000,\n+\t\t\t     TARGET_APCS_32 ? FALSE : TRUE);\n \t  code_size += 4;\n \t}\n       else\n \t{\n \t  if (live_regs_mask || regs_ever_live[14])\n \t    {\n-\t      live_regs_mask |= 0x4000;\n-\t      print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n-\t      code_size += 4;\n+\t      /* Restore the integer regs, and the return address into lr */\n+\t      if (! lr_save_eliminated)\n+\t\tlive_regs_mask |= 0x4000;\n+\n+\t      if (live_regs_mask != 0)\n+\t      {\n+\t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n+\t\tcode_size += 4;\n+\t      }\n \t    }\n \t  if (current_function_pretend_args_size)\n \t    {\n+\t      /* Unwind the pre-pushed regs */\n \t      operands[0] = operands[1] = stack_pointer_rtx;\n \t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t     current_function_pretend_args_size);\n \t      output_add_immediate (operands);\n \t    }\n+\t  /* And finally, go home */\n \t  fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n \t\t       : \"\\tmovs\\t%spc, %slr\\n\"),\n \t\t   REGISTER_PREFIX, REGISTER_PREFIX, f);\n \t  code_size += 4;\n \t}\n     }\n \n- epilogue_done:\n-\n-  /* insn_addresses isn't allocated when not optimizing */\n-  /* ??? The previous comment is incorrect.  Clarify.  */\n-\n-  if (optimize > 0)\n-    arm_increase_location (code_size\n-\t\t\t   + insn_addresses[INSN_UID (get_last_insn ())]\n-\t\t\t   + get_prologue_size ());\n+epilogue_done:\n \n   current_function_anonymous_args = 0;\n }\n@@ -4868,57 +5072,14 @@ arm_print_operand (stream, x, code)\n     }\n }\n \n-/* Increase the `arm_text_location' by AMOUNT if we're in the text\n-   segment.  */\n-\n-void\n-arm_increase_location (amount)\n-     int amount;\n-{\n-  if (in_text_section ())\n-    arm_text_location += amount;\n-}\n-\n-\n-/* Output a label definition.  If this label is within the .text segment, it\n-   is stored in OFFSET_TABLE, to be used when building `llc' instructions.\n-   Maybe GCC remembers names not starting with a `*' for a long time, but this\n-   is a minority anyway, so we just make a copy.  Do not store the leading `*'\n-   if the name starts with one.  */\n+/* Output a label definition.  */\n \n void\n arm_asm_output_label (stream, name)\n      FILE *stream;\n      char *name;\n {\n-  char *real_name, *s;\n-  struct label_offset *cur;\n-  int hash = 0;\n-\n   ARM_OUTPUT_LABEL (stream, name);\n-  if (! in_text_section ())\n-    return;\n-\n-  if (name[0] == '*')\n-    {\n-      real_name = xmalloc (1 + strlen (&name[1]));\n-      strcpy (real_name, &name[1]);\n-    }\n-  else\n-    {\n-      real_name = xmalloc (2 + strlen (name));\n-      strcpy (real_name, USER_LABEL_PREFIX);\n-      strcat (real_name, name);\n-    }\n-  for (s = real_name; *s; s++)\n-    hash += *s;\n-\n-  hash = hash % LABEL_HASH_SIZE;\n-  cur = (struct label_offset *) xmalloc (sizeof (struct label_offset));\n-  cur->name = real_name;\n-  cur->offset = arm_text_location;\n-  cur->cdr = offset_table[hash];\n-  offset_table[hash] = cur;\n }\n \n /* Output code resembling an .lcomm directive.  /bin/as doesn't have this\n@@ -5417,6 +5578,63 @@ final_prescan_insn (insn, opvec, noperands)\n #ifdef AOF_ASSEMBLER\n /* Special functions only needed when producing AOF syntax assembler. */\n \n+rtx aof_pic_label = NULL_RTX;\n+struct pic_chain\n+{\n+  struct pic_chain *next;\n+  char *symname;\n+};\n+\n+static struct pic_chain *aof_pic_chain = NULL;\n+\n+rtx\n+aof_pic_entry (x)\n+     rtx x;\n+{\n+  struct pic_chain **chainp;\n+  int offset;\n+\n+  if (aof_pic_label == NULL_RTX)\n+    {\n+      /* This needs to persist throughout the compilation.  */\n+      end_temporary_allocation ();\n+      aof_pic_label = gen_rtx (SYMBOL_REF, Pmode, \"x$adcons\");\n+      resume_temporary_allocation ();\n+    }\n+\n+  for (offset = 0, chainp = &aof_pic_chain; *chainp;\n+       offset += 4, chainp = &(*chainp)->next)\n+    if ((*chainp)->symname == XSTR (x, 0))\n+      return plus_constant (aof_pic_label, offset);\n+\n+  *chainp = (struct pic_chain *) xmalloc (sizeof (struct pic_chain));\n+  (*chainp)->next = NULL;\n+  (*chainp)->symname = XSTR (x, 0);\n+  return plus_constant (aof_pic_label, offset);\n+}\n+\n+void\n+aof_dump_pic_table (f)\n+     FILE *f;\n+{\n+  struct pic_chain *chain;\n+\n+  if (aof_pic_chain == NULL)\n+    return;\n+\n+  fprintf (f, \"\\tAREA |%s$$adcons|, BASED %s%s\\n\",\n+\t   reg_names[PIC_OFFSET_TABLE_REGNUM], REGISTER_PREFIX,\n+\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+  fputs (\"|x$adcons|\\n\", f);\n+  \n+  for (chain = aof_pic_chain; chain; chain = chain->next)\n+    {\n+      fputs (\"\\tDCD\\t\", f);\n+      assemble_name (f, chain->symname);\n+      fputs (\"\\n\", f);\n+    }\n+}\n+\n int arm_text_section_count = 1;\n \n char *"}]}