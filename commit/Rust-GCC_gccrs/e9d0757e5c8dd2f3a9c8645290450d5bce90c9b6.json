{"sha": "e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkMDc1N2U1YzhkZDJmM2E5Yzg2NDUyOTA0NTBkNWJjZTkwYzliNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-10-01T05:04:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-01T05:04:30Z"}, "message": "alpha.md (beq): For registers and ints 0-255...\n\n        * alpha.md (beq): For registers and ints 0-255, use cmpeq+bne, since\n        that pair will dual-issue on the 21164 and plus+beq won't.\n        (bne): Likewise for cmpeq+beq.\n\nFrom-SVN: r15814", "tree": {"sha": "48fd31c3d9b9d973ab37586e178cfa59e5780756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48fd31c3d9b9d973ab37586e178cfa59e5780756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6/comments", "author": null, "committer": null, "parents": [{"sha": "3f34faec1abc7765aabb7c11eb2abc79aefa6a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f34faec1abc7765aabb7c11eb2abc79aefa6a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f34faec1abc7765aabb7c11eb2abc79aefa6a2b"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "0d6a891072242e53b0e2e13e0a7d2fa7a6bd8905", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "patch": "@@ -1,3 +1,9 @@\n+Tue Sep 30 23:06:43 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.md (beq): For registers and ints 0-255, use cmpeq+bne, since\n+\tthat pair will dual-issue on the 21164 and plus+beq won't.\n+\t(bne): Likewise for cmpeq+beq.\n+\n Tue Sep 30 16:07:58 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* except.c (find_exception_handler_labels): Correct argument to free."}, {"sha": "a5f31a37dfe0e8070b931265643dc1a712f9fb16", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=e9d0757e5c8dd2f3a9c8645290450d5bce90c9b6", "patch": "@@ -2478,16 +2478,23 @@\n   \"\n {\n   enum machine_mode mode;\n-  enum rtx_code compare_code, branch_code;\n+  enum rtx_code compare_code = EQ, branch_code = NE;\n \n   if (alpha_compare_fp_p)\n-    mode = DFmode, compare_code = EQ, branch_code = NE;\n+    mode = DFmode;\n   else\n     {\n-      mode = DImode, compare_code = MINUS, branch_code = EQ;\n-      if (GET_CODE (alpha_compare_op1) == CONST_INT)\n+      mode = DImode;\n+      /* We want to use cmpeq/bne when we can, since there is a zero-delay\n+\t bypass between logicals and br/cmov on the 21164.  But we don't\n+\t want to force valid immediate constants into registers needlessly.  */\n+      if (GET_CODE (alpha_compare_op1) == CONST_INT\n+\t  && ((INTVAL (alpha_compare_op1) >= -0x8000\n+\t       && INTVAL (alpha_compare_op1) < 0)\n+\t      || (INTVAL (alpha_compare_op1) > 0xff\n+\t\t  && INTVAL (alpha_compare_op1) < 0x8000)))\n \t{\n-\t  compare_code = PLUS;\n+\t  compare_code = PLUS, branch_code = EQ;\n \t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n \t}\n     }\n@@ -2509,16 +2516,23 @@\n   \"\n {\n   enum machine_mode mode;\n-  enum rtx_code compare_code, branch_code;\n+  enum rtx_code compare_code = EQ, branch_code = EQ;\n \n   if (alpha_compare_fp_p)\n-    mode = DFmode, compare_code = EQ, branch_code = EQ;\n+    mode = DFmode;\n   else\n     {\n-      mode = DImode, compare_code = MINUS, branch_code = NE;\n-      if (GET_CODE (alpha_compare_op1) == CONST_INT)\n+      mode = DImode;\n+      /* We want to use cmpeq/bne when we can, since there is a zero-delay\n+\t bypass between logicals and br/cmov on the 21164.  But we don't\n+\t want to force valid immediate constants into registers needlessly.  */\n+      if (GET_CODE (alpha_compare_op1) == CONST_INT\n+\t  && ((INTVAL (alpha_compare_op1) >= -0x8000\n+\t       && INTVAL (alpha_compare_op1) < 0)\n+\t      || (INTVAL (alpha_compare_op1) > 0xff\n+\t\t  && INTVAL (alpha_compare_op1) < 0x8000)))\n \t{\n-\t  compare_code = PLUS;\n+\t  compare_code = PLUS, branch_code = NE;\n \t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n \t}\n     }"}]}