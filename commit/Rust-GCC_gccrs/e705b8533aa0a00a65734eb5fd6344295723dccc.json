{"sha": "e705b8533aa0a00a65734eb5fd6344295723dccc", "node_id": "C_kwDOANBUbNoAKGU3MDViODUzM2FhMGEwMGE2NTczNGViNWZkNjM0NDI5NTcyM2RjY2M", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-01T08:45:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-01T08:45:48Z"}, "message": "openmp: Differentiate between order(concurrent) and order(reproducible:concurrent)\n\nWhile OpenMP 5.1 implies order(concurrent) is the same thing as\norder(reproducible:concurrent), this is going to change in OpenMP 5.2, where\nessentially order(concurrent) means nothing is stated on whether it is\nreproducible or unconstrained (and is determined by other means, e.g. for/do\nwith schedule static or runtime with static being selected is implicitly\nreproducible, distribute with dist_schedule static is implicitly reproducible,\nloop is implicitly reproducible) and when the modifier is specified explicitly,\nit overrides the implicit behavior either way.\nAnd, when order(reproducible:concurrent) is used with e.g. schedule(dynamic)\nor some other schedule that is by definition not reproducible, it is\nimplementation's duty to ensure it is reproducible, either by remembering how\nit scheduled some loop and then replaying the same schedule when seeing loops\nwith the same directive/schedule/number of iterations, or by overriding the\nschedule to some reproducible one.\n\nThis patch doesn't implement the 5.2 wording just yet, but in the FEs\ndifferentiates between the 3 states - no explicit modifier, explicit reproducible\nor explicit unconstrainted, so that the middle-end can easily switch any time.\nInstead it follows the 5.1 wording where both order(concurrent) (implicit or\nexplicit) or order(reproducible:concurrent) imply reproducibility.\nAnd, it implements the easier method, when for/do should be reproducible, it\njust chooses static schedule.  order(concurrent) implies no OpenMP APIs in the\nloop body nor threadprivate vars, so the exact scheduling isn't (easily at least)\nobservable.\n\n2021-10-01  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree.h (OMP_CLAUSE_ORDER_REPRODUCIBLE): Define.\n\t* tree-pretty-print.c (dump_omp_clause) <case OMP_CLAUSE_ORDER>: Print\n\treproducible: for OMP_CLAUSE_ORDER_REPRODUCIBLE.\n\t* omp-general.c (omp_extract_for_data): If OMP_CLAUSE_ORDER is seen\n\twithout OMP_CLAUSE_ORDER_UNCONSTRAINED, overwrite sched_kind to\n\tOMP_CLAUSE_SCHEDULE_STATIC.\ngcc/c-family/\n\t* c-omp.c (c_omp_split_clauses): Also copy\n\tOMP_CLAUSE_ORDER_REPRODUCIBLE.\ngcc/c/\n\t* c-parser.c (c_parser_omp_clause_order): Set\n\tOMP_CLAUSE_ORDER_REPRODUCIBLE for explicit reproducible: modifier.\ngcc/cp/\n\t* parser.c (cp_parser_omp_clause_order): Set\n\tOMP_CLAUSE_ORDER_REPRODUCIBLE for explicit reproducible: modifier.\ngcc/fortran/\n\t* gfortran.h (gfc_omp_clauses): Add order_reproducible bitfield.\n\t* dump-parse-tree.c (show_omp_clauses): Print REPRODUCIBLE: for it.\n\t* openmp.c (gfc_match_omp_clauses): Set order_reproducible for\n\texplicit reproducible: modifier.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Set\n\tOMP_CLAUSE_ORDER_REPRODUCIBLE for order_reproducible.\n\t(gfc_split_omp_clauses): Also copy order_reproducible.\ngcc/testsuite/\n\t* gfortran.dg/gomp/order-5.f90: Adjust scan-tree-dump-times regexps.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/order-reproducible-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/order-reproducible-2.c: New test.", "tree": {"sha": "14b7dfb5ef10b315e88664aba384b3975016c0e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14b7dfb5ef10b315e88664aba384b3975016c0e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e705b8533aa0a00a65734eb5fd6344295723dccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e705b8533aa0a00a65734eb5fd6344295723dccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e705b8533aa0a00a65734eb5fd6344295723dccc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e705b8533aa0a00a65734eb5fd6344295723dccc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3749c3aff6512003a61b7cf4a96eff0e8926d781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3749c3aff6512003a61b7cf4a96eff0e8926d781", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3749c3aff6512003a61b7cf4a96eff0e8926d781"}], "stats": {"total": 154, "additions": 144, "deletions": 10}, "files": [{"sha": "2849fdabc3d642bf9d4e84fcec136ac7c8ea7ba3", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -2128,6 +2128,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t\t\t    OMP_CLAUSE_ORDER);\n \t      OMP_CLAUSE_ORDER_UNCONSTRAINED (c)\n \t\t= OMP_CLAUSE_ORDER_UNCONSTRAINED (clauses);\n+\t      OMP_CLAUSE_ORDER_REPRODUCIBLE (c)\n+\t\t= OMP_CLAUSE_ORDER_REPRODUCIBLE (clauses);\n \t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];\n \t      cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE] = c;\n \t    }\n@@ -2139,6 +2141,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t\t\t\tOMP_CLAUSE_ORDER);\n \t\t  OMP_CLAUSE_ORDER_UNCONSTRAINED (c)\n \t\t    = OMP_CLAUSE_ORDER_UNCONSTRAINED (clauses);\n+\t\t  OMP_CLAUSE_ORDER_REPRODUCIBLE (c)\n+\t\t    = OMP_CLAUSE_ORDER_REPRODUCIBLE (clauses);\n \t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_FOR];\n \t\t  cclauses[C_OMP_CLAUSE_SPLIT_FOR] = c;\n \t\t  s = C_OMP_CLAUSE_SPLIT_SIMD;"}, {"sha": "a66f43f6dc2f1074a3a004c63486bfb3f29c821a", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -14626,6 +14626,7 @@ c_parser_omp_clause_order (c_parser *parser, tree list)\n   tree c;\n   const char *p;\n   bool unconstrained = false;\n+  bool reproducible = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -14636,7 +14637,9 @@ c_parser_omp_clause_order (c_parser *parser, tree list)\n       p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       if (strcmp (p, \"unconstrained\") == 0)\n \tunconstrained = true;\n-      else if (strcmp (p, \"reproducible\") != 0)\n+      else if (strcmp (p, \"reproducible\") == 0)\n+\treproducible = true;\n+      else\n \t{\n \t  c_parser_error (parser, \"expected %<reproducible%> or \"\n \t\t\t\t  \"%<unconstrained%>\");\n@@ -14661,6 +14664,7 @@ c_parser_omp_clause_order (c_parser *parser, tree list)\n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDER, \"order\");\n   c = build_omp_clause (loc, OMP_CLAUSE_ORDER);\n   OMP_CLAUSE_ORDER_UNCONSTRAINED (c) = unconstrained;\n+  OMP_CLAUSE_ORDER_REPRODUCIBLE (c) = reproducible;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n "}, {"sha": "c6f1a9796c5be9f6de1b3a9aa45eb5d56623d8e3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -37735,6 +37735,7 @@ cp_parser_omp_clause_order (cp_parser *parser, tree list, location_t location)\n   tree c, id;\n   const char *p;\n   bool unconstrained = false;\n+  bool reproducible = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -37747,7 +37748,9 @@ cp_parser_omp_clause_order (cp_parser *parser, tree list, location_t location)\n       p = IDENTIFIER_POINTER (id);\n       if (strcmp (p, \"unconstrained\") == 0)\n \tunconstrained = true;\n-      else if (strcmp (p, \"reproducible\") != 0)\n+      else if (strcmp (p, \"reproducible\") == 0)\n+\treproducible = true;\n+      else\n \t{\n \t  cp_parser_error (parser, \"expected %<reproducible%> or \"\n \t\t\t\t   \"%<unconstrained%>\");\n@@ -37778,6 +37781,7 @@ cp_parser_omp_clause_order (cp_parser *parser, tree list, location_t location)\n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDER, \"order\", location);\n   c = build_omp_clause (location, OMP_CLAUSE_ORDER);\n   OMP_CLAUSE_ORDER_UNCONSTRAINED (c) = unconstrained;\n+  OMP_CLAUSE_ORDER_REPRODUCIBLE (c) = reproducible;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n "}, {"sha": "64e04c043f673792e8b8e0472542cb5d99ee2d22", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -1634,6 +1634,8 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       fputs (\" ORDER(\", dumpfile);\n       if (omp_clauses->order_unconstrained)\n \tfputs (\"UNCONSTRAINED:\", dumpfile);\n+      else if (omp_clauses->order_reproducible)\n+\tfputs (\"REPRODUCIBLE:\", dumpfile);\n       fputs (\"CONCURRENT)\", dumpfile);\n     }\n   if (omp_clauses->ordered)"}, {"sha": "c25d1cca3a844ea06d4a75c2ae4283b07d54da6a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -1491,8 +1491,8 @@ typedef struct gfc_omp_clauses\n   unsigned inbranch:1, notinbranch:1, nogroup:1;\n   unsigned sched_simd:1, sched_monotonic:1, sched_nonmonotonic:1;\n   unsigned simd:1, threads:1, depend_source:1, destroy:1, order_concurrent:1;\n-  unsigned order_unconstrained:1, capture:1, grainsize_strict:1;\n-  unsigned num_tasks_strict:1;\n+  unsigned order_unconstrained:1, order_reproducible:1, capture:1;\n+  unsigned grainsize_strict:1, num_tasks_strict:1;\n   ENUM_BITFIELD (gfc_omp_sched_kind) sched_kind:3;\n   ENUM_BITFIELD (gfc_omp_device_type) device_type:2;\n   ENUM_BITFIELD (gfc_omp_memorder) memorder:3;"}, {"sha": "6a4ca2868f8f20c2345c270428dfbabc34b25569", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -2374,8 +2374,9 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    {\n \t      if (m == MATCH_ERROR)\n \t\tgoto error;\n-\t      if (gfc_match (\" reproducible : concurrent )\") == MATCH_YES\n-\t\t  || gfc_match (\" concurrent )\") == MATCH_YES)\n+\t      if (gfc_match (\" reproducible : concurrent )\") == MATCH_YES)\n+\t\tc->order_reproducible = true;\n+\t      else if (gfc_match (\" concurrent )\") == MATCH_YES)\n \t\t;\n \t      else if (gfc_match (\" unconstrained : concurrent )\") == MATCH_YES)\n \t\tc->order_unconstrained = true;"}, {"sha": "d234d1b070fbd635cef123f39d4b2dfbdaf3d11f", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -3804,6 +3804,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n     {\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_ORDER);\n       OMP_CLAUSE_ORDER_UNCONSTRAINED (c) = clauses->order_unconstrained;\n+      OMP_CLAUSE_ORDER_REPRODUCIBLE (c) = clauses->order_reproducible;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -5895,6 +5896,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->order_concurrent;\n \t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].order_unconstrained\n \t    = code->ext.omp_clauses->order_unconstrained;\n+\t  clausesa[GFC_OMP_SPLIT_DISTRIBUTE].order_reproducible\n+\t    = code->ext.omp_clauses->order_reproducible;\n \t}\n       if (mask & GFC_OMP_MASK_PARALLEL)\n \t{\n@@ -5951,6 +5954,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->order_concurrent;\n \t  clausesa[GFC_OMP_SPLIT_DO].order_unconstrained\n \t    = code->ext.omp_clauses->order_unconstrained;\n+\t  clausesa[GFC_OMP_SPLIT_DO].order_reproducible\n+\t    = code->ext.omp_clauses->order_reproducible;\n \t}\n       if (mask & GFC_OMP_MASK_SIMD)\n \t{\n@@ -5969,6 +5974,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->order_concurrent;\n \t  clausesa[GFC_OMP_SPLIT_SIMD].order_unconstrained\n \t    = code->ext.omp_clauses->order_unconstrained;\n+\t  clausesa[GFC_OMP_SPLIT_SIMD].order_reproducible\n+\t    = code->ext.omp_clauses->order_reproducible;\n \t  /* And this is copied to all.  */\n \t  clausesa[GFC_OMP_SPLIT_SIMD].if_expr\n \t    = code->ext.omp_clauses->if_expr;"}, {"sha": "1e4c0b2553154c7123f6824bf9ec3aee252a5658", "filename": "gcc/omp-general.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -193,6 +193,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t    == GF_OMP_FOR_KIND_DISTRIBUTE;\n   bool taskloop = gimple_omp_for_kind (for_stmt)\n \t\t  == GF_OMP_FOR_KIND_TASKLOOP;\n+  bool order_reproducible = false;\n   tree iterv, countv;\n \n   fd->for_stmt = for_stmt;\n@@ -277,10 +278,25 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t    && !OMP_CLAUSE__SCANTEMP__CONTROL (t))\n \t  fd->have_nonctrl_scantemp = true;\n \tbreak;\n+      case OMP_CLAUSE_ORDER:\n+\t/* FIXME: For OpenMP 5.2 this should change to\n+\t   if (OMP_CLAUSE_ORDER_REPRODUCIBLE (t))\n+\t   (with the exception of loop construct but that lowers to\n+\t   no schedule/dist_schedule clauses currently).  */\n+\tif (!OMP_CLAUSE_ORDER_UNCONSTRAINED (t))\n+\t  order_reproducible = true;\n       default:\n \tbreak;\n       }\n \n+  /* For order(reproducible:concurrent) schedule ({dynamic,guided,runtime})\n+     we have either the option to expensively remember at runtime how we've\n+     distributed work from first loop and reuse that in following loops with\n+     the same number of iterations and schedule, or just force static schedule.\n+     OpenMP API calls etc. aren't allowed in order(concurrent) bodies so\n+     users can't observe it easily anyway.  */\n+  if (order_reproducible)\n+    fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n   if (fd->collapse > 1 || fd->tiling)\n     fd->loops = loops;\n   else"}, {"sha": "0dddb968cb4ef2ced48e1803d503b705fa572c0a", "filename": "gcc/testsuite/gfortran.dg/gomp/order-5.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Forder-5.f90?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -116,14 +116,14 @@ subroutine f4 (a)\n   end do\n end\n \n-! { dg-final { scan-tree-dump-times \"#pragma omp distribute order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp distribute order\\\\(reproducible:concurrent\\\\)\" 6 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp distribute order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n-! { dg-final { scan-tree-dump-times \"#pragma omp for nowait order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for nowait order\\\\(reproducible:concurrent\\\\)\" 6 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp for nowait order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n-! { dg-final { scan-tree-dump-times \"#pragma omp for order\\\\(concurrent\\\\)\" 2 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for order\\\\(reproducible:concurrent\\\\)\" 2 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp for order\\\\(unconstrained:concurrent\\\\)\" 2 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp parallel\" 12 \"original\"} }\n-! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\) order\\\\(concurrent\\\\)\" 6 \"original\"} }\n+! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\) order\\\\(reproducible:concurrent\\\\)\" 6 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\) order\\\\(unconstrained:concurrent\\\\)\" 6 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp taskloop\" 2 \"original\"} }\n ! { dg-final { scan-tree-dump-times \"#pragma omp teams\" 8 \"original\"} }"}, {"sha": "0b5bdd78f064cd28189f5d2148856562af013c09", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -1165,6 +1165,8 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_string (pp, \"order(\");\n       if (OMP_CLAUSE_ORDER_UNCONSTRAINED (clause))\n \tpp_string (pp, \"unconstrained:\");\n+      else if (OMP_CLAUSE_ORDER_REPRODUCIBLE (clause))\n+\tpp_string (pp, \"reproducible:\");\n       pp_string (pp, \"concurrent)\");\n       break;\n "}, {"sha": "7542d97ce12154cf08b023a2b31a0756c5709aa9", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -1718,6 +1718,9 @@ class auto_suppress_location_wrappers\n /* True for unconstrained modifier on order(concurrent) clause.  */\n #define OMP_CLAUSE_ORDER_UNCONSTRAINED(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDER)->base.public_flag)\n+/* True for reproducible modifier on order(concurrent) clause.  */\n+#define OMP_CLAUSE_ORDER_REPRODUCIBLE(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDER))\n \n #define OMP_CLAUSE_REDUCTION_CODE(NODE)\t\\\n   (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\"}, {"sha": "7e6968fe980e5a559b9b810c65d7a87b3cc9ff16", "filename": "libgomp/testsuite/libgomp.c-c++-common/order-reproducible-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-1.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -0,0 +1,63 @@\n+#include <unistd.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  int a[128];\n+  #pragma omp teams num_teams(5)\n+  {\n+    #pragma omp loop bind(teams)\n+    for (int i = 0; i < 128; i++)\n+      {\n+\ta[i] = i;\n+\tif (i == 0)\n+\t  usleep (20);\n+\telse if (i == 17)\n+\t  usleep (40);\n+      }\n+    #pragma omp loop bind(teams)\n+    for (int i = 0; i < 128; i++)\n+      a[i] += i;\n+  }\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != 2 * i)\n+      abort ();\n+  #pragma omp teams num_teams(5)\n+  {\n+    #pragma omp loop bind(teams) order(concurrent)\n+    for (int i = 0; i < 128; i++)\n+      {\n+\ta[i] *= 2;\n+\tif (i == 1)\n+\t  usleep (20);\n+\telse if (i == 13)\n+\t  usleep (40);\n+      }\n+    #pragma omp loop bind(teams) order(concurrent)\n+    for (int i = 0; i < 128; i++)\n+      a[i] += i;\n+  }\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != 5 * i)\n+      abort ();\n+  #pragma omp teams num_teams(5)\n+  {\n+    #pragma omp loop bind(teams) order(reproducible:concurrent)\n+    for (int i = 0; i < 128; i++)\n+      {\n+\ta[i] *= 2;\n+\tif (i == 2)\n+\t  usleep (20);\n+\telse if (i == 105)\n+\t  usleep (40);\n+      }\n+    #pragma omp loop bind(teams) order(reproducible:concurrent)\n+    for (int i = 0; i < 128; i++)\n+      a[i] += i;\n+  }\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != 11 * i)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "c8ba658cf5ee882c90e06de33939112a1d2042eb", "filename": "libgomp/testsuite/libgomp.c-c++-common/order-reproducible-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e705b8533aa0a00a65734eb5fd6344295723dccc/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e705b8533aa0a00a65734eb5fd6344295723dccc/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Forder-reproducible-2.c?ref=e705b8533aa0a00a65734eb5fd6344295723dccc", "patch": "@@ -0,0 +1,28 @@\n+#include <unistd.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  int a[128];\n+  #pragma omp parallel num_threads(8)\n+  {\n+    #pragma omp barrier\n+    #pragma omp for nowait schedule (dynamic, 2) order(reproducible:concurrent)\n+    for (int i = 0; i < 128; i++)\n+      {\n+\ta[i] = i;\n+\tif (i == 0)\n+\t  usleep (20);\n+\telse if (i == 17)\n+\t  usleep (40);\n+      }\n+    #pragma omp for nowait schedule (dynamic, 2) order(reproducible:concurrent)\n+    for (int i = 0; i < 128; i++)\n+      a[i] += i;\n+  }\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != 2 * i)\n+      abort ();\n+  return 0;\n+}"}]}