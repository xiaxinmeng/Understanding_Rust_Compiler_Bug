{"sha": "5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVkNmFjZTU3OGUwNjU3YzA0ODFiYWNkMTZjOTdjZWIzZGVkYTlhNA==", "commit": {"author": {"name": "Marcin Dalecki", "email": "martin@dalecki.de", "date": "2006-01-31T19:56:55Z"}, "committer": {"name": "Marcin Dalecki", "email": "dalecki@gcc.gnu.org", "date": "2006-01-31T19:56:55Z"}, "message": "tree-vrp.c: Use XNEW/XCNEW allocation wrappers.\n\n2006-01-31  Marcin Dalecki  <martin@dalecki.de>\n\n\t* tree-vrp.c: Use XNEW/XCNEW allocation wrappers.\n\t* regrename.c: Ditto.\n\t* tree-ssa-loop-im.c: Ditto.\n\t* tree-dump.c: Ditto.\n\t* tree-complex.c: Ditto.\n\t* genrecog.c: Ditto.\n\t* tree-ssa-threadupdate.c: Ditto.\n\t* tracer.c: Ditto.\n\t* java/class.c: Ditto.\n\t* java/jcf-parse.c: Ditto.\n\t* java/resource.c: Ditto.\n\t* java/except.c: Ditto.\n\t* java/jvspec.c: Ditto.\n\t* java/jcf-write.c: Ditto.\n\t* java/jcf-path.c: Ditto.\n\t* java/gjavah.c: Ditto.\n\t* java/zextract.c: Ditto.\n\t* java/jcf-io.c: Ditto.\n\t* java/jcf.h: Ditto.\n\t* java/buffer.c: Ditto.\n\t* java/lang.c: Ditto.\n\t* java/parse-scan.y: Ditto.\n\t* java/lex.c: Ditto.\n\t* java/lex.h: Ditto.\n\t* cfgloopmanip.c: Ditto.\n\t* postreload-gcse.c: Ditto.\n\t* tree-ssa-loop-manip.c: Ditto.\n\t* postreload.c: Ditto.\n\t* tree-ssa-loop-ch.c: Ditto.\n\t* loop.c: Ditto.\n\t* ipa-cp.c: Ditto.\n\t* cppspec.c: Ditto.\n\t* diagnostic.c: Ditto.\n\t* final.c: Ditto.\n\t* genoutput.c: Ditto.\n\t* gcc.c: Ditto.\n\t* cfghooks.c: Ditto.\n\t* cfgloopanal.c: Ditto.\n\t* objc/objc-act.c: Ditto.\n\t* gcov.c: Ditto.\n\t* genextract.c: Ditto.\n\t* genautomata.c: Ditto.\n\t* pretty-print.c: Ditto.\n\t* genemit.c: Ditto.\n\t* cgraphunit.c: Ditto.\n\t* flow.c: Ditto.\n\t* df-scan.c: Ditto.\n\t* haifa-sched.c: Ditto.\n\t* dominance.c: Ditto.\n\t* dbxout.c: Ditto.\n\t* tree-ssa-loop-ivopts.c: Ditto.\n\t* df-core.c: Ditto.\n\t* mode-switching.c: Ditto.\n\t* modulo-sched.c: Ditto.\n\t* graph.c: Ditto.\n\t* ipa-pure-const.c: Ditto.\n\t* cse.c: Ditto.\n\t* fix-header.c: Ditto.\n\t* web.c: Ditto.\n\t* tree-stdarg.c: Ditto.\n\t* ipa-utils.c: Ditto.\n\t* loop-init.c: Ditto.\n\t* ipa-inline.c: Ditto.\n\t* cfganal.c: Ditto.\n\t* global.c: Ditto.\n\t* alloc-pool.c: Ditto.\n\t* dwarf2out.c: Ditto.\n\t* opts.c: Ditto.\n\t* genattrtab.c: Ditto.\n\t* tree-ssa-loop-ivcanon.c: Ditto.\n\t* predict.c: Ditto.\n\t* timevar.c: Ditto.\n\t* lcm.c: Ditto.\n\t* fortran/gfortranspec.c: Ditto.\n\t* regmove.c: Ditto.\n\t* local-alloc.c: Ditto.\n\t* langhooks.c: Ditto.\n\t* function.c: Ditto.\n\t* tree-vectorizer.c: Ditto.\n\t* gcse.c: Ditto.\n\t* ipa-type-escape.c: Ditto.\n\t* alias.c: Ditto.\n\t* tree-if-conv.c: Ditto.\n\t* profile.c: Ditto.\n\t* ipa.c: Ditto.\n\t* tree-data-ref.c: Ditto.\n\t* loop-unroll.c: Ditto.\n\t* treelang/treetree.c: Ditto.\n\t* calls.c: Ditto.\n\t* bt-load.c: Ditto.\n\t* ggc-common.c: Ditto.\n\t* except.c: Ditto.\n\t* coverage.c: Ditto.\n\t* cselib.c: Ditto.\n\t* tree-cfgcleanup.c: Ditto.\n\t* tree-ssa-pre.c: Ditto.\n\t* cfgcleanup.c: Ditto.\n\t* loop-invariant.c: Ditto.\n\t* loop-iv.c: Ditto.\n\t* ipa-prop.c: Ditto.\n\t* print-tree.c: Ditto.\n\t* conflict.c: Ditto.\n\t* ggc-page.c: Ditto.\n\t* sched-deps.c: Ditto.\n\t* regclass.c: Ditto.\n\t* tree-object-size.c: Ditto.\n\t* combine.c: Ditto.\n\t* bb-reorder.c: Ditto.\n\t* resource.c: Ditto.\n\t* var-tracking.c: Ditto.\n\t* cfgloop.c: Ditto.\n\t* df-problems.c: Ditto.\n\t* reg-stack.c: Ditto.\n\t* tlink.c: Ditto.\n\t* gccspec.c: Ditto.\n\t* sched-rgn.c: Ditto.\n\t* tree-ssa-structalias.c: Ditto.\n\t* tree-ssa-reassoc.c: Ditto.\n\t* config/darwin-c.c: Ditto.\n\t* config/darwin.c: Ditto.\n\t* config/arm/arm.c: Ditto.\n\t* cfgrtl.c: Ditto.\n\t* collect2.c: Ditto.\n\t* reload1.c: Ditto.\n\nFrom-SVN: r110446", "tree": {"sha": "1d4ee70ba0860ea79946b28d772ea552777594d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d4ee70ba0860ea79946b28d772ea552777594d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/comments", "author": {"login": "rosomak", "id": 2399361, "node_id": "MDQ6VXNlcjIzOTkzNjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2399361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rosomak", "html_url": "https://github.com/rosomak", "followers_url": "https://api.github.com/users/rosomak/followers", "following_url": "https://api.github.com/users/rosomak/following{/other_user}", "gists_url": "https://api.github.com/users/rosomak/gists{/gist_id}", "starred_url": "https://api.github.com/users/rosomak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rosomak/subscriptions", "organizations_url": "https://api.github.com/users/rosomak/orgs", "repos_url": "https://api.github.com/users/rosomak/repos", "events_url": "https://api.github.com/users/rosomak/events{/privacy}", "received_events_url": "https://api.github.com/users/rosomak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f13c4d68fa3f5328f93cde8274152f8da5bd341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f13c4d68fa3f5328f93cde8274152f8da5bd341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f13c4d68fa3f5328f93cde8274152f8da5bd341"}], "stats": {"total": 1167, "additions": 633, "deletions": 534}, "files": [{"sha": "92a4df0fc1388949750c140ff1c0654611564b03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1,3 +1,130 @@\n+2006-01-31  Marcin Dalecki  <martin@dalecki.de>\n+\n+\t* tree-vrp.c: Use XNEW/XCNEW allocation wrappers.\n+\t* regrename.c: Ditto.\n+\t* tree-ssa-loop-im.c: Ditto.\n+\t* tree-dump.c: Ditto.\n+\t* tree-complex.c: Ditto.\n+\t* genrecog.c: Ditto.\n+\t* tree-ssa-threadupdate.c: Ditto.\n+\t* tracer.c: Ditto.\n+\t* java/class.c: Ditto.\n+\t* java/jcf-parse.c: Ditto.\n+\t* java/resource.c: Ditto.\n+\t* java/except.c: Ditto.\n+\t* java/jvspec.c: Ditto.\n+\t* java/jcf-write.c: Ditto.\n+\t* java/jcf-path.c: Ditto.\n+\t* java/gjavah.c: Ditto.\n+\t* java/zextract.c: Ditto.\n+\t* java/jcf-io.c: Ditto.\n+\t* java/jcf.h: Ditto.\n+\t* java/buffer.c: Ditto.\n+\t* java/lang.c: Ditto.\n+\t* java/parse-scan.y: Ditto.\n+\t* java/lex.c: Ditto.\n+\t* java/lex.h: Ditto.\n+\t* cfgloopmanip.c: Ditto.\n+\t* postreload-gcse.c: Ditto.\n+\t* tree-ssa-loop-manip.c: Ditto.\n+\t* postreload.c: Ditto.\n+\t* tree-ssa-loop-ch.c: Ditto.\n+\t* loop.c: Ditto.\n+\t* ipa-cp.c: Ditto.\n+\t* cppspec.c: Ditto.\n+\t* diagnostic.c: Ditto.\n+\t* final.c: Ditto.\n+\t* genoutput.c: Ditto.\n+\t* gcc.c: Ditto.\n+\t* cfghooks.c: Ditto.\n+\t* cfgloopanal.c: Ditto.\n+\t* objc/objc-act.c: Ditto.\n+\t* gcov.c: Ditto.\n+\t* genextract.c: Ditto.\n+\t* genautomata.c: Ditto.\n+\t* pretty-print.c: Ditto.\n+\t* genemit.c: Ditto.\n+\t* cgraphunit.c: Ditto.\n+\t* flow.c: Ditto.\n+\t* df-scan.c: Ditto.\n+\t* haifa-sched.c: Ditto.\n+\t* dominance.c: Ditto.\n+\t* dbxout.c: Ditto.\n+\t* tree-ssa-loop-ivopts.c: Ditto.\n+\t* df-core.c: Ditto.\n+\t* mode-switching.c: Ditto.\n+\t* modulo-sched.c: Ditto.\n+\t* graph.c: Ditto.\n+\t* ipa-pure-const.c: Ditto.\n+\t* cse.c: Ditto.\n+\t* fix-header.c: Ditto.\n+\t* web.c: Ditto.\n+\t* tree-stdarg.c: Ditto.\n+\t* ipa-utils.c: Ditto.\n+\t* loop-init.c: Ditto.\n+\t* ipa-inline.c: Ditto.\n+\t* cfganal.c: Ditto.\n+\t* global.c: Ditto.\n+\t* alloc-pool.c: Ditto.\n+\t* dwarf2out.c: Ditto.\n+\t* opts.c: Ditto.\n+\t* genattrtab.c: Ditto.\n+\t* tree-ssa-loop-ivcanon.c: Ditto.\n+\t* predict.c: Ditto.\n+\t* timevar.c: Ditto.\n+\t* lcm.c: Ditto.\n+\t* fortran/gfortranspec.c: Ditto.\n+\t* regmove.c: Ditto.\n+\t* local-alloc.c: Ditto.\n+\t* langhooks.c: Ditto.\n+\t* function.c: Ditto.\n+\t* tree-vectorizer.c: Ditto.\n+\t* gcse.c: Ditto.\n+\t* ipa-type-escape.c: Ditto.\n+\t* alias.c: Ditto.\n+\t* tree-if-conv.c: Ditto.\n+\t* profile.c: Ditto.\n+\t* ipa.c: Ditto.\n+\t* tree-data-ref.c: Ditto.\n+\t* loop-unroll.c: Ditto.\n+\t* treelang/treetree.c: Ditto.\n+\t* calls.c: Ditto.\n+\t* bt-load.c: Ditto.\n+\t* ggc-common.c: Ditto.\n+\t* except.c: Ditto.\n+\t* coverage.c: Ditto.\n+\t* cselib.c: Ditto.\n+\t* tree-cfgcleanup.c: Ditto.\n+\t* tree-ssa-pre.c: Ditto.\n+\t* cfgcleanup.c: Ditto.\n+\t* loop-invariant.c: Ditto.\n+\t* loop-iv.c: Ditto.\n+\t* ipa-prop.c: Ditto.\n+\t* print-tree.c: Ditto.\n+\t* conflict.c: Ditto.\n+\t* ggc-page.c: Ditto.\n+\t* sched-deps.c: Ditto.\n+\t* regclass.c: Ditto.\n+\t* tree-object-size.c: Ditto.\n+\t* combine.c: Ditto.\n+\t* bb-reorder.c: Ditto.\n+\t* resource.c: Ditto.\n+\t* var-tracking.c: Ditto.\n+\t* cfgloop.c: Ditto.\n+\t* df-problems.c: Ditto.\n+\t* reg-stack.c: Ditto.\n+\t* tlink.c: Ditto.\n+\t* gccspec.c: Ditto.\n+\t* sched-rgn.c: Ditto.\n+\t* tree-ssa-structalias.c: Ditto.\n+\t* tree-ssa-reassoc.c: Ditto.\n+\t* config/darwin-c.c: Ditto.\n+\t* config/darwin.c: Ditto.\n+\t* config/arm/arm.c: Ditto.\n+\t* cfgrtl.c: Ditto.\n+\t* collect2.c: Ditto.\n+\t* reload1.c: Ditto.\n+\n 2006-01-31  Nicolas Pitre  <nico@cam.org>\n \n \t* arm.md (smaxsi3): Make aware of smax_m1."}, {"sha": "717c7b1b1230783a96457342d5220c54cab91eb6", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -2498,8 +2498,8 @@ init_alias_analysis (void)\n       VARRAY_RTX_INIT (reg_base_value, maxreg, \"reg_base_value\");\n     }\n \n-  new_reg_base_value = xmalloc (maxreg * sizeof (rtx));\n-  reg_seen = xmalloc (maxreg);\n+  new_reg_base_value = XNEWVEC (rtx, maxreg);\n+  reg_seen = XNEWVEC (char, maxreg);\n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias"}, {"sha": "9310f1eb0095690267857b7deffd4cee5cbd0e31", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -228,7 +228,7 @@ pool_alloc (alloc_pool pool)\n       alloc_pool_list block_header;\n \n       /* Make the block.  */\n-      block = xmalloc (pool->block_size);\n+      block = XNEWVEC (char, pool->block_size);\n       block_header = (alloc_pool_list) block;\n       block += align_eight (sizeof (struct alloc_pool_list_def));\n #ifdef GATHER_STATISTICS"}, {"sha": "73c759705a21c719ee7e291ef5b933923d08f6d5", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -911,7 +911,7 @@ connect_traces (int n_traces, struct trace *traces)\n   else\n     count_threshold = max_entry_count / 1000 * DUPLICATION_THRESHOLD;\n \n-  connected = xcalloc (n_traces, sizeof (bool));\n+  connected = XCNEWVEC (bool, n_traces);\n   last_trace = -1;\n   current_pass = 1;\n   current_partition = BB_PARTITION (traces[0].first);\n@@ -1912,7 +1912,7 @@ reorder_basic_blocks (unsigned int flags)\n \n   /* We need to know some information for each basic block.  */\n   array_size = GET_ARRAY_SIZE (last_basic_block);\n-  bbd = xmalloc (array_size * sizeof (bbro_basic_block_data));\n+  bbd = XNEWVEC (bbro_basic_block_data, array_size);\n   for (i = 0; i < array_size; i++)\n     {\n       bbd[i].start_of_trace = -1;\n@@ -1922,7 +1922,7 @@ reorder_basic_blocks (unsigned int flags)\n       bbd[i].node = NULL;\n     }\n \n-  traces = xmalloc (n_basic_blocks * sizeof (struct trace));\n+  traces = XNEWVEC (struct trace, n_basic_blocks);\n   n_traces = 0;\n   find_traces (&n_traces, traces);\n   connect_traces (n_traces, traces);\n@@ -2172,7 +2172,7 @@ partition_hot_cold_basic_blocks (void)\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n   \n-  crossing_edges = xcalloc (max_edges, sizeof (edge));\n+  crossing_edges = XCNEWVEC (edge, max_edges);\n \n   cfg_layout_initialize (0);\n   "}, {"sha": "4d49f44ea4e45f6f5ced1f2743563fa356e219ca", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -779,12 +779,12 @@ static void\n build_btr_def_use_webs (fibheap_t all_btr_defs)\n {\n   const int max_uid = get_max_uid ();\n-  btr_def  *def_array   = xcalloc (max_uid, sizeof (btr_def));\n-  btr_user *use_array   = xcalloc (max_uid, sizeof (btr_user));\n+  btr_def  *def_array   = XCNEWVEC (btr_def, max_uid);\n+  btr_user *use_array   = XCNEWVEC (btr_user, max_uid);\n   sbitmap *btr_defset   = sbitmap_vector_alloc (\n \t\t\t   (last_btr - first_btr) + 1, max_uid);\n   sbitmap *bb_gen      = sbitmap_vector_alloc (n_basic_blocks, max_uid);\n-  HARD_REG_SET *btrs_written = xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n+  HARD_REG_SET *btrs_written = XCNEWVEC (HARD_REG_SET, n_basic_blocks);\n   sbitmap *bb_kill;\n   sbitmap *bb_out;\n \n@@ -903,7 +903,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n {\n   basic_block *worklist, *tos;\n \n-  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n \n   if (dominated_by_p (CDI_DOMINATORS, new_bb, head_bb))\n     {"}, {"sha": "4016b18246d9ec43a9b8a14a8eef3c3cad55d815", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -842,7 +842,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t      = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \t  }\n \n-\targs[i].aligned_regs = xmalloc (sizeof (rtx) * args[i].n_aligned_regs);\n+\targs[i].aligned_regs = XNEWVEC (rtx, args[i].n_aligned_regs);\n \n \t/* Structures smaller than a word are normally aligned to the\n \t   least significant byte.  On a BYTES_BIG_ENDIAN machine,\n@@ -2369,7 +2369,7 @@ expand_call (tree exp, rtx target, int ignore)\n #endif\n \t\t  if (stack_usage_map_buf)\n \t\t    free (stack_usage_map_buf);\n-\t\t  stack_usage_map_buf = xmalloc (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n \t\t  stack_usage_map = stack_usage_map_buf;\n \n \t\t  if (initial_highest_arg_in_use)\n@@ -2477,7 +2477,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  /* Make a new map for the new argument list.  */\n \t\t  if (stack_usage_map_buf)\n \t\t    free (stack_usage_map_buf);\n-\t\t  stack_usage_map_buf = xmalloc (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n \t\t  stack_usage_map = stack_usage_map_buf;\n \t\t  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);\n \t\t  highest_outgoing_arg_in_use = 0;\n@@ -3539,7 +3539,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n \t\t\t\t\t needed);\n #endif\n-      stack_usage_map_buf = xmalloc (highest_outgoing_arg_in_use);\n+      stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n       stack_usage_map = stack_usage_map_buf;\n \n       if (initial_highest_arg_in_use)"}, {"sha": "1829ee08cd809a0a40e8dfd7e3736b02bb53636e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -167,11 +167,11 @@ mark_dfs_back_edges (void)\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n-  pre = xcalloc (last_basic_block, sizeof (int));\n-  post = xcalloc (last_basic_block, sizeof (int));\n+  pre = XCNEWVEC (int, last_basic_block);\n+  post = XCNEWVEC (int, last_basic_block);\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -282,7 +282,7 @@ find_unreachable_blocks (void)\n   edge_iterator ei;\n   basic_block *tos, *worklist, bb;\n \n-  tos = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks);\n \n   /* Clear all the reachability flags.  */\n \n@@ -356,10 +356,10 @@ create_edge_list (void)\n       num_edges += EDGE_COUNT (bb->succs);\n     }\n \n-  elist = xmalloc (sizeof (struct edge_list));\n+  elist = XNEW (struct edge_list);\n   elist->num_blocks = block_count;\n   elist->num_edges = num_edges;\n-  elist->index_to_edge = xmalloc (sizeof (edge) * num_edges);\n+  elist->index_to_edge = XNEWVEC (edge, num_edges);\n \n   num_edges = 0;\n \n@@ -660,7 +660,7 @@ post_order_compute (int *post_order, bool include_entry_exit)\n     post_order[post_order_num++] = EXIT_BLOCK;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -738,7 +738,7 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n   sp = 0;\n \n   if (include_entry_exit)\n@@ -862,7 +862,7 @@ static void\n flow_dfs_compute_reverse_init (depth_first_search_ds data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n-  data->stack = xmalloc (n_basic_blocks * sizeof (basic_block));\n+  data->stack = XNEWVEC (basic_block, n_basic_blocks);\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -972,7 +972,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n       v_size = size;\n     }\n \n-  st = xcalloc (rslt_max, sizeof (basic_block));\n+  st = XCNEWVEC (basic_block, rslt_max);\n   rslt[tv++] = st[sp++] = bb;\n   MARK_VISITED (bb);\n   while (sp)"}, {"sha": "9b11d2ae3ab716f45351e6e5da7615e08163ccc9", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -484,8 +484,7 @@ try_forward_edges (int mode, basic_block b)\n \t      if (t)\n \t\t{\n \t\t  if (!threaded_edges)\n-\t\t    threaded_edges = xmalloc (sizeof (*threaded_edges)\n-\t\t\t\t\t      * n_basic_blocks);\n+\t\t    threaded_edges = XNEWVEC (edge, n_basic_blocks);\n \t\t  else\n \t\t    {\n \t\t      int i;"}, {"sha": "dbf259e1efd6c1b5ba2db52ba1556753e46976cd", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -77,8 +77,8 @@ verify_flow_info (void)\n   basic_block *last_visited;\n \n   timevar_push (TV_CFG_VERIFY);\n-  last_visited = xcalloc (last_basic_block, sizeof (basic_block));\n-  edge_checksum = xcalloc (last_basic_block, sizeof (size_t));\n+  last_visited = XCNEWVEC (basic_block, last_basic_block);\n+  edge_checksum = XCNEWVEC (size_t, last_basic_block);\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;"}, {"sha": "ff00c49db924e48184e25f653c81404685185d27", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -233,7 +233,7 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \n   if (loop->latch->loop_father != loop)\n     {\n-      stack = xmalloc (n_basic_blocks * sizeof (basic_block));\n+      stack = XNEWVEC (basic_block, n_basic_blocks);\n       sp = 0;\n       num_nodes++;\n       stack[sp++] = loop->latch;\n@@ -337,7 +337,7 @@ establish_preds (struct loop *loop)\n \n   if (loop->pred)\n     free (loop->pred);\n-  loop->pred = xmalloc (sizeof (struct loop *) * loop->depth);\n+  loop->pred = XNEWVEC (struct loop *, loop->depth);\n   memcpy (loop->pred, father->pred, sizeof (struct loop *) * father->depth);\n   loop->pred[father->depth] = father;\n \n@@ -667,10 +667,10 @@ flow_loops_find (struct loops *loops)\n     }\n \n   /* Allocate loop structures.  */\n-  loops->parray = xcalloc (num_loops + 1, sizeof (struct loop *));\n+  loops->parray = XCNEWVEC (struct loop *, num_loops + 1);\n \n   /* Dummy loop containing whole function.  */\n-  loops->parray[0] = xcalloc (1, sizeof (struct loop));\n+  loops->parray[0] = XCNEW (struct loop);\n   loops->parray[0]->next = NULL;\n   loops->parray[0]->inner = NULL;\n   loops->parray[0]->outer = NULL;\n@@ -694,8 +694,8 @@ flow_loops_find (struct loops *loops)\n     {\n       /* Compute depth first search order of the CFG so that outer\n \t natural loops will be found before inner natural loops.  */\n-      dfs_order = xmalloc (n_basic_blocks * sizeof (int));\n-      rc_order = xmalloc (n_basic_blocks * sizeof (int));\n+      dfs_order = XNEWVEC (int, n_basic_blocks);\n+      rc_order = XNEWVEC (int, n_basic_blocks);\n       pre_and_rev_post_order_compute (dfs_order, rc_order, false);\n \n       /* Save CFG derived information to avoid recomputing it.  */\n@@ -716,7 +716,7 @@ flow_loops_find (struct loops *loops)\n \n \t  header = BASIC_BLOCK (rc_order[b]);\n \n-\t  loop = loops->parray[num_loops] = xcalloc (1, sizeof (struct loop));\n+\t  loop = loops->parray[num_loops] = XCNEW (struct loop);\n \n \t  loop->header = header;\n \t  loop->num = num_loops;\n@@ -789,7 +789,7 @@ get_loop_body (const struct loop *loop)\n \n   gcc_assert (loop->num_nodes);\n \n-  tovisit = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  tovisit = XCNEWVEC (basic_block, loop->num_nodes);\n   tovisit[tv++] = loop->header;\n \n   if (loop->latch == EXIT_BLOCK_PTR)\n@@ -852,7 +852,7 @@ get_loop_body_in_dom_order (const struct loop *loop)\n \n   gcc_assert (loop->num_nodes);\n \n-  tovisit = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  tovisit = XCNEWVEC (basic_block, loop->num_nodes);\n \n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n@@ -878,7 +878,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   gcc_assert (loop->num_nodes);\n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n-  blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  blocks = XCNEWVEC (basic_block, loop->num_nodes);\n   visited = BITMAP_ALLOC (NULL);\n \n   bb = loop->header;\n@@ -932,7 +932,7 @@ get_loop_exit_edges (const struct loop *loop, unsigned int *num_edges)\n     FOR_EACH_EDGE (e, ei, body[i]->succs)\n       if (!flow_bb_inside_loop_p (loop, e->dest))\n \tn++;\n-  edges = xmalloc (n * sizeof (edge));\n+  edges = XNEWVEC (edge, n);\n   *num_edges = n;\n   n = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n@@ -1062,7 +1062,7 @@ verify_loop_structure (struct loops *loops)\n   edge e;\n \n   /* Check sizes.  */\n-  sizes = xcalloc (loops->num, sizeof (int));\n+  sizes = XCNEWVEC (unsigned, loops->num);\n   sizes[0] = 2;\n \n   FOR_EACH_BB (bb)"}, {"sha": "856332bef4dee3f7e8059d7d1581ea9619bdc667", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -111,10 +111,10 @@ void dump_graph (FILE *f, struct graph *g)\n static struct graph *\n new_graph (int n_vertices)\n {\n-  struct graph *g = xmalloc (sizeof (struct graph));\n+  struct graph *g = XNEW (struct graph);\n \n   g->n_vertices = n_vertices;\n-  g->vertices = xcalloc (n_vertices, sizeof (struct vertex));\n+  g->vertices = XCNEWVEC (struct vertex, n_vertices);\n \n   return g;\n }\n@@ -271,8 +271,8 @@ mark_irreducible_loops (struct loops *loops)\n   edge_iterator ei;\n   int i, src, dest;\n   struct graph *g;\n-  int *queue1 = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  int *queue2 = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  int *queue1 = XNEWVEC (int, last_basic_block + loops->num);\n+  int *queue2 = XNEWVEC (int, last_basic_block + loops->num);\n   int nq, depth;\n   struct loop *cloop;\n "}, {"sha": "ac2a75b0b29c46c5d0e42ac13f01995a12bcb8a7", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -85,7 +85,7 @@ find_path (edge e, basic_block **bbs)\n   gcc_assert (EDGE_COUNT (e->dest->preds) <= 1);\n \n   /* Find bbs in the path.  */\n-  *bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  *bbs = XCNEWVEC (basic_block, n_basic_blocks);\n   return dfs_enumerate_from (e->dest, 0, rpe_enum_p, *bbs,\n \t\t\t     n_basic_blocks, e->dest);\n }\n@@ -159,7 +159,7 @@ fix_bb_placements (struct loops *loops, basic_block from)\n   /* Prevent us from going out of the base_loop.  */\n   SET_BIT (in_queue, base_loop->header->index);\n \n-  queue = xmalloc ((base_loop->num_nodes + 1) * sizeof (basic_block));\n+  queue = XNEWVEC (basic_block, base_loop->num_nodes + 1);\n   qtop = queue + base_loop->num_nodes + 1;\n   qbeg = queue;\n   qend = queue + 1;\n@@ -244,7 +244,7 @@ fix_irreducible_loops (basic_block from)\n   on_stack = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (on_stack);\n   SET_BIT (on_stack, from->index);\n-  stack = xmalloc (from->loop_father->num_nodes * sizeof (basic_block));\n+  stack = XNEWVEC (basic_block, from->loop_father->num_nodes);\n   stack[0] = from;\n   stack_top = 1;\n \n@@ -266,7 +266,7 @@ fix_irreducible_loops (basic_block from)\n       else\n \t{\n \t  num_edges = EDGE_COUNT (bb->succs);\n-\t  edges = xmalloc (num_edges * sizeof (edge));\n+\t  edges = XNEWVEC (edge, num_edges);\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    edges[ei.index] = e;\n \t}\n@@ -331,7 +331,7 @@ remove_path (struct loops *loops, edge e)\n   nrem = find_path (e, &rem_bbs);\n \n   n_bord_bbs = 0;\n-  bord_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  bord_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n   seen = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (seen);\n \n@@ -354,7 +354,7 @@ remove_path (struct loops *loops, edge e)\n   from = e->src;\n   deleted = loop_delete_branch_edge (e, 1);\n   gcc_assert (deleted);\n-  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n \n   /* Cancel loops contained in the path.  */\n   for (i = 0; i < nrem; i++)\n@@ -423,7 +423,7 @@ add_loop (struct loops *loops, struct loop *loop)\n   loop->level = 1;\n \n   /* Find its nodes.  */\n-  bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  bbs = XCNEWVEC (basic_block, n_basic_blocks);\n   n = dfs_enumerate_from (loop->latch, 1, alp_enum_p,\n \t\t\t  bbs, n_basic_blocks, loop->header);\n \n@@ -464,7 +464,7 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   basic_block *dom_bbs, *body;\n   unsigned n_dom_bbs, i;\n   sbitmap seen;\n-  struct loop *loop = xcalloc (1, sizeof (struct loop));\n+  struct loop *loop = XCNEW (struct loop);\n   struct loop *outer = succ_bb->loop_father->outer;\n   int freq, prob, tot_prob;\n   gcov_type cnt;\n@@ -515,7 +515,7 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   scale_loop_frequencies (succ_bb->loop_father, tot_prob - prob, tot_prob);\n \n   /* Update dominators of blocks outside of LOOP.  */\n-  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n   n_dom_bbs = 0;\n   seen = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (seen);\n@@ -681,7 +681,7 @@ struct loop *\n duplicate_loop (struct loops *loops, struct loop *loop, struct loop *target)\n {\n   struct loop *cloop;\n-  cloop = xcalloc (1, sizeof (struct loop));\n+  cloop = XCNEW (struct loop);\n   place_new_loop (loops, cloop);\n \n   /* Initialize copied loop.  */\n@@ -867,7 +867,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       free (bbs);\n       return false;\n     }\n-  new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n+  new_bbs = XNEWVEC (basic_block, loop->num_nodes);\n \n   /* In case we are doing loop peeling and the loop is in the middle of\n      irreducible region, the peeled copies will be inside it too.  */\n@@ -894,7 +894,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       prob_pass_wont_exit =\n \t      RDIV (REG_BR_PROB_BASE * (freq_le + freq_out_orig), freq_in);\n \n-      scale_step = xmalloc (ndupl * sizeof (int));\n+      scale_step = XNEWVEC (int, ndupl);\n \n \tfor (i = 1; i <= ndupl; i++)\n \t  scale_step[i - 1] = TEST_BIT (wont_exit, i)\n@@ -957,13 +957,13 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   n_orig_loops = 0;\n   for (aloop = loop->inner; aloop; aloop = aloop->next)\n     n_orig_loops++;\n-  orig_loops = xcalloc (n_orig_loops, sizeof (struct loop *));\n+  orig_loops = XCNEWVEC (struct loop *, n_orig_loops);\n   for (aloop = loop->inner, i = 0; aloop; aloop = aloop->next, i++)\n     orig_loops[i] = aloop;\n \n   loop->copy = target;\n \n-  first_active = xmalloc (n * sizeof (basic_block));\n+  first_active = XNEWVEC (basic_block, n);\n   if (is_latch)\n     {\n       memcpy (first_active, bbs, n * sizeof (basic_block));\n@@ -1296,16 +1296,16 @@ create_loop_notes (void)\n   free_dominance_info (CDI_DOMINATORS);\n   if (loops.num > 1)\n     {\n-      last = xcalloc (loops.num, sizeof (basic_block));\n+      last = XCNEWVEC (basic_block, loops.num);\n \n       FOR_EACH_BB (bb)\n \t{\n \t  for (loop = bb->loop_father; loop->outer; loop = loop->outer)\n \t    last[loop->num] = bb;\n \t}\n \n-      first = xcalloc (loops.num, sizeof (basic_block));\n-      stack = xcalloc (loops.num, sizeof (struct loop *));\n+      first = XCNEWVEC (basic_block, loops.num);\n+      stack = XCNEWVEC (struct loop *, loops.num);\n       top = stack;\n \n       FOR_EACH_BB (bb)"}, {"sha": "d6a576d349528bb399524b7f109802e87c1ccec1", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1806,9 +1806,9 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n     {\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      basic_block *start = xcalloc (max_uid, sizeof (basic_block));\n-      basic_block *end = xcalloc (max_uid, sizeof (basic_block));\n-      enum bb_state *in_bb_p = xcalloc (max_uid, sizeof (enum bb_state));\n+      basic_block *start = XCNEWVEC (basic_block, max_uid);\n+      basic_block *end = XCNEWVEC (basic_block, max_uid);\n+      enum bb_state *in_bb_p = XCNEWVEC (enum bb_state, max_uid);\n \n       basic_block bb;\n \n@@ -1916,7 +1916,7 @@ rtl_verify_flow_info_1 (void)\n   int err = 0;\n   basic_block bb;\n \n-  bb_info = xcalloc (max_uid, sizeof (basic_block));\n+  bb_info = XCNEWVEC (basic_block, max_uid);\n \n   FOR_EACH_BB_REVERSE (bb)\n     {"}, {"sha": "f0081b68da4e7f3a5cd25e9b4e170f8da0d8ba4b", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1143,8 +1143,7 @@ static void\n cgraph_expand_all_functions (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_node **order =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int order_pos = 0, new_order_pos = 0;\n   int i;\n "}, {"sha": "d03d5a28d00896d55377d68b0925bd38036d97c3", "filename": "gcc/collect2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -579,7 +579,7 @@ find_a_file (struct path_prefix *pprefix, const char *name)\n   len += strlen (HOST_EXECUTABLE_SUFFIX);\n #endif\n \n-  temp = xmalloc (len);\n+  temp = XNEWVEC (char, len);\n \n   /* Determine the filename to execute (special case for absolute paths).  */\n \n@@ -667,7 +667,7 @@ add_prefix (struct path_prefix *pprefix, const char *prefix)\n   if (len > pprefix->max_len)\n     pprefix->max_len = len;\n \n-  pl = xmalloc (sizeof (struct prefix_list));\n+  pl = XNEW (struct prefix_list);\n   pl->prefix = xstrdup (prefix);\n \n   if (*prev)\n@@ -694,7 +694,7 @@ static void\n prefix_from_string (const char *p, struct path_prefix *pprefix)\n {\n   const char *startp, *endp;\n-  char *nstore = xmalloc (strlen (p) + 3);\n+  char *nstore = XNEWVEC (char, strlen (p) + 3);\n \n   if (debug)\n     fprintf (stderr, \"Convert string '%s' into prefixes, separator = '%c'\\n\", p, PATH_SEPARATOR);\n@@ -1367,7 +1367,7 @@ main (int argc, char **argv)\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n-\t  char **real_strip_argv = xcalloc (sizeof (char *), 3);\n+\t  char **real_strip_argv = XCNEWVEC (char *, 3);\n \t  const char ** strip_argv = (const char **) real_strip_argv;\n \n \t  strip_argv[0] = strip_file_name;\n@@ -1801,7 +1801,7 @@ write_c_file_stat (FILE *stream, const char *name ATTRIBUTE_UNUSED)\n \t}\n     }\n   /* q points to null at end of the string (or . of the .so version) */\n-  prefix = xmalloc (q - p + 1);\n+  prefix = XNEWVEC (char, q - p + 1);\n   strncpy (prefix, p, q - p);\n   prefix[q - p] = 0;\n   for (r = prefix; *r; r++)"}, {"sha": "d4ea6897c81df3660a7c4d561cf67dd175fffa3b", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -503,7 +503,7 @@ do_SUBST (rtx *into, rtx newval)\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n-    buf = xmalloc (sizeof (struct undo));\n+    buf = XNEW (struct undo);\n \n   buf->kind = UNDO_RTX;\n   buf->where.r = into;\n@@ -531,7 +531,7 @@ do_SUBST_INT (int *into, int newval)\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n-    buf = xmalloc (sizeof (struct undo));\n+    buf = XNEW (struct undo);\n \n   buf->kind = UNDO_INT;\n   buf->where.i = into;\n@@ -560,7 +560,7 @@ do_SUBST_MODE (rtx *into, enum machine_mode newval)\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n-    buf = xmalloc (sizeof (struct undo));\n+    buf = XNEW (struct undo);\n \n   buf->kind = UNDO_MODE;\n   buf->where.r = into;\n@@ -708,7 +708,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   rtl_hooks = combine_rtl_hooks;\n \n-  reg_stat = xcalloc (nregs, sizeof (struct reg_stat));\n+  reg_stat = XCNEWVEC (struct reg_stat, nregs);\n \n   init_recog_no_volatile ();\n \n@@ -718,7 +718,7 @@ combine_instructions (rtx f, unsigned int nregs)\n     if (INSN_UID (insn) > i)\n       i = INSN_UID (insn);\n \n-  uid_cuid = xmalloc ((i + 1) * sizeof (int));\n+  uid_cuid = XNEWVEC (int, i + 1);\n   max_uid_cuid = i;\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n@@ -747,7 +747,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   sbitmap_zero (refresh_blocks);\n \n   /* Allocate array of current insn_rtx_costs.  */\n-  uid_insn_cost = xcalloc (max_uid_cuid + 1, sizeof (int));\n+  uid_insn_cost = XCNEWVEC (int, max_uid_cuid + 1);\n   last_insn_cost = max_uid_cuid;\n \n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))"}, {"sha": "c7cb82c8e2d37cdb3b7e9b51b1c4eceef6b2924d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -7473,7 +7473,7 @@ add_minipool_forward_ref (Mfix *fix)\n      any existing entry.  Otherwise, we insert the new fix before\n      MAX_MP and, if necessary, adjust the constraints on the other\n      entries.  */\n-  mp = xmalloc (sizeof (* mp));\n+  mp = XNEW (Mnode);\n   mp->fix_size = fix->fix_size;\n   mp->mode = fix->mode;\n   mp->value = fix->value;\n@@ -7671,7 +7671,7 @@ add_minipool_backward_ref (Mfix *fix)\n     }\n \n   /* We need to create a new entry.  */\n-  mp = xmalloc (sizeof (* mp));\n+  mp = XNEW (Mnode);\n   mp->fix_size = fix->fix_size;\n   mp->mode = fix->mode;\n   mp->value = fix->value;"}, {"sha": "30de35d47a66fef8943665a31c9757c7ba0b7a0a", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -62,7 +62,7 @@ static struct align_stack * field_align_stack = NULL;\n static void\n push_field_alignment (int bit_alignment)\n {\n-  align_stack *entry = (align_stack *) xmalloc (sizeof (align_stack));\n+  align_stack *entry = XNEW (align_stack);\n \n   entry->alignment = maximum_field_alignment;\n   entry->prev = field_align_stack;\n@@ -194,7 +194,7 @@ add_framework (const char *name, size_t len, cpp_dir *dir)\n       frameworks_in_use = xrealloc (frameworks_in_use,\n \t\t\t\t    max_frameworks*sizeof(*frameworks_in_use));\n     }\n-  dir_name = xmalloc (len + 1);\n+  dir_name = XNEWVEC (char, len + 1);\n   memcpy (dir_name, name, len);\n   dir_name[len] = '\\0';\n   frameworks_in_use[num_frameworks].name = dir_name;\n@@ -261,7 +261,7 @@ framework_construct_pathname (const char *fname, cpp_dir *dir)\n   if (fast_dir && dir != fast_dir)\n     return 0;\n \n-  frname = xmalloc (strlen (fname) + dir->len + 2\n+  frname = XNEWVEC (char, strlen (fname) + dir->len + 2\n \t\t    + strlen(\".framework/\") + strlen(\"PrivateHeaders\"));\n   strncpy (&frname[0], dir->name, dir->len);\n   frname_len = dir->len;\n@@ -349,7 +349,7 @@ find_subframework_file (const char *fname, const char *pname)\n      into\n      sfrname = /System/Library/Frameworks/Foundation.framework/Frameworks/CarbonCore.framework/Headers/OSUtils.h */\n \n-  sfrname = (char *) xmalloc (strlen (pname) + strlen (fname) + 2 +\n+  sfrname = XNEWVEC (char, strlen (pname) + strlen (fname) + 2 +\n \t\t\t      strlen (\"Frameworks/\") + strlen (\".framework/\")\n \t\t\t      + strlen (\"PrivateHeaders\"));\n  \n@@ -405,7 +405,7 @@ add_system_framework_path (char *path)\n   int cxx_aware = 1;\n   cpp_dir *p;\n \n-  p = xmalloc (sizeof (cpp_dir));\n+  p = XNEW (cpp_dir);\n   p->next = NULL;\n   p->name = path;\n   p->sysp = 1 + !cxx_aware;\n@@ -423,7 +423,7 @@ add_framework_path (char *path)\n {\n   cpp_dir *p;\n \n-  p = xmalloc (sizeof (cpp_dir));\n+  p = XNEW (cpp_dir);\n   p->next = NULL;\n   p->name = path;\n   p->sysp = 0;"}, {"sha": "25fecd8ad2612ec1441b82de0a6f1120640b04ac", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1342,7 +1342,7 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)\n   if (! for_eh)\n     suffix = \".eh1\";\n \n-  lab = xmalloc (strlen (prefix)\n+  lab = XNEWVEC (char, strlen (prefix)\n \t\t + base_len + strlen (suffix) + quotes_len + 1);\n   lab[0] = '\\0';\n "}, {"sha": "43f7860820e5f5aac461115dce1fdb0c879e58c3", "filename": "gcc/conflict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -147,7 +147,7 @@ arc_eq (const void *arcp1, const void *arcp2)\n conflict_graph\n conflict_graph_new (int num_regs)\n {\n-  conflict_graph graph = xmalloc (sizeof (struct conflict_graph_def));\n+  conflict_graph graph = XNEW (struct conflict_graph_def);\n   graph->num_regs = num_regs;\n \n   /* Set up the hash table.  No delete action is specified; memory\n@@ -159,7 +159,7 @@ conflict_graph_new (int num_regs)\n   obstack_init (&graph->arc_obstack);\n \t     \n   /* Create and zero the lookup table by register number.  */\n-  graph->neighbor_heads = xcalloc (num_regs, sizeof (conflict_graph_arc));\n+  graph->neighbor_heads = XCNEWVEC (conflict_graph_arc, num_regs);\n \n   return graph;\n }"}, {"sha": "0ba0c110cbb3abc3ee0c83f1e2f722ee3d7679db", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -262,12 +262,12 @@ read_counts_file (void)\n \t  entry = *slot;\n \t  if (!entry)\n \t    {\n-\t      *slot = entry = xcalloc (1, sizeof (counts_entry_t));\n+\t      *slot = entry = XCNEW (counts_entry_t);\n \t      entry->ident = elt.ident;\n \t      entry->ctr = elt.ctr;\n \t      entry->checksum = checksum;\n \t      entry->summary.num = n_counts;\n-\t      entry->counts = xcalloc (n_counts, sizeof (gcov_type));\n+\t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n \t  else if (entry->checksum != checksum)\n \t    {\n@@ -569,7 +569,7 @@ coverage_end_function (void)\n     {\n       struct function_list *item;\n \n-      item = xmalloc (sizeof (struct function_list));\n+      item = XNEW (struct function_list);\n \n       *functions_tail = item;\n       functions_tail = &item->next;\n@@ -951,12 +951,12 @@ coverage_init (const char *filename)\n   int len = strlen (filename);\n \n   /* Name of da file.  */\n-  da_file_name = xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n+  da_file_name = XNEWVEC (char, len + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, filename);\n   strcat (da_file_name, GCOV_DATA_SUFFIX);\n \n   /* Name of bbg file.  */\n-  bbg_file_name = xmalloc (len + strlen (GCOV_NOTE_SUFFIX) + 1);\n+  bbg_file_name = XNEWVEC (char, len + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, filename);\n   strcat (bbg_file_name, GCOV_NOTE_SUFFIX);\n "}, {"sha": "98b7ffb600fb4a37248e41ef8efdd5d990b8edc4", "filename": "gcc/cppspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -172,7 +172,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n     return;\n \n   /* One more slot for a terminating null.  */\n-  new_argv = xmalloc ((new_argc + 1) * sizeof(char *));\n+  new_argv = XNEWVEC (const char *, new_argc + 1);\n \n   new_argv[0] = argv[0];\n   j = 1;"}, {"sha": "3d2f6b43d5e7a71d39ff067b6823fa8d8fa3f897", "filename": "gcc/cse.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -867,8 +867,7 @@ init_cse_reg_info (unsigned int nregs)\n       /* Reallocate the table with NEW_SIZE entries.  */\n       if (cse_reg_info_table)\n \tfree (cse_reg_info_table);\n-      cse_reg_info_table = xmalloc (sizeof (struct cse_reg_info)\n-\t\t\t\t     * new_size);\n+      cse_reg_info_table = XNEWVEC (struct cse_reg_info, new_size);\n       cse_reg_info_table_size = new_size;\n       cse_reg_info_table_first_uninitialized = 0;\n     }\n@@ -1511,7 +1510,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n   if (elt)\n     free_element_chain = elt->next_same_hash;\n   else\n-    elt = xmalloc (sizeof (struct table_elt));\n+    elt = XNEW (struct table_elt);\n \n   elt->exp = x;\n   elt->canon_exp = NULL_RTX;\n@@ -6761,8 +6760,7 @@ cse_main (rtx f, int nregs, FILE *file)\n \n   init_cse_reg_info (nregs);\n \n-  val.path = xmalloc (sizeof (struct branch_path)\n-\t\t      * PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n+  val.path = XNEWVEC (struct branch_path, PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n \n   cse_jumps_altered = 0;\n   recorded_label_ref = 0;\n@@ -6774,12 +6772,12 @@ cse_main (rtx f, int nregs, FILE *file)\n   init_recog ();\n   init_alias_analysis ();\n \n-  reg_eqv_table = xmalloc (nregs * sizeof (struct reg_eqv_elem));\n+  reg_eqv_table = XNEWVEC (struct reg_eqv_elem, nregs);\n \n   /* Find the largest uid.  */\n \n   max_uid = get_max_uid ();\n-  uid_cuid = xcalloc (max_uid + 1, sizeof (int));\n+  uid_cuid = XCNEWVEC (int, max_uid + 1);\n \n   /* Compute the mapping from uids to cuids.\n      CUIDs are numbers assigned to insns, like uids,\n@@ -6884,7 +6882,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n   int no_conflict = 0;\n \n   /* Allocate the space needed by qty_table.  */\n-  qty_table = xmalloc (max_qty * sizeof (struct qty_table_elem));\n+  qty_table = XNEWVEC (struct qty_table_elem, max_qty);\n \n   new_basic_block ();\n \n@@ -7047,8 +7045,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t     following branches in this case.  */\n \t  to_usage = 0;\n \t  val.path_size = 0;\n-\t  val.path = xmalloc (sizeof (struct branch_path)\n-\t\t\t      * PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n+\t  val.path = XNEWVEC (struct branch_path, PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n \t  cse_end_of_basic_block (insn, &val, 0, 0);\n \t  free (val.path);\n \n@@ -7351,7 +7348,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \n   timevar_push (TV_DELETE_TRIVIALLY_DEAD);\n   /* First count the number of times each register is used.  */\n-  counts = xcalloc (nreg, sizeof (int));\n+  counts = XCNEWVEC (int, nreg);\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       count_reg_usage (insn, counts, NULL_RTX, 1);"}, {"sha": "f95a8748ca9556cd824eb335e4f005a998aba65a", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1472,9 +1472,9 @@ cselib_init (bool record_memory)\n       /* Some space for newly emit instructions so we don't end up\n \t reallocating in between passes.  */\n       reg_values_size = cselib_nregs + (63 + cselib_nregs) / 16;\n-      reg_values = xcalloc (reg_values_size, sizeof (reg_values));\n+      reg_values = XCNEWVEC (struct elt_list *, reg_values_size);\n     }\n-  used_regs = xmalloc (sizeof (*used_regs) * cselib_nregs);\n+  used_regs = XNEWVEC (unsigned int, cselib_nregs);\n   n_used_regs = 0;\n   cselib_hash_table = htab_create (31, get_value_hash,\n \t\t\t\t   entry_and_rtx_equal_p, NULL);"}, {"sha": "c2ac7ded0fbc57bbf4d11160dd52863d904a6e7b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1049,7 +1049,7 @@ dbxout_init (const char *input_file_name)\n   next_type_number = 1;\n \n #ifdef DBX_USE_BINCL\n-  current_file = xmalloc (sizeof *current_file);\n+  current_file = XNEW (struct dbx_file);\n   current_file->next = NULL;\n   current_file->file_number = 0;\n   current_file->next_type_number = 1;\n@@ -1158,7 +1158,7 @@ dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n \t\t\t  const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_USE_BINCL\n-  struct dbx_file *n = xmalloc (sizeof *n);\n+  struct dbx_file *n = XNEW (struct dbx_file);\n \n   n->next = current_file;\n   n->next_type_number = 1;"}, {"sha": "5740dd4403cd63a8c29cd974a47aab183e220be4", "filename": "gcc/df-core.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -310,7 +310,7 @@ static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n struct df *\n df_init (int flags)\n {\n-  struct df *df = xcalloc (1, sizeof (struct df));\n+  struct df *df = XCNEW (struct df);\n   df->flags = flags;\n \n   /* This is executed once per compilation to initialize platform\n@@ -342,7 +342,7 @@ df_add_problem (struct df *df, struct df_problem *problem)\n     return dflow;\n \n   /* Make a new one and add it to the end.  */\n-  dflow = xcalloc (1, sizeof (struct dataflow));\n+  dflow = XCNEW (struct dataflow);\n   dflow->df = df;\n   dflow->problem = problem;\n   df->problems_in_order[df->num_problems_defined++] = dflow;\n@@ -731,7 +731,7 @@ df_analyze_problem (struct dataflow *dflow,\n void\n df_analyze (struct df *df)\n {\n-  int *postorder = xmalloc (sizeof (int) *last_basic_block);\n+  int *postorder = XNEWVEC (int, last_basic_block);\n   bitmap current_all_blocks = BITMAP_ALLOC (NULL);\n   int n_blocks;\n   int i;"}, {"sha": "257baad5b86c043db8be1f939b29d9abb0a26a0c", "filename": "gcc/df-problems.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -385,11 +385,10 @@ df_ru_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n     }\n   else \n     {\n-      struct df_ru_problem_data *problem_data =\n-\txmalloc (sizeof (struct df_ru_problem_data));\n+      struct df_ru_problem_data *problem_data = XNEW (struct df_ru_problem_data);\n       dflow->problem_data = problem_data;\n \n-      problem_data->use_sites = xcalloc (reg_size, sizeof (bitmap));\n+      problem_data->use_sites = XCNEWVEC (bitmap, reg_size);\n       problem_data->use_sites_size = reg_size;\n       problem_data->sparse_invalidated_by_call = BITMAP_ALLOC (NULL);\n       problem_data->dense_invalidated_by_call = BITMAP_ALLOC (NULL);\n@@ -909,11 +908,10 @@ df_rd_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n     }\n   else \n     {\n-      struct df_rd_problem_data *problem_data =\n-\txmalloc (sizeof (struct df_rd_problem_data));\n+      struct df_rd_problem_data *problem_data = XNEW (struct df_rd_problem_data);\n       dflow->problem_data = problem_data;\n \n-      problem_data->def_sites = xcalloc (reg_size, sizeof (bitmap));\n+      problem_data->def_sites = XCNEWVEC (bitmap, reg_size);\n       problem_data->def_sites_size = reg_size;\n       problem_data->sparse_invalidated_by_call = BITMAP_ALLOC (NULL);\n       problem_data->dense_invalidated_by_call = BITMAP_ALLOC (NULL);\n@@ -2130,7 +2128,7 @@ df_urec_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \n   if (!dflow->problem_data)\n     {\n-      problem_data = xmalloc (sizeof (struct df_urec_problem_data));\n+      problem_data = XNEW (struct df_urec_problem_data);\n       dflow->problem_data = problem_data;\n     }\n   problem_data->earlyclobbers_found = false;\n@@ -3066,7 +3064,7 @@ struct dataflow *\n df_chain_add_problem (struct df *df, int flags)\n {\n   struct df_chain_problem_data *problem_data =\n-\txmalloc (sizeof (struct df_chain_problem_data));\n+\tXNEW (struct df_chain_problem_data);\n   struct dataflow *dflow = df_add_problem (df, &problem_CHAIN);\n \n   dflow->problem_data = problem_data;\n@@ -3101,8 +3099,7 @@ df_ri_alloc (struct dataflow *dflow, bitmap blocks_to_rescan ATTRIBUTE_UNUSED)\n \n   if (!dflow->problem_data)\n     {\n-      struct df_ri_problem_data *problem_data =\n-\txmalloc (sizeof (struct df_ri_problem_data));\n+      struct df_ri_problem_data *problem_data =\tXNEW (struct df_ri_problem_data);\n       dflow->problem_data = problem_data;\n     }\n "}, {"sha": "fd9e78a7765f51328c23f63e512e9a129c0895ec", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -219,7 +219,7 @@ df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \t\t\t sizeof (struct df_scan_bb_info), \n \t\t\t block_size);\n \n-  problem_data = xmalloc (sizeof (struct df_scan_problem_data));\n+  problem_data = XNEW (struct df_scan_problem_data);\n   dflow->problem_data = problem_data;\n \n   problem_data->ref_pool "}, {"sha": "fb81bbd89c1a44b54c2531fc9df5342bc2535132", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -93,7 +93,7 @@ diagnostic_initialize (diagnostic_context *context)\n {\n   /* Allocate a basic pretty-printer.  Clients will replace this a\n      much more elaborated pretty-printer if they wish.  */\n-  context->printer = xmalloc (sizeof (pretty_printer));\n+  context->printer = XNEW (pretty_printer);\n   pp_construct (context->printer, NULL, 0);\n   /* By default, diagnostics are sent to stderr.  */\n   context->printer->buffer->stream = stderr;"}, {"sha": "c5c0810c6c9636bbbe6cbf1b27a1be7a0d574794", "filename": "gcc/dominance.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -132,10 +132,10 @@ static unsigned n_bbs_in_dom_tree[2];\n     {\t\t\t\t\t\t\t\t\\\n       unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n       if (! (content))\t\t\t\t\t\t\\\n-\t(var) = xcalloc ((num), sizeof (type));\t\t\t\\\n+\t(var) = XCNEWVEC (type, num);\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  (var) = xmalloc ((num) * sizeof (type));\t\t\\\n+\t  (var) = XNEWVEC (type, (num));\t\t\t\\\n \t  for (i = 0; i < num; i++)\t\t\t\t\\\n \t    (var)[i] = (content);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n@@ -213,7 +213,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n   /* Ending block.  */\n   basic_block ex_block;\n \n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n   sp = 0;\n \n   /* Initialize our border blocks, and the first edge.  */\n@@ -722,7 +722,7 @@ get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n   for (ason = son->right, n = 1; ason != son; ason = ason->right)\n     n++;\n \n-  *bbs = xmalloc (n * sizeof (basic_block));\n+  *bbs = XNEWVEC (basic_block, n);\n   (*bbs)[0] = son->data;\n   for (ason = son->right, n = 1; ason != son; ason = ason->right)\n     (*bbs)[n++] = ason->data;"}, {"sha": "97420217131d1af1753c8779efc991dec25683f9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -405,7 +405,7 @@ expand_builtin_dwarf_sp_column (void)\n static inline char *\n stripattributes (const char *s)\n {\n-  char *stripped = xmalloc (strlen (s) + 2);\n+  char *stripped = XNEWVEC (char, strlen (s) + 2);\n   char *p = stripped;\n \n   *p++ = '*';\n@@ -6315,7 +6315,7 @@ check_duplicate_cu (dw_die_ref cu, htab_t htable, unsigned int *sym_num)\n       return 1;\n     }\n \n-  entry = xcalloc (1, sizeof (struct cu_hash_table_entry));\n+  entry = XCNEW (struct cu_hash_table_entry);\n   entry->cu = cu;\n   entry->min_comdat_num = *sym_num = last->max_comdat_num;\n   entry->next = *slot;"}, {"sha": "fba9918b1bb978077dcd1ea7f4d9d012ca05aef3", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1121,7 +1121,7 @@ add_ttypes_entry (htab_t ttypes_hash, tree type)\n     {\n       /* Filter value is a 1 based table index.  */\n \n-      n = xmalloc (sizeof (*n));\n+      n = XNEW (struct ttypes_filter);\n       n->t = type;\n       n->filter = VEC_length (tree, cfun->eh->ttype_data) + 1;\n       *slot = n;\n@@ -1149,7 +1149,7 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n     {\n       /* Filter value is a -1 based byte index into a uleb128 buffer.  */\n \n-      n = xmalloc (sizeof (*n));\n+      n = XNEW (struct ttypes_filter);\n       n->t = list;\n       n->filter = -(VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) + 1);\n       *slot = n;\n@@ -1956,8 +1956,7 @@ sjlj_build_landing_pads (void)\n {\n   struct sjlj_lp_info *lp_info;\n \n-  lp_info = xcalloc (cfun->eh->last_region_number + 1,\n-\t\t     sizeof (struct sjlj_lp_info));\n+  lp_info = XCNEWVEC (struct sjlj_lp_info, cfun->eh->last_region_number + 1);\n \n   if (sjlj_find_directly_reachable_regions (lp_info))\n     {"}, {"sha": "c145045b133f16d3e5cb149f61c8d9849d4adb8d", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -693,8 +693,7 @@ compute_alignments (void)\n \n   max_labelno = max_label_num ();\n   min_labelno = get_first_label_num ();\n-  label_align = xcalloc (max_labelno - min_labelno + 1,\n-\t\t\t sizeof (struct label_alignment));\n+  label_align = XCNEWVEC (struct label_alignment, max_labelno - min_labelno + 1);\n \n   /* If not optimizing or optimizing for size, don't assign any alignments.  */\n   if (! optimize || optimize_size)\n@@ -817,7 +816,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n   /* Free uid_shuid before reallocating it.  */\n   free (uid_shuid);\n   \n-  uid_shuid = xmalloc (max_uid * sizeof *uid_shuid);\n+  uid_shuid = XNEWVEC (int, max_uid);\n \n   if (max_labelno != max_label_num ())\n     {\n@@ -926,20 +925,20 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n #ifdef HAVE_ATTR_length\n \n   /* Allocate the rest of the arrays.  */\n-  insn_lengths = xmalloc (max_uid * sizeof (*insn_lengths));\n+  insn_lengths = XNEWVEC (int, max_uid);\n   insn_lengths_max_uid = max_uid;\n   /* Syntax errors can lead to labels being outside of the main insn stream.\n      Initialize insn_addresses, so that we get reproducible results.  */\n   INSN_ADDRESSES_ALLOC (max_uid);\n \n-  varying_length = xcalloc (max_uid, sizeof (char));\n+  varying_length = XCNEWVEC (char, max_uid);\n \n   /* Initialize uid_align.  We scan instructions\n      from end to start, and keep in align_tab[n] the last seen insn\n      that does an alignment of at least n+1, i.e. the successor\n      in the alignment chain for an insn that does / has a known\n      alignment of n.  */\n-  uid_align = xcalloc (max_uid, sizeof *uid_align);\n+  uid_align = XCNEWVEC (rtx, max_uid);\n \n   for (i = MAX_CODE_ALIGN; --i >= 0;)\n     align_tab[i] = NULL_RTX;"}, {"sha": "8bf50260c87fb042b0b952897a1b0391ccbd8cea", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1187,7 +1187,7 @@ main (int argc, char **argv)\n       exit (FATAL_EXIT_CODE);\n     }\n   inf_size = sbuf.st_size;\n-  inf_buffer = xmalloc (inf_size + 2);\n+  inf_buffer = XNEWVEC (char, inf_size + 2);\n   inf_ptr = inf_buffer;\n \n   to_read = inf_size;"}, {"sha": "9c5c72e94df861e8e3cb2b93a13c659cde20c6f6", "filename": "gcc/flow.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -577,7 +577,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n   ndead = 0;\n \n   if ((prop_flags & PROP_REG_INFO) && !reg_deaths)\n-    reg_deaths = xcalloc (sizeof (*reg_deaths), max_regno);\n+    reg_deaths = XCNEWVEC (int, max_regno);\n \n   timevar_push ((extent == UPDATE_LIFE_LOCAL || blocks)\n \t\t? TV_LIFE_UPDATE : TV_LIFE);\n@@ -1060,12 +1060,12 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       SET_REGNO_REG_SET (invalidated_by_call, i);\n \n   /* Allocate space for the sets of local properties.  */\n-  local_sets = xcalloc (last_basic_block, sizeof (regset));\n-  cond_local_sets = xcalloc (last_basic_block, sizeof (regset));\n+  local_sets = XCNEWVEC (bitmap, last_basic_block);\n+  cond_local_sets = XCNEWVEC (bitmap, last_basic_block);\n \n   /* Create a worklist.  Allocate an extra slot for the `head == tail'\n      style test for an empty queue doesn't work with a full queue.  */\n-  queue = xmalloc ((n_basic_blocks + 1) * sizeof (*queue));\n+  queue = XNEWVEC (basic_block, n_basic_blocks + 1);\n   qtail = queue;\n   qhead = qend = queue + n_basic_blocks;\n \n@@ -1090,7 +1090,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t}\n     }\n \n-  block_accesses = xcalloc (last_basic_block, sizeof (int));\n+  block_accesses = XCNEWVEC (int, last_basic_block);\n   \n   /* We clean aux when we remove the initially-enqueued bbs, but we\n      don't enqueue ENTRY and EXIT initially, so clean them upfront and\n@@ -1574,7 +1574,7 @@ allocate_reg_life_data (void)\n \n   max_regno = max_reg_num ();\n   gcc_assert (!reg_deaths);\n-  reg_deaths = xcalloc (sizeof (*reg_deaths), max_regno);\n+  reg_deaths = XCNEWVEC (int, max_regno);\n \n   /* Recalculate the register space, in case it has grown.  Old style\n      vector oriented regsets would set regset_{size,bytes} here also.  */\n@@ -1940,7 +1940,7 @@ struct propagate_block_info *\n init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t\t   regset cond_local_set, int flags)\n {\n-  struct propagate_block_info *pbi = xmalloc (sizeof (*pbi));\n+  struct propagate_block_info *pbi = XNEW (struct propagate_block_info);\n \n   pbi->bb = bb;\n   pbi->reg_live = live;\n@@ -1953,7 +1953,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n   pbi->insn_num = 0;\n \n   if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-    pbi->reg_next_use = xcalloc (max_reg_num (), sizeof (rtx));\n+    pbi->reg_next_use = XCNEWVEC (rtx, max_reg_num ());\n   else\n     pbi->reg_next_use = NULL;\n \n@@ -2043,7 +2043,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t  struct reg_cond_life_info *rcli;\n \t\t  rtx cond;\n \n-\t\t  rcli = xmalloc (sizeof (*rcli));\n+\t\t  rcli = XNEW (struct reg_cond_life_info);\n \n \t\t  if (REGNO_REG_SET_P (bb_true->il.rtl->global_live_at_start,\n \t\t\t\t       i))\n@@ -3058,7 +3058,7 @@ mark_regno_cond_dead (struct propagate_block_info *pbi, int regno, rtx cond)\n \t  /* The register was unconditionally live previously.\n \t     Record the current condition as the condition under\n \t     which it is dead.  */\n-\t  rcli = xmalloc (sizeof (*rcli));\n+\t  rcli = XNEW (struct reg_cond_life_info);\n \t  rcli->condition = cond;\n \t  rcli->stores = cond;\n \t  rcli->orig_condition = const0_rtx;\n@@ -3858,7 +3858,7 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n \t    {\n \t      /* The register was not previously live at all.  Record\n \t\t the condition under which it is still dead.  */\n-\t      rcli = xmalloc (sizeof (*rcli));\n+\t      rcli = XNEW (struct reg_cond_life_info);\n \t      rcli->condition = not_reg_cond (cond);\n \t      rcli->stores = const0_rtx;\n \t      rcli->orig_condition = const0_rtx;"}, {"sha": "4a37164fe9a1681b23d3a546ab5a166398a61b56", "filename": "gcc/fortran/gfortranspec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -397,15 +397,15 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n \n           if (argv[i][2] == '\\0')\n             {\n-              p = xmalloc (strlen (argv[i + 1]) + 2);\n+              p = XNEWVEC (char, strlen (argv[i + 1]) + 2);\n               p[0] = '-';\n               p[1] = 'J';\n               strcpy (&p[2], argv[i + 1]);\n               i++;\n             }\n           else\n             {\n-              p = xmalloc (strlen (argv[i]) + 1);\n+              p = XNEWVEC (char, strlen (argv[i]) + 1);\n               strcpy (p, argv[i]);\n             }\n           append_arg (p);"}, {"sha": "9ff5ce69c97e4c23ae6843510caa2eb082560667", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -3744,7 +3744,7 @@ get_block_vector (tree block, int *n_blocks_p)\n   tree *block_vector;\n \n   *n_blocks_p = all_blocks (block, NULL);\n-  block_vector = xmalloc (*n_blocks_p * sizeof (tree));\n+  block_vector = XNEWVEC (tree, *n_blocks_p);\n   all_blocks (block, block_vector);\n \n   return block_vector;"}, {"sha": "9fe0970a8afa5218c982ef83f8c5ae74455f77b8", "filename": "gcc/gcc.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1829,7 +1829,7 @@ set_spec (const char *name, const char *spec)\n   if (!sl)\n     {\n       /* Not found - make it.  */\n-      sl = xmalloc (sizeof (struct spec_list));\n+      sl = XNEW (struct spec_list);\n       sl->name = xstrdup (name);\n       sl->name_len = name_len;\n       sl->ptr_spec = &sl->ptr;\n@@ -1912,7 +1912,7 @@ static void\n alloc_args (void)\n {\n   argbuf_length = 10;\n-  argbuf = xmalloc (argbuf_length * sizeof (const char *));\n+  argbuf = XNEWVEC (const char *, argbuf_length);\n }\n \n /* Clear out the vector of arguments (after a command is executed).  */\n@@ -1971,14 +1971,14 @@ load_specs (const char *filename)\n     pfatal_with_name (filename);\n \n   /* Read contents of file into BUFFER.  */\n-  buffer = xmalloc ((unsigned) statbuf.st_size + 1);\n+  buffer = XNEWVEC (char, statbuf.st_size + 1);\n   readlen = read (desc, buffer, (unsigned) statbuf.st_size);\n   if (readlen < 0)\n     pfatal_with_name (filename);\n   buffer[readlen] = 0;\n   close (desc);\n \n-  specs = xmalloc (readlen + 1);\n+  specs = XNEWVEC (char, readlen + 1);\n   specs_p = specs;\n   for (buffer_p = buffer; buffer_p && *buffer_p; buffer_p++)\n     {\n@@ -2294,7 +2294,7 @@ record_temp_file (const char *filename, int always_delete, int fail_delete)\n \tif (! strcmp (name, temp->name))\n \t  goto already1;\n \n-      temp = xmalloc (sizeof (struct temp_file));\n+      temp = XNEW (struct temp_file);\n       temp->next = always_delete_queue;\n       temp->name = name;\n       always_delete_queue = temp;\n@@ -2309,7 +2309,7 @@ record_temp_file (const char *filename, int always_delete, int fail_delete)\n \tif (! strcmp (name, temp->name))\n \t  goto already2;\n \n-      temp = xmalloc (sizeof (struct temp_file));\n+      temp = XNEW (struct temp_file);\n       temp->next = failure_delete_queue;\n       temp->name = name;\n       failure_delete_queue = temp;\n@@ -2440,7 +2440,7 @@ for_each_path (const struct path_prefix *paths,\n \t    len += suffix_len;\n \t  else\n \t    len += multi_os_dir_len;\n-\t  path = xmalloc (len);\n+\t  path = XNEWVEC (char, len);\n \t}\n \n       for (pl = paths->plist; pl != 0; pl = pl->next)\n@@ -2738,7 +2738,7 @@ add_prefix (struct path_prefix *pprefix, const char *prefix,\n   if (len > pprefix->max_len)\n     pprefix->max_len = len;\n \n-  pl = xmalloc (sizeof (struct prefix_list));\n+  pl = XNEW (struct prefix_list);\n   pl->prefix = prefix;\n   pl->require_machine_suffix = require_machine_suffix;\n   pl->priority = priority;\n@@ -3226,7 +3226,7 @@ add_preprocessor_option (const char *option, int len)\n   n_preprocessor_options++;\n \n   if (! preprocessor_options)\n-    preprocessor_options = xmalloc (n_preprocessor_options * sizeof (char *));\n+    preprocessor_options = XNEWVEC (char *, n_preprocessor_options);\n   else\n     preprocessor_options = xrealloc (preprocessor_options,\n \t\t\t\t     n_preprocessor_options * sizeof (char *));\n@@ -3241,7 +3241,7 @@ add_assembler_option (const char *option, int len)\n   n_assembler_options++;\n \n   if (! assembler_options)\n-    assembler_options = xmalloc (n_assembler_options * sizeof (char *));\n+    assembler_options = XNEWVEC (char *, n_assembler_options);\n   else\n     assembler_options = xrealloc (assembler_options,\n \t\t\t\t  n_assembler_options * sizeof (char *));\n@@ -3255,7 +3255,7 @@ add_linker_option (const char *option, int len)\n   n_linker_options++;\n \n   if (! linker_options)\n-    linker_options = xmalloc (n_linker_options * sizeof (char *));\n+    linker_options = XNEWVEC (char *, n_linker_options);\n   else\n     linker_options = xrealloc (linker_options,\n \t\t\t       n_linker_options * sizeof (char *));\n@@ -3685,7 +3685,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t}\n       else if (strcmp (argv[i], \"-specs\") == 0)\n \t{\n-\t  struct user_specs *user = xmalloc (sizeof (struct user_specs));\n+\t  struct user_specs *user = XNEW (struct user_specs);\n \t  if (++i >= argc)\n \t    fatal (\"argument to '-specs' is missing\");\n \n@@ -3699,7 +3699,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t}\n       else if (strncmp (argv[i], \"-specs=\", 7) == 0)\n \t{\n-\t  struct user_specs *user = xmalloc (sizeof (struct user_specs));\n+\t  struct user_specs *user = XNEW (struct user_specs);\n \t  if (strlen (argv[i]) == 7)\n \t    fatal (\"argument to '-specs=' is missing\");\n \n@@ -3766,7 +3766,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\tif (! IS_DIR_SEPARATOR (value [len - 1])\n \t\t    && is_directory (value, false))\n \t\t  {\n-\t\t    char *tmp = xmalloc (len + 2);\n+\t\t    char *tmp = XNEWVEC (char, len + 2);\n \t\t    strcpy (tmp, value);\n \t\t    tmp[len] = DIR_SEPARATOR;\n \t\t    tmp[++ len] = 0;\n@@ -4013,8 +4013,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \n   /* Then create the space for the vectors and scan again.  */\n \n-  switches = xmalloc ((n_switches + 1) * sizeof (struct switchstr));\n-  infiles = xmalloc ((n_infiles + 1) * sizeof (struct infile));\n+  switches = XNEWVEC (struct switchstr, n_switches + 1);\n+  infiles = XNEWVEC (struct infile, n_infiles + 1);\n   n_switches = 0;\n   n_infiles = 0;\n   last_language_n_infiles = -1;\n@@ -4164,7 +4164,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t      if (i + n_args >= argc)\n \t\tfatal (\"argument to '-%s' is missing\", p);\n \t      switches[n_switches].args\n-\t\t= xmalloc ((n_args + 1) * sizeof(const char *));\n+\t\t= XNEWVEC (const char *, n_args + 1);\n \t      while (j < n_args)\n \t\tswitches[n_switches].args[j++] = argv[++i];\n \t      /* Null-terminate the vector.  */\n@@ -4174,12 +4174,12 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t    {\n \t      /* On some systems, ld cannot handle some options without\n \t\t a space.  So split the option from its argument.  */\n-\t      char *part1 = xmalloc (2);\n+\t      char *part1 = XNEWVEC (char, 2);\n \t      part1[0] = c;\n \t      part1[1] = '\\0';\n \n \t      switches[n_switches].part1 = part1;\n-\t      switches[n_switches].args = xmalloc (2 * sizeof (const char *));\n+\t      switches[n_switches].args = XNEWVEC (const char *, 2);\n \t      switches[n_switches].args[0] = xstrdup (p+1);\n \t      switches[n_switches].args[1] = 0;\n \t    }\n@@ -4822,7 +4822,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    else\n \t\t      {\n \t\t\tsaved_suffix\n-\t\t\t  = xmalloc (suffix_length\n+\t\t\t  = XNEWVEC (char, suffix_length\n \t\t\t\t     + strlen (TARGET_OBJECT_SUFFIX));\n \t\t\tstrncpy (saved_suffix, suffix, suffix_length);\n \t\t\tstrcpy (saved_suffix + suffix_length,\n@@ -6477,11 +6477,11 @@ main (int argc, char **argv)\n \n   i = n_infiles;\n   i += lang_specific_extra_outfiles;\n-  outfiles = xcalloc (i, sizeof (char *));\n+  outfiles = XCNEWVEC (const char *, i);\n \n   /* Record which files were specified explicitly as link input.  */\n \n-  explicit_link_files = xcalloc (1, n_infiles);\n+  explicit_link_files = XCNEWVEC (bool, n_infiles);\n \n   if (combine_flag)\n     combine_inputs = true;\n@@ -6792,7 +6792,7 @@ lookup_compiler (const char *name, size_t length, const char *language)\n static char *\n save_string (const char *s, int len)\n {\n-  char *result = xmalloc (len + 1);\n+  char *result = XNEWVEC (char, len + 1);\n \n   memcpy (result, s, len);\n   result[len] = 0;\n@@ -7042,8 +7042,7 @@ used_arg (const char *p, int len)\n \t xmalloc from calling fatal, and prevents us from re-executing this\n \t block of code.  */\n       mswitches\n-\t= xmalloc (sizeof (struct mswitchstr)\n-\t\t   * (n_mdswitches + (n_switches ? n_switches : 1)));\n+\t= XNEWVEC (struct mswitchstr, n_mdswitches + (n_switches ? n_switches : 1));\n       for (i = 0; i < n_switches; i++)\n \tif (switches[i].live_cond != SWITCH_IGNORE)\n \t  {\n@@ -7170,7 +7169,7 @@ set_multilib_dir (void)\n     {\n       int i = 0;\n \n-      mdswitches = xmalloc (sizeof (struct mdswitchstr) * n_mdswitches);\n+      mdswitches = XNEWVEC (struct mdswitchstr, n_mdswitches);\n       for (start = multilib_defaults; *start != '\\0'; start = end + 1)\n \t{\n \t  while (*start == ' ' || *start == '\\t')\n@@ -7332,7 +7331,7 @@ set_multilib_dir (void)\n \t  if (this_path_len != 1\n \t      || this_path[0] != '.')\n \t    {\n-\t      char *new_multilib_dir = xmalloc (this_path_len + 1);\n+\t      char *new_multilib_dir = XNEWVEC (char, this_path_len + 1);\n \t      char *q;\n \n \t      strncpy (new_multilib_dir, this_path, this_path_len);\n@@ -7353,7 +7352,7 @@ set_multilib_dir (void)\n \t    q++;\n \t  if (q < end)\n \t    {\n-\t      char *new_multilib_os_dir = xmalloc (end - q);\n+\t      char *new_multilib_os_dir = XNEWVEC (char, end - q);\n \t      memcpy (new_multilib_os_dir, q + 1, end - q - 1);\n \t      new_multilib_os_dir[end - q - 1] = '\\0';\n \t      multilib_os_dir = new_multilib_os_dir;"}, {"sha": "39b90d92fee3205940ce46d118894997ba2a74c5", "filename": "gcc/gccspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgccspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgccspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgccspec.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -73,7 +73,7 @@ lang_specific_driver (int *in_argc ATTRIBUTE_UNUSED,\n   if  (shared_libgcc)\n     {\n       /* Make sure to have room for the trailing NULL argument.  */\n-      arglist = xmalloc ((argc+2) * sizeof (char *));\n+      arglist = XNEWVEC (const char *, argc + 2);\n \n       i = 0;\n       do"}, {"sha": "78f0ad495e7940502c916cf45bd4f6e6354811fa", "filename": "gcc/gcov.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -514,7 +514,7 @@ process_file (const char *file_name)\n   for (fn = functions; fn; fn = fn->next)\n     solve_flow_graph (fn);\n   for (src = sources; src; src = src->next)\n-    src->lines = xcalloc (src->num_lines, sizeof (line_t));\n+    src->lines = XCNEWVEC (line_t, src->num_lines);\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n@@ -621,7 +621,7 @@ create_file_names (const char *file_name)\n       struct stat status;\n \n       length += strlen (object_directory) + 2;\n-      name = xmalloc (length);\n+      name = XNEWVEC (char, length);\n       name[0] = 0;\n \n       base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);\n@@ -631,7 +631,7 @@ create_file_names (const char *file_name)\n     }\n   else\n     {\n-      name = xmalloc (length + 1);\n+      name = XNEWVEC (char, length + 1);\n       name[0] = 0;\n       base = 1;\n     }\n@@ -650,11 +650,11 @@ create_file_names (const char *file_name)\n \n   length = strlen (name);\n   \n-  bbg_file_name = xmalloc (length + strlen (GCOV_NOTE_SUFFIX) + 1);\n+  bbg_file_name = XNEWVEC (char, length + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, name);\n   strcpy (bbg_file_name + length, GCOV_NOTE_SUFFIX);\n \n-  da_file_name = xmalloc (length + strlen (GCOV_DATA_SUFFIX) + 1);\n+  da_file_name = XNEWVEC (char, length + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, name);\n   strcpy (da_file_name + length, GCOV_DATA_SUFFIX);\n \n@@ -676,7 +676,7 @@ find_source (const char *file_name)\n     if (!strcmp (file_name, src->name))\n       return src;\n \n-  src = xcalloc (1, sizeof (source_t));\n+  src = XCNEW (source_t);\n   src->name = xstrdup (file_name);\n   src->coverage.name = src->name;\n   src->index = sources ? sources->index + 1 : 1;\n@@ -742,7 +742,7 @@ read_graph_file (void)\n \t  src = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n \n-\t  fn = xcalloc (1, sizeof (function_t));\n+\t  fn = XCNEW (function_t);\n \t  fn->name = function_name;\n \t  fn->ident = ident;\n \t  fn->checksum = checksum;\n@@ -778,7 +778,7 @@ read_graph_file (void)\n \t      unsigned ix, num_blocks = GCOV_TAG_BLOCKS_NUM (length);\n \t      fn->num_blocks = num_blocks;\n \n-\t      fn->blocks = xcalloc (fn->num_blocks, sizeof (block_t));\n+\t      fn->blocks = XCNEWVEC (block_t, fn->num_blocks);\n \t      for (ix = 0; ix != num_blocks; ix++)\n \t\tfn->blocks[ix].flags = gcov_read_unsigned ();\n \t    }\n@@ -799,7 +799,7 @@ read_graph_file (void)\n \n \t      if (dest >= fn->num_blocks)\n \t\tgoto corrupt;\n-\t      arc = xcalloc (1, sizeof (arc_t));\n+\t      arc = XCNEW (arc_t);\n \n \t      arc->dst = &fn->blocks[dest];\n \t      arc->src = &fn->blocks[src];\n@@ -844,7 +844,7 @@ read_graph_file (void)\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n \t  unsigned blockno = gcov_read_unsigned ();\n-\t  unsigned *line_nos = xcalloc (length - 1, sizeof (unsigned));\n+\t  unsigned *line_nos = XCNEWVEC (unsigned, length - 1);\n \n \t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n@@ -1037,7 +1037,7 @@ read_count_file (void)\n \t    goto mismatch;\n \n \t  if (!fn->counts)\n-\t    fn->counts = xcalloc (fn->num_counts, sizeof (gcov_type));\n+\t    fn->counts = XCNEWVEC (gcov_type, fn->num_counts);\n \n \t  for (ix = 0; ix != fn->num_counts; ix++)\n \t    fn->counts[ix] += gcov_read_counter ();\n@@ -1417,7 +1417,7 @@ static char *\n make_gcov_file_name (const char *input_name, const char *src_name)\n {\n   char *cptr;\n-  char *name = xmalloc (strlen (src_name) + strlen (input_name) + 10);\n+  char *name = XNEWVEC (char, strlen (src_name) + strlen (input_name) + 10);\n \n   name[0] = 0;\n   if (flag_long_names && strcmp (src_name, input_name))"}, {"sha": "74dd6ea65b562b9c6c3a92f11b8b5d922f5327c9", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -3405,7 +3405,7 @@ one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n   local_cprop_pass (cprop_jumps);\n \n   /* Determine implicit sets.  */\n-  implicit_sets = xcalloc (last_basic_block, sizeof (rtx));\n+  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n   find_implicit_sets ();\n \n   alloc_hash_table (max_cuid, &set_hash_table, 1);\n@@ -3936,7 +3936,7 @@ static int\n pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n {\n   int rval;\n-  char *visited = xcalloc (last_basic_block, 1);\n+  char *visited = XCNEWVEC (char, last_basic_block);\n \n   rval = pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited);\n \n@@ -4499,7 +4499,7 @@ pre_gcse (void)\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -4790,7 +4790,7 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n   if (visited == NULL)\n     {\n       visited_allocated_locally = 1;\n-      visited = xcalloc (last_basic_block, 1);\n+      visited = XCNEWVEC (char, last_basic_block);\n     }\n \n   FOR_EACH_EDGE (pred, ei, bb->preds)\n@@ -4842,7 +4842,7 @@ hoist_code (void)\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -5071,7 +5071,7 @@ ldst_entry (rtx x)\n   if (*slot)\n     return (struct ls_expr *)*slot;\n \n-  ptr = xmalloc (sizeof (struct ls_expr));\n+  ptr = XNEW (struct ls_expr);\n \n   ptr->next         = pre_ldst_mems;\n   ptr->expr         = NULL;\n@@ -5752,8 +5752,8 @@ compute_store_table (void)\n   pre_ldst_mems = 0;\n   pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n \t\t\t\tpre_ldst_expr_eq, NULL);\n-  last_set_in = xcalloc (max_gcse_regno, sizeof (int));\n-  already_set = xmalloc (sizeof (int) * max_gcse_regno);\n+  last_set_in = XCNEWVEC (int, max_gcse_regno);\n+  already_set = XNEWVEC (int, max_gcse_regno);\n \n   /* Find all the stores we care about.  */\n   FOR_EACH_BB (bb)\n@@ -6094,7 +6094,7 @@ build_store_vectors (void)\n \n   transp = sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (transp, last_basic_block);\n-  regs_set_in_block = xmalloc (sizeof (int) * max_gcse_regno);\n+  regs_set_in_block = XNEWVEC (int, max_gcse_regno);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -6242,7 +6242,7 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n   rtx last, insn, note;\n   rtx mem = smexpr->pattern;\n \n-  stack = xmalloc (sizeof (edge_iterator) * n_basic_blocks);\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks);\n   sp = 0;\n   ei = ei_start (bb->succs);\n "}, {"sha": "f11532f19beade33a4737bebaae419d98d002371", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1647,7 +1647,7 @@ simplify_cond (rtx exp, int insn_code, int insn_index)\n   rtx defval = XEXP (exp, 1);\n   rtx new_defval = XEXP (exp, 1);\n   int len = XVECLEN (exp, 0);\n-  rtx *tests = xmalloc (len * sizeof (rtx));\n+  rtx *tests = XNEWVEC (rtx, len);\n   int allsame = 1;\n   rtx ret;\n \n@@ -2773,13 +2773,12 @@ optimize_attrs (void)\n     return;\n \n   /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n-  insn_code_values = xcalloc ((insn_code_number + 2),\n-\t\t\t      sizeof (struct attr_value_list *));\n+  insn_code_values = XCNEWVEC (struct attr_value_list *, insn_code_number + 2);\n \n   /* Offset the table address so we can index by -2 or -1.  */\n   insn_code_values += 2;\n \n-  iv = ivbuf = xmalloc (num_insn_ents * sizeof (struct attr_value_list));\n+  iv = ivbuf = XNEWVEC (struct attr_value_list, num_insn_ents);\n \n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)"}, {"sha": "2c17ee4b4469e67adda567e99bb263f88cb73539", "filename": "gcc/genautomata.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -3791,7 +3791,7 @@ initiate_states (void)\n   int i;\n \n   if (description->units_num)\n-    units_array = xmalloc (description->units_num * sizeof (unit_decl_t));\n+    units_array = XNEWVEC (unit_decl_t, description->units_num);\n   else\n     units_array = 0;\n \n@@ -6162,7 +6162,7 @@ static void\n process_state_for_insn_equiv_partition (state_t state)\n {\n   arc_t arc;\n-  arc_t *insn_arcs_array = xcalloc (description->insns_num, sizeof(arc_t));\n+  arc_t *insn_arcs_array = XCNEWVEC (arc_t, description->insns_num);\n \n   /* Process insns of the arcs.  */\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n@@ -6292,7 +6292,7 @@ units_to_automata_heuristic_distr (void)\n   if (description->units_num == 0)\n     return;\n   estimation_bound = estimate_one_automaton_bound ();\n-  unit_decls = xmalloc (description->units_num * sizeof (unit_decl_t));\n+  unit_decls = XNEWVEC (unit_decl_t, description->units_num);\n \n   for (i = 0, j = 0; i < description->decls_num; i++)\n     if (description->decls[i]->mode == dm_unit)"}, {"sha": "7c743005477604a394ec8f8e467ef814af847639", "filename": "gcc/genemit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -341,7 +341,7 @@ gen_insn (rtx insn, int lineno)\n       if (i != XVECLEN (insn, 1) - 1)\n \t{\n \t  struct clobber_pat *p;\n-\t  struct clobber_ent *link = xmalloc (sizeof (struct clobber_ent));\n+\t  struct clobber_ent *link = XNEW (struct clobber_ent);\n \t  int j;\n \n \t  link->code_number = insn_code_number;\n@@ -377,7 +377,7 @@ gen_insn (rtx insn, int lineno)\n \n \t  if (p == 0)\n \t    {\n-\t      p = xmalloc (sizeof (struct clobber_pat));\n+\t      p = XNEW (struct clobber_pat);\n \n \t      p->insns = 0;\n \t      p->pattern = insn;\n@@ -599,7 +599,7 @@ gen_split (rtx split)\n   max_operand_vec (split, 2);\n   operands = MAX (max_opno, MAX (max_dup_opno, max_scratch_opno)) + 1;\n   unused = (operands == 0 ? \" ATTRIBUTE_UNUSED\" : \"\");\n-  used = xcalloc (1, operands);\n+  used = XCNEWVEC (char, operands);\n \n   /* Output the prototype, function name and argument declarations.  */\n   if (GET_CODE (split) == DEFINE_PEEPHOLE2)"}, {"sha": "06ed44ac4475c0fc88dc8a216250c6d065aa47b8", "filename": "gcc/genextract.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -208,7 +208,7 @@ static char *\n VEC_char_to_string (VEC(char,heap) *v)\n {\n   size_t n = VEC_length (char, v);\n-  char *s = xmalloc (n + 1);\n+  char *s = XNEWVEC (char, n + 1);\n   memcpy (s, VEC_address (char, v), n);\n   s[n] = '\\0';\n   return s;\n@@ -419,7 +419,7 @@ main (int argc, char **argv)\n \n       else if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n \t{\n-\t  struct code_ptr *link = xmalloc (sizeof (struct code_ptr));\n+\t  struct code_ptr *link = XNEW (struct code_ptr);\n \n \t  link->insn_code = insn_code_number;\n \t  link->next = peepholes;"}, {"sha": "7d1feb6fdcafecd0e524186dd1cbbe1957fdf476", "filename": "gcc/genoutput.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -798,7 +798,7 @@ validate_insn_operands (struct data *d)\n static void\n gen_insn (rtx insn, int lineno)\n {\n-  struct data *d = xmalloc (sizeof (struct data));\n+  struct data *d = XNEW (struct data);\n   int i;\n \n   d->code_number = next_code_number;\n@@ -840,7 +840,7 @@ gen_insn (rtx insn, int lineno)\n static void\n gen_peephole (rtx peep, int lineno)\n {\n-  struct data *d = xmalloc (sizeof (struct data));\n+  struct data *d = XNEW (struct data);\n   int i;\n \n   d->code_number = next_code_number;\n@@ -879,7 +879,7 @@ gen_peephole (rtx peep, int lineno)\n static void\n gen_expand (rtx insn, int lineno)\n {\n-  struct data *d = xmalloc (sizeof (struct data));\n+  struct data *d = XNEW (struct data);\n   int i;\n \n   d->code_number = next_code_number;\n@@ -923,7 +923,7 @@ gen_expand (rtx insn, int lineno)\n static void\n gen_split (rtx split, int lineno)\n {\n-  struct data *d = xmalloc (sizeof (struct data));\n+  struct data *d = XNEW (struct data);\n   int i;\n \n   d->code_number = next_code_number;\n@@ -1034,7 +1034,7 @@ strip_whitespace (const char *s)\n   if (s == 0)\n     return 0;\n \n-  p = q = xmalloc (strlen (s) + 1);\n+  p = q = XNEWVEC (char, strlen (s) + 1);\n   while ((ch = *s++) != '\\0')\n     if (! ISSPACE (ch))\n       *p++ = ch;"}, {"sha": "a72243c403f50edf9029b21fed304d658f892305", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -511,7 +511,7 @@ new_decision_test (enum decision_type type, struct decision_test ***pplace)\n   struct decision_test **place = *pplace;\n   struct decision_test *test;\n \n-  test = xmalloc (sizeof (*test));\n+  test = XNEW (struct decision_test);\n   test->next = *place;\n   test->type = type;\n   *place = test;"}, {"sha": "3da248b6e4073a75be284fe4bc2945f2c54b19eb", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -468,7 +468,7 @@ gt_pch_save (FILE *f)\n       \n   ggc_pch_this_base (state.d, mmi.preferred_base);\n \n-  state.ptrs = xmalloc (state.count * sizeof (*state.ptrs));\n+  state.ptrs = XNEWVEC (struct ptr_data *, state.count);\n   state.ptrs_i = 0;\n   htab_traverse (saving_htab, call_alloc, &state);\n   qsort (state.ptrs, state.count, sizeof (*state.ptrs), compare_ptr_data);\n@@ -865,7 +865,7 @@ ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n \t\t     const char *name, int line, const char *function)\n {\n   struct loc_descriptor *loc = loc_descriptor (name, line, function);\n-  struct ptr_hash_entry *p = xmalloc (sizeof (struct ptr_hash_entry));\n+  struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n   PTR *slot;\n \n   p->ptr = ptr;"}, {"sha": "ca11fd7ae797377ce42d3dd0eaa34b1a0303b1a5", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -628,7 +628,7 @@ set_page_table_entry (void *p, page_entry *entry)\n   L2 = LOOKUP_L2 (p);\n \n   if (base[L1] == NULL)\n-    base[L1] = xcalloc (PAGE_L2_SIZE, sizeof (page_entry *));\n+    base[L1] = XCNEWVEC (page_entry *, PAGE_L2_SIZE);\n \n   base[L1][L2] = entry;\n }\n@@ -1346,7 +1346,7 @@ ggc_free (void *p)\n      the data, but instead verify that the data is *actually* not \n      reachable the next time we collect.  */\n   {\n-    struct free_object *fo = xmalloc (sizeof (struct free_object));\n+    struct free_object *fo = XNEW (struct free_object);\n     fo->object = p;\n     fo->next = G.free_object_list;\n     G.free_object_list = fo;\n@@ -1472,7 +1472,7 @@ init_ggc (void)\n       }\n \n     /* We have a good page, might as well hold onto it...  */\n-    e = xcalloc (1, sizeof (struct page_entry));\n+    e = XCNEW (struct page_entry);\n     e->bytes = G.pagesize;\n     e->page = p;\n     e->next = G.free_pages;\n@@ -1518,12 +1518,12 @@ init_ggc (void)\n \n   G.depth_in_use = 0;\n   G.depth_max = 10;\n-  G.depth = xmalloc (G.depth_max * sizeof (unsigned int));\n+  G.depth = XNEWVEC (unsigned int, G.depth_max);\n \n   G.by_depth_in_use = 0;\n   G.by_depth_max = INITIAL_PTE_COUNT;\n-  G.by_depth = xmalloc (G.by_depth_max * sizeof (page_entry *));\n-  G.save_in_use = xmalloc (G.by_depth_max * sizeof (unsigned long *));\n+  G.by_depth = XNEWVEC (page_entry *, G.by_depth_max);\n+  G.save_in_use = XNEWVEC (unsigned long *, G.by_depth_max);\n }\n \n /* Start a new GGC zone.  */\n@@ -2013,7 +2013,7 @@ struct ggc_pch_data\n struct ggc_pch_data *\n init_ggc_pch (void)\n {\n-  return xcalloc (sizeof (struct ggc_pch_data), 1);\n+  return XCNEW (struct ggc_pch_data);\n }\n \n void\n@@ -2161,8 +2161,8 @@ move_ptes_to_front (int count_old_page_tables, int count_new_page_tables)\n   page_entry **new_by_depth;\n   unsigned long **new_save_in_use;\n \n-  new_by_depth = xmalloc (G.by_depth_max * sizeof (page_entry *));\n-  new_save_in_use = xmalloc (G.by_depth_max * sizeof (unsigned long *));\n+  new_by_depth = XNEWVEC (page_entry *, G.by_depth_max);\n+  new_save_in_use = XNEWVEC (unsigned long *, G.by_depth_max);\n \n   memcpy (&new_by_depth[0],\n \t  &G.by_depth[count_old_page_tables],"}, {"sha": "4c6ec1fab0be5076b821a4a5f14c6064b158b80c", "filename": "gcc/global.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -442,14 +442,14 @@ global_alloc (FILE *file)\n   /* Establish mappings from register number to allocation number\n      and vice versa.  In the process, count the allocnos.  */\n \n-  reg_allocno = xmalloc (max_regno * sizeof (int));\n+  reg_allocno = XNEWVEC (int, max_regno);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_allocno[i] = -1;\n \n   /* Initialize the shared-hard-reg mapping\n      from the list of pairs that may share.  */\n-  reg_may_share = xcalloc (max_regno, sizeof (int));\n+  reg_may_share = XCNEWVEC (int, max_regno);\n   for (x = regs_may_share; x; x = XEXP (XEXP (x, 1), 1))\n     {\n       int r1 = REGNO (XEXP (x, 0));\n@@ -480,7 +480,7 @@ global_alloc (FILE *file)\n     else\n       reg_allocno[i] = -1;\n \n-  allocno = xcalloc (max_allocno, sizeof (struct allocno));\n+  allocno = XCNEWVEC (struct allocno, max_allocno);\n \n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_allocno[i] >= 0)\n@@ -528,9 +528,9 @@ global_alloc (FILE *file)\n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n-  conflicts = xcalloc (max_allocno * allocno_row_words, sizeof (INT_TYPE));\n+  conflicts = XCNEWVEC (INT_TYPE, max_allocno * allocno_row_words);\n \n-  allocnos_live = xmalloc (allocno_row_words * sizeof (INT_TYPE));\n+  allocnos_live = XNEWVEC (INT_TYPE, allocno_row_words);\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n@@ -567,7 +567,7 @@ global_alloc (FILE *file)\n \n       /* Determine the order to allocate the remaining pseudo registers.  */\n \n-      allocno_order = xmalloc (max_allocno * sizeof (int));\n+      allocno_order = XNEWVEC (int, max_allocno);\n       for (i = 0; i < (size_t) max_allocno; i++)\n \tallocno_order[i] = i;\n \n@@ -678,9 +678,9 @@ global_conflicts (void)\n   int *block_start_allocnos;\n \n   /* Make a vector that mark_reg_{store,clobber} will store in.  */\n-  regs_set = xmalloc (max_parallel * sizeof (rtx) * 2);\n+  regs_set = XNEWVEC (rtx, max_parallel * 2);\n \n-  block_start_allocnos = xmalloc (max_allocno * sizeof (int));\n+  block_start_allocnos = XNEWVEC (int, max_allocno);\n \n   FOR_EACH_BB (b)\n     {\n@@ -949,7 +949,7 @@ prune_preferences (void)\n {\n   int i;\n   int num;\n-  int *allocno_to_order = xmalloc (max_allocno * sizeof (int));\n+  int *allocno_to_order = XNEWVEC (int, max_allocno);\n \n   /* Scan least most important to most important.\n      For each allocno, remove from preferences registers that cannot be used,\n@@ -2300,7 +2300,7 @@ set_up_bb_rts_numbers (void)\n   int i;\n   int *rts_order;\n   \n-  rts_order = xmalloc (sizeof (int) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n+  rts_order = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n   post_order_compute (rts_order, false);\n   for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     BB_INFO_BY_INDEX (rts_order [i])->rts_number = i;"}, {"sha": "5e1627d8e43b7abb2306d46c0a2ba711fd908410", "filename": "gcc/graph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -247,9 +247,9 @@ print_rtl_graph_with_bb (const char *base, rtx rtx_first)\n     {\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      int *start = xmalloc (max_uid * sizeof (int));\n-      int *end = xmalloc (max_uid * sizeof (int));\n-      enum bb_state *in_bb_p = xmalloc (max_uid * sizeof (enum bb_state));\n+      int *start = XNEWVEC (int, max_uid);\n+      int *end = XNEWVEC (int, max_uid);\n+      enum bb_state *in_bb_p = XNEWVEC (enum bb_state, max_uid);\n       basic_block bb;\n       int i;\n "}, {"sha": "0572560111eb72a144ea7dca98514f177017d1ad", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1875,14 +1875,13 @@ schedule_block (int b, int rgn_n_insns)\n   /* Allocate the ready list.  */\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n-  ready.vec = xmalloc (ready.veclen * sizeof (rtx));\n+  ready.vec = XNEWVEC (rtx, ready.veclen);\n   ready.n_ready = 0;\n \n   /* It is used for first cycle multipass scheduling.  */\n   temp_state = alloca (dfa_state_size);\n-  ready_try = xcalloc ((rgn_n_insns + 1), sizeof (char));\n-  choice_stack = xmalloc ((rgn_n_insns + 1)\n-\t\t\t  * sizeof (struct choice_entry));\n+  ready_try = XCNEWVEC (char, rgn_n_insns + 1);\n+  choice_stack = XNEWVEC (struct choice_entry, rgn_n_insns + 1);\n   for (i = 0; i <= rgn_n_insns; i++)\n     choice_stack[i].state = xmalloc (dfa_state_size);\n \n@@ -2253,7 +2252,7 @@ sched_init (FILE *dump_file)\n      pseudos which do not cross calls.  */\n   old_max_uid = get_max_uid () + 1;\n \n-  h_i_d = xcalloc (old_max_uid, sizeof (*h_i_d));\n+  h_i_d = XCNEWVEC (struct haifa_insn_data, old_max_uid);\n \n   for (i = 0; i < old_max_uid; i++)\n     h_i_d [i].cost = -1;\n@@ -2295,7 +2294,7 @@ sched_init (FILE *dump_file)\n     {\n       rtx line;\n \n-      line_note_head = xcalloc (last_basic_block, sizeof (rtx));\n+      line_note_head = XCNEWVEC (rtx, last_basic_block);\n \n       /* Save-line-note-head:\n          Determine the line-number at the start of each basic block."}, {"sha": "23e8de80a2ef69100cf93ee45de61d94fd188398", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -352,7 +352,7 @@ static inline void\n ipcp_formal_create (struct cgraph_node *mt)\n {\n   IPA_NODE_REF (mt)->ipcp_cval =\n-    xcalloc (ipa_method_formal_count (mt), sizeof (struct ipcp_formal));\n+    XCNEWVEC (struct ipcp_formal, ipa_method_formal_count (mt));\n }\n \n /* Set cval structure of I-th formal of MT to CVAL.  */\n@@ -853,7 +853,7 @@ ipcp_replace_map_create (enum cvalue_type type, tree parm_tree,\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n-  replace_map = xcalloc (1, sizeof (struct ipa_replace_map));\n+  replace_map = XCNEW (struct ipa_replace_map);\n   gcc_assert (ipcp_type_is_const (type));\n   if (type == CONST_VALUE_REF )\n     {"}, {"sha": "2cb6b4207f2721719e4d9b249c343f230190a5d3", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -869,7 +869,7 @@ cgraph_decide_inlining (void)\n   struct cgraph_node *node;\n   int nnodes;\n   struct cgraph_node **order =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int old_insns = 0;\n   int i;\n \n@@ -1138,7 +1138,7 @@ cgraph_early_inlining (void)\n   struct cgraph_node *node;\n   int nnodes;\n   struct cgraph_node **order =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int i;\n \n   if (sorrycount || errorcount)"}, {"sha": "58fe8507a608fae011762d34d315aa2c699aafb5", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -167,15 +167,15 @@ static inline void\n ipa_method_tree_map_create (struct cgraph_node *mt)\n {\n   IPA_NODE_REF (mt)->ipa_param_tree =\n-    xcalloc (ipa_method_formal_count (mt), sizeof (tree));\n+    XCNEWVEC (tree, ipa_method_formal_count (mt));\n }\n \n /* Create modify structure for MT.  */\n static inline void\n ipa_method_modify_create (struct cgraph_node *mt)\n {\n   ((struct ipa_node *) mt->aux)->ipa_mod =\n-    xcalloc (ipa_method_formal_count (mt), sizeof (bool));\n+    XCNEWVEC (bool, ipa_method_formal_count (mt));\n }\n \n /* Set modify of I-th formal of MT to VAL.  */\n@@ -388,7 +388,7 @@ static inline void\n ipa_callsite_param_map_create (struct cgraph_edge *cs)\n {\n   IPA_EDGE_REF (cs)->ipa_param_map =\n-    xcalloc (ipa_callsite_param_count (cs), sizeof (struct ipa_jump_func));\n+    XCNEWVEC (struct ipa_jump_func, ipa_callsite_param_count (cs));\n }\n \n /* Return the call expr tree related to callsite CS.  */"}, {"sha": "1026d9b3130df9598a00d976df64a2cd93f45020", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -490,7 +490,7 @@ scan_function (tree *tp,\n static void\n analyze_function (struct cgraph_node *fn)\n {\n-  funct_state l = xcalloc (1, sizeof (struct funct_state_d));\n+  funct_state l = XCNEW (struct funct_state_d);\n   tree decl = fn->decl;\n   struct ipa_dfs_info * w_info = fn->aux;\n \n@@ -578,7 +578,7 @@ static_execute (void)\n   struct cgraph_node *node;\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int order_pos = order_pos = ipa_utils_reduced_inorder (order, true, false);\n   int i;\n   struct ipa_dfs_info * w_info;"}, {"sha": "28689dabe8cad518b79fb21c416f514fe92b45d1", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -200,7 +200,7 @@ compare_type_brand (splay_tree_key sk1, splay_tree_key sk2)\n static tree\n discover_unique_type (tree type)\n {\n-  struct type_brand_s * brand = xmalloc (sizeof (struct type_brand_s));\n+  struct type_brand_s * brand = XNEW (struct type_brand_s);\n   int i = 0;\n   splay_tree_node result;\n "}, {"sha": "f0025c7559fa0f400e00955117e794a39aedcb11", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -161,7 +161,7 @@ ipa_utils_reduced_inorder (struct cgraph_node **order,\n   struct cgraph_node *node;\n   struct searchc_env env;\n   splay_tree_node result;\n-  env.stack = xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+  env.stack = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   env.stack_size = 0;\n   env.result = order;\n   env.order_pos = 0;"}, {"sha": "eb08e3b880d9e6e4992fb29345b13f66ca0a0fb2", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -36,7 +36,7 @@ cgraph_postorder (struct cgraph_node **order)\n   struct cgraph_edge *edge, last;\n \n   struct cgraph_node **stack =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n \n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need"}, {"sha": "996dac78585e05e27415dd5aa695128e4800764b", "filename": "gcc/java/buffer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuffer.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -37,7 +37,7 @@ buffer_grow (struct buffer *bufp, int size)\n     {\n       if (size < 120)\n \tsize = 120;\n-      bufp->data = xmalloc (size);\n+      bufp->data = XNEWVEC (unsigned char, size);\n       bufp->ptr = bufp->data;\n     }\n   else"}, {"sha": "c09ed5c5314e48814338c0ec7735d476699d0e07", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -156,7 +156,7 @@ add_class_flag (class_flag_node **rootp, const char *ident, int value)\n \n   if (NULL == root)\n     {\n-      root = xmalloc (sizeof (class_flag_node));\n+      root = XNEW (class_flag_node);\n       root->ident = \"\";\n       root->value = 0;\n       root->sibling = NULL;\n@@ -183,7 +183,7 @@ add_class_flag (class_flag_node **rootp, const char *ident, int value)\n   else\n     {\n       /* Insert new node into the tree.  */\n-      node = xmalloc (sizeof (class_flag_node));\n+      node = XNEW (class_flag_node);\n \n       node->ident = xstrdup (ident);\n       node->value = value;"}, {"sha": "2354a6d0794b58e3e702a23ed417eaab314ea953", "filename": "gcc/java/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -211,7 +211,7 @@ split_range (struct eh_range *range, int pc)\n     }\n \n   /* Create a new range.  */\n-  h = xmalloc (sizeof (struct eh_range));\n+  h = XNEW (struct eh_range);\n \n   h->start_pc = pc;\n   h->end_pc = range->end_pc;\n@@ -289,7 +289,7 @@ add_handler (int start_pc, int end_pc, tree handler, tree type)\n     }\n \n   /* Create the new range.  */\n-  h = xmalloc (sizeof (struct eh_range));\n+  h = XNEW (struct eh_range);\n   first_child = &h->first_child;\n \n   h->start_pc = start_pc;"}, {"sha": "8c9884b96faaa35c5981c614a6710361e7a439d3", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -600,7 +600,7 @@ cxx_keyword_subst (const unsigned char *str, int length)\n \t     are `$'.  */\n \t  if (i == length)\n \t    {\n-\t      char *dup = xmalloc (2 + length - min_length + kwl);\n+\t      char *dup = XNEWVEC (char, 2 + length - min_length + kwl);\n \t      strcpy (dup, cxx_keywords[mid]);\n \t      for (i = kwl; i < length + 1; ++i)\n \t\tdup[i] = '$';\n@@ -719,7 +719,7 @@ get_field_name (JCF *jcf, int name_index, JCF_u2 flags)\n \t  return NULL;\n \t}\n \n-      override = xmalloc (length + 3);\n+      override = XNEWVEC (char, length + 3);\n       memcpy (override, name, length);\n       strcpy (override + length, \"__\");\n     }\n@@ -929,13 +929,13 @@ print_method_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n     {\n       struct method_name *nn;\n \n-      nn = xmalloc (sizeof (struct method_name));\n-      nn->name = xmalloc (length);\n+      nn = XNEW (struct method_name);\n+      nn->name = XNEWVEC (unsigned char, length);\n       memcpy (nn->name, str, length);\n       nn->length = length;\n       nn->next = method_name_list;\n       nn->sig_length = JPOOL_UTF_LENGTH (jcf, sig_index);\n-      nn->signature = xmalloc (nn->sig_length);\n+      nn->signature = XNEWVEC (unsigned char, nn->sig_length);\n       nn->is_native = METHOD_IS_NATIVE (flags);\n       memcpy (nn->signature, JPOOL_UTF_DATA (jcf, sig_index),\n \t      nn->sig_length);\n@@ -1240,7 +1240,7 @@ throwable_p (const unsigned char *clname)\n \n   for (length = 0; clname[length] != ';' && clname[length] != '\\0'; ++length)\n     ;\n-  current = ALLOC (length + 1);\n+  current = XNEWVEC (unsigned char, length + 1);\n   for (i = 0; i < length; ++i)\n     current[i] = clname[i] == '/' ? '.' : clname[i];\n   current[length] = '\\0';\n@@ -1276,7 +1276,7 @@ throwable_p (const unsigned char *clname)\n       jcf_parse_class (&jcf);\n \n       tmp = (unsigned char *) super_class_name (&jcf, &super_length);\n-      super = ALLOC (super_length + 1);\n+      super = XNEWVEC (unsigned char, super_length + 1);\n       memcpy (super, tmp, super_length);      \n       super[super_length] = '\\0';\n \n@@ -1836,8 +1836,8 @@ print_include (FILE *out, const unsigned char *utf8, int len)\n \treturn;\n     }\n \n-  incl = xmalloc (sizeof (struct include));\n-  incl->name = xmalloc (len + 1);\n+  incl = XNEW (struct include);\n+  incl->name = XNEWVEC (char, len + 1);\n   strncpy (incl->name, (const char *) utf8, len);\n   incl->name[len] = '\\0';\n   incl->next = all_includes;\n@@ -1922,8 +1922,8 @@ add_namelet (const unsigned char *name, const unsigned char *name_limit,\n \n   if (n == NULL)\n     {\n-      n = xmalloc (sizeof (struct namelet));\n-      n->name = xmalloc (p - name + 1);\n+      n = XNEW (struct namelet);\n+      n->name = XNEWVEC (char, p - name + 1);\n       strncpy (n->name, (const char *) name, p - name);\n       n->name[p - name] = '\\0';\n       n->is_class = (p == name_limit);\n@@ -2173,7 +2173,7 @@ process_file (JCF *jcf, FILE *out)\n \t  if (len > 6 && ! strcmp (&jcf->classname[len - 6], \".class\"))\n \t    len -= 6;\n \t  /* Turn the class name into a file name.  */\n-\t  name = xmalloc (len + 1);\n+\t  name = XNEWVEC (char, len + 1);\n \t  for (i = 0; i < len; ++i)\n \t    name[i] = jcf->classname[i] == '.' ? '/' : jcf->classname[i];\n \t  name[i] = '\\0';\n@@ -2484,25 +2484,25 @@ main (int argc, char** argv)\n \n \tcase OPT_PREPEND:\n \t  if (prepend_count == 0)\n-\t    prepend_specs = ALLOC (argc * sizeof (char*));\n+\t    prepend_specs = XNEWVEC (char *, argc);\n \t  prepend_specs[prepend_count++] = optarg;\n \t  break;\n \n \tcase OPT_FRIEND:\n \t  if (friend_count == 0)\n-\t    friend_specs = ALLOC (argc * sizeof (char*));\n+\t    friend_specs = XNEWVEC (char *, argc);\n \t  friend_specs[friend_count++] = optarg;\n \t  break;\n \n \tcase OPT_ADD:\n \t  if (add_count == 0)\n-\t    add_specs = ALLOC (argc * sizeof (char*));\n+\t    add_specs = XNEWVEC (char *, argc);\n \t  add_specs[add_count++] = optarg;\n \t  break;\n \n \tcase OPT_APPEND:\n \t  if (append_count == 0)\n-\t    append_specs = ALLOC (argc * sizeof (char*));\n+\t    append_specs = XNEWVEC (char *, argc);\n \t  append_specs[append_count++] = optarg;\n \t  break;\n \n@@ -2608,7 +2608,7 @@ main (int argc, char** argv)\n \t{\n \t  int dir_len = strlen (output_directory);\n \t  int i, classname_length = strlen (classname);\n-\t  current_output_file = ALLOC (dir_len + classname_length + 5);\n+\t  current_output_file = XNEWVEC (char, dir_len + classname_length + 5);\n \t  strcpy (current_output_file, output_directory);\n \t  if (dir_len > 0 && output_directory[dir_len-1] != '/')\n \t    current_output_file[dir_len++] = '/';"}, {"sha": "c8651b6715f78a9cd95f6090c3380c365dfbf154", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -188,11 +188,11 @@ int\n read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n {\n   jcf->filbuf = jcf_unexpected_eof;\n-  jcf->zipd = (void *)zipd;\n+  jcf->zipd = zipd;\n \n   if (zipd->compression_method == Z_NO_COMPRESSION)\n     {\n-      jcf->buffer = ALLOC (zipd->size);\n+      jcf->buffer = XNEWVEC (unsigned char, zipd->size);\n       jcf->buffer_end = jcf->buffer + zipd->size;\n       jcf->read_ptr = jcf->buffer;\n       jcf->read_end = jcf->buffer_end;\n@@ -208,13 +208,13 @@ read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n       d_stream.zfree = (free_func) 0;\n       d_stream.opaque = (voidpf) 0;\n \n-      jcf->buffer = ALLOC (zipd->uncompressed_size);\n+      jcf->buffer = XNEWVEC (unsigned char, zipd->uncompressed_size);\n       d_stream.next_out = jcf->buffer;\n       d_stream.avail_out = zipd->uncompressed_size;\n       jcf->buffer_end = jcf->buffer + zipd->uncompressed_size;\n       jcf->read_ptr = jcf->buffer;\n       jcf->read_end = jcf->buffer_end;\n-      buffer = ALLOC (zipd->size);\n+      buffer = XNEWVEC (char, zipd->size);\n       d_stream.next_in = (unsigned char *) buffer;\n       d_stream.avail_in = zipd->size;\n       if (lseek (zipf->fd, zipd->filestart, 0) < 0\n@@ -225,7 +225,7 @@ read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n       inflateInit2 (&d_stream, -MAX_WBITS);\n       inflate (&d_stream, Z_NO_FLUSH);\n       inflateEnd (&d_stream);\n-      FREE (buffer);\n+      free (buffer);\n     }\n \n   return 0;\n@@ -246,7 +246,7 @@ open_class (const char *filename, JCF *jcf, int fd, const char *dep_name)\n       if (dep_name != NULL)\n \tjcf_dependency_add_file (dep_name, 0);\n       JCF_ZERO (jcf);\n-      jcf->buffer = ALLOC (stat_buf.st_size);\n+      jcf->buffer = XNEWVEC (unsigned char, stat_buf.st_size);\n       jcf->buffer_end = jcf->buffer + stat_buf.st_size;\n       jcf->read_ptr = jcf->buffer;\n       jcf->read_end = jcf->buffer_end;\n@@ -383,8 +383,7 @@ caching_stat (char *filename, struct stat *buf)\n   if (!*slot)\n     {\n       /* We have not already scanned this directory; scan it now.  */\n-      dent = ((memoized_dirlist_entry *) \n-\t      ALLOC (sizeof (memoized_dirlist_entry)));\n+      dent = XNEW (memoized_dirlist_entry);\n       dent->dir = xstrdup (filename);\n       /* Unfortunately, scandir is not fully standardized.  In\n \t particular, the type of the function pointer passed as the"}, {"sha": "dc33ccf25f8eb227717e553ada21eed7253f4f08", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -160,7 +160,7 @@ set_source_filename (JCF *jcf, int index)\n \t  /* Length of prefix, not counting final dot. */\n \t  int i = dot - class_name;\n \t  /* Concatenate current package prefix with new sfname. */\n-\t  char *buf = xmalloc (i + new_len + 2); /* Space for '.' and '\\0'. */\n+\t  char *buf = XNEWVEC (char, i + new_len + 2); /* Space for '.' and '\\0'. */\n \t  strcpy (buf + i + 1, sfname);\n \t  /* Copy package from class_name, replacing '.' by DIR_SEPARATOR.\n \t     Note we start at the end with the final package dot. */\n@@ -1084,7 +1084,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       finput = fopen (main_input_filename, \"r\");\n       if (finput == NULL)\n \tfatal_error (\"can't open %s: %m\", input_filename);\n-      list = xmalloc(avail);\n+      list = XNEWVEC (char, avail);\n       next = list;\n       for (;;)\n \t{\n@@ -1351,7 +1351,7 @@ compute_class_name (struct ZipDirectory *zdir)\n     }\n \n   filename_length -= strlen (\".class\");\n-  class_name = ALLOC (filename_length + 1);\n+  class_name = XNEWVEC (char, filename_length + 1);\n   memcpy (class_name, class_name_in_zip_dir, filename_length);\n   class_name [filename_length] = '\\0';\n \n@@ -1455,7 +1455,7 @@ parse_zip_file_entries (void)\n \t    if (TYPE_SIZE (current_class) != error_mark_node)\n \t      {\n \t\tparse_class_file ();\n-\t\tFREE (current_jcf->buffer); /* No longer necessary */\n+\t\tfree (current_jcf->buffer); /* No longer necessary */\n \t\t/* Note: there is a way to free this buffer right after a\n \t\t   class seen in a zip file has been parsed. The idea is the\n \t\t   set its jcf in such a way that buffer will be reallocated\n@@ -1468,11 +1468,11 @@ parse_zip_file_entries (void)\n \t  {\n \t    char *file_name, *class_name_in_zip_dir, *buffer;\n \t    JCF *jcf;\n-\t    file_name = ALLOC (zdir->filename_length + 1);\n+\t    file_name = XNEWVEC (char, zdir->filename_length + 1);\n \t    class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n \t    strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n \t    file_name[zdir->filename_length] = '\\0';\n-\t    jcf = ALLOC (sizeof (JCF));\n+\t    jcf = XNEW (JCF);\n \t    JCF_ZERO (jcf);\n \t    jcf->read_state  = finput;\n \t    jcf->filbuf      = jcf_filbuf_from_stdio;\n@@ -1484,7 +1484,7 @@ parse_zip_file_entries (void)\n \t    if (read_zip_member (jcf, zdir, localToFile) < 0)\n \t      fatal_error (\"error while reading %s from zip file\", file_name);\n \n-\t    buffer = ALLOC (zdir->filename_length + 1 +\n+\t    buffer = XNEWVEC (char, zdir->filename_length + 1 +\n \t\t\t    (jcf->buffer_end - jcf->buffer));\n \t    strcpy (buffer, file_name);\n \t    /* This is not a typo: we overwrite the trailing \\0 of the\n@@ -1495,8 +1495,8 @@ parse_zip_file_entries (void)\n \t    compile_resource_data (file_name, buffer,\n \t\t\t\t   jcf->buffer_end - jcf->buffer);\n \t    JCF_FINISH (jcf);\n-\t    FREE (jcf);\n-\t    FREE (buffer);\n+\t    free (jcf);\n+\t    free (buffer);\n \t  }\n \t  break;\n \n@@ -1529,7 +1529,7 @@ process_zip_dir (FILE *finput)\n \tcontinue;\n \n       class_name = compute_class_name (zdir);\n-      file_name  = ALLOC (zdir->filename_length+1);\n+      file_name  = XNEWVEC (char, zdir->filename_length+1);\n       jcf = ggc_alloc (sizeof (JCF));\n       JCF_ZERO (jcf);\n "}, {"sha": "65cd80ef30ca66dac7dc5fe5854e7bb953ee5ae7", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -132,7 +132,7 @@ add_entry (struct entry **entp, const char *filename, int is_system)\n   int len;\n   struct entry *n;\n \n-  n = ALLOC (sizeof (struct entry));\n+  n = XNEW (struct entry);\n   n->flags = is_system ? FLAG_SYSTEM : 0;\n   n->next = NULL;\n "}, {"sha": "39d318e0e2883ce4454c7c1651c5235a2a5dfe7e", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1729,7 +1729,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t    unsigned HOST_WIDE_INT delta;\n \t    /* Copy the chain of relocs into a sorted array. */\n \t    struct jcf_relocation **relocs\n-\t      = xmalloc (sw_state.num_cases * sizeof (struct jcf_relocation *));\n+\t      = XNEWVEC (struct jcf_relocation *, sw_state.num_cases);\n \t    /* The relocs arrays is a buffer with a gap.\n \t       The assumption is that cases will normally come in \"runs\". */\n \t    int gap_start = 0;\n@@ -3473,7 +3473,7 @@ make_class_file_name (tree clas)\n       slash = dname + strlen (dname);\n     }\n \n-  r = xmalloc (slash - dname + strlen (cname) + 2);\n+  r = XNEWVEC (char, slash - dname + strlen (cname) + 2);\n   strncpy (r, dname, slash - dname);\n   r[slash - dname] = sep;\n   strcpy (&r[slash - dname + 1], cname);"}, {"sha": "87c7a6e5d45cec3574ec5eba5d1321e7ef1db00a", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -165,9 +165,9 @@ typedef struct JCF GTY(()) {\n \n #define JCF_FINISH(JCF) { \\\n   CPOOL_FINISH(&(JCF)->cpool); \\\n-  if ((JCF)->buffer) FREE ((JCF)->buffer); \\\n-  if ((JCF)->filename) FREE ((char *) (JCF)->filename); \\\n-  if ((JCF)->classname) FREE ((char *) (JCF)->classname); \\\n+  if ((JCF)->buffer) free ((JCF)->buffer); \\\n+  if ((JCF)->filename) free ((char *) (JCF)->filename); \\\n+  if ((JCF)->classname) free ((char *) (JCF)->classname); \\\n   (JCF)->finished = 1; }\n   \n #define CPOOL_INIT(CPOOL) \\"}, {"sha": "63f49ff74b3a0350028e9b6ffd26ad611e27697a", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -90,7 +90,7 @@ find_spec_file (const char *dir)\n   int x;\n   struct stat sb;\n \n-  spec = xmalloc (strlen (dir) + sizeof (SPEC_FILE)\n+  spec = XNEWVEC (char, strlen (dir) + sizeof (SPEC_FILE)\n \t\t  + sizeof (\"-specs=\") + 4);\n   strcpy (spec, \"-specs=\");\n   x = strlen (spec);\n@@ -247,7 +247,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n   argv = *in_argv;\n   added_libraries = *in_added_libraries;\n \n-  args = xcalloc (argc, sizeof (int));\n+  args = XCNEWVEC (int, argc);\n \n   for (i = 1; i < argc; i++)\n     {\n@@ -490,7 +490,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n   \n   num_args += shared_libgcc;\n \n-  arglist = xmalloc ((num_args + 1) * sizeof (char *));\n+  arglist = XNEWVEC (const char *, num_args + 1);\n   j = 0;\n \n   arglist[j++] = argv[0];"}, {"sha": "f435fdeeeab70a2b34b8956e4bbd3791706beda4", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -401,7 +401,7 @@ put_decl_string (const char *str, int len)\n       if (decl_buf == NULL)\n \t{\n \t  decl_buflen = len + 100;\n-\t  decl_buf = xmalloc (decl_buflen);\n+\t  decl_buf = XNEWVEC (char, decl_buflen);\n \t}\n       else\n \t{\n@@ -631,7 +631,7 @@ java_post_options (const char **pfilename)\n \t\terror (\"couldn't determine target name for dependency tracking\");\n \t      else\n \t\t{\n-\t\t  char *buf = xmalloc (dot - filename +\n+\t\t  char *buf = XNEWVEC (char, dot - filename +\n \t\t\t\t       3 + sizeof (TARGET_OBJECT_SUFFIX));\n \t\t  strncpy (buf, filename, dot - filename);\n "}, {"sha": "661f1411bd09ed141b6e98a4fa11c4b511d44882", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -162,7 +162,7 @@ java_sprint_unicode (int c)\n java_lexer *\n java_new_lexer (FILE *finput, const char *encoding)\n {\n-  java_lexer *lex = xmalloc (sizeof (java_lexer));\n+  java_lexer *lex = XNEW (java_lexer);\n   int enc_error = 0;\n \n   lex->finput = finput;"}, {"sha": "20f7680b0fd95420c3d3fbffabe32bdffc9b7418", "filename": "gcc/java/lex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -200,7 +200,7 @@ extern void java_destroy_lexer (java_lexer *);\n /* Special ways to report error on numeric literals  */\n #define JAVA_FLOAT_RANGE_ERROR(m)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    char *msg = xmalloc (100 + strlen (m));\t\t\t\t\\\n+    char *msg = XNEWVEC (char, 100 + strlen (m));\t\t\t\\\n     sprintf (msg, \"Floating point literal exceeds range of `%s'\", (m));\t\\\n     JAVA_RANGE_ERROR(msg);\t\t\t\t\t\t\\\n     free (msg);\t\t\t\t\t\t\t\t\\"}, {"sha": "cedba9eb8e3a9c308cf1e95d66d5719eb69f0c07", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -105,7 +105,7 @@ struct method_declarator {\n };\n #define NEW_METHOD_DECLARATOR(D,N,A)\t\t\t\t\t     \\\n {\t\t\t\t\t\t\t\t\t     \\\n-  (D) = xmalloc (sizeof (struct method_declarator));\t\t\t     \\\n+  (D) = XNEW (struct method_declarator);\t\t\t\t     \\\n   (D)->method_name = (N);\t\t\t\t\t\t     \\\n   (D)->args = (A);\t\t\t\t\t\t\t     \\\n }\n@@ -498,7 +498,7 @@ formal_parameter:\n \t\t  if (bracket_count)\n \t\t    {\n \t\t      int i;\n-\t\t      char *n = xmalloc (bracket_count + 1 + strlen ($$));\n+\t\t      char *n = XNEWVEC (char, bracket_count + 1 + strlen ($$));\n \t\t      for (i = 0; i < bracket_count; ++i)\n \t\t\tn[i] = '[';\n \t\t      strcpy (n + bracket_count, $$);\n@@ -512,7 +512,7 @@ formal_parameter:\n \t\t  if (bracket_count)\n \t\t    {\n \t\t      int i;\n-\t\t      char *n = xmalloc (bracket_count + 1 + strlen ($2));\n+\t\t      char *n = XNEWVEC (char, bracket_count + 1 + strlen ($2));\n \t\t      for (i = 0; i < bracket_count; ++i)\n \t\t\tn[i] = '[';\n \t\t      strcpy (n + bracket_count, $2);\n@@ -1175,18 +1175,18 @@ constant_expression:\n void\n java_push_parser_context (void)\n {\n-  struct parser_ctxt *new = xcalloc (1, sizeof (struct parser_ctxt));\n+  struct parser_ctxt *tmp = XCNEW (struct parser_ctxt);\n \n-  new->next = ctxp;\n-  ctxp = new;\n+  tmp->next = ctxp;\n+  ctxp = tmp;\n }  \n \n static void\n push_class_context (const char *name)\n {\n   struct class_context *ctx;\n \n-  ctx = xmalloc (sizeof (struct class_context));\n+  ctx = XNEW (struct class_context);\n   ctx->name = (char *) name;\n   ctx->next = current_class_context;\n   current_class_context = ctx;"}, {"sha": "fd3d4946c4eab562d1b31813cb82319dcfb64f5b", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -145,7 +145,7 @@ compile_resource_file (const char *name, const char *filename)\n       perror (\"Could not figure length of resource file\");\n       return;\n     }\n-  buffer = xmalloc (strlen (name) + stat_buf.st_size);\n+  buffer = XNEWVEC (char, strlen (name) + stat_buf.st_size);\n   strcpy (buffer, name);\n   read (fd, buffer + strlen (name), stat_buf.st_size);\n   close (fd);"}, {"sha": "c1aff1de785eb70a66967f86e639782b6eb3d0be", "filename": "gcc/java/zextract.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -308,9 +308,8 @@ read_zip_archive (ZipFile *zipf)\n     }\n   zipf->count = makeword((const uch *) &buffer[TOTAL_ENTRIES_CENTRAL_DIR]);\n   zipf->dir_size = makelong((const uch *) &buffer[SIZE_CENTRAL_DIRECTORY]);\n-#define ALLOC xmalloc\n   /* Allocate 1 more to allow appending '\\0' to last filename. */\n-  zipf->central_directory = ALLOC (zipf->dir_size+1);\n+  zipf->central_directory = XNEWVEC (char, zipf->dir_size + 1);\n   if (lseek (zipf->fd, -(zipf->dir_size+ECREC_SIZE+4), SEEK_CUR) < 0)\n     return -2;\n   if (read (zipf->fd, zipf->central_directory, zipf->dir_size) < 0)"}, {"sha": "b2b9b4595b21fa22374366f70a90c9a52d30fa70", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -467,7 +467,7 @@ write_global_declarations (void)\n \n   tree globals = lang_hooks.decls.getdecls ();\n   int len = list_length (globals);\n-  tree *vec = xmalloc (sizeof (tree) * len);\n+  tree *vec = XNEWVEC (tree, len);\n   int i;\n   tree decl;\n "}, {"sha": "57fe432f06bda6e186b66c0447b83ac6eb1abac8", "filename": "gcc/lcm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -107,7 +107,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  qin = qout = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  qin = qout = worklist = XNEWVEC (basic_block, n_basic_blocks);\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n@@ -260,7 +260,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist\n-    = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+    = XNEWVEC (basic_block, n_basic_blocks);\n \n   /* Initialize a mapping from each edge to its index.  */\n   for (i = 0; i < num_edges; i++)\n@@ -485,7 +485,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist = \n-    xmalloc (sizeof (basic_block) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n+    XNEWVEC (basic_block, n_basic_blocks - NUM_FIXED_BLOCKS);\n \n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, last_basic_block);\n@@ -614,7 +614,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n \n   /* Initialize NEARER for each edge and build a mapping from an edge to\n      its index.  */"}, {"sha": "e60f573ecfaaf1b57a05ffc64031bfc116e93a7e", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -368,15 +368,15 @@ local_alloc (void)\n      See the declarations of these variables, above,\n      for what they mean.  */\n \n-  qty = xmalloc (max_qty * sizeof (struct qty));\n-  qty_phys_copy_sugg = xmalloc (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_num_copy_sugg = xmalloc (max_qty * sizeof (short));\n-  qty_phys_sugg = xmalloc (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_num_sugg = xmalloc (max_qty * sizeof (short));\n+  qty = XNEWVEC (struct qty, max_qty);\n+  qty_phys_copy_sugg = XNEWVEC (HARD_REG_SET, max_qty);\n+  qty_phys_num_copy_sugg = XNEWVEC (short, max_qty);\n+  qty_phys_sugg = XNEWVEC (HARD_REG_SET, max_qty);\n+  qty_phys_num_sugg = XNEWVEC (short, max_qty);\n \n-  reg_qty = xmalloc (max_regno * sizeof (int));\n-  reg_offset = xmalloc (max_regno * sizeof (char));\n-  reg_next_in_qty = xmalloc (max_regno * sizeof (int));\n+  reg_qty = XNEWVEC (int, max_regno);\n+  reg_offset = XNEWVEC (char, max_regno);\n+  reg_next_in_qty = XNEWVEC (int, max_regno);\n \n   /* Determine which pseudo-registers can be allocated by local-alloc.\n      In general, these are the registers used only in a single block and\n@@ -798,7 +798,7 @@ update_equiv_regs (void)\n   regset_head cleared_regs;\n   int clear_regnos = 0;\n \n-  reg_equiv = xcalloc (max_regno, sizeof *reg_equiv);\n+  reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n   INIT_REG_SET (&cleared_regs);\n   reg_equiv_init = ggc_alloc_cleared (max_regno * sizeof (rtx));\n   reg_equiv_init_size = max_regno;\n@@ -1306,7 +1306,7 @@ block_alloc (int b)\n \n   /* +2 to leave room for a post_mark_life at the last insn and for\n      the birth of a CLOBBER in the first insn.  */\n-  regs_live_at = xcalloc ((2 * insn_count + 2), sizeof (HARD_REG_SET));\n+  regs_live_at = XCNEWVEC (HARD_REG_SET, 2 * insn_count + 2);\n \n   /* Initialize table of hardware registers currently live.  */\n \n@@ -1560,7 +1560,7 @@ block_alloc (int b)\n      number of suggested registers they need so we allocate those with\n      the most restrictive needs first.  */\n \n-  qty_order = xmalloc (next_qty * sizeof (int));\n+  qty_order = XNEWVEC (int, next_qty);\n   for (i = 0; i < next_qty; i++)\n     qty_order[i] = i;\n "}, {"sha": "d44575b983dd38d50931a6b9c86d8646a2b44113", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -39,7 +39,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n struct loops *\n loop_optimizer_init (FILE *dumpfile)\n {\n-  struct loops *loops = xcalloc (1, sizeof (struct loops));\n+  struct loops *loops = XCNEW (struct loops);\n   edge e;\n   edge_iterator ei;\n   static bool first_time = true;"}, {"sha": "3ecf9d6126d222cc14d382b95391de0ae3e88141", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -425,7 +425,7 @@ find_or_insert_inv (htab_t eq, rtx expr, enum machine_mode mode,\n   if (entry)\n     return entry->inv;\n \n-  entry = xmalloc (sizeof (struct invariant_expr_entry));\n+  entry = XNEW (struct invariant_expr_entry);\n   entry->inv = inv;\n   entry->expr = expr;\n   entry->mode = mode;\n@@ -614,7 +614,7 @@ static struct invariant *\n create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n \t\t      bool always_executed)\n {\n-  struct invariant *inv = xmalloc (sizeof (struct invariant));\n+  struct invariant *inv = XNEW (struct invariant);\n   rtx set = single_set (insn);\n \n   inv->def = def;\n@@ -655,7 +655,7 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n static void\n record_use (struct def *def, rtx *use, rtx insn)\n {\n-  struct use *u = xmalloc (sizeof (struct use));\n+  struct use *u = XNEW (struct use);\n \n   if (GET_CODE (*use) == SUBREG)\n     use = &SUBREG_REG (*use);\n@@ -762,7 +762,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n     }\n \n   if (simple)\n-    def = xcalloc (1, sizeof (struct def));\n+    def = XCNEW (struct def);\n   else\n     def = NULL;\n "}, {"sha": "e234fd93b7993283edaa06a167021e60ed36fe3f", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -783,7 +783,7 @@ get_biv_step (struct df_ref *last_def, rtx reg, rtx *inner_step,\n static void\n record_iv (struct df_ref *def, struct rtx_iv *iv)\n {\n-  struct rtx_iv *recorded_iv = xmalloc (sizeof (struct rtx_iv));\n+  struct rtx_iv *recorded_iv = XNEW (struct rtx_iv);\n \n   *recorded_iv = *iv;\n   DF_REF_IV_SET (def, recorded_iv);\n@@ -807,7 +807,7 @@ analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n static void\n record_biv (rtx def, struct rtx_iv *iv)\n {\n-  struct biv_entry *biv = xmalloc (sizeof (struct biv_entry));\n+  struct biv_entry *biv = XNEW (struct biv_entry);\n   void **slot = htab_find_slot_with_hash (bivs, def, REGNO (def), INSERT);\n \n   biv->regno = REGNO (def);\n@@ -2680,7 +2680,7 @@ get_simple_loop_desc (struct loop *loop)\n   if (desc)\n     return desc;\n \n-  desc = xmalloc (sizeof (struct niter_desc));\n+  desc = XNEW (struct niter_desc);\n   iv_analysis_loop_init (loop);\n   find_simple_exit (loop, desc);\n   loop->aux = desc;"}, {"sha": "d25caf9ba1782b4150b305112259efbe3f1e7903", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -507,7 +507,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       if (desc->noloop_assumptions)\n \tRESET_BIT (wont_exit, 1);\n \n-      remove_edges = xcalloc (npeel, sizeof (edge));\n+      remove_edges = XCNEWVEC (edge, npeel);\n       n_remove_edges = 0;\n \n       if (flag_split_ivs_in_unroller)\n@@ -692,7 +692,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   wont_exit = sbitmap_alloc (max_unroll + 1);\n   sbitmap_ones (wont_exit);\n \n-  remove_edges = xcalloc (max_unroll + exit_mod + 1, sizeof (edge));\n+  remove_edges = XCNEWVEC (edge, max_unroll + exit_mod + 1);\n   n_remove_edges = 0;\n   if (flag_split_ivs_in_unroller \n       || flag_variable_expansion_in_unroller)\n@@ -964,7 +964,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n     opt_info = analyze_insns_in_loop (loop);\n   \n   /* Remember blocks whose dominators will have to be updated.  */\n-  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n   n_dom_bbs = 0;\n \n   body = get_loop_body (loop);\n@@ -1022,7 +1022,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   /* Precondition the loop.  */\n   loop_split_edge_with (loop_preheader_edge (loop), init_code);\n \n-  remove_edges = xcalloc (max_unroll + n_peel + 1, sizeof (edge));\n+  remove_edges = XCNEWVEC (edge, max_unroll + n_peel + 1);\n   n_remove_edges = 0;\n \n   wont_exit = sbitmap_alloc (max_unroll + 2);\n@@ -1613,7 +1613,7 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n     return NULL;\n   \n   /* Record the accumulator to expand.  */\n-  ves = xmalloc (sizeof (struct var_to_expand));\n+  ves = XNEW (struct var_to_expand);\n   ves->insn = insn;\n   ves->var_expansions = VEC_alloc (rtx, heap, 1);\n   ves->reg = copy_rtx (dest);\n@@ -1677,7 +1677,7 @@ analyze_iv_to_split_insn (rtx insn)\n     return NULL;\n \n   /* Record the insn to split.  */\n-  ivts = xmalloc (sizeof (struct iv_to_split));\n+  ivts = XNEW (struct iv_to_split);\n   ivts->insn = insn;\n   ivts->base_var = NULL_RTX;\n   ivts->step = iv.step;\n@@ -1697,7 +1697,7 @@ analyze_insns_in_loop (struct loop *loop)\n {\n   basic_block *body, bb;\n   unsigned i, num_edges = 0;\n-  struct opt_info *opt_info = xcalloc (1, sizeof (struct opt_info));\n+  struct opt_info *opt_info = XCNEW (struct opt_info);\n   rtx insn;\n   struct iv_to_split *ivts = NULL;\n   struct var_to_expand *ves = NULL;"}, {"sha": "9c2801d3c35d99be6fe795cda26ae040d4d28b55", "filename": "gcc/loop.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -841,18 +841,18 @@ loop_optimize (rtx f, FILE *dumpfile, int flags)\n      Leave some space for labels allocated by find_and_verify_loops.  */\n   max_uid_for_loop = get_max_uid () + 1 + max_loop_num * 32;\n \n-  uid_luid = xcalloc (max_uid_for_loop, sizeof (int));\n-  uid_loop = xcalloc (max_uid_for_loop, sizeof (struct loop *));\n+  uid_luid = XCNEWVEC (int, max_uid_for_loop);\n+  uid_loop = XCNEWVEC (struct loop *, max_uid_for_loop);\n \n   /* Allocate storage for array of loops.  */\n-  loops->array = xcalloc (loops->num, sizeof (struct loop));\n+  loops->array = XCNEWVEC (struct loop, loops->num);\n \n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n   find_and_verify_loops (f, loops);\n \n   /* Allocate and initialize auxiliary loop information.  */\n-  loops_info = xcalloc (loops->num, sizeof (struct loop_info));\n+  loops_info = XCNEWVEC (struct loop_info, loops->num);\n   for (i = 0; i < (int) loops->num; i++)\n     loops->array[i].aux = loops_info + i;\n \n@@ -1328,7 +1328,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t      continue;\n \t\t    }\n \n-\t\t  m = xmalloc (sizeof (struct movable));\n+\t\t  m = XNEW (struct movable);\n \t\t  m->next = 0;\n \t\t  m->insn = p;\n \t\t  m->set_src = src;\n@@ -1416,7 +1416,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t  if (regs->array[regno].set_in_loop == 2)\n \t\t    {\n \t\t      struct movable *m;\n-\t\t      m = xmalloc (sizeof (struct movable));\n+\t\t      m = XNEW (struct movable);\n \t\t      m->next = 0;\n \t\t      m->insn = p;\n \t\t      m->set_dest = SET_DEST (set);\n@@ -1853,7 +1853,7 @@ static void\n combine_movables (struct loop_movables *movables, struct loop_regs *regs)\n {\n   struct movable *m;\n-  char *matched_regs = xmalloc (regs->num);\n+  char *matched_regs = XNEWVEC (char, regs->num);\n   enum machine_mode mode;\n \n   /* Regs that are set more than once are not allowed to match\n@@ -2188,8 +2188,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n   /* Map of pseudo-register replacements to handle combining\n      when we move several insns that load the same value\n      into different pseudo-registers.  */\n-  rtx *reg_map = xcalloc (nregs, sizeof (rtx));\n-  char *already_moved = xcalloc (nregs, sizeof (char));\n+  rtx *reg_map = XCNEWVEC (rtx, nregs);\n+  char *already_moved = XCNEWVEC (char, nregs);\n \n   for (m = movables->head; m; m = m->next)\n     {\n@@ -2537,8 +2537,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t}\n \t\t      else if (m->insert_temp)\n \t\t\t{\n-\t\t\t  rtx *reg_map2 = xcalloc (REGNO (newreg),\n-\t\t\t\t\t\t   sizeof(rtx));\n+\t\t\t  rtx *reg_map2 = XCNEWVEC (rtx, REGNO(newreg));\n \t\t\t  reg_map2 [m->regno] = newreg;\n \n \t\t\t  i1 = loop_insn_hoist (loop, copy_rtx (PATTERN (p)));\n@@ -6382,7 +6381,7 @@ strength_reduce (struct loop *loop, int flags)\n   addr_placeholder = gen_reg_rtx (Pmode);\n \n   ivs->n_regs = max_reg_before_loop;\n-  ivs->regs = xcalloc (ivs->n_regs, sizeof (struct iv));\n+  ivs->regs = XCNEWVEC (struct iv, ivs->n_regs);\n \n   /* Find all BIVs in loop.  */\n   loop_bivs_find (loop);\n@@ -6431,7 +6430,7 @@ strength_reduce (struct loop *loop, int flags)\n      Some givs might have been made from biv increments, so look at\n      ivs->reg_iv_type for a suitable size.  */\n   reg_map_size = ivs->n_regs;\n-  reg_map = xcalloc (reg_map_size, sizeof (rtx));\n+  reg_map = XCNEWVEC (rtx, reg_map_size);\n \n   /* Examine each iv class for feasibility of strength reduction/induction\n      variable elimination.  */\n@@ -6649,7 +6648,7 @@ check_insn_for_bivs (struct loop *loop, rtx p, int not_every_iteration,\n \t      /* It is a possible basic induction variable.\n \t         Create and initialize an induction structure for it.  */\n \n-\t      struct induction *v = xmalloc (sizeof (struct induction));\n+\t      struct induction *v = XNEW (struct induction);\n \n \t      record_biv (loop, v, p, dest_reg, inc_val, mult_val, location,\n \t\t\t  not_every_iteration, maybe_multiple);\n@@ -6712,7 +6711,7 @@ check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n \t\t\t\t\t     &add_val, &mult_val, &ext_val,\n \t\t\t\t\t     &last_consec_insn))))\n \t{\n-\t  struct induction *v = xmalloc (sizeof (struct induction));\n+\t  struct induction *v = XNEW (struct induction);\n \n \t  /* If this is a library call, increase benefit.  */\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n@@ -6828,7 +6827,7 @@ find_mem_givs (const struct loop *loop, rtx x, rtx insn,\n \t\t\t\t   GET_MODE (x)))\n \t  {\n \t    /* Found one; record it.  */\n-\t    struct induction *v = xmalloc (sizeof (struct induction));\n+\t    struct induction *v = XNEW (struct induction);\n \n \t    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,\n \t\t\tadd_val, ext_val, benefit, DEST_ADDR,\n@@ -6901,7 +6900,7 @@ record_biv (struct loop *loop, struct induction *v, rtx insn, rtx dest_reg,\n     {\n       /* Create and initialize new iv_class.  */\n \n-      bl = xmalloc (sizeof (struct iv_class));\n+      bl = XNEW (struct iv_class);\n \n       bl->regno = REGNO (dest_reg);\n       bl->biv = 0;\n@@ -9024,8 +9023,8 @@ combine_givs (struct loop_regs *regs, struct iv_class *bl)\n     if (!g1->ignore)\n       giv_array[i++] = g1;\n \n-  stats = xcalloc (giv_count, sizeof (*stats));\n-  can_combine = xcalloc (giv_count, giv_count * sizeof (rtx));\n+  stats = XCNEWVEC (struct combine_givs_stats, giv_count);\n+  can_combine = XCNEWVEC (rtx, giv_count * giv_count);\n \n   for (i = 0; i < giv_count; i++)\n     {\n@@ -10617,7 +10616,7 @@ loop_regs_scan (const struct loop *loop, int extra_size)\n       regs->array[i].single_usage = NULL_RTX;\n     }\n \n-  last_set = xcalloc (regs->num, sizeof (rtx));\n+  last_set = XCNEWVEC (rtx, regs->num);\n \n   /* Scan the loop, recording register usage.  */\n   for (insn = loop->top ? loop->top : loop->start; insn != loop->end;"}, {"sha": "9d7989f4fc9a61d42336d7b2f9627961c3149215", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -104,7 +104,7 @@ static struct seginfo *\n new_seginfo (int mode, rtx insn, int bb, HARD_REG_SET regs_live)\n {\n   struct seginfo *ptr;\n-  ptr = xmalloc (sizeof (struct seginfo));\n+  ptr = XNEW (struct seginfo);\n   ptr->mode = mode;\n   ptr->insn_ptr = insn;\n   ptr->bbnum = bb;\n@@ -415,7 +415,7 @@ optimize_mode_switching (FILE *file)\n \tentry_exit_extra = 3;\n #endif\n \tbb_info[n_entities]\n-\t  = xcalloc (last_basic_block + entry_exit_extra, sizeof **bb_info);\n+\t  = XCNEWVEC (struct bb_info, last_basic_block);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];"}, {"sha": "f76bcfdab441329571af5da21933519bc728a826", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -900,7 +900,7 @@ canon_loop (struct loop *loop)\n static struct loops *\n build_loops_structure (FILE *dumpfile)\n {\n-  struct loops *loops = xcalloc (1, sizeof (struct loops));\n+  struct loops *loops = XCNEW (struct loops);\n \n   /* Find the loops.  */\n \n@@ -984,7 +984,7 @@ sms_schedule (FILE *dump_file)\n \n   /* Allocate memory to hold the DDG array one entry for each loop.\n      We use loop->num as index into this array.  */\n-  g_arr = xcalloc (loops->num, sizeof (ddg_ptr));\n+  g_arr = XCNEWVEC (ddg_ptr, loops->num);\n \n \n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n@@ -1172,7 +1172,7 @@ sms_schedule (FILE *dump_file)\n           fprintf (stats_file, \"\\n\");\n         }\n \n-      node_order = (int *) xmalloc (sizeof (int) * g->num_nodes);\n+      node_order = XNEWVEC (int, g->num_nodes);\n \n       mii = 1; /* Need to pass some estimate of mii.  */\n       rec_mii = sms_order_nodes (g, mii, node_order);\n@@ -2037,8 +2037,7 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n static partial_schedule_ptr\n create_partial_schedule (int ii, ddg_ptr g, int history)\n {\n-  partial_schedule_ptr ps = (partial_schedule_ptr)\n-\t\t\t     xmalloc (sizeof (struct partial_schedule));\n+  partial_schedule_ptr ps = XNEW (struct partial_schedule);\n   ps->rows = (ps_insn_ptr *) xcalloc (ii, sizeof (ps_insn_ptr));\n   ps->ii = ii;\n   ps->history = history;\n@@ -2125,7 +2124,7 @@ print_partial_schedule (partial_schedule_ptr ps, FILE *dump)\n static ps_insn_ptr\n create_ps_insn (ddg_node_ptr node, int rest_count, int cycle)\n {\n-  ps_insn_ptr ps_i = xmalloc (sizeof (struct ps_insn));\n+  ps_insn_ptr ps_i = XNEW (struct ps_insn);\n \n   ps_i->node = node;\n   ps_i->next_in_row = NULL;"}, {"sha": "463ceed5db6304a9db924986ff48dfda62e1afcc", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -9048,7 +9048,7 @@ objc_demangle (const char *mangled)\n       (mangled[1] == 'i' || mangled[1] == 'c') &&\n       mangled[2] == '_')\n     {\n-      cp = demangled = xmalloc(strlen(mangled) + 2);\n+      cp = demangled = XNEWVEC (char, strlen(mangled) + 2);\n       if (mangled[1] == 'i')\n \t*cp++ = '-';            /* for instance method */\n       else\n@@ -9106,7 +9106,7 @@ init_objc (void)\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n \n-  errbuf = (char *) xmalloc (1024 * 10);\n+  errbuf = XNEWVEC (char, 1024 * 10);\n   hash_init ();\n   synth_module_prologue ();\n }"}, {"sha": "1218e99326d554d4db531d9033b572f95c4b63a9", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -232,7 +232,7 @@ write_langs (unsigned int mask)\n     if (mask & (1U << n))\n       len += strlen (lang_name) + 1;\n \n-  result = xmalloc (len);\n+  result = XNEWVEC (char, len);\n   len = 0;\n   for (n = 0; (lang_name = lang_names[n]) != 0; n++)\n     if (mask & (1U << n))\n@@ -288,7 +288,7 @@ handle_option (const char **argv, unsigned int lang_mask)\n       /* Drop the \"no-\" from negative switches.  */\n       size_t len = strlen (opt) - 3;\n \n-      dup = xmalloc (len + 1);\n+      dup = XNEWVEC (char, len + 1);\n       dup[0] = '-';\n       dup[1] = opt[1];\n       memcpy (dup + 2, opt + 5, len - 2 + 1);\n@@ -765,7 +765,7 @@ common_handle_option (size_t scode, const char *arg, int value,\n       {\n \tchar *new_option;\n \tint option_index;\n-\tnew_option = (char *) xmalloc (strlen (arg) + 2);\n+\tnew_option = XNEWVEC (char, strlen (arg) + 2);\n \tnew_option[0] = 'W';\n \tstrcpy (new_option+1, arg);\n \toption_index = find_opt (new_option, lang_mask);"}, {"sha": "faa4a4bfc1773f7e1dbff34b7a4c92d660b8f7f5", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -224,7 +224,7 @@ alloc_mem (void)\n   rtx insn;\n \n   /* Find the largest UID and create a mapping from UIDs to CUIDs.  */\n-  uid_cuid = xcalloc (get_max_uid () + 1, sizeof (int));\n+  uid_cuid = XCNEWVEC (int, get_max_uid () + 1);\n   i = 1;\n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)"}, {"sha": "fe2c7c832cd00b504b323a2ccaf8f7723a9560ce", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -731,7 +731,7 @@ reload_combine (void)\n      destination.  */\n   min_labelno = get_first_label_num ();\n   n_labels = max_label_num () - min_labelno;\n-  label_live = xmalloc (n_labels * sizeof (HARD_REG_SET));\n+  label_live = XNEWVEC (HARD_REG_SET, n_labels);\n   CLEAR_HARD_REG_SET (ever_live_at_start);\n \n   FOR_EACH_BB_REVERSE (bb)"}, {"sha": "07053ac843a7c4199c09f7104f4e80e99743a3e0", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1270,7 +1270,7 @@ tree_bb_level_predictions (void)\n   basic_block bb;\n   int *heads;\n \n-  heads = xmalloc (sizeof (int) * last_basic_block);\n+  heads = XNEWVEC (int, last_basic_block);\n   memset (heads, ENTRY_BLOCK, sizeof (int) * last_basic_block);\n   heads[ENTRY_BLOCK_PTR->next_bb->index] = last_basic_block;\n "}, {"sha": "82df53b01aebbf62ee426d01af54bc0849f4b6de", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -677,7 +677,7 @@ void\n pp_construct (pretty_printer *pp, const char *prefix, int maximum_length)\n {\n   memset (pp, 0, sizeof (pretty_printer));\n-  pp->buffer = xcalloc (1, sizeof (output_buffer));\n+  pp->buffer = XCNEW (output_buffer);\n   obstack_init (&pp->buffer->chunk_obstack);\n   obstack_init (&pp->buffer->formatted_obstack);\n   pp->buffer->obstack = &pp->buffer->formatted_obstack;"}, {"sha": "dad7e59e00225abe962c7501dae668da3413e37d", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -50,7 +50,7 @@ static struct bucket **table;\n void\n debug_tree (tree node)\n {\n-  table = xcalloc (HASH_SIZE, sizeof (struct bucket *));\n+  table = XCNEWVEC (struct bucket *, HASH_SIZE);\n   print_node (stderr, \"\", node, 0);\n   free (table);\n   table = 0;\n@@ -209,7 +209,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       }\n \n   /* Add this node to the table.  */\n-  b = xmalloc (sizeof (struct bucket));\n+  b = XNEW (struct bucket);\n   b->node = node;\n   b->next = table[hash];\n   table[hash] = b;"}, {"sha": "1b852c3f691ce0051eccdc3f9ca9bba73cbf2927", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -693,8 +693,7 @@ compute_value_histograms (histogram_values values)\n \n       hist->hvalue.next = ann->histograms;\n       ann->histograms = hist;\n-      hist->hvalue.counters = \n-\t    xmalloc (sizeof (gcov_type) * hist->n_counters);\n+      hist->hvalue.counters =  XNEWVEC (gcov_type, hist->n_counters);\n       for (j = 0; j < hist->n_counters; j++)\n \thist->hvalue.counters[j] = aact_count[j];\n     }"}, {"sha": "8ab9aae32ccaa72fbb1183a558c9f435b6951986", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -2926,7 +2926,7 @@ convert_regs_2 (FILE *file, basic_block block)\n      is only processed after all its predecessors.  The number of predecessors\n      of every block has already been computed.  */ \n \n-  stack = xmalloc (sizeof (*stack) * n_basic_blocks);\n+  stack = XNEWVEC (basic_block, n_basic_blocks);\n   sp = stack;\n \n   *sp++ = block;"}, {"sha": "09d8ed92d870625a08ae9288a965c8b985bfef47", "filename": "gcc/regclass.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1190,11 +1190,11 @@ regclass (rtx f, int nregs, FILE *dump)\n \n   init_recog ();\n \n-  costs = xmalloc (nregs * sizeof (struct costs));\n+  costs = XNEWVEC (struct costs, nregs);\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n-  in_inc_dec = xmalloc (nregs);\n+  in_inc_dec = XNEWVEC (char, nregs);\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n@@ -2143,8 +2143,7 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \t{\n \t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n \t  renumber = xmalloc (size_renumber);\n-\t  reg_pref_buffer = xmalloc (regno_allocated\n-\t\t\t\t     * sizeof (struct reg_pref));\n+\t  reg_pref_buffer = XNEWVEC (struct reg_pref, regno_allocated);\n \t}\n       else\n \t{\n@@ -2155,14 +2154,13 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \t      free ((char *) renumber);\n \t      free ((char *) reg_pref);\n \t      renumber = xmalloc (size_renumber);\n-\t      reg_pref_buffer = xmalloc (regno_allocated\n-\t\t\t\t\t * sizeof (struct reg_pref));\n+\t      reg_pref_buffer = XNEWVEC (struct reg_pref, regno_allocated);\n \t    }\n \n \t  else\n \t    {\n \t      renumber = xrealloc (renumber, size_renumber);\n-\t      reg_pref_buffer = xrealloc (reg_pref_buffer,\n+\t      reg_pref_buffer = (struct reg_pref *) xrealloc (reg_pref_buffer,\n \t\t\t\t\t  regno_allocated\n \t\t\t\t\t  * sizeof (struct reg_pref));\n \t    }\n@@ -2601,7 +2599,7 @@ record_subregs_of_mode (rtx subreg)\n   node = *slot;\n   if (node == NULL)\n     {\n-      node = xcalloc (1, sizeof (*node));\n+      node = XCNEW (struct subregs_of_mode_node);\n       node->block = regno & -8;\n       *slot = node;\n     }"}, {"sha": "0bda55b09a569f6cc140d5bf03d00c754bc4342a", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1057,10 +1057,10 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n      can suppress some optimizations in those zones.  */\n   mark_flags_life_zones (discover_flags_reg ());\n \n-  regno_src_regno = xmalloc (sizeof *regno_src_regno * nregs);\n+  regno_src_regno = XNEWVEC (int, nregs);\n   for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n \n-  regmove_bb_head = xmalloc (sizeof (int) * (old_max_uid + 1));\n+  regmove_bb_head = XNEWVEC (int, old_max_uid + 1);\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n   FOR_EACH_BB (bb)\n     regmove_bb_head[INSN_UID (BB_HEAD (bb))] = bb->index;\n@@ -2197,7 +2197,7 @@ record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n {\n   struct csa_memlist *ml;\n \n-  ml = xmalloc (sizeof (*ml));\n+  ml = XNEW (struct csa_memlist);\n \n   if (XEXP (*mem, 0) == stack_pointer_rtx)\n     ml->sp_offset = 0;"}, {"sha": "8d2a286ccb72d7ce86ad50f3ed03a7c8be2d9f5e", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1797,7 +1797,7 @@ copyprop_hardreg_forward (void)\n \n   need_refresh = false;\n \n-  all_vd = xmalloc (sizeof (struct value_data) * last_basic_block);\n+  all_vd = XNEWVEC (struct value_data, last_basic_block);\n \n   visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (visited);"}, {"sha": "a50dd399f82dee2922050efce0655baa574ea8ce", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -699,15 +699,15 @@ reload (rtx first, int global)\n      Record memory equivalents in reg_mem_equiv so they can\n      be substituted eventually by altering the REG-rtx's.  */\n \n-  reg_equiv_constant = xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_invariant = xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_mem = xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_address = xcalloc (max_regno, sizeof (rtx));\n-  reg_max_ref_width = xcalloc (max_regno, sizeof (int));\n-  reg_old_renumber = xcalloc (max_regno, sizeof (short));\n+  reg_equiv_constant = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_invariant = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_mem = XCNEWVEC (rtx, max_regno);\n+  reg_equiv_address = XCNEWVEC (rtx, max_regno);\n+  reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n+  reg_old_renumber = XCNEWVEC (short, max_regno);\n   memcpy (reg_old_renumber, reg_renumber, max_regno * sizeof (short));\n-  pseudo_forbidden_regs = xmalloc (max_regno * sizeof (HARD_REG_SET));\n-  pseudo_previous_regs = xcalloc (max_regno, sizeof (HARD_REG_SET));\n+  pseudo_forbidden_regs = XNEWVEC (HARD_REG_SET, max_regno);\n+  pseudo_previous_regs = XCNEWVEC (HARD_REG_SET, max_regno);\n \n   CLEAR_HARD_REG_SET (bad_spill_regs_global);\n \n@@ -817,8 +817,8 @@ reload (rtx first, int global)\n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause a core dump.  */\n-  offsets_known_at = xmalloc (num_labels);\n-  offsets_at = xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n+  offsets_known_at = XNEWVEC (char, num_labels);\n+  offsets_at = (HOST_WIDE_INT (*)[NUM_ELIMINABLE_REGS]) xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n \n   /* Alter each pseudo-reg rtx to contain its hard reg number.\n      Assign stack slots to the pseudos that lack hard regs or equivalents.\n@@ -3878,8 +3878,8 @@ reload_as_needed (int live_known)\n \n   memset (spill_reg_rtx, 0, sizeof spill_reg_rtx);\n   memset (spill_reg_store, 0, sizeof spill_reg_store);\n-  reg_last_reload_reg = xcalloc (max_regno, sizeof (rtx));\n-  reg_has_output_reload = xmalloc (max_regno);\n+  reg_last_reload_reg = XCNEWVEC (rtx, max_regno);\n+  reg_has_output_reload = XNEWVEC (char, max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n   CLEAR_HARD_REG_SET (reg_reloaded_call_part_clobbered);\n "}, {"sha": "cd4eb10628ca4fbd7dba8ecf42457a260dc74808", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -949,7 +949,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t{\n \t  /* Allocate a place to put our results and chain it into the\n \t     hash table.  */\n-\t  tinfo = xmalloc (sizeof (struct target_info));\n+\t  tinfo = XNEW (struct target_info);\n \t  tinfo->uid = INSN_UID (target);\n \t  tinfo->block = b;\n \t  tinfo->next\n@@ -1226,8 +1226,8 @@ init_resource_info (rtx epilogue_insn)\n     }\n \n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n-  target_hash_table = xcalloc (TARGET_HASH_PRIME, sizeof (struct target_info *));\n-  bb_ticks = xcalloc (last_basic_block, sizeof (int));\n+  target_hash_table = XCNEWVEC (struct target_info *, TARGET_HASH_PRIME);\n+  bb_ticks = XCNEWVEC (int, last_basic_block);\n }\n \f\n /* Free up the resources allocated to mark_target_live_regs ().  This"}, {"sha": "4831cff8ddfe4222384bbbed502167025f8c2265", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1492,7 +1492,7 @@ init_deps (struct deps *deps)\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n   deps->max_reg = max_reg;\n-  deps->reg_last = xcalloc (max_reg, sizeof (struct deps_reg));\n+  deps->reg_last = XCNEWVEC (struct deps_reg, max_reg);\n   INIT_REG_SET (&deps->reg_last_in_use);\n   INIT_REG_SET (&deps->reg_conditional_sets);\n \n@@ -1558,11 +1558,11 @@ init_dependency_caches (int luid)\n   if (luid / n_basic_blocks > 100 * 5)\n     {\n       int i;\n-      true_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n-      anti_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n-      output_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+      true_dependency_cache = XNEWVEC (bitmap_head, luid);\n+      anti_dependency_cache = XNEWVEC (bitmap_head, luid);\n+      output_dependency_cache = XNEWVEC (bitmap_head, luid);\n #ifdef ENABLE_CHECKING\n-      forward_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+      forward_dependency_cache = XNEWVEC (bitmap_head, luid);\n #endif\n       for (i = 0; i < luid; i++)\n \t{"}, {"sha": "fdb34ed2eb3b57a4b94ff0773397aae738c4a7a0", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -512,9 +512,9 @@ find_rgns (void)\n      STACK, SP and DFS_NR are only used during the first traversal.  */\n \n   /* Allocate and initialize variables for the first traversal.  */\n-  max_hdr = xmalloc (last_basic_block * sizeof (int));\n-  dfs_nr = xcalloc (last_basic_block, sizeof (int));\n-  stack = xmalloc (n_edges * sizeof (edge_iterator));\n+  max_hdr = XNEWVEC (int, last_basic_block);\n+  dfs_nr = XCNEWVEC (int, last_basic_block);\n+  stack = XNEWVEC (edge_iterator, n_edges);\n \n   inner = sbitmap_alloc (last_basic_block);\n   sbitmap_ones (inner);\n@@ -658,7 +658,7 @@ find_rgns (void)\n       /* Second traversal:find reducible inner loops and topologically sort\n \t block of each region.  */\n \n-      queue = xmalloc (n_basic_blocks * sizeof (int));\n+      queue = XNEWVEC (int, n_basic_blocks);\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n \t loops to consider at this point.  */\n@@ -1585,18 +1585,18 @@ init_ready_list (struct ready_list *ready)\n   /* Prepare current target block info.  */\n   if (current_nr_blocks > 1)\n     {\n-      candidate_table = xmalloc (current_nr_blocks * sizeof (candidate));\n+      candidate_table = XNEWVEC (candidate, current_nr_blocks);\n \n       bblst_last = 0;\n       /* bblst_table holds split blocks and update blocks for each block after\n \t the current one in the region.  split blocks and update blocks are\n \t the TO blocks of region edges, so there can be at most rgn_nr_edges\n \t of them.  */\n       bblst_size = (current_nr_blocks - target_bb) * rgn_nr_edges;\n-      bblst_table = xmalloc (bblst_size * sizeof (basic_block));\n+      bblst_table = XNEWVEC (basic_block, bblst_size);\n \n       edgelst_last = 0;\n-      edgelst_table = xmalloc (rgn_nr_edges * sizeof (edge));\n+      edgelst_table = XNEWVEC (edge, rgn_nr_edges);\n \n       compute_trg_info (target_bb);\n     }\n@@ -2275,7 +2275,7 @@ schedule_region (int rgn)\n   init_deps_global ();\n \n   /* Initializations for region data dependence analysis.  */\n-  bb_deps = xmalloc (sizeof (struct deps) * current_nr_blocks);\n+  bb_deps = XNEWVEC (struct deps, current_nr_blocks);\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     init_deps (bb_deps + bb);\n \n@@ -2308,7 +2308,7 @@ schedule_region (int rgn)\n   /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n     {\n-      prob = xmalloc ((current_nr_blocks) * sizeof (float));\n+      prob = XNEWVEC (float, current_nr_blocks);\n \n       dom = sbitmap_vector_alloc (current_nr_blocks, current_nr_blocks);\n       sbitmap_vector_zero (dom, current_nr_blocks);\n@@ -2323,7 +2323,7 @@ schedule_region (int rgn)\n \t    SET_EDGE_TO_BIT (e, rgn_nr_edges++);\n \t}\n \n-      rgn_edges = xmalloc (rgn_nr_edges * sizeof (edge));\n+      rgn_edges = XNEWVEC (edge, rgn_nr_edges);\n       rgn_nr_edges = 0;\n       FOR_EACH_BB (block)\n \t{\n@@ -2460,10 +2460,10 @@ init_regions (void)\n   int rgn;\n \n   nr_regions = 0;\n-  rgn_table = xmalloc ((n_basic_blocks) * sizeof (region));\n-  rgn_bb_table = xmalloc ((n_basic_blocks) * sizeof (int));\n-  block_to_bb = xmalloc ((last_basic_block) * sizeof (int));\n-  containing_rgn = xmalloc ((last_basic_block) * sizeof (int));\n+  rgn_table = XNEWVEC (region, n_basic_blocks);\n+  rgn_bb_table = XNEWVEC (int, n_basic_blocks);\n+  block_to_bb = XNEWVEC (int, last_basic_block);\n+  containing_rgn = XNEWVEC (int, last_basic_block);\n \n   /* Compute regions for scheduling.  */\n   if (reload_completed\n@@ -2493,7 +2493,7 @@ init_regions (void)\n   if (CHECK_DEAD_NOTES)\n     {\n       blocks = sbitmap_alloc (last_basic_block);\n-      deaths_in_region = xmalloc (sizeof (int) * nr_regions);\n+      deaths_in_region = XNEWVEC (int, nr_regions);\n       /* Remove all death notes from the subroutine.  */\n       for (rgn = 0; rgn < nr_regions; rgn++)\n \t{"}, {"sha": "09273841ff5e58e57f72e328bdd8a439175eacbd", "filename": "gcc/timevar.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -293,7 +293,7 @@ timevar_push_1 (timevar_id_t timevar)\n       unused_stack_instances = unused_stack_instances->next;\n     }\n   else\n-    context = xmalloc (sizeof (struct timevar_stack_def));\n+    context = XNEW (struct timevar_stack_def);\n \n   /* Fill it in and put it on the stack.  */\n   context->timevar = tv;"}, {"sha": "1689ddbe24229037d4017bd5c5818cec67c793a0", "filename": "gcc/tlink.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -125,7 +125,7 @@ symbol_hash_lookup (const char *string, int create)\n   if (*e == NULL)\n     {\n       struct symbol_hash_entry *v;\n-      *e = v = xcalloc (1, sizeof (*v));\n+      *e = v = XCNEW (struct symbol_hash_entry);\n       v->key = xstrdup (string);\n     }\n   return *e;\n@@ -145,7 +145,7 @@ file_hash_lookup (const char *string)\n   if (*e == NULL)\n     {\n       struct file_hash_entry *v;\n-      *e = v = xcalloc (1, sizeof (*v));\n+      *e = v = XCNEW (struct file_hash_entry);\n       v->key = xstrdup (string);\n     }\n   return *e;\n@@ -167,7 +167,7 @@ demangled_hash_lookup (const char *string, int create)\n   if (*e == NULL)\n     {\n       struct demangled_hash_entry *v;\n-      *e = v = xcalloc (1, sizeof (*v));\n+      *e = v = XCNEW (struct demangled_hash_entry);\n       v->key = xstrdup (string);\n     }\n   return *e;"}, {"sha": "e61f8202fd6e221d7a6353d385f65c129ea2adef", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -199,9 +199,9 @@ find_trace (basic_block bb, basic_block *trace)\n static void\n tail_duplicate (void)\n {\n-  fibnode_t *blocks = xcalloc (last_basic_block, sizeof (fibnode_t));\n-  basic_block *trace = xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  int *counts = xmalloc (sizeof (int) * last_basic_block);\n+  fibnode_t *blocks = XCNEWVEC (fibnode_t, last_basic_block);\n+  basic_block *trace = XNEWVEC (basic_block, n_basic_blocks);\n+  int *counts = XNEWVEC (int, last_basic_block);\n   int ninsns = 0, nduplicated = 0;\n   gcov_type weighted_insns = 0, traced_insns = 0;\n   fibheap_t heap = fibheap_new ();"}, {"sha": "4619d1dbad09d1abaaeb9ab5db3330bad4235340", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -470,7 +470,7 @@ cleanup_forwarder_blocks (void)\n {\n   basic_block bb;\n   bool changed = false;\n-  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks);\n   basic_block *current = worklist;\n \n   FOR_EACH_BB (bb)\n@@ -711,7 +711,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n static void\n merge_phi_nodes (void)\n {\n-  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks);\n   basic_block *current = worklist;\n   basic_block bb;\n "}, {"sha": "d37a82e701c0961a043fcb36b80488f7b4be7978", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -79,7 +79,7 @@ cvc_insert (unsigned int uid, tree to)\n   struct int_tree_map *h;\n   void **loc;\n \n-  h = xmalloc (sizeof (struct int_tree_map));\n+  h = XNEW (struct int_tree_map);\n   h->uid = uid;\n   h->to = to;\n   loc = htab_find_slot_with_hash (complex_variable_components, h,"}, {"sha": "6f34adacd8afe492941e94f32bdd2326d9017198", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -882,7 +882,7 @@ analyze_array (tree stmt, tree ref, bool is_read)\n       fprintf (dump_file, \")\\n\");\n     }\n   \n-  res = xmalloc (sizeof (struct data_reference));\n+  res = XNEW (struct data_reference);\n   \n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n@@ -1004,7 +1004,7 @@ init_data_ref (tree stmt,\n       fprintf (dump_file, \")\\n\");\n     }\n   \n-  res = xmalloc (sizeof (struct data_reference));\n+  res = XNEW (struct data_reference);\n   \n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n@@ -1976,7 +1976,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n   bool differ_p;\n   unsigned int i;  \n   \n-  res = xmalloc (sizeof (struct data_dependence_relation));\n+  res = XNEW (struct data_dependence_relation);\n   DDR_A (res) = a;\n   DDR_B (res) = b;\n \n@@ -2020,7 +2020,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n     {\n       struct subscript *subscript;\n \t  \n-      subscript = xmalloc (sizeof (struct subscript));\n+      subscript = XNEW (struct subscript);\n       SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n       SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n@@ -3745,7 +3745,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t  struct data_reference *res;\n \n \t\tinsert_dont_know_node:;\n-\t\t  res = xmalloc (sizeof (struct data_reference));\n+\t\t  res = XNEW (struct data_reference);\n \t\t  DR_STMT (res) = NULL_TREE;\n \t\t  DR_REF (res) = NULL_TREE;\n \t\t  DR_BASE_OBJECT (res) = NULL;"}, {"sha": "89fd71ca71207ed4dfaee270f4a9f96990c796b1", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -60,10 +60,10 @@ queue (dump_info_p di, tree t, int flags)\n       di->free_list = dq->next;\n     }\n   else\n-    dq = xmalloc (sizeof (struct dump_queue));\n+    dq = XNEW (struct dump_queue);\n \n   /* Create a new entry in the splay-tree.  */\n-  dni = xmalloc (sizeof (struct dump_node_info));\n+  dni = XNEW (struct dump_node_info);\n   dni->index = index;\n   dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n   dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t,"}, {"sha": "8c41e9454bc215d3c7672b9663ed587bffe5d42b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1038,7 +1038,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   gcc_assert (loop->num_nodes);\n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n-  blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  blocks = XCNEWVEC (basic_block, loop->num_nodes);\n   visited = BITMAP_ALLOC (NULL);\n \n   blocks_in_bfs_order = get_loop_body_in_bfs_order (loop);"}, {"sha": "fd7e427ff7d4003e84cba40622118e7e1cc67a39", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -386,8 +386,8 @@ compute_builtin_object_size (tree ptr, int object_size_type)\n \t\t E.g. p = &buf[0]; while (cond) p = p + 4;  */\n \t      if (object_size_type & 2)\n \t\t{\n-\t\t  osi.depths = xcalloc (num_ssa_names, sizeof (unsigned int));\n-\t\t  osi.stack = xmalloc (num_ssa_names * sizeof (unsigned int));\n+\t\t  osi.depths = XCNEWVEC (unsigned int, num_ssa_names);\n+\t\t  osi.stack = XNEWVEC (unsigned int, num_ssa_names);\n \t\t  osi.tos = osi.stack;\n \t\t  osi.pass = 1;\n \t\t  /* collect_object_sizes_for is changing\n@@ -956,8 +956,7 @@ init_object_sizes (void)\n \n   for (object_size_type = 0; object_size_type <= 3; object_size_type++)\n     {\n-      object_sizes[object_size_type]\n-\t= xmalloc (num_ssa_names * sizeof (HOST_WIDE_INT));\n+      object_sizes[object_size_type] = XNEWVEC (unsigned HOST_WIDE_INT, num_ssa_names);\n       computed[object_size_type] = BITMAP_ALLOC (NULL);\n     }\n "}, {"sha": "7d8870cfed4094512e76ef4afe4839ffb4dce3a9", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -144,8 +144,8 @@ copy_loop_headers (void)\n   verify_loop_structure (loops);\n #endif\n \n-  bbs = xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  copied_bbs = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks);\n+  copied_bbs = XNEWVEC (basic_block, n_basic_blocks);\n   bbs_size = n_basic_blocks;\n \n   for (i = 1; i < loops->num; i++)"}, {"sha": "4dcda9f178a2c4a7384c7a75bea546e8bb6e2b36", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -401,7 +401,7 @@ add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n       && def_bb->loop_father == loop)\n     data->cost += LIM_DATA (def_stmt)->cost;\n \n-  dep = xmalloc (sizeof (struct depend));\n+  dep = XNEW (struct depend);\n   dep->stmt = def_stmt;\n   dep->next = data->depends;\n   data->depends = dep;\n@@ -887,7 +887,7 @@ force_move_till (tree ref, tree *index, void *data)\n static void\n record_mem_ref_loc (struct mem_ref_loc **mem_refs, tree stmt, tree *ref)\n {\n-  struct mem_ref_loc *aref = xmalloc (sizeof (struct mem_ref_loc));\n+  struct mem_ref_loc *aref = XNEW (struct mem_ref_loc);\n \n   aref->stmt = stmt;\n   aref->ref = ref;\n@@ -1258,7 +1258,7 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n     ref = *slot;\n   else\n     {\n-      ref = xmalloc (sizeof (struct mem_ref));\n+      ref = XNEW (struct mem_ref);\n       ref->mem = *mem;\n       ref->hash = hash;\n       ref->locs = NULL;"}, {"sha": "0ad2069983f45b9d829dae146fc3a90049be4875", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -224,7 +224,7 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n   if (n_unroll)\n     {\n       sbitmap wont_exit;\n-      edge *edges_to_remove = xmalloc (sizeof (edge *) * n_unroll);\n+      edge *edges_to_remove = XNEWVEC (edge, n_unroll);\n       unsigned int n_to_remove = 0;\n \n       old_cond = COND_EXPR_COND (cond);"}, {"sha": "7e1363e9aef791a3a6eea884b116b4d4b688b26b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -749,8 +749,7 @@ tree_ssa_iv_optimize_init (struct loops *loops, struct ivopts_data *data)\n   unsigned i;\n \n   data->version_info_size = 2 * num_ssa_names;\n-  data->version_info = xcalloc (data->version_info_size,\n-\t\t\t\tsizeof (struct version_info));\n+  data->version_info = XCNEWVEC (struct version_info, data->version_info_size);\n   data->relevant = BITMAP_ALLOC (NULL);\n   data->important_candidates = BITMAP_ALLOC (NULL);\n   data->max_inv_id = 0;\n@@ -825,7 +824,7 @@ determine_base_object (tree expr)\n static struct iv *\n alloc_iv (tree base, tree step)\n {\n-  struct iv *iv = xcalloc (1, sizeof (struct iv));\n+  struct iv *iv = XCNEW (struct iv);\n \n   if (step && integer_zerop (step))\n     step = NULL_TREE;\n@@ -1160,7 +1159,7 @@ static struct iv_use *\n record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n \t    tree stmt, enum use_type use_type)\n {\n-  struct iv_use *use = xcalloc (1, sizeof (struct iv_use));\n+  struct iv_use *use = XCNEW (struct iv_use);\n \n   use->id = n_iv_uses (data);\n   use->type = use_type;\n@@ -1246,7 +1245,7 @@ find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n     }\n   iv->have_use_for = true;\n \n-  civ = xmalloc (sizeof (struct iv));\n+  civ = XNEW (struct iv);\n   *civ = *iv;\n \n   stmt = SSA_NAME_DEF_STMT (op);\n@@ -1333,7 +1332,7 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n       return;\n     }\n \n-  civ = xmalloc (sizeof (struct iv));\n+  civ = XNEW (struct iv);\n   *civ = zero_p (iv0->step) ? *iv1: *iv0;\n   record_use (data, cond_p, civ, stmt, USE_COMPARE);\n }\n@@ -2032,7 +2031,7 @@ add_candidate_1 (struct ivopts_data *data,\n \n   if (i == n_iv_cands (data))\n     {\n-      cand = xcalloc (1, sizeof (struct iv_cand));\n+      cand = XCNEW (struct iv_cand);\n       cand->id = i;\n \n       if (!base && !step)\n@@ -2350,7 +2349,7 @@ alloc_use_cost_map (struct ivopts_data *data)\n \t}\n \n       use->n_map_members = size;\n-      use->cost_map = xcalloc (size, sizeof (struct cost_pair));\n+      use->cost_map = XCNEWVEC (struct cost_pair, size);\n     }\n }\n \n@@ -3231,7 +3230,7 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n   if (*cached)\n     return (*cached)->cost;\n \n-  *cached = xmalloc (sizeof (struct mbc_entry));\n+  *cached = XNEW (struct mbc_entry);\n   (*cached)->mode = mode;\n   (*cached)->cst = cst;\n \n@@ -4670,7 +4669,7 @@ static struct iv_ca_delta *\n iv_ca_delta_add (struct iv_use *use, struct cost_pair *old_cp,\n \t\t struct cost_pair *new_cp, struct iv_ca_delta *next_change)\n {\n-  struct iv_ca_delta *change = xmalloc (sizeof (struct iv_ca_delta));\n+  struct iv_ca_delta *change = XNEW (struct iv_ca_delta);\n \n   change->use = use;\n   change->old_cp = old_cp;\n@@ -4793,18 +4792,18 @@ iv_ca_delta_free (struct iv_ca_delta **delta)\n static struct iv_ca *\n iv_ca_new (struct ivopts_data *data)\n {\n-  struct iv_ca *nw = xmalloc (sizeof (struct iv_ca));\n+  struct iv_ca *nw = XNEW (struct iv_ca);\n \n   nw->upto = 0;\n   nw->bad_uses = 0;\n-  nw->cand_for_use = xcalloc (n_iv_uses (data), sizeof (struct cost_pair *));\n-  nw->n_cand_uses = xcalloc (n_iv_cands (data), sizeof (unsigned));\n+  nw->cand_for_use = XCNEWVEC (struct cost_pair *, n_iv_uses (data));\n+  nw->n_cand_uses = XCNEWVEC (unsigned, n_iv_cands (data));\n   nw->cands = BITMAP_ALLOC (NULL);\n   nw->n_cands = 0;\n   nw->n_regs = 0;\n   nw->cand_use_cost = 0;\n   nw->cand_cost = 0;\n-  nw->n_invariant_uses = xcalloc (data->max_inv_id + 1, sizeof (unsigned));\n+  nw->n_invariant_uses = XCNEWVEC (unsigned, data->max_inv_id + 1);\n   nw->cost = 0;\n \n   return nw;\n@@ -5922,8 +5921,7 @@ free_loop_data (struct ivopts_data *data)\n     {\n       data->version_info_size = 2 * num_ssa_names;\n       free (data->version_info);\n-      data->version_info = xcalloc (data->version_info_size,\n-\t\t\t\t    sizeof (struct version_info));\n+      data->version_info = XCNEWVEC (struct version_info, data->version_info_size);\n     }\n \n   data->max_inv_id = 0;"}, {"sha": "ab9971dfabf4a877b075c79738c83352220c072c", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -361,7 +361,7 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n   update_ssa (update_flag);\n \n   old_num_ssa_names = num_ssa_names;\n-  use_blocks = xcalloc (old_num_ssa_names, sizeof (bitmap));\n+  use_blocks = XCNEWVEC (bitmap, old_num_ssa_names);\n \n   /* Find the uses outside loops.  */\n   find_uses_to_rename (changed_bbs, use_blocks, names_to_rename);"}, {"sha": "6593deb49bf72cc3bf75c1ca992b5935a16c9cd4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1908,7 +1908,7 @@ compute_rvuse (void)\n      RVUSE_IN[BB] = Union of RVUSE_OUT of predecessors.\n      RVUSE_OUT[BB] = RVUSE_GEN[BB] U (RVUSE_IN[BB] - RVUSE_KILL[BB])\n   */\n-  postorder = xmalloc (sizeof (int) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n+  postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n   pre_and_rev_post_order_compute (NULL, postorder, false);\n \n   changed = true;\n@@ -3596,7 +3596,7 @@ execute_pre (bool do_fre)\n      computing ANTIC, either, even though it's plenty fast.  */\n   if (!do_fre && n_basic_blocks < 4000)\n     {\n-      vuse_names = xcalloc (num_ssa_names, sizeof (bitmap));\n+      vuse_names = XCNEWVEC (bitmap, num_ssa_names);\n       compute_rvuse ();\n       compute_antic ();\n       insert ();"}, {"sha": "c36293f6937d7a3f0293314ab8897223f56bc10d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1415,7 +1415,7 @@ init_reassoc (void)\n   int i;\n   unsigned int rank = 2;\n   tree param;\n-  int *bbs = xmalloc ((last_basic_block + 1) * sizeof (int));\n+  int *bbs = XNEWVEC (int, last_basic_block + 1);\n \n   memset (&reassociate_stats, 0, sizeof (reassociate_stats));\n \n@@ -1425,7 +1425,7 @@ init_reassoc (void)\n   /* Reverse RPO (Reverse Post Order) will give us something where\n      deeper loops come later.  */\n   pre_and_rev_post_order_compute (NULL, bbs, false);\n-  bb_rank = xcalloc (last_basic_block + 1, sizeof (unsigned int));\n+  bb_rank = XCNEWVEC (unsigned int, last_basic_block + 1);\n   \n   operand_rank = htab_create (511, operand_entry_hash,\n \t\t\t      operand_entry_eq, 0);"}, {"sha": "fbe9ddfaf26fc86a6261500916c0720241b2d161", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -1180,15 +1180,11 @@ build_constraint_graph (void)\n   int i = 0;\n   constraint_t c;\n \n-  graph = xmalloc (sizeof (struct constraint_graph));\n-  graph->succs = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n-\t\t\t  sizeof (*graph->succs));\n-  graph->preds = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n-\t\t\t  sizeof (*graph->preds));\n-  graph->zero_weight_succs = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n-\t\t\t  sizeof (*graph->zero_weight_succs));\n-  graph->zero_weight_preds = xcalloc (VEC_length (varinfo_t, varmap) + 1,\n-\t\t\t  sizeof (*graph->zero_weight_preds));\n+  graph = XNEW (struct constraint_graph);\n+  graph->succs = XCNEWVEC (VEC(constraint_edge_t,heap) *, VEC_length (varinfo_t, varmap) + 1);\n+  graph->preds = XCNEWVEC (VEC(constraint_edge_t,heap) *, VEC_length (varinfo_t, varmap) + 1);\n+  graph->zero_weight_succs = XCNEWVEC (bitmap, VEC_length (varinfo_t, varmap) + 1);\n+  graph->zero_weight_preds = XCNEWVEC (bitmap, VEC_length (varinfo_t, varmap) + 1);\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -1466,7 +1462,7 @@ static struct topo_info *\n init_topo_info (void)\n {\n   size_t size = VEC_length (varinfo_t, varmap);\n-  struct topo_info *ti = xmalloc (sizeof (struct topo_info));\n+  struct topo_info *ti = XNEW (struct topo_info);\n   ti->visited = sbitmap_alloc (size);\n   sbitmap_zero (ti->visited);\n   ti->topo_order = VEC_alloc (unsigned, heap, 1);\n@@ -1757,15 +1753,15 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n static struct scc_info *\n init_scc_info (void)\n {\n-  struct scc_info *si = xmalloc (sizeof (struct scc_info));\n+  struct scc_info *si = XNEW (struct scc_info);\n   size_t size = VEC_length (varinfo_t, varmap);\n \n   si->current_index = 0;\n   si->visited = sbitmap_alloc (size);\n   sbitmap_zero (si->visited);\n   si->in_component = sbitmap_alloc (size);\n   sbitmap_ones (si->in_component);\n-  si->visited_index = xcalloc (sizeof (unsigned int), size + 1);\n+  si->visited_index = XCNEWVEC (unsigned int, size + 1);\n   si->scc_stack = VEC_alloc (unsigned, heap, 1);\n   si->unification_queue = VEC_alloc (unsigned, heap, 1);\n   return si;\n@@ -2141,7 +2137,7 @@ insert_id_for_tree (tree t, int id)\n   finder.t = t;\n   slot = htab_find_slot (id_for_tree, &finder, INSERT);\n   gcc_assert (*slot == NULL);\n-  new_pair = xmalloc (sizeof (struct tree_id));\n+  new_pair = XNEW (struct tree_id);\n   new_pair->t = t;\n   new_pair->id = id;\n   *slot = (void *)new_pair;"}, {"sha": "d5777ff4332790266dcda02620e071b06626f89e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -253,7 +253,7 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n \n  /* Build a hash table element so we can see if E is already\n      in the table.  */\n-  elt = xmalloc (sizeof (struct redirection_data));\n+  elt = XNEW (struct redirection_data);\n   elt->outgoing_edge = e;\n   elt->dup_block = NULL;\n   elt->do_not_duplicate = false;\n@@ -274,7 +274,7 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n   if (*slot == NULL)\n     {\n       *slot = (void *)elt;\n-      elt->incoming_edges = xmalloc (sizeof (struct el));\n+      elt->incoming_edges = XNEW (struct el);\n       elt->incoming_edges->e = incoming_edge;\n       elt->incoming_edges->next = NULL;\n       return elt;\n@@ -293,7 +293,7 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n \t to the list of incoming edges associated with E.  */\n       if (insert)\n \t{\n-          struct el *el = xmalloc (sizeof (struct el));\n+          struct el *el = XNEW (struct el);\n \t  el->next = elt->incoming_edges;\n \t  el->e = incoming_edge;\n \t  elt->incoming_edges = el;"}, {"sha": "b49526d1848809b384fc26e1cad443ae3053c0c4", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -59,7 +59,7 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n   if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n     return false;\n \n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = XNEWVEC (edge, n_basic_blocks + 1);\n   sp = 0;\n \n   visited = sbitmap_alloc (last_basic_block);\n@@ -125,7 +125,7 @@ va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n     {\n       unsigned int i;\n \n-      si->offsets = xmalloc (num_ssa_names * sizeof (int));\n+      si->offsets = XNEWVEC (int, num_ssa_names);\n       for (i = 0; i < num_ssa_names; ++i)\n \tsi->offsets[i] = -1;\n     }"}, {"sha": "a07af12b6a1525d90deb0385290fecf50a005d34", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -860,7 +860,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n \t\t\t\t\t  exit_dest) == loop->header ? \n \t\t true : false);\n \n-  new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n+  new_bbs = XNEWVEC (basic_block, loop->num_nodes);\n \n   copy_bbs (bbs, loop->num_nodes, new_bbs,\n \t    &loop->single_exit, 1, &new_loop->single_exit, NULL,"}, {"sha": "e80f385206f7bfd27bc2d0f751448ca8af2f9d9c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -255,7 +255,7 @@ get_value_range (tree var)\n     return vr;\n \n   /* Create a default value range.  */\n-  vr_value[ver] = vr = xmalloc (sizeof (*vr));\n+  vr_value[ver] = vr = XNEW (value_range_t);\n   memset (vr, 0, sizeof (*vr));\n \n   /* Allocate an equivalence set.  */\n@@ -2609,7 +2609,7 @@ register_new_assert_for (tree name,\n   /* If we didn't find an assertion already registered for\n      NAME COMP_CODE VAL, add a new one at the end of the list of\n      assertions associated with NAME.  */\n-  n = xmalloc (sizeof (*n));\n+  n = XNEW (struct assert_locus_d);\n   n->bb = dest_bb;\n   n->e = e;\n   n->si = si;\n@@ -3081,7 +3081,7 @@ insert_range_assertions (void)\n   sbitmap_zero (blocks_visited);\n \n   need_assert_for = BITMAP_ALLOC (NULL);\n-  asserts_for = xmalloc (num_ssa_names * sizeof (assert_locus_t));\n+  asserts_for = XNEWVEC (assert_locus_t, num_ssa_names);\n   memset (asserts_for, 0, num_ssa_names * sizeof (assert_locus_t));\n \n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -3212,7 +3212,7 @@ vrp_initialize (void)\n {\n   basic_block bb;\n \n-  vr_value = xmalloc (num_ssa_names * sizeof (value_range_t *));\n+  vr_value = XNEWVEC (value_range_t *, num_ssa_names);\n   memset (vr_value, 0, num_ssa_names * sizeof (value_range_t *));\n \n   FOR_EACH_BB (bb)\n@@ -4227,7 +4227,7 @@ vrp_finalize (void)\n   /* We may have ended with ranges that have exactly one value.  Those\n      values can be substituted as any other copy/const propagated\n      value using substitute_and_fold.  */\n-  single_val_range = xmalloc (num_ssa_names * sizeof (*single_val_range));\n+  single_val_range = XNEWVEC (prop_value_t, num_ssa_names);\n   memset (single_val_range, 0, num_ssa_names * sizeof (*single_val_range));\n \n   do_value_subst_p = false;"}, {"sha": "98c3694f3a97fa1c5b65d5324debd2eb3029c92d", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -973,7 +973,7 @@ getstmtlist (void)\n static void\n pushlevel (int ignore ATTRIBUTE_UNUSED)\n {\n-  struct binding_level *newlevel = xmalloc (sizeof (struct binding_level));\n+  struct binding_level *newlevel = XNEW (struct binding_level);\n \n   *newlevel = clear_binding_level;\n "}, {"sha": "40e1e424d38cf1c23a59753e0ec488d565a6d0df", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -498,7 +498,7 @@ vt_stack_adjustments (void)\n   VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n   sp = 0;\n \n   /* Push the first edge on to the stack.  */\n@@ -1070,7 +1070,7 @@ variable_union (void **slot, void *data)\n \t  dst_l = 0;\n \t  for (node = dst->var_part[j].loc_chain; node; node = node->next)\n \t    dst_l++;\n-\t  vui = xcalloc (src_l + dst_l, sizeof (struct variable_union_info));\n+\t  vui = XCNEWVEC (struct variable_union_info, src_l + dst_l);\n \n \t  /* Fill in the locations from DST.  */\n \t  for (node = dst->var_part[j].loc_chain, jj = 0; node;\n@@ -1638,8 +1638,8 @@ vt_find_locations (void)\n \n   /* Compute reverse completion order of depth first search of the CFG\n      so that the data-flow runs faster.  */\n-  rc_order = xmalloc ((n_basic_blocks - NUM_FIXED_BLOCKS) * sizeof (int));\n-  bb_order = xmalloc (last_basic_block * sizeof (int));\n+  rc_order = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  bb_order = XNEWVEC (int, last_basic_block);\n   pre_and_rev_post_order_compute (NULL, rc_order, false);\n   for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     bb_order[rc_order[i]] = i;\n@@ -2546,8 +2546,7 @@ vt_initialize (void)\n \t}\n \n       /* Add the micro-operations to the array.  */\n-      VTI (bb)->mos = xmalloc (VTI (bb)->n_mos\n-\t\t\t       * sizeof (struct micro_operation_def));\n+      VTI (bb)->mos = XNEWVEC (micro_operation, VTI (bb)->n_mos);\n       VTI (bb)->n_mos = 0;\n       for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))"}, {"sha": "164fd17223cef5034b93e830be5eef9c05a44b64", "filename": "gcc/web.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ed6ace578e0657c0481bacd16c97ceb3deda9a4/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=5ed6ace578e0657c0481bacd16c97ceb3deda9a4", "patch": "@@ -249,9 +249,9 @@ web_main (void)\n   df_reorganize_refs (&df->def_info);\n   df_reorganize_refs (&df->use_info);\n \n-  def_entry = xcalloc (DF_DEFS_SIZE (df), sizeof (struct web_entry));\n-  use_entry = xcalloc (DF_USES_SIZE (df), sizeof (struct web_entry));\n-  used = xcalloc (max, sizeof (char));\n+  def_entry = XCNEWVEC (struct web_entry, DF_DEFS_SIZE (df));\n+  use_entry = XCNEWVEC (struct web_entry, DF_USES_SIZE (df));\n+  used = XCNEWVEC (char, max);\n \n   if (dump_file)\n     df_dump (df, dump_file);"}]}