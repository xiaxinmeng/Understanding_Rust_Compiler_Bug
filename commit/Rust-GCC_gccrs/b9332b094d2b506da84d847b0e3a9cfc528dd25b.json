{"sha": "b9332b094d2b506da84d847b0e3a9cfc528dd25b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzMzJiMDk0ZDJiNTA2ZGE4NGQ4NDdiMGUzYTljZmM1MjhkZDI1Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-02-03T11:29:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-02-03T11:29:27Z"}, "message": "re PR fortran/32760 (Error defining subroutine named PRINT)\n\n2008-02-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32760\n\t* resolve.c (resolve_allocate_deallocate): New function.\n\t(resolve_code): Call it for allocate and deallocate.\n\t* match.c (gfc_match_allocate, gfc_match_deallocate) : Remove\n\tthe checking of the STAT tag and put in above new function.\n\t* primary,c (match_variable): Do not fix flavor of host\n\tassociated symbols yet if the type is not known.\n\n2008-02-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32760\n\t* gfortran.dg/host_assoc_variable_1.f90: New test.\n\t* gfortran.dg/allocate_stat.f90: Change last three error messages.\n\nFrom-SVN: r132078", "tree": {"sha": "730852770e905aafbbe0906c5de87169a2ad6c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730852770e905aafbbe0906c5de87169a2ad6c36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9332b094d2b506da84d847b0e3a9cfc528dd25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9332b094d2b506da84d847b0e3a9cfc528dd25b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9332b094d2b506da84d847b0e3a9cfc528dd25b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9332b094d2b506da84d847b0e3a9cfc528dd25b/comments", "author": null, "committer": null, "parents": [{"sha": "ce3605e2bbe385f8d07e045a614e470eaaaa0838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3605e2bbe385f8d07e045a614e470eaaaa0838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3605e2bbe385f8d07e045a614e470eaaaa0838"}], "stats": {"total": 283, "additions": 185, "deletions": 98}, "files": [{"sha": "33f342391af1adacea264fe611fb1e21e28018da", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -1,3 +1,13 @@\n+2008-02-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32760\n+\t* resolve.c (resolve_allocate_deallocate): New function.\n+\t(resolve_code): Call it for allocate and deallocate.\n+\t* match.c (gfc_match_allocate, gfc_match_deallocate) : Remove\n+\tthe checking of the STAT tag and put in above new function.\n+\t* primary,c (match_variable): Do not fix flavor of host\n+\tassociated symbols yet if the type is not known.\n+\n 2008-01-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/34910"}, {"sha": "324e52ecee042d532c5acb6985c25d104dc54043", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 79, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -2235,62 +2235,7 @@ gfc_match_allocate (void)\n     }\n \n   if (stat != NULL)\n-    {\n-      bool is_variable;\n-\n-      if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n-\t{\n-\t  gfc_error (\"STAT variable '%s' of ALLOCATE statement at %C cannot \"\n-\t\t     \"be INTENT(IN)\", stat->symtree->n.sym->name);\n-\t  goto cleanup;\n-\t}\n-\n-      if (gfc_pure (NULL) && gfc_impure_variable (stat->symtree->n.sym))\n-\t{\n-\t  gfc_error (\"Illegal STAT variable in ALLOCATE statement at %C \"\n-\t\t     \"for a PURE procedure\");\n-\t  goto cleanup;\n-\t}\n-\n-      is_variable = false;\n-      if (stat->symtree->n.sym->attr.flavor == FL_VARIABLE)\n-\tis_variable = true;\n-      else if (stat->symtree->n.sym->attr.function\n-\t  && stat->symtree->n.sym->result == stat->symtree->n.sym\n-\t  && (gfc_current_ns->proc_name == stat->symtree->n.sym\n-\t      || (gfc_current_ns->parent\n-\t\t  && gfc_current_ns->parent->proc_name\n-\t\t     == stat->symtree->n.sym)))\n-\tis_variable = true;\n-      else if (gfc_current_ns->entries\n-\t       && stat->symtree->n.sym->result == stat->symtree->n.sym)\n-\t{\n-\t  gfc_entry_list *el;\n-\t  for (el = gfc_current_ns->entries; el; el = el->next)\n-\t    if (el->sym == stat->symtree->n.sym)\n-\t      {\n-\t\tis_variable = true;\n-\t      }\n-\t}\n-      else if (gfc_current_ns->parent && gfc_current_ns->parent->entries\n-\t       && stat->symtree->n.sym->result == stat->symtree->n.sym)\n-\t{\n-\t  gfc_entry_list *el;\n-\t  for (el = gfc_current_ns->parent->entries; el; el = el->next)\n-\t    if (el->sym == stat->symtree->n.sym)\n-\t      {\n-\t\tis_variable = true;\n-\t      }\n-\t}\n-\n-      if (!is_variable)\n-\t{\n-\t  gfc_error (\"STAT expression at %C must be a variable\");\n-\t  goto cleanup;\n-\t}\n-\n-      gfc_check_do_variable(stat->symtree);\n-    }\n+    gfc_check_do_variable(stat->symtree);\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;\n@@ -2432,29 +2377,7 @@ gfc_match_deallocate (void)\n     }\n \n   if (stat != NULL)\n-    {\n-      if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n-\t{\n-\t  gfc_error (\"STAT variable '%s' of DEALLOCATE statement at %C \"\n-\t\t     \"cannot be INTENT(IN)\", stat->symtree->n.sym->name);\n-\t  goto cleanup;\n-\t}\n-\n-      if (gfc_pure(NULL) && gfc_impure_variable (stat->symtree->n.sym))\n-\t{\n-\t  gfc_error (\"Illegal STAT variable in DEALLOCATE statement at %C \"\n-\t\t     \"for a PURE procedure\");\n-\t  goto cleanup;\n-\t}\n-\n-      if (stat->symtree->n.sym->attr.flavor != FL_VARIABLE)\n-\t{\n-\t  gfc_error (\"STAT expression at %C must be a variable\");\n-\t  goto cleanup;\n-\t}\n-\n-      gfc_check_do_variable(stat->symtree);\n-    }\n+    gfc_check_do_variable(stat->symtree);\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;"}, {"sha": "8385cb5788eee7fb72339ec6486fffd46a38c5d7", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -2534,6 +2534,14 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \tif (sym->attr.external || sym->attr.procedure\n \t    || sym->attr.function || sym->attr.subroutine)\n \t  flavor = FL_PROCEDURE;\n+\n+\t/* If it is not a procedure, is not typed and is host associated,\n+\t   we cannot give it a flavor yet.  */\n+\telse if (sym->ns == gfc_current_ns->parent\n+\t\t   && sym->ts.type == BT_UNKNOWN)\n+\t  break;\n+\n+\t/* These are definitive indicators that this is a variable.  */\n \telse if (gfc_peek_char () != '(' || sym->ts.type != BT_UNKNOWN\n \t\t || sym->attr.pointer || sym->as != NULL)\n \t  flavor = FL_VARIABLE;"}, {"sha": "926f0455f485210eb02f7e0a31ded302b2e2412b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 79, "deletions": 16, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -4864,6 +4864,81 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   return SUCCESS;\n }\n \n+static void\n+resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n+{\n+  gfc_symbol *s = NULL;\n+  gfc_alloc *a;\n+  bool is_variable;\n+\n+  if (code->expr)\n+    s = code->expr->symtree->n.sym;\n+\n+  if (s)\n+    {\n+      if (s->attr.intent == INTENT_IN)\n+\tgfc_error (\"STAT variable '%s' of %s statement at %C cannot \"\n+\t\t   \"be INTENT(IN)\", s->name, fcn);\n+\n+      if (gfc_pure (NULL) && gfc_impure_variable (s))\n+\tgfc_error (\"Illegal STAT variable in %s statement at %C \"\n+\t\t   \"for a PURE procedure\", fcn);\n+\n+      is_variable = false;\n+      if (s->attr.flavor == FL_VARIABLE)\n+\tis_variable = true;\n+      else if (s->attr.function && s->result == s\n+\t\t && (gfc_current_ns->proc_name == s\n+\t\t\t||\n+\t\t    (gfc_current_ns->parent\n+\t\t       && gfc_current_ns->parent->proc_name == s)))\n+\tis_variable = true;\n+      else if (gfc_current_ns->entries && s->result == s)\n+\t{\n+\t  gfc_entry_list *el;\n+\t  for (el = gfc_current_ns->entries; el; el = el->next)\n+\t    if (el->sym == s)\n+\t      {\n+\t\tis_variable = true;\n+\t      }\n+\t}\n+      else if (gfc_current_ns->parent && gfc_current_ns->parent->entries\n+\t         && s->result == s)\n+\t{\n+\t  gfc_entry_list *el;\n+\t  for (el = gfc_current_ns->parent->entries; el; el = el->next)\n+\t    if (el->sym == s)\n+\t      {\n+\t\tis_variable = true;\n+\t      }\n+\t}\n+\n+      if (s->attr.flavor == FL_UNKNOWN\n+\t    && gfc_add_flavor (&s->attr, FL_VARIABLE,\n+\t\t\t       s->name, NULL) == SUCCESS)\n+\tis_variable = true;\n+\n+      if (!is_variable)\n+\tgfc_error (\"STAT tag in %s statement at %L must be \"\n+\t\t   \"a variable\", fcn, &code->expr->where);\n+\n+    }\n+\n+  if (s && code->expr->ts.type != BT_INTEGER)\n+\tgfc_error (\"STAT tag in %s statement at %L must be \"\n+\t\t       \"of type INTEGER\", fcn, &code->expr->where);\n+\n+  if (strcmp (fcn, \"ALLOCATE\") == 0)\n+    {\n+      for (a = code->ext.alloc_list; a; a = a->next)\n+\tresolve_allocate_expr (a->expr, code);\n+    }\n+  else\n+    {\n+      for (a = code->ext.alloc_list; a; a = a->next)\n+\tresolve_deallocate_expr (a->expr);\n+    }\n+}\n \n /************ SELECT CASE resolution subroutines ************/\n \n@@ -6090,7 +6165,6 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n   int omp_workshare_save;\n   int forall_save;\n   code_stack frame;\n-  gfc_alloc *a;\n   try t;\n \n   frame.prev = cs_base;\n@@ -6275,25 +6349,14 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_ALLOCATE:\n-\t  if (t == SUCCESS && code->expr != NULL\n-\t      && code->expr->ts.type != BT_INTEGER)\n-\t    gfc_error (\"STAT tag in ALLOCATE statement at %L must be \"\n-\t\t       \"of type INTEGER\", &code->expr->where);\n-\n-\t  for (a = code->ext.alloc_list; a; a = a->next)\n-\t    resolve_allocate_expr (a->expr, code);\n+\t  if (t == SUCCESS)\n+\t    resolve_allocate_deallocate (code, \"ALLOCATE\");\n \n \t  break;\n \n \tcase EXEC_DEALLOCATE:\n-\t  if (t == SUCCESS && code->expr != NULL\n-\t      && code->expr->ts.type != BT_INTEGER)\n-\t    gfc_error\n-\t      (\"STAT tag in DEALLOCATE statement at %L must be of type \"\n-\t       \"INTEGER\", &code->expr->where);\n-\n-\t  for (a = code->ext.alloc_list; a; a = a->next)\n-\t    resolve_deallocate_expr (a->expr);\n+\t  if (t == SUCCESS)\n+\t    resolve_allocate_deallocate (code, \"DEALLOCATE\");\n \n \t  break;\n "}, {"sha": "e4760f8951c8c1a0211549fb9b02d2b1d857f2a5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -1,3 +1,9 @@\n+2008-02-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32760\n+\t* gfortran.dg/host_assoc_variable_1.f90: New test.\n+\t* gfortran.dg/allocate_stat.f90: Change last three error messages.\n+\n 2008-02-02  Michael Matz  <matz@suse.de>\n \n \tPR target/35045"}, {"sha": "76626f822bc2863c601955fb13e089cbe38547ba", "filename": "gcc/testsuite/gfortran.dg/allocate_stat.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_stat.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_stat.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_stat.f90?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -51,7 +51,7 @@ integer function func2()\n   end interface\n   real, pointer :: gain \n   integer, parameter :: res = 2\n-  allocate (gain,STAT=func2) ! { dg-error \"STAT expression at .1. must be a variable\" }\n+  allocate (gain,STAT=func2) ! { dg-error \"STAT tag in ALLOCATE statement at .1. must be a variable\" }\n   deallocate(gain)\n end subroutine sub\n \n@@ -68,9 +68,9 @@ function one()\n  end function one\n  subroutine sub()\n    integer, pointer :: p\n-   allocate(p, stat=one) ! { dg-error \"STAT expression at .1. must be a variable\" }\n+   allocate(p, stat=one) ! { dg-error \"STAT tag in ALLOCATE statement at .1. must be a variable\" }\n    if(associated(p)) deallocate(p)\n-   allocate(p, stat=two) ! { dg-error \"STAT expression at .1. must be a variable\" }\n+   allocate(p, stat=two) ! { dg-error \"STAT tag in ALLOCATE statement at .1. must be a variable\" }\n    if(associated(p)) deallocate(p)\n  end subroutine sub\n end module test"}, {"sha": "1e7adea88949846e4c1b1eb7e2ceef67ca3f44dc", "filename": "gcc/testsuite/gfortran.dg/host_assoc_variable_1.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_variable_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9332b094d2b506da84d847b0e3a9cfc528dd25b/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_variable_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_variable_1.f90?ref=b9332b094d2b506da84d847b0e3a9cfc528dd25b", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do compile }\n+! This tests that PR32760, in its various manifestations is fixed.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+!\n+! This is the original bug - the frontend tried to fix the flavor of\n+! 'PRINT' too early so that the compile failed on the subroutine \n+! declaration.\n+!\n+module gfcbug68\n+  implicit none\n+  public :: print\n+contains\n+  subroutine foo (i)\n+    integer, intent(in)  :: i\n+    print *, i\n+  end subroutine foo\n+  subroutine print (m)\n+    integer, intent(in) :: m\n+  end subroutine print\n+end module gfcbug68\n+\n+! This version of the bug appears in comment # 21.\n+!\n+module m\n+  public :: volatile\n+contains\n+  subroutine foo\n+    volatile :: bar\n+  end subroutine foo\n+  subroutine volatile\n+  end subroutine volatile\n+end module\n+\n+! This was a problem with the resolution of the STAT parameter in \n+! ALLOCATE and DEALLOCATE that was exposed in comment #25.\n+!\n+module n\n+  public :: integer\n+  private :: istat\n+contains\n+  subroutine foo\n+    integer, allocatable :: s(:), t(:)\n+    allocate(t(5))\n+    allocate(s(4), stat=istat)\n+  end subroutine foo\n+  subroutine integer()\n+  end subroutine integer\n+end module n\n+\n+! This is the version of the bug in comment #12 of the PR.\n+!\n+module gfcbug68a\n+  implicit none\n+  public :: write\n+contains\n+  function foo (i)\n+    integer, intent(in)  :: i\n+    integer foo\n+    write (*,*) i\n+    foo = i\n+  end function foo\n+  subroutine write (m)\n+    integer, intent(in) :: m\n+    print *, m*m*m\n+  end subroutine write\n+end module gfcbug68a\n+\n+program testit\n+  use gfcbug68a\n+  integer :: i = 27\n+  integer :: k\n+  k = foo(i)\n+  print *, \"in the main:\", k\n+  call write(33)\n+end program testit\n+! { dg-final { cleanup-modules \"gfcbug68 gfcbug68a m n\" } }"}]}