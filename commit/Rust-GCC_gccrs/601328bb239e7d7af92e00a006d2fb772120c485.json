{"sha": "601328bb239e7d7af92e00a006d2fb772120c485", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAxMzI4YmIyMzllN2Q3YWY5MmUwMGEwMDZkMmZiNzcyMTIwYzQ4NQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-16T05:53:24Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-16T05:53:24Z"}, "message": "cpphash.h (cpp_macro): Move here, and make expansion a union.\n\n\t* cpphash.h (cpp_macro): Move here, and make expansion a union.\n\t* cppmacro.c (cpp_macro): Remove.\n\t(enter_macro_context, replace_args, warn_of_redefinition,\n\t_cpp_create_definition, cpp_macro_definition): Update.\n\nFrom-SVN: r53509", "tree": {"sha": "9c92465466bc6540fc41e7c24db7796904c385b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c92465466bc6540fc41e7c24db7796904c385b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/601328bb239e7d7af92e00a006d2fb772120c485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601328bb239e7d7af92e00a006d2fb772120c485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601328bb239e7d7af92e00a006d2fb772120c485", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601328bb239e7d7af92e00a006d2fb772120c485/comments", "author": null, "committer": null, "parents": [{"sha": "f4b251a67a849b89d2b21aa54db59891479d1111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b251a67a849b89d2b21aa54db59891479d1111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b251a67a849b89d2b21aa54db59891479d1111"}], "stats": {"total": 73, "additions": 43, "deletions": 30}, "files": [{"sha": "820122e0e5826ee7fb4668366529b5627ddb8064", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=601328bb239e7d7af92e00a006d2fb772120c485", "patch": "@@ -1,3 +1,10 @@\n+2002-05-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (cpp_macro): Move here, and make expansion a union.\n+\t* cppmacro.c (cpp_macro): Remove.\n+\t(enter_macro_context, replace_args, warn_of_redefinition,\n+\t_cpp_create_definition, cpp_macro_definition): Update.\n+\n 2002-05-16  Jason Merrill  <jason@redhat.com>\n \n \t* config/mips/mips.c (mips_output_external): Don't do sdata"}, {"sha": "3d82316372a147a049cd6035d78383511c3072e5", "filename": "gcc/cpphash.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=601328bb239e7d7af92e00a006d2fb772120c485", "patch": "@@ -29,6 +29,9 @@ struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n \n+typedef unsigned char uchar;\n+#define U (const uchar *)  /* Intended use: U\"string\" */\n+\n #define BITS_PER_CPPCHAR_T (CHAR_BIT * sizeof (cppchar_t))\n \n /* Test if a sign is valid within a preprocessing number.  */\n@@ -47,6 +50,24 @@ struct op;\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n \n+/* Each macro definition is recorded in a cpp_macro structure.\n+   Variadic macros cannot occur with traditional cpp.  */\n+struct cpp_macro\n+{\n+  cpp_hashnode **params;\t/* Parameters, if any.  */\n+  union\n+  {\n+    cpp_token *tokens;\t        /* Tokens of replacement list (ISO).  */\n+    const uchar *text;\t\t/* Expansion text (traditional).  */\n+  } exp;\n+  unsigned int line;\t\t/* Starting line number.  */\n+  unsigned int count;\t\t/* Number of tokens / bytes in expansion.  */\n+  unsigned short paramc;\t/* Number of parameters.  */\n+  unsigned int fun_like : 1;\t/* If a function-like macro.  */\n+  unsigned int variadic : 1;\t/* If a variadic macro.  */\n+  unsigned int syshdr   : 1;\t/* If macro defined in system header.  */\n+};\n+\n /* A generic memory buffer, and operations on it.  */\n typedef struct _cpp_buff _cpp_buff;\n struct _cpp_buff\n@@ -436,9 +457,6 @@ extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n /* These are inline functions instead of macros so we can get type\n    checking.  */\n-typedef unsigned char uchar;\n-#define U (const uchar *)  /* Intended use: U\"string\" */\n-\n static inline int ustrcmp\tPARAMS ((const uchar *, const uchar *));\n static inline int ustrncmp\tPARAMS ((const uchar *, const uchar *,\n \t\t\t\t\t size_t));"}, {"sha": "f9c935fd80554de4fc774a6e79ea8a7bd2674ef1", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601328bb239e7d7af92e00a006d2fb772120c485/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=601328bb239e7d7af92e00a006d2fb772120c485", "patch": "@@ -28,18 +28,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-struct cpp_macro\n-{\n-  cpp_hashnode **params;\t/* Parameters, if any.  */\n-  cpp_token *expansion;\t\t/* First token of replacement list.  */\n-  unsigned int line;\t\t/* Starting line number.  */\n-  unsigned int count;\t\t/* Number of tokens in expansion.  */\n-  unsigned short paramc;\t/* Number of parameters.  */\n-  unsigned int fun_like : 1;\t/* If a function-like macro.  */\n-  unsigned int variadic : 1;\t/* If a variadic macro.  */\n-  unsigned int syshdr   : 1;\t/* If macro defined in system header.  */\n-};\n-\n typedef struct macro_arg macro_arg;\n struct macro_arg\n {\n@@ -695,7 +683,7 @@ enter_macro_context (pfile, node)\n       node->flags |= NODE_DISABLED;\n \n       if (macro->paramc == 0)\n-\tpush_token_context (pfile, node, macro->expansion, macro->count);\n+\tpush_token_context (pfile, node, macro->exp.tokens, macro->count);\n \n       return 1;\n     }\n@@ -726,9 +714,9 @@ replace_args (pfile, node, macro, args)\n      statements below is subtle; we must handle stringification before\n      pasting.  */\n   total = macro->count;\n-  limit = macro->expansion + macro->count;\n+  limit = macro->exp.tokens + macro->count;\n \n-  for (src = macro->expansion; src < limit; src++)\n+  for (src = macro->exp.tokens; src < limit; src++)\n     if (src->type == CPP_MACRO_ARG)\n       {\n \t/* Leading and trailing padding tokens.  */\n@@ -744,7 +732,7 @@ replace_args (pfile, node, macro, args)\n \t      arg->stringified = stringify_arg (pfile, arg);\n \t  }\n \telse if ((src->flags & PASTE_LEFT)\n-\t\t || (src > macro->expansion && (src[-1].flags & PASTE_LEFT)))\n+\t\t || (src > macro->exp.tokens && (src[-1].flags & PASTE_LEFT)))\n \t  total += arg->count - 1;\n \telse\n \t  {\n@@ -760,7 +748,7 @@ replace_args (pfile, node, macro, args)\n   first = (const cpp_token **) buff->base;\n   dest = first;\n \n-  for (src = macro->expansion; src < limit; src++)\n+  for (src = macro->exp.tokens; src < limit; src++)\n     {\n       unsigned int count;\n       const cpp_token **from, **paste_flag;\n@@ -777,7 +765,7 @@ replace_args (pfile, node, macro, args)\n \tcount = 1, from = &arg->stringified;\n       else if (src->flags & PASTE_LEFT)\n \tcount = arg->count, from = arg->first;\n-      else if (src != macro->expansion && (src[-1].flags & PASTE_LEFT))\n+      else if (src != macro->exp.tokens && (src[-1].flags & PASTE_LEFT))\n \t{\n \t  count = arg->count, from = arg->first;\n \t  if (dest != first)\n@@ -805,7 +793,7 @@ replace_args (pfile, node, macro, args)\n \n       /* Padding on the left of an argument (unless RHS of ##).  */\n       if (!pfile->state.in_directive\n-\t  && src != macro->expansion && !(src[-1].flags & PASTE_LEFT))\n+\t  && src != macro->exp.tokens && !(src[-1].flags & PASTE_LEFT))\n \t*dest++ = padding_token (pfile, src);\n \n       if (count)\n@@ -1149,7 +1137,7 @@ warn_of_redefinition (node, macro2)\n \n   /* Check each token.  */\n   for (i = 0; i < macro1->count; i++)\n-    if (! _cpp_equiv_tokens (&macro1->expansion[i], &macro2->expansion[i]))\n+    if (! _cpp_equiv_tokens (&macro1->exp.tokens[i], &macro2->exp.tokens[i]))\n       return 1;\n \n   /* Check parameter spellings.  */\n@@ -1410,22 +1398,22 @@ _cpp_create_definition (pfile, node)\n       token = lex_expansion_token (pfile, macro);\n     }\n \n-  macro->expansion = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n+  macro->exp.tokens = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n \n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n \n   /* Clear whitespace on first token for warn_of_redefinition().  */\n   if (macro->count)\n-    macro->expansion[0].flags &= ~PREV_WHITE;\n+    macro->exp.tokens[0].flags &= ~PREV_WHITE;\n \n   /* Commit the memory.  */\n-  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->expansion[macro->count];\n+  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n \n   /* Implement the macro-defined-to-itself optimisation.  */\n   if (macro->count == 1 && !macro->fun_like\n-      && macro->expansion[0].type == CPP_NAME\n-      && macro->expansion[0].val.node == node)\n+      && macro->exp.tokens[0].type == CPP_NAME\n+      && macro->exp.tokens[0].val.node == node)\n     node->flags |= NODE_DISABLED;\n \n   /* To suppress some diagnostics.  */\n@@ -1545,7 +1533,7 @@ cpp_macro_definition (pfile, node)\n \n   for (i = 0; i < macro->count; i++)\n     {\n-      cpp_token *token = &macro->expansion[i];\n+      cpp_token *token = &macro->exp.tokens[i];\n \n       if (token->type == CPP_MACRO_ARG)\n \tlen += NODE_LEN (macro->params[token->val.arg_no - 1]);\n@@ -1602,7 +1590,7 @@ cpp_macro_definition (pfile, node)\n     {\n       for (i = 0; i < macro->count; i++)\n \t{\n-\t  cpp_token *token = &macro->expansion[i];\n+\t  cpp_token *token = &macro->exp.tokens[i];\n \n \t  if (token->flags & PREV_WHITE)\n \t    *buffer++ = ' ';"}]}