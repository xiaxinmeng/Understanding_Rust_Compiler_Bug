{"sha": "c2f8b491493226d196fc80a9f0d4856612c52992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJmOGI0OTE0OTMyMjZkMTk2ZmM4MGE5ZjBkNDg1NjYxMmM1Mjk5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-02-07T17:39:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-02-07T17:39:40Z"}, "message": "calls.c (compute_argument_block_size): New argument preferred_stack_boundary.\n\n\n\t* calls.c (compute_argument_block_size): New argument\n\tpreferred_stack_boundary.\n\t(expand_call): update cfun->preferred_stack_boundary, update call of\n\tcompute_argument_block_size\n\t(emit_library_call): Increate cfun->preferred_stack_boundary\n\tto PREFERRED_STACK_BOUNDARY\n\t(emit_library_call_value): Likewise.\n\t* explow.c (allocate_dynamic_stack_spave): Likewise.\n\t* function.c (prepare_function_start): Set\n\tcfun->preferred_stack_boundary\n\t* function.h (struct function): Add preferred_stack_boundary field.\n\t* integrate.c (expand_inline_function): Update\n\tcfun->preferred_stack_boundary and cfun->stack_alignment_needed.\n\t(copy_rtx_and_substitute): Align frame to stack_alignment_needed only.\n\t* i386.c (compute_frame_size): Use cfun->preferred_stack_boundary.\n\nFrom-SVN: r31831", "tree": {"sha": "fbcc1dc384eab7f572ca46df0b98ef599a28ec0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbcc1dc384eab7f572ca46df0b98ef599a28ec0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2f8b491493226d196fc80a9f0d4856612c52992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2f8b491493226d196fc80a9f0d4856612c52992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2f8b491493226d196fc80a9f0d4856612c52992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2f8b491493226d196fc80a9f0d4856612c52992/comments", "author": null, "committer": null, "parents": [{"sha": "08a75be26cf718b09bee952783e88d7789b47979", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a75be26cf718b09bee952783e88d7789b47979", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a75be26cf718b09bee952783e88d7789b47979"}], "stats": {"total": 94, "additions": 85, "deletions": 9}, "files": [{"sha": "fbfe968d7023e17dea67b686d64cc32af90c6c13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -1,3 +1,21 @@\n+Mon Feb  7 18:36:41 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (compute_argument_block_size): New argument\n+\tpreferred_stack_boundary.\n+\t(expand_call): update cfun->preferred_stack_boundary, update call of\n+\tcompute_argument_block_size\n+\t(emit_library_call): Increate cfun->preferred_stack_boundary\n+\tto PREFERRED_STACK_BOUNDARY\n+\t(emit_library_call_value): Likewise.\n+\t* explow.c (allocate_dynamic_stack_spave): Likewise.\n+\t* function.c (prepare_function_start): Set\n+\tcfun->preferred_stack_boundary\n+\t* function.h (struct function): Add preferred_stack_boundary field.\n+\t* integrate.c (expand_inline_function): Update\n+\tcfun->preferred_stack_boundary and cfun->stack_alignment_needed.\n+\t(copy_rtx_and_substitute): Align frame to stack_alignment_needed only.\n+\t* i386.c (compute_frame_size): Use cfun->preferred_stack_boundary.\n+\n 2000-02-06  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.c (my_strerror, cpp_error, cpp_error_with_line,"}, {"sha": "03261c080464abd580f749f72e3a6adbbc021d85", "filename": "gcc/calls.c", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -148,7 +148,8 @@ static void precompute_arguments \t\tPARAMS ((int, int, int,\n \t\t\t\t\t\t\t struct arg_data *,\n \t\t\t\t\t\t\t struct args_size *));\n static int compute_argument_block_size\t\tPARAMS ((int, \n-\t\t\t\t\t\t\t struct args_size *));\n+\t\t\t\t\t\t\t struct args_size *,\n+\t\t\t\t\t\t\t int));\n static void initialize_argument_information\tPARAMS ((int,\n \t\t\t\t\t\t\t struct arg_data *,\n \t\t\t\t\t\t\t struct args_size *,\n@@ -1176,9 +1177,11 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n    for arguments passed in registers.  */\n \n static int\n-compute_argument_block_size (reg_parm_stack_space, args_size)\n+compute_argument_block_size (reg_parm_stack_space, args_size,\n+    \t\t\t     preferred_stack_boundary)\n      int reg_parm_stack_space;\n      struct args_size *args_size;\n+     int preferred_stack_boundary ATTRIBUTE_UNUSED;\n {\n   int unadjusted_args_size = args_size->constant;\n \n@@ -1192,8 +1195,9 @@ compute_argument_block_size (reg_parm_stack_space, args_size)\n       args_size->constant = 0;\n \n #ifdef PREFERRED_STACK_BOUNDARY\n-      if (PREFERRED_STACK_BOUNDARY != BITS_PER_UNIT)\n-\targs_size->var = round_up (args_size->var, STACK_BYTES);\n+      preferred_stack_boundary /= BITS_PER_UNIT;\n+      if (preferred_stack_boundary > 1)\n+\targs_size->var = round_up (args_size->var, preferred_stack_boundary);\n #endif\n \n       if (reg_parm_stack_space > 0)\n@@ -1214,10 +1218,12 @@ compute_argument_block_size (reg_parm_stack_space, args_size)\n   else\n     {\n #ifdef PREFERRED_STACK_BOUNDARY\n+      preferred_stack_boundary /= BITS_PER_UNIT;\n       args_size->constant = (((args_size->constant\n \t\t\t       + pending_stack_adjust\n-\t\t\t       + STACK_BYTES - 1)\n-\t\t\t      / STACK_BYTES * STACK_BYTES)\n+\t\t\t       + preferred_stack_boundary - 1)\n+\t\t\t      / preferred_stack_boundary\n+\t\t\t      * preferred_stack_boundary)\n \t\t\t     - pending_stack_adjust);\n #endif\n \n@@ -1692,6 +1698,14 @@ expand_call (exp, target, ignore)\n   rtx call_fusage = 0;\n   register tree p;\n   register int i;\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  int preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+#else\n+  /* In this case preferred_stack_boundary variable is meaningless.\n+     It is used only in order to keep ifdef noise down when calling\n+     compute_argument_block_size.  */\n+  int preferred_stack_boundary = 0;\n+#endif\n \n   /* The value of the function call can be put in a hard register.  But\n      if -fcheck-memory-usage, code which invokes functions (and thus\n@@ -1921,6 +1935,13 @@ expand_call (exp, target, ignore)\n   if (fndecl && DECL_NAME (fndecl))\n     name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n \n+  /* Ensure current function's preferred stack boundary is at least\n+     what we need.  We don't have to increase alignment for recursive\n+     functions.  */\n+  if (cfun->preferred_stack_boundary < preferred_stack_boundary\n+      && fndecl != current_function_decl)\n+    cfun->preferred_stack_boundary = preferred_stack_boundary;\n+\n   /* See if this is a call to a function that can return more than once\n      or a call to longjmp or malloc.  */\n   special_function_p (fndecl, &returns_twice, &is_longjmp, &fork_or_exec,\n@@ -2062,7 +2083,8 @@ expand_call (exp, target, ignore)\n      and constant sizes must be combined, the size may have to be rounded,\n      and there may be a minimum required size.  */\n   unadjusted_args_size\n-    = compute_argument_block_size (reg_parm_stack_space, &args_size);\n+    = compute_argument_block_size (reg_parm_stack_space, &args_size,\n+\t\t\t\t   preferred_stack_boundary);\n \n   /* Now make final decision about preallocating stack space.  */\n   must_preallocate = finalize_must_preallocate (must_preallocate,\n@@ -2703,6 +2725,13 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n   push_temp_slots ();\n \n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* Ensure current function's preferred stack boundary is at least\n+     what we need.  */\n+  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+#endif\n+\n   for (count = 0; count < nargs; count++)\n     {\n       rtx val = va_arg (p, rtx);\n@@ -3192,6 +3221,13 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n   is_const = no_queue;\n   fun = orgfun;\n \n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* Ensure current function's preferred stack boundary is at least\n+     what we need.  */\n+  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+#endif\n+\n   /* If this kind of value comes back in memory,\n      decide where in memory it should come back.  */\n   if (aggregate_value_p (type_for_mode (outmode, 0)))"}, {"sha": "1e5e44ed73ec1fcb8df9b6297c6abbef85f11122", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -1776,7 +1776,7 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n #ifdef PREFERRED_STACK_BOUNDARY\n   {\n     int offset;\n-    int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+    int preferred_alignment = cfun->preferred_stack_boundary / BITS_PER_UNIT;\n \n     offset = frame_pointer_needed ? 8 : 4;\n "}, {"sha": "5883adaee81daece7dc9bea47b09ae63fd8df538", "filename": "gcc/explow.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -1178,6 +1178,13 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n     size = convert_to_mode (Pmode, size, 1);\n \n+  /* We can't attempt to minimize alignment necessary, because we don't\n+     know the final value of preferred_stack_boundary yet while executing\n+     this code.  */\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+#endif\n+\n   /* We will need to ensure that the address we return is aligned to\n      BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't\n      always know its final value at this point in the compilation (it "}, {"sha": "6945b6b53e0fb60ee12e9aa2eee861eb024713e8", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -5686,6 +5686,9 @@ prepare_function_start ()\n   cfun->original_arg_vector = 0;  \n \n   cfun->stack_alignment_needed = 0;\n+#ifdef STACK_BOUNDARY\n+  cfun->preferred_stack_boundary = STACK_BOUNDARY;\n+#endif\n \n   /* Set if a call to setjmp is seen.  */\n   current_function_calls_setjmp = 0;"}, {"sha": "5783c22b6ff86ee9e4992cca44f386f48ff88812", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -456,6 +456,8 @@ struct function\n   struct machine_function *machine;\n   /* The largest alignment of slot allocated on the stack.  */\n   int stack_alignment_needed;\n+  /* Preferred alignment of the end of stack frame.  */\n+  int preferred_stack_boundary;\n \n   /* Language-specific code can use this to store whatever it likes.  */\n   struct language_function *language;"}, {"sha": "865b4bb6faadcb537ec953d2106ff496b2c0443f", "filename": "gcc/integrate.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2f8b491493226d196fc80a9f0d4856612c52992/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c2f8b491493226d196fc80a9f0d4856612c52992", "patch": "@@ -602,6 +602,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   nargs = list_length (DECL_ARGUMENTS (fndecl));\n \n+  if (cfun->preferred_stack_boundary < inl_f->preferred_stack_boundary)\n+    cfun->preferred_stack_boundary = inl_f->preferred_stack_boundary;\n+\n+  if (cfun->stack_alignment_needed < inl_f->stack_alignment_needed)\n+    cfun->stack_alignment_needed = inl_f->stack_alignment_needed;\n+\n   /* Check that the parms type match and that sufficient arguments were\n      passed.  Since the appropriate conversions or default promotions have\n      already been applied, the machine modes should match exactly.  */\n@@ -1619,13 +1625,17 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t    {\n \t      rtx loc, seq;\n \t      int size = get_func_frame_size (DECL_SAVED_INSNS (map->fndecl));\n+\t      int alignment\n+\t\t= (DECL_SAVED_INSNS (map->fndecl)->stack_alignment_needed\n+\t\t   / BITS_PER_UNIT);\n \n #ifdef FRAME_GROWS_DOWNWARD\n \t      /* In this case, virtual_stack_vars_rtx points to one byte\n \t\t higher than the top of the frame area.  So make sure we\n \t\t allocate a big enough chunk to keep the frame pointer\n \t\t aligned like a real one.  */\n-\t      size = CEIL_ROUND (size, BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n+\t      if (alignment)\n+\t\tsize = CEIL_ROUND (size, alignment);\n #endif\n \t      start_sequence ();\n \t      loc = assign_stack_temp (BLKmode, size, 1);"}]}