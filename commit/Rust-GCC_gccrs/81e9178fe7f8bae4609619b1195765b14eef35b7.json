{"sha": "81e9178fe7f8bae4609619b1195765b14eef35b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFlOTE3OGZlN2Y4YmFlNDYwOTYxOWIxMTk1NzY1YjE0ZWVmMzViNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-09-07T13:41:49Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-09-07T13:42:51Z"}, "message": "Fix PR debug/101947\n\nThis is the recent LTO bootstrap failure with Ada enabled.  The compiler now\ngenerates DW_OP_deref_type for a unit of the Ada front-end, which means that\nthe offset of base types in the CU must be computed during early DWARF too.\n\ngcc/\n\tPR debug/101947\n\t* dwarf2out.c (mark_base_types): New overloaded function.\n\t(dwarf2out_early_finish): Invoke it on the COMDAT type list as well\n\tas the compilation unit, and call move_marked_base_types afterward.", "tree": {"sha": "b37377c3c0fa7038f408a9de52d545d54fcf77e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37377c3c0fa7038f408a9de52d545d54fcf77e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81e9178fe7f8bae4609619b1195765b14eef35b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e9178fe7f8bae4609619b1195765b14eef35b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81e9178fe7f8bae4609619b1195765b14eef35b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e9178fe7f8bae4609619b1195765b14eef35b7/comments", "author": null, "committer": null, "parents": [{"sha": "ad9fcb961c0705f56907a728c3748c011a0a8048", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9fcb961c0705f56907a728c3748c011a0a8048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad9fcb961c0705f56907a728c3748c011a0a8048"}], "stats": {"total": 52, "additions": 44, "deletions": 8}, "files": [{"sha": "fbad269b566716b6b946309771f6421835322f18", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81e9178fe7f8bae4609619b1195765b14eef35b7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81e9178fe7f8bae4609619b1195765b14eef35b7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=81e9178fe7f8bae4609619b1195765b14eef35b7", "patch": "@@ -30295,6 +30295,40 @@ mark_base_types (dw_loc_descr_ref loc)\n     }\n }\n \n+/* Stripped-down variant of resolve_addr, mark DW_TAG_base_type nodes\n+   referenced from typed stack ops and count how often they are used.  */\n+\n+static void\n+mark_base_types (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_node *a;\n+  dw_loc_list_ref *curr;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    switch (AT_class (a))\n+      {\n+      case dw_val_class_loc_list:\n+\tcurr = AT_loc_list_ptr (a);\n+\twhile (*curr)\n+\t  {\n+\t    mark_base_types ((*curr)->expr);\n+\t    curr = &(*curr)->dw_loc_next;\n+\t  }\n+\tbreak;\n+\n+      case dw_val_class_loc:\n+\tmark_base_types (AT_loc (a));\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  FOR_EACH_CHILD (die, c, mark_base_types (c));\n+}\n+\n /* Comparison function for sorting marked base types.  */\n \n static int\n@@ -32697,6 +32731,7 @@ ctf_debug_do_cu (dw_die_ref die)\n static void\n dwarf2out_early_finish (const char *filename)\n {\n+  comdat_type_node *ctnode;\n   set_early_dwarf s;\n   char dl_section_ref[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -32776,8 +32811,7 @@ dwarf2out_early_finish (const char *filename)\n       /* For each new comdat type unit, copy declarations for incomplete\n          types to make the new unit self-contained (i.e., no direct\n          references to the main compile unit).  */\n-      for (comdat_type_node *ctnode = comdat_type_list;\n-\t   ctnode != NULL; ctnode = ctnode->next)\n+      for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n         copy_decls_for_unworthy_types (ctnode->root_die);\n       copy_decls_for_unworthy_types (comp_unit_die ());\n \n@@ -32792,8 +32826,7 @@ dwarf2out_early_finish (const char *filename)\n   note_variable_value (comp_unit_die ());\n   for (limbo_die_node *node = cu_die_list; node; node = node->next)\n     note_variable_value (node->die);\n-  for (comdat_type_node *ctnode = comdat_type_list; ctnode != NULL;\n-       ctnode = ctnode->next)\n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     note_variable_value (ctnode->root_die);\n   for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n     note_variable_value (node->die);\n@@ -32845,13 +32878,17 @@ dwarf2out_early_finish (const char *filename)\n      location related output removed and some LTO specific changes.\n      Some refactoring might make both smaller and easier to match up.  */\n \n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n+    mark_base_types (ctnode->root_die);\n+  mark_base_types (comp_unit_die ());\n+  move_marked_base_types ();\n+\n   /* Traverse the DIE's and add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die ());\n   for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n     add_sibling_attributes (node->die);\n-  for (comdat_type_node *ctnode = comdat_type_list;\n-       ctnode != NULL; ctnode = ctnode->next)\n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     add_sibling_attributes (ctnode->root_die);\n \n   /* AIX Assembler inserts the length, so adjust the reference to match the\n@@ -32881,8 +32918,7 @@ dwarf2out_early_finish (const char *filename)\n     output_comp_unit (node->die, 0, NULL);\n \n   hash_table<comdat_type_hasher> comdat_type_table (100);\n-  for (comdat_type_node *ctnode = comdat_type_list;\n-       ctnode != NULL; ctnode = ctnode->next)\n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     {\n       comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);\n "}]}