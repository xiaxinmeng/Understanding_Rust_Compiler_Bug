{"sha": "f8ed6dc529088cab9d586e9b3f06492e27f862fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlZDZkYzUyOTA4OGNhYjlkNTg2ZTliM2YwNjQ5MmUyN2Y4NjJmYw==", "commit": {"author": {"name": "Jeremie Salvucci", "email": "jeremie.salvucci@free.fr", "date": "2010-10-14T13:56:12Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-10-14T13:56:12Z"}, "message": "gengtype.c: Include getopt.h and version.h.\n\n2010-10-14  Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\t    Basile Starynkevitch  <basile@starynkevitch.net>\n\n\t* gcc/gengtype.c:  Include getopt.h and version.h.\n\n\t(lang_bitmap, struct outf, outf_p)\n\t(get_output_file_with_visibility, oprintf): Definitions moved to\n\tgengtype.h\n\t(output_files, header_file, srcdir, srcdir_len, this_file)\n\t(do_dump): No more static variables.\n\t(do_debug): New.\n\t(dbgprint_count_type_at): Added new function.\n\t(gengtype_long_options): New.\n\t(print_usage, print_version, parse_program_options): New.\n\t(main): Call parse_program_options, and removed old option\n\thandling code.  Added some debug output.\n\n\t* gcc/gengtype.h:  Updated copyright year.\n\t(lang_bitmap, struct outf, outf_p, header_file, oprintf)\n\t(get_output_file_with_visibility, srcdir, srcdir_len, do_dump):\n\tMoved from gengtype.c to here.\n\t(do_debug, read_state_filename, write_state_filename): New\n\tvariables. (DBGPRINTF, DBGPRINT_COUNT_TYPE): New macros.\n\n\t* gcc/Makefile.in:\n\t(REVISION): Always defined.\n\t(version.o): Removed ifdef REVISION_c.\n\t(s-gtype): Pass arguments to build/gengtype program.\n\t(build/version.o): Added building rule.\n\t(build/gengtype$(build_exeext)): Added build/version.o.\n\n\nCo-Authored-By: Basile Starynkevitch <basile@starynkevitch.net>\n\nFrom-SVN: r165470", "tree": {"sha": "1d3285b2f57ab16f7f07a313761dda7c317de69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d3285b2f57ab16f7f07a313761dda7c317de69a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8ed6dc529088cab9d586e9b3f06492e27f862fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ed6dc529088cab9d586e9b3f06492e27f862fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ed6dc529088cab9d586e9b3f06492e27f862fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ed6dc529088cab9d586e9b3f06492e27f862fc/comments", "author": null, "committer": null, "parents": [{"sha": "560d6bd5b53d6e9b92cf25b9dcb53590f830c45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/560d6bd5b53d6e9b92cf25b9dcb53590f830c45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/560d6bd5b53d6e9b92cf25b9dcb53590f830c45e"}], "stats": {"total": 582, "additions": 453, "deletions": 129}, "files": [{"sha": "6c92f30f0a0d79cadc1cee55453a4e19a7a8a6bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8ed6dc529088cab9d586e9b3f06492e27f862fc", "patch": "@@ -1,3 +1,34 @@\n+2010-10-14  Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\t    Basile Starynkevitch  <basile@starynkevitch.net>\n+\n+\t* gengtype.c:  Include getopt.h and version.h.\n+\n+\t(lang_bitmap, struct outf, outf_p)\n+\t(get_output_file_with_visibility, oprintf): Definitions moved to\n+\tgengtype.h\n+\t(output_files, header_file, srcdir, srcdir_len, this_file)\n+\t(do_dump): No more static variables.\n+\t(do_debug): New.\n+\t(dbgprint_count_type_at): Added new function.\n+\t(gengtype_long_options): New.\n+\t(print_usage, print_version, parse_program_options): New.\n+\t(main): Call parse_program_options, and removed old option\n+\thandling code.  Added some debug output.\n+\n+\t* gengtype.h:  Updated copyright year.\n+\t(lang_bitmap, struct outf, outf_p, header_file, oprintf)\n+\t(get_output_file_with_visibility, srcdir, srcdir_len, do_dump):\n+\tMoved from gengtype.c to here.\n+\t(do_debug, read_state_filename, write_state_filename): New\n+\tvariables. (DBGPRINTF, DBGPRINT_COUNT_TYPE): New macros.\n+\n+\t* Makefile.in:\n+\t(REVISION): Always defined.\n+\t(version.o): Removed ifdef REVISION_c.\n+\t(s-gtype): Pass arguments to build/gengtype program.\n+\t(build/version.o): Added building rule.\n+\t(build/gengtype$(build_exeext)): Added build/version.o.\n+\n 2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPartial merge of 'ObjC GC' from FSF apple 'trunk' branch."}, {"sha": "fd27cf740376da6b889ce579cb32dd5d5f72ede2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f8ed6dc529088cab9d586e9b3f06492e27f862fc", "patch": "@@ -837,6 +837,7 @@ DATESTAMP_c := $(shell cat $(DATESTAMP))\n \n ifeq (,$(wildcard $(REVISION)))\n REVISION_c  :=\n+REVISION    :=\n else\n REVISION_c  := $(shell cat $(REVISION))\n endif\n@@ -2249,11 +2250,7 @@ gcc-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) opts.h intl\n \n dumpvers: dumpvers.c\n \n-ifdef REVISION_c\n version.o: version.c version.h $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)\n-else\n-version.o: version.c version.h $(DATESTAMP) $(BASEVER) $(DEVPHASE)\n-endif\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n \t-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \\\n \t-DREVISION=$(REVISION_s) \\\n@@ -3807,7 +3804,7 @@ s-gtyp-input: Makefile\n \n s-gtype: build/gengtype$(build_exeext) $(filter-out [%], $(GTFILES)) \\\n \t gtyp-input.list\n-\t$(RUN_GEN) build/gengtype$(build_exeext) $(srcdir) gtyp-input.list\n+\t$(RUN_GEN) build/gengtype$(build_exeext) -S $(srcdir) -I gtyp-input.list\n \t$(STAMP) s-gtype\n \n generated_files = config.h tm.h $(TM_P_H) $(TM_H) multilib.h \\\n@@ -3827,6 +3824,16 @@ build/%.o :  # dependencies provided by explicit rule later\n \t$(COMPILER_FOR_BUILD) -c $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) \\\n \t\t-o $@ $<\n \n+## build/version.o is compiled by the $(COMPILER_FOR_BUILD) but needs\n+## several C macro definitions, just like version.o\n+build/version.o:  version.c version.h \\\n+                  $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)\n+\t$(COMPILER_FOR_BUILD) -c $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) \\\n+\t-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \\\n+\t-DREVISION=$(REVISION_s) \\\n+\t-DDEVPHASE=$(DEVPHASE_s) -DPKGVERSION=$(PKGVERSION_s) \\\n+\t-DBUGURL=$(BUGURL_s) -o $@ $<\n+\n # Header dependencies for the programs that generate source code.\n # These are library modules...\n build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h\n@@ -3936,7 +3943,8 @@ genprog = $(genprogerr) check checksum condmd\n build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n # These programs are not linked with the MD reader.\n-build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o\n+build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \\\n+              build/version.o\n \n # Rule for the generator programs:\n $(genprog:%=build/gen%$(build_exeext)): build/gen%$(build_exeext): build/gen%.o $(BUILD_LIBDEPS)"}, {"sha": "612d21ba9ef1a74256d95da7513f248870d6e8b9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 339, "deletions": 119, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=f8ed6dc529088cab9d586e9b3f06492e27f862fc", "patch": "@@ -20,10 +20,12 @@\n \n #include \"bconfig.h\"\n #include \"system.h\"\n-#include \"gengtype.h\"\n #include \"errors.h\"\t\t/* for fatal */\n+#include \"getopt.h\"\n #include \"double-int.h\"\n+#include \"version.h\"\t\t/* for version_string & pkgversion_string.  */\n #include \"hashtab.h\"\n+#include \"gengtype.h\"\n \n /* Data types, macros, etc. used only in this file.  */\n \n@@ -40,7 +42,6 @@ enum typekind\n   TYPE_PARAM_STRUCT\n };\n \n-typedef unsigned lang_bitmap;\n \n /* A way to pass data through to the output end.  */\n struct options\n@@ -117,55 +118,50 @@ struct type\n };\n \n #define UNION_P(x)\t\t\t\t\t\\\n-  ((x)->kind == TYPE_UNION || \t\t\t\t\\\n-   ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n-    && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+ ((x)->kind == TYPE_UNION || \t\t\t\t\\\n+  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n+   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n #define UNION_OR_STRUCT_P(x)\t\t\t\\\n-  ((x)->kind == TYPE_UNION \t\t\t\\\n-   || (x)->kind == TYPE_STRUCT \t\t\t\\\n-   || (x)->kind == TYPE_LANG_STRUCT)\n+ ((x)->kind == TYPE_UNION \t\t\t\\\n+  || (x)->kind == TYPE_STRUCT \t\t\t\\\n+  || (x)->kind == TYPE_LANG_STRUCT)\n+\n \n-/* Structure representing an output file.  */\n-struct outf\n-{\n-  struct outf *next;\n-  const char *name;\n-  size_t buflength;\n-  size_t bufused;\n-  char *buf;\n-};\n-typedef struct outf *outf_p;\n \n-/* An output file, suitable for definitions, that can see declarations\n-   made in INPUT_FILE and is linked into every language that uses\n-   INPUT_FILE.  May return NULL in plugin mode. */\n-extern outf_p get_output_file_with_visibility (const char *input_file);\n const char *get_output_file_name (const char *);\n \n-/* Print, like fprintf, to O.  No-op if O is NULL. */\n-static void\n-oprintf (outf_p o, const char *S, ...)\n-  ATTRIBUTE_PRINTF_2;\n \n /* The list of output files.  */\n-static outf_p output_files;\n+outf_p output_files;\n+\n+/* The output header file that is included into pretty much every\n+   source file.  */\n+outf_p header_file;\n+\n+\n+/* The name of the file containing the list of input files.  */\n+static char *inputlist;\n \n /* The plugin input files and their number; in that case only\n    a single file is produced.  */\n static char **plugin_files;\n static size_t nb_plugin_files;\n-/* the generated plugin output name & file */\n+\n+/* The generated plugin output file and name.  */\n static outf_p plugin_output;\n+static char *plugin_output_filename;\n \n-/* The output header file that is included into pretty much every\n-   source file.  */\n-static outf_p header_file;\n+/* Our source directory and its length.  */\n+const char *srcdir;\n+size_t srcdir_len;\n \n-/* Source directory.  */\n-static const char *srcdir;\n+/* Variables used for reading and writing the state.  */\n+const char *read_state_filename;\n+const char *write_state_filename;\n \n-/* Length of srcdir name.  */\n-static size_t srcdir_len = 0;\n+/* Variables to help debugging.  */\n+int do_dump;\n+int do_debug;\n \n static outf_p create_file (const char *, const char *);\n \n@@ -225,10 +221,12 @@ xasprintf (const char *format, ...)\n static const char **gt_files;\n static size_t num_gt_files;\n \n-/* A number of places use the name of this file for a location for\n-   things that we can't rely on the source to define.  Make sure we\n-   can still use pointer comparison on filenames.  */\n-static const char this_file[] = __FILE__;\n+/* A number of places use the name of this \"gengtype.h\" file for a\n+   location for things that we can't rely on the source to define.\n+   Make sure we can still use pointer comparison on filenames.  */\n+const char this_file[] = __FILE__;\n+/* The \"system.h\" file is likewise specially useful.  */\n+const char system_h_file[] = \"system.h\";\n \n /* Vector of per-language directories.  */\n static const char **lang_dir_names;\n@@ -254,9 +252,13 @@ static lang_bitmap\n get_lang_bitmap (const char *gtfile)\n {\n \n-  if (gtfile == this_file)\n-    /* Things defined in this file are universal.  */\n-    return (((lang_bitmap) 1) << num_lang_dirs) - 1;\n+  if (gtfile == this_file || gtfile == system_h_file)\n+    {\n+      /* Things defined in this \"gengtype.c\" file or in \"system.h\" are\n+\t universal (and there is no space for their lang_bitmap before\n+\t their file names).  */\n+      return (((lang_bitmap) 1) << num_lang_dirs) - 1;\n+    }\n   else\n     {\n       lang_bitmap n = 0;\n@@ -280,6 +282,65 @@ set_lang_bitmap (char *gtfile, lang_bitmap n)\n     }\n }\n \n+\n+#if ENABLE_CHECKING\n+/* Utility debugging function, printing the various type counts within\n+   a list of types.  Called thru the DBGPRINT_COUNT_TYPE macro.  */\n+void\n+dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n+{\n+  int nb_types = 0, nb_scalar = 0, nb_string = 0;\n+  int nb_struct = 0, nb_union = 0, nb_array = 0, nb_pointer = 0;\n+  int nb_lang_struct = 0, nb_param_struct = 0;\n+  type_p p = NULL;\n+  for (p = t; p; p = p->next)\n+    {\n+      nb_types++;\n+      switch (p->kind)\n+\t{\n+\tcase TYPE_SCALAR:\n+\t  nb_scalar++;\n+\t  break;\n+\tcase TYPE_STRING:\n+\t  nb_string++;\n+\t  break;\n+\tcase TYPE_STRUCT:\n+\t  nb_struct++;\n+\t  break;\n+\tcase TYPE_UNION:\n+\t  nb_union++;\n+\t  break;\n+\tcase TYPE_POINTER:\n+\t  nb_pointer++;\n+\t  break;\n+\tcase TYPE_ARRAY:\n+\t  nb_array++;\n+\t  break;\n+\tcase TYPE_LANG_STRUCT:\n+\t  nb_lang_struct++;\n+\t  break;\n+\tcase TYPE_PARAM_STRUCT:\n+\t  nb_param_struct++;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  fprintf (stderr, \"\\n\" \"%s:%d: %s: @@%%@@ %d types ::\\n\",\n+\t   lbasename (fil), lin, msg, nb_types);\n+  if (nb_scalar > 0 || nb_string > 0)\n+    fprintf (stderr, \"@@%%@@ %d scalars, %d strings\\n\", nb_scalar, nb_string);\n+  if (nb_struct > 0 || nb_union > 0)\n+    fprintf (stderr, \"@@%%@@ %d structs, %d unions\\n\", nb_struct, nb_union);\n+  if (nb_pointer > 0 || nb_array > 0)\n+    fprintf (stderr, \"@@%%@@ %d pointers, %d arrays\\n\", nb_pointer, nb_array);\n+  if (nb_lang_struct > 0 || nb_param_struct > 0)\n+    fprintf (stderr, \"@@%%@@ %d lang_structs, %d param_structs\\n\",\n+\t     nb_lang_struct, nb_param_struct);\n+  fprintf (stderr, \"\\n\");\n+}\n+#endif /* ENABLE_CHECKING */\n+\n /* Scan the input file, LIST, and determine how much space we need to\n    store strings in.  Also, count the number of language directories\n    and files.  The numbers returned are overestimates as they does not\n@@ -864,7 +925,7 @@ create_field_at (pair_p next, type_p type, const char *name, options_p opt,\n /* Create a fake field with the given type and name.  NEXT is the next\n    field in the chain.  */\n #define create_field(next,type,name) \\\n-  create_field_all(next,type,name, 0, this_file, __LINE__)\n+    create_field_all(next,type,name, 0, this_file, __LINE__)\n \n /* Like create_field, but the field is only valid when condition COND\n    is true.  */\n@@ -893,7 +954,7 @@ create_optional_field_ (pair_p next, type_p type, const char *name,\n }\n \n #define create_optional_field(next,type,name,cond)\t\\\n-  create_optional_field_(next,type,name,cond,__LINE__)\n+       create_optional_field_(next,type,name,cond,__LINE__)\n \n /* Reverse a linked list of 'struct pair's in place.  */\n pair_p\n@@ -3230,13 +3291,13 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n /* Write out to F the table entry and any marker routines needed to\n    mark NAME as TYPE.  V can be one of three values:\n \n-   - null, if NAME is too complex to represent using a single\n-   count and stride.  In this case, it is an error for NAME to\n-   contain any gc-ed data.\n+     - null, if NAME is too complex to represent using a single\n+       count and stride.  In this case, it is an error for NAME to\n+       contain any gc-ed data.\n \n-   - the outermost array that contains NAME, if NAME is part of an array.\n+     - the outermost array that contains NAME, if NAME is part of an array.\n \n-   - the C variable that contains NAME, if NAME is not part of an array.\n+     - the C variable that contains NAME, if NAME is not part of an array.\n \n    LINE is the line of the C source that declares the root variable.\n    HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED\n@@ -3732,7 +3793,7 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n    we had expanded the macros in vec.h:\n \n    typedef struct VEC_<type>_<astrat> {\n-   VEC_<type>_base base;\n+     VEC_<type>_base base;\n    } VEC_<type>_<astrat>;\n */\n void\n@@ -4223,100 +4284,264 @@ dump_everything (void)\n }\n \f\n \n+\n+/* Option specification for getopt_long.  */\n+static const struct option gengtype_long_options[] = {\n+  {\"help\", no_argument, NULL, 'h'},\n+  {\"version\", no_argument, NULL, 'V'},\n+  {\"dump\", no_argument, NULL, 'd'},\n+  {\"debug\", no_argument, NULL, 'D'},\n+  {\"plugin\", required_argument, NULL, 'P'},\n+  {\"srcdir\", required_argument, NULL, 'S'},\n+  {\"inputs\", required_argument, NULL, 'I'},\n+  {\"read-state\", required_argument, NULL, 'r'},\n+  {\"write-state\", required_argument, NULL, 'w'},\n+  /* Terminating NULL placeholder.  */\n+  {NULL, no_argument, NULL, 0},\n+};\n+\n+\n+static void\n+print_usage (void)\n+{\n+  printf (\"Usage: %s\\n\", progname);\n+  printf (\"\\t -h | --help \" \" \\t# Give this help.\\n\");\n+  printf (\"\\t -D | --debug \"\n+\t  \" \\t# Give debug output to debug %s itself.\\n\", progname);\n+  printf (\"\\t -V | --version \" \" \\t# Give version information.\\n\");\n+  printf (\"\\t -d | --dump \" \" \\t# Dump state for debugging.\\n\");\n+  printf (\"\\t -P | --plugin <output-file> <plugin-src> ... \"\n+\t  \" \\t# Generate for plugin.\\n\");\n+  printf (\"\\t -S | --srcdir <GCC-directory> \"\n+\t  \" \\t# Specify the GCC source directory.\\n\");\n+  printf (\"\\t -I | --inputs <input-list> \"\n+\t  \" \\t# Specify the file with source files list.\\n\");\n+  printf (\"\\t -w | --write-state <state-file> \" \" \\t# Write a state file.\\n\");\n+  printf (\"\\t -r | --read-state <state-file> \" \" \\t# Read a state file.\\n\");\n+}\n+\n+static void\n+print_version (void)\n+{\n+  printf (\"%s %s%s\\n\", progname, pkgversion_string, version_string);\n+  printf (\"Report bugs: %s\\n\", bug_report_url);\n+}\n+\n+/* Parse the program options using getopt_long... */\n+static void\n+parse_program_options (int argc, char **argv)\n+{\n+  int opt = -1;\n+  while ((opt = getopt_long (argc, argv, \"hVdP:S:I:w:r:D\",\n+\t\t\t     gengtype_long_options, NULL)) >= 0)\n+    {\n+      switch (opt)\n+\t{\n+\tcase 'h':\t\t/* --help */\n+\t  print_usage ();\n+\t  break;\n+\tcase 'V':\t\t/* --version */\n+\t  print_version ();\n+\t  break;\n+\tcase 'd':\t\t/* --dump */\n+\t  do_dump = 1;\n+\t  break;\n+\tcase 'D':\t\t/* --debug */\n+\t  do_debug = 1;\n+\t  break;\n+\tcase 'P':\t\t/* --plugin */\n+\t  if (optarg)\n+\t    plugin_output_filename = optarg;\n+\t  else\n+\t    fatal (\"missing plugin output file name\");\n+\t  break;\n+\tcase 'S':\t\t/* --srcdir */\n+\t  if (optarg)\n+\t    srcdir = optarg;\n+\t  else\n+\t    fatal (\"missing source directory\");\n+\t  srcdir_len = strlen (srcdir);\n+\t  break;\n+\tcase 'I':\t\t/* --inputs */\n+\t  if (optarg)\n+\t    inputlist = optarg;\n+\t  else\n+\t    fatal (\"missing input list\");\n+\t  break;\n+\tcase 'r':\t\t/* --read-state */\n+\t  if (optarg)\n+\t    read_state_filename = optarg;\n+\t  else\n+\t    fatal (\"missing read state file\");\n+\t  DBGPRINTF (\"read state %s\\n\", optarg);\n+\t  break;\n+\tcase 'w':\t\t/* --write-state */\n+\t  DBGPRINTF (\"write state %s\\n\", optarg);\n+\t  if (optarg)\n+\t    write_state_filename = optarg;\n+\t  else\n+\t    fatal (\"missing write state file\");\n+\t  break;\n+\tdefault:\n+\t  fprintf (stderr, \"%s: unknown flag '%c'\\n\", progname, opt);\n+\t  print_usage ();\n+\t  fatal (\"unexpected flag\");\n+\t}\n+    };\n+  if (plugin_output_filename)\n+    {\n+      /* In plugin mode we require some input files.  */\n+      int i = 0;\n+      if (optind >= argc)\n+\tfatal (\"no source files given in plugin mode\");\n+      nb_plugin_files = argc - optind;\n+      for (i = 0; i < (int) nb_plugin_files; i++)\n+\t{\n+\t  char *name = argv[i + optind];\n+\t  plugin_files[i] = name;\n+\t}\n+    }\n+}\n+\n+\n int\n main (int argc, char **argv)\n {\n   size_t i;\n-  static struct fileloc pos = { this_file, 0 };\n-  char *inputlist = 0;\n-  int do_dump = 0;\n+  static struct fileloc pos = { NULL, 0 };\n   outf_p output_header;\n-  char *plugin_output_filename = NULL;\n-  /* fatal uses this */\n-  progname = \"gengtype\";\n \n-  if (argc >= 2 && !strcmp (argv[1], \"-d\"))\n+  /* Mandatory common initializations.  */\n+  progname = \"gengtype\";\t/* For fatal and messages.  */\n+  /* Set the scalar_is_char union number for predefined scalar types.  */\n+  scalar_nonchar.u.scalar_is_char = FALSE;\n+  scalar_char.u.scalar_is_char = TRUE;\n+\n+  parse_program_options (argc, argv);\n+\n+#if ENABLE_CHECKING\n+  if (do_debug)\n     {\n-      do_dump = 1;\n-      argv = &argv[1];\n-      argc--;\n+      time_t now = (time_t) 0;\n+      time (&now);\n+      DBGPRINTF (\"gengtype started pid %d at %s\",\n+\t\t (int) getpid (), ctime (&now));\n     }\n+#endif\t/* ENABLE_CHECKING */\n \n-  if (argc >= 6 && !strcmp (argv[1], \"-P\"))\n+  /* Parse the input list and the input files.  */\n+  DBGPRINTF (\"inputlist %s\", inputlist);\n+  if (read_state_filename)\n     {\n-      plugin_output_filename = argv[2];\n-      plugin_output = create_file (\"GCC\", plugin_output_filename);\n-      srcdir = argv[3];\n-      inputlist = argv[4];\n-      nb_plugin_files = argc - 5;\n-      plugin_files = XCNEWVEC (char *, nb_plugin_files);\n-      for (i = 0; i < nb_plugin_files; i++)\n-\t{\n-\t  /* Place an all zero lang_bitmap before the plugin file\n-\t     name.  */\n-\t  char *name = argv[i + 5];\n-\t  int len = strlen (name) + 1 + sizeof (lang_bitmap);\n-\t  plugin_files[i] = XCNEWVEC (char, len) + sizeof (lang_bitmap);\n-\t  strcpy (plugin_files[i], name);\n-\t}\n+      fatal (\"read state %s not implemented yet\", read_state_filename);\n+      /* TODO: implement read state.  */\n     }\n-  else if (argc == 3)\n+  else if (inputlist)\n     {\n-      srcdir = argv[1];\n-      inputlist = argv[2];\n+      /* These types are set up with #define or else outside of where\n+         we can see them.  We should initialize them before calling\n+         read_input_list.  */\n+      pos.file = this_file;\n+      pos.line = __LINE__ + 1;\n+      do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"double_int\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"uint64_t\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"uint8\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"jword\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"JCF_u2\", &pos);\n+      pos.line++;\n+      do_scalar_typedef (\"void\", &pos);\n+      pos.line++;\n+      do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)),\n+\t\t  &pos);\n+      read_input_list (inputlist);\n+      for (i = 0; i < num_gt_files; i++)\n+\t{\n+\t  parse_file (gt_files[i]);\n+\t  DBGPRINTF (\"parsed file #%d %s\", (int) i, gt_files[i]);\n+\t}\n+      DBGPRINT_COUNT_TYPE (\"structures after parsing\", structures);\n+      DBGPRINT_COUNT_TYPE (\"param_structs after parsing\", param_structs);\n+\n     }\n   else\n-    fatal (\"usage: gengtype [-d] [-P pluginout.h] srcdir input-list \"\n-\t   \"[file1 file2 ... fileN]\");\n-\n-  srcdir_len = strlen (srcdir);\n-\n-  read_input_list (inputlist);\n+    fatal (\"either an input list or a read state file should be given\");\n   if (hit_error)\n     return 1;\n \n-  scalar_char.u.scalar_is_char = true;\n-  scalar_nonchar.u.scalar_is_char = false;\n-  gen_rtx_next ();\n \n-  /* These types are set up with #define or else outside of where\n-     we can see them.  */\n-  pos.line = __LINE__ + 1;\n-  do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"double_int\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"uint64_t\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"uint8\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"jword\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"JCF_u2\", &pos);\n-  pos.line++;\n-  do_scalar_typedef (\"void\", &pos);\n-  pos.line++;\n-  do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)), &pos);\n-\n-  for (i = 0; i < num_gt_files; i++)\n-    parse_file (gt_files[i]);\n+  if (plugin_output_filename)\n+    {\n+      size_t ix = 0;\n+      /* In plugin mode, we should have read a state file, and have\n+         given at least one plugin file.  */\n+      if (!read_state_filename)\n+\tfatal (\"No read state given in plugin mode for %s\",\n+\t       plugin_output_filename);\n+\n+      if (nb_plugin_files <= 0 || !plugin_files)\n+\tfatal (\"No plugin files given in plugin mode for %s\",\n+\t       plugin_output_filename);\n+\n+      /* Parse our plugin files.  */\n+      for (ix = 0; ix < nb_plugin_files; ix++)\n+\tparse_file (plugin_files[ix]);\n+\n+      if (hit_error)\n+\treturn 1;\n \n+      plugin_output = create_file (\"GCC\", plugin_output_filename);\n+      DBGPRINTF (\"created plugin_output %p named %s\",\n+\t\t (void *) plugin_output, plugin_output->name);\n+    }\n+  else\n+    {\t\t\t\t/* No plugin files, we are in normal mode.  */\n+      if (!srcdir)\n+\tfatal (\"gengtype needs a source directory in normal mode\");\n+    }\n   if (hit_error)\n     return 1;\n \n+  gen_rtx_next ();\n+\n+  /* The call to set_gc_used may indirectly call find_param_structure\n+     hence enlarge the param_structs list of types.  */\n   set_gc_used (variables);\n \n+  /* We should write the state here, but it is not yet implemented.  */\n+  if (write_state_filename)\n+    {\n+      fatal (\"write state %s in not yet implemented\", write_state_filename);\n+      /* TODO: implement write state.  */\n+    }\n+\n+\n   open_base_files ();\n+\n   write_enum_defn (structures, param_structs);\n   write_typed_alloc_defns (structures, typedefs);\n   output_header = plugin_output ? plugin_output : header_file;\n+  DBGPRINT_COUNT_TYPE (\"structures before write_types outputheader\",\n+\t\t       structures);\n+  DBGPRINT_COUNT_TYPE (\"param_structs before write_types outputheader\",\n+\t\t       param_structs);\n+\n   write_types (output_header, structures, param_structs, &ggc_wtd);\n   if (plugin_files == NULL)\n     {\n+      DBGPRINT_COUNT_TYPE (\"structures before write_types headerfil\",\n+\t\t\t   structures);\n+      DBGPRINT_COUNT_TYPE (\"param_structs before write_types headerfil\",\n+\t\t\t   param_structs);\n       write_types (header_file, structures, param_structs, &pch_wtd);\n       write_local (header_file, structures, param_structs);\n     }\n@@ -4328,12 +4553,7 @@ main (int argc, char **argv)\n   if (do_dump)\n     dump_everything ();\n \n-  if (plugin_files)\n-    {\n-      for (i = 0; i < nb_plugin_files; i++)\n-\tfree (plugin_files[i] - sizeof (lang_bitmap));\n-      free (plugin_files);\n-    }\n+  /* Don't bother about free-ing any input or plugin file, etc.  */\n \n   if (hit_error)\n     return 1;"}, {"sha": "d9eb9ae1b51f49ff917774c36cba53192f79efd4", "filename": "gcc/gengtype.h", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ed6dc529088cab9d586e9b3f06492e27f862fc/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=f8ed6dc529088cab9d586e9b3f06492e27f862fc", "patch": "@@ -1,5 +1,6 @@\n /* Process source files and output type information.\n-   Copyright (C) 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2007, 2008, 2010 \n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -20,6 +21,10 @@\n #ifndef GCC_GENGTYPE_H\n #define GCC_GENGTYPE_H\n \n+/* Sets of accepted source languages like C, C++, Ada... are\n+   represented by a bitmap.  */\n+typedef unsigned lang_bitmap;\n+\n /* A file position, mostly for error messages.\n    The FILE element may be compared using pointer equality.  */\n struct fileloc\n@@ -38,14 +43,50 @@ typedef struct options *options_p;\n extern int lexer_toplevel_done;\n extern struct fileloc lexer_line;\n \n+/* Structure representing an output file.  */\n+struct outf\n+{\n+  struct outf *next;\n+  const char *name;\n+  size_t buflength;\n+  size_t bufused;\n+  char *buf;\n+};\n+typedef struct outf *outf_p;\n+\n+/* The list of output files.  */\n+extern outf_p output_files;\n+\n+/* The output header file that is included into pretty much every\n+   source file.  */\n+extern outf_p header_file;\n+\n+/* Print, like fprintf, to O.  No-op if O is NULL.  */\n+void\n+oprintf (outf_p o, const char *S, ...)\n+  ATTRIBUTE_PRINTF_2;\n+\n+/* An output file, suitable for definitions, that can see declarations\n+   made in INPUT_FILE and is linked into every language that uses\n+   INPUT_FILE.  May return NULL in plugin mode.  */\n+extern outf_p get_output_file_with_visibility (const char *input_file);\n+\n+/* Source directory.  */\n+extern const char *srcdir;\t/* (-S) program argument. */\n+\n+/* Length of srcdir name.  */\n+extern size_t srcdir_len;\n+\n+/* Variable used for reading and writing the state.  */\n+extern const char *read_state_filename; /* (-r) program argument. */\n+extern const char *write_state_filename; /* (-w) program argument. */\n+\n /* Print an error message.  */\n extern void error_at_line\n (const struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n /* Like asprintf, but calls fatal() on out of memory.  */\n-extern char *\n-xasprintf (const char *, ...)\n-  ATTRIBUTE_PRINTF_1;\n+extern char *xasprintf (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n@@ -117,4 +158,28 @@ enum\n        a meaningful value to be printed.  */\n     FIRST_TOKEN_WITH_VALUE = PARAM_IS\n   };\n+\n+\n+/* For debugging purposes we provide two flags.  */\n+\n+/* Dump everything to understand gengtype's state. Might be useful to\n+   gengtype users.  */\n+extern int do_dump;\t\t/* (-d) program argument. */\n+\n+/* Trace the execution by many DBGPRINTF (with the position inside\n+   gengtype source code).  Only useful to debug gengtype itself.  */\n+extern int do_debug;\t\t/* (-D) program argument. */\n+\n+#if ENABLE_CHECKING\n+#define DBGPRINTF(Fmt,...) do {if (do_debug)\t\t\t\t\\\n+      fprintf (stderr, \"%s:%d: \" Fmt \"\\n\",\t\t\t\t\\\n+\t       lbasename (__FILE__),__LINE__, ##__VA_ARGS__);} while (0)\n+void dbgprint_count_type_at (const char *, int, const char *, type_p);\n+#define DBGPRINT_COUNT_TYPE(Msg,Ty) do {if (do_debug)\t\t\t\\\n+      dbgprint_count_type_at (__FILE__, __LINE__, Msg, Ty);}while (0)\n+#else\n+#define DBGPRINTF(Fmt,...) do {/*nodbgrintf*/} while (0)\n+#define DBGPRINT_COUNT_TYPE(Msg,Ty) do{/*nodbgprint_count_type*/}while (0)\n+#endif /*ENABLE_CHECKING */\n+\n #endif"}]}