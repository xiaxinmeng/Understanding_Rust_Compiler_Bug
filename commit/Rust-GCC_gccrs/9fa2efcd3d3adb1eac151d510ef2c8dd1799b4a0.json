{"sha": "9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhMmVmY2QzZDNhZGIxZWFjMTUxZDUxMGVmMmM4ZGQxNzk5YjRhMA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-11-30T21:36:32Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-11-30T21:36:32Z"}, "message": "Implement coalesce list with hash table instead of linked list.\n\n\t* tree-ssa-live.c (create_coalesce_list): Create a hash table.\n\t(COALESCE_HASH_FN): New.  Define hash function.\n\t(partition_pair_map_hash): New.  Hash value for a partition pair.\n\t(partition_pair_map_eq): New.  Equality for hash pairs.\n\t(create_coalesce_list): Create hash table.\n\t(delete_coalesce_list): Free hash table.\n\t(find_partition_pair): Find/create pairs in hash table.\n\t(compare_pairs):  Sort pairs in ascending order now.\n\t(num_coalesce_pairs): New.  Number of pairs in hash table.\n\t(struct partition_pair_iterator): Iterator struct for pair table.\n\t(first_partition_pair): Iterator function for first pair.\n\t(end_partition_pair_p): Iterator function for end of iteration.\n\t(next_partition_pair): Iterator function for next pair.\n\t(FOR_EACH_PARTITION_PAIR): Macro for iterating over pairs.\n\t(sort_coalesce_list): Sort pairs from hash table into an array.\n\t(pop_best_coalesce): Take pairs from the array.\n\t(dump_coalesce_list): Update to use hash table or sorted array.\n\t* tree-ssa-live.h (struct partition_pair_d): Remove next field.\n\t(struct coalesce_list_d): Add hash table related fields.\n\nFrom-SVN: r119378", "tree": {"sha": "846178c38c493762bf802c9fd5ce7f67e1f92d30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/846178c38c493762bf802c9fd5ce7f67e1f92d30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/comments", "author": null, "committer": null, "parents": [{"sha": "f7b410e0fbe76b707f76381f7dd684171353d1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b410e0fbe76b707f76381f7dd684171353d1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b410e0fbe76b707f76381f7dd684171353d1a9"}], "stats": {"total": 312, "additions": 184, "deletions": 128}, "files": [{"sha": "e9d4055d114682df374d4c1a06587324c6c80b51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "patch": "@@ -1,3 +1,25 @@\n+2006-11-30  Andrew Macleod  <amacleod@redhat.com>\n+\n+\t* tree-ssa-live.c (create_coalesce_list): Create a hash table.\n+\t(COALESCE_HASH_FN): New.  Define hash function.\n+\t(partition_pair_map_hash): New.  Hash value for a partition pair.\n+\t(partition_pair_map_eq): New.  Equality for hash pairs.\n+\t(create_coalesce_list): Create hash table.\n+\t(delete_coalesce_list): Free hash table.\n+\t(find_partition_pair): Find/create pairs in hash table.\n+\t(compare_pairs):  Sort pairs in ascending order now.\n+\t(num_coalesce_pairs): New.  Number of pairs in hash table.\n+\t(struct partition_pair_iterator): Iterator struct for pair table.\n+\t(first_partition_pair): Iterator function for first pair.\n+\t(end_partition_pair_p): Iterator function for end of iteration.\n+\t(next_partition_pair): Iterator function for next pair.\n+\t(FOR_EACH_PARTITION_PAIR): Macro for iterating over pairs.\n+\t(sort_coalesce_list): Sort pairs from hash table into an array.\n+\t(pop_best_coalesce): Take pairs from the array.\n+\t(dump_coalesce_list): Update to use hash table or sorted array.\n+\t* tree-ssa-live.h (struct partition_pair_d): Remove next field.\n+\t(struct coalesce_list_d): Add hash table related fields.\n+\n 2006-11-30  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/30028"}, {"sha": "e1525c1d0037453a88532bbd9759834d8becd8ba", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 150, "deletions": 111, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "patch": "@@ -1136,19 +1136,54 @@ type_var_init (var_map map)\n }\n \n \n+/* Hash function for 2 integer coalesce pairs.  */\n+#define COALESCE_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n+\n+\n+/* Return hash value for partition pair PAIR.  */\n+\n+unsigned int \n+partition_pair_map_hash (const void *pair)\n+{\n+  hashval_t a = (hashval_t)(((partition_pair_p)pair)->first_partition);\n+  hashval_t b = (hashval_t)(((partition_pair_p)pair)->second_partition);\n+\n+  return COALESCE_HASH_FN (a,b);\n+}\n+\n+\n+/* Return TRUE if PAIR1 is equivilent to PAIR2.  */\n+\n+int \n+partition_pair_map_eq (const void *pair1, const void *pair2)\n+{\n+  partition_pair_p p1 = (partition_pair_p) pair1;\n+  partition_pair_p p2 = (partition_pair_p) pair2;\n+\n+  return (p1->first_partition == p2->first_partition\n+\t  && p1->second_partition == p2->second_partition);\n+}\n+\n+\n /* Create a new coalesce list object from MAP and return it.  */\n \n coalesce_list_p \n create_coalesce_list (var_map map)\n {\n   coalesce_list_p list;\n+  unsigned size = num_ssa_names * 3;\n \n-  list = (coalesce_list_p) xmalloc (sizeof (struct coalesce_list_d));\n+  if (size < 40)\n+    size = 40;\n+\n+  list = xmalloc (sizeof (struct coalesce_list_d));\n+  list->list = htab_create (size, partition_pair_map_hash,\n+  \t\t\t    partition_pair_map_eq, NULL);\n \n   list->map = map;\n+  list->sorted = NULL;\n   list->add_mode = true;\n-  list->list = (partition_pair_p *) xcalloc (num_var_partitions (map),\n-\t\t\t\t\t     sizeof (struct partition_pair_d));\n+  list->num_sorted = 0;\n   return list;\n }\n \n@@ -1158,7 +1193,10 @@ create_coalesce_list (var_map map)\n void \n delete_coalesce_list (coalesce_list_p cl)\n {\n-  free (cl->list);\n+  htab_delete (cl->list);\n+  if (cl->sorted)\n+    free (cl->sorted);\n+  gcc_assert (cl->num_sorted == 0);\n   free (cl);\n }\n \n@@ -1170,52 +1208,38 @@ delete_coalesce_list (coalesce_list_p cl)\n static partition_pair_p\n find_partition_pair (coalesce_list_p cl, int p1, int p2, bool create)\n {\n-  partition_pair_p node, tmp;\n-  int s;\n+  struct partition_pair p, *pair;\n+  void **slot;\n+  unsigned int hash;\n     \n-  /* Normalize so that p1 is the smaller value.  */\n+  /* normalize so that p1 is the smaller value.  */\n   if (p2 < p1)\n     {\n-      s = p1;\n-      p1 = p2;\n-      p2 = s;\n+      p.first_partition = p2;\n+      p.second_partition = p1;\n     }\n-  \n-  tmp = NULL;\n-\n-  /* The list is sorted such that if we find a value greater than p2,\n-     p2 is not in the list.  */\n-  for (node = cl->list[p1]; node; node = node->next)\n+  else\n     {\n-      if (node->second_partition == p2)\n-        return node;\n-      else\n-        if (node->second_partition > p2)\n-\t  break;\n-     tmp = node;\n+      p.first_partition = p1;\n+      p.second_partition = p2;\n     }\n+  \n+  \n+  hash = partition_pair_map_hash (&p);\n+  pair = (struct partition_pair *) htab_find_with_hash (cl->list, &p, hash);\n \n-  if (!create)\n-    return NULL;\n-\n-  node = (partition_pair_p) xmalloc (sizeof (struct partition_pair_d));\n-  node->first_partition = p1;\n-  node->second_partition = p2;\n-  node->cost = 0;\n-    \n-  if (tmp != NULL)\n-    {\n-      node->next = tmp->next;\n-      tmp->next = node;\n-    }\n-  else\n+  if (create && !pair)\n     {\n-      /* This is now the first node in the list.  */\n-      node->next = cl->list[p1];\n-      cl->list[p1] = node;\n+      gcc_assert (cl->add_mode);\n+      pair = xmalloc (sizeof (struct partition_pair));\n+      pair->first_partition = p.first_partition;\n+      pair->second_partition = p.second_partition;\n+      pair->cost = 0;\n+      slot = htab_find_slot_with_hash (cl->list, pair, hash, INSERT);\n+      *(struct partition_pair **)slot = pair;\n     }\n \n-  return node;\n+  return pair;\n }\n \n /* Return cost of execution of copy instruction with FREQUENCY\n@@ -1256,14 +1280,55 @@ add_coalesce (coalesce_list_p cl, int p1, int p2,\n }\n \n \n-/* Comparison function to allow qsort to sort P1 and P2 in descending order.  */\n+/* Comparison function to allow qsort to sort P1 and P2 in Ascendiong order.  */\n \n static\n int compare_pairs (const void *p1, const void *p2)\n {\n-  return (*(partition_pair_p *)p2)->cost - (*(partition_pair_p *)p1)->cost;\n+  return (*(partition_pair_p *)p1)->cost - (*(partition_pair_p *)p2)->cost;\n+}\n+\n+\n+static inline int\n+num_coalesce_pairs (coalesce_list_p cl)\n+{\n+  return htab_elements (cl->list);\n+}\n+\n+typedef struct\n+{\n+  htab_iterator hti;\n+} partition_pair_iterator;\n+\n+static inline partition_pair_p\n+first_partition_pair (coalesce_list_p cl, partition_pair_iterator *iter)\n+{\n+  partition_pair_p pair;\n+\n+  pair = (partition_pair_p) first_htab_element (&(iter->hti), cl->list);\n+  return pair;\n+}\n+\n+static inline bool\n+end_partition_pair_p (partition_pair_iterator *iter)\n+{\n+  return end_htab_p (&(iter->hti));\n+}\n+\n+static inline partition_pair_p\n+next_partition_pair (partition_pair_iterator *iter)\n+{\n+  partition_pair_p pair;\n+\n+  pair = (partition_pair_p) next_htab_element (&(iter->hti));\n+  return pair;\n }\n \n+#define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\\n+  for ((PAIR) = first_partition_pair ((CL), &(ITER));\t\\\n+       !end_partition_pair_p (&(ITER));\t\t\t\\\n+       (PAIR) = next_partition_pair (&(ITER)))\n+\n \n /* Prepare CL for removal of preferred pairs.  When finished, list element \n    0 has all the coalesce pairs, sorted in order from most important coalesce \n@@ -1272,64 +1337,45 @@ int compare_pairs (const void *p1, const void *p2)\n void\n sort_coalesce_list (coalesce_list_p cl)\n {\n-  unsigned x, num, count;\n-  partition_pair_p chain, p;\n-  partition_pair_p  *list;\n+  unsigned x, num;\n+  partition_pair_p p;\n+  partition_pair_iterator ppi;\n \n   gcc_assert (cl->add_mode);\n \n   cl->add_mode = false;\n \n-  /* Compact the array of lists to a single list, and count the elements.  */\n-  num = 0;\n-  chain = NULL;\n-  for (x = 0; x < num_var_partitions (cl->map); x++)\n-    if (cl->list[x] != NULL)\n-      {\n-        for (p = cl->list[x]; p->next != NULL; p = p->next)\n-\t  num++;\n-\tnum++;\n-\tp->next = chain;\n-\tchain = cl->list[x];\n-\tcl->list[x] = NULL;\n-      }\n+  /* allocate a vector for the pair pointers.  */\n+  num = num_coalesce_pairs (cl);\n+  cl->num_sorted = num;\n+  if (num == 0)\n+    return;\n+  cl->sorted = XNEWVEC (partition_pair_p, num);\n \n-  /* Only call qsort if there are more than 2 items.  */\n-  if (num > 2)\n-    {\n-      list = XNEWVEC (partition_pair_p, num);\n-      count = 0;\n-      for (p = chain; p != NULL; p = p->next)\n-\tlist[count++] = p;\n+  /* Populate the vector with pointers to the partition pairs.  */\n+  \n+  x = 0;\n+  FOR_EACH_PARTITION_PAIR (p, ppi, cl)\n+    cl->sorted[x++] = p;\n+  gcc_assert (x == num);\n \n-      gcc_assert (count == num);\n-\t\n-      qsort (list, count, sizeof (partition_pair_p), compare_pairs);\n+  if (num == 1)\n+    return;\n \n-      p = list[0];\n-      for (x = 1; x < num; x++)\n-\t{\n-\t  p->next = list[x];\n-\t  p = list[x];\n-\t}\n-      p->next = NULL;\n-      cl->list[0] = list[0];\n-      free (list);\n-    }\n-  else\n+  if (num == 2)\n     {\n-      cl->list[0] = chain;\n-      if (num == 2)\n-\t{\n-\t  /* Simply swap the two elements if they are in the wrong order.  */\n-\t  if (chain->cost < chain->next->cost)\n-\t    {\n-\t      cl->list[0] = chain->next;\n-\t      cl->list[0]->next = chain;\n-\t      chain->next = NULL;\n-\t    }\n+      if (cl->sorted[0]->cost > cl->sorted[1]->cost)\n+        {\n+\t  p = cl->sorted[0];\n+\t  cl->sorted[0] = cl->sorted[1];\n+\t  cl->sorted[1] = p;\n \t}\n+      return;\n     }\n+\n+  /* Only call qsort if there are more than 2 items.  */\n+  if (num > 2)\n+      qsort (cl->sorted, num, sizeof (partition_pair_p), compare_pairs);\n }\n \n \n@@ -1345,11 +1391,10 @@ pop_best_coalesce (coalesce_list_p cl, int *p1, int *p2)\n \n   gcc_assert (!cl->add_mode);\n \n-  node = cl->list[0];\n-  if (!node)\n+  if (cl->num_sorted == 0)\n     return NO_BEST_COALESCE;\n \n-  cl->list[0] = node->next;\n+  node = cl->sorted[--(cl->num_sorted)];\n \n   *p1 = node->first_partition;\n   *p2 = node->second_partition;\n@@ -1729,40 +1774,34 @@ void\n dump_coalesce_list (FILE *f, coalesce_list_p cl)\n {\n   partition_pair_p node;\n-  int x, num;\n+  partition_pair_iterator ppi;\n+  int x;\n   tree var;\n \n   if (cl->add_mode)\n     {\n       fprintf (f, \"Coalesce List:\\n\");\n-      num = num_var_partitions (cl->map);\n-      for (x = 0; x < num; x++)\n+      FOR_EACH_PARTITION_PAIR (node, ppi, cl)\n         {\n-\t  node = cl->list[x];\n-\t  if (node)\n-\t    {\n-\t      fprintf (f, \"[\");\n-\t      print_generic_expr (f, partition_to_var (cl->map, x), TDF_SLIM);\n-\t      fprintf (f, \"] - \");\n-\t      for ( ; node; node = node->next)\n-\t        {\n-\t\t  var = partition_to_var (cl->map, node->second_partition);\n-\t\t  print_generic_expr (f, var, TDF_SLIM);\n-\t\t  fprintf (f, \"(%1d), \", node->cost);\n-\t\t}\n-\t      fprintf (f, \"\\n\");\n-\t    }\n+\t  tree var1 = partition_to_var (cl->map, node->first_partition);\n+\t  tree var2 = partition_to_var (cl->map, node->second_partition);\n+\t  print_generic_expr (f, var1, TDF_SLIM);\n+\t  fprintf (f, \" <-> \");\n+\t  print_generic_expr (f, var2, TDF_SLIM);\n+\t  fprintf (f, \"  (%1d), \", node->cost);\n+\t  fprintf (f, \"\\n\");\n \t}\n     }\n   else\n     {\n       fprintf (f, \"Sorted Coalesce list:\\n\");\n-      for (node = cl->list[0]; node; node = node->next)\n+      for (x = cl->num_sorted - 1 ; x >=0; x--)\n         {\n+\t  node = cl->sorted[x];\n \t  fprintf (f, \"(%d) \", node->cost);\n \t  var = partition_to_var (cl->map, node->first_partition);\n \t  print_generic_expr (f, var, TDF_SLIM);\n-\t  fprintf (f, \" : \");\n+\t  fprintf (f, \" <-> \");\n \t  var = partition_to_var (cl->map, node->second_partition);\n \t  print_generic_expr (f, var, TDF_SLIM);\n \t  fprintf (f, \"\\n\");"}, {"sha": "17ada27bda7cd076c9006d94feb2ba8bfe2ae1f5", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=9fa2efcd3d3adb1eac151d510ef2c8dd1799b4a0", "patch": "@@ -147,7 +147,7 @@ var_to_partition (var_map map, tree var)\n   else\n     {\n       ann = var_ann (var);\n-      if (ann->out_of_ssa_tag)\n+      if (ann && ann->out_of_ssa_tag)\n \tpart = VAR_ANN_PARTITION (ann);\n       else\n         part = NO_PARTITION;\n@@ -671,31 +671,26 @@ type_var_decompact (type_var_p tv)\n    all desired information has been collected, the object can be used to \n    order the pairs for processing.  */\n \n-/* This structure defines a pair for coalescing.  */\n+/* This structure defines a pair entry.  */\n \n-typedef struct partition_pair_d\n+typedef struct partition_pair\n {\n   int first_partition;\n   int second_partition;\n   int cost;\n-  struct partition_pair_d *next;\n-} *partition_pair_p;\n-\n-/* This structure maintains the list of coalesce pairs.  \n-   When add_mode is true, list is a triangular shaped list of coalesce pairs.\n-   The smaller partition number is used to index the list, and the larger is\n-   index is located in a partition_pair_p object. These lists are sorted from \n-   smallest to largest by 'second_partition'.  New coalesce pairs are allowed\n-   to be added in this mode.\n-   When add_mode is false, the lists have all been merged into list[0]. The\n-   rest of the lists are not used. list[0] is ordered from most desirable\n-   coalesce to least desirable. pop_best_coalesce() retrieves the pairs\n-   one at a time.  */\n+} * partition_pair_p;\n+\n+extern unsigned int partition_pair_map_hash (const void *);\n+extern int partition_pair_map_eq (const void *, const void *);\n+\n+/* This structure maintains the list of coalesce pairs.  */\n \n typedef struct coalesce_list_d \n {\n   var_map map;\n-  partition_pair_p *list;\n+  htab_t list;\n+  partition_pair_p *sorted;\n+  int num_sorted;\n   bool add_mode;\n } *coalesce_list_p;\n "}]}