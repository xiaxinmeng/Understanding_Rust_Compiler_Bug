{"sha": "a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "node_id": "C_kwDOANBUbNoAKGEzN2U4Y2UzYjY2MzI1ZjBjNmRlNTVjODBkNTBhYzE2NjRjM2QwZWI", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-12-14T22:00:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-12-17T03:27:10Z"}, "message": "c++: layout of aggregate base with DMI [PR103681]\n\nC++14 changed the definition of 'aggregate' to allow default member\ninitializers, but such classes still need to be considered \"non-POD for the\npurpose of layout\" for ABI compatibility with C++11 code.  It seems rare to\nderive from such a class, as evidenced by how long this bug has\nsurvived (since r216750 in 2014), but it's certainly worth fixing.\n\nWe only warn when we were failing to allocate another field into the\ntail padding of the newly aggregate class; this is the only ABI impact.\n\nThis also changes end_of_class to consider all data members, not just empty\ndata members; that used to be an additional flag, removed in r9-5710, but I\ndon't see any reason not to always include them.  This makes the result of\nthe function correspond to the ABI nvsize term and its nameless counterpart\nthat does include virtual bases.\n\nWhen looking closely at other users of end_of_class, I realized that we were\nassuming that the latter corresponded to the ABI dsize term, but it doesn't\nif the class ends with an empty virtual base (in the rare case that the\nempty base can't be assigned offset 0), and this matters for layout of\n[[no_unique_address]].  So I added another mode that returns the desired\nvalue for that case.  I'm not adding a warning for this ABI fix because it's\na C++20 feature.\n\n\tPR c++/103681\n\ngcc/ChangeLog:\n\n\t* common.opt (fabi-version): Add v17.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (struct lang_type): Add non_pod_aggregate.\n\t(CLASSTYPE_NON_POD_AGGREGATE): New.\n\t* class.c (check_field_decls): Set it.\n\t(check_bases_and_members): Check it.\n\t(check_non_pod_aggregate): New.\n\t(enum eoc_mode): New.\n\t(end_of_class): Always include non-empty fields.\n\tAdd eoc_nv_or_dsize mode.\n\t(include_empty_classes, layout_class_type): Adjust.\n\ngcc/c-family/ChangeLog:\n\n\t* c-opts.c (c_common_post_options): Update defaults.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/abi/macro0.C: Update value.\n\t* g++.dg/abi/no_unique_address6.C: New test.\n\t* g++.dg/abi/nsdmi-aggr1.C: New test.\n\t* g++.dg/abi/nsdmi-aggr1a.C: New test.", "tree": {"sha": "7b73bb503c2a2d753ae8bea87fffa80e6f81da66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b73bb503c2a2d753ae8bea87fffa80e6f81da66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "774269aa4b9fae97f649abe38322135371fd3bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774269aa4b9fae97f649abe38322135371fd3bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774269aa4b9fae97f649abe38322135371fd3bef"}], "stats": {"total": 263, "additions": 217, "deletions": 46}, "files": [{"sha": "4c20e44f5b52521d0532b2d03d68a9edfca19c01", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -975,9 +975,9 @@ c_common_post_options (const char **pfilename)\n \n   /* Change flag_abi_version to be the actual current ABI level, for the\n      benefit of c_cpp_builtins, and to make comparison simpler.  */\n-  const int latest_abi_version = 16;\n-  /* Generate compatibility aliases for ABI v11 (7.1) by default.  */\n-  const int abi_compat_default = 11;\n+  const int latest_abi_version = 17;\n+  /* Generate compatibility aliases for ABI v13 (8.2) by default.  */\n+  const int abi_compat_default = 13;\n \n #define clamp(X) if (X == 0 || X > latest_abi_version) X = latest_abi_version\n   clamp (flag_abi_version);"}, {"sha": "4af89ce8fd2658590b774d3b2c85653d9b3964e3", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -990,6 +990,10 @@ Driver Undocumented\n ;     Adds missing 'on' in mangling of operator names in some cases.\n ;     Default in G++ 11.\n ;\n+; 17: Fixes layout of classes that inherit from aggregate classes with default\n+;     member initializers in C++14 and up.\n+;     Default in G++ 12.\n+;\n ; Additional positive integers will be assigned as new versions of\n ; the ABI become the default version of the ABI.\n fabi-version="}, {"sha": "e70c535b3f24b8a267f367bba6b29932bda142ee", "filename": "gcc/cp/class.c", "status": "modified", "additions": 104, "deletions": 41, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -3857,9 +3857,14 @@ check_field_decls (tree t, tree *access_decls,\n \n       /* Now that we've removed bit-field widths from DECL_INITIAL,\n \t anything left in DECL_INITIAL is an NSDMI that makes the class\n-\t non-aggregate in C++11.  */\n-      if (DECL_INITIAL (field) && cxx_dialect < cxx14)\n-\tCLASSTYPE_NON_AGGREGATE (t) = true;\n+\t non-aggregate in C++11, and non-layout-POD always.  */\n+      if (DECL_INITIAL (field))\n+\t{\n+\t  if (cxx_dialect < cxx14)\n+\t    CLASSTYPE_NON_AGGREGATE (t) = true;\n+\t  else\n+\t    CLASSTYPE_NON_POD_AGGREGATE (t) = true;\n+\t}\n \n       if (CP_TYPE_CONST_P (type))\n \t{\n@@ -6045,6 +6050,16 @@ check_bases_and_members (tree t)\n   TYPE_HAS_COMPLEX_MOVE_ASSIGN (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_CONTAINS_VPTR_P (t);\n \n+  /* Is this class non-layout-POD because it wasn't an aggregate in C++98?  */\n+  if (CLASSTYPE_NON_POD_AGGREGATE (t))\n+    {\n+      if (CLASSTYPE_NON_LAYOUT_POD_P (t))\n+\t/* It's non-POD for another reason.  */\n+\tCLASSTYPE_NON_POD_AGGREGATE (t) = false;\n+      else if (abi_version_at_least (17))\n+\tCLASSTYPE_NON_LAYOUT_POD_P (t) = true;\n+    }\n+\n   /* If the only explicitly declared default constructor is user-provided,\n      set TYPE_HAS_COMPLEX_DFLT.  */\n   if (!TYPE_HAS_COMPLEX_DFLT (t)\n@@ -6341,12 +6356,17 @@ end_of_base (tree binfo)\n   return size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), size);\n }\n \n-/* Returns the offset of the byte just past the end of the base class or empty\n-   data member with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero,\n-   then only non-virtual bases are included.  */\n+/* Returns one of three variations of the ending offset of T.  If MODE is\n+   eoc_nvsize, the result is the ABI \"nvsize\" (i.e. sizeof before allocating\n+   vbases).  If MODE is eoc_vsize, the result is the sizeof after allocating\n+   vbases but before rounding, which is not named in the ABI.  If MODE is\n+   eoc_nv_or_dsize, the result is the greater of \"nvsize\" and \"dsize\" (the size\n+   of the actual data in the class, kinda), as used for allocation of\n+   potentially-overlapping fields.  */\n \n+enum eoc_mode { eoc_nvsize, eoc_vsize, eoc_nv_or_dsize };\n static tree\n-end_of_class (tree t, bool include_virtuals_p)\n+end_of_class (tree t, eoc_mode mode)\n {\n   tree result = size_zero_node;\n   vec<tree, va_gc> *vbases;\n@@ -6358,8 +6378,7 @@ end_of_class (tree t, bool include_virtuals_p)\n   for (binfo = TYPE_BINFO (t), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      if (!include_virtuals_p\n-\t  && BINFO_VIRTUAL_P (base_binfo)\n+      if (BINFO_VIRTUAL_P (base_binfo)\n \t  && (!BINFO_PRIMARY_P (base_binfo)\n \t      || BINFO_INHERITANCE_CHAIN (base_binfo) != TYPE_BINFO (t)))\n \tcontinue;\n@@ -6369,32 +6388,81 @@ end_of_class (tree t, bool include_virtuals_p)\n \tresult = offset;\n     }\n \n-  /* Also consider empty data members.  */\n   for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL\n-\t&& !DECL_ARTIFICIAL (field)\n-\t&& field_poverlapping_p (field)\n-\t&& is_empty_class (TREE_TYPE (field)))\n+\t&& !DECL_FIELD_IS_BASE (field))\n       {\n-\t/* Update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)) */\n-\toffset = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (field),\n-\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\ttree size = DECL_SIZE_UNIT (field);\n+\tif (!size)\n+\t  /* DECL_SIZE_UNIT can be null for a flexible array.  */\n+\t  continue;\n+\n+\tif (is_empty_field (field))\n+\t  /* For empty fields DECL_SIZE_UNIT is 0, but we want the\n+\t     size of the type (usually 1) for computing nvsize.  */\n+\t  size = TYPE_SIZE_UNIT (TREE_TYPE (field));\n+\n+\toffset = size_binop (PLUS_EXPR, byte_position (field), size);\n \tif (tree_int_cst_lt (result, offset))\n \t  result = offset;\n       }\n \n-  if (include_virtuals_p)\n+  if (mode != eoc_nvsize)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n \t vec_safe_iterate (vbases, i, &base_binfo); i++)\n       {\n-\toffset = end_of_base (base_binfo);\n+\tif (mode == eoc_nv_or_dsize)\n+\t  /* For dsize, don't count trailing empty bases.  */\n+\t  offset = size_binop (PLUS_EXPR, BINFO_OFFSET (binfo),\n+\t\t\t       CLASSTYPE_SIZE_UNIT (BINFO_TYPE (binfo)));\n+\telse\n+\t  offset = end_of_base (base_binfo);\n \tif (tree_int_cst_lt (result, offset))\n \t  result = offset;\n       }\n \n   return result;\n }\n \n+/* Warn as appropriate about the change in whether we pack into the tail\n+   padding of FIELD, a base field which has a C++14 aggregate type with default\n+   member initializers.  */\n+\n+static void\n+check_non_pod_aggregate (tree field)\n+{\n+  if (!abi_version_crosses (17) || cxx_dialect < cxx14)\n+    return;\n+  if (TREE_CODE (field) != FIELD_DECL\n+      || (!DECL_FIELD_IS_BASE (field)\n+\t  && !field_poverlapping_p (field)))\n+    return;\n+  tree next = DECL_CHAIN (field);\n+  while (next && TREE_CODE (next) != FIELD_DECL) next = DECL_CHAIN (next);\n+  if (!next)\n+    return;\n+  tree type = TREE_TYPE (field);\n+  if (TYPE_IDENTIFIER (type) == as_base_identifier)\n+    type = TYPE_CONTEXT (type);\n+  if (!CLASS_TYPE_P (type) || !CLASSTYPE_NON_POD_AGGREGATE (type))\n+    return;\n+  tree size = end_of_class (type, (DECL_FIELD_IS_BASE (field)\n+\t\t\t\t   ? eoc_nvsize : eoc_nv_or_dsize));\n+  tree rounded = round_up_loc (input_location, size, DECL_ALIGN_UNIT (next));\n+  if (tree_int_cst_lt (rounded, TYPE_SIZE_UNIT (type)))\n+    {\n+      location_t loc = DECL_SOURCE_LOCATION (next);\n+      if (DECL_FIELD_IS_BASE (next))\n+\twarning_at (loc, OPT_Wabi,\"offset of %qT base class for \"\n+\t\t    \"%<-std=c++14%> and up changes in \"\n+\t\t    \"%<-fabi-version=17%> (GCC 12)\", TREE_TYPE (next));\n+      else\n+\twarning_at (loc, OPT_Wabi, \"offset of %qD for \"\n+\t\t    \"%<-std=c++14%> and up changes in \"\n+\t\t    \"%<-fabi-version=17%> (GCC 12)\", next);\n+    }\n+}\n+\n /* Warn about bases of T that are inaccessible because they are\n    ambiguous.  For example:\n \n@@ -6468,7 +6536,7 @@ include_empty_classes (record_layout_info rli)\n      because we are willing to overlay multiple bases at the same\n      offset.  However, now we need to make sure that RLI is big enough\n      to reflect the entire class.  */\n-  eoc = end_of_class (rli->t, CLASSTYPE_AS_BASE (rli->t) != NULL_TREE);\n+  eoc = end_of_class (rli->t, eoc_vsize);\n   rli_size = rli_size_unit_so_far (rli);\n   if (TREE_CODE (rli_size) == INTEGER_CST\n       && tree_int_cst_lt (rli_size, eoc))\n@@ -6580,21 +6648,13 @@ layout_class_type (tree t, tree *virtuals_p)\n \t{\n \t  /* if D is a potentially-overlapping data member, update sizeof(C) to\n \t     max (sizeof(C), offset(D)+max (nvsize(D), dsize(D))).  */\n-\t  tree nvsize = CLASSTYPE_SIZE_UNIT (type);\n-\t  /* end_of_class doesn't always give dsize, but it does in the case of\n-\t     a class with virtual bases, which is when dsize > nvsize.  */\n-\t  tree dsize = end_of_class (type, /*vbases*/true);\n \t  if (CLASSTYPE_EMPTY_P (type))\n \t    DECL_SIZE (field) = DECL_SIZE_UNIT (field) = size_zero_node;\n-\t  else if (tree_int_cst_le (dsize, nvsize))\n-\t    {\n-\t      DECL_SIZE_UNIT (field) = nvsize;\n-\t      DECL_SIZE (field) = CLASSTYPE_SIZE (type);\n-\t    }\n \t  else\n \t    {\n-\t      DECL_SIZE_UNIT (field) = dsize;\n-\t      DECL_SIZE (field) = bit_from_pos (dsize, bitsize_zero_node);\n+\t      tree size = end_of_class (type, eoc_nv_or_dsize);\n+\t      DECL_SIZE_UNIT (field) = size;\n+\t      DECL_SIZE (field) = bit_from_pos (size, bitsize_zero_node);\n \t    }\n \t}\n \n@@ -6760,16 +6820,19 @@ layout_class_type (tree t, tree *virtuals_p)\n      instead, so that the backends can emit -Wpsabi warnings in the cases\n      where the ABI changed.  */\n   for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n-    if (TREE_CODE (field) == FIELD_DECL\n-\t&& DECL_C_BIT_FIELD (field)\n-\t/* We should not be confused by the fact that grokbitfield\n-\t   temporarily sets the width of the bit field into\n-\t   DECL_BIT_FIELD_REPRESENTATIVE (field).\n-\t   check_bitfield_decl eventually sets DECL_SIZE (field)\n-\t   to that width.  */\n-\t&& (DECL_SIZE (field) == NULL_TREE\n-\t    || integer_zerop (DECL_SIZE (field))))\n-      SET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field, 1);\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && DECL_C_BIT_FIELD (field)\n+\t  /* We should not be confused by the fact that grokbitfield\n+\t     temporarily sets the width of the bit field into\n+\t     DECL_BIT_FIELD_REPRESENTATIVE (field).\n+\t     check_bitfield_decl eventually sets DECL_SIZE (field)\n+\t     to that width.  */\n+\t  && (DECL_SIZE (field) == NULL_TREE\n+\t      || integer_zerop (DECL_SIZE (field))))\n+\tSET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field, 1);\n+      check_non_pod_aggregate (field);\n+    }\n \n   if (CLASSTYPE_NON_LAYOUT_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n@@ -6792,7 +6855,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t used to compute TYPE_SIZE_UNIT.  */\n \n       /* Set the size and alignment for the new type.  */\n-      tree eoc = end_of_class (t, /*include_virtuals_p=*/0);\n+      tree eoc = end_of_class (t, eoc_nvsize);\n       TYPE_SIZE_UNIT (base_t)\n \t= size_binop (MAX_EXPR,\n \t\t      fold_convert (sizetype,"}, {"sha": "8b5cfa230ba6b26c87d49eac634c9b4133c3974f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -2344,6 +2344,7 @@ struct GTY(()) lang_type {\n   unsigned unique_obj_representations : 1;\n   unsigned unique_obj_representations_set : 1;\n   bool erroneous : 1;\n+  bool non_pod_aggregate : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -2352,7 +2353,7 @@ struct GTY(()) lang_type {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 4;\n+  unsigned dummy : 3;\n \n   tree primary_base;\n   vec<tree_pair_s, va_gc> *vcall_indices;\n@@ -2672,6 +2673,12 @@ struct GTY(()) lang_type {\n /* True if we saw errors while instantiating this class.  */\n #define CLASSTYPE_ERRONEOUS(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->erroneous)\n+\n+/* True if this class is non-layout-POD only because it was not an aggregate\n+   before C++14.  If we run out of bits in lang_type, this could be replaced\n+   with a hash_set only filled in when abi_version_crosses (17).  */\n+#define CLASSTYPE_NON_POD_AGGREGATE(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_pod_aggregate)\n \f\n /* Additional macros for inheritance information.  */\n "}, {"sha": "2d07fcdc631cd6b124c14385a39162faf7e4cd64", "filename": "gcc/testsuite/g++.dg/abi/macro0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmacro0.C?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -1,6 +1,6 @@\n // This testcase will need to be kept in sync with c_common_post_options.\n // { dg-options \"-fabi-version=0\" }\n \n-#if __GXX_ABI_VERSION != 1016\n+#if __GXX_ABI_VERSION != 1017\n #error \"Incorrect value of __GXX_ABI_VERSION\"\n #endif"}, {"sha": "5df6995c619ffcd7cd70b3cbcc5b8397d5bc4ed1", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address6.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address6.C?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile { target c++20 } }\n+\n+#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n+\n+struct E { };\n+\n+struct A: virtual E {\n+  // Deny the vbase offset 0 so it goes at the end.\n+  [[no_unique_address]] E e1;\n+  char c;\n+};\n+\n+struct B : public A {\n+  char d;\n+};\n+\n+struct C {\n+  [[no_unique_address]] A a;\n+  char d;\n+};\n+\n+#define SA(X) static_assert ((X),#X)\n+SA(__builtin_offsetof (B, d) == __builtin_offsetof (C, d));"}, {"sha": "c212c439a67eb6da72b5f17504db7d818c93fde8", "filename": "gcc/testsuite/g++.dg/abi/nsdmi-aggr1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1.C?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/103681\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-fabi-version=16 -Wabi\" }\n+\n+struct A {\n+  long l;\n+  char c = -1;\n+};\n+struct B : public A {\n+  char d;\n+  // { dg-warning \"offset\" \"\" { target c++14 } .-1 }\n+};\n+\n+#define SA(X) static_assert(X,#X)\n+SA(sizeof (B) == sizeof (A));\n+// { dg-error \"static assertion\" \"\" { target c++14 } .-1 }\n+\n+struct X { char d; };\n+struct B2 : A, X { };\n+// { dg-warning \"offset\" \"\" { target c++14 } .-1 }\n+SA(sizeof (B2) == sizeof (A));\n+// { dg-error \"static assertion\" \"\" { target c++14 } .-1 }\n+\n+#if __cplusplus > 201800L\n+\n+struct C {\n+  [[no_unique_address]] A a;\n+  char d;\n+  // { dg-warning \"offset\" \"\" { target c++20 } .-1 }\n+};\n+SA(sizeof (C) == sizeof (A));\n+// { dg-error \"static assertion\" \"\" { target c++20 } .-1 }\n+\n+struct C2 : A, X { };\n+// { dg-warning \"offset\" \"\" { target c++20 } .-1 }\n+SA(sizeof (B2) == sizeof (A));\n+// { dg-error \"static assertion\" \"\" { target c++20 } .-1 }\n+\n+#endif /* C++20 */"}, {"sha": "e7a509dbc8583d2c77d924a70d14afd51772d82e", "filename": "gcc/testsuite/g++.dg/abi/nsdmi-aggr1a.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fnsdmi-aggr1a.C?ref=a37e8ce3b66325f0c6de55c80d50ac1664c3d0eb", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/103681\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-fabi-version=0 -Wabi=16\" }\n+\n+struct A {\n+  long l;\n+  char c = -1;\n+};\n+struct B : public A {\n+  char d;\n+  // { dg-warning \"offset\" \"\" { target c++14 } .-1 }\n+};\n+\n+#define SA(X) static_assert(X,#X)\n+SA(sizeof (B) == sizeof (A));\n+\n+struct X { char d; };\n+struct B2 : A, X { };\n+// { dg-warning \"offset\" \"\" { target c++14 } .-1 }\n+SA(sizeof (B2) == sizeof (A));\n+\n+#if __cplusplus > 201800L\n+\n+struct C {\n+  [[no_unique_address]] A a;\n+  char d;\n+  // { dg-warning \"offset\" \"\" { target c++20 } .-1 }\n+};\n+SA(sizeof (C) == sizeof (A));\n+\n+struct C2 : A, X { };\n+// { dg-warning \"offset\" \"\" { target c++20 } .-1 }\n+SA(sizeof (B2) == sizeof (A));\n+\n+#endif /* C++20 */"}]}