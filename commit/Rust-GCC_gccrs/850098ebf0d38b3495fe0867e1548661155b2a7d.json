{"sha": "850098ebf0d38b3495fe0867e1548661155b2a7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUwMDk4ZWJmMGQzOGIzNDk1ZmUwODY3ZTE1NDg2NjExNTViMmE3ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-05-19T13:47:53Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-05-19T13:47:53Z"}, "message": "Introduce new check_GNU_style.py script.\n\n2017-05-19  Martin Liska  <mliska@suse.cz>\n\n\t* check_GNU_style.py: New file.\n\nFrom-SVN: r248281", "tree": {"sha": "8686d3edd8452131ee878ddd76a73a1c5aa9d228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8686d3edd8452131ee878ddd76a73a1c5aa9d228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/850098ebf0d38b3495fe0867e1548661155b2a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850098ebf0d38b3495fe0867e1548661155b2a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/850098ebf0d38b3495fe0867e1548661155b2a7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850098ebf0d38b3495fe0867e1548661155b2a7d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fd549d24fda05c859fb17697c51c16886902dad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd549d24fda05c859fb17697c51c16886902dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd549d24fda05c859fb17697c51c16886902dad"}], "stats": {"total": 282, "additions": 282, "deletions": 0}, "files": [{"sha": "74e441ae8bcf08f098eb2d94fe17a0dd64cfaa17", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/850098ebf0d38b3495fe0867e1548661155b2a7d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/850098ebf0d38b3495fe0867e1548661155b2a7d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=850098ebf0d38b3495fe0867e1548661155b2a7d", "patch": "@@ -1,3 +1,7 @@\n+2017-05-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* check_GNU_style.py: New file.\n+\n 2007-05-03  Jeff Law  <law@redhat.com>\n \n \t* config-list.mk (am33_2.0-linux): Remove from list of targets"}, {"sha": "b236e9312da18b31e817c976ea9c587d5ccdc3e0", "filename": "contrib/check_GNU_style.py", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/850098ebf0d38b3495fe0867e1548661155b2a7d/contrib%2Fcheck_GNU_style.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/850098ebf0d38b3495fe0867e1548661155b2a7d/contrib%2Fcheck_GNU_style.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcheck_GNU_style.py?ref=850098ebf0d38b3495fe0867e1548661155b2a7d", "patch": "@@ -0,0 +1,278 @@\n+#!/usr/bin/env python3\n+#\n+# Checks some of the GNU style formatting rules in a set of patches.\n+# The script is a rewritten of the same bash script and should eventually\n+# replace the former script.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+#\n+# The script requires python packages, which can be installed via pip3\n+# like this:\n+# $ pip3 install unidiff termcolor \n+\n+import sys\n+import re\n+import argparse\n+import unittest\n+\n+try:\n+    from termcolor import colored\n+except ImportError:\n+    print('termcolor module is missing (run: pip3 install termcolor)')\n+    exit(3)\n+\n+try:\n+    from unidiff import PatchSet\n+except ImportError:\n+    print('unidiff module is missing (run: pip3 install unidiff)')\n+    exit(3)\n+\n+from itertools import *\n+\n+ws_char = '\u2588'\n+ts = 8\n+\n+def error_string(s):\n+    return colored(s, 'red', attrs = ['bold'])\n+\n+class CheckError:\n+    def __init__(self, filename, lineno, console_error, error_message,\n+        column = -1):\n+        self.filename = filename\n+        self.lineno = lineno\n+        self.console_error = console_error\n+        self.error_message = error_message\n+        self.column = column\n+\n+    def error_location(self):\n+        return '%s:%d:%d:' % (self.filename, self.lineno,\n+            self.column if self.column != -1 else -1)\n+\n+class LineLengthCheck:\n+    def __init__(self):\n+        self.limit = 80\n+        self.expanded_tab = ' ' * ts\n+\n+    def check(self, filename, lineno, line):\n+        line_expanded = line.replace('\\t', self.expanded_tab)\n+        if len(line_expanded) > self.limit:\n+            return CheckError(filename, lineno,\n+                line_expanded[:self.limit]\n+                    + error_string(line_expanded[self.limit:]),\n+                'lines should not exceed 80 characters', self.limit)\n+\n+        return None\n+\n+class SpacesCheck:\n+    def __init__(self):\n+        self.expanded_tab = ' ' * ts\n+\n+    def check(self, filename, lineno, line):\n+        i = line.find(self.expanded_tab)\n+        if i != -1:\n+            return CheckError(filename, lineno,\n+                line.replace(self.expanded_tab, error_string(ws_char * ts)),\n+                'blocks of 8 spaces should be replaced with tabs', i)\n+\n+class TrailingWhitespaceCheck:\n+    def __init__(self):\n+        self.re = re.compile('(\\s+)$')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'trailing whitespace', m.start(1))\n+\n+class SentenceSeparatorCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\.(\\s|\\s{3,})\\w')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'dot, space, space, new sentence', m.start(1))\n+\n+class SentenceEndOfCommentCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\.(\\s{0,1}|\\s{3,})\\*/')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'dot, space, space, end of comment', m.start(1))\n+\n+class SentenceDotEndCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w(\\s*\\*/)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'dot, space, space, end of comment', m.start(1))\n+\n+class FunctionParenthesisCheck:\n+    # TODO: filter out GTY stuff\n+    def __init__(self):\n+        self.re = re.compile('\\w(\\s{2,})?(\\()')\n+\n+    def check(self, filename, lineno, line):\n+        if '#define' in line:\n+            return None\n+\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n+                'there should be exactly one space between function name ' \\\n+                'and parenthesis', m.start(2))\n+\n+class SquareBracketCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\s+(\\[)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'there should be no space before a left square bracket',\n+                m.start(1))\n+\n+class ClosingParenthesisCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\S\\s+(\\))')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'there should be no space before closing parenthesis',\n+                m.start(1))\n+\n+class BracesOnSeparateLineCheck:\n+    # This will give false positives for C99 compound literals.\n+\n+    def __init__(self):\n+        self.re = re.compile('(\\)|else)\\s*({)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n+                'braces should be on a separate line', m.start(2))\n+\n+class TrailinigOperatorCheck:\n+    def __init__(self):\n+        regex = '^\\s.*(([^a-zA-Z_]\\*)|([-%<=&|^?])|([^*]/)|([^:][+]))$'\n+        self.re = re.compile(regex)\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'trailing operator', m.start(1))\n+\n+class LineLengthTest(unittest.TestCase):\n+    def setUp(self):\n+        self.check = LineLengthCheck()\n+\n+    def test_line_length_check_basic(self):\n+        r = self.check.check('foo', 123, self.check.limit * 'a' + ' = 123;')\n+        self.assertIsNotNone(r)\n+        self.assertEqual('foo', r.filename)\n+        self.assertEqual(80, r.column)\n+        self.assertEqual(r.console_error,\n+            self.check.limit * 'a' + error_string(' = 123;'))\n+\n+def main():\n+    parser = argparse.ArgumentParser(description='Check GNU coding style.')\n+    parser.add_argument('file', help = 'File with a patch')\n+    parser.add_argument('-f', '--format', default = 'stdio',\n+        help = 'Display format',\n+        choices = ['stdio', 'quickfix'])\n+    args = parser.parse_args()\n+\n+    checks = [LineLengthCheck(), SpacesCheck(), TrailingWhitespaceCheck(),\n+        SentenceSeparatorCheck(), SentenceEndOfCommentCheck(),\n+        SentenceDotEndCheck(), FunctionParenthesisCheck(),\n+        SquareBracketCheck(), ClosingParenthesisCheck(),\n+        BracesOnSeparateLineCheck(), TrailinigOperatorCheck()]\n+    errors = []\n+\n+    with open(args.file, 'rb') as diff_file:\n+        patch = PatchSet(diff_file, encoding = 'utf-8')\n+\n+    for pfile in patch.added_files + patch.modified_files:\n+        t = pfile.target_file.lstrip('b/')\n+        # Skip testsuite files\n+        if 'testsuite' in t:\n+            continue\n+\n+        for hunk in pfile:\n+            delta = 0\n+            for line in hunk:\n+                if line.is_added and line.target_line_no != None:\n+                    for check in checks:\n+                        e = check.check(t, line.target_line_no, line.value)\n+                        if e != None:\n+                            errors.append(e)\n+\n+    if args.format == 'stdio':\n+        fn = lambda x: x.error_message\n+        i = 1\n+        for (k, errors) in groupby(sorted(errors, key = fn), fn):\n+            errors = list(errors)\n+            print('=== ERROR type #%d: %s (%d error(s)) ==='\n+                % (i, k, len(errors)))\n+            i += 1\n+            for e in errors:\n+                print(e.error_location () + e.console_error)\n+            print()\n+\n+        exit(0 if len(errors) == 0 else 1)\n+    elif args.format == 'quickfix':\n+        f = 'errors.err'\n+        with open(f, 'w+') as qf:\n+            for e in errors:\n+                qf.write('%s%s\\n' % (e.error_location(), e.error_message))\n+        if len(errors) == 0:\n+            exit(0)\n+        else:\n+            print('%d error(s) written to %s file.' % (len(errors), f))\n+            exit(1)\n+    else:\n+        assert False\n+\n+if __name__ == '__main__':\n+    if len(sys.argv) > 1:\n+        main()\n+    else:\n+        unittest.main()"}]}