{"sha": "d531830f5db3d08322202915d9b44572f410841e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzMTgzMGY1ZGIzZDA4MzIyMjAyOTE1ZDliNDQ1NzJmNDEwODQxZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-11-28T07:29:43Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2005-11-28T07:29:43Z"}, "message": "re PR middle-end/20219 (Missed optimisation sin / tan --> cos)\n\n\tPR middle-end/20219\n\t* fold-const.c (fold binary) <RDIV_EXPR>: Optimize \n\tsin(x)/tan(x) as cos(x) and tan(x)/sin(x) as 1.0/cos(x)\n\twhen flag_unsafe_math_optimizations is set and\n\twe don't care about NaNs or Infinities.\n\n\tMove x/expN(y) and x/pow(y,z) transformation into common\n\tflag_unsafe_math_optimizations section.\n\ntestsuite/\n\n\t* gcc.dg/builtins-20.c: Add checks for sin(x)/tan(x) and\n\ttan(x)/sin(x) transformations.\n\n\nCo-Authored-By: Uros Bizjak <uros@kss-loka.si>\n\nFrom-SVN: r107597", "tree": {"sha": "9646964189188ede7d11f7784543cb37d50fac04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9646964189188ede7d11f7784543cb37d50fac04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d531830f5db3d08322202915d9b44572f410841e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d531830f5db3d08322202915d9b44572f410841e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d531830f5db3d08322202915d9b44572f410841e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d531830f5db3d08322202915d9b44572f410841e/comments", "author": null, "committer": null, "parents": [{"sha": "401cd90a905d8cf4ad2339da824e13943912a89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401cd90a905d8cf4ad2339da824e13943912a89c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401cd90a905d8cf4ad2339da824e13943912a89c"}], "stats": {"total": 140, "additions": 110, "deletions": 30}, "files": [{"sha": "52b1880eb0da99d0b119f52e19985e341c6588d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d531830f5db3d08322202915d9b44572f410841e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d531830f5db3d08322202915d9b44572f410841e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d531830f5db3d08322202915d9b44572f410841e", "patch": "@@ -1,3 +1,15 @@\n+2005-11-28  Roger Sayle  <roger@eyesopen.com>\n+\t    Uros Bizjak  <uros@kss-loka.si>\n+\n+\tPR middle-end/20219\n+\t* fold-const.c (fold binary) <RDIV_EXPR>: Optimize \n+\tsin(x)/tan(x) as cos(x) and tan(x)/sin(x) as 1.0/cos(x)\n+\twhen flag_unsafe_math_optimizations is set and\n+\twe don't care about NaNs or Infinities.\n+\n+\tMove x/expN(y) and x/pow(y,z) transformation into common\n+\tflag_unsafe_math_optimizations section.\n+\n 2005-11-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.c (main): Change type of argv to \"char **\"."}, {"sha": "2d80e66eb05f08fdaf671e0b8c6e152d64053658", "filename": "gcc/fold-const.c", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d531830f5db3d08322202915d9b44572f410841e", "patch": "@@ -8363,36 +8363,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\tTREE_OPERAND (arg1, 0));\n \t}\n \n-      if (flag_unsafe_math_optimizations)\n-\t{\n-\t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n-\t  /* Optimize x/expN(y) into x*expN(-y).  */\n-\t  if (BUILTIN_EXPONENT_P (fcode))\n-\t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg = negate_expr (TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t      tree arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t\t      fold_convert (type, arg));\n-\t      arg1 = build_function_call_expr (expfn, arglist);\n-\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n-\t    }\n-\n-\t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n-\t  if (fcode == BUILT_IN_POW\n-\t      || fcode == BUILT_IN_POWF\n-\t      || fcode == BUILT_IN_POWL)\n-\t    {\n-\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t      tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1, 1)));\n-\t      tree neg11 = fold_convert (type, negate_expr (arg11));\n-\t      tree arglist = tree_cons(NULL_TREE, arg10,\n-\t\t\t\t       build_tree_list (NULL_TREE, neg11));\n-\t      arg1 = build_function_call_expr (powfn, arglist);\n-\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n-\t    }\n-\t}\n-\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  enum built_in_function fcode0 = builtin_mathfn_code (arg0);\n@@ -8430,6 +8400,53 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t}\n \t    }\n \n+ \t  /* Optimize sin(x)/tan(x) as cos(x) if we don't care about\n+\t     NaNs or Infinities.  */\n+ \t  if (((fcode0 == BUILT_IN_SIN && fcode1 == BUILT_IN_TAN)\n+ \t       || (fcode0 == BUILT_IN_SINF && fcode1 == BUILT_IN_TANF)\n+ \t       || (fcode0 == BUILT_IN_SINL && fcode1 == BUILT_IN_TANL)))\n+\t    {\n+\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t      tree arg01 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\n+\t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n+\t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n+\t\t  && operand_equal_p (arg00, arg01, 0))\n+\t\t{\n+\t\t  tree cosfn = mathfn_built_in (type, BUILT_IN_COS);\n+\n+\t\t  if (cosfn != NULL_TREE)\n+\t\t    return build_function_call_expr (cosfn,\n+\t\t\t\t\t\t     TREE_OPERAND (arg0, 1));\n+\t\t}\n+\t    }\n+\n+ \t  /* Optimize tan(x)/sin(x) as 1.0/cos(x) if we don't care about\n+\t     NaNs or Infintes.  */\n+ \t  if (((fcode0 == BUILT_IN_TAN && fcode1 == BUILT_IN_SIN)\n+ \t       || (fcode0 == BUILT_IN_TANF && fcode1 == BUILT_IN_SINF)\n+ \t       || (fcode0 == BUILT_IN_TANL && fcode1 == BUILT_IN_SINL)))\n+\t    {\n+\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t      tree arg01 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\n+\t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n+\t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n+\t\t  && operand_equal_p (arg00, arg01, 0))\n+\t\t{\n+\t\t  tree cosfn = mathfn_built_in (type, BUILT_IN_COS);\n+\n+\t\t  if (cosfn != NULL_TREE)\n+\t\t    {\n+\t\t      tree tmp = TREE_OPERAND (arg0, 1);\n+\t\t      tmp = build_function_call_expr (cosfn, tmp);\n+\t\t      return fold (build (RDIV_EXPR, type,\n+\t\t\t\t\t  build_real (type, dconst1),\n+\t\t\t\t\t  tmp));\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  /* Optimize pow(x,c)/x as pow(x,c-1).  */\n \t  if (fcode0 == BUILT_IN_POW\n \t      || fcode0 == BUILT_IN_POWF\n@@ -8453,6 +8470,32 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  return build_function_call_expr (powfn, arglist);\n \t\t}\n \t    }\n+\n+\t  /* Optimize x/expN(y) into x*expN(-y).  */\n+\t  if (BUILTIN_EXPONENT_P (fcode1))\n+\t    {\n+\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n+\t      tree arg = negate_expr (TREE_VALUE (TREE_OPERAND (arg1, 1)));\n+\t      tree arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t\t      fold_convert (type, arg));\n+\t      arg1 = build_function_call_expr (expfn, arglist);\n+\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n+\t    }\n+\n+\t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n+\t  if (fcode1 == BUILT_IN_POW\n+\t      || fcode1 == BUILT_IN_POWF\n+\t      || fcode1 == BUILT_IN_POWL)\n+\t    {\n+\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n+\t      tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t      tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1, 1)));\n+\t      tree neg11 = fold_convert (type, negate_expr (arg11));\n+\t      tree arglist = tree_cons(NULL_TREE, arg10,\n+\t\t\t\t       build_tree_list (NULL_TREE, neg11));\n+\t      arg1 = build_function_call_expr (powfn, arglist);\n+\t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n+\t    }\n \t}\n       goto binary;\n "}, {"sha": "75ca6e4214c3347739f44e37124d7edaa451af30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d531830f5db3d08322202915d9b44572f410841e", "patch": "@@ -1,3 +1,10 @@\n+2005-11-28  Roger Sayle  <roger@eyesopen.com>\n+\t    Uros Bizjak  <uros@kss-loka.si>\n+\n+\tPR middle-end/20219\n+\t* gcc.dg/builtins-20.c: Add checks for sin(x)/tan(x) and\n+\ttan(x)/sin(x) transformations.\n+\n 2005-11-27  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/24575"}, {"sha": "a8ada8a8606c8d150f04adb6669d56bd2b6971eb", "filename": "gcc/testsuite/gcc.dg/builtins-20.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d531830f5db3d08322202915d9b44572f410841e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c?ref=d531830f5db3d08322202915d9b44572f410841e", "patch": "@@ -39,6 +39,12 @@ void test1(double x)\n \n   if (cos(x)*tan(x) != sin(x))\n     link_error ();\n+\n+  if (sin(x)/tan(x) != cos(x))\n+    link_error ();\n+\n+  if (tan(x)/sin(x) != 1.0/cos(x))\n+    link_error ();\n }\n \n void test2(double x, double y)\n@@ -67,6 +73,12 @@ void test1f(float x)\n \n   if (cosf(x)*tanf(x) != sinf(x))\n     link_error ();\n+\n+  if (sinf(x)/tanf(x) != cosf(x))\n+    link_error ();\n+\n+  if (tanf(x)/sinf(x) != 1.0f/cosf(x))\n+    link_error ();\n #endif\n }\n \n@@ -97,6 +109,12 @@ void test1l(long double x)\n \n   if (cosl(x)*tanl(x) != sinl(x))\n     link_error ();\n+\n+  if (sinl(x)/tanl(x) != cosl(x))\n+    link_error ();\n+\n+  if (tanl(x)/sinl(x) != 1.0l/cosl(x))\n+    link_error ();\n #endif\n }\n "}]}