{"sha": "4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVmZGJlNWE3MzU4ZmNiYjEzNWRkNjgyMmY5YjhmNGFhYWI4YWNlMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-11-18T07:56:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-11-18T07:56:13Z"}, "message": "compiler: Adjust for vec changes.\n\nFrom-SVN: r193596", "tree": {"sha": "3f49a3443267075d14302d2a7475c7ed65b241cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f49a3443267075d14302d2a7475c7ed65b241cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2/comments", "author": null, "committer": null, "parents": [{"sha": "9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}], "stats": {"total": 126, "additions": 68, "deletions": 58}, "files": [{"sha": "4ff6272ad6f2ff2c0c4f18308fee8a46e9996c6e", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "patch": "@@ -180,24 +180,25 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n       // Assigning nil to an open array.\n       go_assert(TREE_CODE(lhs_type_tree) == RECORD_TYPE);\n \n-      VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n+      vec<constructor_elt, va_gc> *init;\n+      vec_alloc(init, 3);\n \n       constructor_elt empty = {NULL, NULL};\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+      constructor_elt* elt = init->quick_push(empty);\n       tree field = TYPE_FIELDS(lhs_type_tree);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__values\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-      elt = VEC_quick_push(constructor_elt, init, empty);\n+      elt = init->quick_push(empty);\n       field = DECL_CHAIN(field);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__count\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), integer_zero_node);\n \n-      elt = VEC_quick_push(constructor_elt, init, empty);\n+      elt = init->quick_push(empty);\n       field = DECL_CHAIN(field);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__capacity\") == 0);\n@@ -320,18 +321,19 @@ Expression::convert_type_to_interface(Translate_context* context,\n \n   // Start building a constructor for the value we will return.\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, 2);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(lhs_type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t    (lhs_is_empty ? \"__type_descriptor\" : \"__methods\")) == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n                                 first_field_value);\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n@@ -445,10 +447,11 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \n   // The result is going to be a two element constructor.\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc (init, 2);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(lhs_type_tree);\n   elt->index = field;\n \n@@ -511,7 +514,7 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \n   // The second field is simply the object pointer.\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n@@ -10016,23 +10019,24 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   tree struct_tree = type_to_tree(this->type()->get_backend(gogo));\n   go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc (init, 3);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(struct_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = value_pointer;\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(loc.gcc_location(), TREE_TYPE(field),\n                                 result_length_tree);\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n   elt->index = field;\n@@ -11385,8 +11389,8 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n \n   bool is_constant = true;\n   const Struct_field_list* fields = this->type_->struct_type()->fields();\n-  VEC(constructor_elt,gc)* elts = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t    fields->size());\n+  vec<constructor_elt, va_gc> *elts;\n+  vec_alloc (elts, fields->size());\n   Struct_field_list::const_iterator pf = fields->begin();\n   Expression_list::const_iterator pv = this->vals_->begin();\n   for (tree field = TYPE_FIELDS(type_tree);\n@@ -11418,7 +11422,7 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n \treturn error_mark_node;\n \n       constructor_elt empty = {NULL, NULL};\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, elts, empty);\n+      constructor_elt* elt = elts->quick_push(empty);\n       elt->index = field;\n       elt->value = val;\n       if (!TREE_CONSTANT(val))\n@@ -11628,10 +11632,8 @@ tree\n Array_construction_expression::get_constructor_tree(Translate_context* context,\n \t\t\t\t\t\t    tree type_tree)\n {\n-  VEC(constructor_elt,gc)* values = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t      (this->vals_ == NULL\n-\t\t\t\t\t       ? 0\n-\t\t\t\t\t       : this->vals_->size()));\n+  vec<constructor_elt, va_gc> *values;\n+  vec_alloc (values, (this->vals_ == NULL ? 0 : this->vals_->size()));\n   Type* element_type = this->type_->array_type()->element_type();\n   bool is_constant = true;\n   if (this->vals_ != NULL)\n@@ -11647,7 +11649,7 @@ Array_construction_expression::get_constructor_tree(Translate_context* context,\n \t  if (this->indexes_ != NULL)\n \t    go_assert(pi != this->indexes_->end());\n \t  constructor_elt empty = {NULL, NULL};\n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, values, empty);\n+\t  constructor_elt* elt = values->quick_push(empty);\n \n \t  if (this->indexes_ == NULL)\n \t    elt->index = size_int(i);\n@@ -11856,9 +11858,10 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t       build_index_type(max));\n       if (constructor_type == error_mark_node)\n \treturn error_mark_node;\n-      VEC(constructor_elt,gc)* vec = VEC_alloc(constructor_elt, gc, 1);\n+      vec<constructor_elt, va_gc> *vec;\n+      vec_alloc(vec, 1);\n       constructor_elt empty = {NULL, NULL};\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, vec, empty);\n+      constructor_elt* elt = vec->quick_push(empty);\n       elt->index = size_int(0);\n       Gogo* gogo = context->gogo();\n       Btype* btype = element_type->get_backend(gogo);\n@@ -11949,22 +11952,23 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n   go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, 3);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), space);\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), length_tree);\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\"__capacity\") == 0);\n   elt->index = field;\n@@ -12157,19 +12161,20 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n     }\n   else\n     {\n-      VEC(constructor_elt,gc)* values = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t\t  this->vals_->size() / 2);\n+      vec<constructor_elt, va_gc> *values;\n+      vec_alloc(values, this->vals_->size() / 2);\n \n       for (Expression_list::const_iterator pv = this->vals_->begin();\n \t   pv != this->vals_->end();\n \t   ++pv, ++i)\n \t{\n \t  bool one_is_constant = true;\n \n-\t  VEC(constructor_elt,gc)* one = VEC_alloc(constructor_elt, gc, 2);\n+\t  vec<constructor_elt, va_gc> *one;\n+\t  vec_alloc(one, 2);\n \n \t  constructor_elt empty = {NULL, NULL};\n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, one, empty);\n+\t  constructor_elt* elt = one->quick_push(empty);\n \t  elt->index = key_field;\n \t  tree val_tree = (*pv)->get_tree(context);\n \t  elt->value = Expression::convert_for_assignment(context, key_type,\n@@ -12182,7 +12187,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n \t  ++pv;\n \n-\t  elt = VEC_quick_push(constructor_elt, one, empty);\n+\t  elt = one->quick_push(empty);\n \t  elt->index = val_field;\n \t  val_tree = (*pv)->get_tree(context);\n \t  elt->value = Expression::convert_for_assignment(context, val_type,\n@@ -12193,7 +12198,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \t  if (!TREE_CONSTANT(elt->value))\n \t    one_is_constant = false;\n \n-\t  elt = VEC_quick_push(constructor_elt, values, empty);\n+\t  elt = values->quick_push(empty);\n \t  elt->index = size_int(i);\n \t  elt->value = build_constructor(struct_type, one);\n \t  if (one_is_constant)"}, {"sha": "95ec70eafc2a1bb538432f387ed0214edb7016d1", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=4efdbe5a7358fcbb135dd6822f9b8f4aaab8ace2", "patch": "@@ -344,64 +344,67 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n \n   // Build an initialier for the __roots array.\n \n-  VEC(constructor_elt,gc)* roots_init = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t\t  count + 1);\n+  vec<constructor_elt, va_gc> *roots_init;\n+  vec_alloc(roots_init, count + 1);\n \n   size_t i = 0;\n   for (std::vector<Named_object*>::const_iterator p = var_gc.begin();\n        p != var_gc.end();\n        ++p, ++i)\n     {\n-      VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+      vec<constructor_elt, va_gc> *init;\n+      vec_alloc(init, 2);\n \n       constructor_elt empty = {NULL, NULL};\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+      constructor_elt* elt = init->quick_push(empty);\n       tree field = TYPE_FIELDS(root_type);\n       elt->index = field;\n       Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n       tree decl = var_to_tree(bvar);\n       go_assert(TREE_CODE(decl) == VAR_DECL);\n       elt->value = build_fold_addr_expr(decl);\n \n-      elt = VEC_quick_push(constructor_elt, init, empty);\n+      elt = init->quick_push(empty);\n       field = DECL_CHAIN(field);\n       elt->index = field;\n       elt->value = DECL_SIZE_UNIT(decl);\n \n-      elt = VEC_quick_push(constructor_elt, roots_init, empty);\n+      elt = roots_init->quick_push(empty);\n       elt->index = size_int(i);\n       elt->value = build_constructor(root_type, init);\n     }\n \n   // The list ends with a NULL entry.\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, 2);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(root_type);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   elt->index = field;\n   elt->value = size_zero_node;\n \n-  elt = VEC_quick_push(constructor_elt, roots_init, empty);\n+  elt = roots_init->quick_push(empty);\n   elt->index = size_int(i);\n   elt->value = build_constructor(root_type, init);\n \n   // Build a constructor for the struct.\n \n-  VEC(constructor_elt,gc)* root_list_init = VEC_alloc(constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *root_list_init;\n+  vec_alloc(root_list_init, 2);\n \n-  elt = VEC_quick_push(constructor_elt, root_list_init, empty);\n+  elt = root_list_init->quick_push(empty);\n   field = TYPE_FIELDS(root_list_type);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-  elt = VEC_quick_push(constructor_elt, root_list_init, empty);\n+  elt = root_list_init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   elt->index = field;\n   elt->value = build_constructor(array_type, roots_init);\n@@ -2030,18 +2033,19 @@ Gogo::go_string_constant_tree(const std::string& val)\n {\n   tree string_type = type_to_tree(Type::make_string_type()->get_backend(this));\n \n-  VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, 2);\n \n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   tree field = TYPE_FIELDS(string_type);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n   elt->index = field;\n   tree str = Gogo::string_constant_tree(val);\n   elt->value = fold_convert(TREE_TYPE(field),\n \t\t\t    build_fold_addr_expr(str));\n \n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n   elt->index = field;\n@@ -2089,12 +2093,13 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n {\n   go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE);\n \n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, 3);\n \n   tree field = TYPE_FIELDS(slice_type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n+  constructor_elt* elt = init->quick_push(empty);\n   elt->index = field;\n   go_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n \t     == TYPE_MAIN_VARIANT(TREE_TYPE(values)));\n@@ -2109,13 +2114,13 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n \n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), count);\n \n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n-  elt = VEC_quick_push(constructor_elt, init, empty);\n+  elt = init->quick_push(empty);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), capacity);\n \n@@ -2172,12 +2177,12 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n     }\n \n   size_t count = interface_methods->size();\n-  VEC(constructor_elt, gc)* pointers = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t\t count + 1);\n+  vec<constructor_elt, va_gc> *pointers;\n+  vec_alloc(pointers, count + 1);\n \n   // The first element is the type descriptor.\n   constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, pointers, empty);\n+  constructor_elt* elt = pointers->quick_push(empty);\n   elt->index = size_zero_node;\n   Type* td_type;\n   if (!is_pointer)\n@@ -2218,7 +2223,7 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n \tgo_unreachable();\n       fndecl = build_fold_addr_expr(fndecl);\n \n-      elt = VEC_quick_push(constructor_elt, pointers, empty);\n+      elt = pointers->quick_push(empty);\n       elt->index = size_int(i);\n       elt->value = fold_convert(const_ptr_type_node, fndecl);\n     }"}]}