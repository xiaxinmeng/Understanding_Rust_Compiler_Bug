{"sha": "d74be3171290547f3311f959351e0c3afe7dcd21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0YmUzMTcxMjkwNTQ3ZjMzMTFmOTU5MzUxZTBjM2FmZTdkY2QyMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-26T15:53:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-26T15:53:23Z"}, "message": "lto.c (uniquify_nodes): Fix bug in one of the previous changes.\n\n2011-05-26  Richard Guenther  <rguenther@suse.de>\n\n\tlto/\n\t* lto.c (uniquify_nodes): Fix bug in one of the previous changes.\n\nFrom-SVN: r174296", "tree": {"sha": "c8a50e2aa082687b2d4e7d0169e2b0849e91c113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8a50e2aa082687b2d4e7d0169e2b0849e91c113"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74be3171290547f3311f959351e0c3afe7dcd21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74be3171290547f3311f959351e0c3afe7dcd21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74be3171290547f3311f959351e0c3afe7dcd21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74be3171290547f3311f959351e0c3afe7dcd21/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3677132a22eb57336e8a749a19f346ac46cdca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3677132a22eb57336e8a749a19f346ac46cdca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3677132a22eb57336e8a749a19f346ac46cdca8"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "9412f76ae1d47b5de0867bfa7ceaebdd17fe6d5b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74be3171290547f3311f959351e0c3afe7dcd21/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74be3171290547f3311f959351e0c3afe7dcd21/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d74be3171290547f3311f959351e0c3afe7dcd21", "patch": "@@ -1,3 +1,7 @@\n+2011-05-26  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (uniquify_nodes): Fix bug in one of the previous changes.\n+\n 2011-05-25  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* lto.c (lto_ft_typed): New function."}, {"sha": "9d4e2edd250851ef98a4426d1e487783ab79a648", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74be3171290547f3311f959351e0c3afe7dcd21/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74be3171290547f3311f959351e0c3afe7dcd21/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=d74be3171290547f3311f959351e0c3afe7dcd21", "patch": "@@ -610,33 +610,36 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n \t    }\n \t}\n \n-      else if (RECORD_OR_UNION_TYPE_P (t))\n+      else\n \t{\n-\t  tree f1, f2;\n-\t  if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n-\t    for (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n-\t\t f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t      {\n-\t\tunsigned ix;\n-\t\tgcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n-\t\tif (!lto_streamer_cache_lookup (cache, f2, &ix))\n-\t\t  gcc_unreachable ();\n-\t\t/* If we're going to replace an element which we'd\n-\t\t   still visit in the next iterations, we wouldn't\n-\t\t   handle it, so do it here.  We do have to handle it\n-\t\t   even though the field_decl itself will be removed,\n-\t\t   as it could refer to e.g. integer_cst which we\n-\t\t   wouldn't reach via any other way, hence they\n-\t\t   (and their type) would stay uncollected.  */\n-\t\t/* ???  We should rather make sure to replace all\n-\t\t   references to f2 with f1.  That means handling\n-\t\t   COMPONENT_REFs and CONSTRUCTOR elements in\n-\t\t   lto_fixup_types and special-case the field-decl\n-\t\t   operand handling.  */\n-\t\tif (ix < i)\n-\t\t  lto_fixup_types (f2);\n-\t\tlto_streamer_cache_insert_at (cache, f1, ix);\n-\t      }\n+\t  if (RECORD_OR_UNION_TYPE_P (t))\n+\t    {\n+\t      tree f1, f2;\n+\t      if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n+\t\tfor (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n+\t\t     f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t\t  {\n+\t\t    unsigned ix;\n+\t\t    gcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n+\t\t    if (!lto_streamer_cache_lookup (cache, f2, &ix))\n+\t\t      gcc_unreachable ();\n+\t\t    /* If we're going to replace an element which we'd\n+\t\t       still visit in the next iterations, we wouldn't\n+\t\t       handle it, so do it here.  We do have to handle it\n+\t\t       even though the field_decl itself will be removed,\n+\t\t       as it could refer to e.g. integer_cst which we\n+\t\t       wouldn't reach via any other way, hence they\n+\t\t       (and their type) would stay uncollected.  */\n+\t\t    /* ???  We should rather make sure to replace all\n+\t\t       references to f2 with f1.  That means handling\n+\t\t       COMPONENT_REFs and CONSTRUCTOR elements in\n+\t\t       lto_fixup_types and special-case the field-decl\n+\t\t       operand handling.  */\n+\t\t    if (ix < i)\n+\t\t      lto_fixup_types (f2);\n+\t\t    lto_streamer_cache_insert_at (cache, f1, ix);\n+\t\t  }\n+\t    }\n \n \t  /* If we found a tree that is equal to oldt replace it in the\n \t     cache, so that further users (in the various LTO sections)"}]}