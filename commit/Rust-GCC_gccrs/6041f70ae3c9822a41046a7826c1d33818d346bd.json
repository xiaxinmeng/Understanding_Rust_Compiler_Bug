{"sha": "6041f70ae3c9822a41046a7826c1d33818d346bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0MWY3MGFlM2M5ODIyYTQxMDQ2YTc4MjZjMWQzMzgxOGQzNDZiZA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-22T16:13:06Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-22T16:13:06Z"}, "message": "libitm: Fix HTM fastpath.\n\n\t* beginend.cc (GTM::gtm_thread::serial_lock): Put on cacheline\n\tboundary.\n\t(htm_fastpath): Remove.\n\t(gtm_thread::begin_transaction): Fix HTM fastpath.\n\t(_ITM_commitTransaction): Adapt.\n\t(_ITM_commitTransactionEH): Adapt.\n\t* libitm/config/linux/rwlock.h (gtm_rwlock): Add htm_fastpath member\n\tand accessors.\n\t* libitm/config/posix/rwlock.h (gtm_rwlock): Likewise.\n\t* libitm/config/posix/rwlock.cc (gtm_rwlock::gtm_rwlock): Adapt.\n\t* libitm/config/x86/sjlj.S (_ITM_beginTransaction): Fix HTM fastpath.\n\t* libitm/libitm_i.h (htm_fastpath): Remove declaration.\n\t* libitm/method-serial.cc (htm_mg): Adapt.\n\t(gtm_thread::serialirr_mode): Adapt.\n\t* libitm/query.cc (_ITM_inTransaction, _ITM_getTransactionId): Adapt.\n\nFrom-SVN: r232735", "tree": {"sha": "11c4d3a4315d5b73971745da630b492a4481574a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11c4d3a4315d5b73971745da630b492a4481574a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6041f70ae3c9822a41046a7826c1d33818d346bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6041f70ae3c9822a41046a7826c1d33818d346bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6041f70ae3c9822a41046a7826c1d33818d346bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6041f70ae3c9822a41046a7826c1d33818d346bd/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "057f7d3afdba4fb5b8119d225140b94f37d1ac70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057f7d3afdba4fb5b8119d225140b94f37d1ac70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/057f7d3afdba4fb5b8119d225140b94f37d1ac70"}], "stats": {"total": 174, "additions": 128, "deletions": 46}, "files": [{"sha": "2a3554fd6af1ec3f393cf980ba2fa8c91b8a4108", "filename": "libitm/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -1,3 +1,21 @@\n+2016-01-22  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_thread::serial_lock): Put on cacheline\n+\tboundary.\n+\t(htm_fastpath): Remove.\n+\t(gtm_thread::begin_transaction): Fix HTM fastpath.\n+\t(_ITM_commitTransaction): Adapt.\n+\t(_ITM_commitTransactionEH): Adapt.\n+\t* libitm/config/linux/rwlock.h (gtm_rwlock): Add htm_fastpath member\n+\tand accessors.\n+\t* libitm/config/posix/rwlock.h (gtm_rwlock): Likewise.\n+\t* libitm/config/posix/rwlock.cc (gtm_rwlock::gtm_rwlock): Adapt.\n+\t* libitm/config/x86/sjlj.S (_ITM_beginTransaction): Fix HTM fastpath.\n+\t* libitm/libitm_i.h (htm_fastpath): Remove declaration.\n+\t* libitm/method-serial.cc (htm_mg): Adapt.\n+\t(gtm_thread::serialirr_mode): Adapt.\n+\t* libitm/query.cc (_ITM_inTransaction, _ITM_getTransactionId): Adapt.\n+\n 2016-01-21  Torvald Riegel  <triegel@redhat.com>\n \n \t* testsuite/libitm.c++/libstdc++-safeexc.C: Not supported on darwin"}, {"sha": "1a258ad7965ee23ac589f319a8ea1d8f1be35589", "filename": "libitm/beginend.cc", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -32,7 +32,11 @@ using namespace GTM;\n extern __thread gtm_thread_tls _gtm_thr_tls;\n #endif\n \n-gtm_rwlock GTM::gtm_thread::serial_lock;\n+// Put this at the start of a cacheline so that serial_lock's writers and\n+// htm_fastpath fields are on the same cacheline, so that HW transactions\n+// only have to pay one cacheline capacity to monitor both.\n+gtm_rwlock GTM::gtm_thread::serial_lock\n+  __attribute__((aligned(HW_CACHELINE_SIZE)));\n gtm_thread *GTM::gtm_thread::list_of_threads = 0;\n unsigned GTM::gtm_thread::number_of_threads = 0;\n \n@@ -51,9 +55,6 @@ static pthread_mutex_t global_tid_lock = PTHREAD_MUTEX_INITIALIZER;\n static pthread_key_t thr_release_key;\n static pthread_once_t thr_release_once = PTHREAD_ONCE_INIT;\n \n-// See gtm_thread::begin_transaction.\n-uint32_t GTM::htm_fastpath = 0;\n-\n /* Allocate a transaction structure.  */\n void *\n GTM::gtm_thread::operator new (size_t s)\n@@ -173,9 +174,11 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   // lock's writer flag and thus abort if another thread is or becomes a\n   // serial transaction.  Therefore, if the fastpath is enabled, then a\n   // transaction is not executing as a HW transaction iff the serial lock is\n-  // write-locked.  This allows us to use htm_fastpath and the serial lock's\n-  // writer flag to reliable determine whether the current thread runs a HW\n-  // transaction, and thus we do not need to maintain this information in\n+  // write-locked.  Also, HW transactions monitor the fastpath control\n+  // variable, so that they will only execute if dispatch_htm is still the\n+  // current method group.  This allows us to use htm_fastpath and the serial\n+  // lock's writers flag to reliable determine whether the current thread runs\n+  // a HW transaction, and thus we do not need to maintain this information in\n   // per-thread state.\n   // If an uninstrumented code path is not available, we can still run\n   // instrumented code from a HW transaction because the HTM fastpath kicks\n@@ -187,19 +190,26 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   // for any internal changes (e.g., they never abort visibly to the STM code\n   // and thus do not trigger the standard retry handling).\n #ifndef HTM_CUSTOM_FASTPATH\n-  if (likely(htm_fastpath && (prop & pr_hasNoAbort)))\n+  if (likely(serial_lock.get_htm_fastpath() && (prop & pr_hasNoAbort)))\n     {\n-      for (uint32_t t = htm_fastpath; t; t--)\n+      // Note that the snapshot of htm_fastpath that we take here could be\n+      // outdated, and a different method group than dispatch_htm may have\n+      // been chosen in the meantime.  Therefore, take care not not touch\n+      // anything besides the serial lock, which is independent of method\n+      // groups.\n+      for (uint32_t t = serial_lock.get_htm_fastpath(); t; t--)\n \t{\n \t  uint32_t ret = htm_begin();\n \t  if (htm_begin_success(ret))\n \t    {\n \t      // We are executing a transaction now.\n \t      // Monitor the writer flag in the serial-mode lock, and abort\n \t      // if there is an active or waiting serial-mode transaction.\n+\t      // Also checks that htm_fastpath is still nonzero and thus\n+\t      // HW transactions are allowed to run.\n \t      // Note that this can also happen due to an enclosing\n \t      // serial-mode transaction; we handle this case below.\n-\t      if (unlikely(serial_lock.is_write_locked()))\n+\t      if (unlikely(serial_lock.htm_fastpath_disabled()))\n \t\thtm_abort();\n \t      else\n \t\t// We do not need to set a_saveLiveVariables because of HTM.\n@@ -210,9 +220,12 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n \t  // retrying the transaction will be successful.\n \t  if (!htm_abort_should_retry(ret))\n \t    break;\n+\t  // Check whether the HTM fastpath has been disabled.\n+\t  if (!serial_lock.get_htm_fastpath())\n+\t    break;\n \t  // Wait until any concurrent serial-mode transactions have finished.\n \t  // This is an empty critical section, but won't be elided.\n-\t  if (serial_lock.is_write_locked())\n+\t  if (serial_lock.htm_fastpath_disabled())\n \t    {\n \t      tx = gtm_thr();\n \t      if (unlikely(tx == NULL))\n@@ -247,7 +260,7 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   // HTM fastpath aborted, and that we thus have to decide whether to retry\n   // the fastpath (returning a_tryHTMFastPath) or just proceed with the\n   // fallback method.\n-  if (likely(htm_fastpath && (prop & pr_HTMRetryableAbort)))\n+  if (likely(serial_lock.get_htm_fastpath() && (prop & pr_HTMRetryableAbort)))\n     {\n       tx = gtm_thr();\n       if (unlikely(tx == NULL))\n@@ -261,13 +274,15 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n       // other fallback will use serial transactions, which don't use\n       // restart_total but will reset it when committing.\n       if (!(prop & pr_HTMRetriedAfterAbort))\n-\ttx->restart_total = htm_fastpath;\n+\ttx->restart_total = gtm_thread::serial_lock.get_htm_fastpath();\n \n       if (--tx->restart_total > 0)\n \t{\n \t  // Wait until any concurrent serial-mode transactions have finished.\n \t  // Essentially the same code as above.\n-\t  if (serial_lock.is_write_locked())\n+\t  if (!serial_lock.get_htm_fastpath())\n+\t    goto stop_custom_htm_fastpath;\n+\t  if (serial_lock.htm_fastpath_disabled())\n \t    {\n \t      if (tx->nesting > 0)\n \t\tgoto stop_custom_htm_fastpath;\n@@ -691,7 +706,7 @@ _ITM_commitTransaction(void)\n   // a serial-mode transaction.  If we are, then there will be no other\n   // concurrent serial-mode transaction.\n   // See gtm_thread::begin_transaction.\n-  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+  if (likely(!gtm_thread::serial_lock.htm_fastpath_disabled()))\n     {\n       htm_commit();\n       return;\n@@ -707,7 +722,7 @@ _ITM_commitTransactionEH(void *exc_ptr)\n {\n #if defined(USE_HTM_FASTPATH)\n   // See _ITM_commitTransaction.\n-  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+  if (likely(!gtm_thread::serial_lock.htm_fastpath_disabled()))\n     {\n       htm_commit();\n       return;"}, {"sha": "4dd1dab80cb951c5a0ae3a73c849b6ef9cdb597d", "filename": "libitm/config/linux/rwlock.h", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Flinux%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Flinux%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.h?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -41,19 +41,27 @@ struct gtm_thread;\n // read-to-write upgrades do not have a higher priority than writers.\n //\n // Do not change the layout of this class; it must remain a POD type with\n-// standard layout, and the WRITERS field must be first (i.e., so the\n+// standard layout, and the writers field must be first (i.e., so the\n // assembler code can assume that its address is equal to the address of the\n-// respective instance of the class).\n+// respective instance of the class), and htm_fastpath must be second.\n \n class gtm_rwlock\n {\n-  // TODO Put futexes on different cachelines?\n   std::atomic<int> writers;       // Writers' futex.\n+  // We put the HTM fastpath control variable here so that HTM fastpath\n+  // transactions can check efficiently whether they are allowed to run.\n+  // This must be accessed atomically because threads can load this value\n+  // when they are neither a registered reader nor writer (i.e., when they\n+  // attempt to execute the HTM fastpath).\n+  std::atomic<uint32_t> htm_fastpath;\n+  // TODO Put these futexes on different cachelines?  (writers and htm_fastpath\n+  // should remain on the same cacheline.\n   std::atomic<int> writer_readers;// A confirmed writer waits here for readers.\n   std::atomic<int> readers;       // Readers wait here for writers (iff true).\n \n  public:\n-  gtm_rwlock() : writers(0), writer_readers(0), readers(0) {};\n+  gtm_rwlock() : writers(0), htm_fastpath(0), writer_readers(0), readers(0)\n+  { }\n \n   void read_lock (gtm_thread *tx);\n   void read_unlock (gtm_thread *tx);\n@@ -64,12 +72,28 @@ class gtm_rwlock\n   bool write_upgrade (gtm_thread *tx);\n   void write_upgrade_finish (gtm_thread *tx);\n \n-  // Returns true iff there is a concurrent active or waiting writer.\n-  // This is primarily useful for simple HyTM approaches, and the value being\n-  // checked is loaded with memory_order_relaxed.\n-  bool is_write_locked()\n+  // Returns true iff there is a concurrent active or waiting writer, or\n+  // htm_fastpath is zero. This is primarily useful for simple HyTM\n+  // approaches, and the values being checked are loaded with\n+  // memory_order_relaxed.\n+  bool htm_fastpath_disabled ()\n   {\n-    return writers.load (memory_order_relaxed) != 0;\n+    return writers.load (memory_order_relaxed) != 0\n+\t|| htm_fastpath.load (memory_order_relaxed) == 0;\n+  }\n+\n+  // This does not need to return an exact value, hence relaxed MO is\n+  // sufficient.\n+  uint32_t get_htm_fastpath ()\n+  {\n+    return htm_fastpath.load (memory_order_relaxed);\n+  }\n+  // This must only be called while having acquired the write lock, and other\n+  // threads do not need to load an exact value; hence relaxed MO is\n+  // sufficient.\n+  void set_htm_fastpath (uint32_t val)\n+  {\n+    htm_fastpath.store (val, memory_order_relaxed);\n   }\n \n  protected:"}, {"sha": "86f71058525897b3fce2bd037d7da6666db36e46", "filename": "libitm/config/posix/rwlock.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fposix%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fposix%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.cc?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -31,6 +31,7 @@ namespace GTM HIDDEN {\n \n gtm_rwlock::gtm_rwlock()\n   : summary (0),\n+    htm_fastpath (0),\n     mutex (PTHREAD_MUTEX_INITIALIZER),\n     c_readers (PTHREAD_COND_INITIALIZER),\n     c_writers (PTHREAD_COND_INITIALIZER),"}, {"sha": "1e74e64b87dc2d333142d5b9bd596e33d7a02382", "filename": "libitm/config/posix/rwlock.h", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fposix%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fposix%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.h?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -46,9 +46,9 @@ struct gtm_thread;\n // read-to-write upgrades do not have a higher priority than writers.\n //\n // Do not change the layout of this class; it must remain a POD type with\n-// standard layout, and the SUMMARY field must be first (i.e., so the\n+// standard layout, and the summary field must be first (i.e., so the\n // assembler code can assume that its address is equal to the address of the\n-// respective instance of the class).\n+// respective instance of the class), and htm_fastpath must be second.\n \n class gtm_rwlock\n {\n@@ -58,6 +58,13 @@ class gtm_rwlock\n \n   std::atomic<unsigned int> summary;\t// Bitmask of the above.\n \n+  // We put the HTM fastpath control variable here so that HTM fastpath\n+  // transactions can check efficiently whether they are allowed to run.\n+  // This must be accessed atomically because threads can load this value\n+  // when they are neither a registered reader nor writer (i.e., when they\n+  // attempt to execute the HTM fastpath).\n+  std::atomic<uint32_t> htm_fastpath;\n+\n   pthread_mutex_t mutex;\t        // Held if manipulating any field.\n   pthread_cond_t c_readers;\t        // Readers wait here\n   pthread_cond_t c_writers;\t        // Writers wait here for writers\n@@ -80,12 +87,28 @@ class gtm_rwlock\n   bool write_upgrade (gtm_thread *tx);\n   void write_upgrade_finish (gtm_thread *tx);\n \n-  // Returns true iff there is a concurrent active or waiting writer.\n-  // This is primarily useful for simple HyTM approaches, and the value being\n-  // checked is loaded with memory_order_relaxed.\n-  bool is_write_locked()\n+  // Returns true iff there is a concurrent active or waiting writer, or\n+  // htm_fastpath is zero. This is primarily useful for simple HyTM\n+  // approaches, and the values being checked are loaded with\n+  // memory_order_relaxed.\n+  bool htm_fastpath_disabled ()\n+  {\n+    return (summary.load (memory_order_relaxed) & (a_writer | w_writer))\n+\t|| htm_fastpath.load (memory_order_relaxed) == 0;\n+  }\n+\n+  // This does not need to return an exact value, hence relaxed MO is\n+  // sufficient.\n+  uint32_t get_htm_fastpath ()\n+  {\n+    return htm_fastpath.load (memory_order_relaxed);\n+  }\n+  // This must only be called while having acquired the write lock, and other\n+  // threads do not need to load an exact value; hence relaxed MO is\n+  // sufficient.\n+  void set_htm_fastpath (uint32_t val)\n   {\n-    return summary.load (memory_order_relaxed) & (a_writer | w_writer);\n+    htm_fastpath.store (val, memory_order_relaxed);\n   }\n \n  protected:"}, {"sha": "3d2a922c82cdb69bf323e89ad41b6092d3fcd282", "filename": "libitm/config/x86/sjlj.S", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fx86%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fconfig%2Fx86%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fsjlj.S?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -81,8 +81,9 @@ SYM(_ITM_beginTransaction):\n \t   back to another execution method.  RTM restores all registers after\n \t   a HW transaction abort, so we can do the SW setjmp after aborts,\n \t   and we have to because we might choose a SW fall back.  However,\n-\t   we have to explicitly save/restore the first argument (edi).  */\n-\tcmpl\t$0, SYM(gtm_htm_fastpath)(%rip)\n+\t   we have to explicitly save/restore the first argument (edi).\n+\t   The htm_fastpath field is the second int in gtm_rwlock.  */\n+\tcmpl\t$0, (SYM(gtm_serial_lock)+4)(%rip)\n \tjz\t.Lno_htm\n \ttestl\t$pr_hasNoAbort, %edi\n \tjz\t.Lno_htm\n@@ -95,15 +96,20 @@ SYM(_ITM_beginTransaction):\n \t   this case in the retry policy implementation.  */\n \tcmpl\t$0, SYM(gtm_serial_lock)(%rip)\n \tjnz\t1f\n+\t/* Now also check that HW transactions are still allowed to run (see\n+\t   gtm_thread::begin_transaction for why this is necessary).  */\n+\tcmpl\t$0, (SYM(gtm_serial_lock)+4)(%rip)\n+\tjz\t1f\n \t/* Everything is good.  Run the transaction, preferably using the\n \t   uninstrumented code path.  Note that the following works because\n \t   pr_uninstrumentedCode == a_runUninstrumentedCode.  */\n \tandl\t$pr_uninstrumentedCode, %edi\n \tmov\t$a_runInstrumentedCode, %eax\n \tcmovnz\t%edi, %eax\n \tret\n-\t/* There is a serial-mode transaction, so abort (see htm_abort()\n-\t   regarding the abort code).  */\n+\t/* There is a serial-mode transaction or HW transactions are not\n+\t   allowed anymore, so abort (see htm_abort() regarding the abort\n+\t   code).  */\n 1:\txabort\t$0xff\n .Ltxn_abort:\n \t/* If it might make sense to retry the HTM fast path, let the C++"}, {"sha": "a8cff575754057dfd2e284144fc9f55b279efcaf", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -344,11 +344,6 @@ extern abi_dispatch *dispatch_gl_wt();\n extern abi_dispatch *dispatch_ml_wt();\n extern abi_dispatch *dispatch_htm();\n \n-// Control variable for the HTM fastpath that uses serial mode as fallback.\n-// Non-zero if the HTM fastpath is enabled. See gtm_thread::begin_transaction.\n-// Accessed from assembly language, thus the \"asm\" specifier on\n-// the name, avoiding complex name mangling.\n-extern uint32_t htm_fastpath __asm__(UPFX \"gtm_htm_fastpath\");\n \n } // namespace GTM\n "}, {"sha": "a151b669618f8196141469f7b616fabe7925253c", "filename": "libitm/method-serial.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fmethod-serial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fmethod-serial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-serial.cc?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -226,13 +226,13 @@ struct htm_mg : public method_group\n     // Enable the HTM fastpath if the HW is available.  The fastpath is\n     // initially disabled.\n #ifdef USE_HTM_FASTPATH\n-    htm_fastpath = htm_init();\n+    gtm_thread::serial_lock.set_htm_fastpath(htm_init());\n #endif\n   }\n   virtual void fini()\n   {\n     // Disable the HTM fastpath.\n-    htm_fastpath = 0;\n+    gtm_thread::serial_lock.set_htm_fastpath(0);\n   }\n };\n \n@@ -292,7 +292,7 @@ GTM::gtm_thread::serialirr_mode ()\n #if defined(USE_HTM_FASTPATH)\n   // HTM fastpath.  If we are executing a HW transaction, don't go serial but\n   // continue.  See gtm_thread::begin_transaction.\n-  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+  if (likely(!gtm_thread::serial_lock.htm_fastpath_disabled()))\n     return;\n #endif\n "}, {"sha": "ddce8462f2d62d5250abcf18bda77f1f0339956f", "filename": "libitm/query.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fquery.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041f70ae3c9822a41046a7826c1d33818d346bd/libitm%2Fquery.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fquery.cc?ref=6041f70ae3c9822a41046a7826c1d33818d346bd", "patch": "@@ -49,7 +49,7 @@ _ITM_inTransaction (void)\n   // a transaction and thus we can't deduce this by looking at just the serial\n   // lock.  This function isn't used in practice currently, so the easiest\n   // way to handle it is to just abort.\n-  if (htm_fastpath && htm_transaction_active())\n+  if (gtm_thread::serial_lock.get_htm_fastpath() && htm_transaction_active())\n     htm_abort();\n #endif\n   struct gtm_thread *tx = gtm_thr();\n@@ -69,7 +69,7 @@ _ITM_getTransactionId (void)\n {\n #if defined(USE_HTM_FASTPATH)\n   // See ITM_inTransaction.\n-  if (htm_fastpath && htm_transaction_active())\n+  if (gtm_thread::serial_lock.get_htm_fastpath() && htm_transaction_active())\n     htm_abort();\n #endif\n   struct gtm_thread *tx = gtm_thr();"}]}