{"sha": "00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBkMzRkM2FiMTlmM2E5ZTlmM2Y5MGY1YjgzZjdlY2U0ZGFhOGE2Mg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-08-26T08:37:24Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-08-26T08:37:24Z"}, "message": "c-pretty-print.h (c_pretty_printer::unary_expression): Now a virtual member function.\n\nc-family/\n\t* c-pretty-print.h (c_pretty_printer::unary_expression): Now a\n\tvirtual member function.\n\t(c_pretty_printer::multiplicative_expression): Likewise.\n\t(c_pretty_printer::conditional_expression): Likewise.\n\t(c_pretty_printer::assignment_expression): Likewise.\n\t(c_pretty_printer::expression): Likewise.\n\t(pp_unary_expression): Adjust.\n\t(pp_multiplicative_expression): Likewise.\n\t(pp_assignment_expression): Likewise.\n\t(pp_conditional_expression): Likewise.\n\t(pp_expression): Likewise.\n\t* c-pretty-print.c (c_pretty_printer::unary_expression): Rename\n\tfrom pp_c_unary_expression.  Adjust.\n\t(c_pretty_printer::multiplicative_expression): Rename from\n\tpp_c_multiplicative_expression.  Adjust.\n\t(c_pretty_printer::conditional_expression): Rename from\n\tpp_c_conditional_expression.  Adjust.\n\t(c_pretty_printer::assignment_expression): Rename from\n\tpp_c_assignment_expression.  Adjust.\n\t(c_pretty_printer::expression): Rename from pp_c_expression.  Adjust.\n\t(c_pretty_printer::c_pretty_printer): Do not assign to\n\tunary_expression, multiplicative_expression,\n\tconditional_expression, expression.\n\ncp/\n\t* cxx-pretty-print.h (cxx_pretty_printer::unary_expression):\n\tDeclare as overrider.\n\t(cxx_pretty_printer::multiplicative_expression): Likewise.\n\t(cxx_pretty_printer::conditional_expression): Likewise.\n\t(cxx_pretty_printer::assignment_expression): Likewise.\n\t(cxx_pretty_printer::expression): Likewise.\n\t* cxx-pretty-print.c (cxx_pretty_printer::unary_expression):\n\tRename from pp_cxx_unary_expression.  Adjust.\n\t(cxx_pretty_printer::multiplicative_expression): Rename from\n\tpp_cxx_multiplicative_expression.  Adjust.\n\t(cxx_pretty_printer::conditional_expression): Rename from\n\tpp_cxx_conditional_expression.  Adjust.\n\t(cxx_pretty_printer::assignment_expression): Rename from\n\tpp_cxx_assignment_expression.  Adjust.\n\t(cxx_pretty_printer::expression): Rename from pp_cxx_expression.\n\tAdjust.\n\t(cxx_pretty_printer::cxx_pretty_printer): Dot not assign to\n\tunary_expression, multiplicative_expression,\n\tconditional_expression, assignment_expression, expression.\n\nFrom-SVN: r201987", "tree": {"sha": "98a33a18ef81062d88e2e8c83ae859f59a0f9e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98a33a18ef81062d88e2e8c83ae859f59a0f9e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/comments", "author": null, "committer": null, "parents": [{"sha": "fb22178f7d94c8101146bcaf66c7703d0ef643e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb22178f7d94c8101146bcaf66c7703d0ef643e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb22178f7d94c8101146bcaf66c7703d0ef643e0"}], "stats": {"total": 497, "additions": 266, "deletions": 231}, "files": [{"sha": "c6562763d7a8cc96d2598edf4908be2009c7b9ee", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -1,3 +1,29 @@\n+2013-08-26  Gabriel Dos Reis  <gdre@integrable-solutions.net>\n+\n+\t* c-pretty-print.h (c_pretty_printer::unary_expression): Now a\n+\tvirtual member function.\n+\t(c_pretty_printer::multiplicative_expression): Likewise.\n+\t(c_pretty_printer::conditional_expression): Likewise.\n+\t(c_pretty_printer::assignment_expression): Likewise.\n+\t(c_pretty_printer::expression): Likewise.\n+\t(pp_unary_expression): Adjust.\n+\t(pp_multiplicative_expression): Likewise.\n+\t(pp_assignment_expression): Likewise.\n+\t(pp_conditional_expression): Likewise.\n+\t(pp_expression): Likewise.\n+\t* c-pretty-print.c (c_pretty_printer::unary_expression): Rename\n+\tfrom pp_c_unary_expression.  Adjust.\n+\t(c_pretty_printer::multiplicative_expression): Rename from\n+\tpp_c_multiplicative_expression.  Adjust.\n+\t(c_pretty_printer::conditional_expression): Rename from\n+\tpp_c_conditional_expression.  Adjust.\n+\t(c_pretty_printer::assignment_expression): Rename from\n+\tpp_c_assignment_expression.  Adjust.\n+\t(c_pretty_printer::expression): Rename from pp_c_expression.  Adjust.\n+\t(c_pretty_printer::c_pretty_printer): Do not assign to\n+\tunary_expression, multiplicative_expression,\n+\tconditional_expression, expression.\n+\n 2013-08-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-pretty-print.h (c_pretty_printer::postfix_expression): Now a"}, {"sha": "d0cc90a2dfcf3b2eab2fa672bec0c2d469ab7b42", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 88, "deletions": 96, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -50,7 +50,6 @@ static void pp_c_char (c_pretty_printer *, int);\n static void pp_c_initializer_list (c_pretty_printer *, tree);\n static void pp_c_brace_enclosed_initializer_list (c_pretty_printer *, tree);\n \n-static void pp_c_multiplicative_expression (c_pretty_printer *, tree);\n static void pp_c_additive_expression (c_pretty_printer *, tree);\n static void pp_c_shift_expression (c_pretty_printer *, tree);\n static void pp_c_relational_expression (c_pretty_printer *, tree);\n@@ -59,8 +58,6 @@ static void pp_c_and_expression (c_pretty_printer *, tree);\n static void pp_c_exclusive_or_expression (c_pretty_printer *, tree);\n static void pp_c_inclusive_or_expression (c_pretty_printer *, tree);\n static void pp_c_logical_and_expression (c_pretty_printer *, tree);\n-static void pp_c_conditional_expression (c_pretty_printer *, tree);\n-static void pp_c_assignment_expression (c_pretty_printer *, tree);\n \n /* declarations.  */\n \n@@ -1255,7 +1252,7 @@ c_pretty_printer::primary_expression (tree e)\n       if (TREE_OPERAND (e, 2))\n \t{\n \t  pp_separate_with (this, ',');\n-\t  pp_c_expression (this, TREE_OPERAND (e, 2));\n+\t  expression (TREE_OPERAND (e, 2));\n \t}\n       pp_c_right_paren (this);\n       break;\n@@ -1619,7 +1616,7 @@ c_pretty_printer::postfix_expression (tree e)\n       break;\n \n     case MEM_REF:\n-      pp_c_expression (this, e);\n+      expression (e);\n       break;\n \n     case COMPLEX_CST:\n@@ -1641,7 +1638,7 @@ c_pretty_printer::postfix_expression (tree e)\n     case VA_ARG_EXPR:\n       pp_c_ws_string (this, \"__builtin_va_arg\");\n       pp_c_left_paren (this);\n-      pp_assignment_expression (this, TREE_OPERAND (e, 0));\n+      assignment_expression (TREE_OPERAND (e, 0));\n       pp_separate_with (this, ',');\n       pp_type_id (this, TREE_TYPE (e));\n       pp_c_right_paren (this);\n@@ -1721,15 +1718,15 @@ pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n       __imag__ unary-expression  */\n \n void\n-pp_c_unary_expression (c_pretty_printer *pp, tree e)\n+c_pretty_printer::unary_expression (tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n-      pp_string (pp, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n-      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n+      pp_string (this, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n+      unary_expression (TREE_OPERAND (e, 0));\n       break;\n \n     case ADDR_EXPR:\n@@ -1740,53 +1737,53 @@ pp_c_unary_expression (c_pretty_printer *pp, tree e)\n     case CONJ_EXPR:\n       /* String literal are used by address.  */\n       if (code == ADDR_EXPR && TREE_CODE (TREE_OPERAND (e, 0)) != STRING_CST)\n-\tpp_ampersand (pp);\n+\tpp_ampersand (this);\n       else if (code == INDIRECT_REF)\n-\tpp_c_star (pp);\n+\tpp_c_star (this);\n       else if (code == NEGATE_EXPR)\n-\tpp_minus (pp);\n+\tpp_minus (this);\n       else if (code == BIT_NOT_EXPR || code == CONJ_EXPR)\n-\tpp_complement (pp);\n+\tpp_complement (this);\n       else if (code == TRUTH_NOT_EXPR)\n-\tpp_exclamation (pp);\n-      pp_c_cast_expression (pp, TREE_OPERAND (e, 0));\n+\tpp_exclamation (this);\n+      pp_c_cast_expression (this, TREE_OPERAND (e, 0));\n       break;\n \n     case MEM_REF:\n       if (TREE_CODE (TREE_OPERAND (e, 0)) == ADDR_EXPR\n \t  && integer_zerop (TREE_OPERAND (e, 1)))\n-\tpp_c_expression (pp, TREE_OPERAND (TREE_OPERAND (e, 0), 0));\n+\texpression (TREE_OPERAND (TREE_OPERAND (e, 0), 0));\n       else\n \t{\n-\t  pp_c_star (pp);\n+\t  pp_c_star (this);\n \t  if (!integer_zerop (TREE_OPERAND (e, 1)))\n \t    {\n-\t      pp_c_left_paren (pp);\n+\t      pp_c_left_paren (this);\n \t      if (!integer_onep (TYPE_SIZE_UNIT\n \t\t\t\t (TREE_TYPE (TREE_TYPE (TREE_OPERAND (e, 0))))))\n-\t\tpp_c_type_cast (pp, ptr_type_node);\n+\t\tpp_c_type_cast (this, ptr_type_node);\n \t    }\n-\t  pp_c_cast_expression (pp, TREE_OPERAND (e, 0));\n+\t  pp_c_cast_expression (this, TREE_OPERAND (e, 0));\n \t  if (!integer_zerop (TREE_OPERAND (e, 1)))\n \t    {\n-\t      pp_plus (pp);\n-\t      pp_c_integer_constant (pp,\n+\t      pp_plus (this);\n+\t      pp_c_integer_constant (this,\n \t\t\t\t     fold_convert (ssizetype,\n \t\t\t\t\t\t   TREE_OPERAND (e, 1)));\n-\t      pp_c_right_paren (pp);\n+\t      pp_c_right_paren (this);\n \t    }\n \t}\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_c_ws_string (pp, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n-      pp_c_whitespace (pp);\n-      pp_unary_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_ws_string (this, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n+      pp_c_whitespace (this);\n+      unary_expression (TREE_OPERAND (e, 0));\n       break;\n \n     default:\n-      pp_postfix_expression (pp, e);\n+      postfix_expression (e);\n       break;\n     }\n }\n@@ -1819,29 +1816,29 @@ pp_c_cast_expression (c_pretty_printer *pp, tree e)\n       multiplicative-expression / cast-expression\n       multiplicative-expression % cast-expression   */\n \n-static void\n-pp_c_multiplicative_expression (c_pretty_printer *pp, tree e)\n+void\n+c_pretty_printer::multiplicative_expression (tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      pp_multiplicative_expression (pp, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (pp);\n+      multiplicative_expression (TREE_OPERAND (e, 0));\n+      pp_c_whitespace (this);\n       if (code == MULT_EXPR)\n-\tpp_c_star (pp);\n+\tpp_c_star (this);\n       else if (code == TRUNC_DIV_EXPR)\n-\tpp_slash (pp);\n+\tpp_slash (this);\n       else\n-\tpp_modulo (pp);\n-      pp_c_whitespace (pp);\n-      pp_c_cast_expression (pp, TREE_OPERAND (e, 1));\n+\tpp_modulo (this);\n+      pp_c_whitespace (this);\n+      pp_c_cast_expression (this, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_c_cast_expression (pp, e);\n+      pp_c_cast_expression (this, e);\n       break;\n     }\n }\n@@ -2069,23 +2066,23 @@ pp_c_logical_or_expression (c_pretty_printer *pp, tree e)\n       logical-OR-expression\n       logical-OR-expression ? expression : conditional-expression  */\n \n-static void\n-pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n+void\n+c_pretty_printer::conditional_expression (tree e)\n {\n   if (TREE_CODE (e) == COND_EXPR)\n     {\n-      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (pp);\n-      pp_question (pp);\n-      pp_c_whitespace (pp);\n-      pp_expression (pp, TREE_OPERAND (e, 1));\n-      pp_c_whitespace (pp);\n-      pp_colon (pp);\n-      pp_c_whitespace (pp);\n-      pp_c_conditional_expression (pp, TREE_OPERAND (e, 2));\n+      pp_c_logical_or_expression (this, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (this);\n+      pp_question (this);\n+      pp_c_whitespace (this);\n+      pp_expression (this, TREE_OPERAND (e, 1));\n+      pp_c_whitespace (this);\n+      pp_colon (this);\n+      pp_c_whitespace (this);\n+      conditional_expression (TREE_OPERAND (e, 2));\n     }\n   else\n-    pp_c_logical_or_expression (pp, e);\n+    pp_c_logical_or_expression (this, e);\n }\n \n \n@@ -2096,20 +2093,20 @@ pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n    assignment-expression: one of\n       =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n \n-static void\n-pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n+void\n+c_pretty_printer::assignment_expression (tree e)\n {\n   if (TREE_CODE (e) == MODIFY_EXPR\n       || TREE_CODE (e) == INIT_EXPR)\n     {\n-      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (pp);\n-      pp_equal (pp);\n-      pp_space (pp);\n-      pp_c_expression (pp, TREE_OPERAND (e, 1));\n+      unary_expression (TREE_OPERAND (e, 0));\n+      pp_c_whitespace (this);\n+      pp_equal (this);\n+      pp_space (this);\n+      pp_expression (this, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_conditional_expression (pp, e);\n+    conditional_expression (e);\n }\n \n /* expression:\n@@ -2120,27 +2117,27 @@ pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n   chain, I take the liberty of dispatching nodes to the appropriate\n   functions.  This makes some redundancy, but it worths it. That also\n   prevents a possible infinite recursion between pp_primary_expression ()\n-  and pp_c_expression ().  */\n+  and pp_expression ().  */\n \n void\n-pp_c_expression (c_pretty_printer *pp, tree e)\n+c_pretty_printer::expression (tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n-      pp_c_integer_constant (pp, e);\n+      pp_c_integer_constant (this, e);\n       break;\n \n     case REAL_CST:\n-      pp_c_floating_constant (pp, e);\n+      pp_c_floating_constant (this, e);\n       break;\n \n     case FIXED_CST:\n-      pp_c_fixed_constant (pp, e);\n+      pp_c_fixed_constant (this, e);\n       break;\n \n     case STRING_CST:\n-      pp_c_string_literal (pp, e);\n+      pp_c_string_literal (this, e);\n       break;\n \n     case IDENTIFIER_NODE:\n@@ -2152,15 +2149,15 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case FIELD_DECL:\n     case LABEL_DECL:\n     case ERROR_MARK:\n-      pp_primary_expression (pp, e);\n+      primary_expression (e);\n       break;\n \n     case SSA_NAME:\n       if (SSA_NAME_VAR (e)\n \t  && !DECL_ARTIFICIAL (SSA_NAME_VAR (e)))\n-\tpp_c_expression (pp, SSA_NAME_VAR (e));\n+\texpression (SSA_NAME_VAR (e));\n       else\n-\tpp->translate_string (\"<unknown>\");\n+\ttranslate_string (\"<unknown>\");\n       break;\n \n     case POSTINCREMENT_EXPR:\n@@ -2185,7 +2182,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case CONSTRUCTOR:\n     case COMPOUND_LITERAL_EXPR:\n     case VA_ARG_EXPR:\n-      pp_postfix_expression (pp, e);\n+      postfix_expression (e);\n       break;\n \n     case CONJ_EXPR:\n@@ -2199,107 +2196,107 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case PREDECREMENT_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_c_unary_expression (pp, e);\n+      unary_expression (e);\n       break;\n \n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n-      pp_c_cast_expression (pp, e);\n+      pp_c_cast_expression (this, e);\n       break;\n \n     case MULT_EXPR:\n     case TRUNC_MOD_EXPR:\n     case TRUNC_DIV_EXPR:\n-      pp_multiplicative_expression (pp, e);\n+      multiplicative_expression (e);\n       break;\n \n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      pp_c_shift_expression (pp, e);\n+      pp_c_shift_expression (this, e);\n       break;\n \n     case LT_EXPR:\n     case GT_EXPR:\n     case LE_EXPR:\n     case GE_EXPR:\n-      pp_c_relational_expression (pp, e);\n+      pp_c_relational_expression (this, e);\n       break;\n \n     case BIT_AND_EXPR:\n-      pp_c_and_expression (pp, e);\n+      pp_c_and_expression (this, e);\n       break;\n \n     case BIT_XOR_EXPR:\n     case TRUTH_XOR_EXPR:\n-      pp_c_exclusive_or_expression (pp, e);\n+      pp_c_exclusive_or_expression (this, e);\n       break;\n \n     case BIT_IOR_EXPR:\n-      pp_c_inclusive_or_expression (pp, e);\n+      pp_c_inclusive_or_expression (this, e);\n       break;\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_AND_EXPR:\n-      pp_c_logical_and_expression (pp, e);\n+      pp_c_logical_and_expression (this, e);\n       break;\n \n     case TRUTH_ORIF_EXPR:\n     case TRUTH_OR_EXPR:\n-      pp_c_logical_or_expression (pp, e);\n+      pp_c_logical_or_expression (this, e);\n       break;\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      pp_c_equality_expression (pp, e);\n+      pp_c_equality_expression (this, e);\n       break;\n \n     case COND_EXPR:\n-      pp_conditional_expression (pp, e);\n+      conditional_expression (e);\n       break;\n \n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      pp_c_additive_expression (pp, e);\n+      pp_c_additive_expression (this, e);\n       break;\n \n     case MODIFY_EXPR:\n     case INIT_EXPR:\n-      pp_assignment_expression (pp, e);\n+      assignment_expression (e);\n       break;\n \n     case COMPOUND_EXPR:\n-      pp_c_left_paren (pp);\n-      pp_expression (pp, TREE_OPERAND (e, 0));\n-      pp_separate_with (pp, ',');\n-      pp_assignment_expression (pp, TREE_OPERAND (e, 1));\n-      pp_c_right_paren (pp);\n+      pp_c_left_paren (this);\n+      expression (TREE_OPERAND (e, 0));\n+      pp_separate_with (this, ',');\n+      assignment_expression (TREE_OPERAND (e, 1));\n+      pp_c_right_paren (this);\n       break;\n \n     case NON_LVALUE_EXPR:\n     case SAVE_EXPR:\n-      pp_expression (pp, TREE_OPERAND (e, 0));\n+      expression (TREE_OPERAND (e, 0));\n       break;\n \n     case TARGET_EXPR:\n-      pp_postfix_expression (pp, TREE_OPERAND (e, 1));\n+      postfix_expression (TREE_OPERAND (e, 1));\n       break;\n \n     case BIND_EXPR:\n     case GOTO_EXPR:\n       /* We don't yet have a way of dumping statements in a\n          human-readable format.  */\n-      pp_string (pp, \"({...})\");\n+      pp_string (this, \"({...})\");\n       break;\n \n     case C_MAYBE_CONST_EXPR:\n-      pp_c_expression (pp, C_MAYBE_CONST_EXPR_EXPR (e));\n+      expression (C_MAYBE_CONST_EXPR_EXPR (e));\n       break;\n \n     default:\n-      pp_unsupported_tree (pp, e);\n+      pp_unsupported_tree (this, e);\n       break;\n     }\n }\n@@ -2344,12 +2341,7 @@ c_pretty_printer::c_pretty_printer ()\n \n   statement                 = pp_c_statement;\n \n-  unary_expression          = pp_c_unary_expression;\n   initializer               = pp_c_initializer;\n-  multiplicative_expression = pp_c_multiplicative_expression;\n-  conditional_expression    = pp_c_conditional_expression;\n-  assignment_expression     = pp_c_assignment_expression;\n-  expression                = pp_c_expression;\n }\n \n "}, {"sha": "24b1f156231b1e784b2dfa6f8602a6f9ca582923", "filename": "gcc/c-family/c-pretty-print.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fc-family%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.h?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -58,6 +58,11 @@ struct c_pretty_printer : pretty_printer\n   virtual void id_expression (tree);\n   virtual void primary_expression (tree);\n   virtual void postfix_expression (tree);\n+  virtual void unary_expression (tree);\n+  virtual void multiplicative_expression (tree);\n+  virtual void conditional_expression (tree);\n+  virtual void assignment_expression (tree);\n+  virtual void expression (tree);\n   /* Points to the first element of an array of offset-list.\n      Not used yet.  */\n   int *offset_list;\n@@ -83,11 +88,6 @@ struct c_pretty_printer : pretty_printer\n \n   c_pretty_print_fn statement;\n \n-  c_pretty_print_fn unary_expression;\n-  c_pretty_print_fn multiplicative_expression;\n-  c_pretty_print_fn conditional_expression;\n-  c_pretty_print_fn assignment_expression;\n-  c_pretty_print_fn expression;\n };\n \n #define pp_c_tree_identifier(PPI, ID)              \\\n@@ -116,13 +116,13 @@ struct c_pretty_printer : pretty_printer\n #define pp_id_expression(PP, E)         (PP)->id_expression (E)\n #define pp_primary_expression(PP, E)    (PP)->primary_expression (E)\n #define pp_postfix_expression(PP, E)    (PP)->postfix_expression (E)\n-#define pp_unary_expression(PP, E)      (PP)->unary_expression (PP, E)\n+#define pp_unary_expression(PP, E)      (PP)->unary_expression (E)\n #define pp_initializer(PP, E)           (PP)->initializer (PP, E)\n #define pp_multiplicative_expression(PP, E)      \\\n-  (PP)->multiplicative_expression (PP, E)\n-#define pp_conditional_expression(PP, E) (PP)->conditional_expression (PP, E)\n-#define pp_assignment_expression(PP, E) (PP)->assignment_expression (PP, E)\n-#define pp_expression(PP, E)            (PP)->expression (PP, E)\n+  (PP)->multiplicative_expression (E)\n+#define pp_conditional_expression(PP, E) (PP)->conditional_expression (E)\n+#define pp_assignment_expression(PP, E) (PP)->assignment_expression (E)\n+#define pp_expression(PP, E)            (PP)->expression (E)\n \n \n void pp_c_whitespace (c_pretty_printer *);\n@@ -162,12 +162,10 @@ void pp_c_storage_class_specifier (c_pretty_printer *, tree);\n /* Statements.  */\n void pp_c_statement (c_pretty_printer *, tree);\n /* Expressions.  */\n-void pp_c_expression (c_pretty_printer *, tree);\n void pp_c_logical_or_expression (c_pretty_printer *, tree);\n void pp_c_expression_list (c_pretty_printer *, tree);\n void pp_c_constructor_elts (c_pretty_printer *, vec<constructor_elt, va_gc> *);\n void pp_c_call_argument_list (c_pretty_printer *, tree);\n-void pp_c_unary_expression (c_pretty_printer *, tree);\n void pp_c_cast_expression (c_pretty_printer *, tree);\n void pp_c_init_declarator (c_pretty_printer *, tree);\n void pp_c_ws_string (c_pretty_printer *, const char *);"}, {"sha": "c03c98735f89f80380ebe23de0bf8b4c04038a40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -1,3 +1,25 @@\n+2013-08-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cxx-pretty-print.h (cxx_pretty_printer::unary_expression):\n+\tDeclare as overrider.\n+\t(cxx_pretty_printer::multiplicative_expression): Likewise.\n+\t(cxx_pretty_printer::conditional_expression): Likewise.\n+\t(cxx_pretty_printer::assignment_expression): Likewise.\n+\t(cxx_pretty_printer::expression): Likewise.\n+\t* cxx-pretty-print.c (cxx_pretty_printer::unary_expression):\n+\tRename from pp_cxx_unary_expression.  Adjust.\n+\t(cxx_pretty_printer::multiplicative_expression): Rename from\n+\tpp_cxx_multiplicative_expression.  Adjust.\n+\t(cxx_pretty_printer::conditional_expression): Rename from\n+\tpp_cxx_conditional_expression.  Adjust.\n+\t(cxx_pretty_printer::assignment_expression): Rename from\n+\tpp_cxx_assignment_expression.  Adjust.\n+\t(cxx_pretty_printer::expression): Rename from pp_cxx_expression.\n+\tAdjust.\n+\t(cxx_pretty_printer::cxx_pretty_printer): Dot not assign to\n+\tunary_expression, multiplicative_expression,\n+\tconditional_expression, assignment_expression, expression.\n+\n 2013-08-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* cxx-pretty-print.h (cxx_pretty_printer::postfix_expression):"}, {"sha": "3e913f368fe4326b162416144188e9b8836f8c4d", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 115, "deletions": 123, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -30,8 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n static void pp_cxx_unqualified_id (cxx_pretty_printer *, tree);\n static void pp_cxx_nested_name_specifier (cxx_pretty_printer *, tree);\n static void pp_cxx_qualified_id (cxx_pretty_printer *, tree);\n-static void pp_cxx_assignment_expression (cxx_pretty_printer *, tree);\n-static void pp_cxx_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_template_argument_list (cxx_pretty_printer *, tree);\n static void pp_cxx_type_specifier_seq (cxx_pretty_printer *, tree);\n static void pp_cxx_ptr_operator (cxx_pretty_printer *, tree);\n@@ -552,7 +550,7 @@ cxx_pretty_printer::postfix_expression (tree t)\n \t\t  skipfirst = false;\n \t\telse\n \t\t  {\n-\t\t    pp_cxx_expression (this, arg);\n+\t\t    expression (arg);\n \t\t    if (more_aggr_init_expr_args_p (&iter))\n \t\t      pp_cxx_separate_with (this, ',');\n \t\t  }\n@@ -567,7 +565,7 @@ cxx_pretty_printer::postfix_expression (tree t)\n \t\t  skipfirst = false;\n \t\telse\n \t\t  {\n-\t\t    pp_cxx_expression (this, arg);\n+\t\t    expression (arg);\n \t\t    if (more_call_expr_args_p (&iter))\n \t\t      pp_cxx_separate_with (this, ',');\n \t\t  }\n@@ -610,7 +608,7 @@ cxx_pretty_printer::postfix_expression (tree t)\n       pp_cxx_type_id (this, TREE_TYPE (t));\n       pp_cxx_end_template_argument_list (this);\n       pp_left_paren (this);\n-      pp_cxx_expression (this, TREE_OPERAND (t, 0));\n+      expression (TREE_OPERAND (t, 0));\n       pp_right_paren (this);\n       break;\n \n@@ -699,7 +697,7 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n \t  else if (init == void_zero_node)\n \t    ;\t\t\t/* OK, empty initializer list.  */\n \t  else\n-\t    pp_cxx_expression (pp, init);\n+\t    pp_expression (pp, init);\n \t  pp_right_paren (pp);\n \t}\n       break;\n@@ -758,80 +756,80 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n       __alignof__ unary-expression\n       __alignof__ ( type-id )  */\n \n-static void\n-pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n+void\n+cxx_pretty_printer::unary_expression (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n   switch (code)\n     {\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n-      pp_cxx_new_expression (pp, t);\n+      pp_cxx_new_expression (this, t);\n       break;\n \n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n-      pp_cxx_delete_expression (pp, t);\n+      pp_cxx_delete_expression (this, t);\n       break;\n \n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n \t{\n-\t  pp_cxx_ws_string (pp, \"sizeof\");\n-\t  pp_cxx_ws_string (pp, \"...\");\n-\t  pp_cxx_whitespace (pp);\n-\t  pp_cxx_left_paren (pp);\n+\t  pp_cxx_ws_string (this, \"sizeof\");\n+\t  pp_cxx_ws_string (this, \"...\");\n+\t  pp_cxx_whitespace (this);\n+\t  pp_cxx_left_paren (this);\n \t  if (TYPE_P (TREE_OPERAND (t, 0)))\n-\t    pp_cxx_type_id (pp, TREE_OPERAND (t, 0));\n+\t    pp_cxx_type_id (this, TREE_OPERAND (t, 0));\n \t  else\n-\t    pp_unary_expression (pp, TREE_OPERAND (t, 0));\n-\t  pp_cxx_right_paren (pp);\n+\t    unary_expression (TREE_OPERAND (t, 0));\n+\t  pp_cxx_right_paren (this);\n \t  break;\n \t}\n       /* Fall through  */\n \n     case ALIGNOF_EXPR:\n-      pp_cxx_ws_string (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n-      pp_cxx_whitespace (pp);\n+      pp_cxx_ws_string (this, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n+      pp_cxx_whitespace (this);\n       if (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n \t{\n-\t  pp_cxx_left_paren (pp);\n-\t  pp_cxx_type_id (pp, TREE_TYPE (TREE_OPERAND (t, 0)));\n-\t  pp_cxx_right_paren (pp);\n+\t  pp_cxx_left_paren (this);\n+\t  pp_cxx_type_id (this, TREE_TYPE (TREE_OPERAND (t, 0)));\n+\t  pp_cxx_right_paren (this);\n \t}\n       else if (TYPE_P (TREE_OPERAND (t, 0)))\n \t{\n-\t  pp_cxx_left_paren (pp);\n-\t  pp_cxx_type_id (pp, TREE_OPERAND (t, 0));\n-\t  pp_cxx_right_paren (pp);\n+\t  pp_cxx_left_paren (this);\n+\t  pp_cxx_type_id (this, TREE_OPERAND (t, 0));\n+\t  pp_cxx_right_paren (this);\n \t}\n       else\n-\tpp_unary_expression (pp, TREE_OPERAND (t, 0));\n+\tunary_expression (TREE_OPERAND (t, 0));\n       break;\n \n     case AT_ENCODE_EXPR:\n-      pp_cxx_ws_string (pp, \"@encode\");\n-      pp_cxx_whitespace (pp);\n-      pp_cxx_left_paren (pp);\n-      pp_cxx_type_id (pp, TREE_OPERAND (t, 0));\n-      pp_cxx_right_paren (pp);\n+      pp_cxx_ws_string (this, \"@encode\");\n+      pp_cxx_whitespace (this);\n+      pp_cxx_left_paren (this);\n+      pp_cxx_type_id (this, TREE_OPERAND (t, 0));\n+      pp_cxx_right_paren (this);\n       break;      \n \n     case NOEXCEPT_EXPR:\n-      pp_cxx_ws_string (pp, \"noexcept\");\n-      pp_cxx_whitespace (pp);\n-      pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n-      pp_cxx_right_paren (pp);\n+      pp_cxx_ws_string (this, \"noexcept\");\n+      pp_cxx_whitespace (this);\n+      pp_cxx_left_paren (this);\n+      expression (TREE_OPERAND (t, 0));\n+      pp_cxx_right_paren (this);\n       break;\n \n     case UNARY_PLUS_EXPR:\n-      pp_plus (pp);\n-      pp_cxx_cast_expression (pp, TREE_OPERAND (t, 0));\n+      pp_plus (this);\n+      pp_cxx_cast_expression (this, TREE_OPERAND (t, 0));\n       break;\n \n     default:\n-      pp_c_unary_expression (pp, t);\n+      c_pretty_printer::unary_expression (t);\n       break;\n     }\n }\n@@ -899,29 +897,29 @@ pp_cxx_pm_expression (cxx_pretty_printer *pp, tree t)\n       multiplicative-expression / pm-expression\n       multiplicative-expression % pm-expression  */\n \n-static void\n-pp_cxx_multiplicative_expression (cxx_pretty_printer *pp, tree e)\n+void\n+cxx_pretty_printer::multiplicative_expression (tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      pp_cxx_multiplicative_expression (pp, TREE_OPERAND (e, 0));\n-      pp_space (pp);\n+      multiplicative_expression (TREE_OPERAND (e, 0));\n+      pp_space (this);\n       if (code == MULT_EXPR)\n-\tpp_star (pp);\n+\tpp_star (this);\n       else if (code == TRUNC_DIV_EXPR)\n-\tpp_slash (pp);\n+\tpp_slash (this);\n       else\n-\tpp_modulo (pp);\n-      pp_space (pp);\n-      pp_cxx_pm_expression (pp, TREE_OPERAND (e, 1));\n+\tpp_modulo (this);\n+      pp_space (this);\n+      pp_cxx_pm_expression (this, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_cxx_pm_expression (pp, e);\n+      pp_cxx_pm_expression (this, e);\n       break;\n     }\n }\n@@ -930,21 +928,21 @@ pp_cxx_multiplicative_expression (cxx_pretty_printer *pp, tree e)\n       logical-or-expression\n       logical-or-expression ?  expression  : assignment-expression  */\n \n-static void\n-pp_cxx_conditional_expression (cxx_pretty_printer *pp, tree e)\n+void\n+cxx_pretty_printer::conditional_expression (tree e)\n {\n   if (TREE_CODE (e) == COND_EXPR)\n     {\n-      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n-      pp_space (pp);\n-      pp_question (pp);\n-      pp_space (pp);\n-      pp_cxx_expression (pp, TREE_OPERAND (e, 1));\n-      pp_space (pp);\n-      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 2));\n+      pp_c_logical_or_expression (this, TREE_OPERAND (e, 0));\n+      pp_space (this);\n+      pp_question (this);\n+      pp_space (this);\n+      expression (TREE_OPERAND (e, 1));\n+      pp_space (this);\n+      assignment_expression (TREE_OPERAND (e, 2));\n     }\n   else\n-    pp_c_logical_or_expression (pp, e);\n+    pp_c_logical_or_expression (this, e);\n }\n \n /* Pretty-print a compound assignment operator token as indicated by T.  */\n@@ -996,64 +994,64 @@ pp_cxx_assignment_operator (cxx_pretty_printer *pp, tree t)\n    assignment-operator: one of\n       =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n \n-static void\n-pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree e)\n+void\n+cxx_pretty_printer::assignment_expression (tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case MODIFY_EXPR:\n     case INIT_EXPR:\n-      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n-      pp_space (pp);\n-      pp_equal (pp);\n-      pp_space (pp);\n-      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 1));\n+      pp_c_logical_or_expression (this, TREE_OPERAND (e, 0));\n+      pp_space (this);\n+      pp_equal (this);\n+      pp_space (this);\n+      assignment_expression (TREE_OPERAND (e, 1));\n       break;\n \n     case THROW_EXPR:\n-      pp_cxx_ws_string (pp, \"throw\");\n+      pp_cxx_ws_string (this, \"throw\");\n       if (TREE_OPERAND (e, 0))\n-\tpp_cxx_assignment_expression (pp, TREE_OPERAND (e, 0));\n+\tassignment_expression (TREE_OPERAND (e, 0));\n       break;\n \n     case MODOP_EXPR:\n-      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n-      pp_cxx_assignment_operator (pp, TREE_OPERAND (e, 1));\n-      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 2));\n+      pp_c_logical_or_expression (this, TREE_OPERAND (e, 0));\n+      pp_cxx_assignment_operator (this, TREE_OPERAND (e, 1));\n+      assignment_expression (TREE_OPERAND (e, 2));\n       break;\n \n     default:\n-      pp_cxx_conditional_expression (pp, e);\n+      conditional_expression (e);\n       break;\n     }\n }\n \n-static void\n-pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n+void\n+cxx_pretty_printer::expression (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case STRING_CST:\n     case INTEGER_CST:\n     case REAL_CST:\n     case COMPLEX_CST:\n-      pp_constant (pp, t);\n+      constant (t);\n       break;\n \n     case USERDEF_LITERAL:\n-      pp_cxx_userdef_literal (pp, t);\n+      pp_cxx_userdef_literal (this, t);\n       break;\n \n     case RESULT_DECL:\n-      pp_cxx_unqualified_id (pp, t);\n+      pp_cxx_unqualified_id (this, t);\n       break;\n \n #if 0\n     case OFFSET_REF:\n #endif\n     case SCOPE_REF:\n     case PTRMEM_CST:\n-      pp_cxx_qualified_id (pp, t);\n+      pp_cxx_qualified_id (this, t);\n       break;\n \n     case OVERLOAD:\n@@ -1069,7 +1067,7 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n     case TEMPLATE_PARM_INDEX:\n     case TEMPLATE_TEMPLATE_PARM:\n     case STMT_EXPR:\n-      pp_primary_expression (pp, t);\n+      primary_expression (t);\n       break;\n \n     case CALL_EXPR:\n@@ -1085,65 +1083,65 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n     case PSEUDO_DTOR_EXPR:\n     case AGGR_INIT_EXPR:\n     case ARROW_EXPR:\n-      pp_postfix_expression (pp, t);\n+      postfix_expression (t);\n       break;\n \n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n-      pp_cxx_new_expression (pp, t);\n+      pp_cxx_new_expression (this, t);\n       break;\n \n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n-      pp_cxx_delete_expression (pp, t);\n+      pp_cxx_delete_expression (this, t);\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n     case NOEXCEPT_EXPR:\n-      pp_cxx_unary_expression (pp, t);\n+      unary_expression (t);\n       break;\n \n     case CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n-      pp_cxx_cast_expression (pp, t);\n+      pp_cxx_cast_expression (this, t);\n       break;\n \n     case OFFSET_REF:\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n-      pp_cxx_pm_expression (pp, t);\n+      pp_cxx_pm_expression (this, t);\n       break;\n \n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      pp_cxx_multiplicative_expression (pp, t);\n+      multiplicative_expression (t);\n       break;\n \n     case COND_EXPR:\n-      pp_cxx_conditional_expression (pp, t);\n+      conditional_expression (t);\n       break;\n \n     case MODIFY_EXPR:\n     case INIT_EXPR:\n     case THROW_EXPR:\n     case MODOP_EXPR:\n-      pp_cxx_assignment_expression (pp, t);\n+      assignment_expression (t);\n       break;\n \n     case NON_DEPENDENT_EXPR:\n     case MUST_NOT_THROW_EXPR:\n-      pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n+      expression (TREE_OPERAND (t, 0));\n       break;\n \n     case EXPR_PACK_EXPANSION:\n-      pp_cxx_expression (pp, PACK_EXPANSION_PATTERN (t));\n-      pp_cxx_ws_string (pp, \"...\");\n+      expression (PACK_EXPANSION_PATTERN (t));\n+      pp_cxx_ws_string (this, \"...\");\n       break;\n \n     case TEMPLATE_ID_EXPR:\n-      pp_cxx_template_id (pp, t);\n+      pp_cxx_template_id (this, t);\n       break;\n \n     case NONTYPE_ARGUMENT_PACK:\n@@ -1153,24 +1151,24 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n \tfor (i = 0; i < len; ++i)\n \t  {\n \t    if (i > 0)\n-\t      pp_cxx_separate_with (pp, ',');\n-\t    pp_cxx_expression (pp, TREE_VEC_ELT (args, i));\n+\t      pp_cxx_separate_with (this, ',');\n+\t    expression (TREE_VEC_ELT (args, i));\n \t  }\n       }\n       break;\n       \n     case LAMBDA_EXPR:\n-      pp_cxx_ws_string (pp, \"<lambda>\");\n+      pp_cxx_ws_string (this, \"<lambda>\");\n       break;\n \n     case PAREN_EXPR:\n-      pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n-      pp_cxx_right_paren (pp);\n+      pp_cxx_left_paren (this);\n+      expression (TREE_OPERAND (t, 0));\n+      pp_cxx_right_paren (this);\n       break;\n \n     default:\n-      pp_c_expression (pp, t);\n+      c_pretty_printer::expression (t);\n       break;\n     }\n }\n@@ -1321,7 +1319,7 @@ pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n     case DECLTYPE_TYPE:\n       pp_cxx_ws_string (pp, \"decltype\");\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, DECLTYPE_TYPE_EXPR (t));\n+      pp_expression (pp, DECLTYPE_TYPE_EXPR (t));\n       pp_cxx_right_paren (pp);\n       break;\n \n@@ -1450,7 +1448,7 @@ pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n \t  pp_cxx_whitespace (pp);\n \t  pp_equal (pp);\n \t  pp_cxx_whitespace (pp);\n-\t  pp_cxx_assignment_expression (pp, TREE_PURPOSE (types));\n+\t  pp_assignment_expression (pp, TREE_PURPOSE (types));\n \t}\n     }\n   pp_cxx_right_paren (pp);\n@@ -1479,7 +1477,7 @@ pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n       if (DEFERRED_NOEXCEPT_SPEC_P (ex_spec))\n \tpp_cxx_ws_string (pp, \"<uninstantiated>\");\n       else\n-\tpp_cxx_expression (pp, TREE_PURPOSE (ex_spec));\n+\tpp_expression (pp, TREE_PURPOSE (ex_spec));\n       pp_cxx_right_paren (pp);\n       return;\n     }\n@@ -1788,7 +1786,7 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n \t\t\t       && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n \t    pp_cxx_type_id (pp, arg);\n \t  else\n-\t    pp_cxx_expression (pp, arg);\n+\t    pp_expression (pp, arg);\n \t}\n     }\n }\n@@ -1877,7 +1875,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"if\");\n       pp_cxx_whitespace (pp);\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, IF_COND (t));\n+      pp_expression (pp, IF_COND (t));\n       pp_cxx_right_paren (pp);\n       pp_newline_and_indent (pp, 2);\n       pp_cxx_statement (pp, THEN_CLAUSE (t));\n@@ -1900,7 +1898,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"switch\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, SWITCH_STMT_COND (t));\n+      pp_expression (pp, SWITCH_STMT_COND (t));\n       pp_cxx_right_paren (pp);\n       pp_indentation (pp) += 3;\n       pp_needs_newline (pp) = true;\n@@ -1917,7 +1915,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"while\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, WHILE_COND (t));\n+      pp_expression (pp, WHILE_COND (t));\n       pp_cxx_right_paren (pp);\n       pp_newline_and_indent (pp, 3);\n       pp_cxx_statement (pp, WHILE_BODY (t));\n@@ -1933,7 +1931,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"while\");\n       pp_space (pp);\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, DO_COND (t));\n+      pp_expression (pp, DO_COND (t));\n       pp_cxx_right_paren (pp);\n       pp_cxx_semicolon (pp);\n       pp_needs_newline (pp) = true;\n@@ -1950,12 +1948,12 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       pp_needs_newline (pp) = false;\n       pp_cxx_whitespace (pp);\n       if (FOR_COND (t))\n-\tpp_cxx_expression (pp, FOR_COND (t));\n+\tpp_expression (pp, FOR_COND (t));\n       pp_cxx_semicolon (pp);\n       pp_needs_newline (pp) = false;\n       pp_cxx_whitespace (pp);\n       if (FOR_EXPR (t))\n-\tpp_cxx_expression (pp, FOR_EXPR (t));\n+\tpp_expression (pp, FOR_EXPR (t));\n       pp_cxx_right_paren (pp);\n       pp_newline_and_indent (pp, 3);\n       pp_cxx_statement (pp, FOR_BODY (t));\n@@ -1994,7 +1992,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n       /* expression-statement:\n \t    expression(opt) ;  */\n     case EXPR_STMT:\n-      pp_cxx_expression (pp, EXPR_STMT_EXPR (t));\n+      pp_expression (pp, EXPR_STMT_EXPR (t));\n       pp_cxx_semicolon (pp);\n       pp_needs_newline (pp) = true;\n       break;\n@@ -2218,9 +2216,9 @@ pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n     {\n       pp_cxx_ws_string (pp, \"static_assert\");\n       pp_cxx_left_paren (pp);\n-      pp_cxx_expression (pp, STATIC_ASSERT_CONDITION (t));\n+      pp_expression (pp, STATIC_ASSERT_CONDITION (t));\n       pp_cxx_separate_with (pp, ',');\n-      pp_cxx_expression (pp, STATIC_ASSERT_MESSAGE (t));\n+      pp_expression (pp, STATIC_ASSERT_MESSAGE (t));\n       pp_cxx_right_paren (pp);\n     }\n   else if (!DECL_LANG_SPECIFIC (t))\n@@ -2279,7 +2277,7 @@ pp_cxx_typeid_expression (cxx_pretty_printer *pp, tree t)\n   if (TYPE_P (t))\n     pp_cxx_type_id (pp, t);\n   else\n-    pp_cxx_expression (pp, t);\n+    pp_expression (pp, t);\n   pp_cxx_right_paren (pp);\n }\n \n@@ -2288,7 +2286,7 @@ pp_cxx_va_arg_expression (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_ws_string (pp, \"va_arg\");\n   pp_cxx_left_paren (pp);\n-  pp_cxx_assignment_expression (pp, TREE_OPERAND (t, 0));\n+  pp_assignment_expression (pp, TREE_OPERAND (t, 0));\n   pp_cxx_separate_with (pp, ',');\n   pp_cxx_type_id (pp, TREE_TYPE (t));\n   pp_cxx_right_paren (pp);\n@@ -2313,13 +2311,13 @@ pp_cxx_offsetof_expression_1 (cxx_pretty_printer *pp, tree t)\n \treturn false;\n       if (TREE_CODE (TREE_OPERAND (t, 0)) != ARROW_EXPR)\n \tpp_cxx_dot (pp);\n-      pp_cxx_expression (pp, TREE_OPERAND (t, 1));\n+      pp_expression (pp, TREE_OPERAND (t, 1));\n       return true;\n     case ARRAY_REF:\n       if (!pp_cxx_offsetof_expression_1 (pp, TREE_OPERAND (t, 0)))\n \treturn false;\n       pp_left_bracket (pp);\n-      pp_cxx_expression (pp, TREE_OPERAND (t, 1));\n+      pp_expression (pp, TREE_OPERAND (t, 1));\n       pp_right_bracket (pp);\n       return true;\n     default:\n@@ -2333,7 +2331,7 @@ pp_cxx_offsetof_expression (cxx_pretty_printer *pp, tree t)\n   pp_cxx_ws_string (pp, \"offsetof\");\n   pp_cxx_left_paren (pp);\n   if (!pp_cxx_offsetof_expression_1 (pp, TREE_OPERAND (t, 0)))\n-    pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n+    pp_expression (pp, TREE_OPERAND (t, 0));\n   pp_cxx_right_paren (pp);\n }\n \n@@ -2447,10 +2445,4 @@ cxx_pretty_printer::cxx_pretty_printer ()\n   simple_type_specifier = (pp_fun) pp_cxx_simple_type_specifier;\n \n   /* pp->statement = (pp_fun) pp_cxx_statement;  */\n-\n-  unary_expression = (pp_fun) pp_cxx_unary_expression;\n-  multiplicative_expression = (pp_fun) pp_cxx_multiplicative_expression;\n-  conditional_expression = (pp_fun) pp_cxx_conditional_expression;\n-  assignment_expression = (pp_fun) pp_cxx_assignment_expression;\n-  expression = (pp_fun) pp_cxx_expression;\n }"}, {"sha": "2da83934b9a998cb99778970944d2fcc899f8766", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=00d34d3ab19f3a9e9f3f90f5b83f7ece4daa8a62", "patch": "@@ -37,6 +37,11 @@ struct cxx_pretty_printer : c_pretty_printer\n   void id_expression (tree);\n   void primary_expression (tree);\n   void postfix_expression (tree);\n+  void unary_expression (tree);\n+  void multiplicative_expression (tree);\n+  void conditional_expression (tree);\n+  void assignment_expression (tree);\n+  void expression (tree);\n   /* This is the enclosing scope of the entity being pretty-printed.  */\n   tree enclosing_scope;\n };"}]}