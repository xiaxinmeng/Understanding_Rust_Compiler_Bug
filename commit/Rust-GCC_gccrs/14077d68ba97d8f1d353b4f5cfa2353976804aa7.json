{"sha": "14077d68ba97d8f1d353b4f5cfa2353976804aa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQwNzdkNjhiYTk3ZDhmMWQzNTNiNGY1Y2ZhMjM1Mzk3NjgwNGFhNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-28T22:19:46Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-28T22:19:46Z"}, "message": "c-decl.c: Update commentary, adjust blank lines throughout.\n\n\t* c-decl.c: Update commentary, adjust blank lines throughout.\n\t(struct c_scope): Fix indentation.  Reorder members so\n\touter-context pointers come first, booleans last.\n\t(duplicate_decls, define_label): Use a 'locus' variable for\n\tdiagnostic locations in a few more places.\n\t(warn_if_shadowing): Un-split a conditional that fits on one line.\n\t(c_init_decl_processing): No need to clear current_scope and\n\tcurrent_function_scope.\n\t(start_decl): Merge if/else if statements with same action.\n\t(push_parm_decl): Rename old_immediate_size_expand to use\n\tsave_foo convention; save/restore around entire function.\n\t(grokdeclarator): Remove unnecessary braces.\n\nFrom-SVN: r69903", "tree": {"sha": "b25acde512454a3053fdf16ae06bc2426487fbdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25acde512454a3053fdf16ae06bc2426487fbdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14077d68ba97d8f1d353b4f5cfa2353976804aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14077d68ba97d8f1d353b4f5cfa2353976804aa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14077d68ba97d8f1d353b4f5cfa2353976804aa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14077d68ba97d8f1d353b4f5cfa2353976804aa7/comments", "author": null, "committer": null, "parents": [{"sha": "58579435ee7287aa28ec4185aba3213182c7bb1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58579435ee7287aa28ec4185aba3213182c7bb1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58579435ee7287aa28ec4185aba3213182c7bb1e"}], "stats": {"total": 235, "additions": 121, "deletions": 114}, "files": [{"sha": "c3e8f266a92b0e056daa48c5a8bca09b3e1d5794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14077d68ba97d8f1d353b4f5cfa2353976804aa7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14077d68ba97d8f1d353b4f5cfa2353976804aa7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14077d68ba97d8f1d353b4f5cfa2353976804aa7", "patch": "@@ -1,3 +1,18 @@\n+2003-07-28  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c: Update commentary, adjust blank lines throughout.\n+\t(struct c_scope): Fix indentation.  Reorder members so\n+\touter-context pointers come first, booleans last.\n+\t(duplicate_decls, define_label): Use a 'locus' variable for\n+\tdiagnostic locations in a few more places.\n+\t(warn_if_shadowing): Un-split a conditional that fits on one line.\n+\t(c_init_decl_processing): No need to clear current_scope and\n+\tcurrent_function_scope.\n+\t(start_decl): Merge if/else if statements with same action.\n+\t(push_parm_decl): Rename old_immediate_size_expand to use\n+\tsave_foo convention; save/restore around entire function.\n+\t(grokdeclarator): Remove unnecessary braces.\n+\n 2003-07-28  Hans-Peter Nilsson  <hp@bitrange.com>\n \t    Michael Culbertson  <Michael.J.Culbertson@wheaton.edu>\n \n@@ -38,7 +53,7 @@ Mon Jul 28 20:13:06 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-07-27  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n-\t* fixinc/fixinc.svr4: Remove dead code.  Remove now-unnecessary \n+\t* fixinc/fixinc.svr4: Remove dead code.  Remove now-unnecessary\n \tcleanup of junk after #else and #endif directives.  Collapse repeated\n \tclauses into for statment.\n "}, {"sha": "7923a1623b284ad1f206f213b5df25e7089d4970", "filename": "gcc/c-decl.c", "status": "modified", "additions": 105, "deletions": 113, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14077d68ba97d8f1d353b4f5cfa2353976804aa7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14077d68ba97d8f1d353b4f5cfa2353976804aa7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=14077d68ba97d8f1d353b4f5cfa2353976804aa7", "patch": "@@ -88,8 +88,8 @@ static int enum_overflow;\n \n static tree last_function_parms;\n \n-/* Parsing a function declarator leaves a chain of structure\n-   and enum types declared in the parmlist here.  */\n+/* ... and a chain of structure and enum types declared in the\n+   parmlist here.  */\n \n static tree last_function_parm_tags;\n \n@@ -166,64 +166,57 @@ static int current_extern_inline;\n  */\n \n struct c_scope GTY(())\n-  {\n-    /* A chain of _DECL nodes for all variables, constants, functions,\n-       and typedef types.  These are in the reverse of the order supplied.\n-     */\n-    tree names;\n-\n-    /* A list of structure, union and enum definitions,\n-     * for looking up tag names.\n-     * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,\n-     * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,\n-     * or ENUMERAL_TYPE node.\n-     */\n-    tree tags;\n-\n-    /* For each scope, a list of shadowed outer-scope definitions\n-       to be restored when this scope is popped.\n-       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n-       whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n-    tree shadowed;\n-\n-    /* For each scope, a list of shadowed outer-scope tag definitions\n-       to be restored when this scope is popped.\n-       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n-       whose TREE_VALUE is its old definition (a kind of ..._TYPE node).  */\n-    tree shadowed_tags;\n-\n-    /* For each scope (except not the global one),\n-       a chain of BLOCK nodes for all the scopes\n-       that were entered and exited one level down.  */\n-    tree blocks;\n-\n-    /* The scope containing this one.  */\n-    struct c_scope *outer;\n-\n-    /* The next outermost function scope.  */\n-    struct c_scope *outer_function;\n-\n-    /* True if we are currently filling this scope with parameter\n-       declarations.  */\n-    bool parm_flag : 1;\n-\n-    /* True if this is the outermost block scope of a function body.\n-       This scope contains both the parameters and the local variables\n-       declared in the outermost block.  */\n-    bool function_body : 1;\n-\n-    /* True means make a BLOCK for this scope regardless of all else.  */\n-    bool keep : 1;\n-\n-    /* List of decls in `names' that have incomplete structure or\n-       union types.  */\n-    tree incomplete_list;\n-\n-    /* A list of decls giving the (reversed) specified order of parms,\n-       not including any forward-decls in the parmlist.\n-       This is so we can put the parms in proper order for assign_parms.  */\n-    tree parm_order;\n-  };\n+{\n+  /* The scope containing this one.  */\n+  struct c_scope *outer;\n+\n+  /* The next outermost function scope.  */\n+  struct c_scope *outer_function;\n+\n+  /* All variables, constants, functions, labels, and typedef names.\n+     They are in the reverse of the order supplied.  */\n+  tree names;\n+\n+  /* All structure, union, and enum type tags.  */\n+  tree tags;\n+\n+  /* For each scope, a list of shadowed outer-scope definitions\n+     to be restored when this scope is popped.\n+     Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n+     whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n+  tree shadowed;\n+\n+  /* For each scope, a list of shadowed outer-scope tag definitions\n+     to be restored when this scope is popped.\n+     Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n+     whose TREE_VALUE is its old definition (a kind of ..._TYPE node).  */\n+  tree shadowed_tags;\n+\n+  /* For each scope (except the global one), a chain of BLOCK nodes\n+     for all the scopes that were entered and exited one level down.  */\n+  tree blocks;\n+\n+  /* Variable declarations with incomplete type in this scope.  */\n+  tree incomplete_list;\n+\n+  /* A list of decls giving the (reversed) specified order of parms,\n+     not including any forward-decls in the parmlist.\n+     This is so we can put the parms in proper order for assign_parms.  */\n+  tree parm_order;\n+\n+  /* True if we are currently filling this scope with parameter\n+     declarations.  */\n+  bool parm_flag : 1;\n+\n+  /* True if this is the outermost block scope of a function body.\n+     This scope contains the parameters, the local variables declared\n+     in the outermost block, and all the labels (except those in\n+     nested functions, or declared at block scope with __label__).  */\n+  bool function_body : 1;\n+\n+  /* True means make a BLOCK for this scope no matter what.  */\n+  bool keep : 1;\n+};\n \n /* The scope currently in effect.  */\n \n@@ -236,6 +229,7 @@ static GTY((deletable (\"\"))) struct c_scope *scope_freelist;\n /* The innermost function scope.  Ordinary (not explicitly declared)\n    labels, bindings to error_mark_node, and the lazily-created\n    bindings of __func__ and its friends get this scope.  */\n+\n static GTY(()) struct c_scope *current_function_scope;\n \n /* The outermost scope, corresponding to the C \"file scope\".  This is\n@@ -402,7 +396,8 @@ in_parm_level_p (void)\n   return current_scope->parm_flag;\n }\n \n-/* Enter a new scope.  */\n+/* Enter a new scope.  The dummy parameter is for signature\n+   compatibility with lang_hooks.decls.pushlevel.  */\n \n void\n pushlevel (int dummy ATTRIBUTE_UNUSED)\n@@ -447,12 +442,15 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n    debugging output.  If KEEP is KEEP_MAYBE, do so only if the names\n    or tags lists are nonempty.\n \n+   If REVERSE is nonzero, reverse the order of decls before putting\n+   them into the BLOCK.\n+\n    If FUNCTIONBODY is nonzero, this level is the body of a function,\n-   so create a BLOCK as if KEEP were set, and save that BLOCK in\n-   DECL_INITIAL of current_function_decl.\n+   even if current_scope->function_body is not set.  This is used\n+   by language-independent code that generates synthetic functions,\n+   and cannot set current_scope->function_body.\n \n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.  */\n+   FIXME: Eliminate the need for all arguments.  */\n \n tree\n poplevel (int keep, int reverse, int functionbody)\n@@ -665,10 +663,9 @@ pushtag (tree name, tree type)\n {\n   struct c_scope *b = current_scope;\n \n+  /* Record the identifier as the type's name if it has none.  */\n   if (name)\n     {\n-      /* Record the identifier as the type's name if it has none.  */\n-\n       if (TYPE_NAME (type) == 0)\n \tTYPE_NAME (type) = name;\n \n@@ -1124,53 +1121,55 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       /* Warn about mismatches in various flags.  */\n       else\n \t{\n+\t  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n+\n \t  /* Warn if function is now inline\n \t     but was previously declared not inline and has been called.  */\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && TREE_USED (olddecl))\n \t    warning (\"%H'%D' declared inline after being called\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     locus, newdecl);\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && DECL_INITIAL (olddecl) != 0)\n \t    warning (\"%H'%D' declared inline after its definition\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     locus, newdecl);\n \n \t  /* If pedantic, warn when static declaration follows a non-static\n-\t     declaration.  Otherwise, do so only for functions.  */\n+\t     declaration.  Otherwise, do so only for functions.\t */\n \t  if ((pedantic || TREE_CODE (olddecl) == FUNCTION_DECL)\n \t      && TREE_PUBLIC (olddecl)\n \t      && !TREE_PUBLIC (newdecl))\n \t    warning (\"%Hstatic declaration for '%D' follows non-static\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     locus, newdecl);\n \n \t  /* If warn_traditional, warn when a non-static function\n-\t     declaration follows a static one.  */\n+\t     declaration follows a static one.\t*/\n \t  if (warn_traditional && !in_system_header\n \t      && TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && !TREE_PUBLIC (olddecl)\n \t      && TREE_PUBLIC (newdecl))\n \t    warning (\"%Hnon-static declaration for '%D' follows static\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     locus, newdecl);\n \n \t  /* Warn when const declaration follows a non-const\n \t     declaration, but not for functions.  */\n \t  if (TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && !TREE_READONLY (olddecl)\n \t      && TREE_READONLY (newdecl))\n \t    warning (\"%Hconst declaration for '%D' follows non-const\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     locus, newdecl);\n \t  /* These bits are logically part of the type, for variables.\n \t     But not for functions\n \t     (where qualifiers are not valid ANSI anyway).  */\n \t  else if (pedantic && TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n \t\t  || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n \t    pedwarn (\"%Htype qualifiers for '%D' conflict with previous \"\n-                     \"declaration\", &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\t     \"declaration\", locus, newdecl);\n \t}\n     }\n \n@@ -1534,12 +1533,10 @@ warn_if_shadowing (tree x, tree old)\n \t It would be nice to avoid warning in any function\n \t declarator in a declaration, as opposed to a definition,\n \t but there is no way to tell it's not a definition.  */\n-      || (TREE_CODE (x) == PARM_DECL\n-\t  && current_scope->outer->parm_flag))\n+      || (TREE_CODE (x) == PARM_DECL && current_scope->outer->parm_flag))\n     return;\n \n   name = IDENTIFIER_POINTER (DECL_NAME (x));\n-\n   if (TREE_CODE (old) == PARM_DECL)\n     shadow_warning (SW_PARAM, name, old);\n   else if (C_DECL_FILE_SCOPE (old))\n@@ -1702,7 +1699,11 @@ pushdecl (tree x)\n       /* Keep list of variables in this scope with incomplete type.\n \t If the input is erroneous, we can have error_mark in the type\n \t slot (e.g. \"f(void a, ...)\") - that doesn't count as an\n-\t incomplete type.  */\n+\t incomplete type.\n+\n+\t FIXME: Chain these off the TYPE_DECL for the incomplete type,\n+\t then we don't have to do (potentially quite costly) searches\n+\t in finish_struct.  */\n       if (TREE_TYPE (x) != error_mark_node\n \t  && !COMPLETE_TYPE_P (TREE_TYPE (x)))\n \t{\n@@ -1826,16 +1827,15 @@ implicitly_declare (tree functionid)\n   C_DECL_IMPLICIT (decl) = 1;\n   implicit_decl_warning (functionid);\n \n-  /* ANSI standard says implicit declarations are in the innermost block.\n+  /* C89 says implicit declarations are in the innermost block.\n      So we record the decl in the standard fashion.  */\n   decl = pushdecl (decl);\n \n   /* No need to call objc_check_decl here - it's a function type.  */\n   rest_of_decl_compilation (decl, NULL, 0, 0);\n \n-  /* Write a record describing this implicit function declaration to the\n-     prototypes file (if requested).  */\n-\n+  /* Write a record describing this implicit function declaration\n+     to the prototypes file (if requested).  */\n   gen_aux_info_record (decl, 0, 1, 0);\n \n   /* Possibly apply some default attributes to this implicit declaration.  */\n@@ -2014,8 +2014,7 @@ lookup_label (tree name)\n   /* No label binding for that identifier; make one.  */\n   label = make_label (name, input_location);\n \n-  /* Ordinary labels go in the current function scope, which is\n-     not necessarily the current label scope.  */\n+  /* Ordinary labels go in the current function scope.  */\n   bind_label (name, label, current_function_scope);\n   return label;\n }\n@@ -2076,13 +2075,12 @@ define_label (location_t location, tree name)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n+      location_t *prev_loc = &DECL_SOURCE_LOCATION (label);\n       error (\"%Hduplicate label `%D'\", &location, label);\n       if (DECL_INITIAL (label))\n-\terror (\"%H`%D' previously defined here\",\n-\t       &DECL_SOURCE_LOCATION (label), label);\n+\terror (\"%H`%D' previously defined here\", prev_loc, label);\n       else\n-\terror (\"%H`%D' previously declared here\",\n-\t       &DECL_SOURCE_LOCATION (label), label);\n+\terror (\"%H`%D' previously declared here\", prev_loc, label);\n       return 0;\n     }\n   else if (label && DECL_CONTEXT (label) == current_function_decl)\n@@ -2097,8 +2095,7 @@ define_label (location_t location, tree name)\n       /* No label binding for that identifier; make one.  */\n       label = make_label (name, location);\n \n-      /* Ordinary labels go in the current function scope, which is\n-\t not necessarily the current label scope.  */\n+      /* Ordinary labels go in the current function scope.  */\n       bind_label (name, label, current_function_scope);\n     }\n \n@@ -2113,9 +2110,7 @@ define_label (location_t location, tree name)\n }\n \f\n /* Return the list of declarations of the current scope.\n-   Note that this list is in reverse order unless/until\n-   you nreverse it; and when you do nreverse it, you must\n-   store the result back using `storedecls' or you will lose.  */\n+   Note that this list is in reverse order.  */\n \n tree\n getdecls (void)\n@@ -2260,14 +2255,12 @@ c_init_decl_processing (void)\n   /* Adds some ggc roots, and reserved words for c-parse.in.  */\n   c_parse_init ();\n \n-  current_function_decl = NULL;\n-  current_scope = NULL;\n-  current_function_scope = NULL;\n-  scope_freelist = NULL;\n+  current_function_decl = 0;\n \n   /* Make the c_scope structure for global names.  */\n   pushlevel (0);\n   global_scope = current_scope;\n+\n   /* Declarations from c_common_nodes_and_builtins must not be associated\n      with this input file, lest we get differences between using and not\n      using preprocessed headers.  */\n@@ -2711,10 +2704,9 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n       && C_DECL_FILE_SCOPE (tem))\n     {\n       if (TREE_TYPE (tem) != error_mark_node\n-\t  && COMPLETE_TYPE_P (TREE_TYPE (tem)))\n-\texpand_decl (tem);\n-      else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n-\t       && DECL_INITIAL (tem) != 0)\n+\t  && (COMPLETE_TYPE_P (TREE_TYPE (tem))\n+\t      || (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n+\t\t  && DECL_INITIAL (tem) != 0)))\n \texpand_decl (tem);\n     }\n \n@@ -3004,8 +2996,10 @@ void\n push_parm_decl (tree parm)\n {\n   tree decl;\n-  int old_immediate_size_expand = immediate_size_expand;\n-  /* Don't try computing parm sizes now -- wait till fn is called.  */\n+\n+  /* Don't attempt to expand sizes while parsing this decl.\n+     (We can get here with i_s_e 1 somehow from Objective-C.)  */\n+  int save_immediate_size_expand = immediate_size_expand;\n   immediate_size_expand = 0;\n \n   decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n@@ -3014,13 +3008,12 @@ push_parm_decl (tree parm)\n \n   decl = pushdecl (decl);\n \n-  immediate_size_expand = old_immediate_size_expand;\n-\n   current_scope->parm_order\n     = tree_cons (NULL_TREE, decl, current_scope->parm_order);\n \n-  /* Add this decl to the current scope.  */\n   finish_decl (decl, NULL_TREE, NULL_TREE);\n+\n+  immediate_size_expand = save_immediate_size_expand;\n }\n \n /* Clear the given order of parms in `parm_order'.\n@@ -4268,11 +4261,9 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  }\n \t/* Move type qualifiers down to element of an array.  */\n \tif (TREE_CODE (type) == ARRAY_TYPE && type_quals)\n-\t  {\n-\t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t\t     type_quals),\n-\t\t\t\t     TYPE_DOMAIN (type));\n-\t  }\n+\t  type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t\t   type_quals),\n+\t\t\t\t   TYPE_DOMAIN (type));\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \n@@ -4508,6 +4499,7 @@ grokparms (tree parms_info, int funcdef_flag)\n \t These tags can never be defined in the scope of the declaration,\n \t so the types can never be completed,\n \t and no call can be compiled successfully.  */\n+\n       for (parm = last_function_parms, typelt = first_parm;\n \t   parm;\n \t   parm = TREE_CHAIN (parm))\n@@ -4539,7 +4531,7 @@ grokparms (tree parms_info, int funcdef_flag)\n }\n \n /* Return a tree_list node with info on a parameter list just parsed.\n-   The TREE_PURPOSE is a chain of decls of those parms.\n+   The TREE_PURPOSE is a list of decls of those parms.\n    The TREE_VALUE is a list of structure, union and enum tags defined.\n    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.\n    This tree_list node is later fed to `grokparms'."}]}