{"sha": "114783066e5d1046dfe83bb987008f4c2729e8f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0NzgzMDY2ZTVkMTA0NmRmZTgzYmI5ODcwMDhmNGMyNzI5ZThmNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-22T19:39:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-22T19:39:44Z"}, "message": "tree-ssa-ccp.c (prop_value_d): Rename to ...\n\n\n\t* tree-ssa-ccp.c (prop_value_d): Rename to ...\n\t(ccp_prop_value_t): ... this one to avoid ODR violation; update uses.\n\t* ipa-prop.c (struct type_change_info): Rename to ...\n\t(prop_type_change_info): ... this; update uses.\n\t* ggc-page.c (globals): Rename to ...\n\t(static struct ggc_globals): ... this; update uses.\n\t* tree-ssa-loop-im.c (mem_ref): Rename to ...\n\t(im_mem_ref): ... this; update uses.\n\t* ggc-common.c (loc_descriptor): Rename to ...\n\t(ggc_loc_descriptor): ... this; update uses.\n\t* lra-eliminations.c (elim_table): Rename to ...\n\t(lra_elim_table): ... this; update uses.\n\t* bitmap.c (output_info): Rename to ...\n\t(bitmap_output_info): ... this; update uses.\n\t* gcse.c (expr): Rename to ...\n\t(gcse_expr) ... this; update uses.\n\t(occr): Rename to ...\n\t(gcse_occr): .. this; update uses.\n\t* tree-ssa-copy.c (prop_value_d): Rename to ...\n\t(prop_value_t): ... this.\n\t* predict.c (block_info_def): Rename to ...\n\t(block_info): ... this; update uses.\n\t(edge_info_def): Rename to ...\n\t(edge_info): ... this; update uses.\n\t* profile.c (bb_info): Rename to ...\n\t(bb_profile_info): ... this; update uses.\n\t* alloc-pool.c (output_info): Rename to ...\n\t(pool_output_info): ... this; update uses.\n\t* ipa-cp.c (topo_info): Rename to ..\n\t(ipa_topo_info): ... this; update uses.\n\t* tree-nrv.c (nrv_data): Rename to ...\n\t(nrv_data_t): ... this; update uses.\n\t* ipa-split.c (bb_info): Rename to ...\n\t(split_bb_info): ... this one.\n\t* profile.h (edge_info): Rename to ...\n\t(edge_profile_info): ... this one; update uses.\n\t* dse.c (bb_info): Rename to ...\n\t(dse_bb_info): ... this one; update uses.\n\t* cprop.c (occr): Rename to ...\n\t(cprop_occr): ... this one; update uses.\n\t(expr): Rename to ...\n\t(cprop_expr): ... this one; update uses.\n\nFrom-SVN: r215480", "tree": {"sha": "b404afbf06494ab4a638586fe78ffa6a9f2b91f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b404afbf06494ab4a638586fe78ffa6a9f2b91f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114783066e5d1046dfe83bb987008f4c2729e8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114783066e5d1046dfe83bb987008f4c2729e8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114783066e5d1046dfe83bb987008f4c2729e8f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114783066e5d1046dfe83bb987008f4c2729e8f6/comments", "author": null, "committer": null, "parents": [{"sha": "6863c41a15ac58554cd413c1dcde9f43d9dba4c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6863c41a15ac58554cd413c1dcde9f43d9dba4c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6863c41a15ac58554cd413c1dcde9f43d9dba4c0"}], "stats": {"total": 574, "additions": 308, "deletions": 266}, "files": [{"sha": "96a5d7a66e4ae35846c66e38b16d7d50942005cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -1,3 +1,48 @@\n+2014-09-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-ccp.c (prop_value_d): Rename to ...\n+\t(ccp_prop_value_t): ... this one to avoid ODR violation; update uses.\n+\t* ipa-prop.c (struct type_change_info): Rename to ...\n+\t(prop_type_change_info): ... this; update uses.\n+\t* ggc-page.c (globals): Rename to ...\n+\t(static struct ggc_globals): ... this; update uses.\n+\t* tree-ssa-loop-im.c (mem_ref): Rename to ...\n+\t(im_mem_ref): ... this; update uses.\n+\t* ggc-common.c (loc_descriptor): Rename to ...\n+\t(ggc_loc_descriptor): ... this; update uses.\n+\t* lra-eliminations.c (elim_table): Rename to ...\n+\t(lra_elim_table): ... this; update uses.\n+\t* bitmap.c (output_info): Rename to ...\n+\t(bitmap_output_info): ... this; update uses.\n+\t* gcse.c (expr): Rename to ...\n+\t(gcse_expr) ... this; update uses.\n+\t(occr): Rename to ...\n+\t(gcse_occr): .. this; update uses.\n+\t* tree-ssa-copy.c (prop_value_d): Rename to ...\n+\t(prop_value_t): ... this.\n+\t* predict.c (block_info_def): Rename to ...\n+\t(block_info): ... this; update uses.\n+\t(edge_info_def): Rename to ...\n+\t(edge_info): ... this; update uses.\n+\t* profile.c (bb_info): Rename to ...\n+\t(bb_profile_info): ... this; update uses.\n+\t* alloc-pool.c (output_info): Rename to ...\n+\t(pool_output_info): ... this; update uses.\n+\t* ipa-cp.c (topo_info): Rename to ..\n+\t(ipa_topo_info): ... this; update uses.\n+\t* tree-nrv.c (nrv_data): Rename to ...\n+\t(nrv_data_t): ... this; update uses.\n+\t* ipa-split.c (bb_info): Rename to ...\n+\t(split_bb_info): ... this one.\n+\t* profile.h (edge_info): Rename to ...\n+\t(edge_profile_info): ... this one; update uses.\n+\t* dse.c (bb_info): Rename to ...\n+\t(dse_bb_info): ... this one; update uses.\n+\t* cprop.c (occr): Rename to ...\n+\t(cprop_occr): ... this one; update uses.\n+\t(expr): Rename to ...\n+\t(cprop_expr): ... this one; update uses.\n+\n 2014-09-22  Jason Merrill  <jason@redhat.com>\n \n \t* Makefile.in (check-parallel-%): Add @."}, {"sha": "a6b13f081ead3683348fd5f9d3be9efbf38d5f16", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -339,7 +339,7 @@ pool_free (alloc_pool pool, void *ptr)\n /* Output per-alloc_pool statistics.  */\n \n /* Used to accumulate statistics about alloc_pool sizes.  */\n-struct output_info\n+struct pool_output_info\n {\n   unsigned long total_created;\n   unsigned long total_allocated;\n@@ -350,7 +350,7 @@ struct output_info\n bool\n print_alloc_pool_statistics (const char *const &name,\n \t\t\t     const alloc_pool_descriptor &d,\n-\t\t\t     struct output_info *i)\n+\t\t\t     struct pool_output_info *i)\n {\n   if (d.allocated)\n     {\n@@ -369,7 +369,7 @@ print_alloc_pool_statistics (const char *const &name,\n void\n dump_alloc_pool_statistics (void)\n {\n-  struct output_info info;\n+  struct pool_output_info info;\n \n   if (! GATHER_STATISTICS)\n     return;\n@@ -381,7 +381,7 @@ dump_alloc_pool_statistics (void)\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   info.total_created = 0;\n   info.total_allocated = 0;\n-  alloc_pool_hash->traverse <struct output_info *,\n+  alloc_pool_hash->traverse <struct pool_output_info *,\n \t\t\t     print_alloc_pool_statistics> (&info);\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   fprintf (stderr, \"%-22s           %7lu %10lu\\n\","}, {"sha": "8f7f3064be642adf82dc2fd9c5bd179dae36157f", "filename": "gcc/bitmap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -2143,7 +2143,7 @@ bitmap_print (FILE *file, const_bitmap head, const char *prefix,\n \n \n /* Used to accumulate statistics about bitmap sizes.  */\n-struct output_info\n+struct bitmap_output_info\n {\n   uint64_t size;\n   uint64_t count;\n@@ -2152,7 +2152,7 @@ struct output_info\n /* Called via hash_table::traverse.  Output bitmap descriptor pointed out by\n    SLOT and update statistics.  */\n int\n-print_statistics (bitmap_descriptor_d **slot, output_info *i)\n+print_statistics (bitmap_descriptor_d **slot, bitmap_output_info *i)\n {\n   bitmap_descriptor d = *slot;\n   char s[4096];\n@@ -2181,7 +2181,7 @@ print_statistics (bitmap_descriptor_d **slot, output_info *i)\n void\n dump_bitmap_statistics (void)\n {\n-  struct output_info info;\n+  struct bitmap_output_info info;\n \n   if (! GATHER_STATISTICS)\n     return;\n@@ -2197,7 +2197,7 @@ dump_bitmap_statistics (void)\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   info.count = 0;\n   info.size = 0;\n-  bitmap_desc_hash->traverse <output_info *, print_statistics> (&info);\n+  bitmap_desc_hash->traverse <bitmap_output_info *, print_statistics> (&info);\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   fprintf (stderr,\n \t   \"%-41s %9\"PRId64\" %15\"PRId64\"\\n\","}, {"sha": "f73abc2c311f622f30855b636902e7b24af0e288", "filename": "gcc/cprop.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -55,19 +55,19 @@ static struct obstack cprop_obstack;\n    There is one per basic block.  If a pattern appears more than once the\n    last appearance is used.  */\n \n-struct occr\n+struct cprop_occr\n {\n   /* Next occurrence of this expression.  */\n-  struct occr *next;\n+  struct cprop_occr *next;\n   /* The insn that computes the expression.  */\n   rtx_insn *insn;\n };\n \n-typedef struct occr *occr_t;\n+typedef struct cprop_occr *occr_t;\n \n /* Hash table entry for assignment expressions.  */\n \n-struct expr\n+struct cprop_expr\n {\n   /* The expression (DEST := SRC).  */\n   rtx dest;\n@@ -76,12 +76,12 @@ struct expr\n   /* Index in the available expression bitmaps.  */\n   int bitmap_index;\n   /* Next entry with the same hash.  */\n-  struct expr *next_same_hash;\n+  struct cprop_expr *next_same_hash;\n   /* List of available occurrence in basic blocks in the function.\n      An \"available occurrence\" is one that is the last occurrence in the\n      basic block and whose operands are not modified by following statements\n      in the basic block [including this insn].  */\n-  struct occr *avail_occr;\n+  struct cprop_occr *avail_occr;\n };\n \n /* Hash table for copy propagation expressions.\n@@ -97,7 +97,7 @@ struct hash_table_d\n {\n   /* The table itself.\n      This is an array of `set_hash_table_size' elements.  */\n-  struct expr **table;\n+  struct cprop_expr **table;\n \n   /* Size of the hash table, in elements.  */\n   unsigned int size;\n@@ -184,8 +184,8 @@ insert_set_in_table (rtx dest, rtx src, rtx_insn *insn,\n {\n   bool found = false;\n   unsigned int hash;\n-  struct expr *cur_expr, *last_expr = NULL;\n-  struct occr *cur_occr;\n+  struct cprop_expr *cur_expr, *last_expr = NULL;\n+  struct cprop_occr *cur_occr;\n \n   hash = hash_mod (REGNO (dest), table->size);\n \n@@ -203,8 +203,8 @@ insert_set_in_table (rtx dest, rtx src, rtx_insn *insn,\n \n   if (! found)\n     {\n-      cur_expr = GOBNEW (struct expr);\n-      bytes_used += sizeof (struct expr);\n+      cur_expr = GOBNEW (struct cprop_expr);\n+      bytes_used += sizeof (struct cprop_expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n \ttable->table[hash] = cur_expr;\n@@ -237,8 +237,8 @@ insert_set_in_table (rtx dest, rtx src, rtx_insn *insn,\n   else\n     {\n       /* First occurrence of this expression in this basic block.  */\n-      cur_occr = GOBNEW (struct occr);\n-      bytes_used += sizeof (struct occr);\n+      cur_occr = GOBNEW (struct cprop_occr);\n+      bytes_used += sizeof (struct cprop_occr);\n       cur_occr->insn = insn;\n       cur_occr->next = cur_expr->avail_occr;\n       cur_expr->avail_occr = cur_occr;\n@@ -335,11 +335,11 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n-  struct expr **flat_table;\n+  struct cprop_expr **flat_table;\n   unsigned int *hash_val;\n-  struct expr *expr;\n+  struct cprop_expr *expr;\n \n-  flat_table = XCNEWVEC (struct expr *, table->n_elems);\n+  flat_table = XCNEWVEC (struct cprop_expr *, table->n_elems);\n   hash_val = XNEWVEC (unsigned int, table->n_elems);\n \n   for (i = 0; i < (int) table->size; i++)\n@@ -451,8 +451,8 @@ alloc_hash_table (struct hash_table_d *table)\n      Making it an odd number is simplest for now.\n      ??? Later take some measurements.  */\n   table->size |= 1;\n-  n = table->size * sizeof (struct expr *);\n-  table->table = XNEWVAR (struct expr *, n);\n+  n = table->size * sizeof (struct cprop_expr *);\n+  table->table = XNEWVAR (struct cprop_expr *, n);\n }\n \n /* Free things allocated by alloc_hash_table.  */\n@@ -471,7 +471,7 @@ compute_hash_table (struct hash_table_d *table)\n {\n   /* Initialize count of number of entries in hash table.  */\n   table->n_elems = 0;\n-  memset (table->table, 0, table->size * sizeof (struct expr *));\n+  memset (table->table, 0, table->size * sizeof (struct cprop_expr *));\n \n   compute_hash_table_work (table);\n }\n@@ -481,11 +481,11 @@ compute_hash_table (struct hash_table_d *table)\n /* Lookup REGNO in the set TABLE.  The result is a pointer to the\n    table entry, or NULL if not found.  */\n \n-static struct expr *\n+static struct cprop_expr *\n lookup_set (unsigned int regno, struct hash_table_d *table)\n {\n   unsigned int hash = hash_mod (regno, table->size);\n-  struct expr *expr;\n+  struct cprop_expr *expr;\n \n   expr = table->table[hash];\n \n@@ -497,8 +497,8 @@ lookup_set (unsigned int regno, struct hash_table_d *table)\n \n /* Return the next entry for REGNO in list EXPR.  */\n \n-static struct expr *\n-next_set (unsigned int regno, struct expr *expr)\n+static struct cprop_expr *\n+next_set (unsigned int regno, struct cprop_expr *expr)\n {\n   do\n     expr = expr->next_same_hash;\n@@ -599,13 +599,13 @@ compute_local_properties (sbitmap *kill, sbitmap *comp,\n \n   for (i = 0; i < table->size; i++)\n     {\n-      struct expr *expr;\n+      struct cprop_expr *expr;\n \n       for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n \t{\n \t  int indx = expr->bitmap_index;\n \t  df_ref def;\n-\t  struct occr *occr;\n+\t  struct cprop_occr *occr;\n \n \t  /* For each definition of the destination pseudo-reg, the expression\n \t     is killed in the block where the definition is.  */\n@@ -799,12 +799,12 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)\n /* Find a set of REGNOs that are available on entry to INSN's block.  Return\n    NULL no such set is found.  */\n \n-static struct expr *\n+static struct cprop_expr *\n find_avail_set (int regno, rtx_insn *insn)\n {\n   /* SET1 contains the last set found that can be returned to the caller for\n      use in a substitution.  */\n-  struct expr *set1 = 0;\n+  struct cprop_expr *set1 = 0;\n \n   /* Loops are not possible here.  To get a loop we would need two sets\n      available at the start of the block containing INSN.  i.e. we would\n@@ -818,7 +818,7 @@ find_avail_set (int regno, rtx_insn *insn)\n   while (1)\n     {\n       rtx src;\n-      struct expr *set = lookup_set (regno, &set_hash_table);\n+      struct cprop_expr *set = lookup_set (regno, &set_hash_table);\n \n       /* Find a set that is available at the start of the block\n \t which contains INSN.  */\n@@ -1040,7 +1040,7 @@ cprop_insn (rtx_insn *insn)\n       rtx reg_used = reg_use_table[i];\n       unsigned int regno = REGNO (reg_used);\n       rtx src;\n-      struct expr *set;\n+      struct cprop_expr *set;\n \n       /* If the register has already been set in this block, there's\n \t nothing we can do.  */\n@@ -1429,15 +1429,15 @@ static int bypass_last_basic_block;\n    block BB.  Return NULL if no such set is found.  Based heavily upon\n    find_avail_set.  */\n \n-static struct expr *\n+static struct cprop_expr *\n find_bypass_set (int regno, int bb)\n {\n-  struct expr *result = 0;\n+  struct cprop_expr *result = 0;\n \n   for (;;)\n     {\n       rtx src;\n-      struct expr *set = lookup_set (regno, &set_hash_table);\n+      struct cprop_expr *set = lookup_set (regno, &set_hash_table);\n \n       while (set)\n \t{\n@@ -1561,7 +1561,7 @@ bypass_block (basic_block bb, rtx_insn *setcc, rtx_insn *jump)\n \t  rtx reg_used = reg_use_table[i];\n \t  unsigned int regno = REGNO (reg_used);\n \t  basic_block dest, old_dest;\n-\t  struct expr *set;\n+\t  struct cprop_expr *set;\n \t  rtx src, new_rtx;\n \n \t  set = find_bypass_set (regno, e->src->index);"}, {"sha": "4a2f3c7f2c7535213a78ef06e3013d921fb1f9e8", "filename": "gcc/dse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -421,7 +421,7 @@ static alloc_pool insn_info_pool;\n static insn_info_t active_local_stores;\n static int active_local_stores_len;\n \n-struct bb_info\n+struct dse_bb_info\n {\n \n   /* Pointer to the insn info for the last insn in the block.  These\n@@ -479,7 +479,7 @@ struct bb_info\n   bitmap regs_live;\n };\n \n-typedef struct bb_info *bb_info_t;\n+typedef struct dse_bb_info *bb_info_t;\n static alloc_pool bb_info_pool;\n \n /* Table to hold all bb_infos.  */\n@@ -757,7 +757,7 @@ dse_step0 (void)\n \t\t\t sizeof (struct insn_info), 100);\n   bb_info_pool\n     = create_alloc_pool (\"bb_info_pool\",\n-\t\t\t sizeof (struct bb_info), 100);\n+\t\t\t sizeof (struct dse_bb_info), 100);\n   rtx_group_info_pool\n     = create_alloc_pool (\"rtx_group_info_pool\",\n \t\t\t sizeof (struct group_info), 100);\n@@ -2700,7 +2700,7 @@ dse_step1 (void)\n       insn_info_t ptr;\n       bb_info_t bb_info = (bb_info_t) pool_alloc (bb_info_pool);\n \n-      memset (bb_info, 0, sizeof (struct bb_info));\n+      memset (bb_info, 0, sizeof (struct dse_bb_info));\n       bitmap_set_bit (all_blocks, bb->index);\n       bb_info->regs_live = regs_live;\n "}, {"sha": "7c629418e6f3d847f740a779f55cccb2fac73e42", "filename": "gcc/gcse.c", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -256,25 +256,25 @@ static struct obstack gcse_obstack;\n \n /* Hash table of expressions.  */\n \n-struct expr\n+struct gcse_expr\n {\n   /* The expression.  */\n   rtx expr;\n   /* Index in the available expression bitmaps.  */\n   int bitmap_index;\n   /* Next entry with the same hash.  */\n-  struct expr *next_same_hash;\n+  struct gcse_expr *next_same_hash;\n   /* List of anticipatable occurrences in basic blocks in the function.\n      An \"anticipatable occurrence\" is one that is the first occurrence in the\n      basic block, the operands are not modified in the basic block prior\n      to the occurrence and the output is not used between the start of\n      the block and the occurrence.  */\n-  struct occr *antic_occr;\n+  struct gcse_occr *antic_occr;\n   /* List of available occurrence in basic blocks in the function.\n      An \"available occurrence\" is one that is the last occurrence in the\n      basic block and the operands are not modified by following statements in\n      the basic block [including this insn].  */\n-  struct occr *avail_occr;\n+  struct gcse_occr *avail_occr;\n   /* Non-null if the computation is PRE redundant.\n      The value is the newly created pseudo-reg to record a copy of the\n      expression in all the places that reach the redundant copy.  */\n@@ -291,10 +291,10 @@ struct expr\n    There is one per basic block.  If a pattern appears more than once the\n    last appearance is used [or first for anticipatable expressions].  */\n \n-struct occr\n+struct gcse_occr\n {\n   /* Next occurrence of this expression.  */\n-  struct occr *next;\n+  struct gcse_occr *next;\n   /* The insn that computes the expression.  */\n   rtx_insn *insn;\n   /* Nonzero if this [anticipatable] occurrence has been deleted.  */\n@@ -306,7 +306,7 @@ struct occr\n   char copied_p;\n };\n \n-typedef struct occr *occr_t;\n+typedef struct gcse_occr *occr_t;\n \n /* Expression hash tables.\n    Each hash table is an array of buckets.\n@@ -317,11 +317,11 @@ typedef struct occr *occr_t;\n    [one could build a mapping table without holes afterwards though].\n    Someday I'll perform the computation and figure it out.  */\n \n-struct hash_table_d\n+struct gcse_hash_table_d\n {\n   /* The table itself.\n      This is an array of `expr_hash_table_size' elements.  */\n-  struct expr **table;\n+  struct gcse_expr **table;\n \n   /* Size of the hash table, in elements.  */\n   unsigned int size;\n@@ -331,7 +331,7 @@ struct hash_table_d\n };\n \n /* Expression hash table.  */\n-static struct hash_table_d expr_hash_table;\n+static struct gcse_hash_table_d expr_hash_table;\n \n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n@@ -344,7 +344,7 @@ static struct hash_table_d expr_hash_table;\n \n struct ls_expr\n {\n-  struct expr * expr;\t\t/* Gcse expression reference for LM.  */\n+  struct gcse_expr * expr;\t/* Gcse expression reference for LM.  */\n   rtx pattern;\t\t\t/* Pattern of this mem.  */\n   rtx pattern_regs;\t\t/* List of registers mentioned by the mem.  */\n   rtx_insn_list *loads;\t\t/* INSN list of loads seen.  */\n@@ -462,38 +462,38 @@ static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n static void *gcse_alloc (unsigned long);\n static void alloc_gcse_mem (void);\n static void free_gcse_mem (void);\n-static void hash_scan_insn (rtx_insn *, struct hash_table_d *);\n-static void hash_scan_set (rtx, rtx_insn *, struct hash_table_d *);\n-static void hash_scan_clobber (rtx, rtx_insn *, struct hash_table_d *);\n-static void hash_scan_call (rtx, rtx_insn *, struct hash_table_d *);\n+static void hash_scan_insn (rtx_insn *, struct gcse_hash_table_d *);\n+static void hash_scan_set (rtx, rtx_insn *, struct gcse_hash_table_d *);\n+static void hash_scan_clobber (rtx, rtx_insn *, struct gcse_hash_table_d *);\n+static void hash_scan_call (rtx, rtx_insn *, struct gcse_hash_table_d *);\n static int want_to_gcse_p (rtx, int *);\n static int oprs_unchanged_p (const_rtx, const rtx_insn *, int);\n static int oprs_anticipatable_p (const_rtx, const rtx_insn *);\n static int oprs_available_p (const_rtx, const rtx_insn *);\n static void insert_expr_in_table (rtx, enum machine_mode, rtx_insn *, int, int,\n-\t\t\t\t  int, struct hash_table_d *);\n+\t\t\t\t  int, struct gcse_hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx_insn *);\n static void record_last_set_info (rtx, const_rtx, void *);\n-static void compute_hash_table (struct hash_table_d *);\n-static void alloc_hash_table (struct hash_table_d *);\n-static void free_hash_table (struct hash_table_d *);\n-static void compute_hash_table_work (struct hash_table_d *);\n-static void dump_hash_table (FILE *, const char *, struct hash_table_d *);\n+static void compute_hash_table (struct gcse_hash_table_d *);\n+static void alloc_hash_table (struct gcse_hash_table_d *);\n+static void free_hash_table (struct gcse_hash_table_d *);\n+static void compute_hash_table_work (struct gcse_hash_table_d *);\n+static void dump_hash_table (FILE *, const char *, struct gcse_hash_table_d *);\n static void compute_transp (const_rtx, int, sbitmap *);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t      struct hash_table_d *);\n+\t\t\t\t      struct gcse_hash_table_d *);\n static void mems_conflict_for_gcse_p (rtx, const_rtx, void *);\n static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n static void canon_list_insert (rtx, const_rtx, void *);\n static void alloc_pre_mem (int, int);\n static void free_pre_mem (void);\n static struct edge_list *compute_pre_data (void);\n-static int pre_expr_reaches_here_p (basic_block, struct expr *,\n+static int pre_expr_reaches_here_p (basic_block, struct gcse_expr *,\n \t\t\t\t    basic_block);\n-static void insert_insn_end_basic_block (struct expr *, basic_block);\n-static void pre_insert_copy_insn (struct expr *, rtx_insn *);\n+static void insert_insn_end_basic_block (struct gcse_expr *, basic_block);\n+static void pre_insert_copy_insn (struct gcse_expr *, rtx_insn *);\n static void pre_insert_copies (void);\n static int pre_delete (void);\n static int pre_gcse (struct edge_list *);\n@@ -503,16 +503,16 @@ static void alloc_code_hoist_mem (int, int);\n static void free_code_hoist_mem (void);\n static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n-static int should_hoist_expr_to_dom (basic_block, struct expr *, basic_block,\n+static int should_hoist_expr_to_dom (basic_block, struct gcse_expr *, basic_block,\n \t\t\t\t     sbitmap, int, int *, enum reg_class,\n \t\t\t\t     int *, bitmap, rtx_insn *);\n static int hoist_code (void);\n static enum reg_class get_regno_pressure_class (int regno, int *nregs);\n static enum reg_class get_pressure_class_and_nregs (rtx_insn *insn, int *nregs);\n static int one_code_hoisting_pass (void);\n-static rtx_insn *process_insert_insn (struct expr *);\n-static int pre_edge_insert (struct edge_list *, struct expr **);\n-static int pre_expr_reaches_here_p_work (basic_block, struct expr *,\n+static rtx_insn *process_insert_insn (struct gcse_expr *);\n+static int pre_edge_insert (struct edge_list *, struct gcse_expr **);\n+static int pre_expr_reaches_here_p_work (basic_block, struct gcse_expr *,\n \t\t\t\t\t basic_block, char *);\n static struct ls_expr * ldst_entry (rtx);\n static void free_ldst_entry (struct ls_expr *);\n@@ -523,7 +523,7 @@ static int simple_mem (const_rtx);\n static void invalidate_any_buried_refs (rtx);\n static void compute_ld_motion_mems (void);\n static void trim_ld_motion_mems (void);\n-static void update_ld_motion_stores (struct expr *);\n+static void update_ld_motion_stores (struct gcse_expr *);\n static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n static rtx gcse_emit_move_after (rtx, rtx, rtx_insn *);\n@@ -679,7 +679,7 @@ free_gcse_mem (void)\n \n static void\n compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n-\t\t\t  struct hash_table_d *table)\n+\t\t\t  struct gcse_hash_table_d *table)\n {\n   unsigned int i;\n \n@@ -696,12 +696,12 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \n   for (i = 0; i < table->size; i++)\n     {\n-      struct expr *expr;\n+      struct gcse_expr *expr;\n \n       for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n \t{\n \t  int indx = expr->bitmap_index;\n-\t  struct occr *occr;\n+\t  struct gcse_occr *occr;\n \n \t  /* The expression is transparent in this block if it is not killed.\n \t     We start by assuming all are transparent [none are killed], and\n@@ -1128,12 +1128,12 @@ expr_equiv_p (const_rtx x, const_rtx y)\n static void\n insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n \t\t      int antic_p,\n-\t\t      int avail_p, int max_distance, struct hash_table_d *table)\n+\t\t      int avail_p, int max_distance, struct gcse_hash_table_d *table)\n {\n   int found, do_not_record_p;\n   unsigned int hash;\n-  struct expr *cur_expr, *last_expr = NULL;\n-  struct occr *antic_occr, *avail_occr;\n+  struct gcse_expr *cur_expr, *last_expr = NULL;\n+  struct gcse_occr *antic_occr, *avail_occr;\n \n   hash = hash_expr (x, mode, &do_not_record_p, table->size);\n \n@@ -1156,8 +1156,8 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n \n   if (! found)\n     {\n-      cur_expr = GOBNEW (struct expr);\n-      bytes_used += sizeof (struct expr);\n+      cur_expr = GOBNEW (struct gcse_expr);\n+      bytes_used += sizeof (struct gcse_expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n \ttable->table[hash] = cur_expr;\n@@ -1194,8 +1194,8 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  antic_occr = GOBNEW (struct occr);\n-\t  bytes_used += sizeof (struct occr);\n+\t  antic_occr = GOBNEW (struct gcse_occr);\n+\t  bytes_used += sizeof (struct gcse_occr);\n \t  antic_occr->insn = insn;\n \t  antic_occr->next = cur_expr->antic_occr;\n \t  antic_occr->deleted_p = 0;\n@@ -1219,8 +1219,8 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  avail_occr = GOBNEW (struct occr);\n-\t  bytes_used += sizeof (struct occr);\n+\t  avail_occr = GOBNEW (struct gcse_occr);\n+\t  bytes_used += sizeof (struct gcse_occr);\n \t  avail_occr->insn = insn;\n \t  avail_occr->next = cur_expr->avail_occr;\n \t  avail_occr->deleted_p = 0;\n@@ -1232,7 +1232,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n /* Scan SET present in INSN and add an entry to the hash TABLE.  */\n \n static void\n-hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table)\n+hash_scan_set (rtx set, rtx_insn *insn, struct gcse_hash_table_d *table)\n {\n   rtx src = SET_SRC (set);\n   rtx dest = SET_DEST (set);\n@@ -1352,22 +1352,22 @@ hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table)\n \n static void\n hash_scan_clobber (rtx x ATTRIBUTE_UNUSED, rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t   struct hash_table_d *table ATTRIBUTE_UNUSED)\n+\t\t   struct gcse_hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n \n static void\n hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\tstruct hash_table_d *table ATTRIBUTE_UNUSED)\n+\t\tstruct gcse_hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n \n /* Process INSN and add hash table entries as appropriate.  */\n \n static void\n-hash_scan_insn (rtx_insn *insn, struct hash_table_d *table)\n+hash_scan_insn (rtx_insn *insn, struct gcse_hash_table_d *table)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -1401,15 +1401,15 @@ hash_scan_insn (rtx_insn *insn, struct hash_table_d *table)\n /* Dump the hash table TABLE to file FILE under the name NAME.  */\n \n static void\n-dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n+dump_hash_table (FILE *file, const char *name, struct gcse_hash_table_d *table)\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n-  struct expr **flat_table;\n+  struct gcse_expr **flat_table;\n   unsigned int *hash_val;\n-  struct expr *expr;\n+  struct gcse_expr *expr;\n \n-  flat_table = XCNEWVEC (struct expr *, table->n_elems);\n+  flat_table = XCNEWVEC (struct gcse_expr *, table->n_elems);\n   hash_val = XNEWVEC (unsigned int, table->n_elems);\n \n   for (i = 0; i < (int) table->size; i++)\n@@ -1553,7 +1553,7 @@ record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n    TABLE is the table computed.  */\n \n static void\n-compute_hash_table_work (struct hash_table_d *table)\n+compute_hash_table_work (struct gcse_hash_table_d *table)\n {\n   int i;\n \n@@ -1605,7 +1605,7 @@ compute_hash_table_work (struct hash_table_d *table)\n    It is used to determine the number of buckets to use.  */\n \n static void\n-alloc_hash_table (struct hash_table_d *table)\n+alloc_hash_table (struct gcse_hash_table_d *table)\n {\n   int n;\n \n@@ -1619,26 +1619,26 @@ alloc_hash_table (struct hash_table_d *table)\n      Making it an odd number is simplest for now.\n      ??? Later take some measurements.  */\n   table->size |= 1;\n-  n = table->size * sizeof (struct expr *);\n-  table->table = GNEWVAR (struct expr *, n);\n+  n = table->size * sizeof (struct gcse_expr *);\n+  table->table = GNEWVAR (struct gcse_expr *, n);\n }\n \n /* Free things allocated by alloc_hash_table.  */\n \n static void\n-free_hash_table (struct hash_table_d *table)\n+free_hash_table (struct gcse_hash_table_d *table)\n {\n   free (table->table);\n }\n \n /* Compute the expression hash table TABLE.  */\n \n static void\n-compute_hash_table (struct hash_table_d *table)\n+compute_hash_table (struct gcse_hash_table_d *table)\n {\n   /* Initialize count of number of entries in hash table.  */\n   table->n_elems = 0;\n-  memset (table->table, 0, table->size * sizeof (struct expr *));\n+  memset (table->table, 0, table->size * sizeof (struct gcse_expr *));\n \n   compute_hash_table_work (table);\n }\n@@ -1864,7 +1864,7 @@ static void\n prune_expressions (bool pre_p)\n {\n   sbitmap prune_exprs;\n-  struct expr *expr;\n+  struct gcse_expr *expr;\n   unsigned int ui;\n   basic_block bb;\n \n@@ -2063,7 +2063,7 @@ compute_pre_data (void)\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n+pre_expr_reaches_here_p_work (basic_block occr_bb, struct gcse_expr *expr,\n \t\t\t      basic_block bb, char *visited)\n {\n   edge pred;\n@@ -2110,7 +2110,7 @@ pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n    memory allocated for that function is returned.  */\n \n static int\n-pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n+pre_expr_reaches_here_p (basic_block occr_bb, struct gcse_expr *expr, basic_block bb)\n {\n   int rval;\n   char *visited = XCNEWVEC (char, last_basic_block_for_fn (cfun));\n@@ -2124,7 +2124,7 @@ pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n /* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */\n \n static rtx_insn *\n-process_insert_insn (struct expr *expr)\n+process_insert_insn (struct gcse_expr *expr)\n {\n   rtx reg = expr->reaching_reg;\n   /* Copy the expression to make sure we don't have any sharing issues.  */\n@@ -2159,7 +2159,7 @@ process_insert_insn (struct expr *expr)\n    This is used by both the PRE and code hoisting.  */\n \n static void\n-insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n+insert_insn_end_basic_block (struct gcse_expr *expr, basic_block bb)\n {\n   rtx_insn *insn = BB_END (bb);\n   rtx_insn *new_insn;\n@@ -2259,7 +2259,7 @@ insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n    the expressions fully redundant.  */\n \n static int\n-pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n+pre_edge_insert (struct edge_list *edge_list, struct gcse_expr **index_map)\n {\n   int e, i, j, num_edges, set_size, did_insert = 0;\n   sbitmap *inserted;\n@@ -2286,8 +2286,8 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \t       j++, insert >>= 1)\n \t    if ((insert & 1) != 0 && index_map[j]->reaching_reg != NULL_RTX)\n \t      {\n-\t\tstruct expr *expr = index_map[j];\n-\t\tstruct occr *occr;\n+\t\tstruct gcse_expr *expr = index_map[j];\n+\t\tstruct gcse_occr *occr;\n \n \t\t/* Now look at each deleted occurrence of this expression.  */\n \t\tfor (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n@@ -2356,7 +2356,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n      MEM          <- reaching_reg.  */\n \n static void\n-pre_insert_copy_insn (struct expr *expr, rtx_insn *insn)\n+pre_insert_copy_insn (struct gcse_expr *expr, rtx_insn *insn)\n {\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -2448,9 +2448,9 @@ static void\n pre_insert_copies (void)\n {\n   unsigned int i, added_copy;\n-  struct expr *expr;\n-  struct occr *occr;\n-  struct occr *avail;\n+  struct gcse_expr *expr;\n+  struct gcse_occr *occr;\n+  struct gcse_occr *avail;\n \n   /* For each available expression in the table, copy the result to\n      `reaching_reg' if the expression reaches a deleted one.\n@@ -2614,8 +2614,8 @@ pre_delete (void)\n {\n   unsigned int i;\n   int changed;\n-  struct expr *expr;\n-  struct occr *occr;\n+  struct gcse_expr *expr;\n+  struct gcse_occr *occr;\n \n   changed = 0;\n   for (i = 0; i < expr_hash_table.size; i++)\n@@ -2687,13 +2687,13 @@ pre_gcse (struct edge_list *edge_list)\n {\n   unsigned int i;\n   int did_insert, changed;\n-  struct expr **index_map;\n-  struct expr *expr;\n+  struct gcse_expr **index_map;\n+  struct gcse_expr *expr;\n \n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n+  index_map = XCNEWVEC (struct gcse_expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -3042,7 +3042,7 @@ update_bb_reg_pressure (basic_block bb, rtx_insn *from)\n    paths.  */\n \n static int\n-should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n+should_hoist_expr_to_dom (basic_block expr_bb, struct gcse_expr *expr,\n \t\t\t  basic_block bb, sbitmap visited, int distance,\n \t\t\t  int *bb_size, enum reg_class pressure_class,\n \t\t\t  int *nregs, bitmap hoisted_bbs, rtx_insn *from)\n@@ -3150,8 +3150,8 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n \f\n /* Find occurrence in BB.  */\n \n-static struct occr *\n-find_occr_in_bb (struct occr *occr, basic_block bb)\n+static struct gcse_occr *\n+find_occr_in_bb (struct gcse_occr *occr, basic_block bb)\n {\n   /* Find the right occurrence of this expression.  */\n   while (occr && BLOCK_FOR_INSN (occr->insn) != bb)\n@@ -3212,8 +3212,8 @@ hoist_code (void)\n   unsigned int dom_tree_walk_index;\n   vec<basic_block> domby;\n   unsigned int i, j, k;\n-  struct expr **index_map;\n-  struct expr *expr;\n+  struct gcse_expr **index_map;\n+  struct gcse_expr *expr;\n   int *to_bb_head;\n   int *bb_size;\n   int changed = 0;\n@@ -3227,7 +3227,7 @@ hoist_code (void)\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = XCNEWVEC (struct expr *, expr_hash_table.n_elems);\n+  index_map = XCNEWVEC (struct gcse_expr *, expr_hash_table.n_elems);\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -3285,7 +3285,7 @@ hoist_code (void)\n \t      int nregs = 0;\n \t      enum reg_class pressure_class = NO_REGS;\n \t      /* Current expression.  */\n-\t      struct expr *expr = index_map[i];\n+\t      struct gcse_expr *expr = index_map[i];\n \t      /* Number of occurrences of EXPR that can be hoisted to BB.  */\n \t      int hoistable = 0;\n \t      /* Occurrences reachable from BB.  */\n@@ -4028,7 +4028,7 @@ trim_ld_motion_mems (void)\n \n   while (ptr != NULL)\n     {\n-      struct expr * expr;\n+      struct gcse_expr * expr;\n \n       /* Delete if entry has been made invalid.  */\n       if (! ptr->invalid)\n@@ -4043,7 +4043,7 @@ trim_ld_motion_mems (void)\n \t      break;\n \t}\n       else\n-\texpr = (struct expr *) 0;\n+\texpr = (struct gcse_expr *) 0;\n \n       if (expr)\n \t{\n@@ -4074,7 +4074,7 @@ trim_ld_motion_mems (void)\n    correct value in the reaching register for the loads.  */\n \n static void\n-update_ld_motion_stores (struct expr * expr)\n+update_ld_motion_stores (struct gcse_expr * expr)\n {\n   struct ls_expr * mem_ptr;\n "}, {"sha": "32440b4f66c6d0664c3431a4c8325571ac5824bd", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -904,7 +904,7 @@ init_ggc_heuristics (void)\n }\n \n /* Datastructure used to store per-call-site statistics.  */\n-struct loc_descriptor\n+struct ggc_loc_descriptor\n {\n   const char *file;\n   int line;\n@@ -918,42 +918,42 @@ struct loc_descriptor\n \n /* Hash table helper.  */\n \n-struct loc_desc_hasher : typed_noop_remove <loc_descriptor>\n+struct ggc_loc_desc_hasher : typed_noop_remove <ggc_loc_descriptor>\n {\n-  typedef loc_descriptor value_type;\n-  typedef loc_descriptor compare_type;\n+  typedef ggc_loc_descriptor value_type;\n+  typedef ggc_loc_descriptor compare_type;\n   static inline hashval_t hash (const value_type *);\n   static inline bool equal (const value_type *, const compare_type *);\n };\n \n inline hashval_t\n-loc_desc_hasher::hash (const value_type *d)\n+ggc_loc_desc_hasher::hash (const value_type *d)\n {\n   return htab_hash_pointer (d->function) | d->line;\n }\n \n inline bool\n-loc_desc_hasher::equal (const value_type *d, const compare_type *d2)\n+ggc_loc_desc_hasher::equal (const value_type *d, const compare_type *d2)\n {\n   return (d->file == d2->file && d->line == d2->line\n \t  && d->function == d2->function);\n }\n \n /* Hashtable used for statistics.  */\n-static hash_table<loc_desc_hasher> *loc_hash;\n+static hash_table<ggc_loc_desc_hasher> *loc_hash;\n \n-struct ptr_hash_entry\n+struct ggc_ptr_hash_entry\n {\n   void *ptr;\n-  struct loc_descriptor *loc;\n+  struct ggc_loc_descriptor *loc;\n   size_t size;\n };\n \n /* Helper for ptr_hash table.  */\n \n-struct ptr_hash_hasher : typed_noop_remove <ptr_hash_entry>\n+struct ptr_hash_hasher : typed_noop_remove <ggc_ptr_hash_entry>\n {\n-  typedef ptr_hash_entry value_type;\n+  typedef ggc_ptr_hash_entry value_type;\n   typedef void compare_type;\n   static inline hashval_t hash (const value_type *);\n   static inline bool equal (const value_type *, const compare_type *);\n@@ -975,22 +975,22 @@ ptr_hash_hasher::equal (const value_type *p, const compare_type *p2)\n static hash_table<ptr_hash_hasher> *ptr_hash;\n \n /* Return descriptor for given call site, create new one if needed.  */\n-static struct loc_descriptor *\n+static struct ggc_loc_descriptor *\n make_loc_descriptor (const char *name, int line, const char *function)\n {\n-  struct loc_descriptor loc;\n-  struct loc_descriptor **slot;\n+  struct ggc_loc_descriptor loc;\n+  struct ggc_loc_descriptor **slot;\n \n   loc.file = name;\n   loc.line = line;\n   loc.function = function;\n   if (!loc_hash)\n-    loc_hash = new hash_table<loc_desc_hasher> (10);\n+    loc_hash = new hash_table<ggc_loc_desc_hasher> (10);\n \n   slot = loc_hash->find_slot (&loc, INSERT);\n   if (*slot)\n     return *slot;\n-  *slot = XCNEW (struct loc_descriptor);\n+  *slot = XCNEW (struct ggc_loc_descriptor);\n   (*slot)->file = name;\n   (*slot)->line = line;\n   (*slot)->function = function;\n@@ -1002,9 +1002,9 @@ void\n ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n \t\t     const char *name, int line, const char *function)\n {\n-  struct loc_descriptor *loc = make_loc_descriptor (name, line, function);\n-  struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n-  ptr_hash_entry **slot;\n+  struct ggc_loc_descriptor *loc = make_loc_descriptor (name, line, function);\n+  struct ggc_ptr_hash_entry *p = XNEW (struct ggc_ptr_hash_entry);\n+  ggc_ptr_hash_entry **slot;\n \n   p->ptr = ptr;\n   p->loc = loc;\n@@ -1023,9 +1023,9 @@ ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n /* Helper function for prune_overhead_list.  See if SLOT is still marked and\n    remove it from hashtable if it is not.  */\n int\n-ggc_prune_ptr (ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n+ggc_prune_ptr (ggc_ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  struct ptr_hash_entry *p = *slot;\n+  struct ggc_ptr_hash_entry *p = *slot;\n   if (!ggc_marked_p (p->ptr))\n     {\n       p->loc->collected += p->size;\n@@ -1047,15 +1047,15 @@ ggc_prune_overhead_list (void)\n void\n ggc_free_overhead (void *ptr)\n {\n-  ptr_hash_entry **slot\n+  ggc_ptr_hash_entry **slot\n     = ptr_hash->find_slot_with_hash (ptr, htab_hash_pointer (ptr), NO_INSERT);\n-  struct ptr_hash_entry *p;\n+  struct ggc_ptr_hash_entry *p;\n   /* The pointer might be not found if a PCH read happened between allocation\n      and ggc_free () call.  FIXME: account memory properly in the presence of\n      PCH. */\n   if (!slot)\n       return;\n-  p = (struct ptr_hash_entry *) *slot;\n+  p = (struct ggc_ptr_hash_entry *) *slot;\n   p->loc->freed += p->size;\n   ptr_hash->clear_slot (slot);\n   free (p);\n@@ -1065,10 +1065,10 @@ ggc_free_overhead (void *ptr)\n static int\n final_cmp_statistic (const void *loc1, const void *loc2)\n {\n-  const struct loc_descriptor *const l1 =\n-    *(const struct loc_descriptor *const *) loc1;\n-  const struct loc_descriptor *const l2 =\n-    *(const struct loc_descriptor *const *) loc2;\n+  const struct ggc_loc_descriptor *const l1 =\n+    *(const struct ggc_loc_descriptor *const *) loc1;\n+  const struct ggc_loc_descriptor *const l2 =\n+    *(const struct ggc_loc_descriptor *const *) loc2;\n   long diff;\n   diff = ((long)(l1->allocated + l1->overhead - l1->freed) -\n \t  (l2->allocated + l2->overhead - l2->freed));\n@@ -1079,10 +1079,10 @@ final_cmp_statistic (const void *loc1, const void *loc2)\n static int\n cmp_statistic (const void *loc1, const void *loc2)\n {\n-  const struct loc_descriptor *const l1 =\n-    *(const struct loc_descriptor *const *) loc1;\n-  const struct loc_descriptor *const l2 =\n-    *(const struct loc_descriptor *const *) loc2;\n+  const struct ggc_loc_descriptor *const l1 =\n+    *(const struct ggc_loc_descriptor *const *) loc1;\n+  const struct ggc_loc_descriptor *const l2 =\n+    *(const struct ggc_loc_descriptor *const *) loc2;\n   long diff;\n \n   diff = ((long)(l1->allocated + l1->overhead - l1->freed - l1->collected) -\n@@ -1095,9 +1095,9 @@ cmp_statistic (const void *loc1, const void *loc2)\n }\n \n /* Collect array of the descriptors from hashtable.  */\n-static struct loc_descriptor **loc_array;\n+static struct ggc_loc_descriptor **loc_array;\n int\n-ggc_add_statistics (loc_descriptor **slot, int *n)\n+ggc_add_statistics (ggc_loc_descriptor **slot, int *n)\n {\n   loc_array[*n] = *slot;\n   (*n)++;\n@@ -1120,7 +1120,7 @@ dump_ggc_loc_statistics (bool final)\n   ggc_force_collect = true;\n   ggc_collect ();\n \n-  loc_array = XCNEWVEC (struct loc_descriptor *,\n+  loc_array = XCNEWVEC (struct ggc_loc_descriptor *,\n \t\t\tloc_hash->elements_with_deleted ());\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n   fprintf (stderr, \"\\n%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n@@ -1131,7 +1131,7 @@ dump_ggc_loc_statistics (bool final)\n \t final ? final_cmp_statistic : cmp_statistic);\n   for (i = 0; i < nentries; i++)\n     {\n-      struct loc_descriptor *d = loc_array[i];\n+      struct ggc_loc_descriptor *d = loc_array[i];\n       allocated += d->allocated;\n       times += d->times;\n       freed += d->freed;\n@@ -1140,7 +1140,7 @@ dump_ggc_loc_statistics (bool final)\n     }\n   for (i = 0; i < nentries; i++)\n     {\n-      struct loc_descriptor *d = loc_array[i];\n+      struct ggc_loc_descriptor *d = loc_array[i];\n       if (d->allocated)\n \t{\n \t  const char *s1 = d->file;"}, {"sha": "85b1ce9f284e0f397ea421929e6f112a79bd3de4", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -378,7 +378,7 @@ struct free_object\n #endif\n \n /* The rest of the global variables.  */\n-static struct globals\n+static struct ggc_globals\n {\n   /* The Nth element in this array is a page with objects of size 2^N.\n      If there are any pages with free objects, they will be at the"}, {"sha": "657536c9c8ee09f30f02dcfa26ffc56bbabba886", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -573,7 +573,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n /* Arrays representing a topological ordering of call graph nodes and a stack\n    of noes used during constant propagation.  */\n \n-struct topo_info\n+struct ipa_topo_info\n {\n   struct cgraph_node **order;\n   struct cgraph_node **stack;\n@@ -583,7 +583,7 @@ struct topo_info\n /* Allocate the arrays in TOPO and topologically sort the nodes into order.  */\n \n static void\n-build_toporder_info (struct topo_info *topo)\n+build_toporder_info (struct ipa_topo_info *topo)\n {\n   topo->order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n@@ -596,7 +596,7 @@ build_toporder_info (struct topo_info *topo)\n    TOPO.  */\n \n static void\n-free_toporder_info (struct topo_info *topo)\n+free_toporder_info (struct ipa_topo_info *topo)\n {\n   ipa_free_postorder_info ();\n   free (topo->order);\n@@ -606,7 +606,7 @@ free_toporder_info (struct topo_info *topo)\n /* Add NODE to the stack in TOPO, unless it is already there.  */\n \n static inline void\n-push_node_to_stack (struct topo_info *topo, struct cgraph_node *node)\n+push_node_to_stack (struct ipa_topo_info *topo, struct cgraph_node *node)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   if (info->node_enqueued)\n@@ -619,7 +619,7 @@ push_node_to_stack (struct topo_info *topo, struct cgraph_node *node)\n    is empty.  */\n \n static struct cgraph_node *\n-pop_node_from_stack (struct topo_info *topo)\n+pop_node_from_stack (struct ipa_topo_info *topo)\n {\n   if (topo->stack_top)\n     {\n@@ -2198,7 +2198,7 @@ add_all_node_vals_to_toposort (struct cgraph_node *node)\n    connected components.  */\n \n static void\n-propagate_constants_topo (struct topo_info *topo)\n+propagate_constants_topo (struct ipa_topo_info *topo)\n {\n   int i;\n \n@@ -2297,7 +2297,7 @@ propagate_effects (void)\n    interprocedurally.  */\n \n static void\n-ipcp_propagate_stage (struct topo_info *topo)\n+ipcp_propagate_stage (struct ipa_topo_info *topo)\n {\n   struct cgraph_node *node;\n \n@@ -3658,7 +3658,7 @@ identify_dead_nodes (struct cgraph_node *node)\n    TOPO and make specialized clones if deemed beneficial.  */\n \n static void\n-ipcp_decision_stage (struct topo_info *topo)\n+ipcp_decision_stage (struct ipa_topo_info *topo)\n {\n   int i;\n \n@@ -3693,7 +3693,7 @@ ipcp_driver (void)\n {\n   struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n   struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-  struct topo_info topo;\n+  struct ipa_topo_info topo;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();"}, {"sha": "d790e4481772ed7f55362109b176ebe4e21ffb14", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -592,7 +592,7 @@ ipa_get_bb_info (struct func_body_info *fbi, basic_block bb)\n /* Structure to be passed in between detect_type_change and\n    check_stmt_for_type_change.  */\n \n-struct type_change_info\n+struct prop_type_change_info\n {\n   /* Offset into the object where there is the virtual method pointer we are\n      looking for.  */\n@@ -680,7 +680,7 @@ stmt_may_be_vtbl_ptr_store (gimple stmt)\n    identified, return the type.  Otherwise return NULL_TREE.  */\n \n static tree\n-extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci)\n+extr_type_from_vtbl_ptr_store (gimple stmt, struct prop_type_change_info *tci)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree lhs, rhs, base, binfo;\n@@ -726,13 +726,13 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci)\n    detect_type_change to check whether a particular statement may modify\n    the virtual table pointer, and if possible also determine the new type of\n    the (sub-)object.  It stores its result into DATA, which points to a\n-   type_change_info structure.  */\n+   prop_type_change_info structure.  */\n \n static bool\n check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n {\n   gimple stmt = SSA_NAME_DEF_STMT (vdef);\n-  struct type_change_info *tci = (struct type_change_info *) data;\n+  struct prop_type_change_info *tci = (struct prop_type_change_info *) data;\n \n   if (stmt_may_be_vtbl_ptr_store (stmt))\n     {\n@@ -830,7 +830,7 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n \t\t\t\t       gimple call, struct ipa_jump_func *jfunc,\n \t\t\t\t       HOST_WIDE_INT offset)\n {\n-  struct type_change_info tci;\n+  struct prop_type_change_info tci;\n   ao_ref ao;\n   bool entry_reached = false;\n "}, {"sha": "f57ce9cae83a619194f3fb83d1544bb431a2df9e", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -117,9 +117,9 @@ typedef struct\n {\n   unsigned int size;\n   unsigned int time;\n-} bb_info;\n+} split_bb_info;\n \n-static vec<bb_info> bb_info_vec;\n+static vec<split_bb_info> bb_info_vec;\n \n /* Description of split point.  */\n "}, {"sha": "8109af84ae0fe45ffb2e817775c48040cf427f33", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -77,7 +77,7 @@ along with GCC; see the file COPYING3.\tIf not see\n \n /* This structure is used to record information about hard register\n    eliminations.  */\n-struct elim_table\n+struct lra_elim_table\n {\n   /* Hard register number to be eliminated.  */\n   int from;\n@@ -105,7 +105,7 @@ struct elim_table\n    of eliminating a register in favor of another.  If there is more\n    than one way of eliminating a particular register, the most\n    preferred should be specified first.\t */\n-static struct elim_table *reg_eliminate = 0;\n+static struct lra_elim_table *reg_eliminate = 0;\n \n /* This is an intermediate structure to initialize the table.  It has\n    exactly the members provided by ELIMINABLE_REGS.  */\n@@ -131,7 +131,7 @@ static const struct elim_table_1\n static void\n print_elim_table (FILE *f)\n {\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     fprintf (f, \"%s eliminate %d to %d (offset=\" HOST_WIDE_INT_PRINT_DEC\n@@ -151,7 +151,7 @@ lra_debug_elim_table (void)\n    VALUE.  Setup FRAME_POINTER_NEEDED if elimination from frame\n    pointer to stack pointer is not possible anymore.  */\n static void\n-setup_can_eliminate (struct elim_table *ep, bool value)\n+setup_can_eliminate (struct lra_elim_table *ep, bool value)\n {\n   ep->can_eliminate = ep->prev_can_eliminate = value;\n   if (! value\n@@ -163,12 +163,12 @@ setup_can_eliminate (struct elim_table *ep, bool value)\n    or NULL if none.  The elimination table may contain more than\n    one elimination for the same hard register, but this map specifies\n    the one that we are currently using.  */\n-static struct elim_table *elimination_map[FIRST_PSEUDO_REGISTER];\n+static struct lra_elim_table *elimination_map[FIRST_PSEUDO_REGISTER];\n \n /* When an eliminable hard register becomes not eliminable, we use the\n    following special structure to restore original offsets for the\n    register.  */\n-static struct elim_table self_elim_table;\n+static struct lra_elim_table self_elim_table;\n \n /* Offsets should be used to restore original offsets for eliminable\n    hard register which just became not eliminable.  Zero,\n@@ -184,7 +184,7 @@ static void\n setup_elimination_map (void)\n {\n   int i;\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     elimination_map[i] = NULL;\n@@ -249,7 +249,7 @@ form_sum (rtx x, rtx y)\n int\n lra_get_elimination_hard_regno (int hard_regno)\n {\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   if (hard_regno < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)\n     return hard_regno;\n@@ -260,11 +260,11 @@ lra_get_elimination_hard_regno (int hard_regno)\n \n /* Return elimination which will be used for hard reg REG, NULL\n    otherwise.  */\n-static struct elim_table *\n+static struct lra_elim_table *\n get_elimination (rtx reg)\n {\n   int hard_regno;\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n   HOST_WIDE_INT offset;\n \n   lra_assert (REG_P (reg));\n@@ -306,7 +306,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, enum machine_mode mem_mode,\n \t\t      bool subst_p, bool update_p, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n   rtx new_rtx;\n   int i, j;\n   const char *fmt;\n@@ -674,7 +674,7 @@ static void\n mark_not_eliminable (rtx x, enum machine_mode mem_mode)\n {\n   enum rtx_code code = GET_CODE (x);\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n   int i, j;\n   const char *fmt;\n \n@@ -856,7 +856,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p)\n   int i;\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n   rtx orig_operand[MAX_RECOG_OPERANDS];\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n   rtx plus_src, plus_cst_src;\n   lra_insn_recog_data_t id;\n   struct lra_static_insn_data *static_id;\n@@ -1130,7 +1130,7 @@ static bool\n update_reg_eliminate (bitmap insns_with_changed_offsets)\n {\n   bool prev, result;\n-  struct elim_table *ep, *ep1;\n+  struct lra_elim_table *ep, *ep1;\n   HARD_REG_SET temp_hard_reg_set;\n \n   /* Clear self elimination offsets.  */\n@@ -1235,14 +1235,14 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n static void\n init_elim_table (void)\n {\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n #ifdef ELIMINABLE_REGS\n   bool value_p;\n   const struct elim_table_1 *ep1;\n #endif\n \n   if (!reg_eliminate)\n-    reg_eliminate = XCNEWVEC (struct elim_table, NUM_ELIMINABLE_REGS);\n+    reg_eliminate = XCNEWVEC (struct lra_elim_table, NUM_ELIMINABLE_REGS);\n \n   memset (self_elim_offsets, 0, sizeof (self_elim_offsets));\n   /* Initiate member values which will be never changed.  */\n@@ -1291,7 +1291,7 @@ init_elimination (void)\n   bool stop_to_sp_elimination_p;\n   basic_block bb;\n   rtx_insn *insn;\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   init_elim_table ();\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -1325,7 +1325,7 @@ void\n lra_eliminate_reg_if_possible (rtx *loc)\n {\n   int regno;\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   lra_assert (REG_P (*loc));\n   if ((regno = REGNO (*loc)) >= FIRST_PSEUDO_REGISTER\n@@ -1369,7 +1369,7 @@ lra_eliminate (bool final_p, bool first_p)\n   unsigned int uid;\n   bitmap_head insns_with_changed_offsets;\n   bitmap_iterator bi;\n-  struct elim_table *ep;\n+  struct lra_elim_table *ep;\n \n   gcc_assert (! final_p || ! first_p);\n "}, {"sha": "56e45d963c061260369f9928685eecc188f3e9ca", "filename": "gcc/predict.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -2496,7 +2496,7 @@ predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n \n-typedef struct block_info_def\n+struct block_info\n {\n   /* Estimated frequency of execution of basic_block.  */\n   sreal frequency;\n@@ -2506,21 +2506,21 @@ typedef struct block_info_def\n \n   /* Number of predecessors we need to visit first.  */\n   int npredecessors;\n-} *block_info;\n+};\n \n /* Similar information for edges.  */\n-typedef struct edge_info_def\n+struct edge_prob_info\n {\n   /* In case edge is a loopback edge, the probability edge will be reached\n      in case header is.  Estimated number of iterations of the loop can be\n      then computed as 1 / (1 - back_edge_prob).  */\n   sreal back_edge_prob;\n   /* True if the edge is a loopback edge in the natural loop.  */\n   unsigned int back_edge:1;\n-} *edge_info;\n+};\n \n-#define BLOCK_INFO(B)\t((block_info) (B)->aux)\n-#define EDGE_INFO(E)\t((edge_info) (E)->aux)\n+#define BLOCK_INFO(B)\t((block_info *) (B)->aux)\n+#define EDGE_INFO(E)\t((edge_prob_info *) (E)->aux)\n \n /* Helper function for estimate_bb_frequencies.\n    Propagate the frequencies in blocks marked in\n@@ -2935,8 +2935,8 @@ estimate_bb_frequencies (bool force)\n \t REG_BR_PROB_BASE;\n \n       /* Set up block info for each basic block.  */\n-      alloc_aux_for_blocks (sizeof (struct block_info_def));\n-      alloc_aux_for_edges (sizeof (struct edge_info_def));\n+      alloc_aux_for_blocks (sizeof (block_info));\n+      alloc_aux_for_edges (sizeof (edge_prob_info));\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n \t  edge e;"}, {"sha": "d5d74f532c128fa8db78534c742d24bd7f5db03b", "filename": "gcc/profile.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define PROFILE_H\n \n /* Additional information about edges. */\n-struct edge_info\n+struct edge_profile_info\n {\n   unsigned int count_valid:1;\n \n@@ -35,7 +35,7 @@ struct edge_info\n   unsigned int ignore:1;\n };\n \n-#define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n+#define EDGE_INFO(e)  ((struct edge_profile_info *) (e)->aux)\n \n /* Smoothes the initial assigned basic block and edge counts using\n    a minimum cost flow algorithm. */"}, {"sha": "f2f3147af365ff85c9732aa3eb35e11d64675c52", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n    This is basically a generic equivalent to the C++ front-end's\n    Named Return Value optimization.  */\n \n-struct nrv_data\n+struct nrv_data_t\n {\n   /* This is the temporary (a VAR_DECL) which appears in all of\n      this function's RETURN_EXPR statements.  */\n@@ -84,7 +84,7 @@ static tree\n finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nrv_data *dp = (struct nrv_data *) wi->info;\n+  struct nrv_data_t *dp = (struct nrv_data_t *) wi->info;\n \n   /* No need to walk into types.  */\n   if (TYPE_P (*tp))\n@@ -150,7 +150,7 @@ pass_nrv::execute (function *fun)\n   tree found = NULL;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n-  struct nrv_data data;\n+  struct nrv_data_t data;\n \n   /* If this function does not return an aggregate type in memory, then\n      there is nothing to do.  */"}, {"sha": "ce23019058d5c57e126ec08e0f5e6e7952915666", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -166,7 +166,7 @@ typedef enum\n   VARYING\n } ccp_lattice_t;\n \n-struct prop_value_d {\n+struct ccp_prop_value_t {\n     /* Lattice value.  */\n     ccp_lattice_t lattice_val;\n \n@@ -180,24 +180,22 @@ struct prop_value_d {\n     widest_int mask;\n };\n \n-typedef struct prop_value_d prop_value_t;\n-\n /* Array of propagated constant values.  After propagation,\n    CONST_VAL[I].VALUE holds the constant value for SSA_NAME(I).  If\n    the constant is held in an SSA name representing a memory store\n    (i.e., a VDEF), CONST_VAL[I].MEM_REF will contain the actual\n    memory reference used to store (i.e., the LHS of the assignment\n    doing the store).  */\n-static prop_value_t *const_val;\n+static ccp_prop_value_t *const_val;\n static unsigned n_const_val;\n \n-static void canonicalize_value (prop_value_t *);\n+static void canonicalize_value (ccp_prop_value_t *);\n static bool ccp_fold_stmt (gimple_stmt_iterator *);\n \n /* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n \n static void\n-dump_lattice_value (FILE *outf, const char *prefix, prop_value_t val)\n+dump_lattice_value (FILE *outf, const char *prefix, ccp_prop_value_t val)\n {\n   switch (val.lattice_val)\n     {\n@@ -236,10 +234,10 @@ dump_lattice_value (FILE *outf, const char *prefix, prop_value_t val)\n \n /* Print lattice value VAL to stderr.  */\n \n-void debug_lattice_value (prop_value_t val);\n+void debug_lattice_value (ccp_prop_value_t val);\n \n DEBUG_FUNCTION void\n-debug_lattice_value (prop_value_t val)\n+debug_lattice_value (ccp_prop_value_t val)\n {\n   dump_lattice_value (stderr, \"\", val);\n   fprintf (stderr, \"\\n\");\n@@ -272,10 +270,10 @@ extend_mask (const wide_int &nonzero_bits)\n    4- Initial values of variables that are not GIMPLE registers are\n       considered VARYING.  */\n \n-static prop_value_t\n+static ccp_prop_value_t\n get_default_value (tree var)\n {\n-  prop_value_t val = { UNINITIALIZED, NULL_TREE, 0 };\n+  ccp_prop_value_t val = { UNINITIALIZED, NULL_TREE, 0 };\n   gimple stmt;\n \n   stmt = SSA_NAME_DEF_STMT (var);\n@@ -343,10 +341,10 @@ get_default_value (tree var)\n \n /* Get the constant value associated with variable VAR.  */\n \n-static inline prop_value_t *\n+static inline ccp_prop_value_t *\n get_value (tree var)\n {\n-  prop_value_t *val;\n+  ccp_prop_value_t *val;\n \n   if (const_val == NULL\n       || SSA_NAME_VERSION (var) >= n_const_val)\n@@ -366,7 +364,7 @@ get_value (tree var)\n static inline tree\n get_constant_value (tree var)\n {\n-  prop_value_t *val;\n+  ccp_prop_value_t *val;\n   if (TREE_CODE (var) != SSA_NAME)\n     {\n       if (is_gimple_min_invariant (var))\n@@ -387,7 +385,7 @@ get_constant_value (tree var)\n static inline void\n set_value_varying (tree var)\n {\n-  prop_value_t *val = &const_val[SSA_NAME_VERSION (var)];\n+  ccp_prop_value_t *val = &const_val[SSA_NAME_VERSION (var)];\n \n   val->lattice_val = VARYING;\n   val->value = NULL_TREE;\n@@ -413,7 +411,7 @@ set_value_varying (tree var)\n   For other constants, make sure to drop TREE_OVERFLOW.  */\n \n static void\n-canonicalize_value (prop_value_t *val)\n+canonicalize_value (ccp_prop_value_t *val)\n {\n   enum machine_mode mode;\n   tree type;\n@@ -451,7 +449,7 @@ canonicalize_value (prop_value_t *val)\n /* Return whether the lattice transition is valid.  */\n \n static bool\n-valid_lattice_transition (prop_value_t old_val, prop_value_t new_val)\n+valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n {\n   /* Lattice transitions must always be monotonically increasing in\n      value.  */\n@@ -486,10 +484,10 @@ valid_lattice_transition (prop_value_t old_val, prop_value_t new_val)\n    value is different from VAR's previous value.  */\n \n static bool\n-set_lattice_value (tree var, prop_value_t new_val)\n+set_lattice_value (tree var, ccp_prop_value_t new_val)\n {\n   /* We can deal with old UNINITIALIZED values just fine here.  */\n-  prop_value_t *old_val = &const_val[SSA_NAME_VERSION (var)];\n+  ccp_prop_value_t *old_val = &const_val[SSA_NAME_VERSION (var)];\n \n   canonicalize_value (&new_val);\n \n@@ -534,8 +532,8 @@ set_lattice_value (tree var, prop_value_t new_val)\n   return false;\n }\n \n-static prop_value_t get_value_for_expr (tree, bool);\n-static prop_value_t bit_value_binop (enum tree_code, tree, tree, tree);\n+static ccp_prop_value_t get_value_for_expr (tree, bool);\n+static ccp_prop_value_t bit_value_binop (enum tree_code, tree, tree, tree);\n static void bit_value_binop_1 (enum tree_code, tree, widest_int *, widest_int *,\n \t\t\t       tree, const widest_int &, const widest_int &,\n \t\t\t       tree, const widest_int &, const widest_int &);\n@@ -544,7 +542,7 @@ static void bit_value_binop_1 (enum tree_code, tree, widest_int *, widest_int *,\n    from VAL.  */\n \n static widest_int\n-value_to_wide_int (prop_value_t val)\n+value_to_wide_int (ccp_prop_value_t val)\n {\n   if (val.value\n       && TREE_CODE (val.value) == INTEGER_CST)\n@@ -556,11 +554,11 @@ value_to_wide_int (prop_value_t val)\n /* Return the value for the address expression EXPR based on alignment\n    information.  */\n \n-static prop_value_t\n+static ccp_prop_value_t\n get_value_from_alignment (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n   unsigned HOST_WIDE_INT bitpos;\n   unsigned int align;\n \n@@ -583,10 +581,10 @@ get_value_from_alignment (tree expr)\n    return constant bits extracted from alignment information for\n    invariant addresses.  */\n \n-static prop_value_t\n+static ccp_prop_value_t\n get_value_for_expr (tree expr, bool for_bits_p)\n {\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n \n   if (TREE_CODE (expr) == SSA_NAME)\n     {\n@@ -654,7 +652,7 @@ likely_value (gimple stmt)\n   all_undefined_operands = true;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      prop_value_t *val = get_value (use);\n+      ccp_prop_value_t *val = get_value (use);\n \n       if (val->lattice_val == UNDEFINED)\n \thas_undefined_operand = true;\n@@ -792,7 +790,7 @@ ccp_initialize (void)\n   basic_block bb;\n \n   n_const_val = num_ssa_names;\n-  const_val = XCNEWVEC (prop_value_t, n_const_val);\n+  const_val = XCNEWVEC (ccp_prop_value_t, n_const_val);\n \n   /* Initialize simulation flags for PHI nodes and statements.  */\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -884,7 +882,7 @@ ccp_finalize (void)\n   for (i = 1; i < num_ssa_names; ++i)\n     {\n       tree name = ssa_name (i);\n-      prop_value_t *val;\n+      ccp_prop_value_t *val;\n       unsigned int tem, align;\n \n       if (!name\n@@ -941,7 +939,7 @@ ccp_finalize (void)\n    */\n \n static void\n-ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n+ccp_lattice_meet (ccp_prop_value_t *val1, ccp_prop_value_t *val2)\n {\n   if (val1->lattice_val == UNDEFINED)\n     {\n@@ -997,7 +995,7 @@ ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n     {\n       /* When not equal addresses are involved try meeting for\n \t alignment.  */\n-      prop_value_t tem = *val2;\n+      ccp_prop_value_t tem = *val2;\n       if (TREE_CODE (val1->value) == ADDR_EXPR)\n \t*val1 = get_value_for_expr (val1->value, true);\n       if (TREE_CODE (val2->value) == ADDR_EXPR)\n@@ -1023,7 +1021,7 @@ static enum ssa_prop_result\n ccp_visit_phi_node (gimple phi)\n {\n   unsigned i;\n-  prop_value_t *old_val, new_val;\n+  ccp_prop_value_t *old_val, new_val;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1069,7 +1067,7 @@ ccp_visit_phi_node (gimple phi)\n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n \t  tree arg = gimple_phi_arg (phi, i)->def;\n-\t  prop_value_t arg_val = get_value_for_expr (arg, false);\n+\t  ccp_prop_value_t arg_val = get_value_for_expr (arg, false);\n \n \t  ccp_lattice_meet (&new_val, &arg_val);\n \n@@ -1449,12 +1447,12 @@ bit_value_binop_1 (enum tree_code code, tree type,\n /* Return the propagation value when applying the operation CODE to\n    the value RHS yielding type TYPE.  */\n \n-static prop_value_t\n+static ccp_prop_value_t\n bit_value_unop (enum tree_code code, tree type, tree rhs)\n {\n-  prop_value_t rval = get_value_for_expr (rhs, true);\n+  ccp_prop_value_t rval = get_value_for_expr (rhs, true);\n   widest_int value, mask;\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n \n   if (rval.lattice_val == UNDEFINED)\n     return rval;\n@@ -1483,13 +1481,13 @@ bit_value_unop (enum tree_code code, tree type, tree rhs)\n /* Return the propagation value when applying the operation CODE to\n    the values RHS1 and RHS2 yielding type TYPE.  */\n \n-static prop_value_t\n+static ccp_prop_value_t\n bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n {\n-  prop_value_t r1val = get_value_for_expr (rhs1, true);\n-  prop_value_t r2val = get_value_for_expr (rhs2, true);\n+  ccp_prop_value_t r1val = get_value_for_expr (rhs1, true);\n+  ccp_prop_value_t r2val = get_value_for_expr (rhs2, true);\n   widest_int value, mask;\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n \n   if (r1val.lattice_val == UNDEFINED\n       || r2val.lattice_val == UNDEFINED)\n@@ -1532,15 +1530,15 @@ bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n    is false, for alloc_aligned attribute ATTR is non-NULL and\n    ALLOC_ALIGNED is true.  */\n \n-static prop_value_t\n-bit_value_assume_aligned (gimple stmt, tree attr, prop_value_t ptrval,\n+static ccp_prop_value_t\n+bit_value_assume_aligned (gimple stmt, tree attr, ccp_prop_value_t ptrval,\n \t\t\t  bool alloc_aligned)\n {\n   tree align, misalign = NULL_TREE, type;\n   unsigned HOST_WIDE_INT aligni, misaligni = 0;\n-  prop_value_t alignval;\n+  ccp_prop_value_t alignval;\n   widest_int value, mask;\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n \n   if (attr == NULL_TREE)\n     {\n@@ -1632,10 +1630,10 @@ bit_value_assume_aligned (gimple stmt, tree attr, prop_value_t ptrval,\n /* Evaluate statement STMT.\n    Valid only for assignments, calls, conditionals, and switches. */\n \n-static prop_value_t\n+static ccp_prop_value_t\n evaluate_stmt (gimple stmt)\n {\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n   tree simplified = NULL_TREE;\n   ccp_lattice_t likelyvalue = likely_value (stmt);\n   bool is_constant = false;\n@@ -2062,7 +2060,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n     {\n     case GIMPLE_COND:\n       {\n-\tprop_value_t val;\n+\tccp_prop_value_t val;\n \t/* Statement evaluation will handle type mismatches in constants\n \t   more gracefully than the final propagation.  This allows us to\n \t   fold more conditionals here.  */\n@@ -2197,7 +2195,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n static enum ssa_prop_result\n visit_assignment (gimple stmt, tree *output_p)\n {\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n   enum ssa_prop_result retval;\n \n   tree lhs = gimple_get_lhs (stmt);\n@@ -2242,7 +2240,7 @@ visit_assignment (gimple stmt, tree *output_p)\n static enum ssa_prop_result\n visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n {\n-  prop_value_t val;\n+  ccp_prop_value_t val;\n   basic_block block;\n \n   block = gimple_bb (stmt);\n@@ -2320,7 +2318,7 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n      Mark them VARYING.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      prop_value_t v = { VARYING, NULL_TREE, -1 };\n+      ccp_prop_value_t v = { VARYING, NULL_TREE, -1 };\n       set_lattice_value (def, v);\n     }\n "}, {"sha": "3bbbb67ce085fb070b8d3255d19293dee6b91890", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114783066e5d1046dfe83bb987008f4c2729e8f6/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=114783066e5d1046dfe83bb987008f4c2729e8f6", "patch": "@@ -76,11 +76,10 @@ along with GCC; see the file COPYING3.  If not see\n    When visiting a statement or PHI node the lattice value for an\n    SSA name can transition from UNDEFINED to COPY to VARYING.  */\n \n-struct prop_value_d {\n+struct prop_value_t {\n     /* Copy-of value.  */\n     tree value;\n };\n-typedef struct prop_value_d prop_value_t;\n \n static prop_value_t *copy_of;\n static unsigned n_copy_of;"}]}