{"sha": "498b529f119b92d970cfa2ad781611338ee405c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4YjUyOWYxMTliOTJkOTcwY2ZhMmFkNzgxNjExMzM4ZWU0MDVjMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-07T16:35:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-07T16:35:25Z"}, "message": "(convert_memory_address): No longer static.\n\nNew arg, TO_MODE.\nDo something special for SYMBOL_REF, LABEL_REF, and CONST.\n(memory_address): Add extra arg to call to convert_memory_address.\n\nFrom-SVN: r9328", "tree": {"sha": "2555f7631dc8f2c8423d9ea237481fdf1444f4d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2555f7631dc8f2c8423d9ea237481fdf1444f4d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/498b529f119b92d970cfa2ad781611338ee405c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498b529f119b92d970cfa2ad781611338ee405c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498b529f119b92d970cfa2ad781611338ee405c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498b529f119b92d970cfa2ad781611338ee405c1/comments", "author": null, "committer": null, "parents": [{"sha": "0aac88f627d0c52b0db0eed139fcffd940f73f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aac88f627d0c52b0db0eed139fcffd940f73f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aac88f627d0c52b0db0eed139fcffd940f73f90"}], "stats": {"total": 40, "additions": 27, "deletions": 13}, "files": [{"sha": "52cb0e963daaf8cba79ef77dc083ea1fe03b4a99", "filename": "gcc/explow.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498b529f119b92d970cfa2ad781611338ee405c1/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498b529f119b92d970cfa2ad781611338ee405c1/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=498b529f119b92d970cfa2ad781611338ee405c1", "patch": "@@ -30,7 +30,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-codes.h\"\n \n static rtx break_out_memory_refs\tPROTO((rtx));\n-static rtx convert_memory_address\tPROTO((rtx));\n \n /* Return an rtx for the sum of X and the integer C.\n \n@@ -294,31 +293,46 @@ break_out_memory_refs (x)\n #ifdef POINTERS_EXTEND_UNSIGNED\n \n /* Given X, a memory address in ptr_mode, convert it to an address\n-   in Pmode.  We take advantage of the fact that pointers are not\n-   allowed to overflow by commuting arithmetic operations over\n-   conversions so that address arithmetic insns can be used.  */\n+   in Pmode, or vice versa (TO_MODE says which way).  We take advantage of\n+   the fact that pointers are not allowed to overflow by commuting arithmetic\n+   operations over conversions so that address arithmetic insns can be\n+   used.  */\n \n-static rtx\n-convert_memory_address (x)\n+rtx\n+convert_memory_address (to_mode, x)\n+     enum machine_mode to_mode;\n      rtx x;\n {\n+  rtx temp;\n+\n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+      return x;\n+\n     case LABEL_REF:\n+      return gen_rtx (LABEL_REF, to_mode, XEXP (x, 0));\n+\n     case SYMBOL_REF:\n-    case CONST:\n-      return x;\n+      temp = gen_rtx (SYMBOL_REF, to_mode, XSTR (x, 0));\n+      SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n+      return temp;\n \n     case PLUS:\n     case MULT:\n-      return gen_rtx (GET_CODE (x), Pmode, \n-\t\t      convert_memory_address (XEXP (x, 0)),\n-\t\t      convert_memory_address (XEXP (x, 1)));\n+      return gen_rtx (GET_CODE (x), to_mode, \n+\t\t      convert_memory_address (to_mode, XEXP (x, 0)),\n+\t\t      convert_memory_address (to_mode, XEXP (x, 1)));\n+\n+    case CONST:\n+      return gen_rtx (CONST, to_mode, \n+\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n \n     default:\n-      return convert_modes (Pmode, ptr_mode, x, POINTERS_EXTEND_UNSIGNED);\n+      return convert_modes (to_mode,\n+\t\t\t    to_mode == ptr_mode ? Pmode : ptr_mode,\n+\t\t\t    x, POINTERS_EXTEND_UNSIGNED);\n     }\n }\n #endif\n@@ -375,7 +389,7 @@ memory_address (mode, x)\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n   if (GET_MODE (x) == ptr_mode)\n-    x = convert_memory_address (x);\n+    x = convert_memory_address (Pmode, x);\n #endif\n \n   /* By passing constant addresses thru registers"}]}