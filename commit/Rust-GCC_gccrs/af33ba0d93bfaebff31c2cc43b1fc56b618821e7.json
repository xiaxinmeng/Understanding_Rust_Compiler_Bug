{"sha": "af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYzM2JhMGQ5M2JmYWViZmYzMWMyY2M0M2IxZmM1NmI2MTg4MjFlNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-01-19T21:08:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-01-19T21:08:10Z"}, "message": "dwarf2out.c (need_endianity_attribute_p): New inline predicate.\n\n\t* dwarf2out.c (need_endianity_attribute_p): New inline predicate.\n\t(base_type_die): Add REVERSE parameter and attach DW_AT_endianity to\n\tthe DIE accordingly.\n\t(modified_type_die): Add REVERSE parameter and pass it recursively,\n\tas well as to base_type_die.  Adjust presence check accordingly.\n\t(base_type_for_mode): Adjust call to modified_type_die.\n\t(add_type_attribute): Add REVERSE parameter and pass it to\n\tmodified_type_die.\n\t(generic_parameter_die): Adjust call to add_type_attribute.\n\t(add_scalar_info): Likewise.\n\t(add_subscript_info): Likewise.\n\t(gen_array_type_die): Likewise.\n\t(gen_descr_array_type_die): Likewise.\n\t(gen_entry_point_die): Likewise.\n\t(gen_enumeration_type_die): Likewise.\n\t(gen_formal_parameter_die): Likewise.\n\t(gen_subprogram_die): Likewise.\n\t(gen_variable_die ): Likewise.\n\t(gen_const_die): Likewise.\n\t(gen_field_die): Likewise.\n\t(gen_pointer_type_die): Likewise.\n\t(gen_reference_type_die): Likewise.\n\t(gen_ptr_to_mbr_type_die): Likewise.\n\t(gen_inheritance_die): Likewise.\n\t(gen_subroutine_type_die): Likewise.\n\t(gen_typedef_die): Likewise.\n\t(force_type_die): Adjust call to modified_type_die.\n\nFrom-SVN: r232585", "tree": {"sha": "80338c1a757e21314511694dbd70213172256226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80338c1a757e21314511694dbd70213172256226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/comments", "author": null, "committer": null, "parents": [{"sha": "d0899488d970a3ade7fbe329964cf03c7b593eb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0899488d970a3ade7fbe329964cf03c7b593eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0899488d970a3ade7fbe329964cf03c7b593eb5"}], "stats": {"total": 185, "additions": 139, "deletions": 46}, "files": [{"sha": "e947d1ddd15b1ece65dd137f4bfe05e8e333c58b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "patch": "@@ -1,3 +1,33 @@\n+2016-01-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (need_endianity_attribute_p): New inline predicate.\n+\t(base_type_die): Add REVERSE parameter and attach DW_AT_endianity to\n+\tthe DIE accordingly.\n+\t(modified_type_die): Add REVERSE parameter and pass it recursively,\n+\tas well as to base_type_die.  Adjust presence check accordingly.\n+\t(base_type_for_mode): Adjust call to modified_type_die.\n+\t(add_type_attribute): Add REVERSE parameter and pass it to\n+\tmodified_type_die.\n+\t(generic_parameter_die): Adjust call to add_type_attribute.\n+\t(add_scalar_info): Likewise.\n+\t(add_subscript_info): Likewise.\n+\t(gen_array_type_die): Likewise.\n+\t(gen_descr_array_type_die): Likewise.\n+\t(gen_entry_point_die): Likewise.\n+\t(gen_enumeration_type_die): Likewise.\n+\t(gen_formal_parameter_die): Likewise.\n+\t(gen_subprogram_die): Likewise.\n+\t(gen_variable_die ): Likewise.\n+\t(gen_const_die): Likewise.\n+\t(gen_field_die): Likewise.\n+\t(gen_pointer_type_die): Likewise.\n+\t(gen_reference_type_die): Likewise.\n+\t(gen_ptr_to_mbr_type_die): Likewise.\n+\t(gen_inheritance_die): Likewise.\n+\t(gen_subroutine_type_die): Likewise.\n+\t(gen_typedef_die): Likewise.\n+\t(force_type_die): Adjust call to modified_type_die.\n+\n 2016-01-19  Sandra Loosemore <sandra@codesourcery.com>\n \n \t* doc/standards.texi: Copy-editing for grammar, markup, and sentence"}, {"sha": "de546df1e75b923692e2399fb4d464d7a16a78ad", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "patch": "@@ -3286,11 +3286,11 @@ static void output_ranges (void);\n static dw_line_info_table *new_line_info_table (void);\n static void output_line_info (bool);\n static void output_file_names (void);\n-static dw_die_ref base_type_die (tree);\n+static dw_die_ref base_type_die (tree, bool);\n static int is_base_type (tree);\n static dw_die_ref subrange_type_die (tree, tree, tree, tree, dw_die_ref);\n static int decl_quals (const_tree);\n-static dw_die_ref modified_type_die (tree, int, dw_die_ref);\n+static dw_die_ref modified_type_die (tree, int, bool, dw_die_ref);\n static dw_die_ref generic_parameter_die (tree, tree, bool, dw_die_ref);\n static dw_die_ref template_parameter_pack_die (tree, tree, dw_die_ref);\n static int type_is_enum (const_tree);\n@@ -3362,7 +3362,7 @@ static dw_die_ref scope_die_for (tree, dw_die_ref);\n static inline int local_scope_p (dw_die_ref);\n static inline int class_scope_p (dw_die_ref);\n static inline int class_or_namespace_scope_p (dw_die_ref);\n-static void add_type_attribute (dw_die_ref, tree, int, dw_die_ref);\n+static void add_type_attribute (dw_die_ref, tree, int, bool, dw_die_ref);\n static void add_calling_convention_attribute (dw_die_ref, tree);\n static const char *type_tag (const_tree);\n static tree member_declared_type (const_tree);\n@@ -10796,14 +10796,23 @@ output_line_info (bool prologue_only)\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n }\n \f\n+/* Return true if DW_AT_endianity should be emitted according to REVERSE.  */\n+\n+static inline bool\n+need_endianity_attribute_p (bool reverse)\n+{\n+  return reverse && (dwarf_version >= 3 || !dwarf_strict);\n+}\n+\n /* Given a pointer to a tree node for some base type, return a pointer to\n-   a DIE that describes the given type.\n+   a DIE that describes the given type.  REVERSE is true if the type is\n+   to be interpreted in the reverse storage order wrt the target order.\n \n    This routine must only be called for GCC type nodes that correspond to\n    Dwarf base (fundamental) types.  */\n \n static dw_die_ref\n-base_type_die (tree type)\n+base_type_die (tree type, bool reverse)\n {\n   dw_die_ref base_type_result;\n   enum dwarf_type encoding;\n@@ -10912,6 +10921,10 @@ base_type_die (tree type)\n \t\t   int_size_in_bytes (type));\n   add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);\n \n+  if (need_endianity_attribute_p (reverse))\n+    add_AT_unsigned (base_type_result, DW_AT_endianity,\n+\t\t     BYTES_BIG_ENDIAN ? DW_END_little : DW_END_big);\n+\n   if (fpt_used)\n     {\n       switch (fpt_info.scale_factor_kind)\n@@ -10948,12 +10961,14 @@ base_type_die (tree type)\n \t  gcc_unreachable ();\n \t}\n     }\n-  if (type_bias != NULL)\n+\n+  if (type_bias)\n     add_scalar_info (base_type_result, DW_AT_GNU_bias, type_bias,\n \t\t     dw_scalar_form_constant\n \t\t     | dw_scalar_form_exprloc\n \t\t     | dw_scalar_form_reference,\n \t\t     NULL);\n+\n   add_pubtype (type, base_type_result);\n \n   return base_type_result;\n@@ -11135,10 +11150,13 @@ get_nearest_type_subqualifiers (tree type, int type_quals, int qual_mask)\n }\n \n /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging\n-   entry that chains various modifiers in front of the given type.  */\n+   entry that chains the modifiers specified by CV_QUALS in front of the\n+   given type.  REVERSE is true if the type is to be interpreted in the\n+   reverse storage order wrt the target order.  */\n \n static dw_die_ref\n-modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n+modified_type_die (tree type, int cv_quals, bool reverse,\n+\t\t   dw_die_ref context_die)\n {\n   enum tree_code code = TREE_CODE (type);\n   dw_die_ref mod_type_die;\n@@ -11159,7 +11177,7 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n       tree debug_type = lang_hooks.types.get_debug_type (type);\n \n       if (debug_type != NULL_TREE && debug_type != type)\n-\treturn modified_type_die (debug_type, cv_quals, context_die);\n+\treturn modified_type_die (debug_type, cv_quals, reverse, context_die);\n     }\n \n   cv_quals &= cv_qual_mask;\n@@ -11196,7 +11214,12 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n   if (qualified_type)\n     {\n       mod_type_die = lookup_type_die (qualified_type);\n-      if (mod_type_die)\n+\n+      /* DW_AT_endianity doesn't come from a qualifier on the type.  */\n+      if (mod_type_die\n+\t  && (!need_endianity_attribute_p (reverse)\n+\t      || !is_base_type (type)\n+\t      || get_AT_unsigned (mod_type_die, DW_AT_endianity)))\n \treturn mod_type_die;\n     }\n \n@@ -11222,8 +11245,8 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n \t      || (cv_quals == dquals && DECL_ORIGINAL_TYPE (name) != type))\n \t    /* cv-unqualified version of named type.  Just use\n \t       the unnamed type to which it refers.  */\n-\t    return modified_type_die (DECL_ORIGINAL_TYPE (name),\n-\t\t\t\t      cv_quals, context_die);\n+\t    return modified_type_die (DECL_ORIGINAL_TYPE (name), cv_quals,\n+\t\t\t\t      reverse, context_die);\n \t  /* Else cv-qualified version of named type; fall through.  */\n \t}\n     }\n@@ -11248,7 +11271,7 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n \t qualifiers.  */\n       sub_quals = get_nearest_type_subqualifiers (type, cv_quals,\n \t\t\t\t\t\t  cv_qual_mask);\n-      mod_type_die = modified_type_die (type, sub_quals, context_die);\n+      mod_type_die = modified_type_die (type, sub_quals, reverse, context_die);\n \n       for (i = 0; i < sizeof (qual_info) / sizeof (qual_info[0]); i++)\n \tif (qual_info[i].q & cv_quals & ~sub_quals)\n@@ -11304,7 +11327,7 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n       item_type = TREE_TYPE (type);\n     }\n   else if (is_base_type (type))\n-    mod_type_die = base_type_die (type);\n+    mod_type_die = base_type_die (type, reverse);\n   else\n     {\n       gen_type_die (type, context_die);\n@@ -11361,6 +11384,7 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n        types are possible in Ada.  */\n     sub_die = modified_type_die (item_type,\n \t\t\t\t TYPE_QUALS_NO_ADDR_SPACE (item_type),\n+\t\t\t\t reverse,\n \t\t\t\t context_die);\n \n   if (sub_die != NULL)\n@@ -11505,7 +11529,7 @@ generic_parameter_die (tree parm, tree arg,\n \t  add_type_attribute (tmpl_die, tmpl_type,\n \t\t\t      (TREE_THIS_VOLATILE (tmpl_type)\n \t\t\t       ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED),\n-\t\t\t      parent_die);\n+\t\t\t      false, parent_die);\n \t}\n       else\n \t{\n@@ -12392,7 +12416,8 @@ base_type_for_mode (machine_mode mode, bool unsignedp)\n     }\n   type_die = lookup_type_die (type);\n   if (!type_die)\n-    type_die = modified_type_die (type, TYPE_UNQUALIFIED, comp_unit_die ());\n+    type_die = modified_type_die (type, TYPE_UNQUALIFIED, false,\n+\t\t\t\t  comp_unit_die ());\n   if (type_die == NULL || type_die->die_tag != DW_TAG_base_type)\n     return NULL;\n   return type_die;\n@@ -17995,7 +18020,7 @@ static void\n add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n \t\t int forms, const struct loc_descr_context *context)\n {\n-  dw_die_ref ctx, decl_die;\n+  dw_die_ref context_die, decl_die;\n   dw_loc_list_ref list;\n \n   bool strip_conversions = true;\n@@ -18112,13 +18137,14 @@ add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n     return;\n \n   if (current_function_decl == 0)\n-    ctx = comp_unit_die ();\n+    context_die = comp_unit_die ();\n   else\n-    ctx = lookup_decl_die (current_function_decl);\n+    context_die = lookup_decl_die (current_function_decl);\n \n-  decl_die = new_die (DW_TAG_variable, ctx, value);\n+  decl_die = new_die (DW_TAG_variable, context_die, value);\n   add_AT_flag (decl_die, DW_AT_artificial, 1);\n-  add_type_attribute (decl_die, TREE_TYPE (value), TYPE_QUAL_CONST, ctx);\n+  add_type_attribute (decl_die, TREE_TYPE (value), TYPE_QUAL_CONST, false,\n+\t\t      context_die);\n   add_AT_location_description (decl_die, DW_AT_location, list);\n   add_AT_die_ref (die, attr, decl_die);\n }\n@@ -18292,7 +18318,7 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n \t\t;\n \t      else\n \t\tadd_type_attribute (subrange_die, TREE_TYPE (domain),\n-\t\t\t\t    TYPE_UNQUALIFIED, type_die);\n+\t\t\t\t    TYPE_UNQUALIFIED, false, type_die);\n \t    }\n \n \t  /* ??? If upper is NULL, the array has unspecified length,\n@@ -18856,7 +18882,7 @@ class_or_namespace_scope_p (dw_die_ref context_die)\n \n static void\n add_type_attribute (dw_die_ref object_die, tree type, int cv_quals,\n-\t\t    dw_die_ref context_die)\n+\t\t    bool reverse, dw_die_ref context_die)\n {\n   enum tree_code code  = TREE_CODE (type);\n   dw_die_ref type_die  = NULL;\n@@ -18878,6 +18904,7 @@ add_type_attribute (dw_die_ref object_die, tree type, int cv_quals,\n \n   type_die = modified_type_die (type,\n \t\t\t\tcv_quals | TYPE_QUALS_NO_ADDR_SPACE (type),\n+\t\t\t\treverse,\n \t\t\t\tcontext_die);\n \n   if (type_die != NULL)\n@@ -19114,7 +19141,10 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \telement_type = TREE_TYPE (element_type);\n       }\n \n-  add_type_attribute (array_die, element_type, TYPE_UNQUALIFIED, context_die);\n+  add_type_attribute (array_die, element_type, TYPE_UNQUALIFIED,\n+\t\t      TREE_CODE (type) == ARRAY_TYPE\n+\t\t      && TYPE_REVERSE_STORAGE_ORDER (type),\n+\t\t      context_die);\n \n   add_gnat_descriptive_type_attribute (array_die, type, context_die);\n   if (TYPE_ARTIFICIAL (type))\n@@ -19191,8 +19221,8 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n \n       if (info->dimen[dim].bounds_type)\n \tadd_type_attribute (subrange_die,\n-\t\t\t    info->dimen[dim].bounds_type, 0,\n-\t\t\t    context_die);\n+\t\t\t    info->dimen[dim].bounds_type, TYPE_UNQUALIFIED,\n+\t\t\t    false, context_die);\n       if (info->dimen[dim].lower_bound)\n \tadd_bound_info (subrange_die, DW_AT_lower_bound,\n \t\t\tinfo->dimen[dim].lower_bound, &context);\n@@ -19210,6 +19240,8 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n \n   gen_type_die (info->element_type, context_die);\n   add_type_attribute (array_die, info->element_type, TYPE_UNQUALIFIED,\n+\t\t      TREE_CODE (type) == ARRAY_TYPE\n+\t\t      && TYPE_REVERSE_STORAGE_ORDER (type),\n \t\t      context_die);\n \n   if (get_AT (array_die, DW_AT_name))\n@@ -19229,7 +19261,7 @@ gen_entry_point_die (tree decl, dw_die_ref context_die)\n     {\n       add_name_and_src_coords_attributes (decl_die, decl);\n       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t  TYPE_UNQUALIFIED, context_die);\n+\t\t\t  TYPE_UNQUALIFIED, false, context_die);\n     }\n \n   if (DECL_ABSTRACT_P (decl))\n@@ -19319,7 +19351,7 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n       if (dwarf_version >= 3 || !dwarf_strict)\n \t{\n \t  tree underlying = lang_hooks.types.enum_underlying_base_type (type);\n-\t  add_type_attribute (type_die, underlying, TYPE_UNQUALIFIED,\n+\t  add_type_attribute (type_die, underlying, TYPE_UNQUALIFIED, false,\n \t\t\t      context_die);\n \t}\n       if (TYPE_STUB_DECL (type) != NULL_TREE)\n@@ -19485,11 +19517,12 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \t  tree type = TREE_TYPE (node_or_origin);\n \t  if (decl_by_reference_p (node_or_origin))\n \t    add_type_attribute (parm_die, TREE_TYPE (type),\n-\t\t\t\tTYPE_UNQUALIFIED, context_die);\n+\t\t\t\tTYPE_UNQUALIFIED,\n+\t\t\t\tfalse, context_die);\n \t  else\n \t    add_type_attribute (parm_die, type,\n \t\t\t\tdecl_quals (node_or_origin),\n-\t\t\t\tcontext_die);\n+\t\t\t\tfalse, context_die);\n \t}\n       if (origin == NULL && DECL_ARTIFICIAL (node))\n \tadd_AT_flag (parm_die, DW_AT_artificial, 1);\n@@ -19504,7 +19537,7 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \n     case tcc_type:\n       /* We were called with some kind of a ..._TYPE node.  */\n-      add_type_attribute (parm_die, node_or_origin, TYPE_UNQUALIFIED,\n+      add_type_attribute (parm_die, node_or_origin, TYPE_UNQUALIFIED, false,\n \t\t\t  context_die);\n       break;\n \n@@ -20229,7 +20262,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t      dw_die_ref die = get_AT_ref (old_die, DW_AT_type);\n \t      if (die == auto_die || die == decltype_auto_die)\n \t\tadd_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t\t    TYPE_UNQUALIFIED, context_die);\n+\t\t\t\t    TYPE_UNQUALIFIED, false, context_die);\n \t    }\n \t}\n     }\n@@ -20247,7 +20280,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  add_prototyped_attribute (subr_die, TREE_TYPE (decl));\n \t  add_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t      TYPE_UNQUALIFIED, context_die);\n+\t\t\t      TYPE_UNQUALIFIED, false, context_die);\n \t}\n \n       add_pure_or_virtual_attribute (subr_die, decl);\n@@ -20914,7 +20947,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t}\n       var_die = new_die (DW_TAG_variable, com_die, decl);\n       add_name_and_src_coords_attributes (var_die, decl);\n-      add_type_attribute (var_die, TREE_TYPE (decl), decl_quals (decl),\n+      add_type_attribute (var_die, TREE_TYPE (decl), decl_quals (decl), false,\n \t\t\t  context_die);\n       add_AT_flag (var_die, DW_AT_external, 1);\n       if (loc)\n@@ -21027,10 +21060,10 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       tree type = TREE_TYPE (decl_or_origin);\n \n       if (decl_by_reference_p (decl_or_origin))\n-\tadd_type_attribute (var_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+\tadd_type_attribute (var_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,\n \t\t\t    context_die);\n       else\n-\tadd_type_attribute (var_die, type, decl_quals (decl_or_origin),\n+\tadd_type_attribute (var_die, type, decl_quals (decl_or_origin), false,\n \t\t\t    context_die);\n     }\n \n@@ -21090,7 +21123,7 @@ gen_const_die (tree decl, dw_die_ref context_die)\n   const_die = new_die (DW_TAG_constant, context_die, decl);\n   equate_decl_number_to_die (decl, const_die);\n   add_name_and_src_coords_attributes (const_die, decl);\n-  add_type_attribute (const_die, type, TYPE_QUAL_CONST, context_die);\n+  add_type_attribute (const_die, type, TYPE_QUAL_CONST, false, context_die);\n   if (TREE_PUBLIC (decl))\n     add_AT_flag (const_die, DW_AT_external, 1);\n   if (DECL_ARTIFICIAL (decl))\n@@ -21376,8 +21409,9 @@ gen_field_die (tree decl, struct vlr_context *ctx, dw_die_ref context_die)\n \n   decl_die = new_die (DW_TAG_member, context_die, decl);\n   add_name_and_src_coords_attributes (decl_die, decl);\n-  add_type_attribute (decl_die, member_declared_type (decl),\n-\t\t      decl_quals (decl), context_die);\n+  add_type_attribute (decl_die, member_declared_type (decl), decl_quals (decl),\n+\t\t      TYPE_REVERSE_STORAGE_ORDER (DECL_FIELD_CONTEXT (decl)),\n+\t\t      context_die);\n \n   if (DECL_BIT_FIELD_TYPE (decl))\n     {\n@@ -21416,7 +21450,7 @@ gen_pointer_type_die (tree type, dw_die_ref context_die)\n     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ptr_die);\n-  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,\n \t\t      context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n@@ -21437,7 +21471,7 @@ gen_reference_type_die (tree type, dw_die_ref context_die)\n     ref_die = new_die (DW_TAG_reference_type, scope_die, type);\n \n   equate_type_number_to_die (type, ref_die);\n-  add_type_attribute (ref_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+  add_type_attribute (ref_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,\n \t\t      context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n@@ -21455,7 +21489,7 @@ gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)\n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n \t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n-  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED,\n+  add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,\n \t\t      context_die);\n }\n \n@@ -21724,7 +21758,8 @@ gen_inheritance_die (tree binfo, tree access, tree type,\n   dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);\n   struct vlr_context ctx = { type, NULL };\n \n-  add_type_attribute (die, BINFO_TYPE (binfo), TYPE_UNQUALIFIED, context_die);\n+  add_type_attribute (die, BINFO_TYPE (binfo), TYPE_UNQUALIFIED, false,\n+\t\t      context_die);\n   add_data_member_location_attribute (die, binfo, &ctx);\n \n   if (BINFO_VIRTUAL_P (binfo))\n@@ -22357,7 +22392,8 @@ gen_subroutine_type_die (tree type, dw_die_ref context_die)\n \n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n-  add_type_attribute (subr_die, return_type, TYPE_UNQUALIFIED, context_die);\n+  add_type_attribute (subr_die, return_type, TYPE_UNQUALIFIED, false,\n+\t\t      context_die);\n   gen_formal_types_die (type, subr_die);\n \n   if (get_AT (subr_die, DW_AT_name))\n@@ -22435,7 +22471,8 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t    }\n \t}\n \n-      add_type_attribute (type_die, type, decl_quals (decl), context_die);\n+      add_type_attribute (type_die, type, decl_quals (decl), false,\n+\t\t\t  context_die);\n \n       if (is_naming_typedef_decl (decl))\n \t/* We want that all subsequent calls to lookup_type_die with\n@@ -23066,7 +23103,7 @@ force_type_die (tree type)\n       dw_die_ref context_die = get_context_die (TYPE_CONTEXT (type));\n \n       type_die = modified_type_die (type, TYPE_QUALS_NO_ADDR_SPACE (type),\n-\t\t\t\t    context_die);\n+\t\t\t\t    false, context_die);\n       gcc_assert (type_die);\n     }\n   return type_die;"}, {"sha": "065c7a8d2a4726a1a91366842a9e399e688a3f67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "patch": "@@ -1,3 +1,7 @@\n+2016-01-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/debug/dwarf2/sso.c: New test.\n+\n 2016-01-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR testsuite/68820"}, {"sha": "698c636a130564d64669791e63f3b627de1c9e92", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/sso.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af33ba0d93bfaebff31c2cc43b1fc56b618821e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso.c?ref=af33ba0d93bfaebff31c2cc43b1fc56b618821e7", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-gdwarf-3 -dA\" } */\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"big-endian\")));\n+#else\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"little-endian\")));\n+#endif\n+\n+struct S0 { int i; };\n+\n+struct S1 { int i; struct S0 s; } REVERSE_SSO;\n+\n+struct S2 { int a[4]; struct S0 s; } REVERSE_SSO;\n+\n+struct S0 s0;\n+struct S1 s1;\n+struct S2 s2;\n+\n+/* Verify that we have endianity on the common base type of 'i' in S1 and of\n+   the element of 'a' in S2.  */\n+/* { dg-final { scan-assembler-times \" DW_AT_endianity\" 1 } } */"}]}