{"sha": "434aeebbffe4ab538143fb7f12653e8745e077f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM0YWVlYmJmZmU0YWI1MzgxNDNmYjdmMTI2NTNlODc0NWUwNzdmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-03-02T19:32:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-03-02T19:32:52Z"}, "message": "tm.texi (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Document.\n\n\t* doc/tm.texi (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Document.\n\t(ASM_OUTPUT_BSS): Describe the two ways of handling global BSS,\n\tand say that only one is needed.\n\t* doc/rtl.texi (SYMBOL_REF_BLOCK): Say that the block can be null.\n\t* target.h (have_switchable_bss_sections): New hook.\n\t* explow.c (use_anchored_address): Check that the symbol is in a block.\n\t* varasm.c (tls_comm_section, comm_section, lcomm_section)\n\t(bss_noswitch_section): New variables.\n\t(get_unnamed_section): Add SECTION_UNNAMED to the flags.\n\t(get_noswitch_section): New function.\n\t(get_block_for_section): Allow SECT to be null.\n\t(unlikely_text_section_p): Use SECTION_STYLE.\n\t(bss_initializer_p): New function.\n\t(get_variable_section): Move earlier in file.  Take a new argument,\n\tprefer_noswitch_p.  Move bss checks from assemble_variable to here.\n\tReturn one of the new *_sections in such cases.\n\t(get_block_for_decl): New function, extracting some logic from\n\tuse_blocks_for_decl_p.\n\t(change_symbol_section): Remove in favor of...\n\t(change_symbol_block): ...this new function.\n\t(use_blocks_for_decl_p): Remove checks now performed by\n\tget_block_for_decl.\n\t(make_decl_rtl): Use change_symbol_block and get_block_for_decl.\n\t(ASM_EMIT_LOCAL, ASM_EMIT_BSS, ASM_EMIT_COMMON): Delete in favor of...\n\t(emit_local, emit_bss, emit_common): ...these new functions.\n\tReturn true if the alignment was honored.\n\t(emit_tls_common): New function.\n\t(asm_emit_uninitialised): Delete.\n\t(assemble_variable_noswitch): New function, split out from...\n\t(assemble_variable): ...here.  Don't make decisions about common\n\tvariables here.  Globalize all public decls that go into non-common\n\tsections.  Check whether SYMBOL_REF_BLOCK is null.\n\t(output_constant_def_contents): Check whether SYMBOL_REF_BLOCK is null.\n\t(output_constant_pool): Likewise.\n\t(init_varasm_once): Initialize the new section variables.\n\t(have_global_bss_p): New function.\n\t(categorize_decl_for_section): Use bss_initializer_p.\n\t(switch_to_section): Use SECTION_STYLE.  Abort for SECTION_NOSWITCH.\n\t(place_block_symbol): Assert that the symbol must be in a block.\n\t* target-def.h (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): New macro.\n\t(TARGET_INITIALIZER): Include it.\n\t* rtl.h (SYMBOL_REF_BLOCK): Document the null alternative.\n\t* output.h (SECTION_STYLE_MASK, SECTION_COMMON): New macros.\n\t(SECTION_MACH_DEP): Bump by two.\n\t(SECTION_UNNAMED, SECTION_NOSWITCH): New macros.\n\t(unnamed_section): Mention SECTION_UNNAMED in comment.\n\t(named_section): Likewise SECTION_NAMED.\n\t(noswitch_section_callback): New type.\n\t(noswitch_section): New structure.\n\t(section): Add a noswitch_section alternative.\n\t(SECTION_STYLE): New macro.\n\t(tls_comm_section, comm_section, lcomm_section): Declare.\n\t(bss_noswitch_section, have_global_bss_p): Declare.\n\t* config/elfos.h (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Override.\n\t* config/iq2000/iq2000.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS):\n\tOverride.\n\t* config/v850/v850.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Override.\n\t* config/stormy16/stormy16.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS):\n\tOverride.\n\ncp/\n\t* decl.c (start_decl): Use have_global_bss_p when deciding\n\twhether to make the decl common.\n\nada/\n\t* utils.c (create_var_decl): Use have_global_bss_p when deciding\n\twhether to make the decl common.\n\nFrom-SVN: r111644", "tree": {"sha": "528d89d3defd10c4dc529d8c5dd944f7010598a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528d89d3defd10c4dc529d8c5dd944f7010598a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/434aeebbffe4ab538143fb7f12653e8745e077f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434aeebbffe4ab538143fb7f12653e8745e077f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/434aeebbffe4ab538143fb7f12653e8745e077f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434aeebbffe4ab538143fb7f12653e8745e077f0/comments", "author": null, "committer": null, "parents": [{"sha": "c2924966db687eb67be927c2db657dc92ff25f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2924966db687eb67be927c2db657dc92ff25f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2924966db687eb67be927c2db657dc92ff25f25"}], "stats": {"total": 664, "additions": 432, "deletions": 232}, "files": [{"sha": "55bb0ad17d4f1e5a533e003acf75389402c4409a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -1,3 +1,65 @@\n+2006-03-02  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* doc/tm.texi (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Document.\n+\t(ASM_OUTPUT_BSS): Describe the two ways of handling global BSS,\n+\tand say that only one is needed.\n+\t* doc/rtl.texi (SYMBOL_REF_BLOCK): Say that the block can be null.\n+\t* target.h (have_switchable_bss_sections): New hook.\n+\t* explow.c (use_anchored_address): Check that the symbol is in a block.\n+\t* varasm.c (tls_comm_section, comm_section, lcomm_section)\n+\t(bss_noswitch_section): New variables.\n+\t(get_unnamed_section): Add SECTION_UNNAMED to the flags.\n+\t(get_noswitch_section): New function.\n+\t(get_block_for_section): Allow SECT to be null.\n+\t(unlikely_text_section_p): Use SECTION_STYLE.\n+\t(bss_initializer_p): New function.\n+\t(get_variable_section): Move earlier in file.  Take a new argument,\n+\tprefer_noswitch_p.  Move bss checks from assemble_variable to here.\n+\tReturn one of the new *_sections in such cases.\n+\t(get_block_for_decl): New function, extracting some logic from\n+\tuse_blocks_for_decl_p.\n+\t(change_symbol_section): Remove in favor of...\n+\t(change_symbol_block): ...this new function.\n+\t(use_blocks_for_decl_p): Remove checks now performed by\n+\tget_block_for_decl.\n+\t(make_decl_rtl): Use change_symbol_block and get_block_for_decl.\n+\t(ASM_EMIT_LOCAL, ASM_EMIT_BSS, ASM_EMIT_COMMON): Delete in favor of...\n+\t(emit_local, emit_bss, emit_common): ...these new functions.\n+\tReturn true if the alignment was honored.\n+\t(emit_tls_common): New function.\n+\t(asm_emit_uninitialised): Delete.\n+\t(assemble_variable_noswitch): New function, split out from...\n+\t(assemble_variable): ...here.  Don't make decisions about common\n+\tvariables here.  Globalize all public decls that go into non-common\n+\tsections.  Check whether SYMBOL_REF_BLOCK is null.\n+\t(output_constant_def_contents): Check whether SYMBOL_REF_BLOCK is null.\n+\t(output_constant_pool): Likewise.\n+\t(init_varasm_once): Initialize the new section variables.\n+\t(have_global_bss_p): New function.\n+\t(categorize_decl_for_section): Use bss_initializer_p.\n+\t(switch_to_section): Use SECTION_STYLE.  Abort for SECTION_NOSWITCH.\n+\t(place_block_symbol): Assert that the symbol must be in a block.\n+\t* target-def.h (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): New macro.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* rtl.h (SYMBOL_REF_BLOCK): Document the null alternative.\n+\t* output.h (SECTION_STYLE_MASK, SECTION_COMMON): New macros.\n+\t(SECTION_MACH_DEP): Bump by two.\n+\t(SECTION_UNNAMED, SECTION_NOSWITCH): New macros.\n+\t(unnamed_section): Mention SECTION_UNNAMED in comment.\n+\t(named_section): Likewise SECTION_NAMED.\n+\t(noswitch_section_callback): New type.\n+\t(noswitch_section): New structure.\n+\t(section): Add a noswitch_section alternative.\n+\t(SECTION_STYLE): New macro.\n+\t(tls_comm_section, comm_section, lcomm_section): Declare.\n+\t(bss_noswitch_section, have_global_bss_p): Declare.\n+\t* config/elfos.h (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Override.\n+\t* config/iq2000/iq2000.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS):\n+\tOverride.\n+\t* config/v850/v850.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS): Override.\n+\t* config/stormy16/stormy16.c (TARGET_HAVE_SWITCHABLE_BSS_SECTIONS):\n+\tOverride.\n+\n 2006-03-02  Daniel Berlin <dberlin@dberlin.org>\n \n \t* gcc/tree-vrp.c (execute_vrp): Return value."}, {"sha": "d87a8d67251e26b9ffca544ff468bb11d72d7aa0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -1,3 +1,8 @@\n+2006-03-02  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* utils.c (create_var_decl): Use have_global_bss_p when deciding\n+\twhether to make the decl common.\n+\n 2006-02-20 Rafael \ufffdvila de Esp\ufffdndola <rafael.espindola@gmail.com>\n \t* Make-lang.in (Ada): Remove\n \t(.PHONY): Remove Ada"}, {"sha": "a3fdb0d5c4538fcc96e3f7fe321c76cead56818a", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -1293,10 +1293,10 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n      try to fiddle with DECL_COMMON.  However, on platforms that don't\n      support global BSS sections, uninitialized global variables would\n      go in DATA instead, thus increasing the size of the executable.  */\n-#if !defined(ASM_OUTPUT_BSS) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n-  if (TREE_CODE (var_decl) == VAR_DECL)\n-    DECL_COMMON   (var_decl) = !flag_no_common;\n-#endif\n+  if (!flag_no_common\n+      && TREE_CODE (var_decl) == VAR_DECL\n+      && !have_global_bss_p ())\n+    DECL_COMMON (var_decl) = 1;\n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n   DECL_EXTERNAL (var_decl) = extern_flag;"}, {"sha": "31e309d9b07f4377c9629ff4ab6b2d7aa44dc36f", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -221,6 +221,8 @@ Boston, MA 02110-1301, USA.  */\n #define TARGET_ASM_SELECT_RTX_SECTION default_elf_select_rtx_section\n #undef\tTARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION default_elf_select_section\n+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS true\n \n /* Define the strings used for the special svr4 .type and .size directives.\n    These strings generally do not vary from one system running svr4 to"}, {"sha": "4b1cb3e52334ef3d9d387429df0fa55392de8c17", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -186,6 +186,11 @@ static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n #undef  TARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION\tiq2000_select_section\n \n+/* The assembler supports switchable .bss sections, but\n+   iq2000_select_section doesn't yet make use of them.  */\n+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n+\n #undef  TARGET_PROMOTE_FUNCTION_ARGS\n #define TARGET_PROMOTE_FUNCTION_ARGS\thook_bool_tree_true\n #undef  TARGET_PROMOTE_FUNCTION_RETURN"}, {"sha": "32513d28e9493dd26ca68a80b07ea47699d5e24f", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -2653,6 +2653,10 @@ xstormy16_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO xstormy16_encode_section_info\n \n+/* select_section doesn't handle .bss_below100.  */\n+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n+\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK xstormy16_asm_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK"}, {"sha": "eb2771c571578eadda5d66bd12a82d2e17308cb8", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -117,6 +117,11 @@ static GTY(()) section *zbss_section;\n #undef  TARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION  v850_select_section\n \n+/* The assembler supports switchable .bss sections, but\n+   v850_select_section doesn't yet make use of them.  */\n+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n+\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO v850_encode_section_info\n "}, {"sha": "71541e1fe56fb5a4e1bded0fa62d7622cb9b3691", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -1,3 +1,8 @@\n+2006-03-02  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* decl.c (start_decl): Use have_global_bss_p when deciding\n+\twhether to make the decl common.\n+\n 2006-03-01  Mike Stump  <mrs@apple.com>\n \n \tPR darwin/25908"}, {"sha": "a9aec670634fe1d4b4a6033a0df251bd622b78da", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -3824,16 +3824,17 @@ start_decl (const cp_declarator *declarator,\n   if (tem == error_mark_node)\n     return error_mark_node;\n \n-#if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n   /* Tell the back-end to use or not use .common as appropriate.  If we say\n      -fconserve-space, we want this to save .data space, at the expense of\n      wrong semantics.  If we say -fno-conserve-space, we want this to\n      produce errors about redefs; to do this we force variables into the\n      data segment.  */\n-  DECL_COMMON (tem) = ((TREE_CODE (tem) != VAR_DECL\n-\t\t\t|| !DECL_THREAD_LOCAL_P (tem))\n-\t\t       && (flag_conserve_space || ! TREE_PUBLIC (tem)));\n-#endif\n+  if (flag_conserve_space\n+      && TREE_CODE (tem) == VAR_DECL\n+      && TREE_PUBLIC (tem)\n+      && !DECL_THREAD_LOCAL_P (tem)\n+      && !have_global_bss_p ())\n+    DECL_COMMON (tem) = 1;\n \n   if (! processing_template_decl)\n     start_decl_1 (tem);"}, {"sha": "76b3a3cff6758be005e0b93d8ea9debc1943d73e", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -528,7 +528,7 @@ the target's use.\n @findex SYMBOL_REF_BLOCK\n @item SYMBOL_REF_BLOCK (@var{x})\n If @samp{SYMBOL_REF_IN_BLOCK_P (@var{x})}, this is the @samp{object_block}\n-structure to which the symbol belongs.  The value is always nonnull.\n+structure to which the symbol belongs, or @code{NULL} if none.\n \n @findex SYMBOL_REF_BLOCK_OFFSET\n @item SYMBOL_REF_BLOCK_OFFSET (@var{x})"}, {"sha": "e99989fbde52ec450a5d43d9a98fa98deda376be", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -6477,6 +6477,13 @@ specify an alignment within the section directive need pay attention to\n This flag is true if the target supports @code{TARGET_ASM_NAMED_SECTION}.\n @end deftypefn\n \n+@anchor{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}\n+@deftypefn {Target Hook} bool TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+This flag is true if we can create zeroed data by switching to a BSS\n+section and then using @code{ASM_OUTPUT_SKIP} to allocate the space.\n+This is true on most ELF targets.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {unsigned int} TARGET_SECTION_TYPE_FLAGS (tree @var{decl}, const char *@var{name}, int @var{reloc})\n Choose a set of section attributes for use by @code{TARGET_ASM_NAMED_SECTION}\n based on a variable or function decl, a section name, and whether or not the\n@@ -6705,13 +6712,17 @@ defining this macro.  If unable, use the expression\n before and after that, output the additional assembler syntax for defining\n the name, and a newline.\n \n-This macro controls how the assembler definitions of uninitialized global\n-variables are output.  This macro exists to properly support languages like\n-C++ which do not have @code{common} data.  However, this macro currently\n-is not defined for all targets.  If this macro and\n-@code{ASM_OUTPUT_ALIGNED_BSS} are not defined then @code{ASM_OUTPUT_COMMON}\n-or @code{ASM_OUTPUT_ALIGNED_COMMON} or\n-@code{ASM_OUTPUT_ALIGNED_DECL_COMMON} is used.\n+There are two ways of handling global BSS.  One is to define either\n+this macro or its aligned counterpart, @code{ASM_OUTPUT_ALIGNED_BSS}.\n+The other is to have @code{TARGET_ASM_SELECT_SECTION} return a\n+switchable BSS section (@pxref{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}).\n+You do not need to do both.\n+\n+Some languages do not have @code{common} data, and require a\n+non-common form of global BSS in order to handle uninitialized globals\n+efficiently.  C++ is one example of this.  However, if the target does\n+not support global BSS, the front end may choose to make globals\n+common in order to save space in the object file.\n @end defmac\n \n @defmac ASM_OUTPUT_ALIGNED_BSS (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})"}, {"sha": "361c717252ddd5ac9d5666bc5a2b984fa207c2b4", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -568,6 +568,7 @@ use_anchored_address (rtx x)\n   if (GET_CODE (base) != SYMBOL_REF\n       || !SYMBOL_REF_IN_BLOCK_P (base)\n       || SYMBOL_REF_ANCHOR_P (base)\n+      || SYMBOL_REF_BLOCK (base) == NULL\n       || !targetm.use_anchors_for_symbol_p (base))\n     return x;\n "}, {"sha": "897435160502ef5ca611d1cc864241f5a3477929", "filename": "gcc/output.h", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -402,8 +402,22 @@ extern void no_asm_to_stream (FILE *);\n #define SECTION_TLS\t 0x40000\t/* contains thread-local storage */\n #define SECTION_NOTYPE\t 0x80000\t/* don't output @progbits */\n #define SECTION_DECLARED 0x100000\t/* section has been used */\n-#define SECTION_NAMED\t 0x200000\t/* section has a name */\n-#define SECTION_MACH_DEP 0x400000\t/* subsequent bits reserved for target */\n+#define SECTION_STYLE_MASK 0x600000\t/* bits used for SECTION_STYLE */\n+#define SECTION_COMMON   0x800000\t/* contains common data */\n+#define SECTION_MACH_DEP 0x1000000\t/* subsequent bits reserved for target */\n+\n+/* This SECTION_STYLE is used for unnamed sections that we can switch\n+   to using a special assembler directive.  */\n+#define SECTION_UNNAMED\t 0x000000\n+\n+/* This SECTION_STYLE is used for named sections that we can switch\n+   to using a general section directive.  */\n+#define SECTION_NAMED\t 0x200000\n+\n+/* This SECTION_STYLE is used for sections that we cannot switch to at\n+   all.  The choice of section is implied by the directive that we use\n+   to declare the object.  */\n+#define SECTION_NOSWITCH 0x400000\n \n /* A helper function for default_elf_select_section and\n    default_elf_unique_section.  Categorizes the DECL.  */\n@@ -448,7 +462,7 @@ struct section_common GTY(()) {\n   unsigned int flags;\n };\n \n-/* Information that is provided by named sections.  */\n+/* Information about a SECTION_NAMED section.  */\n struct named_section GTY(()) {\n   struct section_common common;\n \n@@ -464,7 +478,7 @@ struct named_section GTY(()) {\n    section.  The argument provides callback-specific data.  */\n typedef void (*unnamed_section_callback) (const void *);\n \n-/* Information that is provided by unnamed sections.  */\n+/* Information about a SECTION_UNNAMED section.  */\n struct unnamed_section GTY(()) {\n   struct section_common common;\n \n@@ -477,14 +491,39 @@ struct unnamed_section GTY(()) {\n   section *next;\n };\n \n+/* A callback that writes the assembly code for a decl in a\n+   SECTION_NOSWITCH section.  DECL is the decl that should be assembled\n+   and NAME is the name of its SYMBOL_REF.  SIZE is the size of the decl\n+   in bytes and ROUNDED is that size rounded up to the next\n+   BIGGEST_ALIGNMENT / BITS_PER_UNIT boundary.\n+\n+   Return true if the callback used DECL_ALIGN to set the object's\n+   alignment.  A false return value implies that we are relying\n+   on the rounded size to align the decl.  */\n+typedef bool (*noswitch_section_callback) (tree decl, const char *name,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT size,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT rounded);\n+\n+/* Information about a SECTION_NOSWITCH section.  */\n+struct noswitch_section GTY(()) {\n+  struct section_common common;\n+\n+  /* The callback used to assemble decls in this section.  */\n+  noswitch_section_callback GTY ((skip)) callback;\n+};\n+\n /* Information about a section, which may be named or unnamed.  */\n-union section GTY ((desc (\"(%h).common.flags & SECTION_NAMED\")))\n+union section GTY ((desc (\"SECTION_STYLE (&(%h))\")))\n {\n   struct section_common GTY ((skip)) common;\n   struct named_section GTY ((tag (\"SECTION_NAMED\"))) named;\n-  struct unnamed_section GTY ((tag (\"0\"))) unnamed;\n+  struct unnamed_section GTY ((tag (\"SECTION_UNNAMED\"))) unnamed;\n+  struct noswitch_section GTY ((tag (\"SECTION_NOSWITCH\"))) noswitch;\n };\n \n+/* Return the style of section SECT.  */\n+#define SECTION_STYLE(SECT) ((SECT)->common.flags & SECTION_STYLE_MASK)\n+\n struct object_block;\n \n /* Special well-known sections.  */\n@@ -498,6 +537,10 @@ extern GTY(()) section *bss_section;\n extern GTY(()) section *sbss_section;\n extern GTY(()) section *exception_section;\n extern GTY(()) section *eh_frame_section;\n+extern GTY(()) section *tls_comm_section;\n+extern GTY(()) section *comm_section;\n+extern GTY(()) section *lcomm_section;\n+extern GTY(()) section *bss_noswitch_section;\n \n extern GTY(()) section *in_section;\n extern GTY(()) bool in_cold_section_p;\n@@ -523,6 +566,7 @@ extern void output_section_asm_op (const void *);\n extern unsigned int default_section_type_flags (tree, const char *, int);\n extern unsigned int default_section_type_flags_1 (tree, const char *, int, int);\n \n+extern bool have_global_bss_p (void);\n extern void default_no_named_section (const char *, unsigned int, tree);\n extern void default_elf_asm_named_section (const char *, unsigned int, tree);\n extern enum section_category categorize_decl_for_section (tree, int, int);"}, {"sha": "236c8a13640e2ae44aeb6285803cf7950a80eeff", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -1331,8 +1331,8 @@ do {\t\t\t\t\t\t\\\n #define SYMBOL_FLAG_MACH_DEP_SHIFT\t9\n #define SYMBOL_FLAG_MACH_DEP\t\t(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)\n \n-/* The block to which the given SYMBOL_REF belongs.  Only valid if\n-   SYMBOL_REF_IN_BLOCK_P (RTX).  */\n+/* The block to which the given SYMBOL_REF belongs, or NULL if none.\n+   Only valid if SYMBOL_REF_IN_BLOCK_P (RTX).  */\n #define SYMBOL_REF_BLOCK(RTX) (BLOCK_SYMBOL_CHECK (RTX)->block)\n \n /* The byte offset of the given SYMBOL_REF from the start of its block,"}, {"sha": "fa38166769c322626ec58ee7fbdc323266dd214d", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -140,6 +140,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n # endif\n #endif\n \n+#ifndef TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n+#endif\n+\n #ifndef TARGET_ASM_INIT_SECTIONS\n #define TARGET_ASM_INIT_SECTIONS hook_void_void\n #endif\n@@ -651,6 +655,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_EXTRA_LIVE_ON_ENTRY,                    \\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n+  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS,\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n   TARGET_HAVE_TLS,\t\t\t\t\\\n   TARGET_HAVE_SRODATA_SECTION,\t\t\t\\"}, {"sha": "e6e6ba83155c2b84c57c70cf00caf4676e8741ae", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -734,6 +734,10 @@ struct gcc_target\n   /* True if arbitrary sections are supported.  */\n   bool have_named_sections;\n \n+  /* True if we can create zeroed data by switching to a BSS section\n+     and then using ASM_OUTPUT_SKIP to allocate the space.  */\n+  bool have_switchable_bss_sections;\n+\n   /* True if \"native\" constructors and destructors are supported,\n      false if we're using collect2 for the job.  */\n   bool have_ctors_dtors;"}, {"sha": "801d11e41d8c07025d191861c92f966df4fadf29", "filename": "gcc/varasm.c", "status": "modified", "additions": 253, "deletions": 207, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434aeebbffe4ab538143fb7f12653e8745e077f0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=434aeebbffe4ab538143fb7f12653e8745e077f0", "patch": "@@ -138,9 +138,6 @@ static void asm_output_aligned_bss (FILE *, tree, const char *,\n      ATTRIBUTE_UNUSED;\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n-static bool asm_emit_uninitialised (tree, const char*,\n-\t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT);\n static void mark_weak (tree);\n \f\n /* Well-known sections, each one associated with some sort of *_ASM_OP.  */\n@@ -153,6 +150,15 @@ section *dtors_section;\n section *bss_section;\n section *sbss_section;\n \n+/* Various forms of common section.  All are guaranteed to be nonnull.  */\n+section *tls_comm_section;\n+section *comm_section;\n+section *lcomm_section;\n+\n+/* A SECTION_NOSWITCH section used for declaring global BSS variables.\n+   May be null.  */\n+section *bss_noswitch_section;\n+\n /* The section that holds the main exception table, when known.  The section\n    is set either by the target's init_sections hook or by the first call to\n    switch_to_exception_section.  */\n@@ -245,7 +251,7 @@ get_unnamed_section (unsigned int flags, void (*callback) (const void *),\n   section *sect;\n \n   sect = ggc_alloc (sizeof (struct unnamed_section));\n-  sect->unnamed.common.flags = flags;\n+  sect->unnamed.common.flags = flags | SECTION_UNNAMED;\n   sect->unnamed.callback = callback;\n   sect->unnamed.data = data;\n   sect->unnamed.next = unnamed_sections;\n@@ -254,6 +260,20 @@ get_unnamed_section (unsigned int flags, void (*callback) (const void *),\n   return sect;\n }\n \n+/* Return a SECTION_NOSWITCH section with the given fields.  */\n+\n+static section *\n+get_noswitch_section (unsigned int flags, noswitch_section_callback callback)\n+{\n+  section *sect;\n+\n+  sect = ggc_alloc (sizeof (struct unnamed_section));\n+  sect->noswitch.common.flags = flags | SECTION_NOSWITCH;\n+  sect->noswitch.callback = callback;\n+\n+  return sect;\n+}\n+\n /* Return the named section structure associated with NAME.  Create\n    a new section with the given fields if no such structure exists.  */\n \n@@ -300,14 +320,18 @@ use_object_blocks_p (void)\n }\n \n /* Return the object_block structure for section SECT.  Create a new\n-   structure if we haven't created one already.  */\n+   structure if we haven't created one already.  Return null if SECT\n+   itself is null.  */\n \n static struct object_block *\n get_block_for_section (section *sect)\n {\n   struct object_block *block;\n   void **slot;\n \n+  if (sect == NULL)\n+    return NULL;\n+\n   slot = htab_find_slot_with_hash (object_block_htab, sect,\n \t\t\t\t   hash_section (sect), INSERT);\n   block = (struct object_block *) *slot;\n@@ -409,7 +433,7 @@ unlikely_text_section_p (section *sect)\n \n   return (name\n \t  && sect\n-\t  && (sect->common.flags & SECTION_NAMED) != 0\n+\t  && SECTION_STYLE (sect) == SECTION_NAMED\n \t  && strcmp (name, sect->named.name) == 0);\n }\n \n@@ -786,81 +810,127 @@ decode_reg_name (const char *asmspec)\n   return -1;\n }\n \f\n-/* Return true if it is possible to put DECL in an object_block.  */\n+/* Return true if DECL's initializer is suitable for a BSS section.  */\n \n static bool\n-use_blocks_for_decl_p (tree decl)\n+bss_initializer_p (tree decl)\n {\n-  /* Only data DECLs can be placed into object blocks.  */\n-  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != CONST_DECL)\n-    return false;\n+  return (DECL_INITIAL (decl) == NULL\n+\t  || DECL_INITIAL (decl) == error_mark_node\n+\t  || (flag_zero_initialized_in_bss\n+\t      /* Leave constant zeroes in .rodata so they\n+\t\t can be shared.  */\n+\t      && !TREE_READONLY (decl)\n+\t      && initializer_zerop (DECL_INITIAL (decl))));\n+}\n+\n+/* Return the section into which the given VAR_DECL or CONST_DECL\n+   should be placed.  PREFER_NOSWITCH_P is true if a noswitch\n+   section should be used wherever possible.  */\n+\n+static section *\n+get_variable_section (tree decl, bool prefer_noswitch_p)\n+{\n+  int reloc;\n+\n+  /* If the decl has been given an explicit section name, then it\n+     isn't common, and shouldn't be handled as such.  */\n+  if (DECL_COMMON (decl) && DECL_SECTION_NAME (decl) == NULL)\n+    {\n+      if (DECL_THREAD_LOCAL_P (decl))\n+\treturn tls_comm_section;\n+      if (TREE_PUBLIC (decl) && bss_initializer_p (decl))\n+\treturn comm_section;\n+    }\n+\n+  if (DECL_INITIAL (decl) == error_mark_node)\n+    reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;\n+  else if (DECL_INITIAL (decl))\n+    reloc = compute_reloc_for_constant (DECL_INITIAL (decl));\n+  else\n+    reloc = 0;\n+\n+  resolve_unique_section (decl, reloc, flag_data_sections);\n+  if (IN_NAMED_SECTION (decl))\n+    return get_named_section (decl, NULL, reloc);\n+\n+  if (!DECL_THREAD_LOCAL_P (decl)\n+      && !(prefer_noswitch_p && targetm.have_switchable_bss_sections)\n+      && bss_initializer_p (decl))\n+    {\n+      if (!TREE_PUBLIC (decl))\n+\treturn lcomm_section;\n+      if (bss_noswitch_section)\n+\treturn bss_noswitch_section;\n+    }\n+\n+  return targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+}\n+\n+/* Return the block into which object_block DECL should be placed.  */\n+\n+static struct object_block *\n+get_block_for_decl (tree decl)\n+{\n+  section *sect;\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* The object must be defined in this translation unit.  */\n       if (DECL_EXTERNAL (decl))\n-\treturn false;\n+\treturn NULL;\n \n       /* There's no point using object blocks for something that is\n \t isolated by definition.  */\n       if (DECL_ONE_ONLY (decl))\n-\treturn false;\n-\n-      /* Symbols that use .common cannot be put into blocks.  */\n-      if (DECL_COMMON (decl) && DECL_INITIAL (decl) == NULL)\n-\treturn false;\n+\treturn NULL;\n     }\n \n   /* We can only calculate block offsets if the decl has a known\n      constant size.  */\n   if (DECL_SIZE_UNIT (decl) == NULL)\n-    return false;\n+    return NULL;\n   if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n-    return false;\n+    return NULL;\n \n-  /* Detect decls created by dw2_force_const_mem.  Such decls are\n-     special because DECL_INITIAL doesn't specify the decl's true value.\n-     dw2_output_indirect_constants will instead call assemble_variable\n-     with dont_output_data set to 1 and then print the contents itself.  */\n-  if (DECL_INITIAL (decl) == decl)\n-    return false;\n+  /* Find out which section should contain DECL.  We cannot put it into\n+     an object block if it requires a standalone definition.  */\n+  sect = get_variable_section (decl, true);\n+  if (SECTION_STYLE (sect) == SECTION_NOSWITCH)\n+    return NULL;\n \n-  return true;\n+  return get_block_for_section (sect);\n }\n \n-/* Make sure block symbol SYMBOL is in section SECT, moving it to a\n-   different block if necessary.  */\n+/* Make sure block symbol SYMBOL is in block BLOCK.  */\n \n static void\n-change_symbol_section (rtx symbol, section *sect)\n+change_symbol_block (rtx symbol, struct object_block *block)\n {\n-  if (sect != SYMBOL_REF_BLOCK (symbol)->sect)\n+  if (block != SYMBOL_REF_BLOCK (symbol))\n     {\n       gcc_assert (SYMBOL_REF_BLOCK_OFFSET (symbol) < 0);\n-      SYMBOL_REF_BLOCK (symbol) = get_block_for_section (sect);\n+      SYMBOL_REF_BLOCK (symbol) = block;\n     }\n }\n \n-/* Return the section into which the given VAR_DECL or CONST_DECL\n-   should be placed.  */\n+/* Return true if it is possible to put DECL in an object_block.  */\n \n-static section *\n-get_variable_section (tree decl)\n+static bool\n+use_blocks_for_decl_p (tree decl)\n {\n-  int reloc;\n+  /* Only data DECLs can be placed into object blocks.  */\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != CONST_DECL)\n+    return false;\n \n-  if (DECL_INITIAL (decl) == error_mark_node)\n-    reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;\n-  else if (DECL_INITIAL (decl))\n-    reloc = compute_reloc_for_constant (DECL_INITIAL (decl));\n-  else\n-    reloc = 0;\n+  /* Detect decls created by dw2_force_const_mem.  Such decls are\n+     special because DECL_INITIAL doesn't specify the decl's true value.\n+     dw2_output_indirect_constants will instead call assemble_variable\n+     with dont_output_data set to 1 and then print the contents itself.  */\n+  if (DECL_INITIAL (decl) == decl)\n+    return false;\n \n-  resolve_unique_section (decl, reloc, flag_data_sections);\n-  if (IN_NAMED_SECTION (decl))\n-    return get_named_section (decl, NULL, reloc);\n-  else\n-    return targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+  return true;\n }\n \n /* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should\n@@ -921,7 +991,7 @@ make_decl_rtl (tree decl)\n       if (MEM_P (x)\n \t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && SYMBOL_REF_IN_BLOCK_P (XEXP (x, 0)))\n-\tchange_symbol_section (XEXP (x, 0), get_variable_section (decl));\n+\tchange_symbol_block (XEXP (x, 0), get_block_for_decl (decl));\n \n       /* Make this function static known to the mudflap runtime.  */\n       if (flag_mudflap && TREE_CODE (decl) == VAR_DECL)\n@@ -1020,10 +1090,7 @@ make_decl_rtl (tree decl)\n     DECL_COMMON (decl) = 0;\n \n   if (use_object_blocks_p () && use_blocks_for_decl_p (decl))\n-    {\n-      section *sect = get_variable_section (decl);\n-      x = create_block_symbol (name, get_block_for_section (sect), -1);\n-    }\n+    x = create_block_symbol (name, get_block_for_decl (decl), -1);\n   else\n     x = gen_rtx_SYMBOL_REF (Pmode, name);\n   SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);\n@@ -1458,100 +1525,110 @@ assemble_string (const char *p, int size)\n }\n \n \f\n-#if defined  ASM_OUTPUT_ALIGNED_DECL_LOCAL\n-#define ASM_EMIT_LOCAL(decl, name, size, rounded) \\\n-  ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name, size, DECL_ALIGN (decl))\n-#else\n-#if defined  ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_EMIT_LOCAL(decl, name, size, rounded) \\\n-  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl))\n+/* A noswitch_section_callback for lcomm_section.  */\n+\n+static bool\n+emit_local (tree decl ATTRIBUTE_UNUSED,\n+\t    const char *name ATTRIBUTE_UNUSED,\n+\t    unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t    unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n+{\n+#if defined ASM_OUTPUT_ALIGNED_DECL_LOCAL\n+  ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name,\n+\t\t\t\t size, DECL_ALIGN (decl));\n+  return true;\n+#elif defined ASM_OUTPUT_ALIGNED_LOCAL\n+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, DECL_ALIGN (decl));\n+  return true;\n #else\n-#define ASM_EMIT_LOCAL(decl, name, size, rounded) \\\n-  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded)\n-#endif\n+  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+  return false;\n #endif\n+}\n \n+/* A noswitch_section_callback for bss_noswitch_section.  */\n+\n+#if defined ASM_OUTPUT_ALIGNED_BSS || defined ASM_OUTPUT_BSS\n+static bool\n+emit_bss (tree decl ATTRIBUTE_UNUSED,\n+\t  const char *name ATTRIBUTE_UNUSED,\n+\t  unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t  unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n+{\n #if defined ASM_OUTPUT_ALIGNED_BSS\n-#define ASM_EMIT_BSS(decl, name, size, rounded) \\\n-  ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl))\n-#else\n-#if defined ASM_OUTPUT_BSS\n-#define ASM_EMIT_BSS(decl, name, size, rounded) \\\n-  ASM_OUTPUT_BSS (asm_out_file, decl, name, size, rounded)\n+  ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl));\n+  return true;\n #else\n-#undef  ASM_EMIT_BSS\n+  ASM_OUTPUT_BSS (asm_out_file, decl, name, size, rounded);\n+  return false;\n #endif\n+}\n #endif\n \n+/* A noswitch_section_callback for comm_section.  */\n+\n+static bool\n+emit_common (tree decl ATTRIBUTE_UNUSED,\n+\t     const char *name ATTRIBUTE_UNUSED,\n+\t     unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t     unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n+{\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n-#define ASM_EMIT_COMMON(decl, name, size, rounded) \\\n-  ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name, size, DECL_ALIGN (decl))\n-#else\n-#if defined ASM_OUTPUT_ALIGNED_COMMON\n-#define ASM_EMIT_COMMON(decl, name, size, rounded) \\\n-  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl))\n+  ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name,\n+\t\t\t\t  size, DECL_ALIGN (decl));\n+  return true;\n+#elif defined ASM_OUTPUT_ALIGNED_COMMON\n+  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl));\n+  return true;\n #else\n-#define ASM_EMIT_COMMON(decl, name, size, rounded) \\\n-  ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded)\n-#endif\n+  ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n+  return false;\n #endif\n+}\n+\n+/* A noswitch_section_callback for tls_comm_section.  */\n \n static bool\n-asm_emit_uninitialised (tree decl, const char *name,\n-\t\t\tunsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n-\t\t\tunsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n+emit_tls_common (tree decl ATTRIBUTE_UNUSED,\n+\t\t const char *name ATTRIBUTE_UNUSED,\n+\t\t unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t\t unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n {\n-  enum\n-  {\n-    asm_dest_common,\n-    asm_dest_bss,\n-    asm_dest_local\n-  }\n-  destination = asm_dest_local;\n-\n-  /* ??? We should handle .bss via select_section mechanisms rather than\n-     via special target hooks.  That would eliminate this special case.  */\n-  if (TREE_PUBLIC (decl))\n-    {\n-      if (!DECL_COMMON (decl))\n-#ifdef ASM_EMIT_BSS\n-\tdestination = asm_dest_bss;\n+#ifdef ASM_OUTPUT_TLS_COMMON\n+  ASM_OUTPUT_TLS_COMMON (asm_out_file, decl, name, size);\n+  return true;\n #else\n-\treturn false;\n+  sorry (\"thread-local COMMON data not implemented\");\n+  return true;\n #endif\n-      else\n-\tdestination = asm_dest_common;\n-    }\n+}\n \n-  if (destination != asm_dest_common)\n-    {\n-      resolve_unique_section (decl, 0, flag_data_sections);\n-      /* Custom sections don't belong here.  */\n-      if (DECL_SECTION_NAME (decl))\n-        return false;\n-    }\n+/* Assemble DECL given that it belongs in SECTION_NOSWITCH section SECT.\n+   NAME is the name of DECL's SYMBOL_REF.  */\n \n-  if (destination == asm_dest_bss)\n-    globalize_decl (decl);\n+static void\n+assemble_noswitch_variable (tree decl, const char *name, section *sect)\n+{\n+  unsigned HOST_WIDE_INT size, rounded;\n \n-  switch (destination)\n-    {\n-#ifdef ASM_EMIT_BSS\n-    case asm_dest_bss:\n-      ASM_EMIT_BSS (decl, name, size, rounded);\n-      break;\n-#endif\n-    case asm_dest_common:\n-      ASM_EMIT_COMMON (decl, name, size, rounded);\n-      break;\n-    case asm_dest_local:\n-      ASM_EMIT_LOCAL (decl, name, size, rounded);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+  rounded = size;\n \n-  return true;\n+  /* Don't allocate zero bytes of common,\n+     since that means \"undefined external\" in the linker.  */\n+  if (size == 0)\n+    rounded = 1;\n+\n+  /* Round size up to multiple of BIGGEST_ALIGNMENT bits\n+     so that each uninitialized object starts on such a boundary.  */\n+  rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n+  rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\t     * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+\n+  if (!sect->noswitch.callback (decl, name, size, rounded)\n+      && (unsigned HOST_WIDE_INT) DECL_ALIGN_UNIT (decl) > rounded)\n+    warning (0, \"requested alignment for %q+D is greater than \"\n+\t     \"implemented alignment of %wu\", decl, rounded);\n }\n \n /* A subroutine of assemble_variable.  Output the label and contents of\n@@ -1602,8 +1679,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n {\n   const char *name;\n   unsigned int align;\n-  rtx decl_rtl;\n-  bool in_block_p;\n+  rtx decl_rtl, symbol;\n+  section *sect;\n \n   if (lang_hooks.decls.prepare_assemble_variable)\n     lang_hooks.decls.prepare_assemble_variable (decl);\n@@ -1675,8 +1752,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   gcc_assert (MEM_P (decl_rtl));\n   gcc_assert (GET_CODE (XEXP (decl_rtl, 0)) == SYMBOL_REF);\n-  in_block_p = SYMBOL_REF_IN_BLOCK_P (XEXP (decl_rtl, 0));\n-  name = XSTR (XEXP (decl_rtl, 0), 0);\n+  symbol = XEXP (decl_rtl, 0);\n+  name = XSTR (symbol, 0);\n   if (TREE_PUBLIC (decl) && DECL_NAME (decl))\n     notice_global_symbol (decl);\n \n@@ -1724,70 +1801,11 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (DECL_PRESERVE_P (decl))\n     targetm.asm_out.mark_decl_preserved (name);\n \n-  /* Handle uninitialized definitions.  */\n-\n-  /* If the decl has been given an explicit section name, then it\n-     isn't common, and shouldn't be handled as such.  */\n-  if (DECL_SECTION_NAME (decl) || dont_output_data)\n-    ;\n-  else if (DECL_THREAD_LOCAL_P (decl))\n-    {\n-      if (DECL_COMMON (decl))\n-\t{\n-#ifdef ASM_OUTPUT_TLS_COMMON\n-\t  unsigned HOST_WIDE_INT size;\n-\n-\t  size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-\t  ASM_OUTPUT_TLS_COMMON (asm_out_file, decl, name, size);\n-\t  return;\n-#else\n-\t  sorry (\"thread-local COMMON data not implemented\");\n-#endif\n-\t}\n-    }\n-  /* Do not handle decls as common if they will be assigned a\n-     specific section position.  */\n-  else if (in_block_p)\n-    ;\n-  else if (DECL_INITIAL (decl) == 0\n-\t   || DECL_INITIAL (decl) == error_mark_node\n-\t   || (flag_zero_initialized_in_bss\n-\t       /* Leave constant zeroes in .rodata so they can be shared.  */\n-\t       && !TREE_READONLY (decl)\n-\t       && initializer_zerop (DECL_INITIAL (decl))))\n-    {\n-      unsigned HOST_WIDE_INT size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-      unsigned HOST_WIDE_INT rounded = size;\n-\n-      /* Don't allocate zero bytes of common,\n-\t since that means \"undefined external\" in the linker.  */\n-      if (size == 0)\n-\trounded = 1;\n-\n-      /* Round size up to multiple of BIGGEST_ALIGNMENT bits\n-\t so that each uninitialized object starts on such a boundary.  */\n-      rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n-      rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n-\t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\n-#if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n-      if ((unsigned HOST_WIDE_INT) DECL_ALIGN_UNIT (decl) > rounded)\n-\twarning (0, \"requested alignment for %q+D is greater than \"\n-                 \"implemented alignment of %wu\", decl, rounded);\n-#endif\n-\n-      /* If the target cannot output uninitialized but not common global data\n-\t in .bss, then we have to use .data, so fall through.  */\n-      if (asm_emit_uninitialised (decl, name, size, rounded))\n-\treturn;\n-    }\n-\n-  /* Handle initialized definitions.\n-     Also handle uninitialized global definitions if -fno-common and the\n-     target doesn't support ASM_OUTPUT_BSS.  */\n-\n   /* First make the assembler name(s) global if appropriate.  */\n-  if (TREE_PUBLIC (decl) && DECL_NAME (decl))\n+  sect = get_variable_section (decl, false);\n+  if (TREE_PUBLIC (decl)\n+      && DECL_NAME (decl)\n+      && (sect->common.flags & SECTION_COMMON) == 0)\n     globalize_decl (decl);\n \n   /* Output any data that we will need to use the address of.  */\n@@ -1801,14 +1819,16 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   /* If the decl is part of an object_block, make sure that the decl\n      has been positioned within its block, but do not write out its\n      definition yet.  output_object_blocks will do that later.  */\n-  if (in_block_p)\n+  if (SYMBOL_REF_IN_BLOCK_P (symbol) && SYMBOL_REF_BLOCK (symbol))\n     {\n       gcc_assert (!dont_output_data);\n-      place_block_symbol (XEXP (decl_rtl, 0));\n+      place_block_symbol (symbol);\n     }\n+  else if (SECTION_STYLE (sect) == SECTION_NOSWITCH)\n+    assemble_noswitch_variable (decl, name, sect);\n   else\n     {\n-      switch_to_section (get_variable_section (decl));\n+      switch_to_section (sect);\n       if (align > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));\n       assemble_variable_contents (decl, name, dont_output_data);\n@@ -2927,7 +2947,7 @@ output_constant_def_contents (rtx symbol)\n   /* If the constant is part of an object block, make sure that the\n      decl has been positioned within its block, but do not write out\n      its definition yet.  output_object_blocks will do that later.  */\n-  if (SYMBOL_REF_IN_BLOCK_P (symbol))\n+  if (SYMBOL_REF_IN_BLOCK_P (symbol) && SYMBOL_REF_BLOCK (symbol))\n     place_block_symbol (symbol);\n   else\n     {\n@@ -3488,7 +3508,7 @@ output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n \t   the constant has been positioned within its block, but do not\n \t   write out its definition yet.  output_object_blocks will do\n \t   that later.  */\n-\tif (SYMBOL_REF_IN_BLOCK_P (desc->sym))\n+\tif (SYMBOL_REF_IN_BLOCK_P (desc->sym) && SYMBOL_REF_BLOCK (desc->sym))\n \t  place_block_symbol (desc->sym);\n \telse\n \t  {\n@@ -5085,6 +5105,18 @@ init_varasm_once (void)\n \t\t\t\t      SBSS_SECTION_ASM_OP);\n #endif\n \n+  tls_comm_section = get_noswitch_section (SECTION_WRITE | SECTION_BSS\n+\t\t\t\t\t   | SECTION_COMMON, emit_tls_common);\n+  lcomm_section = get_noswitch_section (SECTION_WRITE | SECTION_BSS\n+\t\t\t\t\t| SECTION_COMMON, emit_local);\n+  comm_section = get_noswitch_section (SECTION_WRITE | SECTION_BSS\n+\t\t\t\t       | SECTION_COMMON, emit_common);\n+\n+#if defined ASM_OUTPUT_ALIGNED_BSS || defined ASM_OUTPUT_BSS\n+  bss_noswitch_section = get_noswitch_section (SECTION_WRITE | SECTION_BSS,\n+\t\t\t\t\t       emit_bss);\n+#endif\n+\n   targetm.asm_out.init_sections ();\n \n   if (readonly_data_section == NULL)\n@@ -5191,6 +5223,16 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n   return flags;\n }\n \n+/* Return true if the target supports some form of global BSS,\n+   either through bss_noswitch_section, or by selecting a BSS\n+   section in TARGET_ASM_SELECT_SECTION.  */\n+\n+bool\n+have_global_bss_p (void)\n+{\n+  return bss_noswitch_section || targetm.have_switchable_bss_sections;\n+}\n+\n /* Output assembly to switch to section NAME with attribute FLAGS.\n    Four variants for common object file formats.  */\n \n@@ -5344,12 +5386,7 @@ categorize_decl_for_section (tree decl, int reloc, int shlib)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      if (DECL_INITIAL (decl) == NULL\n-\t  || DECL_INITIAL (decl) == error_mark_node\n-\t  || (flag_zero_initialized_in_bss\n-\t      /* Leave constant zeroes in .rodata so they can be shared.  */\n-\t      && !TREE_READONLY (decl)\n-\t      && initializer_zerop (DECL_INITIAL (decl))))\n+      if (bss_initializer_p (decl))\n \tret = SECCAT_BSS;\n       else if (! TREE_READONLY (decl)\n \t       || TREE_SIDE_EFFECTS (decl)\n@@ -5888,8 +5925,9 @@ switch_to_section (section *new_section)\n   else\n     in_section = new_section;\n \n-  if (new_section->common.flags & SECTION_NAMED)\n+  switch (SECTION_STYLE (new_section))\n     {\n+    case SECTION_NAMED:\n       if (cfun\n \t  && !cfun->unlikely_text_section_name\n \t  && strcmp (new_section->named.name,\n@@ -5899,9 +5937,16 @@ switch_to_section (section *new_section)\n       targetm.asm_out.named_section (new_section->named.name,\n \t\t\t\t     new_section->named.common.flags,\n \t\t\t\t     new_section->named.decl);\n+      break;\n+\n+    case SECTION_UNNAMED:\n+      new_section->unnamed.callback (new_section->unnamed.data);\n+      break;\n+\n+    case SECTION_NOSWITCH:\n+      gcc_unreachable ();\n+      break;\n     }\n-  else\n-    new_section->unnamed.callback (new_section->unnamed.data);\n \n   new_section->common.flags |= SECTION_DECLARED;\n }\n@@ -5918,6 +5963,7 @@ place_block_symbol (rtx symbol)\n   struct object_block *block;\n   tree decl;\n \n+  gcc_assert (SYMBOL_REF_BLOCK (symbol));\n   if (SYMBOL_REF_BLOCK_OFFSET (symbol) >= 0)\n     return;\n "}]}