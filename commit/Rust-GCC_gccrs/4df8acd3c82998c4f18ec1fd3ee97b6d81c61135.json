{"sha": "4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmOGFjZDNjODI5OThjNGYxOGVjMWZkM2VlOTdiNmQ4MWM2MTEzNQ==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2006-01-13T23:24:42Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2006-01-13T23:24:42Z"}, "message": "combine.c (struct reg_stat): Add new fields truncation_label and truncated_to_mode.\n\n\t* combine.c (struct reg_stat): Add new fields truncation_label and\n\ttruncated_to_mode.\n\t(record_value_for_reg): Reset truncated_to_mode.\n\t(record_truncated_value): New function.\n\t(check_promoted_subreg): Call it.  Rename to check_conversions.\n\t(combine_instructions): Rename check_promoted_subreg to\n\tcheck_conversions.\n\t(reg_truncated_to_mode): New function.\n\t(make_extraction): Use it.  Check TRULY_NOOP_TRUNCATION.\n\t(gen_lowpart_or_truncate): New function.\n\t(force_to_mode): Use it instead of gen_lowpart.\n\nFrom-SVN: r109679", "tree": {"sha": "b95582e94072bc2374e02928fcda10acb9258f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b95582e94072bc2374e02928fcda10acb9258f6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135/comments", "author": null, "committer": null, "parents": [{"sha": "c4603146017af9e00eadb5ca826a8c4b3a4b7c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4603146017af9e00eadb5ca826a8c4b3a4b7c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4603146017af9e00eadb5ca826a8c4b3a4b7c32"}], "stats": {"total": 175, "additions": 148, "deletions": 27}, "files": [{"sha": "e12842e4df8a63258c49d969a5425a710d1ecb12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "patch": "@@ -1,3 +1,17 @@\n+2006-01-13  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\t* combine.c (struct reg_stat): Add new fields truncation_label and\n+\ttruncated_to_mode.\n+\t(record_value_for_reg): Reset truncated_to_mode.\n+\t(record_truncated_value): New function.\n+\t(check_promoted_subreg): Call it.  Rename to check_conversions.\n+\t(combine_instructions): Rename check_promoted_subreg to\n+\tcheck_conversions.\n+\t(reg_truncated_to_mode): New function.\n+\t(make_extraction): Use it.  Check TRULY_NOOP_TRUNCATION.\n+\t(gen_lowpart_or_truncate): New function.\n+\t(force_to_mode): Use it instead of gen_lowpart.\n+\n 2006-01-13  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-ssa-alias.c (add_type_alias): Fix typo.  Test whether"}, {"sha": "3b1fd77605e4e2cd256beadcf434e78f547d128f", "filename": "gcc/combine.c", "status": "modified", "additions": 134, "deletions": 27, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df8acd3c82998c4f18ec1fd3ee97b6d81c61135/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4df8acd3c82998c4f18ec1fd3ee97b6d81c61135", "patch": "@@ -220,7 +220,7 @@ struct reg_stat {\n \n   unsigned HOST_WIDE_INT\tlast_set_nonzero_bits;\n   char\t\t\t\tlast_set_sign_bit_copies;\n-  ENUM_BITFIELD(machine_mode)\tlast_set_mode : 8; \n+  ENUM_BITFIELD(machine_mode)\tlast_set_mode : 8;\n \n   /* Set nonzero if references to register n in expressions should not be\n      used.  last_set_invalid is set nonzero when this register is being\n@@ -243,6 +243,19 @@ struct reg_stat {\n   unsigned char\t\t\tsign_bit_copies;\n \n   unsigned HOST_WIDE_INT\tnonzero_bits;\n+\n+  /* Record the value of the label_tick when the last truncation\n+     happened.  The field truncated_to_mode is only valid if\n+     truncation_label == label_tick.  */\n+\n+  int\t\t\t\ttruncation_label;\n+\n+  /* Record the last truncation seen for this register.  If truncation\n+     is not a nop to this mode we might be able to save an explicit\n+     truncation if we know that value already contains a truncated\n+     value.  */\n+\n+  ENUM_BITFIELD(machine_mode)\ttruncated_to_mode : 8; \n };\n \n static struct reg_stat *reg_stat;\n@@ -407,7 +420,7 @@ static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n static void record_value_for_reg (rtx, rtx, rtx);\n-static void check_promoted_subreg (rtx, rtx);\n+static void check_conversions (rtx, rtx);\n static void record_dead_and_set_regs_1 (rtx, rtx, void *);\n static void record_dead_and_set_regs (rtx);\n static int get_last_value_validate (rtx *, rtx, int, int);\n@@ -424,6 +437,9 @@ static int insn_cuid (rtx);\n static void record_promoted_value (rtx, rtx);\n static int unmentioned_reg_p_1 (rtx *, void *);\n static bool unmentioned_reg_p (rtx, rtx);\n+static void record_truncated_value (rtx);\n+static bool reg_truncated_to_mode (enum machine_mode, rtx);\n+static rtx gen_lowpart_or_truncate (enum machine_mode, rtx);\n \f\n \n /* It is not safe to use ordinary gen_lowpart in combine.\n@@ -790,7 +806,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t    {\n \t      /* See if we know about function return values before this\n \t\t insn based upon SUBREG flags.  */\n-\t      check_promoted_subreg (insn, PATTERN (insn));\n+\t      check_conversions (insn, PATTERN (insn));\n \n \t      /* Try this insn with each insn it links back to.  */\n \n@@ -5989,6 +6005,11 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       && ! (spans_byte && inner_mode != tmode)\n       && ((pos_rtx == 0 && (pos % BITS_PER_WORD) == 0\n \t   && !MEM_P (inner)\n+\t   && (inner_mode == tmode\n+\t       || !REG_P (inner)\n+\t       || TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (tmode),\n+\t\t\t\t\t GET_MODE_BITSIZE (inner_mode))\n+\t       || reg_truncated_to_mode (tmode, inner))\n \t   && (! in_dest\n \t       || (REG_P (inner)\n \t\t   && have_insn_for (STRICT_LOW_PART, tmode))))\n@@ -6758,6 +6779,22 @@ canon_reg_for_combine (rtx x, rtx reg)\n   return x;\n }\n \n+/* Return X converted to MODE.  If the value is already truncated to\n+   MODE we can just return a subreg even though in the general case we\n+   would need an explicit truncation.  */\n+\n+static rtx\n+gen_lowpart_or_truncate (enum machine_mode mode, rtx x)\n+{\n+  if (GET_MODE_SIZE (GET_MODE (x)) <= GET_MODE_SIZE (mode)\n+      || TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n+\t\t\t\tGET_MODE_BITSIZE (GET_MODE (x)))\n+      || (REG_P (x) && reg_truncated_to_mode (mode, x)))\n+    return gen_lowpart (mode, x);\n+  else\n+    return gen_rtx_TRUNCATE (mode, x);\n+}\n+\n /* See if X can be simplified knowing that we will only refer to it in\n    MODE and will only refer to those bits that are nonzero in MASK.\n    If other bits are being computed or if masking operations are done\n@@ -7023,11 +7060,11 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* For most binary operations, just propagate into the operation and\n \t change the mode if we have an operation of that mode.  */\n \n-      op0 = gen_lowpart (op_mode,\n-\t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\tnext_select));\n-      op1 = gen_lowpart (op_mode,\n-\t\t\t force_to_mode (XEXP (x, 1), mode, mask,\n+      op0 = gen_lowpart_or_truncate (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\t\t    next_select));\n+      op1 = gen_lowpart_or_truncate (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 1), mode, mask,\n \t\t\t\t\tnext_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n@@ -7060,9 +7097,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       else\n \tmask = fuller_mask;\n \n-      op0 = gen_lowpart (op_mode,\n-\t\t\t force_to_mode (XEXP (x, 0), op_mode,\n-\t\t\t\t\tmask, next_select));\n+      op0 = gen_lowpart_or_truncate (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 0), op_mode,\n+\t\t\t\t\t\t    mask, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = simplify_gen_binary (code, op_mode, op0, XEXP (x, 1));\n@@ -7266,9 +7303,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       mask = fuller_mask;\n \n     unop:\n-      op0 = gen_lowpart (op_mode,\n-\t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\tnext_select));\n+      op0 = gen_lowpart_or_truncate (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\t\t    next_select));\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = simplify_gen_unary (code, op_mode, op0, op_mode);\n       break;\n@@ -7291,19 +7328,21 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t written in a narrower mode.  We play it safe and do not do so.  */\n \n       SUBST (XEXP (x, 1),\n-\t     gen_lowpart (GET_MODE (x), force_to_mode (XEXP (x, 1), mode,\n-\t\t\t\t\t\t       mask, next_select)));\n+\t     gen_lowpart_or_truncate (GET_MODE (x),\n+\t\t\t\t      force_to_mode (XEXP (x, 1), mode,\n+\t\t\t\t\t\t     mask, next_select)));\n       SUBST (XEXP (x, 2),\n-\t     gen_lowpart (GET_MODE (x), force_to_mode (XEXP (x, 2), mode,\n-\t\t\t\t\t\t       mask, next_select)));\n+\t     gen_lowpart_or_truncate (GET_MODE (x),\n+\t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n+\t\t\t\t\t\t     mask, next_select)));\n       break;\n \n     default:\n       break;\n     }\n \n   /* Ensure we return a value of the proper mode.  */\n-  return gen_lowpart (mode, x);\n+  return gen_lowpart_or_truncate (mode, x);\n }\n \f\n /* Return nonzero if X is an expression that has one of two values depending on\n@@ -10871,6 +10910,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n       reg_stat[i].last_set_nonzero_bits = 0;\n       reg_stat[i].last_set_sign_bit_copies = 0;\n       reg_stat[i].last_death = 0;\n+      reg_stat[i].truncated_to_mode = 0;\n     }\n \n   /* Mark registers that are being referenced in this value.  */\n@@ -11004,6 +11044,7 @@ record_dead_and_set_regs (rtx insn)\n \t    reg_stat[i].last_set_nonzero_bits = 0;\n \t    reg_stat[i].last_set_sign_bit_copies = 0;\n \t    reg_stat[i].last_death = 0;\n+\t    reg_stat[i].truncated_to_mode = 0;\n \t  }\n \n       last_call_cuid = mem_last_set = INSN_CUID (insn);\n@@ -11067,15 +11108,81 @@ record_promoted_value (rtx insn, rtx subreg)\n     }\n }\n \n-/* Scan X for promoted SUBREGs.  For each one found,\n-   note what it implies to the registers used in it.  */\n+/* Check if X, a register, is known to contain a value already\n+   truncated to MODE.  In this case we can use a subreg to refer to\n+   the truncated value even though in the generic case we would need\n+   an explicit truncation.  */\n+\n+static bool\n+reg_truncated_to_mode (enum machine_mode mode, rtx x)\n+{\n+  enum machine_mode truncated = reg_stat[REGNO (x)].truncated_to_mode;\n+\n+  if (truncated == 0 || reg_stat[REGNO (x)].truncation_label != label_tick)\n+    return false;\n+  if (GET_MODE_SIZE (truncated) <= GET_MODE_SIZE (mode))\n+    return true;\n+  if (TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n+\t\t\t     GET_MODE_BITSIZE (truncated)))\n+    return true;\n+  return false;\n+}\n+\n+/* X is a REG or a SUBREG.  If X is some sort of a truncation record\n+   it.  For non-TRULY_NOOP_TRUNCATION targets we might be able to turn\n+   a truncate into a subreg using this information.  */\n \n static void\n-check_promoted_subreg (rtx insn, rtx x)\n+record_truncated_value (rtx x)\n {\n-  if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n-      && REG_P (SUBREG_REG (x)))\n-    record_promoted_value (insn, x);\n+  enum machine_mode truncated_mode;\n+  \n+  if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x)))\n+    {\n+      enum machine_mode original_mode = GET_MODE (SUBREG_REG (x));\n+      truncated_mode = GET_MODE (x);\n+\n+      if (GET_MODE_SIZE (original_mode) <= GET_MODE_SIZE (truncated_mode))\n+\treturn;\n+\n+      if (TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (truncated_mode),\n+\t\t\t\t GET_MODE_BITSIZE (original_mode)))\n+\treturn;\n+\n+      x = SUBREG_REG (x);\n+    }\n+  /* ??? For hard-regs we now record everthing.  We might be able to\n+     optimize this using last_set_mode.  */\n+  else if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    truncated_mode = GET_MODE (x);\n+  else\n+    return;\n+\n+  if (reg_stat[REGNO (x)].truncated_to_mode == 0\n+      || reg_stat[REGNO (x)].truncation_label < label_tick\n+      || (GET_MODE_SIZE (truncated_mode)\n+\t  < GET_MODE_SIZE (reg_stat[REGNO (x)].truncated_to_mode)))\n+    {\n+      reg_stat[REGNO (x)].truncated_to_mode = truncated_mode;\n+      reg_stat[REGNO (x)].truncation_label = label_tick;\n+    }\n+}\n+\n+/* Scan X for promoted SUBREGs and truncated REGs.  For each one\n+   found, note what it implies to the registers used in it.  */\n+\n+static void\n+check_conversions (rtx insn, rtx x)\n+{\n+  if (GET_CODE (x) == SUBREG || REG_P (x))\n+    {\n+      if (GET_CODE (x) == SUBREG\n+\t  && SUBREG_PROMOTED_VAR_P (x)\n+\t  && REG_P (SUBREG_REG (x)))\n+\trecord_promoted_value (insn, x);\n+\n+      record_truncated_value (x);\n+    }\n   else\n     {\n       const char *format = GET_RTX_FORMAT (GET_CODE (x));\n@@ -11085,13 +11192,13 @@ check_promoted_subreg (rtx insn, rtx x)\n \tswitch (format[i])\n \t  {\n \t  case 'e':\n-\t    check_promoted_subreg (insn, XEXP (x, i));\n+\t    check_conversions (insn, XEXP (x, i));\n \t    break;\n \t  case 'V':\n \t  case 'E':\n \t    if (XVEC (x, i) != 0)\n \t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\tcheck_promoted_subreg (insn, XVECEXP (x, i, j));\n+\t\tcheck_conversions (insn, XVECEXP (x, i, j));\n \t    break;\n \t  }\n     }"}]}