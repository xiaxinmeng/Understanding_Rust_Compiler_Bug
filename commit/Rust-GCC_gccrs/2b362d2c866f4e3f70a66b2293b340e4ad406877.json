{"sha": "2b362d2c866f4e3f70a66b2293b340e4ad406877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzNjJkMmM4NjZmNGUzZjcwYTY2YjIyOTNiMzQwZTRhZDQwNjg3Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T18:09:59Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T18:09:59Z"}, "message": "(truncdfsf2+2): Use f%$move instead of fsmove.\n\n(fix_truncdfsi2, fix_truncdfhi2, fix_truncdfqi2):\nUse %# instead of #.\n\n(call, call_value): Set SYMBOL_REF_FLAG for the called\nfunction symbol_ref rtx.  In PIC mode, output `bsr FUNC@PLTPC'\nwhen the operand is symbol_ref.\n\nFrom-SVN: r3594", "tree": {"sha": "b133b9dbb5012e9014f0f607119e1c865f3f2d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b133b9dbb5012e9014f0f607119e1c865f3f2d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b362d2c866f4e3f70a66b2293b340e4ad406877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b362d2c866f4e3f70a66b2293b340e4ad406877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b362d2c866f4e3f70a66b2293b340e4ad406877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b362d2c866f4e3f70a66b2293b340e4ad406877/comments", "author": null, "committer": null, "parents": [{"sha": "24e3324a7f31b2d6bc87a5501edfde69605dfb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24e3324a7f31b2d6bc87a5501edfde69605dfb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24e3324a7f31b2d6bc87a5501edfde69605dfb5b"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "dc8c45aa286f757ca18f920dd7aac301dd041b38", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b362d2c866f4e3f70a66b2293b340e4ad406877/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b362d2c866f4e3f70a66b2293b340e4ad406877/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=2b362d2c866f4e3f70a66b2293b340e4ad406877", "patch": "@@ -1472,8 +1472,8 @@\n   \"*\n {\n   if (FP_REG_P (operands[1]))\n-    return \\\"fsmove%.x %1,%0\\\";\n-  return \\\"fsmove%.d %f1,%0\\\";\n+    return \\\"f%$move%.x %1,%0\\\";\n+  return \\\"f%$move%.d %f1,%0\\\";\n }\")\n \n (define_insn \"\"\n@@ -1565,7 +1565,7 @@\n   \"*\n {\n   CC_STATUS_INIT;\n-  return \\\"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.l %1,%0\\;fmovem%.l %2,%!\\\";\n+  return \\\"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.l %1,%0\\;fmovem%.l %2,%!\\\";\n }\")\n \n (define_insn \"fix_truncdfhi2\"\n@@ -1577,7 +1577,7 @@\n   \"*\n {\n   CC_STATUS_INIT;\n-  return \\\"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.w %1,%0\\;fmovem%.l %2,%!\\\";\n+  return \\\"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.w %1,%0\\;fmovem%.l %2,%!\\\";\n }\")\n \n (define_insn \"fix_truncdfqi2\"\n@@ -1589,7 +1589,7 @@\n   \"*\n {\n   CC_STATUS_INIT;\n-  return \\\"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.b %1,%0\\;fmovem%.l %2,%!\\\";\n+  return \\\"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.b %1,%0\\;fmovem%.l %2,%!\\\";\n }\")\n \n ;; Convert a float to a float whose value is an integer.\n@@ -4626,6 +4626,31 @@\n ;; We have different patterns for PIC calls and non-PIC calls.  The\n ;; different patterns are only used to choose the right syntax\n ;; (\"jsr\" vs \"jbsr\").\n+;;\n+;; On svr4 m68k, PIC stuff is done differently. To be able to support\n+;; dynamic linker LAZY BINDING, all the procedure calls need to go \n+;; through the PLT (Procedure Linkage Table) section in PIC mode. The \n+;; svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it \n+;; will create the correct relocation entry (R_68K_PLT32) for `FUNC', \n+;; that tells the linker editor to create an entry for `FUNC' in PLT\n+;; section at link time. However, all global objects reference are still\n+;; done by using `OBJ@GOT'. So, the goal here is to output the function \n+;; call operand as `FUNC@PLTPC', but output object operand as `OBJ@GOT'. \n+;; We need to have a way to differentiate these two different operands.\n+;;\n+;; The strategy I use here is to use SYMBOL_REF_FLAG to differentiate \n+;; these two different operands. The macro LEGITIMATE_PIC_OPERAND_P needs\n+;; to be changed to recognize function calls symbol_ref operand as a legal \n+;; PIC operand (by checking whether SYMBOL_REF_FLAG is set). This will \n+;; avoid the compiler to load this symbol_ref operand into a register. \n+;; Remember, the operand \"foo@PLTPC\" cannot be called via jsr directly \n+;; since the value is a PC relative offset, not a real address.\n+;;\n+;; All global objects are treated in the similar way as in SUN3. The only \n+;; difference is: on m68k svr4, the reference of such global object needs \n+;; to end with a suffix \"@GOT\" so the assembler and linker know to create\n+;; an entry for it in GOT (Global Offset Table) section. This is done in \n+;; m68k.c.\n \n ;; Call subroutine with no return value.\n (define_expand \"call\"\n@@ -4637,8 +4662,12 @@\n   \"\n {\n   if (flag_pic && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+#ifdef MOTOROLA\n+    SYMBOL_REF_FLAG (XEXP (operands[0], 0)) = 1;\n+#else\n     operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n \t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+#endif\n }\")\n \n ;; This is a normal call sequence.\n@@ -4664,6 +4693,11 @@\n \n   \"flag_pic\"\n   \"*\n+#ifdef MOTOROLA\n+  if (GET_CODE (operands[0]) == MEM \n+      && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+    return \\\"bsr %0@PLTPC\\\";\n+#endif\n   return \\\"jsr %0\\\";\n \")\n \n@@ -4679,8 +4713,12 @@\n   \"\n {\n   if (flag_pic && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+#ifdef MOTOROLA\n+    SYMBOL_REF_FLAG (XEXP (operands[1], 0)) = 1;\n+#else\n     operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n \t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+#endif\n }\")\n \n ;; This is a normal call_value\n@@ -4706,6 +4744,11 @@\n   ;; Operand 2 not really used on the m68000.\n   \"flag_pic\"\n   \"*\n+#ifdef MOTOROLA\n+  if (GET_CODE (operands[1]) == MEM \n+      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+    return \\\"bsr %1@PLTPC\\\";\n+#endif\n   return \\\"jsr %1\\\";\n \")\n "}]}