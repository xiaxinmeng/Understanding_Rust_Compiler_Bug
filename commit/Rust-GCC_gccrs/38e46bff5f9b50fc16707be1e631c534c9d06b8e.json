{"sha": "38e46bff5f9b50fc16707be1e631c534c9d06b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhlNDZiZmY1ZjliNTBmYzE2NzA3YmUxZTYzMWM1MzRjOWQwNmI4ZQ==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2003-08-13T16:49:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2003-08-13T16:49:58Z"}, "message": "Font.java: Stub out more recent API.\n\n2003-08-12  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/awt/Font.java:\n\tStub out more recent API.\n\nFrom-SVN: r70404", "tree": {"sha": "f7a2e53cdb69762bdba4d82c0846666a221accc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a2e53cdb69762bdba4d82c0846666a221accc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38e46bff5f9b50fc16707be1e631c534c9d06b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e46bff5f9b50fc16707be1e631c534c9d06b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e46bff5f9b50fc16707be1e631c534c9d06b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e46bff5f9b50fc16707be1e631c534c9d06b8e/comments", "author": null, "committer": null, "parents": [{"sha": "d0cf60ccdb9ce676eacbe9ee25a2429aed523f96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cf60ccdb9ce676eacbe9ee25a2429aed523f96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cf60ccdb9ce676eacbe9ee25a2429aed523f96"}], "stats": {"total": 789, "additions": 784, "deletions": 5}, "files": [{"sha": "7395873dfb8e6c5ef6f7f33ef309f8662dbb225e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e46bff5f9b50fc16707be1e631c534c9d06b8e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e46bff5f9b50fc16707be1e631c534c9d06b8e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=38e46bff5f9b50fc16707be1e631c534c9d06b8e", "patch": "@@ -1,3 +1,8 @@\n+2003-08-12  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/awt/Font.java: \n+\tStub out more recent API. \n+\n 2003-08-12  Graydon Hoare  <graydon@redhat.com>\n \n \t* java/awt/Color.java (getAlpha): "}, {"sha": "d1ff566e5592813b64a3c17ead9fd7fb74dad861", "filename": "libjava/java/awt/Font.java", "status": "modified", "additions": 779, "deletions": 5, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e46bff5f9b50fc16707be1e631c534c9d06b8e/libjava%2Fjava%2Fawt%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e46bff5f9b50fc16707be1e631c534c9d06b8e/libjava%2Fjava%2Fawt%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFont.java?ref=38e46bff5f9b50fc16707be1e631c534c9d06b8e", "patch": "@@ -39,10 +39,20 @@\n package java.awt;\n \n import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n import java.awt.font.LineMetrics;\n+import java.awt.font.TextAttribute;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n import java.awt.peer.FontPeer;\n+import java.io.InputStream;\n+import java.io.IOException;\n import java.io.Serializable;\n+import java.util.Locale;\n+import java.util.Map;\n import java.util.StringTokenizer;\n+import java.text.CharacterIterator;\n+import java.text.AttributedCharacterIterator;\n \n /**\n   * This class represents a windowing system font.\n@@ -72,9 +82,20 @@ public class Font implements Serializable\n   */\n public static final int ITALIC = 2;\n \n+/**\n+ * Constant indicating the baseline mode characteristic of Roman.\n+ */\n public static final int ROMAN_BASELINE = 0;\n+\n+/**\n+ * Constant indicating the baseline mode characteristic of Chinese.\n+ */\n public static final int CENTER_BASELINE = 1;\n-public static final int HANGING_BASELINE = 2;\n+\n+/**\n+ * Constant indicating the baseline mode characteristic of Devanigri.\n+ */\n+public static final int HANGING_BASELINE = 2;  \n \n \n   /**\n@@ -294,16 +315,28 @@ public class Font implements Serializable\n   this.pointSize = size;\n }\n \n+public  \n+Font(Map attributes)\n+{\n+  throw new UnsupportedOperationException();\n+}\n+\n /*************************************************************************/\n \n /*\n  * Instance Methods\n  */\n \n /**\n-  * Returns the name of the font.\n+  * Returns the logical name of the font.  A logical name describes a very\n+  * general typographic style (such as Sans Serif). It is less specific\n+  * than both a font family name (such as Helvetica) and a font face name\n+  * (such as Helvetica Bold).\n   *\n-  * @return The name of the font.\n+  * @return The logical name of the font.\n+  *\n+  * @see getFamily()\n+  * @see getFontName()\n   */\n public String\n getName()\n@@ -385,9 +418,18 @@ public class Font implements Serializable\n /*************************************************************************/\n \n /**\n-  * Returns the system specific font family name.\n+  * Returns the family name of this font. A family name describes a\n+  * typographic style (such as Helvetica or Palatino). It is more specific\n+  * than a logical font name (such as Sans Serif) but less specific than a\n+  * font face name (such as Helvetica Bold).\n+  *\n+  * @return A string containing the font family name.\n+  *\n+  * @since 1.2\n   *\n-  * @return The system specific font family name.\n+  * @see getName()\n+  * @see getFontName()\n+  * @see GraphicsEnvironment.getAvailableFontFamilyNames()\n   */\n public String\n getFamily()\n@@ -396,12 +438,744 @@ public class Font implements Serializable\n   return(name);\n }\n \n+/**\n+  * Returns integer code representing the sum of style flags of this font, a\n+  * combination of either {@link PLAIN}, {@link BOLD}, or {@link ITALIC}.\n+  *\n+  * @return code representing the style of this font.\n+  *\n+  * @see isPlain()\n+  * @see isBold()\n+  * @see isItalic()\n+  */\n public int\n getStyle()\n {\n   return style;\n }\n \n+/**\n+  * Checks if specified character maps to a glyph in this font.\n+  *\n+  * @param c The character to check.\n+  *\n+  * @return Whether the character has a corresponding glyph in this font.\n+  *\n+  * @since 1.2\n+  */\n+public boolean \n+canDisplay(char c)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Checks how much of a given string can be mapped to glyphs in \n+  * this font.\n+  *\n+  * @param s The string to check.\n+  *\n+  * @return The index of the first character in <code>s</code> which cannot\n+  * be converted to a glyph by this font, or <code>-1</code> if all\n+  * characters can be mapped to glyphs.\n+  *\n+  * @since 1.2\n+  */\n+public int \n+canDisplayUpTo(String s)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Checks how much of a given sequence of text can be mapped to glyphs in\n+  * this font.\n+  *\n+  * @param text Array containing the text to check.\n+  * @param start Position of first character to check in <code>text</code>.\n+  * @param limit Position of last character to check in <code>text</code>.\n+  *\n+  * @return The index of the first character in the indicated range which\n+  * cannot be converted to a glyph by this font, or <code>-1</code> if all\n+  * characters can be mapped to glyphs.\n+  *\n+  * @since 1.2\n+  *\n+  * @throws IndexOutOfBoundsException if the range [start, limit] is\n+  * invalid in <code>text</code>.\n+  */\n+public int\n+canDisplayUpTo(char[] text, int start, int limit)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Checks how much of a given sequence of text can be mapped to glyphs in\n+  * this font.\n+  *\n+  * @param i Iterator over the text to check.\n+  * @param start Position of first character to check in <code>i</code>.\n+  * @param limit Position of last character to check in <code>i</code>.\n+  *\n+  * @return The index of the first character in the indicated range which\n+  * cannot be converted to a glyph by this font, or <code>-1</code> if all\n+  * characters can be mapped to glyphs.\n+  *\n+  * @since 1.2\n+  *\n+  * @throws IndexOutOfBoundsException if the range [start, limit] is\n+  * invalid in <code>i</code>.\n+  */\n+public int\n+canDisplayUpTo(CharacterIterator i, int start, int limit)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Creates a new font with point size 1 and {@link PLAIN} style,\n+  * reading font data from the provided input stream. The resulting font\n+  * can have further fonts derived from it using its\n+  * <code>deriveFont</code> method.\n+  *\n+  * @param fontFormat Integer code indicating the format the font data is\n+  * in.Currently this can only be {@link TRUETYPE_FONT}.\n+  * @param is {@link InputStream} from which font data will be read. This\n+  * stream is not closed after font data is extracted.\n+  *\n+  * @return A new {@link Font} of the format indicated.\n+  *\n+  * @throws IllegalArgumentException if <code>fontType</code> is not\n+  * recognized.\n+  * @throws FontFormatException if data in InputStream is not of format\n+  * indicated.\n+  * @throws IOException if insufficient data is present on InputStream.\n+  *\n+  * @since 1.3\n+  */\n+public static Font \n+createFont(int fontFormat, InputStream is) \n+  throws FontFormatException, IOException\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Maps characters to glyphs in a one-to-one relationship, returning a new\n+  * {@link GlyphVector} with a mapped glyph for each input character. This\n+  * sort of mapping is often sufficient for some scripts such as Roman, but\n+  * is inappropriate for scripts with special shaping or contextual layout\n+  * requirements such as Arabic, Indic, Hebrew or Thai.\n+  *\n+  * @param ctx The rendering context used for precise glyph placement.\n+  * @param str The string to convert to Glyphs.\n+  *\n+  * @return A new {@link GlyphVector} containing glyphs mapped from str,\n+  * through the font's cmap table.\n+  *\n+  * @see layoutGlyphVector()\n+  */\n+public GlyphVector\n+createGlyphVector(FontRenderContext ctx, String str)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Maps characters to glyphs in a one-to-one relationship, returning a new\n+  * {@link GlyphVector} with a mapped glyph for each input character. This\n+  * sort of mapping is often sufficient for some scripts such as Roman, but\n+  * is inappropriate for scripts with special shaping or contextual layout\n+  * requirements such as Arabic, Indic, Hebrew or Thai.\n+  *\n+  * @param ctx The rendering context used for precise glyph placement.\n+  * @param i Iterator over the text to convert to glyphs.\n+  *\n+  * @return A new {@link GlyphVector} containing glyphs mapped from str,\n+  * through the font's cmap table.\n+  *\n+  * @see layoutGlyphVector()\n+  */\n+public GlyphVector\n+createGlyphVector(FontRenderContext ctx, CharacterIterator i)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Maps characters to glyphs in a one-to-one relationship, returning a new\n+  * {@link GlyphVector} with a mapped glyph for each input character. This\n+  * sort of mapping is often sufficient for some scripts such as Roman, but\n+  * is inappropriate for scripts with special shaping or contextual layout\n+  * requirements such as Arabic, Indic, Hebrew or Thai.\n+  *\n+  * @param ctx The rendering context used for precise glyph placement.\n+  * @param chars Array of characters to convert to glyphs.\n+  *\n+  * @return A new {@link GlyphVector} containing glyphs mapped from str,\n+  * through the font's cmap table.\n+  *\n+  * @see layoutGlyphVector()\n+  */\n+public GlyphVector\n+createGlyphVector(FontRenderContext ctx, char[] chars)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Extracts a sequence of glyphs from a font, returning a new {@link\n+  * GlyphVector} with a mapped glyph for each input glyph code. \n+  *\n+  * @param ctx The rendering context used for precise glyph placement.\n+  * @param chars Array of characters to convert to glyphs.\n+  *\n+  * @return A new {@link GlyphVector} containing glyphs mapped from str,\n+  * through the font's cmap table.\n+  *\n+  * @see layoutGlyphVector()\n+  *\n+  * @specnote This method is documented to perform character-to-glyph\n+  * conversions, in the Sun documentation, but its second parameter name is\n+  * \"glyphCodes\" and it is not clear to me why it would exist if its\n+  * purpose was to transport character codes inside integers. I assume it\n+  * is mis-documented in the Sun documentation.\n+  */\n+public GlyphVector\n+createGlyphVector(FontRenderContext ctx, int[] glyphCodes)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Produces a new {@link Font} based on the current font, adjusted to a\n+  * new size.\n+  *\n+  * @param size The size of the newly created font.\n+  *\n+  * @return A clone of the current font, with the specified size.\n+  *\n+  * @since 1.2\n+  */\n+public Font\n+deriveFont(float size)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Produces a new {@link Font} based on the current font, adjusted to a\n+  * new style.\n+  *\n+  * @param style The style of the newly created font.\n+  *\n+  * @return A clone of the current font, with the specified style.\n+  *\n+  * @since 1.2\n+  */\n+public Font\n+deriveFont(int style)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Produces a new {@link Font} based on the current font, adjusted to a\n+  * new style and subjected to a new affine transformation.\n+  *\n+  * @param style The style of the newly created font.\n+  * @param a The transformation to apply.\n+  *\n+  * @return A clone of the current font, with the specified style and\n+  * transform.\n+  *\n+  * @throws IllegalArgumentException If transformation is\n+  * <code>null</code>.\n+  *\n+  * @since 1.2\n+  */\n+public Font\n+deriveFont(int style, AffineTransform a)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Produces a new {@link Font} based on the current font, adjusted to a\n+  * new set of attributes.\n+  *\n+  * @param attributes Attributes of the newly created font.\n+  *\n+  * @return A clone of the current font, with the specified attributes.\n+  *\n+  * @since 1.2\n+  */\n+public Font\n+deriveFont(Map attributes)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a map of chracter attributes which this font currently has set.\n+  *\n+  * @return A map of chracter attributes which this font currently has set.\n+  *\n+  * @see getAvailableAttributes()\n+  * @see java.text.AttributedCharacterIterator.Attribute\n+  * @see java.awt.font.TextAttribute\n+  */\n+public Map\n+getAttributes()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns an array of chracter attribute keys which this font understands. \n+  *\n+  * @return An array of chracter attribute keys which this font understands.\n+  *\n+  * @see getAttributes()\n+  * @see java.text.AttributedCharacterIterator.Attribute\n+  * @see java.awt.font.TextAttribute\n+  */\n+public AttributedCharacterIterator.Attribute[]\n+getAvailableAttributes()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a baseline code (one of {@link ROMAN_BASELINE}, {@link\n+  * CENTER_BASELINE} or {@link HANGING_BASELINE}) indicating which baseline\n+  * this font will measure baseline offsets for, when presenting glyph\n+  * metrics for a given character.\n+  *\n+  * Baseline offsets describe the position of a glyph relative to an\n+  * invisible line drawn under, through the center of, or over a line of\n+  * rendered text, respectively. Different scripts use different baseline\n+  * modes, so clients should not assume all baseline offsets in a glyph\n+  * vector are from a common baseline.\n+  *\n+  * @param c The character code to select a baseline mode for.\n+  *\n+  * @return The baseline mode which would be used in a glyph associated\n+  * with the provided character.\n+  *\n+  * @since 1.2\n+  *\n+  * @see LineMetrics.getBaselineOffsets()\n+  */\n+public byte \n+getBaselineFor(char c)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the family name of this font. A family name describes a\n+  * typographic style (such as Helvetica or Palatino). It is more specific\n+  * than a logical font name (such as Sans Serif) but less specific than a\n+  * font face name (such as Helvetica Bold).\n+  *\n+  * @param lc The locale in which to describe the name of the font family.\n+  *\n+  * @return A string containing the font family name, localized for the\n+  * provided locale.\n+  *\n+  * @since 1.2\n+  *\n+  * @see getName()\n+  * @see getFontName()\n+  * @see GraphicsEnvironment.getAvailableFontFamilyNames()\n+  * @see Locale\n+  */\n+public String\n+getFamily(Locale lc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a font appropriate for the given attribute set.\n+  *\n+  * @param attributes The attributes required for the new font.\n+  *\n+  * @return A new Font with the given attributes.\n+  *\n+  * @since 1.2\n+  *\n+  * @see TextAttribure  \n+  */\n+public static Font\n+getFont(Map attributes)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the font face name of the font.  A font face name describes a\n+  * specific variant of a font family (such as Helvetica Bold). It is more\n+  * specific than both a font family name (such as Helvetica) and a logical\n+  * font name (such as Sans Serif).\n+  *\n+  * @return The font face name of the font.\n+  *\n+  * @since 1.2\n+  *\n+  * @see getName()\n+  * @see getFamily()\n+  */\n+public String\n+getFontName()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the font face name of the font.  A font face name describes a\n+  * specific variant of a font family (such as Helvetica Bold). It is more\n+  * specific than both a font family name (such as Helvetica) and a logical\n+  * font name (such as Sans Serif).\n+  *\n+  * @param lc The locale in which to describe the name of the font face.\n+  *\n+  * @return A string containing the font face name, localized for the\n+  * provided locale.\n+  *\n+  * @since 1.2\n+  *\n+  * @see getName()\n+  * @see getFamily()\n+  */\n+public String\n+getFontName(Locale lc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the italic angle of this font, a measurement of its slant when\n+  * style is {@link ITALIC}. The precise meaning is the inverse slope of a\n+  * caret line which \"best measures\" the font's italic posture.\n+  *\n+  * @return The italic angle.\n+  *\n+  * @see TextAttribute.POSTURE\n+  */\n+public float\n+getItalicAngle()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a {@link LineMetrics} object constructed with the specified\n+  * text and {@link FontRenderContext}. \n+  *\n+  * @param text The string to calculate metrics from.\n+  * @param begin Index of first character in <code>text</code> to measure.\n+  * @param limit Index of last character in <code>text</code> to measure.\n+  * @param rc Context for calculating precise glyph placement and hints.\n+  *\n+  * @return A new {@link LineMetrics} object.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>text</code>.\n+  */\n+public LineMetrics\n+getLineMetrics(String text, int begin, int limit, FontRenderContext rc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a {@link LineMetrics} object constructed with the specified\n+  * text and {@link FontRenderContext}. \n+  *\n+  * @param chars The string to calculate metrics from.\n+  * @param begin Index of first character in <code>text</code> to measure.\n+  * @param limit Index of last character in <code>text</code> to measure.\n+  * @param rc Context for calculating precise glyph placement and hints.\n+  *\n+  * @return A new {@link LineMetrics} object.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>chars</code>.\n+  */\n+public LineMetrics\n+getLineMetrics(char[] chars, int begin, int limit, FontRenderContext rc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a {@link LineMetrics} object constructed with the specified\n+  * text and {@link FontRenderContext}. \n+  *\n+  * @param ci The string to calculate metrics from.\n+  * @param begin Index of first character in <code>text</code> to measure.\n+  * @param limit Index of last character in <code>text</code> to measure.\n+  * @param rc Context for calculating precise glyph placement and hints.\n+  *\n+  * @return A new {@link LineMetrics} object.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>ci</code>.\n+  */\n+public LineMetrics\n+getLineMetrics(CharacterIterator ci, int begin, int limit, FontRenderContext rc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the maximal bounding box of all the bounding boxes in this\n+  * font, when the font's bounding boxes are evaluated in a given {@link\n+  * FontRenderContext}\n+  *\n+  * @param rc Context in which to evaluate bounding boxes.\n+  *\n+  * @return The maximal bounding box.\n+  */\n+public Rectangle2D\n+getMaxCharBounds(FontRenderContext rc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the glyph code this font uses to represent missing glyphs. This\n+  * code will be present in glyph vectors when the font was unable to\n+  * locate a glyph to represent a particular character code.\n+  *\n+  * @return The missing glyph code.\n+  *\n+  * @since 1.2\n+  */\n+public int\n+getMissingGlyphCode()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the overall number of glyphs in this font. This number is one\n+  * more than the greatest glyph code used in any glyph vectors this font\n+  * produces. In other words, glyph codes are taken from the range\n+  * <code>[ 0, getNumGlyphs() - 1 ]</code>.\n+  *\n+  * @return The number of glyphs in this font.\n+  * \n+  * @since 1.2\n+  */\n+public int\n+getNumGlyphs()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the PostScript Name of this font.   \n+  *\n+  * @return The PostScript Name of this font.\n+  *\n+  * @since 1.2\n+  *\n+  * @see getName()\n+  * @see getFamily()\n+  * @see getFontName()\n+  */\n+public String\n+getPSName()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the logical bounds of the specified string when rendered with this\n+  * font in the specified {@link FontRenderContext}. This box will include the\n+  * glyph origin, ascent, advance, height, and leading, but may not include all\n+  * diacritics or accents. To get the complete visual bounding box of all the\n+  * glyphs in a run of text, use the {@link TextLayout#getBounds} method of\n+  * {@link TextLayout}.\n+  *\n+  * @param str The string to measure.\n+  * @param frc The context in which to make the precise glyph measurements.\n+  * \n+  * @return A bounding box covering the logical bounds of the specified text.\n+  *\n+  * @see createGlyphVector()\n+  */\n+public Rectangle2D\n+getStringBounds(String str, FontRenderContext frc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the logical bounds of the specified string when rendered with this\n+  * font in the specified {@link FontRenderContext}. This box will include the\n+  * glyph origin, ascent, advance, height, and leading, but may not include all\n+  * diacritics or accents. To get the complete visual bounding box of all the\n+  * glyphs in a run of text, use the {@link TextLayout#getBounds} method of\n+  * {@link TextLayout}.\n+  *\n+  * @param str The string to measure.\n+  * @param begin Index of the first character in <code>str</code> to measure.\n+  * @param limit Index of the last character in <code>str</code> to measure.\n+  * @param frc The context in which to make the precise glyph measurements.\n+  * \n+  * @return A bounding box covering the logical bounds of the specified text.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>str</code>.\n+  *\n+  * @since 1.2\n+  *\n+  * @see createGlyphVector()\n+  */\n+public Rectangle2D\n+getStringBounds(String str, int begin, int limit, FontRenderContext frc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the logical bounds of the specified string when rendered with this\n+  * font in the specified {@link FontRenderContext}. This box will include the\n+  * glyph origin, ascent, advance, height, and leading, but may not include all\n+  * diacritics or accents. To get the complete visual bounding box of all the\n+  * glyphs in a run of text, use the {@link TextLayout#getBounds} method of\n+  * {@link TextLayout}.\n+  *\n+  * @param ci The text to measure.\n+  * @param begin Index of the first character in <code>ci</code> to measure.\n+  * @param limit Index of the last character in <code>ci</code> to measure.\n+  * @param frc The context in which to make the precise glyph measurements.\n+  * \n+  * @return A bounding box covering the logical bounds of the specified text.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>ci</code>.\n+  *\n+  * @since 1.2\n+  *\n+  * @see createGlyphVector()\n+  */\n+public Rectangle2D\n+getStringBounds(CharacterIterator ci, int begin, int limit, FontRenderContext frc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns the logical bounds of the specified string when rendered with this\n+  * font in the specified {@link FontRenderContext}. This box will include the\n+  * glyph origin, ascent, advance, height, and leading, but may not include all\n+  * diacritics or accents. To get the complete visual bounding box of all the\n+  * glyphs in a run of text, use the {@link TextLayout#getBounds} method of\n+  * {@link TextLayout}.\n+  *\n+  * @param chars The text to measure.\n+  * @param begin Index of the first character in <code>ci</code> to measure.\n+  * @param limit Index of the last character in <code>ci</code> to measure.\n+  * @param frc The context in which to make the precise glyph measurements.\n+  * \n+  * @return A bounding box covering the logical bounds of the specified text.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>chars</code>.\n+  *\n+  * @since 1.2\n+  *\n+  * @see createGlyphVector()\n+  */\n+public Rectangle2D\n+getStringBounds(char[] chars, int begin, int limit, FontRenderContext frc)\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Returns a copy of the affine transformation this font is currently\n+  * subject to, if any.\n+  *\n+  * @return The current transformation.\n+ */\n+public AffineTransform\n+getTransform()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Indicates whether this font's line metrics are uniform. A font may be\n+  * composed of several \"subfonts\", each covering a different code range,\n+  * and each with their own line metrics. A font with no subfonts, or\n+  * subfonts with identical line metrics, is said to have \"uniform\" line\n+  * metrics.\n+  *\n+  * @return Whether this font has uniform line metrics.\n+  *\n+  * @see LineMetrics\n+  * @see getLineMetrics()\n+  */\n+public boolean\n+hasUniformLineMetrics()\n+{\n+  throw new UnsupportedOperationException ();\n+}\n+\n+/**\n+  * Indicates whether this font is subject to a non-identity affine\n+  * transformation.\n+  *\n+  * @return <code>true</code> iff the font has a non-identity affine\n+  * transformation applied to it.\n+  */\n+public boolean\n+isTransformed()\n+{\n+  throw new UnsupportedOperationException ();  \n+}\n+\n+/**\n+  * Produces a glyph vector representing a full layout fo the specified\n+  * text in this font. Full layouts may include complex shaping and\n+  * reordering operations, for scripts such as Arabic or Hindi.\n+  *\n+  * Bidirectional (bidi) layout is not performed in this method; text\n+  * should have its bidi direction specified with one of the flags {@link\n+  * LAYOUT_LEFT_TO_RIGHT} or {@link LAYOUT_RIGHT_TO_LEFT}.\n+  *\n+  * Some types of layout (notably Arabic glyph shaping) may examine context\n+  * characters beyond the bounds of the indicated range, in order to select\n+  * an appropriate shape. The flags {@link LAYOUT_NO_START_CONTEXT} and\n+  * {@link LAYOUT_NO_LIMIT_CONTEXT} can be provided to prevent these extra\n+  * context areas from being examined, for instance if they contain invalid\n+  * characters.\n+  *\n+  * @param frc Context in which to perform the layout.\n+  * @param chars Text to perform layout on.\n+  * @param start Index of first character to perform layout on.\n+  * @param limit Index of last character to perform layout on.\n+  * @param flags Combination of flags controlling layout.\n+  *\n+  * @return A new {@link GlyphVector} representing the specified text.\n+  *\n+  * @throws IndexOutOfBoundsException if the range [begin, limit] is\n+  * invalid in <code>chars</code>. \n+  */\n+public GlyphVector\n+layoutGlyphVector(FontRenderContext frc, char[] chars, int start, int limit, int flags)\n+{\n+  throw new UnsupportedOperationException ();  \n+}\n+\n+\n /*************************************************************************/\n \n /**"}]}