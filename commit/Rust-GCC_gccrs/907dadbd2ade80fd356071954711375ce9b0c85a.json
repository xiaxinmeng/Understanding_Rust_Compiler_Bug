{"sha": "907dadbd2ade80fd356071954711375ce9b0c85a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA3ZGFkYmQyYWRlODBmZDM1NjA3MTk1NDcxMTM3NWNlOWIwYzg1YQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-11-20T15:10:49Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-11-20T15:10:49Z"}, "message": "remove more ggc htabs\n\ngcc/\n\n\t* ipa-utils.c, lto-section-in.c, lto-streamer.h,\n\ttree-scalar-evolution.c: Replace htab with hash_table.\n\nlto/\n\n\t* lto.c: Replace htab with hash_table.\n\nFrom-SVN: r217871", "tree": {"sha": "0e6aa4b2c49f7ab4a703ab71a3335cb58bcb19c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e6aa4b2c49f7ab4a703ab71a3335cb58bcb19c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/907dadbd2ade80fd356071954711375ce9b0c85a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907dadbd2ade80fd356071954711375ce9b0c85a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/907dadbd2ade80fd356071954711375ce9b0c85a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907dadbd2ade80fd356071954711375ce9b0c85a/comments", "author": null, "committer": null, "parents": [{"sha": "9c71e9df38dc3260fc21d8e8024b53d6dd3f7ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c71e9df38dc3260fc21d8e8024b53d6dd3f7ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c71e9df38dc3260fc21d8e8024b53d6dd3f7ac3"}], "stats": {"total": 178, "additions": 75, "deletions": 103}, "files": [{"sha": "8c70fadd2a88dc6ebb5324a73c58e765fe1a4ca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -1,3 +1,8 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* ipa-utils.c, lto-section-in.c, lto-streamer.h,\n+\ttree-scalar-evolution.c: Replace htab with hash_table.\n+\n 2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* lto-section-in.c (lto_delete_in_decl_state): Adjust."}, {"sha": "7613205f6735a6e7a93565ff81be080b32a126db", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -438,17 +438,17 @@ ipa_merge_profiles (struct cgraph_node *dst,\n      temporarily inconsistent.  */\n   if (src->decl == dst->decl)\n     {\n-      void **slot;\n       struct lto_in_decl_state temp;\n       struct lto_in_decl_state *state;\n \n       /* We are going to move the decl, we want to remove its file decl data.\n \t and link these with the new decl. */\n       temp.fn_decl = src->decl;\n-      slot = htab_find_slot (src->lto_file_data->function_decl_states,\n-\t\t\t     &temp, NO_INSERT);\n-      state = (lto_in_decl_state *)*slot;\n-      htab_clear_slot (src->lto_file_data->function_decl_states, slot);\n+      lto_in_decl_state **slot\n+\t= src->lto_file_data->function_decl_states->find_slot (&temp,\n+\t\t\t\t\t\t\t       NO_INSERT);\n+      state = *slot;\n+      src->lto_file_data->function_decl_states->clear_slot (slot);\n       gcc_assert (state);\n \n       /* Duplicate the decl and be sure it does not link into body of DST.  */\n@@ -461,8 +461,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       /* Associate the decl state with new declaration, so LTO streamer\n  \t can look it up.  */\n       state->fn_decl = src->decl;\n-      slot = htab_find_slot (src->lto_file_data->function_decl_states,\n-\t\t\t     state, INSERT);\n+      slot\n+\t= src->lto_file_data->function_decl_states->find_slot (state, INSERT);\n       gcc_assert (!*slot);\n       *slot = state;\n     }"}, {"sha": "3ccdfb93fe0e68255bd5afdb08d8395016ddffd1", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -384,29 +384,6 @@ lto_delete_in_decl_state (struct lto_in_decl_state *state)\n   ggc_free (state);\n }\n \n-/* Hashtable helpers. lto_in_decl_states are hash by their function decls. */\n-\n-hashval_t\n-lto_hash_in_decl_state (const void *p)\n-{\n-  const struct lto_in_decl_state *state = (const struct lto_in_decl_state *) p;\n-  return htab_hash_pointer (state->fn_decl);\n-}\n-\n-/* Return true if the fn_decl field of the lto_in_decl_state pointed to by\n-   P1 equals to the function decl P2. */\n-\n-int\n-lto_eq_in_decl_state (const void *p1, const void *p2)\n-{\n-  const struct lto_in_decl_state *state1 =\n-   (const struct lto_in_decl_state *) p1;\n-  const struct lto_in_decl_state *state2 =\n-   (const struct lto_in_decl_state *) p2;\n-  return state1->fn_decl == state2->fn_decl;\n-}\n-\n-\n /* Search the in-decl state of a function FUNC contained in the file\n    associated with FILE_DATA.  Return NULL if not found.  */\n \n@@ -415,11 +392,11 @@ lto_get_function_in_decl_state (struct lto_file_decl_data *file_data,\n \t\t\t\ttree func)\n {\n   struct lto_in_decl_state temp;\n-  void **slot;\n+  lto_in_decl_state **slot;\n \n   temp.fn_decl = func;\n-  slot = htab_find_slot (file_data->function_decl_states, &temp, NO_INSERT);\n-  return slot? ((struct lto_in_decl_state*) *slot) : NULL;\n+  slot = file_data->function_decl_states->find_slot (&temp, NO_INSERT);\n+  return slot? *slot : NULL;\n }\n \n /* Free decl_states.  */\n@@ -440,19 +417,18 @@ void\n lto_free_function_in_decl_state_for_node (symtab_node *node)\n {\n   struct lto_in_decl_state temp;\n-  void **slot;\n+  lto_in_decl_state **slot;\n \n   if (!node->lto_file_data)\n     return;\n \n   temp.fn_decl = node->decl;\n-  slot = htab_find_slot (node->lto_file_data->function_decl_states,\n-\t\t\t &temp, NO_INSERT);\n+  slot\n+    = node->lto_file_data->function_decl_states->find_slot (&temp, NO_INSERT);\n   if (slot && *slot)\n     {\n-      lto_free_function_in_decl_state ((struct lto_in_decl_state*) *slot);\n-      htab_clear_slot (node->lto_file_data->function_decl_states,\n-\t\t       slot);\n+      lto_free_function_in_decl_state (*slot);\n+      node->lto_file_data->function_decl_states->clear_slot (slot);\n     }\n   node->lto_file_data = NULL;\n }"}, {"sha": "d67f05816a0ffe44b54269ec2033ac7108f33a9c", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -430,7 +430,7 @@ struct lto_tree_ref_encoder\n \n \n /* Structure to hold states of input scope.  */\n-struct GTY(()) lto_in_decl_state\n+struct GTY((for_user)) lto_in_decl_state\n {\n   /* Array of lto_in_decl_buffers to store type and decls streams. */\n   vec<tree, va_gc> *streams[LTO_N_DECL_STREAMS];\n@@ -442,6 +442,20 @@ struct GTY(()) lto_in_decl_state\n \n typedef struct lto_in_decl_state *lto_in_decl_state_ptr;\n \n+struct decl_state_hasher : ggc_hasher<lto_in_decl_state *>\n+{\n+  static hashval_t\n+  hash (lto_in_decl_state *s)\n+  {\n+    return htab_hash_pointer (s->fn_decl);\n+  }\n+\n+  static bool\n+  equal (lto_in_decl_state *a, lto_in_decl_state *b)\n+  {\n+    return a->fn_decl == b->fn_decl;\n+  }\n+};\n \n /* The structure that holds all of the vectors of global types,\n    decls and cgraph nodes used in the serialization of this file.  */\n@@ -488,7 +502,7 @@ struct GTY(()) lto_file_decl_data\n   lto_symtab_encoder_t GTY((skip)) symtab_node_encoder;\n \n   /* Hash table maps lto-related section names to location in file.  */\n-  htab_t GTY((param_is (struct lto_in_decl_state))) function_decl_states;\n+  hash_table<decl_state_hasher> *function_decl_states;\n \n   /* The .o file that these offsets relate to.  */\n   const char *GTY((skip)) file_name;\n@@ -687,8 +701,6 @@ extern const char *lto_get_decl_name_mapping (struct lto_file_decl_data *,\n \t\t\t\t\t      const char *);\n extern struct lto_in_decl_state *lto_new_in_decl_state (void);\n extern void lto_delete_in_decl_state (struct lto_in_decl_state *);\n-extern hashval_t lto_hash_in_decl_state (const void *);\n-extern int lto_eq_in_decl_state (const void *, const void *);\n extern struct lto_in_decl_state *lto_get_function_in_decl_state (\n \t\t\t\t      struct lto_file_decl_data *, tree);\n extern void lto_free_function_in_decl_state (struct lto_in_decl_state *);"}, {"sha": "fa96f4825ca5f6abcc7ab79ecae4c8fc0252e21e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -1,3 +1,7 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto.c: Replace htab with hash_table.\n+\n 2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* lto.c (lto_read_in_decl_state): Adjust."}, {"sha": "a1cd9581bb2a263ad7b8efbd9b4dd4c23a62d23d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -1980,15 +1980,15 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \n   /* Read in per-function decl states and enter them in hash table.  */\n   decl_data->function_decl_states =\n-    htab_create_ggc (37, lto_hash_in_decl_state, lto_eq_in_decl_state, NULL);\n+    hash_table<decl_state_hasher>::create_ggc (37);\n \n   for (i = 1; i < num_decl_states; i++)\n     {\n       struct lto_in_decl_state *state = lto_new_in_decl_state ();\n-      void **slot;\n \n       data_ptr = lto_read_in_decl_state (data_in, data_ptr, state);\n-      slot = htab_find_slot (decl_data->function_decl_states, state, INSERT);\n+      lto_in_decl_state **slot\n+\t= decl_data->function_decl_states->find_slot (state, INSERT);\n       gcc_assert (*slot == NULL);\n       *slot = state;\n     }\n@@ -2817,17 +2817,6 @@ lto_fixup_state (struct lto_in_decl_state *state)\n     }\n }\n \n-/* A callback of htab_traverse. Just extracts a state from SLOT\n-   and calls lto_fixup_state. */\n-\n-static int\n-lto_fixup_state_aux (void **slot, void *aux ATTRIBUTE_UNUSED)\n-{\n-  struct lto_in_decl_state *state = (struct lto_in_decl_state *) *slot;\n-  lto_fixup_state (state);\n-  return 1;\n-}\n-\n /* Fix the decls from all FILES. Replaces each decl with the corresponding\n    prevailing one.  */\n \n@@ -2847,7 +2836,11 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n       struct lto_in_decl_state *state = file->global_decl_state;\n       lto_fixup_state (state);\n \n-      htab_traverse (file->function_decl_states, lto_fixup_state_aux, NULL);\n+      hash_table<decl_state_hasher>::iterator iter;\n+      lto_in_decl_state *elt;\n+      FOR_EACH_HASH_TABLE_ELEMENT (*file->function_decl_states, elt,\n+\t\t\t\t   lto_in_decl_state *, iter)\n+\tlto_fixup_state (elt);\n     }\n }\n "}, {"sha": "5183cb8785dac85829ca8aee85ac5473cfeae3a2", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907dadbd2ade80fd356071954711375ce9b0c85a/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=907dadbd2ade80fd356071954711375ce9b0c85a", "patch": "@@ -307,7 +307,7 @@ static tree analyze_scalar_evolution_for_address_of (struct loop *loop,\n    claiming that below basic block with index INSTANTIATED_BELOW, the\n    value of the SSA name can be expressed as CHREC.  */\n \n-struct GTY(()) scev_info_str {\n+struct GTY((for_user)) scev_info_str {\n   unsigned int name_version;\n   int instantiated_below;\n   tree chrec;\n@@ -332,7 +332,13 @@ tree chrec_dont_know;\n    happen, then it qualifies it with chrec_known.  */\n tree chrec_known;\n \n-static GTY ((param_is (struct scev_info_str))) htab_t scalar_evolution_info;\n+struct scev_info_hasher : ggc_hasher<scev_info_str *>\n+{\n+  static hashval_t hash (scev_info_str *i);\n+  static bool equal (const scev_info_str *a, const scev_info_str *b);\n+};\n+\n+static GTY (()) hash_table<scev_info_hasher> *scalar_evolution_info;\n \n \f\n /* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n@@ -352,34 +358,21 @@ new_scev_info_str (basic_block instantiated_below, tree var)\n \n /* Computes a hash function for database element ELT.  */\n \n-static inline hashval_t\n-hash_scev_info (const void *elt_)\n+hashval_t\n+scev_info_hasher::hash (scev_info_str *elt)\n {\n-  const struct scev_info_str *elt = (const struct scev_info_str *) elt_;\n   return elt->name_version ^ elt->instantiated_below;\n }\n \n /* Compares database elements E1 and E2.  */\n \n-static inline int\n-eq_scev_info (const void *e1, const void *e2)\n+bool\n+scev_info_hasher::equal (const scev_info_str *elt1, const scev_info_str *elt2)\n {\n-  const struct scev_info_str *elt1 = (const struct scev_info_str *) e1;\n-  const struct scev_info_str *elt2 = (const struct scev_info_str *) e2;\n-\n   return (elt1->name_version == elt2->name_version\n \t  && elt1->instantiated_below == elt2->instantiated_below);\n }\n \n-/* Deletes database element E.  */\n-\n-static void\n-del_scev_info (void *e)\n-{\n-  ggc_free (e);\n-}\n-\n-\n /* Get the scalar evolution of VAR for INSTANTIATED_BELOW basic block.\n    A first query on VAR returns chrec_not_analyzed_yet.  */\n \n@@ -388,15 +381,14 @@ find_var_scev_info (basic_block instantiated_below, tree var)\n {\n   struct scev_info_str *res;\n   struct scev_info_str tmp;\n-  PTR *slot;\n \n   tmp.name_version = SSA_NAME_VERSION (var);\n   tmp.instantiated_below = instantiated_below->index;\n-  slot = htab_find_slot (scalar_evolution_info, &tmp, INSERT);\n+  scev_info_str **slot = scalar_evolution_info->find_slot (&tmp, INSERT);\n \n   if (!*slot)\n     *slot = new_scev_info_str (instantiated_below, var);\n-  res = (struct scev_info_str *) *slot;\n+  res = *slot;\n \n   return &res->chrec;\n }\n@@ -2209,7 +2201,7 @@ static inline hashval_t\n hash_idx_scev_info (const void *elt_)\n {\n   unsigned idx = ((size_t) elt_) - 2;\n-  return hash_scev_info (&global_cache->entries[idx]);\n+  return scev_info_hasher::hash (&global_cache->entries[idx]);\n }\n \n /* Compares database elements E1 and E2.  */\n@@ -2218,7 +2210,8 @@ static inline int\n eq_idx_scev_info (const void *e1, const void *e2)\n {\n   unsigned idx1 = ((size_t) e1) - 2;\n-  return eq_scev_info (&global_cache->entries[idx1], e2);\n+  return scev_info_hasher::equal (&global_cache->entries[idx1],\n+\t\t\t\t  (const scev_info_str *) e2);\n }\n \n /* Returns from CACHE the slot number of the cached chrec for NAME.  */\n@@ -2237,7 +2230,7 @@ get_instantiated_value_entry (instantiate_cache_type &cache,\n   e.name_version = SSA_NAME_VERSION (name);\n   e.instantiated_below = instantiate_below->index;\n   void **slot = htab_find_slot_with_hash (cache.map, &e,\n-\t\t\t\t\t  hash_scev_info (&e), INSERT);\n+\t\t\t\t\t  scev_info_hasher::hash (&e), INSERT);\n   if (!*slot)\n     {\n       e.chrec = chrec_not_analyzed_yet;\n@@ -3052,7 +3045,7 @@ dump_chrecs_stats (FILE *file, struct chrec_stats *stats)\n \t   stats->nb_undetermined);\n   fprintf (file, \"-----------------------------------------\\n\");\n   fprintf (file, \"%d\\tchrecs in the scev database\\n\",\n-\t   (int) htab_elements (scalar_evolution_info));\n+\t   (int) scalar_evolution_info->elements ());\n   fprintf (file, \"%d\\tsets in the scev database\\n\", nb_set_scev);\n   fprintf (file, \"%d\\tgets in the scev database\\n\", nb_get_scev);\n   fprintf (file, \"-----------------------------------------\\n\");\n@@ -3118,19 +3111,6 @@ gather_chrec_stats (tree chrec, struct chrec_stats *stats)\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Callback for htab_traverse, gathers information on chrecs in the\n-   hashtable.  */\n-\n-static int\n-gather_stats_on_scev_database_1 (void **slot, void *stats)\n-{\n-  struct scev_info_str *entry = (struct scev_info_str *) *slot;\n-\n-  gather_chrec_stats (entry->chrec, (struct chrec_stats *) stats);\n-\n-  return 1;\n-}\n-\n /* Classify the chrecs of the whole database.  */\n \n void\n@@ -3143,8 +3123,11 @@ gather_stats_on_scev_database (void)\n \n   reset_chrecs_counters (&stats);\n \n-  htab_traverse (scalar_evolution_info, gather_stats_on_scev_database_1,\n-\t\t &stats);\n+  hash_table<scev_info_hasher>::iterator iter;\n+  scev_info_str *elt;\n+  FOR_EACH_HASH_TABLE_ELEMENT (*scalar_evolution_info, elt, scev_info_str *,\n+\t\t\t       iter)\n+    gather_chrec_stats (elt->chrec, &stats);\n \n   dump_chrecs_stats (dump_file, &stats);\n }\n@@ -3174,8 +3157,7 @@ scev_initialize (void)\n {\n   struct loop *loop;\n \n-  scalar_evolution_info = htab_create_ggc (100, hash_scev_info, eq_scev_info,\n-\t\t\t\t\t   del_scev_info);\n+  scalar_evolution_info = hash_table<scev_info_hasher>::create_ggc (100);\n \n   initialize_scalar_evolutions_analyzer ();\n \n@@ -3202,7 +3184,7 @@ scev_reset_htab (void)\n   if (!scalar_evolution_info)\n     return;\n \n-  htab_empty (scalar_evolution_info);\n+  scalar_evolution_info->empty ();\n }\n \n /* Cleans up the information cached by the scalar evolutions analysis\n@@ -3297,7 +3279,7 @@ scev_finalize (void)\n {\n   if (!scalar_evolution_info)\n     return;\n-  htab_delete (scalar_evolution_info);\n+  scalar_evolution_info->empty ();\n   scalar_evolution_info = NULL;\n }\n "}]}