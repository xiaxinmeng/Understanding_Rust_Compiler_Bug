{"sha": "0a578fee772469fe17168079f48b5b1a37b30522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE1NzhmZWU3NzI0NjlmZTE3MTY4MDc5ZjQ4YjViMWEzN2IzMDUyMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-17T01:28:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-17T01:28:57Z"}, "message": "Makefile.in (insn-extract.o): Fix dependencies.\n\n\t* Makefile.in (insn-extract.o): Fix dependencies.\n\t* genextract.c (main): Generate includes for insn-config.h and\n\trecog.h.\n\tDelete generation of declarations which are now in recog.h.\n\t* genrecog.c (main): Delete generation of definitions which are\n\tnow in recog.c.\n\t* local-alloc.c (block_alloc): Use extract_insn and the variables\n\tit sets up instead of looking up values by insn_code.\n\t* recog.c (recog_operand, recog_operand_loc, recog_dup_loc,\n\trecog_dup_num): Define here instead of generating the definition in\n\tgenrecog.c.\n\t(recog_n_operands, recog_n_dups, recog_n_alternatives,\n\trecog_operand_mode, recog_constraints, recog_operand_address_p):\n\tNew variables.\n\t(extract_insn): New function.\n\t* recog.h (extract_insn): Declare function.\n\t(which_alternative, recog_n_operands, recog_n_dups,\n\trecog_n_alternatives, recog_operand_mode, recog_constraints,\n\trecog_operand_address_p): Declare variables.\n\t* regclass.c (n_occurrences): New static function.\n\t* reload.c (n_occurrences): Delete function.\n\t(find_reloads): Use extract_insn.\n\t* reload.h (n_occurrences): Delete declaration.\n\nFrom-SVN: r23147", "tree": {"sha": "1c32cb74e56fdcc9e94bba84731ea49ea1e5910f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c32cb74e56fdcc9e94bba84731ea49ea1e5910f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a578fee772469fe17168079f48b5b1a37b30522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a578fee772469fe17168079f48b5b1a37b30522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a578fee772469fe17168079f48b5b1a37b30522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a578fee772469fe17168079f48b5b1a37b30522/comments", "author": null, "committer": null, "parents": [{"sha": "e02bdac1315357e99067a279385d0e39fa66ee33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02bdac1315357e99067a279385d0e39fa66ee33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02bdac1315357e99067a279385d0e39fa66ee33"}], "stats": {"total": 397, "additions": 236, "deletions": 161}, "files": [{"sha": "9907808cdf394f58f6886c3e7b25eeb0d83628ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -1,3 +1,29 @@\n+Sat Oct 17 02:26:03 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de> \n+\n+\t* Makefile.in (insn-extract.o): Fix dependencies.\n+\t* genextract.c (main): Generate includes for insn-config.h and\n+\trecog.h.\n+\tDelete generation of declarations which are now in recog.h.\n+\t* genrecog.c (main): Delete generation of definitions which are\n+\tnow in recog.c.\n+\t* local-alloc.c (block_alloc): Use extract_insn and the variables\n+\tit sets up instead of looking up values by insn_code.\n+\t* recog.c (recog_operand, recog_operand_loc, recog_dup_loc,\n+\trecog_dup_num): Define here instead of generating the definition in\n+\tgenrecog.c.\n+\t(recog_n_operands, recog_n_dups, recog_n_alternatives,\n+\trecog_operand_mode, recog_constraints, recog_operand_address_p):\n+\tNew variables.\n+\t(extract_insn): New function.\n+\t* recog.h (extract_insn): Declare function.\n+\t(which_alternative, recog_n_operands, recog_n_dups,\n+\trecog_n_alternatives, recog_operand_mode, recog_constraints,\n+\trecog_operand_address_p): Declare variables.\n+\t* regclass.c (n_occurrences): New static function.\n+\t* reload.c (n_occurrences): Delete function.\n+\t(find_reloads): Use extract_insn.\n+\t* reload.h (n_occurrences): Delete declaration.\n+\n Sat Oct 17 01:17:51 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reload1.c (reload_as_needed): Fix test for when to call"}, {"sha": "7d01d8b6ead57e0a9da8ff91e35962aa67267533", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -1627,7 +1627,8 @@ s-opinit : $(md_file) genopinit $(srcdir)/move-if-change\n \t$(srcdir)/move-if-change tmp-opinit.c insn-opinit.c\n \ttouch s-opinit\n \n-insn-extract.o : insn-extract.c $(CONFIG_H) $(RTL_H) system.h toplev.h\n+insn-extract.o : insn-extract.c $(CONFIG_H) $(RTL_H) system.h toplev.h \\\n+  insn-config.h recog.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-extract.c\n \n insn-extract.c: s-extract ; @true"}, {"sha": "a1e48ed92ea9409a72212b84a3902bd932f4e374", "filename": "gcc/genextract.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -460,17 +460,14 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n   printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"insn-config.h\\\"\\n\");\n+  printf (\"#include \\\"recog.h\\\"\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\\n\");\n \n   /* This variable exists only so it can be the \"location\"\n      of any missing operand whose numbers are skipped by a given pattern.  */\n   printf (\"static rtx junk ATTRIBUTE_UNUSED;\\n\");\n \n-  printf (\"extern rtx recog_operand[];\\n\");\n-  printf (\"extern rtx *recog_operand_loc[];\\n\");\n-  printf (\"extern rtx *recog_dup_loc[];\\n\");\n-  printf (\"extern char recog_dup_num[];\\n\");\n-\n   printf (\"void\\ninsn_extract (insn)\\n\");\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");"}, {"sha": "ee33a0c189ef20cff97958e7e907eb93bd8642cd", "filename": "gcc/genrecog.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -1802,10 +1802,6 @@ from the machine description file `md'.  */\\n\\n\");\n \n   printf (\"*/\\n\\n\");\n \n-  printf (\"rtx recog_operand[MAX_RECOG_OPERANDS];\\n\\n\");\n-  printf (\"rtx *recog_operand_loc[MAX_RECOG_OPERANDS];\\n\\n\");\n-  printf (\"rtx *recog_dup_loc[MAX_DUP_OPERANDS];\\n\\n\");\n-  printf (\"char recog_dup_num[MAX_DUP_OPERANDS];\\n\\n\");\n   printf (\"#define operands recog_operand\\n\\n\");\n \n   next_subroutine_number = 0;"}, {"sha": "f26167ffd1fc966c8dd93d5c173ae8455eea66ec", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -955,13 +955,11 @@ block_alloc (b)\n \t  register rtx r0, r1;\n \t  int combined_regno = -1;\n \t  int i;\n-\t  int insn_code_number = recog_memoized (insn);\n \n \t  this_insn_number = insn_number;\n \t  this_insn = insn;\n \n-\t  if (insn_code_number >= 0)\n-\t    insn_extract (insn);\n+\t  extract_insn (insn);\n \t  which_alternative = -1;\n \n \t  /* Is this insn suitable for tying two registers?\n@@ -982,11 +980,11 @@ block_alloc (b)\n \n \t     If tying is done, WIN is set nonzero.  */\n \n-\t  if (insn_code_number >= 0\n+\t  if (1\n #ifdef REGISTER_CONSTRAINTS\n-\t      && insn_n_operands[insn_code_number] > 1\n-\t      && insn_operand_constraint[insn_code_number][0][0] == '='\n-\t      && insn_operand_constraint[insn_code_number][0][1] != '&'\n+\t      && recog_n_operands > 1\n+\t      && recog_constraints[0][0] == '='\n+\t      && recog_constraints[0][1] != '&'\n #else\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && rtx_equal_p (SET_DEST (PATTERN (insn)), recog_operand[0])\n@@ -1000,19 +998,19 @@ block_alloc (b)\n \t\t operand 0.  */\n \t      int n_matching_alts = 0;\n \n-\t      for (i = 1; i < insn_n_operands[insn_code_number]; i++)\n+\t      for (i = 1; i < recog_n_operands; i++)\n \t\t{\n-\t\t  char *p = insn_operand_constraint[insn_code_number][i];\n+\t\t  char *p = recog_constraints[i];\n \t\t  int this_match = (requires_inout (p));\n \n \t\t  n_matching_alts += this_match;\n-\t\t  if (this_match == insn_n_alternatives[insn_code_number])\n+\t\t  if (this_match == recog_n_alternatives)\n \t\t    must_match_0 = i;\n \t\t}\n #endif\n \n \t      r0 = recog_operand[0];\n-\t      for (i = 1; i < insn_n_operands[insn_code_number]; i++)\n+\t      for (i = 1; i < recog_n_operands; i++)\n \t\t{\n #ifdef REGISTER_CONSTRAINTS\n \t\t  /* Skip this operand if we found an operand that\n@@ -1021,19 +1019,18 @@ block_alloc (b)\n \n \t\t  if (must_match_0 >= 0 && i != must_match_0\n \t\t      && ! (i == must_match_0 + 1\n-\t\t\t    && insn_operand_constraint[insn_code_number][i-1][0] == '%')\n+\t\t\t    && recog_constraints[i-1][0] == '%')\n \t\t      && ! (i == must_match_0 - 1\n-\t\t\t    && insn_operand_constraint[insn_code_number][i][0] == '%'))\n+\t\t\t    && recog_constraints[i][0] == '%'))\n \t\t    continue;\n \n \t\t  /* Likewise if each alternative has some operand that\n \t\t     must match operand zero.  In that case, skip any \n \t\t     operand that doesn't list operand 0 since we know that\n \t\t     the operand always conflicts with operand 0.  We\n \t\t     ignore commutatity in this case to keep things simple.  */\n-\t\t  if (n_matching_alts == insn_n_alternatives[insn_code_number]\n-\t\t      && (0 == requires_inout\n-\t\t\t  (insn_operand_constraint[insn_code_number][i])))\n+\t\t  if (n_matching_alts == recog_n_alternatives\n+\t\t      && 0 == requires_inout (recog_constraints[i]))\n \t\t    continue;\n #endif\n \n@@ -1044,9 +1041,9 @@ block_alloc (b)\n \t\t     of them.  */\n \t\t  if (\n #ifdef REGISTER_CONSTRAINTS\n-\t\t      insn_operand_constraint[insn_code_number][i][0] == 'p'\n+\t\t      recog_constraints[i][0] == 'p'\n #else\n-\t\t      insn_operand_address_p[insn_code_number][i]\n+\t\t      recog_operand_address_p[i]\n #endif\n \t\t      )\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)"}, {"sha": "261bb4d164694320db121d33648d7b53d9f64b32", "filename": "gcc/recog.c", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -54,6 +54,45 @@ static rtx *find_constant_term_loc PROTO((rtx *));\n \n int volatile_ok;\n \n+/* The following vectors hold the results from insn_extract.  */\n+\n+/* Indexed by N, gives value of operand N.  */\n+rtx recog_operand[MAX_RECOG_OPERANDS];\n+\n+/* Indexed by N, gives location where operand N was found.  */\n+rtx *recog_operand_loc[MAX_RECOG_OPERANDS];\n+\n+/* Indexed by N, gives location where the Nth duplicate-appearance of\n+   an operand was found.  This is something that matched MATCH_DUP.  */\n+rtx *recog_dup_loc[MAX_RECOG_OPERANDS];\n+\n+/* Indexed by N, gives the operand number that was duplicated in the\n+   Nth duplicate-appearance of an operand.  */\n+char recog_dup_num[MAX_RECOG_OPERANDS];\n+\n+\n+/* The next variables are set up by extract_insn.  */\n+\n+/* The number of operands of the insn.  */\n+int recog_n_operands;\n+\n+/* The number of MATCH_DUPs in the insn.  */\n+int recog_n_dups;\n+\n+/* The number of alternatives in the constraints for the insn.  */\n+int recog_n_alternatives;\n+\n+/* Indexed by N, gives the mode of operand N.  */\n+enum machine_mode recog_operand_mode[MAX_RECOG_OPERANDS];\n+\n+/* Indexed by N, gives the constraint string for operand N.  */\n+char *recog_constraints[MAX_RECOG_OPERANDS];\n+\n+#ifndef REGISTER_CONSTRAINTS\n+/* Indexed by N, nonzero if operand N should be an address.  */\n+char recog_operand_address_p[MAX_RECOG_OPERANDS];\n+#endif\n+\n /* On return from `constrain_operands', indicate which alternative\n    was satisfied.  */\n \n@@ -1656,6 +1695,90 @@ adj_offsettable_operand (op, offset)\n   abort ();\n }\n \f\n+/* Analyze INSN and compute the variables recog_n_operands, recog_n_dups,\n+   recog_n_alternatives, recog_operand, recog_operand_loc, recog_constraints,\n+   recog_operand_mode, recog_dup_loc and recog_dup_num.\n+   If REGISTER_CONSTRAINTS is not defined, also compute\n+   recog_operand_address_p.  */\n+void\n+extract_insn (insn)\n+     rtx insn;\n+{\n+  int i;\n+  int icode;\n+  int noperands;\n+  rtx body = PATTERN (insn);\n+\n+  recog_n_operands = 0;\n+  recog_n_alternatives = 0;\n+  recog_n_dups = 0;\n+\n+  switch (GET_CODE (body))\n+    {\n+    case USE:\n+    case CLOBBER:\n+    case ASM_INPUT:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n+\n+    case SET:\n+    case PARALLEL:\n+    case ASM_OPERANDS:\n+      recog_n_operands = noperands = asm_noperands (body);\n+      if (noperands >= 0)\n+\t{\n+\t  char *p;\n+\t  /* This insn is an `asm' with operands.  */\n+\n+\t  /* expand_asm_operands makes sure there aren't too many operands.  */\n+\t  if (noperands > MAX_RECOG_OPERANDS)\n+\t    abort ();\n+\n+\t  /* Now get the operand values and constraints out of the insn.  */\n+\t  decode_asm_operands (body, recog_operand, recog_operand_loc,\n+\t\t\t       recog_constraints, recog_operand_mode);\n+\t  if (noperands > 0)\n+\t    {\n+\t      char *p =  recog_constraints[0];\n+\t      recog_n_alternatives = 1;\n+\t      while (*p)\n+\t\trecog_n_alternatives += (*p++ == ',');\n+\t    }\n+#ifndef REGISTER_CONSTRAINTS\n+\t  bzero (recog_operand_address_p, sizeof recog_operand_address_p);\n+#endif\n+\t  break;\n+\t}\n+\n+      /* FALLTHROUGH */\n+\n+    default:\n+      /* Ordinary insn: recognize it, get the operands via insn_extract\n+\t and get the constraints.  */\n+\n+      icode = recog_memoized (insn);\n+      if (icode < 0)\n+\tfatal_insn_not_found (insn);\n+\n+      recog_n_operands = noperands = insn_n_operands[icode];\n+      recog_n_alternatives = insn_n_alternatives[icode];\n+      recog_n_dups = insn_n_dups[icode];\n+\n+      insn_extract (insn);\n+\n+      for (i = 0; i < noperands; i++)\n+\t{\n+#ifdef REGISTER_CONSTRAINTS\n+\t  recog_constraints[i] = insn_operand_constraint[icode][i];\n+#else\n+\t  recog_operand_address_p[i] = insn_operand_address_p[icode][i];\n+#endif\n+\t  recog_operand_mode[i] = insn_operand_mode[icode][i];\n+\t}\n+    }\n+}\n+\n #ifdef REGISTER_CONSTRAINTS\n \n /* Check the operands of an insn (found in recog_operands)"}, {"sha": "195efe39264e9ddf9a8b73be0019ecf6d2997f40", "filename": "gcc/recog.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -61,10 +61,15 @@ extern int mode_dependent_address_p\tPROTO((rtx));\n extern int recog\t\t\tPROTO((rtx, rtx, int *));\n extern void add_clobbers\t\tPROTO((rtx, int));\n extern void insn_extract\t\tPROTO((rtx));\n+extern void extract_insn\t\tPROTO((rtx));\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;\n \n+/* Set by constrain_operands to the number of the alternative that\n+   matched.  */\n+extern int which_alternative;\n+\n /* The following vectors hold the results from insn_extract.  */\n \n /* Indexed by N, gives value of operand N.  */\n@@ -81,6 +86,28 @@ extern rtx *recog_dup_loc[];\n    Nth duplicate-appearance of an operand.  */\n extern char recog_dup_num[];\n \n+/* The next variables are set up by extract_insn.  */\n+\n+/* The number of operands of the insn.  */\n+extern int recog_n_operands;\n+\n+/* The number of MATCH_DUPs in the insn.  */\n+extern int recog_n_dups;\n+\n+/* The number of alternatives in the constraints for the insn.  */\n+extern int recog_n_alternatives;\n+\n+/* Indexed by N, gives the mode of operand N.  */\n+extern enum machine_mode recog_operand_mode[];\n+\n+/* Indexed by N, gives the constraint string for operand N.  */\n+extern char *recog_constraints[];\n+\n+#ifndef REGISTER_CONSTRAINTS\n+/* Indexed by N, nonzero if operand N should be an address.  */\n+extern char recog_operand_address_p[];\n+#endif\n+\n /* Access the output function for CODE.  */\n \n #define OUT_FCN(CODE) (*insn_outfun[(int) (CODE)])"}, {"sha": "bfb5fe653454ffadd1cd4509cfa78408308dd346", "filename": "gcc/regclass.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -665,6 +665,7 @@ static int loop_depth;\n \n static int loop_cost;\n \n+static int n_occurrences\tPROTO((int, char *));\n static void record_reg_classes\tPROTO((int, int, rtx *, enum machine_mode *,\n \t\t\t\t       char **, rtx));\n static int copy_cost\t\tPROTO((rtx, enum machine_mode, \n@@ -707,6 +708,18 @@ regclass_init ()\n   prefclass = 0;\n }\n \f\n+/* Return the number of times character C occurs in string S.  */\n+static int\n+n_occurrences (c, s)\n+     int c;\n+     char *s;\n+{\n+  int n = 0;\n+  while (*s)\n+    n += (*s++ == c);\n+  return n;\n+}\n+\n /* This is a pass of the compiler that scans all instructions\n    and calculates the preferred class for each pseudo-register.\n    This information can be accessed later by calling `reg_preferred_class'."}, {"sha": "a60841ff09a9b04bad00c0e0e208f556123ee7c1", "filename": "gcc/reload.c", "status": "modified", "additions": 28, "deletions": 130, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -2156,19 +2156,6 @@ operands_match_p (x, y)\n   return 1 + success_2;\n }\n \f\n-/* Return the number of times character C occurs in string S.  */\n-\n-int\n-n_occurrences (c, s)\n-     int c;\n-     char *s;\n-{\n-  int n = 0;\n-  while (*s)\n-    n += (*s++ == c);\n-  return n;\n-}\n-\f\n /* Describe the range of registers or memory referenced by X.\n    If X is a register, set REG_FLAG and put the first register \n    number into START and the last plus one into END.\n@@ -2442,7 +2429,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   static int last_output_reload_regno = -1;\n \n   this_insn = insn;\n-  this_insn_is_asm = 0;\t\t/* Tentative.  */\n   n_reloads = 0;\n   n_replacements = 0;\n   n_earlyclobbers = 0;\n@@ -2470,85 +2456,36 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   bzero ((char *) secondary_memlocs_elim, sizeof secondary_memlocs_elim);\n #endif\n \n-  /* Find what kind of insn this is.  NOPERANDS gets number of operands.\n-     Make OPERANDS point to a vector of operand values.\n-     Make OPERAND_LOCS point to a vector of pointers to\n-     where the operands were found.\n-     Fill CONSTRAINTS and CONSTRAINTS1 with pointers to the\n-     constraint-strings for this insn.\n-     Return if the insn needs no reload processing.  */\n-\n-  switch (GET_CODE (body))\n-    {\n-    case USE:\n-    case CLOBBER:\n-    case ASM_INPUT:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return 0;\n-\n-    case SET:\n-      /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it\n-\t is cheap to move between them.  If it is not, there may not be an insn\n-\t to do the copy, so we may need a reload.  */\n-      if (GET_CODE (SET_DEST (body)) == REG\n-\t  && REGNO (SET_DEST (body)) < FIRST_PSEUDO_REGISTER\n-\t  && GET_CODE (SET_SRC (body)) == REG\n-\t  && REGNO (SET_SRC (body)) < FIRST_PSEUDO_REGISTER\n-\t  && REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n-\t\t\t\t REGNO_REG_CLASS (REGNO (SET_DEST (body)))) == 2)\n-\treturn 0;\n-    case PARALLEL:\n-    case ASM_OPERANDS:\n-      reload_n_operands = noperands = asm_noperands (body);\n-      if (noperands >= 0)\n-\t{\n-\t  /* This insn is an `asm' with operands.  */\n-\n-\t  insn_code_number = -1;\n-\t  this_insn_is_asm = 1;\n+  /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it\n+     is cheap to move between them.  If it is not, there may not be an insn\n+     to do the copy, so we may need a reload.  */\n+  if (GET_CODE (body) == SET\n+      && GET_CODE (SET_DEST (body)) == REG\n+      && REGNO (SET_DEST (body)) < FIRST_PSEUDO_REGISTER\n+      && GET_CODE (SET_SRC (body)) == REG\n+      && REGNO (SET_SRC (body)) < FIRST_PSEUDO_REGISTER\n+      && REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n+\t\t\t     REGNO_REG_CLASS (REGNO (SET_DEST (body)))) == 2)\n+    return 0;\n \n-\t  /* expand_asm_operands makes sure there aren't too many operands.  */\n-\t  if (noperands > MAX_RECOG_OPERANDS)\n-\t    abort ();\n+  extract_insn (insn);\n \n-\t  /* Now get the operand values and constraints out of the insn.  */\n+  noperands = reload_n_operands = recog_n_operands;\n+  n_alternatives = recog_n_alternatives;\n \n-\t  decode_asm_operands (body, recog_operand, recog_operand_loc,\n-\t\t\t       constraints, operand_mode);\n-\t  if (noperands > 0)\n-\t    {\n-\t      bcopy ((char *) constraints, (char *) constraints1,\n-\t\t     noperands * sizeof (char *));\n-\t      n_alternatives = n_occurrences (',', constraints[0]) + 1;\n-\t    }\n-\t  break;\n-\t}\n+  /* Just return \"no reloads\" if insn has no operands with constraints.  */\n+  if (noperands == 0 || n_alternatives == 0)\n+    return 0;\n \n-    default:\n-      /* Ordinary insn: recognize it, get the operands via insn_extract\n-\t and get the constraints.  */\n+  insn_code_number = INSN_CODE (insn);\n+  this_insn_is_asm = insn_code_number < 0;\n \n-      insn_code_number = recog_memoized (insn);\n-      if (insn_code_number < 0)\n-\tfatal_insn_not_found (insn);\n-\n-      reload_n_operands = noperands = insn_n_operands[insn_code_number];\n-      n_alternatives = insn_n_alternatives[insn_code_number];\n-      /* Just return \"no reloads\" if insn has no operands with constraints.  */\n-      if (n_alternatives == 0)\n-\treturn 0;\n-      insn_extract (insn);\n-      for (i = 0; i < noperands; i++)\n-\t{\n-\t  constraints[i] = constraints1[i]\n-\t    = insn_operand_constraint[insn_code_number][i];\n-\t  operand_mode[i] = insn_operand_mode[insn_code_number][i];\n-\t}\n-    }\n-\n-  if (noperands == 0)\n-    return 0;\n+  bcopy ((char *) recog_operand_mode, (char *) operand_mode,\n+\t noperands * sizeof (enum machine_mode));\n+  bcopy ((char *) recog_constraints, (char *) constraints,\n+\t noperands * sizeof (char *));\n+  bcopy ((char *) constraints, (char *) constraints1,\n+\t noperands * sizeof (char *));\n \n   commutative = -1;\n \n@@ -4272,50 +4209,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   replace_reloads = replace;\n   this_insn = insn;\n \n-  /* Find what kind of insn this is.  NOPERANDS gets number of operands.\n-     Store the operand values in RECOG_OPERAND and the locations\n-     of the words in the insn that point to them in RECOG_OPERAND_LOC.\n-     Return if the insn needs no reload processing.  */\n-\n-  switch (GET_CODE (body))\n-    {\n-    case USE:\n-    case CLOBBER:\n-    case ASM_INPUT:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return;\n+  extract_insn (insn);\n \n-    case PARALLEL:\n-    case SET:\n-      noperands = asm_noperands (body);\n-      if (noperands >= 0)\n-\t{\n-\t  /* This insn is an `asm' with operands.\n-\t     First, find out how many operands, and allocate space.  */\n-\n-\t  insn_code_number = -1;\n-\t  /* ??? This is a bug! ???\n-\t     Give up and delete this insn if it has too many operands.  */\n-\t  if (noperands > MAX_RECOG_OPERANDS)\n-\t    abort ();\n-\n-\t  /* Now get the operand values out of the insn.  */\n-\n-\t  decode_asm_operands (body, recog_operand, recog_operand_loc,\n-\t\t\t       NULL_PTR, NULL_PTR);\n-\t  break;\n-\t}\n-\n-    default:\n-      /* Ordinary insn: recognize it, allocate space for operands and\n-\t constraints, and get them out via insn_extract.  */\n-\n-      insn_code_number = recog_memoized (insn);\n-      noperands = insn_n_operands[insn_code_number];\n-      insn_extract (insn);\n-    }\n+  noperands = reload_n_operands = recog_n_operands;\n \n+  /* Return if the insn needs no reload processing.  */\n   if (noperands == 0)\n     return;\n "}, {"sha": "24e6aa8ccf9ab01d5b7c932b7d72807839d3dbdf", "filename": "gcc/reload.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a578fee772469fe17168079f48b5b1a37b30522/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=0a578fee772469fe17168079f48b5b1a37b30522", "patch": "@@ -247,9 +247,6 @@ extern int remove_address_replacements PROTO((rtx in_rtx));\n    autoincrement and autodecrement.  */\n extern int operands_match_p PROTO((rtx, rtx));\n \n-/* Return the number of times character C occurs in string S.  */\n-extern int n_occurrences PROTO((int, char *));\n-\n /* Return 1 if altering OP will not modify the value of CLOBBER. */\n extern int safe_from_earlyclobber PROTO((rtx, rtx));\n "}]}