{"sha": "2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI0N2Y2ZWQ4ZDY1MmI3ODY2NmE0Y2NmMTliYjBiYTY5MWRmZTdlMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-01-24T15:54:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-24T15:54:35Z"}, "message": "i386.h (PREDICATE_CODES): Add aligned_operand.\n\n\t* i386.h (PREDICATE_CODES): Add aligned_operand.\n\t* i386.c (aligned_operand): New function.\n\t(ix86_aligned_p): Kill.\n\t* i386.md (movhi_1): Emit mov for aligned operands.\n\t(promoting peep2s): Use aligned_operand.\n\nFrom-SVN: r31586", "tree": {"sha": "aca981535f6b2b5bddd1452dd30f43c6c0136054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aca981535f6b2b5bddd1452dd30f43c6c0136054"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/comments", "author": null, "committer": null, "parents": [{"sha": "059fa5e776a738f956ad62692a1a143ba34d86b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059fa5e776a738f956ad62692a1a143ba34d86b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059fa5e776a738f956ad62692a1a143ba34d86b0"}], "stats": {"total": 132, "additions": 74, "deletions": 58}, "files": [{"sha": "40053440e88e53221207c6c6c3758e5215f6be3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "patch": "@@ -1,3 +1,11 @@\n+Mon Jan 24 16:50:08 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (PREDICATE_CODES): Add aligned_operand.\n+\t* i386.c (aligned_operand): New function.\n+\t(ix86_aligned_p): Kill.\n+\t* i386.md (movhi_1): Emit mov for aligned operands.\n+\t(promoting peep2s): Use aligned_operand.\n+\n 2000-01-23  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* fixinc/fixfixes.c (fix_char_macro_uses): Correct regular"}, {"sha": "d589e4f110ae05ac2fae19884e14c2859af25588", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "patch": "@@ -64,6 +64,7 @@ extern int promotable_binary_operator PARAMS ((rtx, enum machine_mode));\n extern int memory_displacement_operand PARAMS ((rtx, enum machine_mode));\n extern int cmpsi_operand PARAMS ((rtx, enum machine_mode));\n extern int long_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int aligned_operand PARAMS ((rtx, enum machine_mode));\n \n \n extern int legitimate_pic_address_disp_p PARAMS ((rtx));"}, {"sha": "320237e8a7a3a37f0b0bc1e779c6ce9cf034a4a7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "patch": "@@ -678,57 +678,6 @@ optimization_options (level, size)\n #endif\n }\n \f\n-/* Return nonzero if the rtx is known aligned.  */\n-/* ??? Unused.  */\n-\n-int\n-ix86_aligned_p (op)\n-     rtx op;\n-{\n-  struct ix86_address parts;\n-\n-  /* Registers and immediate operands are always \"aligned\". */\n-  if (GET_CODE (op) != MEM)\n-    return 1;\n-\n-  /* Don't even try to do any aligned optimizations with volatiles. */\n-  if (MEM_VOLATILE_P (op))\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* Pushes and pops are only valid on the stack pointer.  */\n-  if (GET_CODE (op) == PRE_DEC\n-      || GET_CODE (op) == POST_INC)\n-    return 1;\n-\n-  /* Decode the address.  */\n-  if (! ix86_decompose_address (op, &parts))\n-    abort ();\n-\n-  /* Look for some component that isn't known to be aligned.  */\n-  if (parts.index)\n-    {\n-      if (parts.scale < 4\n-\t  && REGNO_POINTER_ALIGN (REGNO (parts.index)) < 4)\n-\treturn 0;\n-    }\n-  if (parts.base)\n-    {\n-      if (REGNO_POINTER_ALIGN (REGNO (parts.index)) < 4)\n-\treturn 0;\n-    }\n-  if (parts.disp)\n-    {\n-      if (GET_CODE (parts.disp) != CONST_INT\n-\t  || (INTVAL (parts.disp) & 3) != 0)\n-\treturn 0;\n-    }\n-\n-  /* Didn't find one -- this must be an aligned address.  */\n-  return 1;\n-}\n-\f\n /* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n    attribute for DECL.  The attributes in ATTRIBUTES have previously been\n    assigned to DECL.  */\n@@ -1422,6 +1371,60 @@ long_memory_operand (op, mode)\n \n   return memory_address_length (op) != 0;\n }\n+\n+/* Return nonzero if the rtx is known aligned.  */\n+\n+int\n+aligned_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  struct ix86_address parts;\n+\n+  if (!general_operand (op, mode))\n+    return 0;\n+\n+  /* Registers and immediate operands are always \"aligned\". */\n+  if (GET_CODE (op) != MEM)\n+    return 1;\n+\n+  /* Don't even try to do any aligned optimizations with volatiles. */\n+  if (MEM_VOLATILE_P (op))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  /* Pushes and pops are only valid on the stack pointer.  */\n+  if (GET_CODE (op) == PRE_DEC\n+      || GET_CODE (op) == POST_INC)\n+    return 1;\n+\n+  /* Decode the address.  */\n+  if (! ix86_decompose_address (op, &parts))\n+    abort ();\n+\n+  /* Look for some component that isn't known to be aligned.  */\n+  if (parts.index)\n+    {\n+      if (parts.scale < 4\n+\t  && REGNO_POINTER_ALIGN (REGNO (parts.index)) < 4)\n+\treturn 0;\n+    }\n+  if (parts.base)\n+    {\n+      if (REGNO_POINTER_ALIGN (REGNO (parts.base)) < 4)\n+\treturn 0;\n+    }\n+  if (parts.disp)\n+    {\n+      if (GET_CODE (parts.disp) != CONST_INT\n+\t  || (INTVAL (parts.disp) & 3) != 0)\n+\treturn 0;\n+    }\n+\n+  /* Didn't find one -- this must be an aligned address.  */\n+  return 1;\n+}\n \f\n /* Return true if the constant is something that can be loaded with\n    a special instruction.  Only handle 0.0 and 1.0; others are less"}, {"sha": "74cd5d69399eca28e6c044ec123b5bf76d0e0b38", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "patch": "@@ -2400,6 +2400,8 @@ do { long l;\t\t\t\t\t\t\\\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n+  {\"aligned_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n+\t\t       LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n   {\"pic_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n   {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\\n   {\"expander_call_insn_operand\", {MEM}},\t\t\t\t\\"}, {"sha": "fac96f5b5c0e03fd9dc849c15c9044c7f2b79a3a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2247f6ed8d652b78666a4ccf19bb0ba691dfe7e1", "patch": "@@ -1397,7 +1397,8 @@\n     }\n }\"\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"0\")\n+     (cond [(and (eq_attr \"alternative\" \"0,1\")\n+\t\t (match_operand:HI 1 \"aligned_operand\" \"\"))\n \t      (const_string \"imov\")\n \t    (and (ne (symbol_ref \"TARGET_MOVX\")\n \t\t     (const_int 0))\n@@ -1408,9 +1409,10 @@\n     (set (attr \"length_prefix\")\n       (cond [(eq_attr \"type\" \"imovx\")\n \t       (const_string \"0\")\n-\t     (and (eq_attr \"alternative\" \"0\")\n-\t\t  (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n-\t\t      (const_int 0)))\n+\t     (and (eq_attr \"alternative\" \"0,1\")\n+\t\t  (and (match_operand:HI 1 \"aligned_operand\" \"\")\n+\t\t       (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n+\t\t\t   (const_int 0))))\n \t       (const_string \"0\")\n \t    ]\n \t    (const_string \"1\")))\n@@ -8562,7 +8564,7 @@\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(match_operator 3 \"promotable_binary_operator\"\n \t   [(match_operand 1 \"register_operand\" \"\")\n-\t    (match_operand 2 \"nonmemory_operand\" \"\")]))\n+\t    (match_operand 2 \"aligned_operand\" \"\")]))\n    (clobber (reg:CC 17))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    && ((GET_MODE (operands[0]) == HImode \n@@ -8581,7 +8583,7 @@\n \n (define_split\n   [(set (reg:CCNO 17)\n-\t(compare:CCNO (and (match_operand 1 \"register_operand\" \"\")\n+\t(compare:CCNO (and (match_operand 1 \"aligned_operand\" \"\")\n \t\t\t   (match_operand 2 \"immediate_operand\" \"\"))\n \t\t      (const_int 0)))\n    (set (match_operand 0 \"register_operand\" \"\")\n@@ -8601,7 +8603,7 @@\n \n (define_split\n   [(set (reg:CCNO 17)\n-\t(compare:CCNO (and (match_operand 0 \"register_operand\" \"\")\n+\t(compare:CCNO (and (match_operand 0 \"aligned_operand\" \"\")\n \t\t\t   (match_operand 1 \"immediate_operand\" \"\"))\n \t\t      (const_int 0)))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed"}]}