{"sha": "5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmOTFmMDY5MDhjM2E0MGJiYjQzYmMzYTdlNTU0NWZkYzQwNTRkMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-11-25T21:41:28Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-11-25T21:41:28Z"}, "message": "codecvt_members.cc (codecvt::do_length): Rewrite, using both mbsnrtowcs and mbrtowc in a loop...\n\n2003-11-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* config/locale/gnu/codecvt_members.cc (codecvt::do_length):\n\tRewrite, using both mbsnrtowcs and mbrtowc in a loop: the\n\tformer is very fast, but stops if encounters a NUL.\n\t(codecvt::do_out): Tweaks.\n\t(codecvt::do_in): Tweaks, improve the code dealing with errors.\n\t* testsuite/performance/wchar_t_length.cc: New.\n\nFrom-SVN: r73934", "tree": {"sha": "45985c2f94342d3f11fee2776f778115fcfaaa54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45985c2f94342d3f11fee2776f778115fcfaaa54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/comments", "author": null, "committer": null, "parents": [{"sha": "eb459c81bfebbe1f647a70c62e320be93f5a0f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb459c81bfebbe1f647a70c62e320be93f5a0f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb459c81bfebbe1f647a70c62e320be93f5a0f1f"}], "stats": {"total": 174, "additions": 142, "deletions": 32}, "files": [{"sha": "72fd837893c1d90b908054c45b6fb8edd9246b25", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "patch": "@@ -1,3 +1,12 @@\n+2003-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* config/locale/gnu/codecvt_members.cc (codecvt::do_length):\n+\tRewrite, using both mbsnrtowcs and mbrtowc in a loop: the\n+\tformer is very fast, but stops if encounters a NUL.\n+\t(codecvt::do_out): Tweaks.\n+\t(codecvt::do_in): Tweaks, improve the code dealing with errors.\n+\t* testsuite/performance/wchar_t_length.cc: New.\n+\n 2003-11-24  Paolo Carlini  <pcarlini@suse.de>\n \n \t* config/locale/gnu/codecvt_members.cc (codecvt::do_in):"}, {"sha": "aa9fcec684548c42b076e2417e4229bab2941a4f", "filename": "libstdc++-v3/config/locale/gnu/codecvt_members.cc", "status": "modified", "additions": 71, "deletions": 32, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc?ref=5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "patch": "@@ -1,6 +1,6 @@\n // std::codecvt implementation details, GNU version -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -57,17 +57,16 @@ namespace std\n     // wcsnrtombs is *very* fast but stops if encounters NUL characters:\n     // in case we fall back to wcrtomb and then continue, in a loop.\n     // NB: wcsnrtombs is a GNU extension\n-    __from_next = __from;\n-    __to_next = __to;\n-    while (__from_next < __from_end && __to_next < __to_end\n-\t   && __ret == ok)\n+    for (__from_next = __from, __to_next = __to;\n+\t __from_next < __from_end && __to_next < __to_end\n+\t && __ret == ok;)\n       {\n \tconst intern_type* __from_chunk_end = wmemchr(__from_next, L'\\0',\n \t\t\t\t\t\t      __from_end - __from_next);\n \tif (!__from_chunk_end)\n \t  __from_chunk_end = __from_end;\n \n-\tconst intern_type* __tmp_from = __from_next;\n+\t__from = __from_next;\n \tconst size_t __conv = wcsnrtombs(__to_next, &__from_next,\n \t\t\t\t\t __from_chunk_end - __from_next,\n \t\t\t\t\t __to_end - __to_next, &__state);\n@@ -76,9 +75,9 @@ namespace std\n \t    // In case of error, in order to stop at the exact place we\n \t    // have to start again from the beginning with a series of\n \t    // wcrtomb.\n-\t    while (__tmp_from < __from_next)\n-\t      __to_next += wcrtomb(__to_next, *__tmp_from++, &__tmp_state);\n-\t    __state = __tmp_state;\t    \n+\t    for (; __from < __from_next; ++__from)\n+\t      __to_next += wcrtomb(__to_next, *__from, &__tmp_state);\n+\t    __state = __tmp_state;\n \t    __ret = error;\n \t  }\n \telse if (__from_next && __from_next < __from_chunk_end)\n@@ -133,10 +132,9 @@ namespace std\n     // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n     // in case we store a L'\\0' and then continue, in a loop.\n     // NB: mbsnrtowcs is a GNU extension\n-    __from_next = __from;\n-    __to_next = __to;\n-    while (__from_next < __from_end && __to_next < __to_end\n-\t   && __ret == ok)\n+    for (__from_next = __from, __to_next = __to;\n+\t __from_next < __from_end && __to_next < __to_end\n+\t && __ret == ok;)\n       {\n \tconst extern_type* __from_chunk_end;\n \t__from_chunk_end = static_cast<const extern_type*>(memchr(__from_next, '\\0',\n@@ -145,7 +143,7 @@ namespace std\n \tif (!__from_chunk_end)\n \t  __from_chunk_end = __from_end;\n \n-\tconst extern_type* __tmp_from = __from_next;\n+\t__from = __from_next;\n \tconst size_t __conv = mbsnrtowcs(__to_next, &__from_next,\n \t\t\t\t\t __from_chunk_end - __from_next,\n \t\t\t\t\t __to_end - __to_next, &__state);\n@@ -154,9 +152,18 @@ namespace std\n \t    // In case of error, in order to stop at the exact place we\n \t    // have to start again from the beginning with a series of\n \t    // mbrtowc.\n-\t    while (__tmp_from < __from_next)\n-\t      __tmp_from += mbrtowc(__to_next++, __tmp_from,\n-\t\t\t\t    __from_next - __tmp_from, &__tmp_state);\n+\t    for (;;)\n+\t      {\n+\t\tconst size_t __conv_err = mbrtowc(__to_next, __from,\n+\t\t\t\t\t\t  __from_end - __from,\n+\t\t\t\t\t\t  &__tmp_state);\n+\t\tif (__conv_err == static_cast<size_t>(-1)\n+\t\t    || __conv_err == static_cast<size_t>(-2))\n+\t\t  break;\n+\t\t__from += __conv_err;\n+\t\t++__to_next;\n+\t      }\n+\t    __from_next = __from;\n \t    __state = __tmp_state;\t    \n \t    __ret = error;\n \t  }\n@@ -177,6 +184,7 @@ namespace std\n \t    if (__to_next < __to_end)\n \t      {\n \t\t// XXX Probably wrong for stateful encodings\n+\t\t__tmp_state = __state;\t\t\n \t\t++__from_next;\n \t\t*__to_next++ = L'\\0';\n \t      }\n@@ -232,39 +240,70 @@ namespace std\n   {\n     int __ret = 0;\n     state_type __tmp_state(__state);\n+\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __c_locale __old = __uselocale(_M_c_locale_codecvt);\n #endif\n \n+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n+    // in case we advance past it and then continue, in a loop.\n+    // NB: mbsnrtowcs is a GNU extension\n+  \n+    // A dummy internal buffer is needed in order for mbsnrtocws to consider\n+    // its fourth parameter (it wouldn't with NULL as first parameter).\n+    wchar_t* __to = static_cast<wchar_t*>(__builtin_alloca(sizeof(wchar_t) \n+\t\t\t\t\t\t\t   * __max));\n     while (__from < __end && __max)\n       {\n-\tsize_t __conv = mbrtowc(NULL, __from, __end - __from, &__tmp_state);\n+\tconst extern_type* __from_chunk_end;\n+\t__from_chunk_end = static_cast<const extern_type*>(memchr(__from, '\\0',\n+\t\t\t\t\t\t\t\t  __end\n+\t\t\t\t\t\t\t\t  - __from));\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __end;\n+\n+\tconst extern_type* __tmp_from = __from;\n+\tconst size_t __conv = mbsnrtowcs(__to, &__from,\n+\t\t\t\t\t __from_chunk_end - __from,\n+\t\t\t\t\t __max, &__state);\n \tif (__conv == static_cast<size_t>(-1))\n \t  {\n-\t    // Invalid source character\n-\t    break;\n-\t  }\n-\telse if (__conv == static_cast<size_t>(-2))\n-\t  {\n-\t    // Remainder of input does not form a complete destination\n-\t    // character.\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // mbrtowc.\n+\t    for (__from = __tmp_from;;)\n+\t      {\n+\t\tconst size_t __conv_err = mbrtowc(NULL, __from, __end - __from,\n+\t\t\t\t\t\t  &__tmp_state);\n+\t\tif (__conv_err == static_cast<size_t>(-1)\n+\t\t    || __conv_err == static_cast<size_t>(-2))\n+\t\t  break;\n+\t\t__from += __conv_err;\n+\t      }\n+\t    __state = __tmp_state;\n+\t    __ret += __from - __tmp_from;\n \t    break;\n \t  }\n-\telse if (__conv == 0)\n+\tif (!__from)\n+\t  __from = __from_chunk_end;\n+\t\n+\t__ret += __from - __tmp_from;\n+\t__max -= __conv;\n+\n+\tif (__from < __end && __max)\n \t  {\n \t    // XXX Probably wrong for stateful encodings\n-\t    __conv = 1;\n+\t    __tmp_state = __state;\n+\t    ++__from;\n+\t    ++__ret;\n+\t    --__max;\n \t  }\n-\n-\t__state = __tmp_state;\n-\t__from += __conv;\n-\t__ret += __conv;\n-\t__max--;\n       }\n \n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __uselocale(__old);\n #endif\n+\n     return __ret; \n   }\n #endif"}, {"sha": "f0146fe99910a1e12164cd3ca80a50b723ffa856", "filename": "libstdc++-v3/testsuite/performance/wchar_t_length.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_length.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af91f06908c3a40bbb43bc3a7e5545fdc4054d3/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_length.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_length.cc?ref=5af91f06908c3a40bbb43bc3a7e5545fdc4054d3", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdio>\n+#include <cstring>\n+#include <fstream>\n+#include <langinfo.h>\n+#include <iconv.h>\n+#include <testsuite_performance.h>\n+\n+// libstdc++/11602 (do_length)\n+int main(int argc, char** argv)\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+  const int iters = 400000;\n+\n+  char cbuf[1024];\n+  \n+  memset(cbuf, 'a', 1024);\n+\n+  // C++ (codecvt)\n+  locale loc;\n+  const codecvt<wchar_t, char, mbstate_t>& cvt =\n+    use_facet<codecvt<wchar_t, char, mbstate_t> >(loc);\n+  mbstate_t state;\n+  memset(&state, 0, sizeof(state));\n+  start_counters(time, resource);\n+  for (int i = 0; i < iters; ++i)\n+    cvt.length(state, cbuf, cbuf + 1024, 1024);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"C++ (codecvt)\", time, resource);\n+\n+  return 0;\n+}"}]}