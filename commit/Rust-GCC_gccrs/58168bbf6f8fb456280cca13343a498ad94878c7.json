{"sha": "58168bbf6f8fb456280cca13343a498ad94878c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxNjhiYmY2ZjhmYjQ1NjI4MGNjYTEzMzQzYTQ5OGFkOTQ4NzhjNw==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2018-11-06T13:09:52Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2018-11-06T13:09:52Z"}, "message": "2018-11-06  Chung-Lin Tang <cltang@codesourcery.com>\n\n\tReviewed-by: Thomas Schwinge <thomas@codesourcery.com>\n\n\tlibgomp/\n\t* oacc-mem.c (memcpy_tofrom_device): New function, combined from\n\tacc_memcpy_to/from_device functions, now with async parameter.\n\t(acc_memcpy_to_device): Modify to use memcpy_tofrom_device.\n\t(acc_memcpy_from_device): Likewise.\n\t(acc_memcpy_to_device_async): New API function.\n\t(acc_memcpy_from_device_async): Likewise.\n\t(present_create_copy): Add async parameter and async setting/unsetting.\n\t(acc_create): Adjust present_create_copy call.\n\t(acc_copyin): Likewise.\n\t(acc_present_or_create): Likewise.\n\t(acc_present_or_copyin): Likewise.\n\t(acc_create_async): New API function.\n\t(acc_copyin_async): New API function.\n\t(delete_copyout): Add async parameter and async setting/unsetting.\n\t(acc_delete): Adjust delete_copyout call.\n\t(acc_copyout): Likewise.\n\t(acc_delete_async): New API function.\n\t(acc_copyout_async): Likewise.\n\t(update_dev_host): Add async parameter and async setting/unsetting.\n\t(acc_update_device): Adjust update_dev_host call.\n\t(acc_update_self): Likewise.\n\t(acc_update_device_async): New API function.\n\t(acc_update_self_async): Likewise.\n\t* openacc.h (acc_copyin_async): Declare new API function.\n\t(acc_create_async): Likewise.\n\t(acc_copyout_async): Likewise.\n\t(acc_delete_async): Likewise.\n\t(acc_update_device_async): Likewise.\n\t(acc_update_self_async): Likewise.\n\t(acc_memcpy_to_device_async): Likewise.\n\t(acc_memcpy_from_device_async): Likewise.\n\t* openacc_lib.h (acc_copyin_async_32_h): New subroutine.\n\t(acc_copyin_async_64_h): New subroutine.\n\t(acc_copyin_async_array_h): New subroutine.\n\t(acc_create_async_32_h): New subroutine.\n\t(acc_create_async_64_h): New subroutine.\n\t(acc_create_async_array_h): New subroutine.\n\t(acc_copyout_async_32_h): New subroutine.\n\t(acc_copyout_async_64_h): New subroutine.\n\t(acc_copyout_async_array_h): New subroutine.\n\t(acc_delete_async_32_h): New subroutine.\n\t(acc_delete_async_64_h): New subroutine.\n\t(acc_delete_async_array_h): New subroutine.\n\t(acc_update_device_async_32_h): New subroutine.\n\t(acc_update_device_async_64_h): New subroutine.\n\t(acc_update_device_async_array_h): New subroutine.\n\t(acc_update_self_async_32_h): New subroutine.\n\t(acc_update_self_async_64_h): New subroutine.\n\t(acc_update_self_async_array_h): New subroutine.\n\t* openacc.f90 (acc_copyin_async_32_h): New subroutine.\n\t(acc_copyin_async_64_h): New subroutine.\n\t(acc_copyin_async_array_h): New subroutine.\n\t(acc_create_async_32_h): New subroutine.\n\t(acc_create_async_64_h): New subroutine.\n\t(acc_create_async_array_h): New subroutine.\n\t(acc_copyout_async_32_h): New subroutine.\n\t(acc_copyout_async_64_h): New subroutine.\n\t(acc_copyout_async_array_h): New subroutine.\n\t(acc_delete_async_32_h): New subroutine.\n\t(acc_delete_async_64_h): New subroutine.\n\t(acc_delete_async_array_h): New subroutine.\n\t(acc_update_device_async_32_h): New subroutine.\n\t(acc_update_device_async_64_h): New subroutine.\n\t(acc_update_device_async_array_h): New subroutine.\n\t(acc_update_self_async_32_h): New subroutine.\n\t(acc_update_self_async_64_h): New subroutine.\n\t(acc_update_self_async_array_h): New subroutine.\n\t* libgomp.map (OACC_2.5): Add acc_copyin_async*, acc_copyout_async*,\n\tacc_copyout_finalize_async*, acc_create_async*, acc_delete_async*,\n\tacc_delete_finalize_async*, acc_memcpy_from_device_async*,\n\tacc_memcpy_to_device_async*, acc_update_device_async*, and\n\tacc_update_self_async* entries.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-94.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-95.c: New test.\n\t* testsuite/libgomp.oacc-fortran/lib-16.f90: New test.\n\nFrom-SVN: r265842", "tree": {"sha": "7d54fbc4ad86d32bf11c35fbebbe030294a143b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d54fbc4ad86d32bf11c35fbebbe030294a143b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58168bbf6f8fb456280cca13343a498ad94878c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58168bbf6f8fb456280cca13343a498ad94878c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58168bbf6f8fb456280cca13343a498ad94878c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58168bbf6f8fb456280cca13343a498ad94878c7/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd78c6d5b2c7e6e2c6e99032454bc6de8c39d238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd78c6d5b2c7e6e2c6e99032454bc6de8c39d238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd78c6d5b2c7e6e2c6e99032454bc6de8c39d238"}], "stats": {"total": 986, "additions": 953, "deletions": 33}, "files": [{"sha": "81bfc77a0e0fe89e39f4a5ebd0d449a0ccb1fb5a", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -1,3 +1,81 @@\n+2018-11-06  Chung-Lin Tang <cltang@codesourcery.com>\n+\n+\t* oacc-mem.c (memcpy_tofrom_device): New function, combined from\n+\tacc_memcpy_to/from_device functions, now with async parameter.\n+\t(acc_memcpy_to_device): Modify to use memcpy_tofrom_device.\n+\t(acc_memcpy_from_device): Likewise.\n+\t(acc_memcpy_to_device_async): New API function.\n+\t(acc_memcpy_from_device_async): Likewise.\n+\t(present_create_copy): Add async parameter and async setting/unsetting.\n+\t(acc_create): Adjust present_create_copy call.\n+\t(acc_copyin): Likewise.\n+\t(acc_present_or_create): Likewise.\n+\t(acc_present_or_copyin): Likewise.\n+\t(acc_create_async): New API function.\n+\t(acc_copyin_async): New API function.\n+\t(delete_copyout): Add async parameter and async setting/unsetting.\n+\t(acc_delete): Adjust delete_copyout call.\n+\t(acc_copyout): Likewise.\n+\t(acc_delete_async): New API function.\n+\t(acc_copyout_async): Likewise.\n+\t(update_dev_host): Add async parameter and async setting/unsetting.\n+\t(acc_update_device): Adjust update_dev_host call.\n+\t(acc_update_self): Likewise.\n+\t(acc_update_device_async): New API function.\n+\t(acc_update_self_async): Likewise.\n+\t* openacc.h (acc_copyin_async): Declare new API function.\n+\t(acc_create_async): Likewise.\n+\t(acc_copyout_async): Likewise.\n+\t(acc_delete_async): Likewise.\n+\t(acc_update_device_async): Likewise.\n+\t(acc_update_self_async): Likewise.\n+\t(acc_memcpy_to_device_async): Likewise.\n+\t(acc_memcpy_from_device_async): Likewise.\n+\t* openacc_lib.h (acc_copyin_async_32_h): New subroutine.\n+\t(acc_copyin_async_64_h): New subroutine.\n+\t(acc_copyin_async_array_h): New subroutine.\n+\t(acc_create_async_32_h): New subroutine.\n+\t(acc_create_async_64_h): New subroutine.\n+\t(acc_create_async_array_h): New subroutine.\n+\t(acc_copyout_async_32_h): New subroutine.\n+\t(acc_copyout_async_64_h): New subroutine.\n+\t(acc_copyout_async_array_h): New subroutine.\n+\t(acc_delete_async_32_h): New subroutine.\n+\t(acc_delete_async_64_h): New subroutine.\n+\t(acc_delete_async_array_h): New subroutine.\n+\t(acc_update_device_async_32_h): New subroutine.\n+\t(acc_update_device_async_64_h): New subroutine.\n+\t(acc_update_device_async_array_h): New subroutine.\n+\t(acc_update_self_async_32_h): New subroutine.\n+\t(acc_update_self_async_64_h): New subroutine.\n+\t(acc_update_self_async_array_h): New subroutine.\n+\t* openacc.f90 (acc_copyin_async_32_h): New subroutine.\n+\t(acc_copyin_async_64_h): New subroutine.\n+\t(acc_copyin_async_array_h): New subroutine.\n+\t(acc_create_async_32_h): New subroutine.\n+\t(acc_create_async_64_h): New subroutine.\n+\t(acc_create_async_array_h): New subroutine.\n+\t(acc_copyout_async_32_h): New subroutine.\n+\t(acc_copyout_async_64_h): New subroutine.\n+\t(acc_copyout_async_array_h): New subroutine.\n+\t(acc_delete_async_32_h): New subroutine.\n+\t(acc_delete_async_64_h): New subroutine.\n+\t(acc_delete_async_array_h): New subroutine.\n+\t(acc_update_device_async_32_h): New subroutine.\n+\t(acc_update_device_async_64_h): New subroutine.\n+\t(acc_update_device_async_array_h): New subroutine.\n+\t(acc_update_self_async_32_h): New subroutine.\n+\t(acc_update_self_async_64_h): New subroutine.\n+\t(acc_update_self_async_array_h): New subroutine.\n+\t* libgomp.map (OACC_2.5): Add acc_copyin_async*, acc_copyout_async*,\n+\tacc_copyout_finalize_async*, acc_create_async*, acc_delete_async*,\n+\tacc_delete_finalize_async*, acc_memcpy_from_device_async*,\n+\tacc_memcpy_to_device_async*, acc_update_device_async*, and\n+\tacc_update_self_async* entries.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-94.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-95.c: New test.\n+\t* testsuite/libgomp.oacc-fortran/lib-16.f90: New test.\n+\n 2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/82856"}, {"sha": "e3f0c648e45b37e674bddc97a73adc81945a1e3e", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -388,14 +388,48 @@ OACC_2.0.1 {\n \n OACC_2.5 {\n   global:\n+\tacc_copyin_async;\n+\tacc_copyin_async_32_h_;\n+\tacc_copyin_async_64_h_;\n+\tacc_copyin_async_array_h_;\n+\tacc_copyout_async;\n+\tacc_copyout_async_32_h_;\n+\tacc_copyout_async_64_h_;\n+\tacc_copyout_async_array_h_;\n \tacc_copyout_finalize;\n \tacc_copyout_finalize_32_h_;\n \tacc_copyout_finalize_64_h_;\n \tacc_copyout_finalize_array_h_;\n+\tacc_copyout_finalize_async;\n+\tacc_copyout_finalize_async_32_h_;\n+\tacc_copyout_finalize_async_64_h_;\n+\tacc_copyout_finalize_async_array_h_;\n+\tacc_create_async;\n+\tacc_create_async_32_h_;\n+\tacc_create_async_64_h_;\n+\tacc_create_async_array_h_;\n+\tacc_delete_async;\n+\tacc_delete_async_32_h_;\n+\tacc_delete_async_64_h_;\n+\tacc_delete_async_array_h_;\n \tacc_delete_finalize;\n \tacc_delete_finalize_32_h_;\n \tacc_delete_finalize_64_h_;\n \tacc_delete_finalize_array_h_;\n+\tacc_delete_finalize_async;\n+\tacc_delete_finalize_async_32_h_;\n+\tacc_delete_finalize_async_64_h_;\n+\tacc_delete_finalize_async_array_h_;\n+\tacc_memcpy_from_device_async;\n+\tacc_memcpy_to_device_async;\n+\tacc_update_device_async;\n+\tacc_update_device_async_32_h_;\n+\tacc_update_device_async_64_h_;\n+\tacc_update_device_async_array_h_;\n+\tacc_update_self_async;\n+\tacc_update_self_async_32_h_;\n+\tacc_update_self_async_64_h_;\n+\tacc_update_self_async_array_h_;\n } OACC_2.0.1;\n \n GOACC_2.0 {"}, {"sha": "72414b7489714c6405c31b8002d9a6b73199d3ee", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 109, "deletions": 33, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -153,8 +153,9 @@ acc_free (void *d)\n     gomp_fatal (\"error in freeing device memory in %s\", __FUNCTION__);\n }\n \n-void\n-acc_memcpy_to_device (void *d, void *h, size_t s)\n+static void\n+memcpy_tofrom_device (bool from, void *d, void *h, size_t s, int async,\n+\t\t      const char *libfnname)\n {\n   /* No need to call lazy open here, as the device pointer must have\n      been obtained from a routine that did that.  */\n@@ -164,31 +165,49 @@ acc_memcpy_to_device (void *d, void *h, size_t s)\n \n   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     {\n-      memmove (d, h, s);\n+      if (from)\n+\tmemmove (h, d, s);\n+      else\n+\tmemmove (d, h, s);\n       return;\n     }\n \n-  if (!thr->dev->host2dev_func (thr->dev->target_id, d, h, s))\n-    gomp_fatal (\"error in %s\", __FUNCTION__);\n+  if (async > acc_async_sync)\n+    thr->dev->openacc.async_set_async_func (async);\n+\n+  bool ret = (from\n+\t      ? thr->dev->dev2host_func (thr->dev->target_id, h, d, s)\n+\t      : thr->dev->host2dev_func (thr->dev->target_id, d, h, s));\n+\n+  if (async > acc_async_sync)\n+    thr->dev->openacc.async_set_async_func (acc_async_sync);\n+\n+  if (!ret)\n+    gomp_fatal (\"error in %s\", libfnname);\n }\n \n void\n-acc_memcpy_from_device (void *h, void *d, size_t s)\n+acc_memcpy_to_device (void *d, void *h, size_t s)\n {\n-  /* No need to call lazy open here, as the device pointer must have\n-     been obtained from a routine that did that.  */\n-  struct goacc_thread *thr = goacc_thread ();\n+  memcpy_tofrom_device (false, d, h, s, acc_async_sync, __FUNCTION__);\n+}\n \n-  assert (thr && thr->dev);\n+void\n+acc_memcpy_to_device_async (void *d, void *h, size_t s, int async)\n+{\n+  memcpy_tofrom_device (false, d, h, s, async, __FUNCTION__);\n+}\n \n-  if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-    {\n-      memmove (h, d, s);\n-      return;\n-    }\n+void\n+acc_memcpy_from_device (void *h, void *d, size_t s)\n+{\n+  memcpy_tofrom_device (true, d, h, s, acc_async_sync, __FUNCTION__);\n+}\n \n-  if (!thr->dev->dev2host_func (thr->dev->target_id, h, d, s))\n-    gomp_fatal (\"error in %s\", __FUNCTION__);\n+void\n+acc_memcpy_from_device_async (void *h, void *d, size_t s, int async)\n+{\n+  memcpy_tofrom_device (true, d, h, s, async, __FUNCTION__);\n }\n \n /* Return the device pointer that corresponds to host data H.  Or NULL\n@@ -428,7 +447,7 @@ acc_unmap_data (void *h)\n #define FLAG_COPY (1 << 2)\n \n static void *\n-present_create_copy (unsigned f, void *h, size_t s)\n+present_create_copy (unsigned f, void *h, size_t s, int async)\n {\n   void *d;\n   splay_tree_key n;\n@@ -490,11 +509,17 @@ present_create_copy (unsigned f, void *h, size_t s)\n \n       gomp_mutex_unlock (&acc_dev->lock);\n \n+      if (async > acc_async_sync)\n+\tacc_dev->openacc.async_set_async_func (async);\n+\n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,\n \t\t\t   GOMP_MAP_VARS_OPENACC);\n       /* Initialize dynamic refcount.  */\n       tgt->list[0].key->dynamic_refcount = 1;\n \n+      if (async > acc_async_sync)\n+\tacc_dev->openacc.async_set_async_func (acc_async_sync);\n+\n       gomp_mutex_lock (&acc_dev->lock);\n \n       d = tgt->to_free;\n@@ -510,19 +535,32 @@ present_create_copy (unsigned f, void *h, size_t s)\n void *\n acc_create (void *h, size_t s)\n {\n-  return present_create_copy (FLAG_PRESENT | FLAG_CREATE, h, s);\n+  return present_create_copy (FLAG_PRESENT | FLAG_CREATE, h, s, acc_async_sync);\n+}\n+\n+void\n+acc_create_async (void *h, size_t s, int async)\n+{\n+  present_create_copy (FLAG_PRESENT | FLAG_CREATE, h, s, async);\n }\n \n void *\n acc_copyin (void *h, size_t s)\n {\n-  return present_create_copy (FLAG_PRESENT | FLAG_CREATE | FLAG_COPY, h, s);\n+  return present_create_copy (FLAG_PRESENT | FLAG_CREATE | FLAG_COPY, h, s,\n+\t\t\t      acc_async_sync);\n+}\n+\n+void\n+acc_copyin_async (void *h, size_t s, int async)\n+{\n+  present_create_copy (FLAG_PRESENT | FLAG_CREATE | FLAG_COPY, h, s, async);\n }\n \n void *\n acc_present_or_create (void *h, size_t s)\n {\n-  return present_create_copy (FLAG_PRESENT | FLAG_CREATE, h, s);\n+  return present_create_copy (FLAG_PRESENT | FLAG_CREATE, h, s, acc_async_sync);\n }\n \n /* acc_pcreate is acc_present_or_create by a different name.  */\n@@ -539,7 +577,8 @@ acc_pcreate (void *h, size_t s)\n void *\n acc_present_or_copyin (void *h, size_t s)\n {\n-  return present_create_copy (FLAG_PRESENT | FLAG_CREATE | FLAG_COPY, h, s);\n+  return present_create_copy (FLAG_PRESENT | FLAG_CREATE | FLAG_COPY, h, s,\n+\t\t\t      acc_async_sync);\n }\n \n /* acc_pcopyin is acc_present_or_copyin by a different name.  */\n@@ -557,7 +596,7 @@ acc_pcopyin (void *h, size_t s)\n #define FLAG_FINALIZE (1 << 1)\n \n static void\n-delete_copyout (unsigned f, void *h, size_t s, const char *libfnname)\n+delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n {\n   size_t host_size;\n   splay_tree_key n;\n@@ -633,7 +672,13 @@ delete_copyout (unsigned f, void *h, size_t s, const char *libfnname)\n \t}\n \n       if (f & FLAG_COPYOUT)\n-\tacc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n+\t{\n+\t  if (async > acc_async_sync)\n+\t    acc_dev->openacc.async_set_async_func (async);\n+\t  acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n+\t  if (async > acc_async_sync)\n+\t    acc_dev->openacc.async_set_async_func (acc_async_sync);\n+\t}\n \n       gomp_remove_var (acc_dev, n);\n     }\n@@ -644,41 +689,54 @@ delete_copyout (unsigned f, void *h, size_t s, const char *libfnname)\n void\n acc_delete (void *h , size_t s)\n {\n-  delete_copyout (0, h, s, __FUNCTION__);\n+  delete_copyout (0, h, s, acc_async_sync, __FUNCTION__);\n+}\n+\n+void\n+acc_delete_async (void *h , size_t s, int async)\n+{\n+  delete_copyout (0, h, s, async, __FUNCTION__);\n }\n \n void\n acc_delete_finalize (void *h , size_t s)\n {\n-  delete_copyout (FLAG_FINALIZE, h, s, __FUNCTION__);\n+  delete_copyout (FLAG_FINALIZE, h, s, acc_async_sync, __FUNCTION__);\n }\n \n void\n acc_delete_finalize_async (void *h , size_t s, int async)\n {\n-  delete_copyout (FLAG_FINALIZE, h, s, __FUNCTION__);\n+  delete_copyout (FLAG_FINALIZE, h, s, async, __FUNCTION__);\n }\n \n void\n acc_copyout (void *h, size_t s)\n {\n-  delete_copyout (FLAG_COPYOUT, h, s, __FUNCTION__);\n+  delete_copyout (FLAG_COPYOUT, h, s, acc_async_sync, __FUNCTION__);\n+}\n+\n+void\n+acc_copyout_async (void *h, size_t s, int async)\n+{\n+  delete_copyout (FLAG_COPYOUT, h, s, async, __FUNCTION__);\n }\n \n void\n acc_copyout_finalize (void *h, size_t s)\n {\n-  delete_copyout (FLAG_COPYOUT | FLAG_FINALIZE, h, s, __FUNCTION__);\n+  delete_copyout (FLAG_COPYOUT | FLAG_FINALIZE, h, s, acc_async_sync,\n+\t\t  __FUNCTION__);\n }\n \n void\n acc_copyout_finalize_async (void *h, size_t s, int async)\n {\n-  delete_copyout (FLAG_COPYOUT | FLAG_FINALIZE, h, s, __FUNCTION__);\n+  delete_copyout (FLAG_COPYOUT | FLAG_FINALIZE, h, s, async, __FUNCTION__);\n }\n \n static void\n-update_dev_host (int is_dev, void *h, size_t s)\n+update_dev_host (int is_dev, void *h, size_t s, int async)\n {\n   splay_tree_key n;\n   void *d;\n@@ -704,24 +762,42 @@ update_dev_host (int is_dev, void *h, size_t s)\n   d = (void *) (n->tgt->tgt_start + n->tgt_offset\n \t\t+ (uintptr_t) h - n->host_start);\n \n+  if (async > acc_async_sync)\n+    acc_dev->openacc.async_set_async_func (async);\n+\n   if (is_dev)\n     acc_dev->host2dev_func (acc_dev->target_id, d, h, s);\n   else\n     acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n \n+  if (async > acc_async_sync)\n+    acc_dev->openacc.async_set_async_func (acc_async_sync);\n+\n   gomp_mutex_unlock (&acc_dev->lock);\n }\n \n void\n acc_update_device (void *h, size_t s)\n {\n-  update_dev_host (1, h, s);\n+  update_dev_host (1, h, s, acc_async_sync);\n+}\n+\n+void\n+acc_update_device_async (void *h, size_t s, int async)\n+{\n+  update_dev_host (1, h, s, async);\n }\n \n void\n acc_update_self (void *h, size_t s)\n {\n-  update_dev_host (0, h, s);\n+  update_dev_host (0, h, s, acc_async_sync);\n+}\n+\n+void\n+acc_update_self_async (void *h, size_t s, int async)\n+{\n+  update_dev_host (0, h, s, async);\n }\n \n void"}, {"sha": "7c809fe007386bf77199f9d6730ec492b070b516", "filename": "libgomp/openacc.f90", "status": "modified", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.f90?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -332,6 +332,150 @@ function acc_is_present_array_h (a)\n       logical acc_is_present_array_h\n       type (*), dimension (..), contiguous :: a\n     end function\n+\n+    subroutine acc_copyin_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_copyin_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_copyin_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_create_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_create_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_create_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_copyout_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_copyout_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_copyout_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_delete_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_delete_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_delete_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_device_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_device_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_device_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_self_async_32_h (a, len, async)\n+      use iso_c_binding, only: c_int32_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int32_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_self_async_64_h (a, len, async)\n+      use iso_c_binding, only: c_int64_t\n+      use openacc_kinds, only: acc_handle_kind\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_int64_t) len\n+      integer (acc_handle_kind) async\n+    end subroutine\n+\n+    subroutine acc_update_self_async_array_h (a, async)\n+      use openacc_kinds, only: acc_handle_kind\n+      type (*), dimension (..), contiguous :: a\n+      integer (acc_handle_kind) async\n+    end subroutine\n   end interface\n \n   interface\n@@ -510,6 +654,60 @@ function acc_is_present_l (a, len) &\n       type (*), dimension (*) :: a\n       integer (c_size_t), value :: len\n     end function\n+\n+    subroutine acc_copyin_async_l (a, len, async) &\n+        bind (C, name = \"acc_copyin_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n+\n+    subroutine acc_create_async_l (a, len, async) &\n+        bind (C, name = \"acc_create_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n+\n+    subroutine acc_copyout_async_l (a, len, async) &\n+        bind (C, name = \"acc_copyout_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n+\n+    subroutine acc_delete_async_l (a, len, async) &\n+        bind (C, name = \"acc_delete_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n+\n+    subroutine acc_update_device_async_l (a, len, async) &\n+        bind (C, name = \"acc_update_device_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n+\n+    subroutine acc_update_self_async_l (a, len, async) &\n+        bind (C, name = \"acc_update_self_async\")\n+      use iso_c_binding, only: c_size_t, c_int\n+      !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+      type (*), dimension (*) :: a\n+      integer (c_size_t), value :: len\n+      integer (c_int), value :: async\n+    end subroutine\n   end interface\n end module\n \n@@ -529,6 +727,8 @@ module openacc\n   public :: acc_copyin, acc_present_or_copyin, acc_pcopyin, acc_create\n   public :: acc_present_or_create, acc_pcreate, acc_copyout, acc_delete\n   public :: acc_update_device, acc_update_self, acc_is_present\n+  public :: acc_copyin_async, acc_create_async, acc_copyout_async\n+  public :: acc_delete_async, acc_update_device_async, acc_update_self_async\n \n   integer, parameter :: openacc_version = 201306\n \n@@ -694,6 +894,42 @@ module openacc\n   ! acc_memcpy_to_device: Only available in C/C++\n   ! acc_memcpy_from_device: Only available in C/C++\n \n+  interface acc_copyin_async\n+    procedure :: acc_copyin_async_32_h\n+    procedure :: acc_copyin_async_64_h\n+    procedure :: acc_copyin_async_array_h\n+  end interface\n+\n+  interface acc_create_async\n+    procedure :: acc_create_async_32_h\n+    procedure :: acc_create_async_64_h\n+    procedure :: acc_create_async_array_h\n+  end interface\n+\n+  interface acc_copyout_async\n+    procedure :: acc_copyout_async_32_h\n+    procedure :: acc_copyout_async_64_h\n+    procedure :: acc_copyout_async_array_h\n+  end interface\n+\n+  interface acc_delete_async\n+    procedure :: acc_delete_async_32_h\n+    procedure :: acc_delete_async_64_h\n+    procedure :: acc_delete_async_array_h\n+  end interface\n+\n+  interface acc_update_device_async\n+    procedure :: acc_update_device_async_32_h\n+    procedure :: acc_update_device_async_64_h\n+    procedure :: acc_update_device_async_array_h\n+  end interface\n+\n+  interface acc_update_self_async\n+    procedure :: acc_update_self_async_32_h\n+    procedure :: acc_update_self_async_64_h\n+    procedure :: acc_update_self_async_array_h\n+  end interface\n+\n end module\n \n function acc_get_num_devices_h (d)\n@@ -1078,3 +1314,189 @@ function acc_is_present_array_h (a)\n   type (*), dimension (..), contiguous :: a\n   acc_is_present_array_h = acc_is_present_l (a, sizeof (a)) == 1\n end function\n+\n+subroutine acc_copyin_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_copyin_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_copyin_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_copyin_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_copyin_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_copyin_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_copyin_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_copyin_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_copyin_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_create_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_create_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_create_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_create_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_create_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_create_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_create_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_create_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_create_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_copyout_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_copyout_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_copyout_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_copyout_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_copyout_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_copyout_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_copyout_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_copyout_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_copyout_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_delete_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_delete_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_delete_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_delete_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_delete_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_delete_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_delete_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_delete_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_delete_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_device_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_update_device_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_update_device_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_device_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_update_device_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_update_device_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_device_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_update_device_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_update_device_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_self_async_32_h (a, len, async)\n+  use iso_c_binding, only: c_int32_t, c_size_t, c_int\n+  use openacc_internal, only: acc_update_self_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int32_t) len\n+  integer (acc_handle_kind) async\n+  call acc_update_self_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_self_async_64_h (a, len, async)\n+  use iso_c_binding, only: c_int64_t, c_size_t, c_int\n+  use openacc_internal, only: acc_update_self_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+  type (*), dimension (*) :: a\n+  integer (c_int64_t) len\n+  integer (acc_handle_kind) async\n+  call acc_update_self_async_l (a, int (len, kind = c_size_t), int (async, kind = c_int))\n+end subroutine\n+\n+subroutine acc_update_self_async_array_h (a, async)\n+  use iso_c_binding, only: c_int\n+  use openacc_internal, only: acc_update_self_async_l\n+  use openacc_kinds, only: acc_handle_kind\n+  type (*), dimension (..), contiguous :: a\n+  integer (acc_handle_kind) async\n+  call acc_update_self_async_l (a, sizeof (a), int (async, kind = c_int))\n+end subroutine"}, {"sha": "f61bb77f9f3e34f5313874e2eb5c46d1a0459d18", "filename": "libgomp/openacc.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.h?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -115,6 +115,16 @@ void acc_copyout_finalize_async (void *, size_t, int) __GOACC_NOTHROW;\n void acc_delete_finalize (void *, size_t) __GOACC_NOTHROW;\n void acc_delete_finalize_async (void *, size_t, int) __GOACC_NOTHROW;\n \n+/* Async functions, specified in OpenACC 2.5.  */\n+void acc_copyin_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_create_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_copyout_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_delete_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_update_device_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_update_self_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_memcpy_to_device_async (void *, void *, size_t, int) __GOACC_NOTHROW;\n+void acc_memcpy_from_device_async (void *, void *, size_t, int) __GOACC_NOTHROW;\n+\n /* CUDA-specific routines.  */\n void *acc_get_current_cuda_device (void) __GOACC_NOTHROW;\n void *acc_get_current_cuda_context (void) __GOACC_NOTHROW;"}, {"sha": "820d987d72e284cd5db3671f584c07400cc54dd1", "filename": "libgomp/openacc_lib.h", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc_lib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Fopenacc_lib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc_lib.h?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -403,3 +403,159 @@\n \n       ! acc_memcpy_to_device: Only available in C/C++\n       ! acc_memcpy_from_device: Only available in C/C++\n+\n+      interface acc_copyin_async\n+        subroutine acc_copyin_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_copyin_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_copyin_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface\n+\n+      interface acc_create_async\n+        subroutine acc_create_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_create_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_create_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface\n+\n+      interface acc_copyout_async\n+        subroutine acc_copyout_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_copyout_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_copyout_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface\n+\n+      interface acc_delete_async\n+        subroutine acc_delete_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_delete_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_delete_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface\n+\n+      interface acc_update_device_async\n+        subroutine acc_update_device_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_update_device_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_update_device_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface\n+\n+      interface acc_update_self_async\n+        subroutine acc_update_self_async_32_h (a, len, async)\n+          use iso_c_binding, only: c_int32_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int32_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_update_self_async_64_h (a, len, async)\n+          use iso_c_binding, only: c_int64_t\n+          import acc_handle_kind\n+          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+          type (*), dimension (*) :: a\n+          integer (c_int64_t) len\n+          integer (acc_handle_kind) async\n+        end subroutine\n+\n+        subroutine acc_update_self_async_array_h (a, async_)\n+          import acc_handle_kind\n+          type (*), dimension (..), contiguous :: a\n+          integer (acc_handle_kind) async_\n+        end subroutine\n+      end interface"}, {"sha": "54497237b0c08229e45bcbaa4860208c9c21ac8c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-94.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-94.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-94.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-94.c?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const int N = 256;\n+  int i;\n+  int async = 8;\n+  unsigned char *h;\n+\n+  h = (unsigned char *) malloc (N);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      h[i] = i;\n+    }\n+\n+  acc_copyin_async (h, N, async);\n+\n+  memset (h, 0, N);\n+\n+  acc_wait (async);\n+\n+  acc_copyout_async (h, N, async + 1);\n+\n+  acc_wait (async + 1);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (h[i] != i)\n+\tabort ();\n+    }\n+\n+  free (h);\n+\n+  return 0;\n+}"}, {"sha": "85b238d78c832e87d49b6209e97b88ea880f0b6f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-95.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-95.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-95.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-95.c?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const int N = 256;\n+  int i, q = 5;\n+  unsigned char *h, *g;\n+  void *d;\n+\n+  h = (unsigned char *) malloc (N);\n+  g = (unsigned char *) malloc (N);\n+  for (i = 0; i < N; i++)\n+    {\n+      g[i] = i;\n+    }\n+\n+  acc_create_async (h, N, q);\n+\n+  acc_memcpy_to_device_async (acc_deviceptr (h), g, N, q);\n+  memset (&h[0], 0, N);\n+\n+  acc_wait (q);\n+\n+  acc_update_self_async (h, N, q + 1);\n+  acc_delete_async (h, N, q + 1);\n+\n+  acc_wait (q + 1);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (h[i] != i)\n+\tabort ();\n+    }\n+\n+  free (h);\n+  free (g);\n+\n+  return 0;\n+}"}, {"sha": "9701b52dd257712b1cfefa8a707e91598155cb47", "filename": "libgomp/testsuite/libgomp.oacc-fortran/lib-16.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Flib-16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58168bbf6f8fb456280cca13343a498ad94878c7/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Flib-16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Flib-16.f90?ref=58168bbf6f8fb456280cca13343a498ad94878c7", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n+\n+program main\n+  use openacc\n+  implicit none\n+\n+  integer, parameter :: N = 256\n+  integer, allocatable :: h(:)\n+  integer :: i\n+  integer :: async = 5\n+\n+  allocate (h(N))\n+\n+  do i = 1, N\n+    h(i) = i\n+  end do \n+\n+  call acc_copyin (h)\n+\n+  do i = 1, N\n+    h(i) = i + i\n+  end do \n+\n+  call acc_update_device_async (h, sizeof (h), async)\n+\n+  if (acc_is_present (h) .neqv. .TRUE.) call abort\n+\n+  h(:) = 0\n+\n+  call acc_copyout_async (h, sizeof (h), async)\n+\n+  call acc_wait (async)\n+\n+  do i = 1, N\n+    if (h(i) /= i + i) call abort\n+  end do \n+\n+  call acc_copyin (h, sizeof (h))\n+\n+  h(:) = 0\n+\n+  call acc_update_self_async (h, sizeof (h), async)\n+  \n+  if (acc_is_present (h) .neqv. .TRUE.) call abort\n+\n+  do i = 1, N\n+    if (h(i) /= i + i) call abort\n+  end do \n+\n+  call acc_delete_async (h, async)\n+\n+  call acc_wait (async)\n+\n+  if (acc_is_present (h) .neqv. .FALSE.) call abort\n+  \n+end program"}]}