{"sha": "abb73f901b36ca3125f358cddfc58aab2cc1bf15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJiNzNmOTAxYjM2Y2EzMTI1ZjM1OGNkZGZjNThhYWIyY2MxYmYxNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-05T23:58:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-05T23:58:39Z"}, "message": "expmed.c (extract_force_align_mem_bit_field): New.\n\n        * expmed.c (extract_force_align_mem_bit_field): New.\n        (extract_split_bit_field): Call it.\n\nFrom-SVN: r90150", "tree": {"sha": "f692126d33b801c05fd5dad1b6979c0a1f095eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f692126d33b801c05fd5dad1b6979c0a1f095eb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abb73f901b36ca3125f358cddfc58aab2cc1bf15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb73f901b36ca3125f358cddfc58aab2cc1bf15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abb73f901b36ca3125f358cddfc58aab2cc1bf15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb73f901b36ca3125f358cddfc58aab2cc1bf15/comments", "author": null, "committer": null, "parents": [{"sha": "f526a3c8fd2cbcf42ae282cfa3572b59d19414f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f526a3c8fd2cbcf42ae282cfa3572b59d19414f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f526a3c8fd2cbcf42ae282cfa3572b59d19414f9"}], "stats": {"total": 154, "additions": 153, "deletions": 1}, "files": [{"sha": "d654bf89b996511b4f35cc57fe712855c55ba142", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb73f901b36ca3125f358cddfc58aab2cc1bf15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb73f901b36ca3125f358cddfc58aab2cc1bf15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abb73f901b36ca3125f358cddfc58aab2cc1bf15", "patch": "@@ -1,3 +1,8 @@\n+2004-11-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* expmed.c (extract_force_align_mem_bit_field): New.\n+\t(extract_split_bit_field): Call it.\n+\n 2004-11-05  Richard Henderson  <rth@redhat.com>\n \n \t* ia64.md (UNSPEC_SHRP): New."}, {"sha": "475cdcf71fbd1a0beb8f918cb2c87c3450c78ac1", "filename": "gcc/expmed.c", "status": "modified", "additions": 148, "deletions": 1, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb73f901b36ca3125f358cddfc58aab2cc1bf15/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb73f901b36ca3125f358cddfc58aab2cc1bf15/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=abb73f901b36ca3125f358cddfc58aab2cc1bf15", "patch": "@@ -1853,6 +1853,144 @@ lshift_value (enum machine_mode mode, rtx value, int bitpos, int bitsize)\n   return immed_double_const (low, high, mode);\n }\n \f\n+/* Extract a bit field from a memory by forcing the alignment of the\n+   memory.  This efficient only if the field spans at least 4 boundaries.\n+\n+   OP0 is the MEM.\n+   BITSIZE is the field width; BITPOS is the position of the first bit.\n+   UNSIGNEDP is true if the result should be zero-extended.  */\n+\n+static rtx\n+extract_force_align_mem_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t\t   unsigned HOST_WIDE_INT bitpos,\n+\t\t\t\t   int unsignedp)\n+{\n+  enum machine_mode mode, dmode;\n+  unsigned int m_bitsize, m_size;\n+  unsigned int sign_shift_up, sign_shift_dn;\n+  rtx base, a1, a2, v1, v2, comb, shift, result, start;\n+\n+  /* Choose a mode that will fit BITSIZE.    */\n+  mode = smallest_mode_for_size (bitsize, MODE_INT);\n+  m_size = GET_MODE_SIZE (mode);\n+  m_bitsize = GET_MODE_BITSIZE (mode);\n+\n+  /* Choose a mode twice as wide.  Fail if no such mode exists.  */\n+  dmode = mode_for_size (m_bitsize * 2, MODE_INT, false);\n+  if (dmode == BLKmode)\n+    return NULL;\n+\n+  do_pending_stack_adjust ();\n+  start = get_last_insn ();\n+\n+  /* At the end, we'll need an additional shift to deal with sign/zero\n+     extension.  By default this will be a left+right shift of the\n+     appropriate size.  But we may be able to elimitate one of them.  */\n+  sign_shift_up = sign_shift_dn = m_bitsize - bitsize;\n+\n+  if (STRICT_ALIGNMENT)\n+    {\n+      base = plus_constant (XEXP (op0, 0), bitpos / BITS_PER_UNIT);\n+      base = force_operand (base, NULL);\n+      bitpos %= BITS_PER_UNIT;\n+\n+      /* Force alignment of the address; load two sequential values.  */\n+      a1 = expand_simple_binop (Pmode, AND, base,\n+\t\t\t\tGEN_INT (-(HOST_WIDE_INT)m_size),\n+\t\t\t\tNULL, true, OPTAB_LIB_WIDEN);\n+      mark_reg_pointer (a1, m_bitsize);\n+      v1 = gen_rtx_MEM (mode, a1);\n+      set_mem_align (v1, m_bitsize);\n+      v1 = force_reg (mode, validize_mem (v1));\n+\n+      a2 = plus_constant (a1, GET_MODE_SIZE (mode));\n+      v2 = gen_rtx_MEM (mode, a2);\n+      set_mem_align (v2, m_bitsize);\n+      v2 = force_reg (mode, validize_mem (v2));\n+\n+      /* Combine these two values into a double-word value.  */\n+      if (m_bitsize == BITS_PER_WORD)\n+\t{\n+\t  comb = gen_reg_rtx (dmode);\n+\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, comb));\n+\t  emit_move_insn (gen_rtx_SUBREG (mode, comb, 0), v1);\n+\t  emit_move_insn (gen_rtx_SUBREG (mode, comb, m_size), v2);\n+\t}\n+      else\n+\t{\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    comb = v1, v1 = v2, v2 = comb;\n+\t  v1 = convert_modes (dmode, mode, v1, true);\n+\t  if (v1 == NULL)\n+\t    goto fail;\n+\t  v2 = convert_modes (dmode, mode, v2, true);\n+\t  v2 = expand_simple_binop (dmode, ASHIFT, v2, GEN_INT (m_bitsize),\n+\t\t\t\t    NULL, true, OPTAB_LIB_WIDEN);\n+\t  if (v2 == NULL)\n+\t    goto fail;\n+\t  comb = expand_simple_binop (dmode, IOR, v1, v2, NULL,\n+\t\t\t\t      true, OPTAB_LIB_WIDEN);\n+\t  if (comb == NULL)\n+\t    goto fail;\n+\t}\n+\n+      shift = expand_simple_binop (Pmode, AND, base, GEN_INT (m_size - 1),\n+\t\t\t\t   NULL, true, OPTAB_LIB_WIDEN);\n+      shift = expand_mult (Pmode, shift, GEN_INT (BITS_PER_UNIT), NULL, 1);\n+\n+      if (bitpos != 0)\n+\t{\n+\t  if (sign_shift_up <= bitpos)\n+\t    bitpos -= sign_shift_up, sign_shift_up = 0;\n+\t  shift = expand_simple_binop (Pmode, PLUS, shift, GEN_INT (bitpos),\n+\t\t\t\t       NULL, true, OPTAB_LIB_WIDEN);\n+\t}\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT offset = bitpos / BITS_PER_UNIT;\n+      bitpos %= BITS_PER_UNIT;\n+\n+      /* When strict alignment is not required, we can just load directly\n+\t from memory without masking.  If the remaining BITPOS offset is\n+\t small enough, we may be able to do all operations in MODE as \n+\t opposed to DMODE.  */\n+      if (bitpos + bitsize <= m_bitsize)\n+\tdmode = mode;\n+      comb = adjust_address (op0, dmode, offset);\n+\n+      if (sign_shift_up <= bitpos)\n+\tbitpos -= sign_shift_up, sign_shift_up = 0;\n+      shift = GEN_INT (bitpos);\n+    }\n+\n+  /* Shift down the double-word such that the requested value is at bit 0.  */\n+  if (shift != const0_rtx)\n+    comb = expand_simple_binop (dmode, unsignedp ? LSHIFTRT : ASHIFTRT,\n+\t\t\t\tcomb, shift, NULL, unsignedp, OPTAB_LIB_WIDEN);\n+  if (comb == NULL)\n+    goto fail;\n+\n+  /* If the field exactly matches MODE, then all we need to do is return the\n+     lowpart.  Otherwise, shift to get the sign bits set properly.  */\n+  result = force_reg (mode, gen_lowpart (mode, comb));\n+\n+  if (sign_shift_up)\n+    result = expand_simple_binop (mode, ASHIFT, result,\n+\t\t\t\t  GEN_INT (sign_shift_up),\n+\t\t\t\t  NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+  if (sign_shift_dn)\n+    result = expand_simple_binop (mode, unsignedp ? LSHIFTRT : ASHIFTRT,\n+\t\t\t\t  result, GEN_INT (sign_shift_dn),\n+\t\t\t\t  NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\n+  return result;\n+\n+ fail:\n+  delete_insns_since (start);\n+  return NULL;\n+}\n+\n /* Extract a bit field that is split across two words\n    and return an RTX for the result.\n \n@@ -1874,7 +2012,16 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n     unit = BITS_PER_WORD;\n   else\n-    unit = MIN (MEM_ALIGN (op0), BITS_PER_WORD);\n+    {\n+      unit = MIN (MEM_ALIGN (op0), BITS_PER_WORD);\n+      if (bitsize / unit > 2)\n+\t{\n+\t  rtx tmp = extract_force_align_mem_bit_field (op0, bitsize, bitpos,\n+\t\t\t\t\t\t       unsignedp);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+    }\n \n   while (bitsdone < bitsize)\n     {"}]}