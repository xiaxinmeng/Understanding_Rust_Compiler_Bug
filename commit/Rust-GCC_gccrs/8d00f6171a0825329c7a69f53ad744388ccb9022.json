{"sha": "8d00f6171a0825329c7a69f53ad744388ccb9022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwMGY2MTcxYTA4MjUzMjljN2E2OWY1M2FkNzQ0Mzg4Y2NiOTAyMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-03-07T00:10:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-03-07T00:10:52Z"}, "message": "jni.cc (MARK_NONE): New define.\n\n\t* jni.cc (MARK_NONE): New define.\n\t(MARK_USER): Likewise.\n\t(MARK_SYSTEM): Likewise.\n\t(struct _Jv_JNI_LocalFrame): Made `marker' bigger and `size'\n\tsmaller.\n\t(_Jv_JNI_DeleteLocalRef): Use MARK_NONE in assert.\n\t(_Jv_JNI_EnsureLocalCapacity): Use MARK_NONE.\n\t(_Jv_JNI_PushLocalFrame): Use MARK_USER.\n\t(_Jv_JNI_PopLocalFrame): New version with additional `stop'\n\targument.\n\t(call): Use MARK_SYSTEM.\n\t(_Jv_GetJNIEnvNewFrame): New function.\n\t(_Jv_LookupJNIMethod): New function.\n\t(_Jv_JNI_PopSystemFrame): New function.\n\t(call): Use _Jv_JNI_PopSystemFrame and _Jv_LookupJNIMethod.\n\nFrom-SVN: r32373", "tree": {"sha": "4db67277e34fdff4998ca352076c9163233bd56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db67277e34fdff4998ca352076c9163233bd56c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d00f6171a0825329c7a69f53ad744388ccb9022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d00f6171a0825329c7a69f53ad744388ccb9022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d00f6171a0825329c7a69f53ad744388ccb9022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d00f6171a0825329c7a69f53ad744388ccb9022/comments", "author": null, "committer": null, "parents": [{"sha": "b1b41fe4acbba6e729d035d3d561e0f82ff5f06a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b41fe4acbba6e729d035d3d561e0f82ff5f06a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b41fe4acbba6e729d035d3d561e0f82ff5f06a"}], "stats": {"total": 167, "additions": 117, "deletions": 50}, "files": [{"sha": "c33749c7a5a10c837686b67b0356b7717366f0be", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d00f6171a0825329c7a69f53ad744388ccb9022/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d00f6171a0825329c7a69f53ad744388ccb9022/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8d00f6171a0825329c7a69f53ad744388ccb9022", "patch": "@@ -1,3 +1,21 @@\n+2000-03-06  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* jni.cc (MARK_NONE): New define.\n+\t(MARK_USER): Likewise.\n+\t(MARK_SYSTEM): Likewise.\n+\t(struct _Jv_JNI_LocalFrame): Made `marker' bigger and `size'\n+\tsmaller.\n+\t(_Jv_JNI_DeleteLocalRef): Use MARK_NONE in assert.\n+\t(_Jv_JNI_EnsureLocalCapacity): Use MARK_NONE.\n+\t(_Jv_JNI_PushLocalFrame): Use MARK_USER.\n+\t(_Jv_JNI_PopLocalFrame): New version with additional `stop'\n+\targument.\n+\t(call): Use MARK_SYSTEM.\n+\t(_Jv_GetJNIEnvNewFrame): New function.\n+\t(_Jv_LookupJNIMethod): New function.\n+\t(_Jv_JNI_PopSystemFrame): New function.\n+\t(call): Use _Jv_JNI_PopSystemFrame and _Jv_LookupJNIMethod.\n+\n 2000-03-05  Tom Tromey  <tromey@cygnus.com>\n \n \tFix for PR libgcj/43:"}, {"sha": "d25b03cc55e3f5acd59c6c592c5476cef8a105bd", "filename": "libjava/jni.cc", "status": "modified", "additions": 99, "deletions": 50, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d00f6171a0825329c7a69f53ad744388ccb9022/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d00f6171a0825329c7a69f53ad744388ccb9022/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=8d00f6171a0825329c7a69f53ad744388ccb9022", "patch": "@@ -75,15 +75,22 @@ extern struct JNIInvokeInterface _Jv_JNI_InvokeFunctions;\n // 16.\n #define FRAME_SIZE 32\n \n+// Mark value indicating this is an overflow frame.\n+#define MARK_NONE    0\n+// Mark value indicating this is a user frame.\n+#define MARK_USER    1\n+// Mark value indicating this is a system frame.\n+#define MARK_SYSTEM  2\n+\n // This structure is used to keep track of local references.\n struct _Jv_JNI_LocalFrame\n {\n   // This is true if this frame object represents a pushed frame (eg\n   // from PushLocalFrame).\n-  int marker :  1;\n+  int marker :  2;\n \n   // Number of elements in frame.\n-  int size   : 31;\n+  int size   : 30;\n \n   // Next frame in chain.\n   _Jv_JNI_LocalFrame *next;\n@@ -169,7 +176,7 @@ _Jv_JNI_DeleteLocalRef (JNIEnv *env, jobject obj)\n \t}\n \n       // Don't go past a marked frame.\n-      JvAssert (! frame->marker);\n+      JvAssert (frame->marker == MARK_NONE);\n     }\n \n   JvAssert (0);\n@@ -194,7 +201,7 @@ _Jv_JNI_EnsureLocalCapacity (JNIEnv *env, jint size)\n       return JNI_ERR;\n     }\n \n-  frame->marker = true;\n+  frame->marker = MARK_NONE;\n   frame->size = size;\n   memset (&frame->vec[0], 0, size * sizeof (jobject));\n   frame->next = env->locals;\n@@ -211,7 +218,7 @@ _Jv_JNI_PushLocalFrame (JNIEnv *env, jint size)\n     return r;\n \n   // The new frame is on top.\n-  env->locals->marker = true;\n+  env->locals->marker = MARK_USER;\n \n   return 0;\n }\n@@ -248,7 +255,7 @@ _Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n }\n \n static jobject\n-_Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n+_Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result, int stop)\n {\n   _Jv_JNI_LocalFrame *rf = env->locals;\n \n@@ -260,7 +267,7 @@ _Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n \t  unmark_for_gc (rf->vec[i]);\n \n       // If the frame we just freed is the marker frame, we are done.\n-      done = rf->marker;\n+      done = (rf->marker == stop);\n \n       _Jv_JNI_LocalFrame *n = rf->next;\n       // When N==NULL, we've reached the stack-allocated frame, and we\n@@ -279,6 +286,20 @@ _Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n   return result == NULL ? NULL : _Jv_JNI_NewLocalRef (env, result);\n }\n \n+static jobject\n+_Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n+{\n+  return _Jv_JNI_PopLocalFrame (env, result, MARK_USER);\n+}\n+\n+// Pop a `system' frame from the stack.  This is `extern \"C\"' as it is\n+// used by the compiler.\n+extern \"C\" void\n+_Jv_JNI_PopSystemFrame (JNIEnv *env)\n+{\n+  _Jv_JNI_PopLocalFrame (env, NULL, MARK_SYSTEM);\n+}\n+\n // This function is used from other template functions.  It wraps the\n // return value appropriately; we specialize it so that object returns\n // are turned into local references.\n@@ -1598,29 +1619,78 @@ mangled_name (jclass klass, _Jv_Utf8Const *func_name,\n   buf[here] = '\\0';\n }\n \n-// This function is the stub which is used to turn an ordinary (CNI)\n-// method call into a JNI call.\n-void\n-_Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n+// Return the current thread's JNIEnv; if one does not exist, create\n+// it.  Also create a new system frame for use.  This is `extern \"C\"'\n+// because the compiler calls it.\n+extern \"C\" JNIEnv *\n+_Jv_GetJNIEnvNewFrame (jclass klass)\n {\n-  _Jv_JNIMethod* _this = (_Jv_JNIMethod *) __this;\n+  JNIEnv *env = _Jv_GetCurrentJNIEnv ();\n+  if (env == NULL)\n+    {\n+      env = (JNIEnv *) _Jv_MallocUnchecked (sizeof (JNIEnv));\n+      env->p = &_Jv_JNIFunctions;\n+      env->ex = NULL;\n+      env->klass = klass;\n+      env->locals = NULL;\n \n-  JNIEnv env;\n-  _Jv_JNI_LocalFrame *frame\n-    = (_Jv_JNI_LocalFrame *) alloca (sizeof (_Jv_JNI_LocalFrame)\n-\t\t\t\t     + FRAME_SIZE * sizeof (jobject));\n+      _Jv_SetCurrentJNIEnv (env);\n+    }\n \n-  env.p = &_Jv_JNIFunctions;\n-  env.ex = NULL;\n-  env.klass = _this->defining_class;\n-  env.locals = frame;\n+  _Jv_JNI_LocalFrame *frame\n+    = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t\t\t  + (FRAME_SIZE\n+\t\t\t\t\t\t     * sizeof (jobject)));\n \n-  frame->marker = true;\n-  frame->next = NULL;\n+  frame->marker = MARK_SYSTEM;\n   frame->size = FRAME_SIZE;\n+  frame->next = env->locals;\n+  env->locals = frame;\n+\n   for (int i = 0; i < frame->size; ++i)\n     frame->vec[i] = NULL;\n \n+  return env;\n+}\n+\n+// Return the function which implements a particular JNI method.  If\n+// we can't find the function, we throw the appropriate exception.\n+// This is `extern \"C\"' because the compiler uses it.\n+extern \"C\" void *\n+_Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n+\t\t     _Jv_Utf8Const *signature)\n+{\n+  char buf[10 + 6 * (name->length + signature->length)];\n+  int long_start;\n+  void *function;\n+\n+  mangled_name (klass, name, signature, buf, &long_start);\n+  char c = buf[long_start];\n+  buf[long_start] = '\\0';\n+  function = _Jv_FindSymbolInExecutable (buf);\n+  if (function == NULL)\n+    {\n+      buf[long_start] = c;\n+      function = _Jv_FindSymbolInExecutable (buf);\n+      if (function == NULL)\n+\t{\n+\t  jstring str = JvNewStringUTF (name->data);\n+\t  JvThrow (new java::lang::AbstractMethodError (str));\n+\t}\n+    }\n+\n+  return function;\n+}\n+\n+// This function is the stub which is used to turn an ordinary (CNI)\n+// method call into a JNI call.\n+void\n+_Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n+{\n+  _Jv_JNIMethod* _this = (_Jv_JNIMethod *) __this;\n+\n+  JNIEnv *env = _Jv_GetJNIEnvNewFrame (_this->defining_class);\n+\n   // FIXME: we should mark every reference parameter as a local.  For\n   // now we assume a conservative GC, and we assume that the\n   // references are on the stack somewhere.\n@@ -1629,33 +1699,16 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n   // a value we don't cache that fact -- we might subsequently load a\n   // library which finds the function in question.\n   if (_this->function == NULL)\n-    {\n-      char buf[10 + 6 * (_this->self->name->length\n-\t\t\t + _this->self->signature->length)];\n-      int long_start;\n-      mangled_name (_this->defining_class, _this->self->name,\n-\t\t    _this->self->signature, buf, &long_start);\n-      char c = buf[long_start];\n-      buf[long_start] = '\\0';\n-      _this->function = _Jv_FindSymbolInExecutable (buf);\n-      if (_this->function == NULL)\n-\t{\n-\t  buf[long_start] = c;\n-\t  _this->function = _Jv_FindSymbolInExecutable (buf);\n-\t  if (_this->function == NULL)\n-\t    {\n-\t      jstring str = JvNewStringUTF (_this->self->name->data);\n-\t      JvThrow (new java::lang::AbstractMethodError (str));\n-\t    }\n-\t}\n-    }\n+    _this->function = _Jv_LookupJNIMethod (_this->defining_class,\n+\t\t\t\t\t   _this->self->name,\n+\t\t\t\t\t   _this->self->signature);\n \n   JvAssert (_this->args_raw_size % sizeof (ffi_raw) == 0);\n   ffi_raw real_args[2 + _this->args_raw_size / sizeof (ffi_raw)];\n   int offset = 0;\n \n   // First argument is always the environment pointer.\n-  real_args[offset++].ptr = &env;\n+  real_args[offset++].ptr = env;\n \n   // For a static method, we pass in the Class.  For non-static\n   // methods, the `this' argument is already handled.\n@@ -1669,14 +1722,10 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n   ffi_raw_call (&_this->jni_cif, (void (*) (...)) _this->function,\n \t\tret, real_args);\n \n-  do\n-    {\n-      _Jv_JNI_PopLocalFrame (&env, NULL);\n-    }\n-  while (env.locals != frame);\n+  _Jv_JNI_PopSystemFrame (env);\n \n-  if (env.ex)\n-    JvThrow (env.ex);\n+  if (env->ex)\n+    JvThrow (env->ex);\n }\n \n #endif /* INTERPRETER */"}]}