{"sha": "7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E5NWFlNmI1MWI1OTBhOGI4YjllZTA2NzY4MjA0YzVkNmE0YTkwZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-31T21:31:20Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-31T21:31:20Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Removed\n\tEnumerationChain, added DoubleEnumeration.\n\t(nat_source_files): Added natResourceBundle.cc.\n\t* java/util/natResourceBundle.cc: New file.\n\t* gnu/java/util/DoubleEnumeration.java: New file.\n\t* gnu/gcj/util/EnumerationChain.java: Removed.\n\t* java/beans/VetoableChangeSupport.java: Merged with Classpath.\n\t* java/util/ResourceBundle.java: Merged with Classpath.\n\t* java/util/StringTokenizer.java: Merged with Classpath.\n\t* java/util/Locale.java: Merged with Classpath.\n\t* java/util/Random.java: Merged with Classpath.\n\t* java/util/PropertyResourceBundle.java: Merged with Classpath.\n\t* java/util/ListResourceBundle.java: Merged with Classpath.\n\t* java/util/ConcurrentModificationException.java: Re-merged with\n\tClasspath.\n\t* java/util/EmptyStackException.java: Likewise.\n\t* java/util/MissingResourceException.java: Likewise.\n\t* java/util/NoSuchElementException.java: Likewise.\n\t* java/util/TooManyListenersException.java: Likewise.\n\nFrom-SVN: r45335", "tree": {"sha": "57cf10eba5f71e6072958cb8ef14beb8842f8b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57cf10eba5f71e6072958cb8ef14beb8842f8b91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/comments", "author": null, "committer": null, "parents": [{"sha": "fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a"}], "stats": {"total": 2946, "additions": 2219, "deletions": 727}, "files": [{"sha": "636dcc92619eaff350f37aa86c62fc80a0953200", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,5 +1,26 @@\n 2001-08-31  Tom Tromey  <tromey@redhat.com>\n \n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Removed\n+\tEnumerationChain, added DoubleEnumeration.\n+\t(nat_source_files): Added natResourceBundle.cc.\n+\t* java/util/natResourceBundle.cc: New file.\n+\t* gnu/java/util/DoubleEnumeration.java: New file.\n+\t* gnu/gcj/util/EnumerationChain.java: Removed.\n+\t* java/beans/VetoableChangeSupport.java: Merged with Classpath.\n+\t* java/util/ResourceBundle.java: Merged with Classpath.\n+\t* java/util/StringTokenizer.java: Merged with Classpath.\n+\t* java/util/Locale.java: Merged with Classpath.\n+\t* java/util/Random.java: Merged with Classpath.\n+\t* java/util/PropertyResourceBundle.java: Merged with Classpath.\n+\t* java/util/ListResourceBundle.java: Merged with Classpath.\n+\t* java/util/ConcurrentModificationException.java: Re-merged with\n+\tClasspath.\n+\t* java/util/EmptyStackException.java: Likewise.\n+\t* java/util/MissingResourceException.java: Likewise.\n+\t* java/util/NoSuchElementException.java: Likewise.\n+\t* java/util/TooManyListenersException.java: Likewise.\n+\n \t* java/io/ByteArrayOutputStream.java: Re-merged with Classpath.\n \t* java/io/OptionalDataException.java: Merged with Classpath.\n "}, {"sha": "c88d63c0633a7756430b571d5c13a29cafe8c7fe", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1128,7 +1128,6 @@ gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n-gnu/gcj/util/EnumerationChain.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -1143,6 +1142,7 @@ gnu/java/security/provider/DefaultPolicy.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n java/lang/ref/ReferenceQueue.java \\\n@@ -1492,6 +1492,7 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n+java/util/natResourceBundle.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n "}, {"sha": "7d1122dbb8a2e5a476a098b48776f08faa6ef4fa", "filename": "libjava/Makefile.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -878,7 +878,6 @@ gnu/gcj/text/LocaleData_en.java\t\\\n gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n-gnu/gcj/util/EnumerationChain.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -893,6 +892,7 @@ gnu/java/security/provider/DefaultPolicy.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n java/lang/ref/ReferenceQueue.java \\\n@@ -1241,6 +1241,7 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n+java/util/natResourceBundle.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n@@ -1388,7 +1389,8 @@ java/lang/reflect/natArray.lo java/lang/reflect/natConstructor.lo \\\n java/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n-java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n+java/util/natResourceBundle.lo java/util/zip/natDeflater.lo \\\n+java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -1493,8 +1495,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/text/LocaleData_en.P \\\n .deps/gnu/gcj/text/LocaleData_en_US.P \\\n .deps/gnu/gcj/text/SentenceBreakIterator.P \\\n-.deps/gnu/gcj/text/WordBreakIterator.P \\\n-.deps/gnu/gcj/util/EnumerationChain.P .deps/gnu/gcj/xlib/Clip.P \\\n+.deps/gnu/gcj/text/WordBreakIterator.P .deps/gnu/gcj/xlib/Clip.P \\\n .deps/gnu/gcj/xlib/Colormap.P .deps/gnu/gcj/xlib/Display.P \\\n .deps/gnu/gcj/xlib/Drawable.P .deps/gnu/gcj/xlib/Font.P \\\n .deps/gnu/gcj/xlib/GC.P .deps/gnu/gcj/xlib/Pixmap.P \\\n@@ -1560,7 +1561,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/security/provider/DefaultPolicy.P \\\n .deps/gnu/java/security/provider/Gnu.P \\\n .deps/gnu/java/security/provider/SHA.P \\\n-.deps/gnu/java/security/provider/SHA1PRNG.P .deps/interpret.P \\\n+.deps/gnu/java/security/provider/SHA1PRNG.P \\\n+.deps/gnu/java/util/DoubleEnumeration.P .deps/interpret.P \\\n .deps/java/applet/Applet.P .deps/java/applet/AppletContext.P \\\n .deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \\\n .deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \\\n@@ -2062,8 +2064,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/jar/JarEntry.P .deps/java/util/jar/JarException.P \\\n .deps/java/util/jar/JarFile.P .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n-.deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n-.deps/java/util/zip/CheckedInputStream.P \\\n+.deps/java/util/natResourceBundle.P .deps/java/util/zip/Adler32.P \\\n+.deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\\n .deps/java/util/zip/CheckedOutputStream.P \\\n .deps/java/util/zip/Checksum.P \\\n .deps/java/util/zip/DataFormatException.P \\"}, {"sha": "b8bf5a366075a7074bf5cdd9fa85b25e8470d34e", "filename": "libjava/gnu/gcj/util/EnumerationChain.java", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a/libjava%2Fgnu%2Fgcj%2Futil%2FEnumerationChain.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a/libjava%2Fgnu%2Fgcj%2Futil%2FEnumerationChain.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FEnumerationChain.java?ref=fb9282f91f0bc4f90f30cd6fa5a18c91f0e7e32a", "patch": "@@ -1,52 +0,0 @@\n-/* Copyright (C) 1999  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.util;\n-\n-import java.util.Enumeration;\n-import java.util.NoSuchElementException;\n-\n-public class EnumerationChain implements Enumeration\n-{\n-  private Enumeration first_;\n-  private Enumeration second_;\n-\n-  public EnumerationChain (Enumeration first, Enumeration second)\n-    {\n-      if (first == null\n-          || second == null)\n-        throw new NullPointerException();\n-\n-      first_ = first;\n-      second_ = second;\n-    }\n-\n-  public synchronized boolean hasMoreElements()\n-    {\n-      if (first_ == null)\n-        return false;\n-      else\n-        return first_.hasMoreElements();\n-    }\n-\n-  public synchronized Object nextElement() throws NoSuchElementException\n-    {\n-      while (first_ != null)\n-        {\n-          if (! first_.hasMoreElements())\n-            {\n-              first_ = second_;\n-              second_ = null;\n-            }\n-          else \n-            return first_.nextElement();\n-        }\n-      \n-      throw new NoSuchElementException();\n-    }\n-}"}, {"sha": "33aa2d8e6e0b6522e9e12140b8abeef078a41a10", "filename": "libjava/gnu/java/util/DoubleEnumeration.java", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fgnu%2Fjava%2Futil%2FDoubleEnumeration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fgnu%2Fjava%2Futil%2FDoubleEnumeration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2FDoubleEnumeration.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -0,0 +1,128 @@\n+/* gnu.java.util.DoubleEnumeration\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package gnu.java.util;\n+\n+import java.io.*;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * This is a helper class that combines two Enumerations.\n+ * It returns the elements of the first Enumeration until it has\n+ * no more elements and then returns the elements of the second\n+ * Enumeration.<br>\n+ * \n+ * In the default case:\n+ * <pre>\n+ * doubleEnum = new DoubleEnumeration(enum1, enum2);\n+ * while (doubleEnum.hasMoreElements()) {\n+ *    Object o = doubleEnum.nextElement();\n+ *    do_something(o);\n+ * }\n+ * </pre>\n+ * it calls hasMoreElements of the Enumerations as few times as\n+ * possible.\n+ * The references to the Enumerations are cleared as soon as they have no\n+ * more elements to help garbage collecting.\n+ *\n+ * @author Jochen Hoenicke\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class DoubleEnumeration implements Enumeration\n+{\n+  /**\n+   * This is true as long as one of the enumerations has more\n+   * elements.  \n+   * Only valid when hasChecked is true.\n+   * Set in <code>hasMoreElements()</code>\n+   */\n+  private boolean hasMore;\n+  /**\n+   * This is true, if it is sure that hasMore indicates wether there are\n+   * more elements.\n+   * Set to true in <code>hasMoreElements()</code>.\n+   * Set to false in <code>getNextElement()</code>.\n+   */\n+  private boolean hasChecked;\n+  /**\n+   * The first enumeration.\n+   */\n+  private Enumeration e1;\n+  /**\n+   * The second enumeration.\n+   */\n+  private Enumeration e2;\n+\n+  /**\n+   * Creates a new Enumeration combining the given two enumerations.\n+   * The enumerations mustn't be accessed by other classes.\n+   */\n+  public DoubleEnumeration(Enumeration e1, Enumeration e2)\n+  {\n+    this.e1 = e1;\n+    this.e2 = e2;\n+    hasChecked = false;\n+  }\n+\n+  /**\n+   * Returns true, if at least one of the two enumerations has more\n+   * elements.\n+   */\n+  public boolean hasMoreElements()\n+  {\n+    if (hasChecked)\n+      return hasMore;\n+\n+    hasMore = (e1 != null && e1.hasMoreElements());\n+\n+    if (!hasMore) {\n+      e1 = e2;\n+      e2 = null;\n+      hasMore = (e1 != null && e1.hasMoreElements());\n+    }\n+\n+    hasChecked = true;\n+    return hasMore;\n+  }\n+\n+  /**\n+   * Returns the next element.  This returns the next element of the\n+   * first enumeration, if it has more elements, otherwise the next\n+   * element of the second enumeration. If both enumeration don't have\n+   * any elements it throws a <code>NoSuchElementException</code>.\n+   */\n+  public Object nextElement()\n+  {\n+    if (!hasMoreElements())\n+      throw new NoSuchElementException();\n+    else {\n+      hasChecked = false;\n+      return e1.nextElement();\n+    }\n+  }\n+}"}, {"sha": "88a6488fff863aa54c694c6f0e9ac03c420aa094", "filename": "libjava/java/beans/VetoableChangeSupport.java", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,22 +1,28 @@\n-/*\n- * java.beans.VetoableChangeSupport: part of the Java Class Libraries project.\n- * Copyright (C) 1998, 2000 Free Software Foundation\n- *\n- * This library is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n- * Boston, MA  02111-1307, USA.\n- */\n+/* java.beans.VetoableChangeSupport\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.beans;\n import java.util.Hashtable;"}, {"sha": "0f88c8f0bdaf3eac9ec28e4e8c57d24fe924f086", "filename": "libjava/java/util/ConcurrentModificationException.java", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FConcurrentModificationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FConcurrentModificationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FConcurrentModificationException.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,33 +1,69 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* ConcurrentModificationException.java -- Data structure concurrently modified\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-   This file is part of libgcj.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n- \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n-/* Added in JDK 1.2 */\n+\n+/**\n+ * Exception that is thrown by the collections classes when it is detected that\n+ * a modification has been made to a data structure when this is not allowed,\n+ * such as when a collection is structurally modified while an Iterator is\n+ * operating over it. In cases where this can be detected, a\n+ * ConcurrentModificationException will be thrown. An Iterator that detects this\n+ * condition is referred to as fail-fast.\n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 2, 1998.\n+ * @since 1.2\n+ */\n public class ConcurrentModificationException extends RuntimeException\n {\n+  private static final long serialVersionUID = -3666751008965953603L;\n+\n+  /**\n+   * Constructs a ConcurrentModificationException with no detail message.\n+   */\n   public ConcurrentModificationException()\n   {\n     super();\n   }\n \n-  public ConcurrentModificationException(String msg)\n+  /**\n+   * Constructs a ConcurrentModificationException with a detail message.\n+   *\n+   * @param detail the detail message for the exception\n+   */\n+  public ConcurrentModificationException(String detail)\n   {\n-    super(msg);\n+    super(detail);\n   }\n }"}, {"sha": "a903d9d20dde7ffd8bb4c44352e4364d5fb43d26", "filename": "libjava/java/util/EmptyStackException.java", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FEmptyStackException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FEmptyStackException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEmptyStackException.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,25 +1,52 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* EmptyStackException.java -- Attempt to pop from an empty stack\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n+\n+/**\n+ * This exception is thrown by the Stack class when an attempt is made to pop\n+ * or otherwise access elements from an empty stack.\n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 2, 1998.\n+ */\n public class EmptyStackException extends RuntimeException\n {\n+  private static final long serialVersionUID = 5084686378493302095L;\n+\n+  /**\n+   * Constructs an EmptyStackException with no detail message.\n+   */\n   public EmptyStackException()\n   {\n     super();"}, {"sha": "96572ffcf7813ed28110fbdda6c9d4e4363db38a", "filename": "libjava/java/util/ListResourceBundle.java", "status": "modified", "additions": 87, "deletions": 39, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FListResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FListResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FListResourceBundle.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,52 +1,100 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.ListResourceBundle\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n-\n-/**\n- * @author Anthony Green <green@cygnus.com>\n- * @date November 26, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.  */\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-public abstract class ListResourceBundle extends ResourceBundle \n-{\n-  public final Object handleGetObject(String key)\n-    {\n-      Object a[][] = getContents();\n-\n-      for (int i = 0; i < a.length; i++)\n-\t{\n-\t  if (key.compareTo((String) a[i][0]) == 0)\n-\t    return a[i][1];\n-\t}\n-      throw new MissingResourceException(\"can't find handle\", \n-\t\t\t\t\t getClass().getName(), \n-\t\t\t\t\t key);\n-    }\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-  public Enumeration getKeys()\n-    {\n-      Object a[][] = getContents();\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-      Vector keys = new Vector(a.length);\n \n-      for (int i = 0; i < a.length; i++)\n-\tkeys.addElement(a[i][0]);\n+package java.util;\n \n-      return keys.elements();\n-    }\n+/**\n+ * A <code>ListResouceBundle</code> provides an easy way, to create\n+ * your own resource bundle.  It is an abstract class that you can\n+ * subclass.  You should then overwrite the getContents method, that\n+ * provides a key/value list.\n+ * <br>\n+ * The key/value list is a two dimensional list of Object.  The first\n+ * dimension ranges over the resources. The second dimension ranges\n+ * from zero (key) to one (value).  The keys must be of type String.\n+ * <br>\n+ * XXX Example!\n+ *\n+ * @see Locale\n+ * @see PropertyResourceBundle\n+ * @author Jochen Hoenicke */\n+public abstract class ListResourceBundle extends ResourceBundle\n+{\n+  /**\n+   * The constructor.  It does nothing special.\n+   */\n+  public ListResourceBundle()\n+  {\n+  }\n \n+  /**\n+   * Gets the key/value list.  You must override this method.\n+   * @return a two dimensional list of Objects.  The first dimension\n+   * ranges over the objects, and the second dimension ranges from\n+   * zero (key) to one (value).  \n+   */\n   protected abstract Object[][] getContents();\n \n-  public ListResourceBundle()\n+  /**\n+   * Override this method to provide the resource for a keys.  This gets\n+   * called by <code>getObject</code>.\n+   * @param key The key of the resource.\n+   * @return The resource for the key or null if it doesn't exists.\n+   */\n+  protected Object handleGetObject(String key)\n+  {\n+    Object[][] contents = getContents();\n+    for (int i = 0; i < contents.length; i++)\n+      {\n+\tif (key.equals(contents[i][0]))\n+\t  return contents[i][1];\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * This method should return all keys for which a resource exists.\n+   * @return An enumeration of the keys.\n+   */\n+  public Enumeration getKeys()\n+  {\n+    final Object[][] contents = getContents();\n+    \n+    return new Enumeration()\n     {\n-    }\n+      int i = 0;\n+      public boolean hasMoreElements()\n+      {\n+\treturn i < contents.length;\n+      }\n+      public Object nextElement()\n+      {\n+\treturn contents[i++][0];\n+      }\n+    };\n+  }\n }"}, {"sha": "159c841f2eec743083243d2bc10f0d83e2080726", "filename": "libjava/java/util/Locale.java", "status": "modified", "additions": 631, "deletions": 101, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FLocale.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FLocale.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLocale.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,157 +1,687 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+/* java.util.Locale\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+ \n+This file is part of GNU Classpath.\n+ \n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+ \n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+ \n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.util;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.\n- * Status:  None of the getDisplayXXX or getISO3XXX methods are implemented.\n+ * Locales represent a specific country and culture.\n+ * <br><br>\n+ * Classes which can be passed a Locale object tailor their information \n+ * for a given locale.  For instance, currency number formatting is \n+ * handled differently for the USA and France.\n+ * <br><br>\n+ * Locales are made up of a language code, a country code, and an optional\n+ * set of variant strings.\n+ * <br><br>\n+ * Language codes are represented by\n+ * <a href=\"http://www.indigo.ie/egt/standards/iso639/iso639-1-en.html\">ISO 639:1988</a>\n+ * w/ additions from ISO 639/RA Newsletter No. 1/1989\n+ * and a decision of the Advisory Committee of ISO/TC39 on\n+ * August 8, 1997.\n+ * <br><br>\n+ * Country codes are represented by \n+ * <a href=\"ftp://ftp.ripe.net/iso3166-countrycodes\">ISO 3166</a>.\n+ * <br><br>\n+ * Variant strings are vendor and browser specific.  Standard variant\n+ * strings include \"POSIX\" for POSIX, \"WIN\" for MS-Windows, and \"MAC\" for\n+ * Macintosh.  When there is more than one variant string, they must\n+ * be separated by an underscore (U+005F).\n+ * <br><br>\n+ * The default locale is determined by the values of the system properties\n+ * user.language, user.region, and user.variant.\n+ * @see ResourceBundle\n+ * @see java.text.Format\n+ * @see java.text.NumberFormat\n+ * @see java.text.Collator\n+ * @author Jochen Hoenicke\n+ * @author Paul Fisher\n  */\n public final class Locale implements java.io.Serializable, Cloneable\n {\n-  // The fields are as specified in Sun's \"Serialized Form\"\n-  // in the JDK 1.2 beta 4 API specification.\n-  private String country;\n-  private int hashcode;\n+  /**\n+   * Locale which represents the English language.\n+   */\n+  public static final Locale ENGLISH = new Locale(\"en\", \"\");\n+  /**\n+   * Locale which represents the English language.\n+   */\n+  public static final Locale FRENCH = new Locale(\"fr\", \"\");\n+  /**\n+   * Locale which represents the German language.\n+   */\n+  public static final Locale GERMAN = new Locale(\"de\", \"\");\n+  /**\n+   * Locale which represents the Italian language.\n+   */\n+  public static final Locale ITALIAN = new Locale(\"it\", \"\");\n+  /**\n+   * Locale which represents the Japanese language.\n+   */\n+  public static final Locale JAPANESE = new Locale(\"ja\", \"\");\n+  /**\n+   * Locale which represents the Korean language.\n+   */\n+  public static final Locale KOREAN = new Locale(\"ko\", \"\");\n+  /**\n+   * Locale which represents the Chinese language.\n+   */\n+  public static final Locale CHINESE = new Locale(\"zh\", \"\");\n+  /**\n+   * Locale which represents the Chinese language as used in China.\n+   */\n+  public static final Locale SIMPLIFIED_CHINESE = new Locale(\"zh\", \"CN\");\n+  /**\n+   * Locale which represents the Chinese language as used in Taiwan.\n+   * Same as TAIWAN Locale.\n+   */\n+  public static final Locale TRADITIONAL_CHINESE = new Locale(\"zh\", \"TW\");\n+  /**\n+   * Locale which represents France.\n+   */\n+  public static final Locale FRANCE = new Locale(\"fr\", \"FR\");\n+  /**\n+   * Locale which represents Germany.\n+   */\n+  public static final Locale GERMANY = new Locale(\"de\", \"DE\");\n+  /**\n+   * Locale which represents Italy.\n+   */\n+  public static final Locale ITALY = new Locale(\"it\", \"IT\");\n+  /**\n+   * Locale which represents Japan.\n+   */\n+  public static final Locale JAPAN = new Locale(\"ja\", \"JP\");\n+  /**\n+   * Locale which represents Korea.\n+   */\n+  public static final Locale KOREA = new Locale(\"ko\", \"KR\");\n+  /**\n+   * Locale which represents China.\n+   * Same as SIMPLIFIED_CHINESE Locale.\n+   */\n+  public static final Locale CHINA = SIMPLIFIED_CHINESE;\n+  /**\n+   * Locale which represents the People's Republic of China.\n+   * Same as CHINA Locale.\n+   */\n+  public static final Locale PRC = CHINA;\n+  /**\n+   * Locale which represents Taiwan.\n+   * Same as TRADITIONAL_CHINESE Locale.\n+   */\n+  public static final Locale TAIWAN = TRADITIONAL_CHINESE;\n+  /**\n+   * Locale which represents the United Kingdom.\n+   */\n+  public static final Locale UK = new Locale(\"en\", \"GB\");\n+  /**\n+   * Locale which represents the United States.\n+   */\n+  public static final Locale US = new Locale(\"en\", \"US\");\n+  /**\n+   * Locale which represents the English speaking portion of Canada.\n+   */\n+  public static final Locale CANADA = new Locale(\"en\", \"CA\");\n+  /**\n+   * Locale which represents the French speaking portion of Canada.\n+   */\n+  public static final Locale CANADA_FRENCH = new Locale(\"fr\", \"CA\");\n+\n+  /**\n+   * We are compatible to sun's Locale.\n+   */\n+  static final long serialVersionUID = 9149081749638150636L;\n+\n+  /**\n+   * The language code, as returned by getLanguage().\n+   * @serial\n+   */\n   private String language;\n+  /**\n+   * The country code, as returned by getCountry().\n+   * @serial\n+   */\n+  private String country;\n+  /**\n+   * The variant code, as returned by getVariant().\n+   * @serial\n+   */\n   private String variant;\n-  private static Locale defaultLocale;\n-  private static final long serialVersionUID = 9149081749638150636L;\n-\n-  // These are as specified in the JDK 1.2 AP documentation\n-\n-\n-  // LANGUAGE constants ... country-neutral\n-  public static final Locale CHINESE = new Locale (\"zh\", \"\");\n-  public static final Locale ENGLISH = new Locale (\"en\", \"\");\n-  public static final Locale FRENCH = new Locale (\"fr\", \"\");\n-  public static final Locale GERMAN = new Locale (\"de\", \"\");\n-  public static final Locale ITALIAN = new Locale (\"it\", \"\");\n-  public static final Locale JAPANESE = new Locale (\"ja\", \"\");\n-  public static final Locale KOREAN = new Locale (\"ko\", \"\");\n-\n-  // COUNTRY constants ... countries can be multi-lingual\n-  public static final Locale CANADA = new Locale (\"en\", \"CA\");\n-  public static final Locale CANADA_FRENCH = new Locale (\"fr\", \"CA\");\n-  public static final Locale FRANCE = new Locale (\"fr\", \"FR\");\n-  public static final Locale GERMANY = new Locale (\"de\", \"DE\");\n-  public static final Locale ITALY = new Locale (\"it\", \"IT\");\n-  public static final Locale JAPAN = new Locale (\"ja\", \"JP\");\n-  public static final Locale KOREA = new Locale (\"ko\", \"KR\");\n-  public static final Locale UK = new Locale (\"en\", \"GB\");\n-  public static final Locale US = new Locale (\"en\", \"US\");\n-\n-  // Chinese has multiple scripts and political bodies\n-  public static final Locale SIMPLIFIED_CHINESE = new Locale (\"zh\", \"CN\");\n-  public static final Locale TRADITIONAL_CHINESE = new Locale (\"zh\", \"TW\");\n-  public static final Locale PRC = SIMPLIFIED_CHINESE;\n-  public static final Locale TAIWAN = TRADITIONAL_CHINESE;\n-  public static final Locale CHINA = PRC;\n+  /**\n+   * This is the cached hashcode.  When writing to stream, we write -1.\n+   * @serial\n+   */\n+  private int hashcode;\n+\n+  /**\n+   * Convert old iso639 codes to the new ones.\n+   */\n+  private String convertLanguage(String language)\n+  {\n+    if (language.equals(\"\"))\n+      return language;\n+\n+    language = language.toLowerCase();\n+    int index = \"iw,in,ji\".indexOf(language);\n+    if (index != -1)\n+      return \"he,id,yi\".substring(index, index + 2);\n+    return language;\n+  }\n+\n+  /**\n+   * Creates a new locale for the given language and country.\n+   * @param language lowercase two-letter ISO-639 A2 language code.\n+   * @param country uppercase two-letter ISO-3166 A2 contry code.\n+   * @param variant vendor and browser specific.\n+   */\n+  public Locale(String language, String country, String variant)\n+  {\n+    this.language = convertLanguage(language);\n+    this.country = country.toUpperCase();\n+    this.variant = variant.toUpperCase();\n+    this.hashcode = (this.language.hashCode() ^ this.country.hashCode()\n+\t\t     ^ this.variant.hashCode());\n+  }\n \n-  public Locale (String languageCode, String countryCode)\n+  /**\n+   * Creates a new locale for the given language and country.\n+   * @param language lowercase two-letter ISO-639 A2 language code.\n+   * @param country uppercase two-letter ISO-3166 A2 country code.\n+   */\n+  public Locale(String language, String country)\n   {\n-    this (languageCode, countryCode, \"\");\n+    this(language, country, \"\");\n   }\n \n-  public Locale (String languageCode, String countryCode,\n-\t\t String variantCode)\n+  private static Locale defaultLocale =\n+    new Locale(System.getProperty(\"user.language\", \"\"),\n+\t       System.getProperty(\"user.region\", \"\"),\n+\t       System.getProperty(\"user.variant\", \"\"));\n+\n+  /**\n+   * Returns the default Locale.  The default locale is generally\n+   * once set on start up and then never changed.  Normally you \n+   * should use this locale for everywhere you need a locale.\n+   * The initial setting matches the default locale, the user has\n+   * chosen.\n+   */\n+  public static Locale getDefault()\n   {\n-    language = languageCode.toLowerCase();\n-    country = countryCode.toUpperCase();\n-    variant = variantCode.toUpperCase();\n-    hashcode = (languageCode.hashCode()\n-\t\t^ countryCode.hashCode()\n-\t\t^ variantCode.hashCode());\n+    return defaultLocale;\n   }\n \n-  public Object clone ()\n+  /**\n+   * Changes the default locale.  Normally only called on program\n+   * start up.  Note that this doesn't change the locale for other\n+   * programs.  \n+   */\n+  public static void setDefault(Locale newLocale)\n   {\n-    return (Object) new Locale (language, country, variant);\n+    defaultLocale = newLocale;\n   }\n \n-  public boolean equals (Object obj)\n+  /**\n+   * Returns the list of available locales.\n+   */\n+  public static Locale[] getAvailableLocales()\n+  {\n+    /* I only return those for which localized language\n+     * or country information exists.\n+     * XXX - remove hard coded list.\n+     */\n+    return new Locale[]\n     {\n-      if (! (obj instanceof Locale))\n-\treturn false;\n-      Locale loc = (Locale) obj;\n-      return (language.equals(loc.language)\n-\t      && country.equals(loc.country)\n-\t      && variant.equals(loc.variant));\n-    }\n+      ENGLISH, FRENCH, GERMAN, new Locale(\"ga\", \"\")\n+    };\n+  }\n \n-  public String getCountry ()\n+  /**\n+   * Returns a list of all 2-letter uppercase country codes as defined\n+   * in ISO 3166\n+   */\n+  public static String[] getISOCountries()\n   {\n-    return country;\n+    return new String[]\n+    {\n+       \"AF\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\",\n+       \"AR\", \"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BS\", \"BH\", \"BD\",\n+       \"BB\", \"BY\", \"BE\", \"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BA\",\n+       \"BW\", \"BV\", \"BR\", \"IO\", \"BN\", \"BG\", \"BF\", \"BI\", \"KH\",\n+       \"CM\", \"CA\", \"CV\", \"KY\", \"CF\", \"TD\", \"CL\", \"CN\", \"CX\",\n+       \"CC\", \"CO\", \"KM\", \"CG\", \"CK\", \"CR\", \"CI\", \"HR\", \"CU\",\n+       \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"TP\", \"EC\", \"EG\",\n+       \"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\",\n+       \"FR\", \"FX\", \"GF\", \"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\",\n+       \"GH\", \"GI\", \"GR\", \"GL\", \"GD\", \"GP\", \"GU\", \"GT\", \"GN\",\n+       \"GW\", \"GY\", \"HT\", \"HM\", \"HN\", \"HK\", \"HU\", \"IS\", \"IN\",\n+       \"ID\", \"IR\", \"IQ\", \"IE\", \"IL\", \"IT\", \"JM\", \"JP\", \"JO\",\n+       \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\", \"LA\", \"LV\",\n+       \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\",\n+       \"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\",\n+       \"MU\", \"YT\", \"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"MS\", \"MA\",\n+       \"MZ\", \"MM\", \"NA\", \"NR\", \"NP\", \"NL\", \"AN\", \"NC\", \"NZ\",\n+       \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\", \"NO\", \"OM\", \"PK\",\n+       \"PW\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\", \"PL\", \"PT\",\n+       \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"KN\", \"LC\", \"VC\",\n+       \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"SC\", \"SL\", \"SG\", \"SK\",\n+       \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"ES\", \"LK\", \"SH\", \"PM\",\n+       \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\",\n+       \"TZ\", \"TH\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\",\n+       \"TC\", \"TV\", \"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\",\n+       \"UZ\", \"VU\", \"VA\", \"VE\", \"VN\", \"VG\", \"VI\", \"WF\", \"EH\",\n+       \"YE\", \"YU\", \"ZR\", \"ZM\", \"ZW\"};\n   }\n \n-  public String getLanguage ()\n+  /**\n+   * Returns a list of all 2-letter lowercase language codes as defined\n+   * in ISO 639 (both old and new variant).\n+   */\n+  public static String[] getISOLanguages()\n+  {\n+    return new String[]\n+    {\n+\t\"aa\", \"ab\", \"af\", \"am\", \"ar\", \"as\", \"ay\", \"az\", \"ba\",\n+\t\"be\", \"bg\", \"bh\", \"bi\", \"bn\", \"bo\", \"br\", \"ca\", \"co\",\n+\t\"cs\", \"cy\", \"da\", \"de\", \"dz\", \"el\", \"en\", \"eo\", \"es\",\n+\t\"et\", \"eu\", \"fa\", \"fi\", \"fj\", \"fo\", \"fr\", \"fy\", \"ga\",\n+\t\"gd\", \"gl\", \"gn\", \"gu\", \"ha\", \"iw\", \"he\", \"hi\", \"hr\",\n+\t\"hu\", \"hy\", \"ia\", \"in\", \"id\", \"ie\", \"ik\", \"is\", \"it\",\n+\t\"iu\", \"ja\", \"jw\", \"ka\", \"kk\", \"kl\", \"km\", \"kn\", \"ko\",\n+\t\"ks\", \"ku\", \"ky\", \"la\", \"ln\", \"lo\", \"lt\", \"lv\", \"mg\",\n+\t\"mi\", \"mk\", \"ml\", \"mn\", \"mo\", \"mr\", \"ms\", \"mt\", \"my\",\n+\t\"na\", \"ne\", \"nl\", \"no\", \"oc\", \"om\", \"or\", \"pa\", \"pl\",\n+\t\"ps\", \"pt\", \"qu\", \"rm\", \"rn\", \"ro\", \"ru\", \"rw\", \"sa\",\n+\t\"sd\", \"sg\", \"sh\", \"si\", \"sk\", \"sl\", \"sm\", \"sn\", \"so\",\n+\t\"sq\", \"sr\", \"ss\", \"st\", \"su\", \"sv\", \"sw\", \"ta\", \"te\",\n+\t\"tg\", \"th\", \"ti\", \"tk\", \"tl\", \"tn\", \"to\", \"tr\", \"ts\",\n+\t\"tt\", \"tw\", \"ug\", \"uk\", \"ur\", \"uz\", \"vi\", \"vo\", \"wo\",\n+\t\"xh\", \"ji\", \"yi\", \"yo\", \"za\", \"zh\", \"zu\"};\n+  }\n+\n+  /**\n+   * Returns the language code of this locale.\n+   * @return language code portion of this locale, or an empty String if\n+   * none exists\n+   */\n+  public String getLanguage()\n   {\n     return language;\n   }\n \n-  public String getVariant ()\n+  /**\n+   * Returns the country code of this locale.\n+   * @return country code portion of this locale, or an empty String if\n+   * none exists\n+   */\n+  public String getCountry()\n+  {\n+    return country;\n+  }\n+\n+  /**\n+   * Returns the variant code of this locale.\n+   */\n+  public String getVariant()\n   {\n     return variant;\n   }\n \n-  public int hashCode ()\n+  /**\n+   * Gets the string representation of the current locale.  This\n+   * consists of the language, the country, and the variant,\n+   * separated by an underscore.  If one of this three component is\n+   * missing the underscore will also disappear.  \n+   * @return the string representation of this Locale.\n+   */\n+  public final String toString()\n   {\n-    return hashcode;\n+    StringBuffer result = new StringBuffer(language);\n+    String underscore = \"\";\n+    if (language.length() != 0)\n+      underscore = \"_\";\n+    if (country.length() != 0)\n+      {\n+\tresult.append(underscore);\n+\tresult.append(country);\n+\tunderscore = \"_\";\n+      }\n+    if (variant.length() != 0)\n+      {\n+\tresult.append(underscore);\n+\tresult.append(variant);\n+      }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns the three-letter ISO language abbrevation of this locale.\n+   * @exception MissingResourceException if the three-letter code is not\n+   * known.  \n+   */\n+  public String getISO3Language() throws MissingResourceException\n+  {\n+    int index =\n+      (\"aa,ab,af,am,ar,as,ay,az,ba,be,bg,bh,bi,bn,bo,br,ca,co,cs,cy,\" +\n+       \"da,de,dz,el,en,eo,es,et,eu,fa,fi,fj,fo,fr,fy,ga,gd,gl,gn,gu,\" +\n+       \"gv,ha,hi,hr,hu,hy,ia,ie,ik,id,is,it,iu,he,ja,yi,jw,ka,kk,kl,\" +\n+       \"km,kn,ko,ks,ku,kw,ky,la,lb,ln,lo,lt,lv,mg,mi,mk,ml,mn,mo,mr,\" +\n+       \"ms,mt,my,na,ne,nl,no,oc,om,or,pa,pl,ps,pt,qu,rm,rn,ro,ru,rw,\" +\n+       \"sa,sd,se,sg,sh,si,sk,sl,sm,sn,so,sq,sr,ss,st,su,sv,sw,ta,te,\" +\n+       \"tg,th,ti,tk,tl,tn,to,tr,ts,tt,tw,ug,uk,ur,uz,vi,vo,wo,xh,yo,\" +\n+       \"za,zh,zu,\").indexOf(language + \",\");\n+       \n+    if (index == -1 || language.length() != 2)\n+      throw new MissingResourceException\n+\t(\"Can't find ISO3 language for \" + language,\n+\t \"java.util.Locale\", language);\n+\n+    /* Don't read this aloud.  This are the three letter language codes\n+     */\n+    return\n+      (\"aarabkaframharaasmaymazebakbelbulbihbisbenbodbrecatcoscescym\" +\n+       \"dandeudzoellengepospaesteusfasfinfijfaofrafrygaigdhglggrnguj\" +\n+       \"maxhauhinhrvhunhyeinaileipkindislitaikuhebjpnyidjawkatkazkal\" +\n+       \"khmkankorkaskurcorkirlatltzlinlaolitlavmlgmrimkdmalmonmolmar\" +\n+       \"msamltmyanaunepnldnorociormoripanpolpusporquerohrunronruskin\" +\n+       \"sansndsmisagsrpsinslkslvsmosnasomsqisrpsswsotsunsweswatamtel\" +\n+       \"tgkthatirtuktgltsntonturtsotattwiuigukrurduzbvievolwolxhoyor\" +\n+       \"zhazhozul\").substring(index, index + 3);\n   }\n \n-  private static synchronized Locale setDefault()\n+  /**\n+   * Returns the three-letter ISO country abbrevation of the locale.\n+   * @exception MissingResourceException if the three-letter code is not\n+   * known.\n+   */\n+  public String getISO3Country() throws MissingResourceException\n   {\n-    if (defaultLocale != null)\n-      return defaultLocale;\n-    String language = System.getProperty(\"user.language\");\n-    String country = System.getProperty(\"user.region\");\n-    defaultLocale = new Locale (language == null ? \"en\" : language,\n-\t\t\t\tcountry == null ? \"\" : country);\n-    return defaultLocale;\n+    int index =\n+      (\"AF,AL,DZ,AS,AD,AO,AI,AQ,AG,AR,AM,AW,AU,AT,AZ,BS,BH,BD,BB,BY,BE,\" +\n+       \"BZ,BJ,BM,BT,BO,BA,BW,BV,BR,IO,BN,BG,BF,BI,KH,CM,CA,CV,KY,CF,TD,\" +\n+       \"CL,CN,CX,CC,CO,KM,CG,CD,CK,CR,CI,HR,CU,CY,CZ,DK,DJ,DM,DO,TP,EC,\" +\n+       \"EG,SV,GQ,ER,EE,ET,FK,FO,FJ,FI,FR,FX,GF,PF,TF,GA,GM,GE,DE,GH,GI,\" +\n+       \"GR,GL,GD,GP,GU,GT,GN,GW,GY,HT,HM,VA,HN,HK,HU,IS,IN,ID,IR,IQ,IE,\" +\n+       \"IL,IT,JM,JP,JO,KZ,KE,KI,KP,KR,KW,KG,LA,LV,LB,LS,LR,LY,LI,LT,LU,\" +\n+       \"MO,MK,MG,MW,MY,MV,ML,MT,MH,MQ,MR,MU,YT,MX,FM,MD,MC,MN,MS,MA,MZ,\" +\n+       \"MM,NA,NR,NP,NL,AN,NC,NZ,NI,NE,NG,NU,NF,MP,NO,OM,PK,PW,PA,PG,PY,\" +\n+       \"PE,PH,PN,PL,PT,PR,QA,RE,RO,RU,RW,KN,LC,VC,WS,SM,ST,SA,SN,SC,SL,\" +\n+       \"SG,SK,SI,SB,SO,ZA,GS,ES,LK,SH,PM,SD,SR,SJ,SZ,SE,CH,SY,TW,TJ,TZ,\" +\n+       \"TH,TG,TK,TO,TT,TN,TR,TM,TC,TV,UG,UA,AE,GB,US,UM,UY,UZ,VU,VE,VN,\" +\n+       \"VG,VI,WF,EH,YE,YU,ZM,ZW,\").indexOf(country + \",\");\n+       \n+    if (index == -1 || language.length() != 2)\n+      throw new MissingResourceException\n+\t(\"Can't find ISO3 country for \" + country,\n+\t \"java.util.Locale\", country);\n+\n+    /* Don't read this aloud.  This are the three letter country codes\n+     */\n+    return\n+      (\"AFGALBDZAASMANDAGOAIAATAATGARGARMABWAUSAUTAZEBHSBHRBGDBRBBLRBEL\" +\n+       \"BLZBENBMUBTNBOLBIHBWABVTBRAIOTBRNBGRBFABDIKHMCMRCANCPVCYMCAFTCD\" +\n+       \"CHLCHNCXRCCKCOLCOMCOGCODCOKCRICIVHRVCUBCYPCZEDNKDJIDMADOMTMPECU\" +\n+       \"EGYSLVGNQERIESTETHFLKFROFJIFINFRAFXXGUFPYFATFGABGMBGEODEUGHAGIB\" +\n+       \"GRCGRLGRDGLPGUMGTMGINGNBGUYHTIHMDVATHNDHKGHUNISLINDIDNIRNIRQIRL\" +\n+       \"ISRITAJAMJPNJORKAZKENKIRPRKKORKWTKGZLAOLVALBNLSOLBRLBYLIELTULUX\" +\n+       \"MACMKDMDGMWIMYSMDVMLIMLTMHLMTQMRTMUSMYTMEXFSMMDAMCOMNGMSRMARMOZ\" +\n+       \"MMRNAMNRUNPLNLDANTNCLNZLNICNERNGANIUNFKMNPNOROMNPAKPLWPANPNGPRY\" +\n+       \"PERPHLPCNPOLPRTPRIQATREUROMRUSRWAKNALCAVCTWSMSMRSTPSAUSENSYCSLE\" +\n+       \"SGPSVKSVNSLBSOMZAFSGSESPLKASHNSPMSDNSURSJMSWZSWECHESYRTWNTJKTZA\" +\n+       \"THATGOTKLTONTTOTUNTURTKMTCATUVUGAUKRAREGBRUSAUMIURYUZBVUTVENVNM\" +\n+       \"VGBVIRWLFESHYEMYUGZMBZWE\").substring(index, index + 3);\n   }\n \n-  public static Locale getDefault ()\n+  /** \n+   * Gets the country name suitable for display to the user, formatted\n+   * for the default locale.  This has the same effect as\n+   * <pre>\n+   * getDisplayLanguage(Locale.getDefault());\n+   * </pre>\n+   *\n+   * @return the language name of this locale localized to the\n+   * default locale.  If the localized is not found, the ISO code\n+   * is returned.\n+   */\n+  public String getDisplayLanguage()\n   {\n-    return defaultLocale == null ? setDefault() : defaultLocale;\n+    return getDisplayLanguage(getDefault());\n   }\n \n-  public static void setDefault (Locale newLocale)\n+  /** \n+   * Gets the language name suitable for display to the user, formatted\n+   * for a specified locale.\n+   * @param locale locale to use for formatting\n+   * @return the language name of this locale localized to the\n+   * given locale.  If the localized is not found, the ISO code\n+   * is returned.\n+   */\n+  public String getDisplayLanguage(Locale locale)\n   {\n-    defaultLocale = newLocale;\n+    try\n+      {\n+\tResourceBundle bundle\n+\t  = ResourceBundle.getBundle(\"gnu.java.locale.iso639\", locale);\n+\treturn bundle.getString(language);\n+      }\n+    catch (MissingResourceException ex)\n+      {\n+\treturn language;\n+      }\n+  }\n+\n+  /** \n+   * Returns the country name of this locale localized to the\n+   * default locale.  If the localized is not found, the ISO code\n+   * is returned.  This has the same effect as\n+   * <pre>\n+   * getDisplayCountry(Locale.getDefault());\n+   * </pre>\n+   */\n+  public String getDisplayCountry()\n+  {\n+    return getDisplayCountry(getDefault());\n   }\n \n-  public String toString ()\n+  /** \n+   * Gets the country name suitable for display to the user, formatted\n+   * for a specified locale.\n+   *\n+   * @param locale locale to use for formatting\n+   * @return the country name of this locale localized to the given\n+   * locale.  If the localized is not found, the ISO country code is\n+   * returned.  */\n+  public String getDisplayCountry(Locale locale)\n   {\n-    StringBuffer result = new StringBuffer(20);\n-    result.append(language);\n-    if (country.length() > 0)\n+    try\n       {\n-\tresult.append('_');\n-\tresult.append(country);\n-\tif (variant.length() > 0)\n-\t  {\n-\t    result.append('_');\n-\t    result.append(variant);\n-\t  }\n+\tResourceBundle bundle =\n+\t  ResourceBundle.getBundle(\"gnu.java.locale.iso3166\", locale);\n+\treturn bundle.getString(country);\n+      }\n+    catch (MissingResourceException ex)\n+      {\n+\treturn country;\n       }\n+  }\n+\n+  /** \n+   * Returns the variant name of this locale localized to the\n+   * default locale.  If the localized is not found, the variant code\n+   * itself is returned.  This has the same effect as\n+   * <pre>\n+   * getDisplayVariant(Locale.getDefault());\n+   * </pre>\n+   */\n+  public String getDisplayVariant()\n+  {\n+    return getDisplayVariant(getDefault());\n+  }\n+\n+  /** \n+   * Returns the variant name of this locale localized to the\n+   * given locale.  If the localized is not found, the variant code\n+   * itself is returned.\n+   */\n+  public String getDisplayVariant(Locale locale)\n+  {\n+    /*XXX - load a bundle? */\n+    return variant;\n+  }\n+\n+  /**\n+   * Gets all local components suitable for display to the user, formatted\n+   * for the default locale.  For the language component, getDisplayLanguage\n+   * is called.  For the country component, getDisplayCountry is called.\n+   * For the variant set component, getDisplayVariant is called.\n+   * <br><br>\n+   * The returned String will be one of the following forms:<br>\n+   * <pre>\n+   * language (country, variant)\n+   * language (country)\n+   * language (variant)\n+   * country (variant)\n+   * language\n+   * country\n+   * variant\n+   * </pre>\n+   * @return String version of this locale, suitable for display to the\n+   * user.\n+   */\n+  public String getDisplayName()\n+  {\n+    return getDisplayName(getDefault());\n+  }\n+\n+  /**\n+   * Gets all local components suitable for display to the user, formatted\n+   * for a specified locale.  For the language component, \n+   * getDisplayLanguage(Locale) is called.  For the country component, \n+   * getDisplayCountry(Locale) is called.  For the variant set component, \n+   * getDisplayVariant(Locale) is called.\n+   * <br><br>\n+   * The returned String will be one of the following forms:<br>\n+   * <pre>\n+   * language (country, variant)\n+   * language (country)\n+   * language (variant)\n+   * country (variant)\n+   * language\n+   * country\n+   * variant\n+   * </pre>\n+   *\n+   * @param locale locale to use for formatting\n+   *\n+   * @return String version of this locale, suitable for display to the\n+   * user.\n+   */\n+  public String getDisplayName(Locale locale)\n+  {\n+    StringBuffer result = new StringBuffer();\n+    int count = 0;\n+    String[] delimiters = {\"\", \" (\", \",\"};\n+    \n+    if (language.length() != 0)\n+      {\n+\tresult.append(delimiters[count++]);\n+\tresult.append(getDisplayLanguage(locale));\n+      }\n+\n+    if (country.length() != 0)\n+      {\n+\tresult.append(delimiters[count++]);\n+\tresult.append(getDisplayCountry(locale));\n+      }\n+\n+    if (variant.length() != 0)\n+      {\n+\tresult.append(delimiters[count++]);\n+\tresult.append(getDisplayVariant(locale));\n+      }\n+\n+    if (count > 1)\n+      result.append(\")\");\n+      \n     return result.toString();\n   }\n \n- /**\n+  /**\n+   * Does the same as <code>Object.clone()</code> but does not throw\n+   * an <code>CloneNotSupportedException</code>.  Why anyone would\n+   * use this method is a secret to me, since this class is\n+   * immutable.  \n+   */\n+  public Object clone()\n+  {\n+    try\n+      {\n+\treturn super.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * Return the hash code for this locale.  The hashcode is the logical\n+   * xor of the hash codes of the language, the country and the variant.\n+   * The hash code is precomputed, since <code>Locale</code>s are often\n+   * used in hash tables.\n+   */\n+  public synchronized int hashCode()\n+  {\n+    // This method is synchronized because writeObject() might reset\n+    // the hashcode.\n+    return hashcode;\n+  }\n+\n+  /**\n+   * Compares two locales.\n+   * @param obj the other locale.\n+   * @return true, if obj is a Locale with the same language, country, and\n+   * variant code as this locale, otherwise false.\n+   */\n+  public boolean equals(Object obj)\n+  {\n+    if (this == obj)\n+      return true;\n+    if (!(obj instanceof Locale))\n+      return false;\n+    Locale l = (Locale) obj;\n+    return (language.equals(l.language)\n+\t    && country.equals(l.country)\n+\t    && variant.equals(l.variant));\n+  }\n+\n+  /**\n    * @serialdata According to jdk1.2 the hashcode should always be \n    * written as -1; \n    */\n-  private void writeObject(java.io.ObjectOutputStream output)\n+  private synchronized void writeObject(java.io.ObjectOutputStream output)\n     throws java.io.IOException\n   {\n     int tmpHashcode = hashcode;"}, {"sha": "4408ef4013e4d5af4382d69cc9ea28ca8cf39f22", "filename": "libjava/java/util/MissingResourceException.java", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FMissingResourceException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FMissingResourceException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FMissingResourceException.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,43 +1,88 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.MissingResourceException\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n+\n+/**\n+ * This exception is thrown when a resource is missing.\n+ *\n+ * @see ResourceBundle\n+ * @author Jochen Hoenicke\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ */\n public class MissingResourceException extends RuntimeException\n {\n+  private static final long serialVersionUID = -4876345176062000401L;\n+\n+  /**\n+   * The name of the resource bundle requested by user.\n+   */\n   private String className;\n+\n+  /**\n+   * The key of the resource in the bundle requested by user.\n+   */\n   private String key;\n \n-  public MissingResourceException(String msg, String cName, String k)\n+  /**\n+   * Creates a new exception, with the specified parameters.\n+   * @param s the detail message.\n+   * @param className the name of the resource bundle.\n+   * @param key the key of the missing resource.\n+   */\n+  public MissingResourceException(String s, String className, String key)\n   {\n-    super(msg);\n-    className = cName;\n-    key = k;\n+    super(s);\n+    this.className = className;\n+    this.key = key;\n   }\n \n+  /**\n+   * Gets the name of the resource bundle, for which a resource is missing.\n+   * @return the name of the resource bundle.\n+   */\n   public String getClassName()\n   {\n     return className;\n   }\n \n+  /**\n+   * Gets the key of the resource that is missing bundle, this is an empty\n+   * string if the whole resource bundle is missing.\n+   * @return the name of the resource bundle.\n+   */\n   public String getKey()\n   {\n     return key;\n   }\n }\n-"}, {"sha": "5ca6544c340743e1eb13a80ccf96cff71ef4bb00", "filename": "libjava/java/util/NoSuchElementException.java", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FNoSuchElementException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FNoSuchElementException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FNoSuchElementException.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,32 +1,66 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* NoSuchElementException.java -- Attempt to access element that does not exist\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n+\n+/**\n+ * Exception thrown when an attempt is made to access an element that does not\n+ * exist. This exception is thrown by the Enumeration, Iterator and ListIterator\n+ * classes if the nextElement, next or previous method goes beyond the end of\n+ * the list of elements that are being accessed.\n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 2, 1998.\n+ */\n public class NoSuchElementException extends RuntimeException\n {\n+  private static final long serialVersionUID = 6769829250639411880L;\n+\n+  /**\n+   * Constructs a NoSuchElementException with no detail message.\n+   */\n   public NoSuchElementException()\n   {\n     super();\n   }\n \n-  public NoSuchElementException(String msg)\n+  /**\n+   * Constructs a NoSuchElementException with a detail message.\n+   *\n+   * @param detail the detail message for the exception\n+   */\n+  public NoSuchElementException(String detail)\n   {\n-    super(msg);\n+    super(detail);\n   }\n }"}, {"sha": "3a5629c0a448702a4c9125e5a961862143c2e3f0", "filename": "libjava/java/util/PropertyResourceBundle.java", "status": "modified", "additions": 121, "deletions": 35, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,47 +1,133 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* java.util.PropertyResourceBundle\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-import java.io.InputStream;\n-import java.io.IOException;\n-import gnu.gcj.util.EnumerationChain;\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-/**\n- * @author Anthony Green <green@cygnus.com>\n- * @date April 29, 1999.\n- */\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.  */\n \n+package java.util;\n+\n+import gnu.java.util.DoubleEnumeration;\n+\n+/**\n+ * This class is a concrete <code>ResourceBundle</code> that gets it\n+ * resources from a property file.  This implies that the resources are\n+ * strings. For more information about resource bundles see the class\n+ * <code>ResourceBundle</code>.\n+ *\n+ * You should not use this class directly, or subclass it, but you get\n+ * an object of this class automatically when you call\n+ * <code>ResourceBundle.getBundle()</code> and there is a properties\n+ * file.\n+ *\n+ * If there is also a class for this resource and the same locale, the\n+ * class does win.\n+ *\n+ * The properties file should have the name of the resource bundle,\n+ * appended with the locale (e.g. <code>_de</code) and the extension\n+ * <code>.properties</code>.  The file should have the same format\n+ * as for <code>Properties.load()</code>\n+ *\n+ * XXX- move this to properties.\n+ * The file should have the following\n+ * format: An empty line or a line starting with <code>#</code> is\n+ * ignored.  An backslash (<code>\\</code>) at the end of the line\n+ * makes the line continueing on the next line.  Otherwise, each line\n+ * describes a key/value pair.  The chars up to the first whitespace,\n+ * = or : are the key.  The key is followed by one or more\n+ * whitespaces, <code>=</code> or <code>:</code>.  The rest of the\n+ * line is the resource belonging to the key.  You can give unicode\n+ * characters with the <code>\\\\uxxxx</code> notation, where\n+ * <code>xxxx</code> is the hex encoding of the 16 bit unicode char\n+ * number.\n+ *\n+ * An example of a properties file for the german language is given\n+ * here.  This extends the example given in ListResourceBundle.\n+ * Create a file MyResource_de.properties with the following contents\n+ * and put it in the CLASSPATH.  (The char <code>\\u00e4<char> is the \n+ * german &auml;)\n+ * \n+ * <pre>\n+ * s1=3\n+ * s2=MeineDisk\n+ * s3=3. M\\u00e4rz 96\n+ * s4=Die Diskette ''{1}'' enth\\u00e4lt {0} in {2}.\n+ * s5=0\n+ * s6=keine Dateien\n+ * s7=1\n+ * s8=eine Datei\n+ * s9=2\n+ * s10={0,number} Dateien\n+ * s11=Die Formatierung warf eine Exception: {0}\n+ * s12=FEHLER\n+ * s13=Ergebnis\n+ * s14=Dialog\n+ * s15=Auswahlkriterium\n+ * s16=1,3\n+ * </pre>\n+ *\n+ * @see ResourceBundle\n+ * @see ListResourceBundle\n+ * @see Properties#load()\n+ * @author Jochen Hoenicke */\n public class PropertyResourceBundle extends ResourceBundle\n {\n-  private Properties properties;\n+  Properties properties;\n+\n+  /**\n+   * Creates a new property resource bundle.\n+   * @param stream An input stream, where the resources are read from.\n+   */\n+  public PropertyResourceBundle(java.io.InputStream stream)\n+    throws java.io.IOException\n+  {\n+    properties = new Properties();\n+    properties.load(stream);\n+  }\n \n-  public PropertyResourceBundle (InputStream pstream) throws IOException\n-    {\n-      // Initialize and load our Properties.\n-      properties = new Properties();\n-      properties.load(pstream);\n-    }\n+  /**\n+   * Called by <code>getObject</code> when a resource is needed.  This\n+   * returns the resource given by the key.\n+   * @param key The key of the resource.\n+   * @return The resource for the key or null if it doesn't exists.\n+   */\n+  protected Object handleGetObject(String key)\n+  {\n+    return properties.getProperty(key);\n+  }\n \n+  /**\n+   * This method should return all keys for which a resource exists.\n+   * @return An enumeration of the keys.\n+   */\n   public Enumeration getKeys()\n-    {\n-      if (parent == null)\n-        return properties.propertyNames();\n-      else\n-        return new EnumerationChain (properties.propertyNames(),\n-                                     parent.getKeys ());\n-    }\n-\n-  public Object handleGetObject (String key)\n-    {\n-      return properties.getProperty(key);\n-    }\n-}    \n+  {\n+    // We must also return the keys of our parent.\n+    if (parent != null)\n+      {\n+\treturn new DoubleEnumeration(properties.propertyNames(),\n+\t\t\t\t     parent.getKeys());\n+      }\n+    return properties.propertyNames();\n+  }\n+}"}, {"sha": "aa25a697d65e6bebe778420da8ee0a846defbc86", "filename": "libjava/java/util/Random.java", "status": "modified", "additions": 323, "deletions": 94, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FRandom.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FRandom.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FRandom.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,150 +1,379 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.Random\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-import java.io.Serializable;\n+\n+package java.util;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 25, 1998.\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n- */\n-\n-/* This class is completely specified by the spec to ensure absolute\n- * portability between all implementations of Java \n- */\n-public class Random implements Serializable\n+ * This class generates pseudorandom numbers.  It uses the same\n+ * algorithm as the original JDK-class, so that your programs behave\n+ * exactly the same way, if started with the same seed.\n+ *\n+ * The algorithm is described in <em>The Art of Computer Programming,\n+ * Volume 2</em> by Donald Knuth in Section 3.2.1.\n+ *\n+ * If two instances of this class are created with the same seed and\n+ * the same calls to these classes are made, they behave exactly the\n+ * same way.  This should be even true for foreign implementations\n+ * (like this), so every port must use the same algorithm as described\n+ * here.\n+ *\n+ * If you want to implement your own pseudorandom algorithm, you\n+ * should extend this class and overload the <code>next()</code> and\n+ * <code>setSeed(long)</code> method.  In that case the above\n+ * paragraph doesn't apply to you.\n+ *\n+ * This class shouldn't be used for security sensitive purposes (like \n+ * generating passwords or encryption keys.  See <code>SecureRandom</code>\n+ * in package <code>java.security</code> for this purpose.\n+ *\n+ * For simple random doubles between 0.0 and 1.0, you may consider using\n+ * Math.random instead.\n+ *\n+ * @see java.security.SecureRandom\n+ * @see Math#random()\n+ * @author Jochen Hoenicke */\n+public class Random implements java.io.Serializable\n {\n-  /* Used by next() to hold the state of the pseudorandom number generator */\n-  private long seed;\n-\n-  /* Used by nextGaussian() to hold a precomputed value */\n-  /* to be delivered by that method the next time it is called */\n+  /**\n+   * True if the next nextGaussian is available.  This is used by\n+   * nextGaussian, which generates two gaussian numbers by one call,\n+   * and returns the second on the second call.  \n+   * @see #nextGaussian.  */\n+  private boolean haveNextNextGaussian;\n+  /**\n+   * The next nextGaussian if available.  This is used by nextGaussian,\n+   * which generates two gaussian numbers by one call, and returns the\n+   * second on the second call.\n+   * @see #nextGaussian.\n+   */\n   private double nextNextGaussian;\n-\n-  /* Used by nextGaussian() to keep track of whether it is has precomputed */\n-  /* and stashed away the next value to be delivered by that method */\n-  private boolean haveNextNextGaussian = false;\n+  /**\n+   * The seed.  This is the number set by setSeed and which is used\n+   * in next.\n+   * @see #next\n+   */\n+  private long seed;\n \n   private static final long serialVersionUID = 3905348978240129619L;\n \n+  /**\n+   * Creates a new pseudorandom number generator.  The seed is initialized\n+   * to the current time as follows.\n+   * <pre>\n+   * setSeed(System.currentTimeMillis());\n+   * </pre>\n+   * @see System#currentTimeMillis()\n+   */\n   public Random()\n   {\n-    this(System.currentTimeMillis());\n+    setSeed(System.currentTimeMillis());\n   }\n \n+  /**\n+   * Creates a new pseudorandom number generator, starting with the\n+   * specified seed. This does:\n+   * <pre>\n+   * setSeed(seed);\n+   * </pre>\n+   * @param seed the initial seed.\n+   */\n   public Random(long seed)\n   {\n     setSeed(seed);\n   }\n \n-  protected synchronized int next(int bits)\n-  {\n-    seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\n-    return (int)(seed >>> (48 - bits));\n-  }\n-\n-  // JDK1.2\n-  public boolean nextBoolean()\n-  {\n-    return next(1) != 0;\n-  }\n-\n-  /* The method nextBytes() is not fully specified in the published specs.\n-   * At first I implemented it simply via:\n-   *\tfor (int i = 0; i < buf.length; i++)\n-   *\t  buf[i] = (byte)next(8);\n-   * but a simple test did not yield the same results as the std implementation.\n-   * There seemed to be a relationship where each i byte above was at pos 4*i+3\n-   * in the std.  For efficiency, by reducing calls to the expensive math\n-   * routines, the std probably was calling next(32) once rather than next(8)\n-   * 4 times.  Changing the algorithm to the one below based on that assumption\n-   * then yielded identical results to the std.\n+  /**\n+   * Sets the seed for this pseudorandom number generator.  As described\n+   * above, two instances of the same random class, starting with the\n+   * same seed, should produce the same results, if the same methods\n+   * are called.  The implementation for java.util.Random is:\n+   * <pre>\n+   * public synchronized void setSeed(long seed) {\n+   *     this.seed = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1);\n+   *     haveNextNextGaussian = false;\n+   * }\n+   * </pre>\n    */\n-  public void nextBytes(byte[] buf)\n-  {\n-    int randInt = 0;\n-\n-    for (int i = 0;  i < buf.length;  i++)\n-      {\n-\tint shift = (i % 4) * 8;\n-        if (shift == 0)\n-            randInt = next(32);\n-        buf[i] = (byte) (randInt >> shift);\n-      }\n-  }\n-\n-  public double nextDouble()\n+  public synchronized void setSeed(long seed)\n   {\n-    return (((long)next(26) << 27) + next(27)) / (double)(1L << 53);\n+    this.seed = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1);\n+    haveNextNextGaussian = false;\n   }\n \n-  public float nextFloat()\n+  /**\n+   * Generates the next pseudorandom number.  This returns\n+   * an int value whose <code>bits</code> low order bits are\n+   * independent chosen random bits (0 and 1 are equally likely).\n+   * The implementation for java.util.Random is:\n+   * <pre>\n+   * protected synchronized int next(int bits) {\n+   *     seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\n+   *     return (int) (seed >>> (48 - bits));\n+   * }\n+   * </pre>\n+   * @param bits the number of random bits to generate.  Must be in range\n+   * 1..32.\n+   * @return the next pseudorandom value.\n+   * @since JDK1.1\n+   */\n+  protected synchronized int next(int bits)\n+    /*{ require { 1 <= bits && bits <=32 :: \n+       \"bits \"+bits+\" not in range [1..32]\" } } */\n   {\n-    return next(24) / ((float)(1 << 24));\n+    seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\n+    return (int) (seed >>> (48 - bits));\n   }\n \n-  public synchronized double nextGaussian()\n+  /**\n+   * Fills an array of bytes with random numbers.  All possible values\n+   * are (approximately) equally likely.\n+   * The JDK documentation gives no implementation, but it seems to be:\n+   * <pre>\n+   * public void nextBytes(byte[] bytes) {\n+   *     for (int i=0; i< bytes.length; i+=4) {\n+   *         int random = next(32);\n+   *         for (int j=0; i+j< bytes.length && j<4; j++)\n+   *             bytes[i+j] = (byte) (random & 0xff)\n+   *             random >>= 8;\n+   *         }\n+   *     }\n+   * }\n+   * </pre>\n+   * @param bytes The byte array that should be filled.\n+   * @since JDK1.1\n+   */\n+  public void nextBytes(byte[] bytes)\n+    /*{ require { bytes != null :: \"bytes is null\"; } } */\n   {\n-    if (haveNextNextGaussian)\n+    int random;\n+    /* Do a little bit unrolling of the above algorithm. */\n+    int max = bytes.length & ~0x3;\n+    for (int i = 0; i < max; i += 4)\n       {\n-        haveNextNextGaussian = false;\n-        return nextNextGaussian;\n+\trandom = next(32);\n+\tbytes[i] = (byte) random;\n+\tbytes[i + 1] = (byte) (random >> 8);\n+\tbytes[i + 2] = (byte) (random >> 16);\n+\tbytes[i + 3] = (byte) (random >> 24);\n       }\n-    else\n+    if (max < bytes.length)\n       {\n-        double v1, v2, s;\n-        do\n-\t  { \n-            v1 = 2 * nextDouble() - 1;   // between -1.0 and 1.0\n-            v2 = 2 * nextDouble() - 1;   // between -1.0 and 1.0\n-            s = v1 * v1 + v2 * v2;\n-          } while (s >= 1);\n-        double norm = Math.sqrt(-2 * Math.log(s)/s);\n-        nextNextGaussian = v2 * norm;\n-        haveNextNextGaussian = true;\n-        return v1 * norm;\n+\trandom = next(32);\n+\tfor (int j = max; j < bytes.length; j++)\n+\t  {\n+\t    bytes[j] = (byte) random;\n+\t    random >>= 8;\n+\t  }\n       }\n   }\n \n+  /**\n+   * Generates the next pseudorandom number.  This returns\n+   * an int value whose 32 bits are independent chosen random bits\n+   * (0 and 1 are equally likely).  The implementation for\n+   * java.util.Random is:\n+   * <pre>\n+   * public int nextInt() {\n+   *     return next(32);\n+   * }\n+   * </pre>\n+   *\n+   * @return the next pseudorandom value.  */\n   public int nextInt()\n   {\n     return next(32);\n   }\n \n-  // JDK1.2\n+  /**\n+   * Generates the next pseudorandom number.  This returns\n+   * a value between 0(inclusive) and <code>n</code>(exclusive), and\n+   * each value has the same likelihodd (1/<code>n</code>).\n+   * (0 and 1 are equally likely).  The implementation for\n+   * java.util.Random is:\n+   * <pre>\n+   * public int nextInt(int n) {\n+   *     if (n<=0)\n+   *         throw new IllegalArgumentException(\"n must be positive\");\n+   *     if ((n & -n) == n)  // i.e., n is a power of 2\n+   *         return (int)((n * (long)next(31)) >> 31);\n+   *     int bits, val;\n+   *     do {\n+   *         bits = next(32);\n+   *         val = bits % n;\n+   *     } while(bits - val + (n-1) < 0);\n+   *     return val;\n+   * }\n+   * </pre>\n+   * This algorithm would return every value with exactly the same \n+   * probability, if the next()-method would be a perfect random number\n+   * generator.\n+   * \n+   * The loop at the bottom only accepts a value, if the random\n+   * number was between 0 and the highest number less then 1<<31,\n+   * which is divisible by n.  The probability for this is high for small\n+   * n, and the worst case is 1/2 (for n=(1<<30)+1).\n+   *\n+   * The special treatment for n = power of 2, selects the high bits of \n+   * the random number (the loop at the bottom would select the low order\n+   * bits).  This is done, because the low order bits of linear congruential\n+   * number generators (like the one used in this class) are known to be \n+   * ``less random'' than the high order bits.\n+   *\n+   * @param n the upper bound.\n+   * @exception IllegalArgumentException if the given upper bound is negative\n+   * @return the next pseudorandom value.  \n+   */\n   public int nextInt(int n)\n+    /*{ require { n > 0 :: \"n must be positive\"; } } */\n   {\n     if (n <= 0)\n       throw new IllegalArgumentException(\"n must be positive\");\n-\n+    if ((n & -n) == n)\t\t// i.e., n is a power of 2\n+      return (int) ((n * (long) next(31)) >> 31);\n     int bits, val;\n     do\n       {\n-        bits = next(31);\n-        val = bits % n;\n-      } while (bits - val + (n-1) < 0);\n+\tbits = next(32);\n+\tval = bits % n;\n+      }\n+    while (bits - val + (n - 1) < 0);\n     return val;\n   }\n \n+  /**\n+   * Generates the next pseudorandom long number.  All bits of this\n+   * long are independently chosen and 0 and 1 have equal likelihood.\n+   * The implementation for java.util.Random is:\n+   * <pre>\n+   * public long nextLong() {\n+   *     return ((long)next(32) << 32) + next(32);\n+   * }\n+   * </pre>\n+   * @return the next pseudorandom value.  \n+   */\n   public long nextLong()\n   {\n-    return ((long)next(32) << 32) + next(32);\n+    return ((long) next(32) << 32) + next(32);\n   }\n \n-  public synchronized void setSeed(long seed)\n+  /**\n+   * Generates the next pseudorandom boolean.  True and false have\n+   * the same probability.  The implementation is:\n+   * <pre>\n+   * public boolean nextBoolean() {\n+   *     return next(1) != 0;\n+   * }\n+   * </pre>\n+   * @return the next pseudorandom boolean.\n+   */\n+  public boolean nextBoolean()\n   {\n-    this.seed = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1);\n-    haveNextNextGaussian = false;\n+    return next(1) != 0;\n+  }\n+\n+  /**\n+   * Generates the next pseudorandom float uniformly distributed\n+   * between 0.0f (inclusive) and 1.0 (exclusive).  The\n+   * implementation is as follows.\n+   * <pre>\n+   * public float nextFloat() {\n+   *     return next(24) / ((float)(1 << 24));\n+   * }\n+   * </pre>\n+   * @return the next pseudorandom float.  */\n+  public float nextFloat()\n+  {\n+    return next(24) / ((float) (1 << 24));\n+  }\n+\n+  /**\n+   * Generates the next pseudorandom double uniformly distributed\n+   * between 0.0f (inclusive) and 1.0 (exclusive).  The\n+   * implementation is as follows.\n+   * <pre>\n+   * public double nextDouble() {\n+   *     return (((long)next(26) << 27) + next(27)) / (double)(1 << 53);\n+   * }\n+   * </pre>\n+   * @return the next pseudorandom double.  */\n+  public double nextDouble()\n+  {\n+    return (((long) next(26) << 27) + next(27)) / (double) (1L << 53);\n+  }\n+\n+  /**\n+   * Generates the next pseudorandom, Gaussian (normally) distributed \n+   * double value, with mean 0.0 and standard deviation 1.0.\n+   * The algorithm is as follows.\n+   * <pre>\n+   * public synchronized double nextGaussian() {\n+   *     if (haveNextNextGaussian) {\n+   *         haveNextNextGaussian = false;\n+   *         return nextNextGaussian;\n+   *     } else {\n+   *         double v1, v2, s;\n+   *         do {\n+   *             v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n+   *             v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n+   *             s = v1 * v1 + v2 * v2;\n+   *         } while (s >= 1);\n+   *         double norm = Math.sqrt(-2 * Math.log(s)/s);\n+   *         nextNextGaussian = v2 * norm;\n+   *         haveNextNextGaussian = true;\n+   *         return v1 * norm;\n+   *     }\n+   * }\n+   * </pre>\n+   * This is described in section 3.4.1 of <em>The Art of Computer\n+   * Programming, Volume 2</em> by Donald Knuth.\n+   *\n+   * @return the next pseudorandom Gaussian distributed double.  \n+   */\n+  public synchronized double nextGaussian()\n+  {\n+    if (haveNextNextGaussian)\n+      {\n+\thaveNextNextGaussian = false;\n+\treturn nextNextGaussian;\n+      }\n+    else\n+      {\n+\tdouble v1, v2, s;\n+\tdo\n+\t  {\n+\t    v1 = 2 * nextDouble() - 1;\t// between -1.0 and 1.0\n+\t    v2 = 2 * nextDouble() - 1;\t// between -1.0 and 1.0\n+\t    s = v1 * v1 + v2 * v2;\n+\t  }\n+\twhile (s >= 1);\n+\tdouble norm = Math.sqrt(-2 * Math.log(s) / s);\n+\tnextNextGaussian = v2 * norm;\n+\thaveNextNextGaussian = true;\n+\treturn v1 * norm;\n+      }\n   }\n }"}, {"sha": "c0ff67323ccfabec6453202e15609a30e6c22064", "filename": "libjava/java/util/ResourceBundle.java", "status": "modified", "additions": 391, "deletions": 183, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FResourceBundle.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,223 +1,431 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.util.ResourceBundle\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-import java.io.InputStream;\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-/**\n- * @author Anthony Green <green@cygnus.com>\n- * @date November 26, 1998.\n- */\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.  */\n \n+package java.util;\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n+\n+/**\n+ * A resource bundle contains locale-specific data.  If you need\n+ * localized data, you can load a resource bundle that matches the\n+ * locale with <code>getBundle</code>.  Now you can get your object by\n+ * calling <code>getObject</code> or <code>getString</code> on that\n+ * bundle.\n+ * <br>\n+ * When a bundle is demanded for a specific locale, the ResourceBundle\n+ * is searched in following order (<i>def. language code<i> stands for\n+ * the two letter ISO language code of the default locale (see\n+ * <code>Locale.getDefault()</code>).\n+ * <pre>\n+ * baseName_<i>language code</i>_<i>country code</i>_<i>variant</i>\n+ * baseName_<i>language code</i>_<i>country code</i>\n+ * baseName_<i>language code</i>\n+ * baseName_<i>def. language code</i>_<i>def. country code</i>_<i>def. variant</i>\n+ * baseName_<i>def. language code</i>_<i>def. country code</i>\n+ * baseName_<i>def. language code</i>\n+ * baseName\n+ * </pre>\n+ *\n+ * A bundle is backed up, by less specific bundle (omiting variant,\n+ * country or language). But it is not backed up by the default\n+ * language locale.\n+ * <br>\n+ * If you provide a bundle for a given locale, say\n+ * <code>Bundle_en_UK_POSIX</code>, you must also provide a bundle for\n+ * all sub locales, ie. <code>Bundle_en_UK</code>, <code>Bundle_en</code>, and\n+ * <code>Bundle</code>.\n+ * <br>\n+ * When a bundle is searched, we look first for a class with\n+ * the given name and if that is not found for a file with\n+ * <code>.properties</code> extension in the classpath.  The name\n+ * must be a fully qualified classname (with dots as path separators).  \n+ * <br>\n+ * (Note: This implementation always backs up the class with a\n+ * properties file if that is existing, but you shouldn't rely on\n+ * this, if you want to be compatible to the standard JDK.)\n+ *\n+ * @see Locale\n+ * @see PropertyResourceBundle\n+ * @author Jochen Hoenicke */\n public abstract class ResourceBundle\n {\n+  /**\n+   * The parent bundle.  This is consulted when you call getObject\n+   * and there is no such resource in the current bundle.  This\n+   * field may be null.  \n+   */\n   protected ResourceBundle parent;\n \n-  // This is used to cache resource bundles.\n-  private static Hashtable resource_cache = new Hashtable ();\n-\n-  public ResourceBundle ()\n-    {\n-    }\n-    \n-  public Locale getLocale()\n+  /**\n+   * The locale of this resource bundle.  You can read this with\n+   * <code>getLocale</code> and it is automatically set in\n+   * <code>getBundle</code>.  \n+   */\n+  private Locale locale;\n+\n+  /**\n+   * The constructor.  It does nothing special.\n+   */\n+  public ResourceBundle()\n   {\n-    // FIXME: Stub added for this missing method because it is needed for AWT.\n-    return null;\n   }\n \n-  public final String getString (String key) throws MissingResourceException\n-    {\n-      return (String) getObject(key);\n-    }\n+  /**\n+   * Get a String from this resource bundle.  Since most localized\n+   * Objects are Strings, this method provides a convenient way to get\n+   * them without casting.\n+   * @param key the name of the resource.\n+   * @exception MissingResourceException\n+   *   if that particular object could not be found in this bundle nor\n+   *   the parent bundle.\n+   */\n+  public final String getString(String key) throws MissingResourceException\n+  {\n+    return (String) getObject(key);\n+  }\n \n-  public final String[] getStringArray (String key) \n+  /**\n+   * Get an array of Strings from this resource bundle.  This method\n+   * provides a convenient way to get it without casting.\n+   * @param key the name of the resource.\n+   * @exception MissingResourceException\n+   *   if that particular object could not be found in this bundle nor\n+   *   the parent bundle.\n+   */\n+  public final String[] getStringArray(String key)\n     throws MissingResourceException\n-    {\n-      return (String[]) getObject(key);\n-    }\n+  {\n+    return (String[]) getObject(key);\n+  }\n \n+  /**\n+   * Get an object from this resource bundle.\n+   * @param key the name of the resource.\n+   * @exception MissingResourceException\n+   *   if that particular object could not be found in this bundle nor\n+   *   the parent bundle.\n+   */\n   public final Object getObject(String key) throws MissingResourceException\n-    {\n-      Object result;\n+  {\n+    for (ResourceBundle bundle = this; bundle != null; bundle = bundle.parent)\n+      {\n+\ttry\n+\t  {\n+\t    Object o = bundle.handleGetObject(key);\n+\t    if (o != null)\n+\t      return o;\n+\t  }\n+\tcatch (MissingResourceException ex)\n+\t  {\n+\t  }\n+      }\n+    throw new MissingResourceException\n+      (\"Key not found\", getClass().getName(), key);\n+  }\n \n-      try \n-\t{\n-\t  return handleGetObject (key);\n-\t}\n-      catch (MissingResourceException ex)\n-\t{\n-\t  if (parent != null)\n-\t    return parent.getObject(key);\n-\t  else \n-\t    throw ex;\n-\t}\n-    }\n+  /**\n+   * This method returns an array with the classes of the calling\n+   * methods.  The zeroth entry is the class that called this method\n+   * (should always be ResourceBundle), the first contains the class\n+   * that called the caller (i.e. the class that called getBundle).\n+   *\n+   * Implementation note: This depends on the fact, that getBundle\n+   * doesn't get inlined, but since it calls a private method, it\n+   * isn't inlineable.\n+   *\n+   * @return an array containing the classes for the callers.  \n+   */\n+  private static native Class[] getClassContext();\n+\n+  /**\n+   * Get the appropriate ResourceBundle for the default locale.  \n+   * @param baseName the name of the ResourceBundle.  This should be\n+   * a name of a Class or a properties-File.  See the class\n+   * description for details.  \n+   * @return the desired resource bundle\n+   * @exception MissingResourceException \n+   *    if the resource bundle couldn't be found.  */\n+  public static final ResourceBundle getBundle(String baseName)\n+    throws MissingResourceException\n+  {\n+    return getBundle(baseName, Locale.getDefault(),\n+\t\t     getClassContext()[1].getClassLoader());\n+  }\n \n-  public static final ResourceBundle getBundle(String baseName) \n+  /**\n+   * Get the appropriate ResourceBundle for the given locale.  \n+   * @param baseName the name of the ResourceBundle.  This should be\n+   * a name of a Class or a properties-File.  See the class\n+   * description for details.  \n+   * @param locale A locale.\n+   * @return the desired resource bundle\n+   * @exception MissingResourceException \n+   *    if the resource bundle couldn't be found.\n+   */\n+  public static final ResourceBundle getBundle(String baseName,\n+\t\t\t\t\t       Locale locale)\n     throws MissingResourceException\n-    {\n-      return getBundle(baseName, Locale.getDefault());\n-    }\n+  {\n+    return getBundle(baseName, locale, getClassContext()[1].getClassLoader());\n+  }\n \n-  // Start searching with the name bundleName.  Continue searching by\n-  // stripping off the '_' delimited tails until the search name is\n-  // the same as stopHere.\n-  private static final ResourceBundle trySomeGetBundle (String bundleName,\n-\t\t\t\t\t\t\tString stopHere,\n-\t\t\t\t\t\t\tClassLoader loader)\n+  /**\n+   * The resource bundle cache.  This is a two-level hash map: The key\n+   * is the class loader, the value is a new HashMap.  The key of this\n+   * second hash map is the localized name, the value is a soft\n+   * references to the resource bundle.  */\n+  private static Map resourceBundleCache = new HashMap();\n+\n+  /**\n+   * Tries to load a class or a property file with the specified name.\n+   * @param name the name.\n+   * @param locale the locale, that must be used exactly.\n+   * @param classloader the classloader.\n+   * @param bundle the back up (parent) bundle\n+   * @return the resource bundle if that could be loaded, otherwise \n+   * <code>bundle</code>.\n+   */\n+  private static final ResourceBundle tryBundle(String localizedName,\n+\t\t\t\t\t\tLocale locale,\n+\t\t\t\t\t\tClassLoader classloader,\n+\t\t\t\t\t\tResourceBundle bundle,\n+\t\t\t\t\t\tHashMap cache)\n+  {\n     {\n-      Class rbc;\n-      ResourceBundle needs_parent = null, r, result = null;\n-\n-      while (true)\n+      // First look into the cache.\n+      // XXX We should remove cleared references from the cache.\n+      Reference ref = (Reference) cache.get(localizedName);\n+      if (ref != null)\n \t{\n-\t  try \n-\t    {\n-\t      rbc = Class.forName(bundleName, true, loader);\n-\t      r = null;\n-\t      try \n-\t\t{\n-\t\t  r = (ResourceBundle) rbc.newInstance();\n-\t\t}\n-\t      catch (IllegalAccessException ex)\n-\t\t{\n-\t\t  // Fall through\n-\t\t}\n-\t      catch (InstantiationException ex)\n-\t\t{\n-\t\t  // Fall through\n-\t\t}\n-\t      if (r != null)\n-\t\t{\n-\t\t  if (result == null)\n-\t\t    result = r;\n-\t\t  if (needs_parent != null)\n-\t\t    {\n-\t\t      // We've been through the loop one or more times\n-\t\t      // already.  Set the parent and keep going.\n-\t\t      needs_parent.setParent(r);\n-\t\t    }\n-\t\t  needs_parent = r;\n-\t\t}\n-\t    }\n-\t  catch (ClassNotFoundException ex)\n-\t    {\n-\t      // Fall through.\n-\t    }\n-\n-\t  // Look for a properties file.\n-\t  InputStream i = loader.getResourceAsStream (bundleName.replace ('.',\n-\t\t\t\t\t\t\t\t\t  '/')\n-\t\t\t\t\t\t      + \".properties\");\n-\t  if (i != null)\n-\t    {\n-\t      try\n-\t\t{\n-\t\t  return new PropertyResourceBundle (i);\n-\t\t}\n-\t      catch (java.io.IOException e)\n-\t\t{\n-\t\t  // The docs don't appear to define what happens in\n-\t\t  // this case, but it seems like continuing the\n-\t\t  // search is a reasonable thing to do.\n-\t\t}\n-\t    }\n-\n-\t  if (bundleName.equals(stopHere))\n-\t    return result;\n-\t  else\n-\t    {\n-\t      int last = bundleName.lastIndexOf('_');\n-\t\t  \n-\t      // No more underscores?\n-\t      if (last == -1)\n-\t\treturn result;\n-\n-\t      // Loop around, testing this new shorter name.\n-\t      bundleName = bundleName.substring(0, last);\n-\t    }\n+\t  ResourceBundle rb = (ResourceBundle) ref.get();\n+\t  if (rb != null)\n+\t    // rb should already have the right parent, except if\n+\t    // something very strange happened.\n+\t    return rb;\n \t}\n     }\n \n-  // Search for bundles, but stop at baseName_language (if required).\n-  // This is synchronized so that the cache works correctly.\n-  private static final synchronized ResourceBundle\n-    partialGetBundle (String baseName, Locale locale, boolean langStop,\n-\t\t      ClassLoader loader)\n-    {\n-      ResourceBundle rb;\n-\n-      // Explicitly invoke locale.toString() to force a\n-      // NullPointerException when required.\n-      String bundleName = baseName + \"_\" + locale.toString();\n-\n-      // Check the cache.\n-      Object obj = resource_cache.get(bundleName);\n-      if (obj != null)\n-\treturn (ResourceBundle) obj;\n-\n-      String stopHere = (baseName \n-\t\t\t + (langStop ? (\"_\" + locale.getLanguage()) : \"\"));\n-\n-\n-      rb = trySomeGetBundle(bundleName, stopHere, loader);\n-      if (rb != null)\n-\tresource_cache.put(bundleName, rb);\n-\n-      return rb;\n-    }\n+    try\n+      {\n+\tjava.io.InputStream is;\n+\tif (classloader == null)\n+\t  is = ClassLoader.getSystemResourceAsStream\n+\t    (localizedName.replace('.', '/') + \".properties\");\n+\telse\n+\t  is = classloader.getResourceAsStream\n+\t    (localizedName.replace('.', '/') + \".properties\");\n+\tif (is != null)\n+\t  {\n+\t    ResourceBundle rb = new PropertyResourceBundle(is);\n+\t    rb.parent = bundle;\n+\t    rb.locale = locale;\n+\t    bundle = rb;\n+\t  }\n+      }\n+    catch (java.io.IOException ex)\n+      {\n+      }\n+\n+    try\n+      {\n+\tClass rbClass;\n+\tif (classloader == null)\n+\t  rbClass = Class.forName(localizedName);\n+\telse\n+\t  rbClass = classloader.loadClass(localizedName);\n+\tResourceBundle rb = (ResourceBundle) rbClass.newInstance();\n+\trb.parent = bundle;\n+\trb.locale = locale;\n+\tbundle = rb;\n+      }\n+    catch (ClassNotFoundException ex)\n+      {\n+      }\n+    catch (IllegalAccessException ex)\n+      {\n+      }\n+    catch (InstantiationException ex)\n+      {\n+\t// ignore them all\n+\t// XXX should we also ignore ClassCastException?\n+      }\n+\n+    // Put the bundle in the cache\n+    if (bundle != null)\n+      cache.put(localizedName, new SoftReference(bundle));\n+\n+    return bundle;\n+  }\n \n-  public static final ResourceBundle getBundle (String baseName, \n-\t\t\t\t\t\tLocale locale)\n+  /**\n+   * Tries to load a the bundle for a given locale, also loads the backup\n+   * locales with the same language.\n+   *\n+   * @param name the name.\n+   * @param locale the locale, that must be used exactly.\n+   * @param classloader the classloader.\n+   * @param bundle the back up (parent) bundle\n+   * @return the resource bundle if that could be loaded, otherwise \n+   * <code>bundle</code>.\n+   */\n+  private static final ResourceBundle tryLocalBundle(String baseName,\n+\t\t\t\t\t\t     Locale locale,\n+\t\t\t\t\t\t     ClassLoader classloader,\n+\t\t\t\t\t\t     ResourceBundle bundle,\n+\t\t\t\t\t\t     HashMap cache)\n   {\n-    return getBundle (baseName, locale, ClassLoader.getSystemClassLoader ());\n+    if (locale.getLanguage().length() > 0)\n+      {\n+\tString name = baseName + \"_\" + locale.getLanguage();\n+\n+\tif (locale.getCountry().length() != 0)\n+\t  {\n+\t    bundle = tryBundle(name,\n+\t\t\t       new Locale(locale.getLanguage(), \"\"),\n+\t\t\t       classloader, bundle, cache);\n+\n+\t    name += \"_\" + locale.getCountry();\n+\n+\t    if (locale.getVariant().length() != 0)\n+\t      {\n+\t\tbundle = tryBundle(name,\n+\t\t\t\t   new Locale(locale.getLanguage(),\n+\t\t\t\t\t      locale.getCountry()),\n+\t\t\t\t   classloader, bundle, cache);\n+\n+\t\tname += \"_\" + locale.getVariant();\n+\t      }\n+\t  }\n+\tbundle = tryBundle(name, locale, classloader, bundle, cache);\n+      }\n+    return bundle;\n   }\n \n-  public static final ResourceBundle getBundle (String baseName, \n-\t\t\t\t\t\tLocale locale,\n-\t\t\t\t\t\tClassLoader loader)\n+  /**\n+   * Get the appropriate ResourceBundle for the given locale.  \n+   * @param baseName the name of the ResourceBundle.  This should be\n+   * a name of a Class or a properties file.  See the class\n+   * description for details.  \n+   * @param locale A locale.\n+   * @param classloader a ClassLoader.\n+   * @return the desired resource bundle\n+   * @exception MissingResourceException \n+   *    if the resource bundle couldn't be found.\n+   */\n+  // This method is synchronized so that the cache is properly\n+  // handled.\n+  public static final synchronized ResourceBundle getBundle(String baseName,\n+\t\t\t\t\t\t\t    Locale locale,\n+\t\t\t\t\t\t\t    ClassLoader classLoader)\n     throws MissingResourceException\n-    {\n-      ResourceBundle rb;\n-      Class rbc;\n-\n-      if (baseName == null)\n-\tthrow new NullPointerException ();\n-\n-      rb = partialGetBundle(baseName, locale, false, loader);\n-      if (rb != null)\n-\treturn rb;\n-\n-      // Finally, try the default locale.\n-      if (! locale.equals(Locale.getDefault()))\n-\t{\n-\t  rb = partialGetBundle(baseName, Locale.getDefault(), true, loader);\n-\t  if (rb != null)\n-\t    return rb;\n-\t}\n+  {\n+    // This implementation searches the bundle in the reverse direction\n+    // and builds the parent chain on the fly.\n+\n+    HashMap cache = (HashMap) resourceBundleCache.get(classLoader);\n+    if (cache == null)\n+      {\n+\tcache = new HashMap();\n+\tresourceBundleCache.put(classLoader, cache);\n+      }\n+    else\n+      {\n+\t// Fast path: If baseName + \"_\" + locale is in cache use it.\n+\tString name = baseName + \"_\" + locale.toString();\n+\tReference ref = (Reference) cache.get(name);\n+\tif (ref != null)\n+\t  {\n+\t    ResourceBundle rb = (ResourceBundle) ref.get();\n+\t    if (rb != null)\n+\t      // rb should already have the right parent, except if\n+\t      // something very strange happened.\n+\t      return rb;\n+\t  }\n+      }\n+\n+    ResourceBundle baseBundle = tryBundle(baseName, new Locale(\"\", \"\"),\n+\t\t\t\t\t  classLoader, null, cache);\n+    if (baseBundle == null)\n+      // JDK says, that if one provides a bundle base_en_UK, one\n+      // must also provide the bundles base_en and base.\n+      // This implies that if there is no bundle for base, there\n+      // is no bundle at all.\n+      throw new MissingResourceException(\"Bundle not found\", baseName, \"\");\n+\n+    // Now use the default locale.\n+    ResourceBundle bundle = tryLocalBundle(baseName, locale,\n+\t\t\t\t\t   classLoader, baseBundle, cache);\n+    if (bundle == baseBundle && !locale.equals(Locale.getDefault()))\n+      {\n+\tbundle = tryLocalBundle(baseName, Locale.getDefault(),\n+\t\t\t\tclassLoader, baseBundle, cache);\n+      }\n+    return bundle;\n+  }\n \n-      throw new MissingResourceException(\"can't load bundle\", \n-\t\t\t\t\t baseName,\n-\t\t\t\t\t \"bundle\");\n-    }\n+  /**\n+   * Return the actual locale of this bundle.  You can use it after\n+   * calling getBundle, to know if the bundle for the desired locale\n+   * was loaded or if the fall back was used.\n+   */\n+  public Locale getLocale()\n+  {\n+    return locale;\n+  }\n \n+  /**\n+   * Set the parent of this bundle. This is consulted when you call\n+   * getObject and there is no such resource in the current bundle.\n+   * @param parent the parent of this bundle.\n+   */\n   protected void setParent(ResourceBundle parent)\n-    {\n-      this.parent = parent;\n-    }\n+  {\n+    // Shall we ignore the old parent?\n+    this.parent = parent;\n+  }\n \n-  protected abstract Object handleGetObject(String key) \n+  /**\n+   * Override this method to provide the resource for a keys.  This gets\n+   * called by <code>getObject</code>.  If you don't have a resource\n+   * for the given key, you should return null instead throwing a\n+   * MissingResourceException.   You don't have to ask the parent, \n+   * getObject() already does this.\n+   *\n+   * @param key The key of the resource.\n+   * @return The resource for the key, or null if not in bundle.\n+   * @exception MissingResourceException\n+   *   you shouldn't throw this.\n+   */\n+  protected abstract Object handleGetObject(String key)\n     throws MissingResourceException;\n \n+  /**\n+   * This method should return all keys for which a resource exists.\n+   * @return An enumeration of the keys.\n+   */\n   public abstract Enumeration getKeys();\n }"}, {"sha": "ee2994014c8340ee151e16f3cd524f56e22c756a", "filename": "libjava/java/util/StringTokenizer.java", "status": "modified", "additions": 204, "deletions": 127, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FStringTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FStringTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FStringTokenizer.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,76 +1,236 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.StringTokenizer\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n \n /**\n+ * This class splits a string into tokens.  The caller can set on which \n+ * delimiters the string should be split and if the delimiters should be\n+ * returned.\n+ *\n+ * You may change the delimiter set on the fly by calling\n+ * nextToken(String).  But the semantic is quite difficult; it even\n+ * depends on calling <code>hasMoreTokens()</code>.  You should call\n+ * <code>hasMoreTokens()</code> before, otherwise the old delimiters\n+ * after the last token are returned.\n+ *\n+ * If you want to get the delimiters, you have to use the three argument\n+ * constructor.  The delimiters are returned as token consisting of a\n+ * single character.  \n+ *\n+ * @author Jochen Hoenicke\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 24, 1998.\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n  */\n-\n public class StringTokenizer implements Enumeration\n {\n-  /* String to be parsed */\n-  private String inputString;\n+  /**\n+   * The position in the str, where we currently are.\n+   */\n+  private int pos;\n+  /**\n+   * The string that should be split into tokens.\n+   */\n+  private String str;\n+  /**\n+   * The string containing the delimiter characters.\n+   */\n+  private String delim;\n+  /**\n+   * Tells, if we should return the delimiters.\n+   */\n+  private boolean retDelims;\n+\n+  /*{ \n+     invariant {\n+     pos >= 0 :: \"position is negative\";\n+     pos <= str.length() :: \"position is out of string\";\n+     str != null :: \"String is null\";\n+     delim != null :: \"Delimiters are null\";\n+     }\n+     } */\n+\n+  /**\n+   * Creates a new StringTokenizer for the string <code>str</code>,\n+   * that should split on the default delimiter set (space, tap,\n+   * newline, return and formfeed), and which doesn't return the\n+   * delimiters.\n+   * @param str The string to split.\n+   */\n+  public StringTokenizer(String str)\n+    /*{ require { str != null :: \"str must not be null\"; } } */\n+  {\n+    this(str, \" \\t\\n\\r\\f\", false);\n+  }\n \n-  /* String to be parsed put into a char array for efficient access */\n-  private char[] chArray;\n+  /**\n+   * Create a new StringTokenizer, that splits the given string on \n+   * the given delimiter characters.  It doesn't return the delimiter\n+   * characters.\n+   *\n+   * @param str The string to split.\n+   * @param delim A string containing all delimiter characters.\n+   */\n+  public StringTokenizer(String str, String delim)\n+    /*{ require { str != null :: \"str must not be null\";\n+       delim != null :: \"delim must not be null\"; } } */\n+  {\n+    this(str, delim, false);\n+  }\n \n-  /* Set of delimiter characters for separating tokens */\n-  private String delimiters;\n+  /**\n+   * Create a new StringTokenizer, that splits the given string on\n+   * the given delimiter characters.  If you set\n+   * <code>returnDelims</code> to <code>true</code>, the delimiter\n+   * characters are returned as tokens of their own.  The delimiter\n+   * tokens always consist of a single character.\n+   *\n+   * @param str The string to split.\n+   * @param delim A string containing all delimiter characters.\n+   * @param returnDelims Tells, if you want to get the delimiters.\n+   */\n+  public StringTokenizer(String str, String delim, boolean returnDelims)\n+    /*{ require { str != null :: \"str must not be null\";\n+       delim != null :: \"delim must not be null\"; } } */\n+  {\n+    this.str = str;\n+    this.delim = delim;\n+    this.retDelims = returnDelims;\n+    this.pos = 0;\n+  }\n \n-  /* Whether delimiters in this instance are treated as tokens themselves */\n-  private boolean returnDelimiters;\n+  /**\n+   * Tells if there are more tokens.\n+   * @return True, if the next call of nextToken() succeeds, false otherwise.\n+   */\n+  public boolean hasMoreTokens()\n+  {\n+    if (!retDelims)\n+      {\n+\twhile (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n+\t  {\n+\t    pos++;\n+\t  }\n+      }\n+    return pos < str.length();\n+  }\n \n-  /* Index into the input string to start parsing for the next token */\n-  private int inputStringIndex;\n+  /**\n+   * Returns the nextToken, changing the delimiter set to the given\n+   * <code>delim</code>.  The change of the delimiter set is\n+   * permanent, ie. the next call of nextToken(), uses the same\n+   * delimiter set.\n+   * @param delim a string containing the new delimiter characters.\n+   * @return the next token with respect to the new delimiter characters.\n+   * @exception NoSuchElementException if there are no more tokens.\n+   */\n+  public String nextToken(String delim) throws NoSuchElementException\n+    /*{ require { hasMoreTokens() :: \"no more Tokens available\";\n+       ensure { $return != null && $return.length() > 0; } } */\n+  {\n+    this.delim = delim;\n+    return nextToken();\n+  }\n \n-  public StringTokenizer(String str)\n+  /**\n+   * Returns the nextToken of the string.\n+   * @param delim a string containing the new delimiter characters.\n+   * @return the next token with respect to the new delimiter characters.\n+   * @exception NoSuchElementException if there are no more tokens.\n+   */\n+  public String nextToken() throws NoSuchElementException\n+    /*{ require { hasMoreTokens() :: \"no more Tokens available\";\n+       ensure { $return != null && $return.length() > 0; } } */\n   {\n-    this(str, \" \\t\\n\\r\", false);\n+    if (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n+      {\n+\tif (retDelims)\n+\t  return str.substring(pos, ++pos);\n+\n+\twhile (++pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n+\t  {\n+\t    /* empty */\n+\t  }\n+      }\n+    if (pos < str.length())\n+      {\n+\tint start = pos;\n+\twhile (++pos < str.length() && delim.indexOf(str.charAt(pos)) == -1)\n+\t  {\n+\t    /* empty */\n+\t  }\n+\treturn str.substring(start, pos);\n+      }\n+    throw new NoSuchElementException();\n   }\n \n-  public StringTokenizer(String str, String delims)\n+  /**\n+   * This does the same as hasMoreTokens. This is the\n+   * <code>Enumeration</code interface method.\n+   * @return True, if the next call of nextElement() succeeds, false\n+   * otherwise.  \n+   * @see #hasMoreTokens\n+   */\n+  public boolean hasMoreElements()\n   {\n-    this(str, delims, false);\n+    return hasMoreTokens();\n   }\n \n-  public StringTokenizer(String str, String delims, boolean retDelim)\n+  /**\n+   * This does the same as nextTokens. This is the\n+   * <code>Enumeration</code interface method.\n+   * @return the next token with respect to the new delimiter characters.\n+   * @exception NoSuchElementException if there are no more tokens.\n+   * @see #nextToken\n+   */\n+  public Object nextElement() throws NoSuchElementException\n   {\n-    inputString = str;\n-    delimiters = delims;\n-    returnDelimiters = retDelim;\n-    inputStringIndex = 0;\n-\n-    // Work on a copy of the remaining string in a char array\n-    // to gain efficiency of using primitives\n-    chArray = new char[inputString.length()];\n-    inputString.getChars(0, inputString.length(), chArray, 0);\n+    return nextToken();\n   }\n \n+  /**\n+   * This counts the number of remaining tokens in the string, with\n+   * respect to the current delimiter set.\n+   * @return the number of times <code>nextTokens()</code> will\n+   * succeed.  \n+   * @see #nextToken\n+   */\n   public int countTokens()\n   {\n     int count = 0;\n     int delimiterCount = 0;\n     boolean tokenFound = false;\t\t// Set when a non-delimiter is found\n-    int offset = inputStringIndex;\n+    int tmpPos = pos;\n \n     // Note for efficiency, we count up the delimiters rather than check\n-    // returnDelimiters every time we encounter one.  That way, we can\n+    // retDelims every time we encounter one.  That way, we can\n     // just do the conditional once at the end of the method\n-    while (offset < chArray.length)\n+    while (tmpPos < str.length())\n       {\n-\tif (isDelimiter(chArray[offset++]))\n+\tif (delim.indexOf(str.charAt(tmpPos++)) > -1)\n \t  {\n \t    if (tokenFound)\n \t      {\n@@ -86,8 +246,9 @@ public int countTokens()\n \t    tokenFound = true;\n \n \t    // Get to the end of the token\n-\t    while (offset < chArray.length && !isDelimiter(chArray[offset]))\n-\t      offset++;\n+\t    while (tmpPos < str.length()\n+\t\t   && delim.indexOf(str.charAt(tmpPos)) == -1)\n+\t      ++tmpPos;\n \t  }\n       }\n \n@@ -96,90 +257,6 @@ public int countTokens()\n       count++;\n \n     // if counting delmiters add them into the token count\n-    return returnDelimiters ? count + delimiterCount : count;\n-  }\n-\n-  public boolean hasMoreElements()\n-  {\n-    return hasMoreTokens();\n-  }\n-\n-  public boolean hasMoreTokens()\n-  {\n-    int offset = inputStringIndex;\n-\n-    while (offset < chArray.length)\n-      if (!isDelimiter(chArray[offset++]) || returnDelimiters)\n-\t{\n-\t  // update the current position with the start of the next token\n-\t  inputStringIndex = --offset;\n-\n-\t  return true;\n-\t}\n-\n-    return false;\n-  }\n-\n-  public Object nextElement()\n-  {\n-    return nextToken();\n-  }\n-\n-  public String nextToken()\n-  {\n-    int offset = inputStringIndex;\n-    int startSubstr = -1;\n-\n-    // Make sure we have more chars left to parse\n-    // and then find the start of the next token\n-    while (offset < chArray.length && startSubstr < 0)\n-      {\n-\t// Find the start of the token; skipping initial delimiters\n-\tif (!isDelimiter(chArray[offset++]))\n-\t  startSubstr = offset - 1;\n-\telse if (returnDelimiters)\n-\t  {\n-\t    // The single char delimiter is treated as a token\n-\t    inputStringIndex = offset;\t\t// update the current position\n-\n-\t    return inputString.substring(offset - 1, inputStringIndex);\n-\t  }\n-      }\n-\n-    // Now look for the end of the token\n-    while (offset < chArray.length)\n-      {\n-\tif (isDelimiter(chArray[offset++]))\n-\t  {\n-\t    // Found the end of token\n-            inputStringIndex = offset - 1;\t// update the current position\n-\n-            return inputString.substring(startSubstr, inputStringIndex);\n-\t  }\n-      }\n-\n-    // Got to the end of the string without finding the start of a token\n-    if (startSubstr < 0)\n-      throw new NoSuchElementException();\n-\n-    // Got to the end of the string before a delimiter\n-    inputStringIndex = offset;\t\t// update the current position\n-\n-    return inputString.substring(startSubstr, inputStringIndex);\n-  }\n-\n-  public String nextToken(String delims)\n-  {\n-    // First replace with new set of delimiters\n-    delimiters = delims;\n-\n-    return nextToken();\n-  }\n-\n-  // This private method could be inlined but the other methods are\n-  // more readable this way, so we'll take the hit on efficiency.\n-  private boolean isDelimiter(char ch)\n-  {\n-    return delimiters.indexOf(ch, 0) >= 0;\n+    return retDelims ? count + delimiterCount : count;\n   }\n }"}, {"sha": "3223e9648eee7c451615e35af103c6d05479452a", "filename": "libjava/java/util/TooManyListenersException.java", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FTooManyListenersException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FTooManyListenersException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTooManyListenersException.java?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -1,32 +1,67 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.TooManyListenersException\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n+\n+/**\n+ * This exception is part of the java event model.  It is thrown if an\n+ * event listener is added via the addXyzEventListener method, but the\n+ * object doesn't support any more listeners, e.g. it only supports a\n+ * single event listener.\n+ *\n+ * @see EventListener\n+ * @see EventObject\n+ * @author Jochen Hoenicke \n+ * @author Warren Levy <warrenl@cygnus.com>\n+ */\n+\n public class TooManyListenersException extends Exception\n {\n+  private static final long serialVersionUID = 5074640544770687831L;\n+\n+  /**\n+   * Constructs a TooManyListenersException with no detail message.\n+   */\n   public TooManyListenersException()\n   {\n-    super();\n   }\n \n-  public TooManyListenersException(String msg)\n+  /**\n+   * Constructs a TooManyListenersException with a detail message.\n+   * @param detail the detail message.\n+   */\n+  public TooManyListenersException(String detail)\n   {\n-    super(msg);\n+    super(detail);\n   }\n }"}, {"sha": "0c560eacf421f0e9f11b01920451829e0b6b1e0d", "filename": "libjava/java/util/natResourceBundle.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FnatResourceBundle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f/libjava%2Fjava%2Futil%2FnatResourceBundle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatResourceBundle.cc?ref=7a95ae6b51b590a8b8b9ee06768204c5d6a4a90f", "patch": "@@ -0,0 +1,31 @@\n+// natResourceBundle.cc - Native code for ResourceBundle class.\n+\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/util/ResourceBundle.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/ClassLoader.h>\n+\n+JArray<jclass> *\n+java::util::ResourceBundle::getClassContext ()\n+{\n+  // FIXME: we currently lack the capability to correctly implement\n+  // this method.  So we fake it by telling ResourceBundle that we\n+  // only have the system class loader.\n+  jobjectArray a = JvNewObjectArray (2, &java::lang::Class::class$, NULL);\n+  jobject *elts = elements (a);\n+  elts[0] = java::lang::ClassLoader::getSystemClassLoader ();\n+  elts[1] = elts[0];\n+\n+  return reinterpret_cast< JArray<jclass> *> (a);\n+}"}]}