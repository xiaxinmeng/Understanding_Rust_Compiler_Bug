{"sha": "d1908febeca224f88fb8fa10344eef0bf0392d47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5MDhmZWJlY2EyMjRmODhmYjhmYTEwMzQ0ZWVmMGJmMDM5MmQ0Nw==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2003-04-30T16:51:23Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2003-04-30T16:51:23Z"}, "message": "linux64.h (ASM_OUTPUT_LABELREF): Remove.\n\n2003-04-30  Janis Johnson  <janis187@us.ibm.com>\n\n\t* config/rs6000/linux64.h (ASM_OUTPUT_LABELREF): Remove.\n\t* config/rs6000/rs6000.c (rs6000_elf_strip_name_encoding): Remove.\n\t(rs6000_xcoff_encode_section_info): Remove.\n\t(current_file_function_operand): Use SYMBOL_REF_FLAGS; fix latent bug.\n\t(rs6000_output_mi_thunk): Remove dead code; use SYMBOL_REF_FLAGS.\n\t(small_data_operand, rs6000_emit_move, rs6000_elf_in_small_data_p,):\n\tUse SYMBOL_REF_FLAGS.\n\t(rs6000_elf_encode_section_info): Call default_encode_section_info for\n\tgeneric flags, use SYMBOL_REF_FLAGS; code cleanups.\n\t* sysv4.h (TARGET_STRIP_NAME_ENCODING, ASM_OUTPUT_LABELREF): Remove.\n\t(SYMBOL_FLAG_SMALL_V4, SYMBOL_REF_SMALL_V4_P): New.\n\t* xcoff.h (TARGET_ENCODE_SECTION_INFO): Remove.\n\t(ASM_DECLARE_FUNCTION_NAME): Remove setting of SYMBOL_REF_FLAG.\n\nFrom-SVN: r66297", "tree": {"sha": "203e3ac0006800453190507b96d49fa687a15207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/203e3ac0006800453190507b96d49fa687a15207"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1908febeca224f88fb8fa10344eef0bf0392d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1908febeca224f88fb8fa10344eef0bf0392d47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1908febeca224f88fb8fa10344eef0bf0392d47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1908febeca224f88fb8fa10344eef0bf0392d47/comments", "author": null, "committer": null, "parents": [{"sha": "0e42348d22b0e82931e53569757fdf815082dfdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e42348d22b0e82931e53569757fdf815082dfdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e42348d22b0e82931e53569757fdf815082dfdd"}], "stats": {"total": 206, "additions": 68, "deletions": 138}, "files": [{"sha": "ba6abb7e29ef3b4888896546e1710a9ba9581144", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1908febeca224f88fb8fa10344eef0bf0392d47", "patch": "@@ -1,3 +1,19 @@\n+2003-04-30  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* config/rs6000/linux64.h (ASM_OUTPUT_LABELREF): Remove.\n+\t* config/rs6000/rs6000.c (rs6000_elf_strip_name_encoding): Remove.\n+\t(rs6000_xcoff_encode_section_info): Remove.\n+\t(current_file_function_operand): Use SYMBOL_REF_FLAGS; fix latent bug.\n+\t(rs6000_output_mi_thunk): Remove dead code; use SYMBOL_REF_FLAGS.\n+\t(small_data_operand, rs6000_emit_move, rs6000_elf_in_small_data_p,):\n+\tUse SYMBOL_REF_FLAGS.\n+\t(rs6000_elf_encode_section_info): Call default_encode_section_info for\n+\tgeneric flags, use SYMBOL_REF_FLAGS; code cleanups.\n+\t* sysv4.h (TARGET_STRIP_NAME_ENCODING, ASM_OUTPUT_LABELREF): Remove.\n+\t(SYMBOL_FLAG_SMALL_V4, SYMBOL_REF_SMALL_V4_P): New.\n+\t* xcoff.h (TARGET_ENCODE_SECTION_INFO): Remove.\n+\t(ASM_DECLARE_FUNCTION_NAME): Remove setting of SYMBOL_REF_FLAG.\n+\n 2003-04-30  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* diagnostic.c (output_pointer): Use HOST_PTR_PRINTF."}, {"sha": "0cc8ae0cbc32d8796c14306b2d6b5ebc8a1957eb", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=d1908febeca224f88fb8fa10344eef0bf0392d47", "patch": "@@ -272,23 +272,6 @@\n #undef  PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.  */\n-\n-/* Override elfos.h definition.  */\n-#undef  ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\\\n-do {\t\t\t\t\t\t\\\n-  const char *_name = NAME;\t\t\t\\\n-  if (*_name == '@')\t\t\t\t\\\n-    _name++;\t\t\t\t\t\\\n- \t\t\t\t\t\t\\\n-  if (*_name == '*')\t\t\t\t\\\n-    fprintf (FILE, \"%s\", _name + 1);\t\t\\\n-  else\t\t\t\t\t\t\\\n-    asm_fprintf (FILE, \"%U%s\", _name);\t\t\\\n-} while (0)\n-\n #undef  ASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\"}, {"sha": "a2186cfe94f5fd38995acb0a1da3ab83701dff05", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 44, "deletions": 95, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d1908febeca224f88fb8fa10344eef0bf0392d47", "patch": "@@ -231,7 +231,6 @@ static void rs6000_elf_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t   unsigned HOST_WIDE_INT));\n static void rs6000_elf_encode_section_info PARAMS ((tree, rtx, int))\n      ATTRIBUTE_UNUSED;\n-static const char *rs6000_elf_strip_name_encoding PARAMS ((const char *));\n static bool rs6000_elf_in_small_data_p PARAMS ((tree));\n #endif\n #if TARGET_XCOFF\n@@ -244,8 +243,6 @@ static void rs6000_xcoff_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t     unsigned HOST_WIDE_INT));\n static const char * rs6000_xcoff_strip_name_encoding PARAMS ((const char *));\n static unsigned int rs6000_xcoff_section_type_flags PARAMS ((tree, const char *, int));\n-static void rs6000_xcoff_encode_section_info PARAMS ((tree, rtx, int))\n-     ATTRIBUTE_UNUSED;\n #endif\n #if TARGET_MACHO\n static bool rs6000_binds_local_p PARAMS ((tree));\n@@ -2092,17 +2089,24 @@ call_operand (op, mode)\n }\n \n /* Return 1 if the operand is a SYMBOL_REF for a function known to be in\n-   this file and the function is not weakly defined.  */\n+   this file.  */\n \n int\n current_file_function_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  && (SYMBOL_REF_FLAG (op)\n-\t      || (op == XEXP (DECL_RTL (current_function_decl), 0)\n-\t          && ! DECL_WEAK (current_function_decl))));\n+  if (GET_CODE (op) == SYMBOL_REF\n+      && (SYMBOL_REF_LOCAL_P (op)\n+\t  || (op == XEXP (DECL_RTL (current_function_decl), 0))))\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (!SYMBOL_REF_FUNCTION_P (op))\n+\tabort ();\n+#endif\n+      return 1;\n+    }\n+  return 0;\n }\n \n /* Return 1 if this operand is a valid input for a move insn.  */\n@@ -2206,11 +2210,7 @@ small_data_operand (op, mode)\n       sym_ref = XEXP (sum, 0);\n     }\n \n-  if (*XSTR (sym_ref, 0) != '@')\n-    return 0;\n-\n-  return 1;\n-\n+  return SYMBOL_REF_SMALL_V4_P (sym_ref);\n #else\n   return 0;\n #endif\n@@ -2939,8 +2939,9 @@ rs6000_emit_move (dest, source, mode)\n \t      new_ref = gen_rtx_SYMBOL_REF (Pmode, name);\n \t      CONSTANT_POOL_ADDRESS_P (new_ref)\n \t\t= CONSTANT_POOL_ADDRESS_P (operands[1]);\n-\t      SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n+\t      SYMBOL_REF_FLAGS (new_ref) = SYMBOL_REF_FLAGS (operands[1]);\n \t      SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n+\t      SYMBOL_REF_DECL (new_ref) = SYMBOL_REF_DECL (operands[1]);\n \t      operands[1] = new_ref;\n \t    }\n \n@@ -11749,15 +11750,7 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n       TREE_USED (function) = 1;\n     }\n   funexp = XEXP (DECL_RTL (function), 0);\n-\n-  SYMBOL_REF_FLAG (funexp) = 0;\n-  if (current_file_function_operand (funexp, VOIDmode)\n-      && (! lookup_attribute (\"longcall\",\n-\t\t\t      TYPE_ATTRIBUTES (TREE_TYPE (function)))\n-\t  || lookup_attribute (\"shortcall\",\n-\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (function)))))\n-    SYMBOL_REF_FLAG (funexp) = 1;\n-\n+  SYMBOL_REF_FLAGS (funexp) &= ~SYMBOL_FLAG_LOCAL;\n   funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n \n #if TARGET_MACHO\n@@ -12930,40 +12923,36 @@ rs6000_elf_unique_section (decl, reloc)\n \t\t\t    flag_pic || DEFAULT_ABI == ABI_AIX);\n }\n \f\n-/* If we are referencing a function that is static or is known to be\n-   in this file, make the SYMBOL_REF special.  We can use this to indicate\n-   that we can branch to this function without emitting a no-op after the\n-   call.  For real AIX calling sequences, we also replace the\n-   function name with the real name (1 or 2 leading .'s), rather than\n-   the function descriptor name.  This saves a lot of overriding code\n-   to read the prefixes.  */\n+/* For a SYMBOL_REF, set generic flags and then perform some\n+   target-specific processing.\n+\n+   Set SYMBOL_FLAG_SMALL_V4 for an operand in small memory on V.4/eabi;\n+   this is different from the generic SYMBOL_FLAG_SMALL.\n+\n+   When the AIX ABI is requested on a non-AIX system, replace the\n+   function name with the real name (with a leading .) rather than the\n+   function descriptor name.  This saves a lot of overriding code to\n+   read the prefixes.  */\n \n static void\n rs6000_elf_encode_section_info (decl, rtl, first)\n      tree decl;\n      rtx rtl;\n      int first;\n {\n-  if (!first)\n-    return;\n+  default_encode_section_info (decl, rtl, first);\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n+  if (first\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      && !TARGET_AIX\n+      && DEFAULT_ABI == ABI_AIX)\n     {\n       rtx sym_ref = XEXP (rtl, 0);\n-      if ((*targetm.binds_local_p) (decl))\n-\tSYMBOL_REF_FLAG (sym_ref) = 1;\n-\n-      if (!TARGET_AIX && DEFAULT_ABI == ABI_AIX)\n-\t{\n-\t  size_t len1 = (DEFAULT_ABI == ABI_AIX) ? 1 : 2;\n-\t  size_t len2 = strlen (XSTR (sym_ref, 0));\n-\t  char *str = alloca (len1 + len2 + 1);\n-\t  str[0] = '.';\n-\t  str[1] = '.';\n-\t  memcpy (str + len1, XSTR (sym_ref, 0), len2 + 1);\n-\n-\t  XSTR (sym_ref, 0) = ggc_alloc_string (str, len1 + len2);\n-\t}\n+      size_t len = strlen (XSTR (sym_ref, 0));\n+      char *str = alloca (len + 2);\n+      str[0] = '.';\n+      memcpy (str + 1, XSTR (sym_ref, 0), len + 1);\n+      XSTR (sym_ref, 0) = ggc_alloc_string (str, len + 1);\n     }\n   else if (rs6000_sdata != SDATA_NONE\n \t   && DEFAULT_ABI == ABI_V4\n@@ -12973,56 +12962,27 @@ rs6000_elf_encode_section_info (decl, rtl, first)\n       int size = int_size_in_bytes (TREE_TYPE (decl));\n       tree section_name = DECL_SECTION_NAME (decl);\n       const char *name = (char *)0;\n-      int len = 0;\n-\n-      if ((*targetm.binds_local_p) (decl))\n-\tSYMBOL_REF_FLAG (sym_ref) = 1;\n \n       if (section_name)\n \t{\n \t  if (TREE_CODE (section_name) == STRING_CST)\n-\t    {\n-\t      name = TREE_STRING_POINTER (section_name);\n-\t      len = TREE_STRING_LENGTH (section_name);\n-\t    }\n+\t    name = TREE_STRING_POINTER (section_name);\n \t  else\n \t    abort ();\n \t}\n \n       if (name\n-\t  ? ((len == sizeof (\".sdata\") - 1\n-\t      && strcmp (name, \".sdata\") == 0)\n-\t     || (len == sizeof (\".sdata2\") - 1\n-\t\t && strcmp (name, \".sdata2\") == 0)\n-\t     || (len == sizeof (\".sbss\") - 1\n-\t\t && strcmp (name, \".sbss\") == 0)\n-\t     || (len == sizeof (\".sbss2\") - 1\n-\t\t && strcmp (name, \".sbss2\") == 0)\n-\t     || (len == sizeof (\".PPC.EMB.sdata0\") - 1\n-\t\t && strcmp (name, \".PPC.EMB.sdata0\") == 0)\n-\t     || (len == sizeof (\".PPC.EMB.sbss0\") - 1\n-\t\t && strcmp (name, \".PPC.EMB.sbss0\") == 0))\n+\t  ? (strcmp (name, \".sdata\") == 0\n+\t     || strcmp (name, \".sdata2\") == 0\n+\t     || strcmp (name, \".sbss\") == 0\n+\t     || strcmp (name, \".sbss2\") == 0\n+\t     || strcmp (name, \".PPC.EMB.sdata0\") == 0\n+\t     || strcmp (name, \".PPC.EMB.sbss0\") == 0)\n \t  : (size > 0 && size <= g_switch_value))\n-\t{\n-\t  size_t len = strlen (XSTR (sym_ref, 0));\n-\t  char *str = alloca (len + 2);\n-\n-\t  str[0] = '@';\n-\t  memcpy (str + 1, XSTR (sym_ref, 0), len + 1);\n-\t  XSTR (sym_ref, 0) = ggc_alloc_string (str, len + 1);\n-\t}\n+\tSYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_SMALL_V4;\n     }\n }\n \n-static const char *\n-rs6000_elf_strip_name_encoding (str)\n-     const char *str;\n-{\n-  while (*str == '*' || *str == '@')\n-    str++;\n-  return str;\n-}\n-\n static bool\n rs6000_elf_in_small_data_p (decl)\n      tree decl;\n@@ -13631,17 +13591,6 @@ rs6000_xcoff_section_type_flags (decl, name, reloc)\n \n   return flags | (exact_log2 (align) & SECTION_ENTSIZE);\n }\n-\n-static void\n-rs6000_xcoff_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first ATTRIBUTE_UNUSED;\n-{\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && (*targetm.binds_local_p) (decl))\n-    SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\n-}\n #endif /* TARGET_XCOFF */\n \n #if TARGET_MACHO"}, {"sha": "8fd4f45a3209d3844ca9a155ea779431ac8aeaaa", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=d1908febeca224f88fb8fa10344eef0bf0392d47", "patch": "@@ -766,7 +766,6 @@ extern int fixuplabelno;\n #define DBX_DEBUGGING_INFO 1\n \n #define TARGET_ENCODE_SECTION_INFO  rs6000_elf_encode_section_info\n-#define TARGET_STRIP_NAME_ENCODING  rs6000_elf_strip_name_encoding\n #define TARGET_IN_SMALL_DATA_P  rs6000_elf_in_small_data_p\n #define TARGET_SECTION_TYPE_FLAGS  rs6000_elf_section_type_flags\n \n@@ -775,25 +774,8 @@ extern int fixuplabelno;\n #define\tRS6000_OUTPUT_BASENAME(FILE, NAME)\t\\\n     assemble_name (FILE, NAME)\n \n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.  */\n-\n-/* Override elfos.h definition.  */\n-#undef\tASM_OUTPUT_LABELREF\n-#define\tASM_OUTPUT_LABELREF(FILE,NAME)\t\t\\\n-do {\t\t\t\t\t\t\\\n-  const char *_name = NAME;\t\t\t\\\n-  if (*_name == '@')\t\t\t\t\\\n-    _name++;\t\t\t\t\t\\\n- \t\t\t\t\t\t\\\n-  if (*_name == '*')\t\t\t\t\\\n-    fprintf (FILE, \"%s\", _name + 1);\t\t\\\n-  else\t\t\t\t\t\t\\\n-    asm_fprintf (FILE, \"%U%s\", _name);\t\t\\\n-} while (0)\n-\n-/* But, to make this work, we have to output the stabs for the function\n-   name *first*...  */\n+/* We have to output the stabs for the function name *first*, before\n+   outputting its label.  */\n \n #define\tDBX_FUNCTION_FIRST\n \n@@ -1392,3 +1374,9 @@ ncrtn.o%s\"\n \n /* Generate entries in .fixup for relocatable addresses.  */\n #define RELOCATABLE_NEEDS_FIXUP\n+\n+/* Define target-specific symbol_ref flags, beginning with\n+   SYMBOL_REF_FLAG_DEP.  */\n+#define SYMBOL_FLAG_SMALL_V4  (SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_REF_SMALL_V4_P(RTX) \\\n+  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_SMALL_V4) != 0)"}, {"sha": "fe65ea93c21145d2e596444b80a0ff8132ed0751", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1908febeca224f88fb8fa10344eef0bf0392d47/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=d1908febeca224f88fb8fa10344eef0bf0392d47", "patch": "@@ -163,7 +163,6 @@ toc_section ()\t\t\t\t\t\t\\\n #define TARGET_ASM_SELECT_SECTION  rs6000_xcoff_select_section\n #define TARGET_ASM_SELECT_RTX_SECTION  rs6000_xcoff_select_rtx_section\n #define TARGET_ASM_UNIQUE_SECTION  rs6000_xcoff_unique_section\n-#define TARGET_ENCODE_SECTION_INFO  rs6000_xcoff_encode_section_info\n #define TARGET_STRIP_NAME_ENCODING  rs6000_xcoff_strip_name_encoding\n #define TARGET_SECTION_TYPE_FLAGS  rs6000_xcoff_section_type_flags\n \n@@ -255,16 +254,11 @@ toc_section ()\t\t\t\t\t\t\\\n    `text_section' call previously done.  We do have to go back to that\n    csect, however.\n \n-   We also record that the function exists in the current compilation\n-   unit, reachable by short branch, by setting SYMBOL_REF_FLAG.\n-\n    The third and fourth parameters to the .function pseudo-op (16 and 044)\n    are placeholders which no longer have any use.  */\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n { rtx sym_ref = XEXP (DECL_RTL (DECL), 0);\t\t\t\\\n-  if ((*targetm.binds_local_p) (DECL))\t\t\t\t\\\n-    SYMBOL_REF_FLAG (sym_ref) = 1;\t\t\t\t\\\n   if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       if (!RS6000_WEAK || !DECL_WEAK (decl))\t\t\t\\"}]}