{"sha": "8022264265dd39887a1723eeda8ae445afad1fde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyMjI2NDI2NWRkMzk4ODdhMTcyM2VlZGE4YWU0NDVhZmFkMWZkZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-01-26T20:49:04Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-01-26T20:50:58Z"}, "message": "coroutines: Fix whitespace and comment markers.\n\nThis amends the cases where inline comments in function calls were\nfollowed by a space.  It also fixes some uses of C++ style and wrongly\nwrapped comment end markers.\n\ngcc/cp/ChangeLog:\n\n2020-01-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n* coroutines.cc: Amend whitespace after inline comments\nthroughout.  Ensure use of C-style comment markers.", "tree": {"sha": "5db289fc0fd43cee93d7cdb56a5bcf3159270f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5db289fc0fd43cee93d7cdb56a5bcf3159270f93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8022264265dd39887a1723eeda8ae445afad1fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8022264265dd39887a1723eeda8ae445afad1fde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8022264265dd39887a1723eeda8ae445afad1fde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8022264265dd39887a1723eeda8ae445afad1fde/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9664b52aeb3db9ae35bba1766d677790c8a461ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9664b52aeb3db9ae35bba1766d677790c8a461ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9664b52aeb3db9ae35bba1766d677790c8a461ef"}], "stats": {"total": 147, "additions": 71, "deletions": 76}, "files": [{"sha": "b222c1f7a8edc8fbbb07f155026a7f6129236589", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 71, "deletions": 76, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8022264265dd39887a1723eeda8ae445afad1fde/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8022264265dd39887a1723eeda8ae445afad1fde/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=8022264265dd39887a1723eeda8ae445afad1fde", "patch": "@@ -296,9 +296,8 @@ instantiate_coro_traits (tree fndecl, location_t kw)\n \n   tree traits_class\n     = lookup_template_class (coro_traits_templ, targ,\n-\t\t\t     /*in_decl=*/ NULL_TREE,\n-\t\t\t     /*context=*/ NULL_TREE /*std_node*/,\n-\t\t\t     /*entering scope=*/ false, tf_warning_or_error);\n+\t\t\t     /*in_decl=*/NULL_TREE, /*context=*/NULL_TREE,\n+\t\t\t     /*entering scope=*/false, tf_warning_or_error);\n \n   if (traits_class == error_mark_node || traits_class == NULL_TREE)\n     {\n@@ -335,9 +334,9 @@ instantiate_coro_handle_for_promise_type (location_t kw, tree promise_type)\n   TREE_VEC_ELT (targ, 0) = promise_type;\n   tree handle_type\n     = lookup_template_class (coro_handle_identifier, targ,\n-\t\t\t     /* in_decl */ NULL_TREE,\n-\t\t\t     /* context */ std_node,\n-\t\t\t     /* entering scope */ false, tf_warning_or_error);\n+\t\t\t     /* in_decl=*/NULL_TREE,\n+\t\t\t     /* context=*/std_node,\n+\t\t\t     /* entering scope=*/false, tf_warning_or_error);\n \n   if (handle_type == error_mark_node)\n     {\n@@ -356,7 +355,7 @@ find_promise_type (tree traits_class)\n {\n   tree promise_type\n     = lookup_member (traits_class, coro_promise_type_identifier,\n-\t\t     /* protect */ 1, /*want_type=*/true, tf_warning_or_error);\n+\t\t     /* protect=*/1, /*want_type=*/true, tf_warning_or_error);\n \n   if (promise_type)\n     promise_type\n@@ -539,15 +538,15 @@ coro_common_keyword_context_valid_p (tree fndecl, location_t kw_loc,\n   /* This is arranged in order of prohibitions in the std.  */\n   if (DECL_MAIN_P (fndecl))\n     {\n-      // [basic.start.main] 3. The function main shall not be a coroutine.\n+      /* [basic.start.main] 3. The function main shall not be a coroutine.  */\n       error_at (kw_loc, \"%qs cannot be used in the %<main%> function\",\n \t\tkw_name);\n       return false;\n     }\n \n   if (DECL_DECLARED_CONSTEXPR_P (fndecl))\n     {\n-      // [dcl.constexpr] 3.3 it shall not be a coroutine.\n+      /* [dcl.constexpr] 3.3 it shall not be a coroutine.  */\n       error_at (kw_loc, \"%qs cannot be used in a %<constexpr%> function\",\n \t\tkw_name);\n       cp_function_chain->invalid_constexpr = true;\n@@ -556,8 +555,8 @@ coro_common_keyword_context_valid_p (tree fndecl, location_t kw_loc,\n \n   if (FNDECL_USED_AUTO (fndecl))\n     {\n-      // [dcl.spec.auto] 15. A function declared with a return type that uses\n-      // a placeholder type shall not be a coroutine .\n+      /* [dcl.spec.auto] 15. A function declared with a return type that uses\n+\t a placeholder type shall not be a coroutine.  */\n       error_at (kw_loc,\n \t\t\"%qs cannot be used in a function with a deduced return type\",\n \t\tkw_name);\n@@ -566,24 +565,24 @@ coro_common_keyword_context_valid_p (tree fndecl, location_t kw_loc,\n \n   if (varargs_function_p (fndecl))\n     {\n-      // [dcl.fct.def.coroutine] The parameter-declaration-clause of the\n-      // coroutine shall not terminate with an ellipsis that is not part\n-      // of a parameter-declaration.\n+      /* [dcl.fct.def.coroutine] The parameter-declaration-clause of the\n+\t coroutine shall not terminate with an ellipsis that is not part\n+\t of a parameter-declaration.  */\n       error_at (kw_loc,\n \t\t\"%qs cannot be used in a varargs function\", kw_name);\n       return false;\n     }\n \n   if (DECL_CONSTRUCTOR_P (fndecl))\n     {\n-      // [class.ctor] 7. a constructor shall not be a coroutine.\n+      /* [class.ctor] 7. a constructor shall not be a coroutine.  */\n       error_at (kw_loc, \"%qs cannot be used in a constructor\", kw_name);\n       return false;\n     }\n \n   if (DECL_DESTRUCTOR_P (fndecl))\n     {\n-      // [class.dtor] 21. a destructor shall not be a coroutine.\n+      /* [class.dtor] 21. a destructor shall not be a coroutine.  */\n       error_at (kw_loc, \"%qs cannot be used in a destructor\", kw_name);\n       return false;\n     }\n@@ -685,7 +684,7 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n   /* To complete the lookups, we need an instance of 'e' which is built from\n      'o' according to [expr.await] 3.4.  However, we don't want to materialize\n      'e' here (it might need to be placed in the coroutine frame) so we will\n-     make a temp placeholder instead. */\n+     make a temp placeholder instead.  */\n   tree e_proxy = build_lang_decl (VAR_DECL, NULL_TREE, o_type);\n \n   /* I suppose we could check that this is contextually convertible to bool.  */\n@@ -793,7 +792,7 @@ finish_co_await_expr (location_t kw, tree expr)\n   tree at_meth\n     = lookup_promise_method (current_function_decl,\n \t\t\t     coro_await_transform_identifier, kw,\n-\t\t\t     /*musthave=*/ false);\n+\t\t\t     /*musthave=*/false);\n   if (at_meth == error_mark_node)\n     return error_mark_node;\n \n@@ -869,7 +868,7 @@ finish_co_yield_expr (location_t kw, tree expr)\n      call for p.yield_value(e).  */\n   tree y_meth = lookup_promise_method (current_function_decl,\n \t\t\t\t       coro_yield_value_identifier, kw,\n-\t\t\t\t        /*musthave=*/ true);\n+\t\t\t\t       /*musthave=*/true);\n   if (!y_meth || y_meth == error_mark_node)\n     return error_mark_node;\n \n@@ -956,7 +955,7 @@ finish_co_return_stmt (location_t kw, tree expr)\n       tree crv_meth\n \t= lookup_promise_method (current_function_decl,\n \t\t\t\t coro_return_void_identifier, kw,\n-\t\t\t\t /*musthave=*/ true);\n+\t\t\t\t /*musthave=*/true);\n       if (!crv_meth || crv_meth == error_mark_node)\n \treturn error_mark_node;\n \n@@ -969,7 +968,7 @@ finish_co_return_stmt (location_t kw, tree expr)\n       tree crv_meth\n \t= lookup_promise_method (current_function_decl,\n \t\t\t\t coro_return_value_identifier, kw,\n-\t\t\t\t /*musthave=*/ true);\n+\t\t\t\t /*musthave=*/true);\n       if (!crv_meth || crv_meth == error_mark_node)\n \treturn error_mark_node;\n \n@@ -1471,17 +1470,17 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   /* Implement the suspend, a scope exit without clean ups.  */\n   r = build_call_expr_internal_loc (loc, IFN_CO_SUSPN, void_type_node, 1, susp);\n   r = coro_build_cvt_void_expr_stmt (r, loc);\n-  add_stmt (r); //   goto ret;\n+  add_stmt (r); /*   goto ret;  */\n   r = build_case_label (build_int_cst (integer_type_node, 1), NULL_TREE,\n \t\t\tcreate_anon_label_with_ctx (loc, actor));\n-  add_stmt (r); // case 1:\n+  add_stmt (r); /* case 1:  */\n   r = build1_loc (loc, GOTO_EXPR, void_type_node, resume_label);\n-  add_stmt (r); //  goto resume;\n+  add_stmt (r); /*  goto resume;  */\n   r = build_case_label (NULL_TREE, NULL_TREE,\n \t\t\tcreate_anon_label_with_ctx (loc, actor));\n-  add_stmt (r); // default:;\n+  add_stmt (r); /* default:;  */\n   r = build1_loc (loc, GOTO_EXPR, void_type_node, destroy_label);\n-  add_stmt (r); // goto destroy;\n+  add_stmt (r); /* goto destroy;  */\n \n   /* part of finish switch.  */\n   SWITCH_STMT_BODY (sw) = pop_stmt_list (SWITCH_STMT_BODY (sw));\n@@ -1599,16 +1598,15 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n      in : CO_AWAIT_EXPR (a, e_proxy, o, awr_call_vector, mode)\n \t  We no longer need a [it had diagnostic value, maybe?]\n \t  We need to replace the promise proxy in all elements\n-\t  We need to replace the e_proxy in the awr_call.\n-  */\n+\t  We need to replace the e_proxy in the awr_call.  */\n \n   tree coro_frame_type = TREE_TYPE (xform->actor_frame);\n   tree ah = NULL_TREE;\n   if (si->susp_handle_id)\n     {\n       tree ah_m\n \t= lookup_member (coro_frame_type, si->susp_handle_id,\n-\t\t\t /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t\t /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n       ah = build_class_member_access_expr (xform->actor_frame, ah_m, NULL_TREE,\n \t\t\t\t\t   true, tf_warning_or_error);\n     }\n@@ -1623,7 +1621,7 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n   /* Get a reference to the initial suspend var in the frame.  */\n   tree as_m\n     = lookup_member (coro_frame_type, si->await_field_id,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree as = build_class_member_access_expr (xform->actor_frame, as_m, NULL_TREE,\n \t\t\t\t\t    true, tf_warning_or_error);\n \n@@ -1730,7 +1728,7 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \n \t  tree fld_ref\n \t    = lookup_member (lvd->coro_frame_type, local_var.field_id,\n-\t\t\t     /*protect*/ 1, /*want_type*/ 0,\n+\t\t\t     /*protect=*/1, /*want_type=*/0,\n \t\t\t     tf_warning_or_error);\n \t  tree fld_idx = build3_loc (lvd->loc, COMPONENT_REF, TREE_TYPE (lvar),\n \t\t\t\t     lvd->actor_frame, fld_ref, NULL_TREE);\n@@ -1749,7 +1747,7 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  if (local_var.field_id == NULL_TREE)\n \t    pvar = &DECL_CHAIN (*pvar); /* Wasn't used.  */\n \n-\t  *pvar = DECL_CHAIN (*pvar); // discard this one, we replaced it.\n+\t  *pvar = DECL_CHAIN (*pvar); /* discard this one, we replaced it.  */\n \t}\n \n       *do_subtree = 0; /* We've done the body already.  */\n@@ -1855,7 +1853,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n       /* We will discard this, since it's connected to the original scope\n \t nest.  */\n       tree block = BIND_EXPR_BLOCK (first);\n-      if (block) // For this to be missing is probably a bug.\n+      if (block) /* For this to be missing is probably a bug.  */\n \t{\n \t  gcc_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n \t  gcc_assert (BLOCK_CHAIN (block) == NULL_TREE);\n@@ -1884,7 +1882,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t  if (parm.field_id == NULL_TREE)\n \t    continue; /* Wasn't used.  */\n \t  tree fld_ref = lookup_member (coro_frame_type, parm.field_id,\n-\t\t\t\t\t/*protect*/ 1, /*want_type*/ 0,\n+\t\t\t\t\t/*protect=*/1, /*want_type=*/0,\n \t\t\t\t\ttf_warning_or_error);\n \t  tree fld_idx = build3_loc (loc, COMPONENT_REF, TREE_TYPE (arg),\n \t\t\t\t     actor_frame, fld_ref, NULL_TREE);\n@@ -2032,7 +2030,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree return_void = NULL_TREE;\n   tree rvm\n     = lookup_promise_method (orig, coro_return_void_identifier, loc,\n-\t\t\t     /*musthave=*/ false);\n+\t\t\t     /*musthave=*/false);\n   if (rvm && rvm != error_mark_node)\n     return_void\n       = build_new_method_call (ap, rvm, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n@@ -2070,7 +2068,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n      branch to the final resume, and fall through to the destroy.  */\n   tree resume_m\n     = lookup_member (coro_frame_type, get_identifier (\"__resume\"),\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree res_x = build_class_member_access_expr (actor_frame, resume_m, NULL_TREE,\n \t\t\t\t\t       false, tf_warning_or_error);\n   r = build1 (CONVERT_EXPR, act_des_fn_ptr, integer_zero_node);\n@@ -2186,7 +2184,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* We need the resume index to work with.  */\n   tree res_idx_m\n     = lookup_member (coro_frame_type, resume_idx_name,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree res_idx\n     = build_class_member_access_expr (actor_frame, res_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n@@ -2313,7 +2311,7 @@ build_init_or_final_await (location_t loc, bool is_final)\n   tree suspend_alt = is_final ? coro_final_suspend_identifier\n \t\t\t      : coro_initial_suspend_identifier;\n   tree setup_meth = lookup_promise_method (current_function_decl, suspend_alt,\n-\t\t\t\t\t   loc, /*musthave=*/ true);\n+\t\t\t\t\t   loc, /*musthave=*/true);\n   if (!setup_meth || setup_meth == error_mark_node)\n     return error_mark_node;\n \n@@ -2551,8 +2549,8 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n \t     await-suspend.resume() is evaluated.\n      (5.1.2) if the type of await-suspend is bool, await-suspend is evaluated,\n \t     and the coroutine is resumed if the result is false.\n-     (5.1.3) Otherwise, await-suspend is evaluated.\n-  */\n+     (5.1.3) Otherwise, await-suspend is evaluated.  */\n+\n   tree susp_typ = get_await_suspend_return_type (aw_expr);\n   tree handle_field_nam;\n   if (VOID_TYPE_P (susp_typ) || TREE_CODE (susp_typ) == BOOLEAN_TYPE)\n@@ -2596,10 +2594,9 @@ maybe_promote_captured_temps (tree *stmt, void *d)\n \n   /* When register_awaits sees an await, it walks the initializer for\n      that await looking for temporaries captured by reference and notes\n-     them in awpts->captured_temps.  We only need to take any action\n-     here if the statement contained any awaits, and any of those had\n-     temporaries captured by reference in the initializers for their class.\n-  */\n+     them in awpts->captured_temps.  We only need to take any action here\n+     if the statement contained any awaits, and any of those had temporaries\n+     captured by reference in the initializers for their class.  */\n \n   tree res = cp_walk_tree (stmt, register_awaits, d, &visited);\n   if (!res && awpts->saw_awaits > 0 && !awpts->captured_temps.is_empty ())\n@@ -2797,8 +2794,8 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   /* As we enter a bind expression - record the vars there and then recurse.\n      As we exit drop the nest depth.\n      The bind index is a growing count of how many bind indices we've seen.\n-     We build a space in the frame for each local var.\n-  */\n+     We build a space in the frame for each local var.  */\n+\n   if (TREE_CODE (*stmt) == BIND_EXPR)\n     {\n       lvd->bind_indx++;\n@@ -2828,7 +2825,7 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t    }\n \t  else\n \t    {\n-\t      namsize += 10; // 'D' followed by an unsigned.\n+\t      namsize += 10; /* 'D' followed by an unsigned.  */\n \t      buf = (char *) alloca (namsize);\n \t      snprintf (buf, namsize, \"__%s.%u.%u.D%u\", nm, lvd->bind_indx,\n \t\t\tlvd->nest_depth, DECL_UID (lvar));\n@@ -2881,8 +2878,8 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   void (*__resume)(_R_frame *);\n   void (*__destroy)(_R_frame *);\n   coro1::promise_type __p;\n-  bool frame_needs_free; // free the coro frame mem if set.\n-  short __resume_at; // this is where clang puts it - but it's a smaller entity.\n+  bool frame_needs_free; free the coro frame mem if set.\n+  short __resume_at;\n   coro1::suspend_never_prt __is;\n   (maybe) handle_type i_hand;\n   coro1::suspend_always_prt __fs;\n@@ -2929,8 +2926,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      If we encounter a fatal error we might return a now-empty body.\n      TODO: determine if it would help to restore the original.\n \t   determine if looking for more errors in coro_function_valid_p()\n-\t   and stashing types is a better solution.\n-  */\n+\t   and stashing types is a better solution.  */\n \n   tree newbody = push_stmt_list ();\n   DECL_SAVED_TREE (orig) = newbody;\n@@ -3174,11 +3170,11 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      2. Otherwise, we call new and the ramp is expected to terminate with an\n \tunhandled exception in the case of failure to allocate.\n \n-     The get_return_object_on_allocation_failure() must be a static method.\n-  */\n+     The get_return_object_on_allocation_failure() must be a static method.  */\n+\n   tree grooaf_meth\n     = lookup_promise_method (orig, coro_gro_on_allocation_fail_identifier,\n-\t\t\t     fn_start, /*musthave=*/ false);\n+\t\t\t     fn_start, /*musthave=*/false);\n \n   /* The CO_FRAME internal function is a mechanism to allow the middle end\n      to adjust the allocation in response to optimisations.  We provide the\n@@ -3203,7 +3199,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  TREE_USED (fn) = 1;\n \t}\n       tree nth_ns = lookup_qualified_name (std_node, get_identifier (\"nothrow\"),\n-\t\t\t\t\t   0, /*complain=*/ true, false);\n+\t\t\t\t\t   0, /*complain=*/true, false);\n       arglist->quick_push (nth_ns);\n     }\n \n@@ -3213,7 +3209,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* The user can (optionally) provide an allocation function in the promise\n       type, it's not a failure for it to be absent.  */\n   tree fns = lookup_promise_method (orig, nwname, fn_start,\n-\t\t\t\t    /*musthave=*/ false);\n+\t\t\t\t    /*musthave=*/false);\n   tree new_fn = NULL_TREE;\n   if (fns && fns != error_mark_node)\n     {\n@@ -3233,7 +3229,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     {\n       fns =lookup_name_real (nwname, 0, 1, /*block_p=*/true, 0, 0);\n       new_fn = lookup_arg_dependent (nwname, fns, arglist);\n-      new_fn = build_new_function_call (new_fn, &arglist, /*complain=*/ true);\n+      new_fn = build_new_function_call (new_fn, &arglist, /*complain=*/true);\n     }\n \n   tree allocated = build1 (CONVERT_EXPR, coro_frame_ptr, new_fn);\n@@ -3256,7 +3252,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t  grooaf);\n       r = coro_build_cvt_void_expr_stmt (r, fn_start);\n       append_to_statement_list (r, &early_ret_list);\n-      // We know it's the correct type.\n+      /* We know it's the correct type.  */\n       r = DECL_RESULT (orig);\n       r = build_stmt (fn_start, RETURN_EXPR, r);\n       TREE_NO_WARNING (r) |= 1;\n@@ -3294,7 +3290,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree actor_addr = build1 (ADDR_EXPR, act_des_fn_ptr, actor);\n   tree resume_m\n     = lookup_member (coro_frame_type, resume_name,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree resume_x = build_class_member_access_expr (deref_fp, resume_m, NULL_TREE,\n \t\t\t\t\t\t  false, tf_warning_or_error);\n   r = build2_loc (fn_start, INIT_EXPR, act_des_fn_ptr, resume_x, actor_addr);\n@@ -3304,7 +3300,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree destroy_addr = build1 (ADDR_EXPR, act_des_fn_ptr, destroy);\n   tree destroy_m\n     = lookup_member (coro_frame_type, destroy_name,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree destroy_x\n     = build_class_member_access_expr (deref_fp, destroy_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n@@ -3315,7 +3311,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Set up the promise.  */\n   tree promise_m\n     = lookup_member (coro_frame_type, promise_name,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n \n   tree p = build_class_member_access_expr (deref_fp, promise_m, NULL_TREE,\n \t\t\t\t\t   false, tf_warning_or_error);\n@@ -3328,8 +3324,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n \t First try to find a constructor with the same parameter list as the\n \t original function (if it has params), failing that find a constructor\n-\t with no parameter list.\n-      */\n+\t with no parameter list.  */\n \n       if (DECL_ARGUMENTS (orig))\n \t{\n@@ -3368,7 +3363,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    continue; /* Wasn't used.  */\n \n \t  tree fld_ref = lookup_member (coro_frame_type, parm.field_id,\n-\t\t\t\t\t/*protect*/ 1, /*want_type*/ 0,\n+\t\t\t\t\t/*protect=*/1, /*want_type=*/0,\n \t\t\t\t\ttf_warning_or_error);\n \t  tree fld_idx\n \t    = build_class_member_access_expr (deref_fp, fld_ref, NULL_TREE,\n@@ -3381,7 +3376,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t  && (CLASSTYPE_LAZY_MOVE_CTOR (parm.frame_type)\n \t\t      || CLASSTYPE_LAZY_MOVE_ASSIGN (parm.frame_type)\n \t\t      || classtype_has_move_assign_or_move_ctor_p\n-\t\t\t    (parm.frame_type, /* user-declared */ true)))\n+\t\t\t    (parm.frame_type, /*user_declared=*/true)))\n \t\tp_in = make_tree_vector_single (rvalue (arg));\n \t      else\n \t\tp_in = make_tree_vector_single (arg);\n@@ -3419,7 +3414,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \tcontinue;\n \n       tree fld_ref = lookup_member (coro_frame_type, cap.field_id,\n-\t\t\t\t    /*protect*/ 1, /*want_type*/ 0,\n+\t\t\t\t    /*protect=*/1, /*want_type=*/0,\n \t\t\t\t    tf_warning_or_error);\n       tree fld_idx\n \t= build_class_member_access_expr (deref_fp, fld_ref, NULL_TREE,\n@@ -3439,7 +3434,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t  && (CLASSTYPE_LAZY_MOVE_CTOR (cap_type)\n \t\t      || CLASSTYPE_LAZY_MOVE_ASSIGN (cap_type)\n \t\t      || classtype_has_move_assign_or_move_ctor_p\n-\t\t\t    (cap_type, /* user-declared */ true)))\n+\t\t\t    (cap_type, /*user_declared=*/true)))\n \t    p_in = make_tree_vector_single (rvalue (cap.captured));\n \t  else\n \t    p_in = make_tree_vector_single (cap.captured);\n@@ -3478,7 +3473,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   tree gro_meth = lookup_promise_method (orig,\n \t\t\t\t\t coro_get_return_object_identifier,\n-\t\t\t\t\t fn_start, /*musthave=*/ true );\n+\t\t\t\t\t fn_start, /*musthave=*/true );\n   tree get_ro\n     = build_new_method_call (p, gro_meth, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n \t\t\t     tf_warning_or_error);\n@@ -3495,7 +3490,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   if (same_type_p (TREE_TYPE (get_ro), fn_return_type))\n     {\n       gro = DECL_RESULT (orig);\n-      gro_bind_vars = NULL_TREE; // We don't need a separate var.\n+      gro_bind_vars = NULL_TREE; /* We don't need a separate var.  */\n     }\n   else\n     {\n@@ -3504,18 +3499,18 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       DECL_CONTEXT (gro) = current_scope ();\n       r = build_stmt (fn_start, DECL_EXPR, gro);\n       add_stmt (r);\n-      gro_bind_vars = gro; // We need a temporary var.\n+      gro_bind_vars = gro; /* We need a temporary var.  */\n     }\n \n-  // init our actual var.\n+  /* Initialize our actual var.  */\n   r = build2_loc (fn_start, INIT_EXPR, TREE_TYPE (gro), gro, get_ro);\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n   /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n   tree resume_idx_m\n     = lookup_member (coro_frame_type, resume_idx_name,\n-\t\t     /*protect*/ 1, /*want_type*/ 0, tf_warning_or_error);\n+\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree resume_idx\n     = build_class_member_access_expr (deref_fp, resume_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n@@ -3540,7 +3535,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n   else\n     {\n-      // construct the return value with a single GRO param.\n+      /* construct the return value with a single GRO param.  */\n       vec<tree, va_gc> *args = make_tree_vector_single (gro);\n       r = build_special_member_call (DECL_RESULT (orig),\n \t\t\t\t     complete_ctor_identifier, &args,\n@@ -3576,7 +3571,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       orig_fn_has_outer_bind = true;\n       tree block = BIND_EXPR_BLOCK (first);\n       replace_blk = make_node (BLOCK);\n-      if (block) // missing block is probably an error.\n+      if (block) /* missing block is probably an error.  */\n \t{\n \t  gcc_assert (BLOCK_SUPERCONTEXT (block) == NULL_TREE);\n \t  gcc_assert (BLOCK_CHAIN (block) == NULL_TREE);\n@@ -3592,7 +3587,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     {\n       tree ueh_meth\n \t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n-\t\t\t\t fn_start, /*musthave=*/ true);\n+\t\t\t\t fn_start, /*musthave=*/true);\n       /* Build promise.unhandled_exception();  */\n       tree ueh\n \t= build_new_method_call (p, ueh_meth, NULL, NULL_TREE, LOOKUP_NORMAL,\n@@ -3633,7 +3628,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t present.  */\n       tree ueh_meth\n \t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n-\t\t\t\t fn_start, /*musthave=*/ false);\n+\t\t\t\t fn_start, /*musthave=*/false);\n       if (!ueh_meth || ueh_meth == error_mark_node)\n \twarning_at (fn_start, 0, \"no member named %qE in %qT\",\n \t\t    coro_unhandled_exception_identifier,"}]}