{"sha": "9d5e7640c335a590cec4497fa64230f0b0e83465", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1ZTc2NDBjMzM1YTU5MGNlYzQ0OTdmYTY0MjMwZjBiMGU4MzQ2NQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-06-15T06:27:32Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-06-15T06:27:32Z"}, "message": "tree-vect-loop-manip.c (remove_dead_stmts_from_loop): Remove.\n\n\n        * tree-vect-loop-manip.c (remove_dead_stmts_from_loop): Remove.\n        (slpeel_tree_peel_loop_to_edge): Don't call\n        remove_dead_stmts_from_loop.\n        * tree-vect-loop.c (vect_determine_vectorization_factor): Don't\n        remove irrelevant pattern statements.  For irrelevant statements\n        check if it is the last statement of a detected pattern, use\n        corresponding pattern statement instead.\n        (destroy_loop_vec_info): No need to remove pattern statements,\n        only free stmt_vec_info.\n        (vect_transform_loop): For irrelevant statements check if it is\n        the last statement of a detected pattern, use corresponding\n        pattern statement instead.\n        * tree-vect-patterns.c (vect_pattern_recog_1): Don't insert\n        pattern statements.  Set basic block for the new statement.\n        (vect_pattern_recog): Update documentation.\n        * tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Scan\n        operands of pattern statements.\n        (vectorizable_call): Fix printing.  In case of a pattern\n        statement use the lhs of the original statement when creating\n        a dummy statement to replace the original call.\n        (vect_analyze_stmt): For irrelevant statements check if it is\n        the last statement of a detected pattern, use corresponding\n        pattern statement instead.\n        * tree-vect-slp.c (vect_schedule_slp_instance): For pattern\n        statements use gsi of the original statement.\n\nFrom-SVN: r175074", "tree": {"sha": "907668cbb2e8294a111bd06a50c65091ce15c360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/907668cbb2e8294a111bd06a50c65091ce15c360"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d5e7640c335a590cec4497fa64230f0b0e83465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5e7640c335a590cec4497fa64230f0b0e83465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5e7640c335a590cec4497fa64230f0b0e83465", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5e7640c335a590cec4497fa64230f0b0e83465/comments", "author": null, "committer": null, "parents": [{"sha": "b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae"}], "stats": {"total": 259, "additions": 156, "deletions": 103}, "files": [{"sha": "c9485bc0b6f0e10fc2515e4bee00b860cfb30c2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -1,3 +1,31 @@\n+2011-06-15  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-loop-manip.c (remove_dead_stmts_from_loop): Remove.\n+\t(slpeel_tree_peel_loop_to_edge): Don't call\n+\tremove_dead_stmts_from_loop.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Don't\n+\tremove irrelevant pattern statements.  For irrelevant statements\n+\tcheck if it is the last statement of a detected pattern, use\n+\tcorresponding pattern statement instead.\n+\t(destroy_loop_vec_info): No need to remove pattern statements,\n+\tonly free stmt_vec_info.\n+\t(vect_transform_loop): For irrelevant statements check if it is\n+\tthe last statement of a detected pattern, use corresponding\n+\tpattern statement instead.\n+\t* tree-vect-patterns.c (vect_pattern_recog_1): Don't insert\n+\tpattern statements.  Set basic block for the new statement.\n+\t(vect_pattern_recog): Update documentation.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Scan\n+\toperands of pattern statements.\n+\t(vectorizable_call): Fix printing.  In case of a pattern statement\n+\tuse the lhs of the original statement when creating a dummy\n+\tstatement to replace the original call.\n+\t(vect_analyze_stmt): For irrelevant statements check if it is\n+\tthe last statement of a detected pattern, use corresponding\n+\tpattern statement instead.\n+\t* tree-vect-slp.c (vect_schedule_slp_instance): For pattern\n+\tstatements use gsi of the original statement.\n+\n 2011-06-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* target-def.h (TARGET_HAVE_NAMED_SECTIONS): Move to"}, {"sha": "a120fb153aa468c0342203e2781ec6ee72846be5", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -1105,35 +1105,6 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n   first_niters = PHI_RESULT (newphi);\n }\n \n-\n-/* Remove dead assignments from loop NEW_LOOP.  */\n-\n-static void\n-remove_dead_stmts_from_loop (struct loop *new_loop)\n-{\n-  basic_block *bbs = get_loop_body (new_loop);\n-  unsigned i;\n-  for (i = 0; i < new_loop->num_nodes; ++i)\n-    {\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);)\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_assign (stmt)\n-\t      && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-\t      && has_zero_uses (gimple_assign_lhs (stmt)))\n-\t    {\n-\t      gsi_remove (&gsi, true);\n-\t      release_defs (stmt);\n-\t    }\n-\t  else\n-\t    gsi_next (&gsi);\n-\t}\n-    }\n-  free (bbs);\n-}\n-\n-\n /* Function slpeel_tree_peel_loop_to_edge.\n \n    Peel the first (last) iterations of LOOP into a new prolog (epilog) loop\n@@ -1445,13 +1416,6 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   BITMAP_FREE (definitions);\n   delete_update_ssa ();\n \n-  /* Remove all pattern statements from the loop copy.  They will confuse\n-     the expander if DCE is disabled.\n-     ???  The pattern recognizer should be split into an analysis and\n-     a transformation phase that is then run only on the loop that is\n-     going to be transformed.  */\n-  remove_dead_stmts_from_loop (new_loop);\n-\n   adjust_vec_debug_stmts ();\n \n   return new_loop;"}, {"sha": "9217bc7aba1a87bcf836c46b362ce95754f3be51", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -244,7 +244,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n \t  tree vf_vectype;\n-\t  gimple stmt = gsi_stmt (si);\n+\t  gimple stmt = gsi_stmt (si), pattern_stmt;\n \t  stmt_info = vinfo_for_stmt (stmt);\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -258,20 +258,26 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  /* Skip stmts which do not need to be vectorized.  */\n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n-\t    {\n-              if (is_pattern_stmt_p (stmt_info))\n+            {\n+              if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+                  && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n+                  && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+                      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n                 {\n-                   /* We are not going to vectorize this pattern statement,\n-                      therefore, remove it.  */\n-                  gimple_stmt_iterator tmp_gsi = gsi_for_stmt (stmt);\n-                  STMT_VINFO_RELATED_STMT (stmt_info) = NULL;\n-                  gsi_remove (&tmp_gsi, true);\n-                  free_stmt_vec_info (stmt);\n+                  stmt = pattern_stmt;\n+                  stmt_info = vinfo_for_stmt (pattern_stmt);\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    {\n+                      fprintf (vect_dump, \"==> examining pattern statement: \");\n+                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                    }\n+                }\n+              else\n+\t        {\n+\t          if (vect_print_dump_info (REPORT_DETAILS))\n+\t            fprintf (vect_dump, \"skip.\");\n+\t          continue;\n                 }\n-\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t        fprintf (vect_dump, \"skip.\");\n-\t      continue;\n \t    }\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n@@ -828,25 +834,17 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n \n           if (stmt_info)\n             {\n-              /* Check if this is a \"pattern stmt\" (introduced by the\n-                 vectorizer during the pattern recognition pass).  */\n-              bool remove_stmt_p = false;\n-              gimple orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-              if (orig_stmt)\n-                {\n-                  stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n-                  if (orig_stmt_info\n-                      && STMT_VINFO_IN_PATTERN_P (orig_stmt_info))\n-                    remove_stmt_p = true;\n-                }\n+              /* Check if this statement has a related \"pattern stmt\"\n+                 (introduced by the vectorizer during the pattern recognition\n+                 pass).  Free pattern's stmt_vec_info.  */\n+              if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+                  && vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info)))\n+                free_stmt_vec_info (STMT_VINFO_RELATED_STMT (stmt_info));\n \n               /* Free stmt_vec_info.  */\n               free_stmt_vec_info (stmt);\n-\n-              /* Remove dead \"pattern stmts\".  */\n-              if (remove_stmt_p)\n-                gsi_remove (&si, true);\n             }\n+\n           gsi_next (&si);\n         }\n     }\n@@ -5131,7 +5129,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n       for (si = gsi_start_bb (bb); !gsi_end_p (si);)\n \t{\n-\t  gimple stmt = gsi_stmt (si);\n+\t  gimple stmt = gsi_stmt (si), pattern_stmt;\n \t  bool is_store;\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -5156,14 +5154,25 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n-\t    {\n-\t      gsi_next (&si);\n-\t      continue;\n+            {\n+              if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+                  && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n+                  && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+                      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+                {\n+                  stmt = pattern_stmt;\n+                  stmt_info = vinfo_for_stmt (stmt);\n+                }\n+              else\n+\t        {\n+   \t          gsi_next (&si);\n+\t          continue;\n+                }\n \t    }\n \n \t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-\t  nunits =\n-\t    (unsigned int) TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+\t  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (\n+                                               STMT_VINFO_VECTYPE (stmt_info));\n \t  if (!STMT_SLP_TYPE (stmt_info)\n \t      && nunits != (unsigned int) vectorization_factor\n               && vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "482b55317971e95968d57ecd5e61358be7e66fd8", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -831,9 +831,9 @@ vect_pattern_recog_1 (\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n-  gsi_insert_before (&si, pattern_stmt, GSI_SAME_STMT);\n   set_vinfo_for_stmt (pattern_stmt,\n \t\t      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n+  gimple_set_bb (pattern_stmt, gimple_bb (stmt));\n   pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n \n   STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;\n@@ -856,8 +856,8 @@ vect_pattern_recog_1 (\n    LOOP_VINFO - a struct_loop_info of a loop in which we want to look for\n         computation idioms.\n \n-   Output - for each computation idiom that is detected we insert a new stmt\n-        that provides the same functionality and that can be vectorized. We\n+   Output - for each computation idiom that is detected we create a new stmt\n+        that provides the same functionality and that can be vectorized.  We\n         also record some information in the struct_stmt_info of the relevant\n         stmts, as explained below:\n \n@@ -872,52 +872,48 @@ vect_pattern_recog_1 (\n          S5: ... = ..use(a_0)..         -       -               -\n \n    Say the sequence {S1,S2,S3,S4} was detected as a pattern that can be\n-   represented by a single stmt. We then:\n-   - create a new stmt S6 that will replace the pattern.\n-   - insert the new stmt S6 before the last stmt in the pattern\n+   represented by a single stmt.  We then:\n+   - create a new stmt S6 equivalent to the pattern (the stmt is not\n+     inserted into the code)\n    - fill in the STMT_VINFO fields as follows:\n \n                                   in_pattern_p  related_stmt    vec_stmt\n          S1: a_i = ....                 -       -               -\n          S2: a_2 = ..use(a_i)..         -       -               -\n          S3: a_1 = ..use(a_2)..         -       -               -\n-       > S6: a_new = ....               -       S4              -\n          S4: a_0 = ..use(a_1)..         true    S6              -\n+          '---> S6: a_new = ....        -       S4              -\n          S5: ... = ..use(a_0)..         -       -               -\n \n    (the last stmt in the pattern (S4) and the new pattern stmt (S6) point\n-    to each other through the RELATED_STMT field).\n+   to each other through the RELATED_STMT field).\n \n    S6 will be marked as relevant in vect_mark_stmts_to_be_vectorized instead\n    of S4 because it will replace all its uses.  Stmts {S1,S2,S3} will\n    remain irrelevant unless used by stmts other than S4.\n \n    If vectorization succeeds, vect_transform_stmt will skip over {S1,S2,S3}\n-   (because they are marked as irrelevant). It will vectorize S6, and record\n+   (because they are marked as irrelevant).  It will vectorize S6, and record\n    a pointer to the new vector stmt VS6 both from S6 (as usual), and also\n-   from S4. We do that so that when we get to vectorizing stmts that use the\n+   from S4.  We do that so that when we get to vectorizing stmts that use the\n    def of S4 (like S5 that uses a_0), we'll know where to take the relevant\n-   vector-def from. S4 will be skipped, and S5 will be vectorized as usual:\n+   vector-def from.  S4 will be skipped, and S5 will be vectorized as usual:\n \n                                   in_pattern_p  related_stmt    vec_stmt\n          S1: a_i = ....                 -       -               -\n          S2: a_2 = ..use(a_i)..         -       -               -\n          S3: a_1 = ..use(a_2)..         -       -               -\n        > VS6: va_new = ....             -       -               -\n-         S6: a_new = ....               -       S4              VS6\n          S4: a_0 = ..use(a_1)..         true    S6              VS6\n+          '---> S6: a_new = ....        -       S4              VS6\n        > VS5: ... = ..vuse(va_new)..    -       -               -\n          S5: ... = ..use(a_0)..         -       -               -\n \n-   DCE could then get rid of {S1,S2,S3,S4,S5,S6} (if their defs are not used\n+   DCE could then get rid of {S1,S2,S3,S4,S5} (if their defs are not used\n    elsewhere), and we'll end up with:\n \n         VS6: va_new = ....\n-        VS5: ... = ..vuse(va_new)..\n-\n-   If vectorization does not succeed, DCE will clean S6 away (its def is\n-   not used), and we'll end up with the original sequence.\n-*/\n+        VS5: ... = ..vuse(va_new)..  */\n \n void\n vect_pattern_recog (loop_vec_info loop_vinfo)"}, {"sha": "efedf66e2ec6c914df2d20679f88af107f75531a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -2546,6 +2546,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       && STMT_VINFO_STRIDED_ACCESS (stmt_info)\n       && !REFERENCE_CLASS_P (gimple_get_lhs (stmt)))\n     si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n+  else if (is_pattern_stmt_p (stmt_info))\n+     si = gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n   else\n     si = gsi_for_stmt (stmt);\n "}, {"sha": "6a5ba22d42a4abc2c2f9a0fe17d5638d45d89fec", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5e7640c335a590cec4497fa64230f0b0e83465/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9d5e7640c335a590cec4497fa64230f0b0e83465", "patch": "@@ -605,15 +605,49 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n             break;\n         }\n \n-      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  tree op = USE_FROM_PTR (use_p);\n-\t  if (!process_use (stmt, op, loop_vinfo, live_p, relevant, &worklist))\n-\t    {\n-\t      VEC_free (gimple, heap, worklist);\n-\t      return false;\n-\t    }\n-\t}\n+      if (is_pattern_stmt_p (vinfo_for_stmt (stmt)))\n+        {\n+          /* Pattern statements are not inserted into the code, so\n+             FOR_EACH_PHI_OR_STMT_USE optimizes their operands out, and we\n+             have to scan the RHS or function arguments instead.  */\n+          if (is_gimple_assign (stmt))\n+            {\n+              for (i = 1; i < gimple_num_ops (stmt); i++)\n+                {\n+                  tree op = gimple_op (stmt, i);\n+                  if (!process_use (stmt, op, loop_vinfo, live_p, relevant,\n+                                    &worklist))\n+                    {\n+                      VEC_free (gimple, heap, worklist);\n+                      return false;\n+                    }\n+                 }\n+            }\n+          else if (is_gimple_call (stmt))\n+            {\n+              for (i = 0; i < gimple_call_num_args (stmt); i++)\n+                {\n+                  tree arg = gimple_call_arg (stmt, i);\n+                  if (!process_use (stmt, arg, loop_vinfo, live_p, relevant,\n+                                    &worklist))\n+                    {\n+                      VEC_free (gimple, heap, worklist);\n+                      return false;\n+                    }\n+                }\n+            }\n+        }\n+      else\n+        FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+          {\n+            tree op = USE_FROM_PTR (use_p);\n+            if (!process_use (stmt, op, loop_vinfo, live_p, relevant,\n+                              &worklist))\n+              {\n+                VEC_free (gimple, heap, worklist);\n+                return false;\n+              }\n+          }\n     } /* while worklist */\n \n   VEC_free (gimple, heap, worklist);\n@@ -1406,6 +1440,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   VEC(tree, heap) *vargs = NULL;\n   enum { NARROW, NONE, WIDEN } modifier;\n   size_t i, nargs;\n+  tree lhs;\n \n   /* FORNOW: unsupported in basic block SLP.  */\n   gcc_assert (loop_vinfo);\n@@ -1543,7 +1578,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   /** Transform.  **/\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform operation.\");\n+    fprintf (vect_dump, \"transform call.\");\n \n   /* Handle def.  */\n   scalar_dest = gimple_call_lhs (stmt);\n@@ -1662,8 +1697,11 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n      rhs of the statement with something harmless.  */\n \n   type = TREE_TYPE (scalar_dest);\n-  new_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n-\t\t\t\t  build_zero_cst (type));\n+  if (is_pattern_stmt_p (stmt_info))\n+    lhs = gimple_call_lhs (STMT_VINFO_RELATED_STMT (stmt_info));\n+  else\n+    lhs = gimple_call_lhs (stmt);\n+  new_stmt = gimple_build_assign (lhs, build_zero_cst (type));\n   set_vinfo_for_stmt (new_stmt, stmt_info);\n   set_vinfo_for_stmt (stmt, NULL);\n   STMT_VINFO_STMT (stmt_info) = new_stmt;\n@@ -4846,10 +4884,26 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   if (!STMT_VINFO_RELEVANT_P (stmt_info)\n       && !STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"irrelevant.\");\n+      gimple pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+      if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+          && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+              || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+        {\n+          stmt = pattern_stmt;\n+          stmt_info = vinfo_for_stmt (pattern_stmt);\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"==> examining pattern statement: \");\n+              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+            }\n+        }\n+      else\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"irrelevant.\");\n \n-      return true;\n+          return true;\n+        }\n     }\n \n   switch (STMT_VINFO_DEF_TYPE (stmt_info))"}]}