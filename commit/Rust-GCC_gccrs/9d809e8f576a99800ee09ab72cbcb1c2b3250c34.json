{"sha": "9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ4MDllOGY1NzZhOTk4MDBlZTA5YWI3MmNiY2IxYzJiMzI1MGMzNA==", "commit": {"author": {"name": "Fabien Ch\u00eane", "email": "fabien.chene@gmail.com", "date": "2010-04-12T19:58:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-04-12T19:58:27Z"}, "message": "re PR c++/25811 (No failure creating a POD containing a const member, using new without a new-initializer.)\n\n\tPR c++/25811\n\t* cp-tree.h (diagnose_uninitialized_cst_or_ref_member): Declare.\n\t* init.c (build_new_1): Check for uninitialized const members and\n\tuninitialized reference members, when using new without\n\tnew-initializer. Call diagnose_uninitialized_cst_or_ref_member.\n\t(diagnose_uninitialized_cst_or_ref_member): Define, call\n\tdiagnose_uninitialized_cst_or_ref_member_1.\n\t(diagnose_uninitialized_cst_or_ref_member_1): New function.\n\nFrom-SVN: r158239", "tree": {"sha": "36abb2bf7447b0e5206eeea7e8c01a8c6a31adb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36abb2bf7447b0e5206eeea7e8c01a8c6a31adb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/comments", "author": null, "committer": null, "parents": [{"sha": "c7392d11305431de870a375c15fb34688d33f447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7392d11305431de870a375c15fb34688d33f447", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7392d11305431de870a375c15fb34688d33f447"}], "stats": {"total": 302, "additions": 300, "deletions": 2}, "files": [{"sha": "c32e19fcb732d9c07d4cf05ec143cf729704e328", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "patch": "@@ -1,3 +1,14 @@\n+2010-04-12  Fabien Chene  <fabien.chene@gmail.com>\n+\n+\tPR c++/25811\n+\t* cp-tree.h (diagnose_uninitialized_cst_or_ref_member): Declare.\n+\t* init.c (build_new_1): Check for uninitialized const members and\n+\tuninitialized reference members, when using new without\n+\tnew-initializer. Call diagnose_uninitialized_cst_or_ref_member.\n+\t(diagnose_uninitialized_cst_or_ref_member): Define, call\n+\tdiagnose_uninitialized_cst_or_ref_member_1.\n+\t(diagnose_uninitialized_cst_or_ref_member_1): New function.\n+\n 2010-04-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/43611"}, {"sha": "91f2a9e98839dc106c3fc881e1a243969dde5e87", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -4852,6 +4852,7 @@ extern tree create_temporary_var\t\t(tree);\n extern void initialize_vtbl_ptrs\t\t(tree);\n extern tree build_java_class_ref\t\t(tree);\n extern tree integral_constant_value\t\t(tree);\n+extern void diagnose_uninitialized_cst_or_ref_member (tree, bool);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);"}, {"sha": "c1f1cbf4a3861af7c1f75994c174ddbbad44ee44", "filename": "gcc/cp/init.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "patch": "@@ -1,6 +1,6 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -54,6 +54,7 @@ static tree dfs_initialize_vtbl_ptrs (tree, void *);\n static tree build_dtor_call (tree, special_function_kind, int);\n static tree build_field_list (tree, tree, int *);\n static tree build_vtbl_address (tree);\n+static void diagnose_uninitialized_cst_or_ref_member_1 (tree, tree, bool);\n \n /* We are about to generate some complex initialization code.\n    Conceptually, it is all a single expression.  However, we may want\n@@ -1753,6 +1754,59 @@ build_raw_new_expr (VEC(tree,gc) *placement, tree type, tree nelts,\n   return new_expr;\n }\n \n+/* Diagnose uninitialized const members or reference members of type\n+   TYPE. USING_NEW is used to disambiguate the diagnostic between a\n+   new expression without a new-initializer and a declaration */\n+\n+static void\n+diagnose_uninitialized_cst_or_ref_member_1 (tree type, tree origin,\n+\t\t\t\t\t    bool using_new)\n+{\n+  tree field;\n+\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      tree field_type;\n+\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      field_type = strip_array_types (TREE_TYPE (field));\n+\n+      if (TREE_CODE (field_type) == REFERENCE_TYPE)\n+\t{\n+\t  if (using_new)\n+\t    error (\"uninitialized reference member in %q#T using %<new%>\",\n+\t\t   origin);\n+\t  else\n+\t    error (\"uninitialized reference member in %q#T\", origin);\n+\t  inform (DECL_SOURCE_LOCATION (field),\n+\t\t  \"%qD should be initialized\", field);\n+\t}\n+\n+      if (CP_TYPE_CONST_P (field_type))\n+\t{\n+\t  if (using_new)\n+\t    error (\"uninitialized const member in %q#T using %<new%>\",\n+\t\t   origin);\n+\t  else\n+\t    error (\"uninitialized const member in %q#T\", origin);\n+\t  inform (DECL_SOURCE_LOCATION (field),\n+\t\t  \"%qD should be initialized\", field);\n+\t}\n+\n+      if (CLASS_TYPE_P (field_type))\n+\tdiagnose_uninitialized_cst_or_ref_member_1 (field_type,\n+\t\t\t\t\t\t    origin, using_new);\n+    }\n+}\n+\n+void\n+diagnose_uninitialized_cst_or_ref_member (tree type, bool using_new)\n+{\n+  diagnose_uninitialized_cst_or_ref_member_1 (type, type, using_new);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -1839,6 +1893,38 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \n   is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || *init != NULL);\n \n+  if (*init == NULL && !type_has_user_provided_constructor (elt_type))\n+    {\n+      bool uninitialized_error = false;\n+      /* A program that calls for default-initialization [...] of an\n+\t entity of reference type is ill-formed. */\n+      if (CLASSTYPE_REF_FIELDS_NEED_INIT (elt_type))\n+\tuninitialized_error = true;\n+\n+      /* A new-expression that creates an object of type T initializes\n+\t that object as follows:\n+      - If the new-initializer is omitted:\n+        -- If T is a (possibly cv-qualified) non-POD class type\n+\t   (or array thereof), the object is default-initialized (8.5).\n+\t   [...]\n+        -- Otherwise, the object created has indeterminate\n+\t   value. If T is a const-qualified type, or a (possibly\n+\t   cv-qualified) POD class type (or array thereof)\n+\t   containing (directly or indirectly) a member of\n+\t   const-qualified type, the program is ill-formed; */\n+\n+      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (elt_type))\n+\tuninitialized_error = true;\n+\n+      if (uninitialized_error)\n+\t{\n+\t  if (complain & tf_error)\n+\t    diagnose_uninitialized_cst_or_ref_member (elt_type,\n+\t\t\t\t\t\t      /*using_new*/true);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n   if (CP_TYPE_CONST_P (elt_type) && *init == NULL\n       && !type_has_user_provided_default_constructor (elt_type))\n     {"}, {"sha": "4b79ce0a0cfd5beb7a5a3e7793a0956ef42cc714", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "patch": "@@ -1,3 +1,8 @@\n+2010-04-12  Fabien Chene  <fabien.chene@gmail.com>\n+\n+\tPR c++/25811\n+\t* g++.dg/init/pr25811.C: New test.\n+\n 2010-04-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/warn/miss-format-1.C: Removed *-*-solaris2.7 from"}, {"sha": "c906a9bbd355ff9285faa312f1eb93d9d0c77c7e", "filename": "gcc/testsuite/g++.dg/init/pr25811.C", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr25811.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d809e8f576a99800ee09ab72cbcb1c2b3250c34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr25811.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr25811.C?ref=9d809e8f576a99800ee09ab72cbcb1c2b3250c34", "patch": "@@ -0,0 +1,195 @@\n+// PR c++/25811\n+// { dg-do compile }\n+\n+struct A1\n+{\n+  int const j; // { dg-message \"should be initialized\" }\n+};\n+\n+struct A2\n+{\n+  int const volatile i; // { dg-message \"should be initialized\" }\n+};\n+\n+struct A3\n+{\n+  int& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct A4\n+{\n+  int const& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct A5\n+{\n+  int& ref; // { dg-message \"should be initialized\" }\n+  int const i; // { dg-message \"should be initialized\" }\n+};\n+\n+template <class T> struct S1\n+{\n+  T const i; // { dg-message \"should be initialized\" }\n+};\n+\n+template <class T> struct S2\n+{\n+  T const volatile i; // { dg-message \"should be initialized\" }\n+};\n+\n+template <class T> struct S3\n+{\n+  T& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+template <class T> struct S4\n+{\n+  T const i; // { dg-message \"should be initialized\" }\n+  T& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct X\n+{\n+  X () : c (0), r (c) {}\n+  int const c;\n+  int const& r;\n+};\n+\n+struct Y11\n+{\n+  int const i; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Y1\n+{\n+  Y11 a[1];\n+};\n+\n+struct Y22\n+{\n+  int& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Y2\n+{\n+  Y22 a[1];\n+};\n+\n+struct Z1\n+{\n+  int const i; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Z2\n+{\n+  int& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Z3\n+{\n+  int const i; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Z4\n+{\n+  int& ref; // { dg-message \"should be initialized\" }\n+};\n+\n+struct Z5\n+{\n+  int i;\n+};\n+\n+struct Z\n+{\n+  Z1 z1;\n+  Z2 z2;\n+  Z3 z3;\n+  Z4 z4;\n+  Z5 z5;\n+};\n+\n+union U\n+{\n+  int const i; // { dg-message \"should be initialized\" }\n+};\n+\n+void f1 ()\n+{\n+  new A1; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f2 ()\n+{\n+  new A2; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f3 ()\n+{\n+  new A3; // { dg-error \"uninitialized reference member\" }\n+}\n+\n+void f4 ()\n+{\n+  new A4; // { dg-error \"uninitialized reference member\" }\n+}\n+\n+void f5 ()\n+{\n+  new A5; // { dg-error \"uninitialized reference member|uninitialized const member\" }\n+}\n+\n+void f6 ()\n+{\n+  new S1<int>; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f7 ()\n+{\n+  new S2<int>; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f8 ()\n+{\n+  new S3<int>; // { dg-error \"uninitialized reference member\" }\n+}\n+\n+void f9 ()\n+{\n+  new S4<int>; // { dg-error \"uninitialized reference member|uninitialized const member\" }\n+}\n+\n+void f10 ()\n+{\n+  new X;\n+}\n+\n+void f11 ()\n+{\n+  new A1[1]; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f12 ()\n+{\n+  new A3[1]; // { dg-error \"uninitialized reference member\" }\n+}\n+\n+void f13 ()\n+{\n+  new Y1; // { dg-error \"uninitialized const member\" }\n+}\n+\n+void f14 ()\n+{\n+  new Y2; // { dg-error \"uninitialized reference member\" }\n+}\n+\n+void f15 ()\n+{\n+  new Z; // { dg-error \"uninitialized reference member|uninitialized const member\" }\n+}\n+\n+void f16 ()\n+{\n+  new U; // { dg-error \"uninitialized const member\" }\n+}"}]}