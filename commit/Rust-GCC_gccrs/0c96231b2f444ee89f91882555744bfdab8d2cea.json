{"sha": "0c96231b2f444ee89f91882555744bfdab8d2cea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5NjIzMWIyZjQ0NGVlODlmOTE4ODI1NTU3NDRiZmRhYjhkMmNlYQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2008-02-29T12:41:14Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-02-29T12:41:14Z"}, "message": "tree-loop-linear.c (try_interchange_loops): Compare memory access strides against cache sizes.\n\n\t* tree-loop-linear.c (try_interchange_loops): Compare memory access\n\tstrides against cache sizes.\n\n\t* testsuite/gcc.dg/tree-ssa/ltrans-8.c: Increase the size of strides\n\tto make the interchange profitable.\n\nFrom-SVN: r132765", "tree": {"sha": "f9a535bf4c6727dddb73dd954029131e101008f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9a535bf4c6727dddb73dd954029131e101008f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c96231b2f444ee89f91882555744bfdab8d2cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c96231b2f444ee89f91882555744bfdab8d2cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c96231b2f444ee89f91882555744bfdab8d2cea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c96231b2f444ee89f91882555744bfdab8d2cea/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d973ac5a9f35cbb79c6c2457f48159f1541f79c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d973ac5a9f35cbb79c6c2457f48159f1541f79c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d973ac5a9f35cbb79c6c2457f48159f1541f79c4"}], "stats": {"total": 49, "additions": 43, "deletions": 6}, "files": [{"sha": "617782a0584ff1d6e91acf8266f3ea736c2ef52f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c96231b2f444ee89f91882555744bfdab8d2cea", "patch": "@@ -1,3 +1,8 @@\n+2008-02-29  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-loop-linear.c (try_interchange_loops): Compare memory access\n+\tstrides against cache sizes.\n+\n 2008-02-29  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_secondary_reload): Handle loading a float"}, {"sha": "93f2c458dbd509c239e846dda59b8b01a87ceabc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c96231b2f444ee89f91882555744bfdab8d2cea", "patch": "@@ -1,3 +1,8 @@\n+2008-02-29  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* testsuite/gcc.dg/tree-ssa/ltrans-8.c: Increase the size of strides\n+\tto make the interchange profitable.\n+\n 2008-02-28  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/31463"}, {"sha": "21f8ffafce6476c2aeb69f8186595f07c2777ba4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c?ref=0c96231b2f444ee89f91882555744bfdab8d2cea", "patch": "@@ -4,9 +4,9 @@ double foo(double *a)\n {\n        int i,j;\n        double r = 0.0;\n-      for (i=0; i<8; ++i)\n-               for (j=0; j<8; ++j)\n-                      r += a[j*8+i];\n+      for (i=0; i<100; ++i)\n+               for (j=0; j<1000; ++j)\n+                      r += a[j*100+i];\n        return r;\n }\n "}, {"sha": "806d9e6d1cb7b3886bd042c70c9d9db04586d9cd", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96231b2f444ee89f91882555744bfdab8d2cea/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=0c96231b2f444ee89f91882555744bfdab8d2cea", "patch": "@@ -179,10 +179,14 @@ try_interchange_loops (lambda_trans_matrix trans,\n \t\t       VEC (data_reference_p, heap) *datarefs,\n \t\t       struct loop *first_loop)\n {\n+  bool res;\n   struct loop *loop_i;\n   struct loop *loop_j;\n   unsigned int dependence_steps_i, dependence_steps_j;\n   double_int access_strides_i, access_strides_j;\n+  double_int small, large, nb_iter;\n+  double_int l1_cache_size, l2_cache_size;\n+  int cmp;\n   unsigned int nb_deps_not_carried_by_i, nb_deps_not_carried_by_j;\n   struct data_dependence_relation *ddr;\n \n@@ -194,7 +198,10 @@ try_interchange_loops (lambda_trans_matrix trans,\n   ddr = VEC_index (ddr_p, dependence_relations, 0);\n   if (ddr == NULL || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     return trans;\n-  \n+\n+  l1_cache_size = uhwi_to_double_int (L1_CACHE_SIZE * 1024);\n+  l2_cache_size = uhwi_to_double_int (L2_CACHE_SIZE * 1024);\n+\n   /* LOOP_I is always the outer loop.  */\n   for (loop_j = first_loop->inner; \n        loop_j; \n@@ -216,18 +223,38 @@ try_interchange_loops (lambda_trans_matrix trans,\n \t\n \t/* Heuristics for loop interchange profitability:\n \n+\t   0. Don't transform if the smallest stride is larger than\n+\t      the L2 cache, or if the largest stride multiplied by the\n+\t      number of iterations is smaller than the L1 cache.\n+\n \t   1. (spatial locality) Inner loops should have smallest\n               dependence steps.\n \n \t   2. (spatial locality) Inner loops should contain more\n \t   dependence relations not carried by the loop.\n \n-\t   3. (temporal locality) Inner loops should have smallest \n+\t   3. (temporal locality) Inner loops should have smallest\n \t      array access strides.\n \t*/\n+\n+\tcmp = double_int_ucmp (access_strides_i, access_strides_j);\n+\tsmall = cmp < 0 ? access_strides_i : access_strides_j;\n+\tlarge = cmp < 0 ? access_strides_j : access_strides_i;\n+\n+\tif (double_int_ucmp (small, l2_cache_size) > 0)\n+\t  continue;\n+\n+\tres = cmp < 0 ?\n+\t  estimated_loop_iterations (loop_j, false, &nb_iter):\n+\t  estimated_loop_iterations (loop_i, false, &nb_iter);\n+\tlarge = double_int_mul (large, nb_iter);\n+\n+\tif (res && double_int_ucmp (large, l1_cache_size) < 0)\n+\t  continue;\n+\n \tif (dependence_steps_i < dependence_steps_j \n \t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j\n-\t    || double_int_ucmp (access_strides_i, access_strides_j) < 0)\n+\t    || cmp < 0)\n \t  {\n \t    lambda_matrix_row_exchange (LTM_MATRIX (trans),\n \t\t\t\t\tloop_depth (loop_i) - loop_depth (first_loop),"}]}