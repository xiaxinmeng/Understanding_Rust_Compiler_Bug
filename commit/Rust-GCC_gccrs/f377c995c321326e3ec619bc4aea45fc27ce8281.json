{"sha": "f377c995c321326e3ec619bc4aea45fc27ce8281", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3N2M5OTVjMzIxMzI2ZTNlYzYxOWJjNGFlYTQ1ZmMyN2NlODI4MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-06-06T10:44:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:44:43Z"}, "message": "sem_util.ads, [...] (May_Be_Lvalue): A prefix of an attribute reference acts as an lvalue when...\n\n2007-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (May_Be_Lvalue): A prefix of an attribute\n\treference acts as an lvalue when the attribute name modifies the prefix\n\t(Is_Coextension_Root): New routine.\n\t(Mark_Static_Coextensions): New routine.\n\t(Type_Access_Level): Revise code for checking the level of the\n\tanonymous access type of a return object.\n\t(Safe_To_Capture_Value): Not safe to capture if Address_Taken\n\t(Matches_Prefixed_View_Profile): Remove the no longer necessary\n\tretrieval of the corresponding controlling record type.\n\t(Find_Overridden_Synchronized_Primitive): Code cleanup. Add handling of\n\tconcurrent types declared within a generic as well as class wide types.\n\tEmit a mode incompatibility error whenever a protected entry or routine\n\toverride an interface routine whose first parameter is not of mode\n\t\"out\", \"in out\" or access to variable.\n\t(Overrides_Synchronized_Primitive): Rename to\n\tFind_Overridden_Synchronized_Primitive.\n\t(Collect_Interface_Components): New subprogram that collects all the\n\tcomponents of a tagged record containing tags of secondary dispatch\n\ttables.\n\t(Add_Global_Declaration): New procedure\n\t(Abstract_Interface_List): Handle properly the case of a subtype of a\n\tprivate extension.\n\t(Type_Access_Level): In the case of a type whose parent scope is a\n\treturn statement, call Type_Access_Level recursively on the enclosing\n\tfunction's result type to determine the level of the return object's\n\ttype.\n\t(Build_Elaboration_Entity): Build name of elaboration entity from the\n\tscope chain of the entity, rather than the unit name of the file name.\n\t(Check_Nested_Access): New procedure.\n\t(Has_Up_Level_Access, Set_Has_Up_Level_Access): New procedures.\n\t(Find_Direct_Name, Note_Possible_Modification): Use Check_Nested_Access.\n\t(Get_Renamed_Entity): Utility routine for performing common operation\n\tof chasing the Renamed_Entity field of an entity.\n\nFrom-SVN: r125453", "tree": {"sha": "db949ab416509cd19330c3e0ec3476fab527544b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db949ab416509cd19330c3e0ec3476fab527544b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f377c995c321326e3ec619bc4aea45fc27ce8281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f377c995c321326e3ec619bc4aea45fc27ce8281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f377c995c321326e3ec619bc4aea45fc27ce8281", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f377c995c321326e3ec619bc4aea45fc27ce8281/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20"}], "stats": {"total": 1158, "additions": 784, "deletions": 374}, "files": [{"sha": "2e618024bd86da91851db51f3b67913a82ec908b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 730, "deletions": 361, "changes": 1091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f377c995c321326e3ec619bc4aea45fc27ce8281/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f377c995c321326e3ec619bc4aea45fc27ce8281/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f377c995c321326e3ec619bc4aea45fc27ce8281", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,6 @@ with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Output;   use Output;\n@@ -45,6 +44,7 @@ with Rtsfind;  use Rtsfind;\n with Scans;    use Scans;\n with Scn;      use Scn;\n with Sem;      use Sem;\n+with Sem_Attr; use Sem_Attr;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -126,6 +126,12 @@ package body Sem_Util is\n       elsif Ekind (Typ) = E_Record_Subtype then\n          Nod := Type_Definition (Parent (Etype (Typ)));\n \n+      elsif Ekind (Typ) = E_Record_Subtype_With_Private then\n+\n+         --  Recurse, because parent may still be a private extension\n+\n+         return Abstract_Interface_List (Etype (Full_View (Typ)));\n+\n       else pragma Assert ((Ekind (Typ)) = E_Record_Type);\n          if Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n             Nod := Formal_Type_Definition (Parent (Typ));\n@@ -156,6 +162,22 @@ package body Sem_Util is\n       Append_Elmt (A, L);\n    end Add_Access_Type_To_Process;\n \n+   ----------------------------\n+   -- Add_Global_Declaration --\n+   ----------------------------\n+\n+   procedure Add_Global_Declaration (N : Node_Id) is\n+      Aux_Node : constant Node_Id := Aux_Decls_Node (Cunit (Current_Sem_Unit));\n+\n+   begin\n+      if No (Declarations (Aux_Node)) then\n+         Set_Declarations (Aux_Node, New_List);\n+      end if;\n+\n+      Append_To (Declarations (Aux_Node), N);\n+      Analyze (N);\n+   end Add_Global_Declaration;\n+\n    -----------------------\n    -- Alignment_In_Bits --\n    -----------------------\n@@ -719,11 +741,39 @@ package body Sem_Util is\n    ------------------------------\n \n    procedure Build_Elaboration_Entity (N : Node_Id; Spec_Id : Entity_Id) is\n-      Loc       : constant Source_Ptr       := Sloc (N);\n-      Unum      : constant Unit_Number_Type := Get_Source_Unit (Loc);\n-      Decl      : Node_Id;\n-      P         : Natural;\n-      Elab_Ent  : Entity_Id;\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Decl     : Node_Id;\n+      Elab_Ent : Entity_Id;\n+\n+      procedure Set_Package_Name (Ent : Entity_Id);\n+      --  Given an entity, sets the fully qualified name of the entity in\n+      --  Name_Buffer, with components separated by double underscores. This\n+      --  is a recursive routine that climbs the scope chain to Standard.\n+\n+      ----------------------\n+      -- Set_Package_Name --\n+      ----------------------\n+\n+      procedure Set_Package_Name (Ent : Entity_Id) is\n+      begin\n+         if Scope (Ent) /= Standard_Standard then\n+            Set_Package_Name (Scope (Ent));\n+\n+            declare\n+               Nam : constant String := Get_Name_String (Chars (Ent));\n+            begin\n+               Name_Buffer (Name_Len + 1) := '_';\n+               Name_Buffer (Name_Len + 2) := '_';\n+               Name_Buffer (Name_Len + 3 .. Name_Len + Nam'Length + 2) := Nam;\n+               Name_Len := Name_Len + Nam'Length + 2;\n+            end;\n+\n+         else\n+            Get_Name_String (Chars (Ent));\n+         end if;\n+      end Set_Package_Name;\n+\n+   --  Start of processing for Build_Elaboration_Entity\n \n    begin\n       --  Ignore if already constructed\n@@ -732,44 +782,25 @@ package body Sem_Util is\n          return;\n       end if;\n \n-      --  Construct name of elaboration entity as xxx_E, where xxx\n-      --  is the unit name with dots replaced by double underscore.\n-      --  We have to manually construct this name, since it will\n-      --  be elaborated in the outer scope, and thus will not have\n-      --  the unit name automatically prepended.\n-\n-      Get_Name_String (Unit_Name (Unum));\n+      --  Construct name of elaboration entity as xxx_E, where xxx is the unit\n+      --  name with dots replaced by double underscore. We have to manually\n+      --  construct this name, since it will be elaborated in the outer scope,\n+      --  and thus will not have the unit name automatically prepended.\n \n-      --  Replace the %s by _E\n+      Set_Package_Name (Spec_Id);\n \n-      Name_Buffer (Name_Len - 1 .. Name_Len) := \"_E\";\n+      --  Append _E\n \n-      --  Replace dots by double underscore\n-\n-      P := 2;\n-      while P < Name_Len - 2 loop\n-         if Name_Buffer (P) = '.' then\n-            Name_Buffer (P + 2 .. Name_Len + 1) :=\n-              Name_Buffer (P + 1 .. Name_Len);\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (P) := '_';\n-            Name_Buffer (P + 1) := '_';\n-            P := P + 3;\n-         else\n-            P := P + 1;\n-         end if;\n-      end loop;\n+      Name_Buffer (Name_Len + 1) := '_';\n+      Name_Buffer (Name_Len + 2) := 'E';\n+      Name_Len := Name_Len + 2;\n \n       --  Create elaboration flag\n \n       Elab_Ent :=\n         Make_Defining_Identifier (Loc, Chars => Name_Find);\n       Set_Elaboration_Entity (Spec_Id, Elab_Ent);\n \n-      if No (Declarations (Aux_Decls_Node (N))) then\n-         Set_Declarations (Aux_Decls_Node (N), New_List);\n-      end if;\n-\n       Decl :=\n          Make_Object_Declaration (Loc,\n            Defining_Identifier => Elab_Ent,\n@@ -778,8 +809,9 @@ package body Sem_Util is\n            Expression          =>\n              New_Occurrence_Of (Standard_False, Loc));\n \n-      Append_To (Declarations (Aux_Decls_Node (N)), Decl);\n-      Analyze (Decl);\n+      Push_Scope (Standard_Standard);\n+      Add_Global_Declaration (Decl);\n+      Pop_Scope;\n \n       --  Reset True_Constant indication, since we will indeed assign a value\n       --  to the variable in the binder main. We also kill the Current_Value\n@@ -965,13 +997,48 @@ package body Sem_Util is\n       end if;\n    end Check_Fully_Declared;\n \n+   -------------------------\n+   -- Check_Nested_Access --\n+   -------------------------\n+\n+   procedure Check_Nested_Access (Ent : Entity_Id) is\n+      Scop         : constant Entity_Id := Current_Scope;\n+      Current_Subp : Entity_Id;\n+\n+   begin\n+      --  Currently only enabled for VM back-ends for efficiency, should we\n+      --  enable it more systematically ???\n+\n+      if VM_Target /= No_VM\n+        and then (Ekind (Ent) = E_Variable\n+                    or else\n+                  Ekind (Ent) = E_Constant\n+                    or else\n+                  Ekind (Ent) = E_Loop_Parameter)\n+        and then Scope (Ent) /= Empty\n+        and then not Is_Library_Level_Entity (Ent)\n+      then\n+         if Is_Subprogram (Scop)\n+           or else Is_Generic_Subprogram (Scop)\n+           or else Is_Entry (Scop)\n+         then\n+            Current_Subp := Scop;\n+         else\n+            Current_Subp := Current_Subprogram;\n+         end if;\n+\n+         if Enclosing_Subprogram (Ent) /= Current_Subp then\n+            Set_Has_Up_Level_Access (Ent, True);\n+         end if;\n+      end if;\n+   end Check_Nested_Access;\n+\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n \n    procedure Check_Potentially_Blocking_Operation (N : Node_Id) is\n-      S   : Entity_Id;\n-\n+      S : Entity_Id;\n    begin\n       --  N is one of the potentially blocking operations listed in 9.5.1(8).\n       --  When pragma Detect_Blocking is active, the run time will raise\n@@ -1177,6 +1244,65 @@ package body Sem_Util is\n       Collect (T);\n    end Collect_Abstract_Interfaces;\n \n+   ----------------------------------\n+   -- Collect_Interface_Components --\n+   ----------------------------------\n+\n+   procedure Collect_Interface_Components\n+     (Tagged_Type     : Entity_Id;\n+      Components_List : out Elist_Id)\n+   is\n+      procedure Collect (Typ : Entity_Id);\n+      --  Subsidiary subprogram used to climb to the parents\n+\n+      -------------\n+      -- Collect --\n+      -------------\n+\n+      procedure Collect (Typ : Entity_Id) is\n+         Tag_Comp : Entity_Id;\n+\n+      begin\n+         if Etype (Typ) /= Typ\n+\n+            --  Protect the frontend against wrong sources. For example:\n+\n+            --    package P is\n+            --      type A is tagged null record;\n+            --      type B is new A with private;\n+            --      type C is new A with private;\n+            --    private\n+            --      type B is new C with null record;\n+            --      type C is new B with null record;\n+            --    end P;\n+\n+           and then Etype (Typ) /= Tagged_Type\n+         then\n+            Collect (Etype (Typ));\n+         end if;\n+\n+         --  Collect the components containing tags of secondary dispatch\n+         --  tables.\n+\n+         Tag_Comp := Next_Tag_Component (First_Tag_Component (Typ));\n+         while Present (Tag_Comp) loop\n+            pragma Assert (Present (Related_Interface (Tag_Comp)));\n+            Append_Elmt (Tag_Comp, Components_List);\n+\n+            Tag_Comp := Next_Tag_Component (Tag_Comp);\n+         end loop;\n+      end Collect;\n+\n+   --  Start of processing for Collect_Interface_Components\n+\n+   begin\n+      pragma Assert (Ekind (Tagged_Type) = E_Record_Type\n+        and then Is_Tagged_Type (Tagged_Type));\n+\n+      Components_List := New_Elmt_List;\n+      Collect (Tagged_Type);\n+   end Collect_Interface_Components;\n+\n    ----------------------------------\n    -- Collect_Primitive_Operations --\n    ----------------------------------\n@@ -2415,6 +2541,321 @@ package body Sem_Util is\n       raise Program_Error;\n    end Find_Corresponding_Discriminant;\n \n+   --------------------------------------------\n+   -- Find_Overridden_Synchronized_Primitive --\n+   --------------------------------------------\n+\n+   function Find_Overridden_Synchronized_Primitive\n+     (Def_Id      : Entity_Id;\n+      First_Hom   : Entity_Id;\n+      Ifaces_List : Elist_Id;\n+      In_Scope    : Boolean := True) return Entity_Id\n+   is\n+      Candidate : Entity_Id := Empty;\n+      Hom       : Entity_Id := Empty;\n+      Iface_Typ : Entity_Id;\n+      Subp      : Entity_Id := Empty;\n+      Tag_Typ   : Entity_Id;\n+\n+      function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n+      --  Return the type of a formal parameter as determined by its\n+      --  specification.\n+\n+      function Has_Correct_Formal_Mode (Subp : Entity_Id) return Boolean;\n+      --  For an overridden subprogram Subp, check whether the mode of its\n+      --  first parameter is correct depending on the kind of Tag_Typ.\n+\n+      function Matches_Prefixed_View_Profile\n+        (Prim_Params  : List_Id;\n+         Iface_Params : List_Id) return Boolean;\n+      --  Determine whether a subprogram's parameter profile Prim_Params\n+      --  matches that of a potentially overriden interface subprogram\n+      --  Iface_Params. Also determine if the type of first parameter of\n+      --  Iface_Params is an implemented interface.\n+\n+      -------------------------\n+      -- Find_Parameter_Type --\n+      -------------------------\n+\n+      function Find_Parameter_Type (Param : Node_Id) return Entity_Id is\n+      begin\n+         pragma Assert (Nkind (Param) = N_Parameter_Specification);\n+\n+         if Nkind (Parameter_Type (Param)) = N_Access_Definition then\n+            return Etype (Subtype_Mark (Parameter_Type (Param)));\n+\n+         else\n+            return Etype (Parameter_Type (Param));\n+         end if;\n+      end Find_Parameter_Type;\n+\n+      -----------------------------\n+      -- Has_Correct_Formal_Mode --\n+      -----------------------------\n+\n+      function Has_Correct_Formal_Mode (Subp : Entity_Id) return Boolean is\n+         Param : Node_Id;\n+\n+      begin\n+         Param := First_Formal (Subp);\n+\n+         --  In order for an entry or a protected procedure to override, the\n+         --  first parameter of the overridden routine must be of mode \"out\",\n+         --  \"in out\" or access-to-variable.\n+\n+         if (Ekind (Subp) = E_Entry\n+               or else Ekind (Subp) = E_Procedure)\n+           and then Is_Protected_Type (Tag_Typ)\n+           and then Ekind (Param) /= E_In_Out_Parameter\n+           and then Ekind (Param) /= E_Out_Parameter\n+           and then Nkind (Parameter_Type (Parent (Param))) /=\n+                      N_Access_Definition\n+         then\n+            return False;\n+         end if;\n+\n+         --  All other cases are OK since a task entry or routine does not\n+         --  have a restriction on the mode of the first parameter of the\n+         --  overridden interface routine.\n+\n+         return True;\n+      end Has_Correct_Formal_Mode;\n+\n+      -----------------------------------\n+      -- Matches_Prefixed_View_Profile --\n+      -----------------------------------\n+\n+      function Matches_Prefixed_View_Profile\n+        (Prim_Params  : List_Id;\n+         Iface_Params : List_Id) return Boolean\n+      is\n+         Iface_Id     : Entity_Id;\n+         Iface_Param  : Node_Id;\n+         Iface_Typ    : Entity_Id;\n+         Prim_Id      : Entity_Id;\n+         Prim_Param   : Node_Id;\n+         Prim_Typ     : Entity_Id;\n+\n+         function Is_Implemented (Iface : Entity_Id) return Boolean;\n+         --  Determine if Iface is implemented by the current task or\n+         --  protected type.\n+\n+         --------------------\n+         -- Is_Implemented --\n+         --------------------\n+\n+         function Is_Implemented (Iface : Entity_Id) return Boolean is\n+            Iface_Elmt : Elmt_Id;\n+\n+         begin\n+            Iface_Elmt := First_Elmt (Ifaces_List);\n+            while Present (Iface_Elmt) loop\n+               if Node (Iface_Elmt) = Iface then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+\n+            return False;\n+         end Is_Implemented;\n+\n+      --  Start of processing for Matches_Prefixed_View_Profile\n+\n+      begin\n+         Iface_Param := First (Iface_Params);\n+         Iface_Typ   := Find_Parameter_Type (Iface_Param);\n+         Prim_Param  := First (Prim_Params);\n+\n+         --  The first parameter of the potentially overriden subprogram\n+         --  must be an interface implemented by Prim.\n+\n+         if not Is_Interface (Iface_Typ)\n+           or else not Is_Implemented (Iface_Typ)\n+         then\n+            return False;\n+         end if;\n+\n+         --  The checks on the object parameters are done, move onto the rest\n+         --  of the parameters.\n+\n+         if not In_Scope then\n+            Prim_Param := Next (Prim_Param);\n+         end if;\n+\n+         Iface_Param := Next (Iface_Param);\n+         while Present (Iface_Param) and then Present (Prim_Param) loop\n+            Iface_Id  := Defining_Identifier (Iface_Param);\n+            Iface_Typ := Find_Parameter_Type (Iface_Param);\n+            Prim_Id   := Defining_Identifier (Prim_Param);\n+            Prim_Typ  := Find_Parameter_Type (Prim_Param);\n+\n+            --  Case of multiple interface types inside a parameter profile\n+\n+            --     (Obj_Param : in out Iface; ...; Param : Iface)\n+\n+            --  If the interface type is implemented, then the matching type\n+            --  in the primitive should be the implementing record type.\n+\n+            if Ekind (Iface_Typ) = E_Record_Type\n+              and then Is_Interface (Iface_Typ)\n+              and then Is_Implemented (Iface_Typ)\n+            then\n+               if Prim_Typ /= Tag_Typ then\n+                  return False;\n+               end if;\n+\n+            --  The two parameters must be both mode and subtype conformant\n+\n+            elsif Ekind (Iface_Id) /= Ekind (Prim_Id)\n+              or else\n+                not Conforming_Types (Iface_Typ, Prim_Typ, Subtype_Conformant)\n+            then\n+               return False;\n+            end if;\n+\n+            Next (Iface_Param);\n+            Next (Prim_Param);\n+         end loop;\n+\n+         --  One of the two lists contains more parameters than the other\n+\n+         if Present (Iface_Param) or else Present (Prim_Param) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Matches_Prefixed_View_Profile;\n+\n+   --  Start of processing for Find_Overridden_Synchronized_Primitive\n+\n+   begin\n+      --  At this point the caller should have collected the interfaces\n+      --  implemented by the synchronized type.\n+\n+      pragma Assert (Present (Ifaces_List));\n+\n+      --  Find the tagged type to which subprogram Def_Id is primitive. If the\n+      --  subprogram was declared within a protected or a task type, the type\n+      --  is the scope itself, otherwise it is the type of the first parameter.\n+\n+      if In_Scope then\n+         Tag_Typ := Scope (Def_Id);\n+\n+      elsif Present (First_Formal (Def_Id)) then\n+         Tag_Typ := Find_Parameter_Type (Parent (First_Formal (Def_Id)));\n+\n+      --  A parameterless subprogram which is declared outside a synchronized\n+      --  type cannot act as a primitive, thus it cannot override anything.\n+\n+      else\n+         return Empty;\n+      end if;\n+\n+      --  Traverse the homonym chain, looking at a potentially overriden\n+      --  subprogram that belongs to an implemented interface.\n+\n+      Hom := First_Hom;\n+      while Present (Hom) loop\n+         Subp := Hom;\n+\n+         --  Entries can override abstract or null interface procedures\n+\n+         if Ekind (Def_Id) = E_Entry\n+           and then Ekind (Subp) = E_Procedure\n+           and then Nkind (Parent (Subp)) = N_Procedure_Specification\n+           and then (Is_Abstract_Subprogram (Subp)\n+                       or else Null_Present (Parent (Subp)))\n+         then\n+            while Present (Alias (Subp)) loop\n+               Subp := Alias (Subp);\n+            end loop;\n+\n+            if Matches_Prefixed_View_Profile\n+                 (Parameter_Specifications (Parent (Def_Id)),\n+                  Parameter_Specifications (Parent (Subp)))\n+            then\n+               Candidate := Subp;\n+\n+               --  Absolute match\n+\n+               if Has_Correct_Formal_Mode (Candidate) then\n+                  return Candidate;\n+               end if;\n+            end if;\n+\n+         --  Procedures can override abstract or null interface procedures\n+\n+         elsif Ekind (Def_Id) = E_Procedure\n+           and then Ekind (Subp) = E_Procedure\n+           and then Nkind (Parent (Subp)) = N_Procedure_Specification\n+           and then (Is_Abstract_Subprogram (Subp)\n+                       or else Null_Present (Parent (Subp)))\n+           and then Matches_Prefixed_View_Profile\n+                      (Parameter_Specifications (Parent (Def_Id)),\n+                       Parameter_Specifications (Parent (Subp)))\n+         then\n+            Candidate := Subp;\n+\n+            --  Absolute match\n+\n+            if Has_Correct_Formal_Mode (Candidate) then\n+               return Candidate;\n+            end if;\n+\n+         --  Functions can override abstract interface functions\n+\n+         elsif Ekind (Def_Id) = E_Function\n+           and then Ekind (Subp) = E_Function\n+           and then Nkind (Parent (Subp)) = N_Function_Specification\n+           and then Is_Abstract_Subprogram (Subp)\n+           and then Matches_Prefixed_View_Profile\n+                      (Parameter_Specifications (Parent (Def_Id)),\n+                       Parameter_Specifications (Parent (Subp)))\n+           and then Etype (Result_Definition (Parent (Def_Id))) =\n+                    Etype (Result_Definition (Parent (Subp)))\n+         then\n+            return Subp;\n+         end if;\n+\n+         Hom := Homonym (Hom);\n+      end loop;\n+\n+      --  After examining all candidates for overriding, we are left with\n+      --  the best match which is a mode incompatible interface routine.\n+      --  Do not emit an error of the Expander is active since this error\n+      --  will be detected later on after all concurrent types are expanded\n+      --  and all wrappers are built. This check is meant for spec-only\n+      --  compilations.\n+\n+      if Present (Candidate)\n+        and then not Expander_Active\n+      then\n+         Iface_Typ := Find_Parameter_Type (Parent (First_Formal (Candidate)));\n+\n+         --  Def_Id is primitive of a protected type, the candidate is\n+         --  primitive of a limited or synchronized interface.\n+\n+         if Is_Protected_Type (Tag_Typ)\n+           and then\n+             (Is_Limited_Interface (Iface_Typ)\n+                or else Is_Protected_Interface (Iface_Typ)\n+                or else Is_Synchronized_Interface (Iface_Typ)\n+                or else Is_Task_Interface (Iface_Typ))\n+         then\n+            Error_Msg_NE\n+              (\"first formal of & must be of mode `OUT`, `IN OUT` or \" &\n+               \"access-to-variable\", Tag_Typ, Candidate);\n+\n+            Error_Msg_N\n+              (\"\\to be overridden by protected procedure or entry \" &\n+               \"(`R`M 9.4(11))\", Tag_Typ);\n+         end if;\n+      end if;\n+\n+      return Candidate;\n+   end Find_Overridden_Synchronized_Primitive;\n+\n    -----------------------------\n    -- Find_Static_Alternative --\n    -----------------------------\n@@ -3053,57 +3494,6 @@ package body Sem_Util is\n       return Entity_Id (Get_Name_Table_Info (Id));\n    end Get_Name_Entity_Id;\n \n-   ---------------------------\n-   -- Get_Subprogram_Entity --\n-   ---------------------------\n-\n-   function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id is\n-      Nam  : Node_Id;\n-      Proc : Entity_Id;\n-\n-   begin\n-      if Nkind (Nod) = N_Accept_Statement then\n-         Nam := Entry_Direct_Name (Nod);\n-\n-      --  For an entry call, the prefix of the call is a selected component.\n-      --  Need additional code for internal calls ???\n-\n-      elsif Nkind (Nod) = N_Entry_Call_Statement then\n-         if Nkind (Name (Nod)) = N_Selected_Component then\n-            Nam := Entity (Selector_Name (Name (Nod)));\n-         else\n-            Nam := Empty;\n-         end if;\n-\n-      else\n-         Nam := Name (Nod);\n-      end if;\n-\n-      if Nkind (Nam) = N_Explicit_Dereference then\n-         Proc := Etype (Prefix (Nam));\n-      elsif Is_Entity_Name (Nam) then\n-         Proc := Entity (Nam);\n-      else\n-         return Empty;\n-      end if;\n-\n-      if Is_Object (Proc) then\n-         Proc := Etype (Proc);\n-      end if;\n-\n-      if Ekind (Proc) = E_Access_Subprogram_Type then\n-         Proc := Directly_Designated_Type (Proc);\n-      end if;\n-\n-      if not Is_Subprogram (Proc)\n-        and then Ekind (Proc) /= E_Subprogram_Type\n-      then\n-         return Empty;\n-      else\n-         return Proc;\n-      end if;\n-   end Get_Subprogram_Entity;\n-\n    ---------------------------\n    -- Get_Referenced_Object --\n    ---------------------------\n@@ -3122,6 +3512,22 @@ package body Sem_Util is\n       return R;\n    end Get_Referenced_Object;\n \n+   ------------------------\n+   -- Get_Renamed_Entity --\n+   ------------------------\n+\n+   function Get_Renamed_Entity (E : Entity_Id) return Entity_Id is\n+      R : Entity_Id;\n+\n+   begin\n+      R := E;\n+      while Present (Renamed_Entity (R)) loop\n+         R := Renamed_Entity (R);\n+      end loop;\n+\n+      return R;\n+   end Get_Renamed_Entity;\n+\n    -------------------------\n    -- Get_Subprogram_Body --\n    -------------------------\n@@ -3140,16 +3546,67 @@ package body Sem_Util is\n \n       else           --  Nkind (Decl) = N_Subprogram_Declaration\n \n-         if Present (Corresponding_Body (Decl)) then\n-            return Unit_Declaration_Node (Corresponding_Body (Decl));\n+         if Present (Corresponding_Body (Decl)) then\n+            return Unit_Declaration_Node (Corresponding_Body (Decl));\n+\n+         --  Imported subprogram case\n+\n+         else\n+            return Empty;\n+         end if;\n+      end if;\n+   end Get_Subprogram_Body;\n+\n+   ---------------------------\n+   -- Get_Subprogram_Entity --\n+   ---------------------------\n+\n+   function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id is\n+      Nam  : Node_Id;\n+      Proc : Entity_Id;\n+\n+   begin\n+      if Nkind (Nod) = N_Accept_Statement then\n+         Nam := Entry_Direct_Name (Nod);\n+\n+      --  For an entry call, the prefix of the call is a selected component.\n+      --  Need additional code for internal calls ???\n+\n+      elsif Nkind (Nod) = N_Entry_Call_Statement then\n+         if Nkind (Name (Nod)) = N_Selected_Component then\n+            Nam := Entity (Selector_Name (Name (Nod)));\n+         else\n+            Nam := Empty;\n+         end if;\n+\n+      else\n+         Nam := Name (Nod);\n+      end if;\n+\n+      if Nkind (Nam) = N_Explicit_Dereference then\n+         Proc := Etype (Prefix (Nam));\n+      elsif Is_Entity_Name (Nam) then\n+         Proc := Entity (Nam);\n+      else\n+         return Empty;\n+      end if;\n+\n+      if Is_Object (Proc) then\n+         Proc := Etype (Proc);\n+      end if;\n \n-         --  Imported subprogram case\n+      if Ekind (Proc) = E_Access_Subprogram_Type then\n+         Proc := Directly_Designated_Type (Proc);\n+      end if;\n \n-         else\n-            return Empty;\n-         end if;\n+      if not Is_Subprogram (Proc)\n+        and then Ekind (Proc) /= E_Subprogram_Type\n+      then\n+         return Empty;\n+      else\n+         return Proc;\n       end if;\n-   end Get_Subprogram_Body;\n+   end Get_Subprogram_Entity;\n \n    -----------------------------\n    -- Get_Task_Body_Procedure --\n@@ -3848,12 +4305,23 @@ package body Sem_Util is\n    --  Start of processing for Has_Preelaborable_Initialization\n \n    begin\n-      --  Immediate return if already marked as known preelaborable init\n+      --  Immediate return if already marked as known preelaborable init. This\n+      --  covers types for which this function has already been called once\n+      --  and returned True (in which case the result is cached), and also\n+      --  types to which a pragma Preelaborable_Initialization applies.\n \n       if Known_To_Have_Preelab_Init (E) then\n          return True;\n       end if;\n \n+      --  Other private types never have preelaborable initialization\n+\n+      if Is_Private_Type (E) then\n+         return False;\n+      end if;\n+\n+      --  Here for all non-private view\n+\n       --  All elementary types have preelaborable initialization\n \n       if Is_Elementary_Type (E) then\n@@ -3864,17 +4332,30 @@ package body Sem_Util is\n       elsif Is_Array_Type (E) then\n          Has_PE := Has_Preelaborable_Initialization (Component_Type (E));\n \n-      --  Record types have PI if all components have PI\n+      --  A derived type has preelaborable initialization if its parent type\n+      --  has preelaborable initialization and (in the case of a derived record\n+      --  extension) if the non-inherited components all have preelaborable\n+      --  initialization. However, a user-defined controlled type with an\n+      --  overriding Initialize procedure does not have preelaborable\n+      --  initialization.\n \n-      elsif Is_Record_Type (E) then\n-         Has_PE := True;\n-         Check_Components (First_Entity (E));\n+      elsif Is_Derived_Type (E) then\n+\n+         --  First check whether ancestor type has preelaborable initialization\n+\n+         Has_PE := Has_Preelaborable_Initialization (Etype (Base_Type (E)));\n+\n+         --  If OK, check extension components (if any)\n+\n+         if Has_PE and then Is_Record_Type (E) then\n+            Check_Components (First_Entity (E));\n+         end if;\n \n-         --  Another check here, if this is a controlled type, see if it has a\n-         --  user defined Initialize procedure. If so, then there is a special\n-         --  rule that means this type does not have PI.\n+         --  Check specifically for 10.2.1(11.4/2) exception: a controlled type\n+         --  with a user defined Initialize procedure does not have PI.\n \n-         if Is_Controlled (E)\n+         if Has_PE\n+           and then Is_Controlled (E)\n            and then Present (Primitive_Operations (E))\n          then\n             declare\n@@ -3895,7 +4376,13 @@ package body Sem_Util is\n             end;\n          end if;\n \n-      --  Protected types, must not have entries, and components must meet\n+      --  Record type has PI if it is non private and all components have PI\n+\n+      elsif Is_Record_Type (E) then\n+         Has_PE := True;\n+         Check_Components (First_Entity (E));\n+\n+      --  Protected types must not have entries, and components must meet\n       --  same set of rules as for record components.\n \n       elsif Is_Protected_Type (E) then\n@@ -3907,26 +4394,19 @@ package body Sem_Util is\n             Check_Components (First_Private_Entity (E));\n          end if;\n \n-      --  A derived type has preelaborable initialization if its parent type\n-      --  has preelaborable initialization and (in the case of a derived record\n-      --  extension) if the non-inherited components all have preelaborable\n-      --  initialization. However, a user-defined controlled type with an\n-      --  overriding Initialize procedure does not have preelaborable\n-      --  initialization.\n-\n-      --  TBD ???\n-\n       --  Type System.Address always has preelaborable initialization\n \n       elsif Is_RTE (E, RE_Address) then\n          Has_PE := True;\n \n-      --  In all other cases, type does not have preelaborable init\n+      --  In all other cases, type does not have preelaborable initialization\n \n       else\n          return False;\n       end if;\n \n+      --  If type has preelaborable initialization, cache result\n+\n       if Has_PE then\n          Set_Known_To_Have_Preelab_Init (E);\n       end if;\n@@ -4527,6 +5007,23 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n+   -------------------------\n+   -- Is_Coextension_Root --\n+   -------------------------\n+\n+   function Is_Coextension_Root (N : Node_Id) return Boolean is\n+   begin\n+      return\n+        Nkind (N) = N_Allocator\n+          and then Present (Coextensions (N))\n+\n+         --  Anonymous access discriminants carry a list of all nested\n+         --  controlled coextensions.\n+\n+          and then not Is_Coextension (N)\n+          and then not Is_Static_Coextension (N);\n+   end Is_Coextension_Root;\n+\n    --------------------------------------\n    -- Is_Controlling_Limited_Procedure --\n    --------------------------------------\n@@ -5785,6 +6282,17 @@ package body Sem_Util is\n       return (U /= 0);\n    end Is_True;\n \n+   -------------------\n+   -- Is_Value_Type --\n+   -------------------\n+\n+   function Is_Value_Type (T : Entity_Id) return Boolean is\n+   begin\n+      return VM_Target = CLI_Target\n+        and then Chars (T) /= No_Name\n+        and then Get_Name_String (Chars (T)) = \"valuetype\";\n+   end Is_Value_Type;\n+\n    -----------------\n    -- Is_Variable --\n    -----------------\n@@ -5878,6 +6386,7 @@ package body Sem_Util is\n \n       elsif Nkind (N) = N_Explicit_Dereference\n         and then Nkind (Orig_Node) /= N_Explicit_Dereference\n+        and then Present (Etype (Orig_Node))\n         and then Is_Access_Type (Etype (Orig_Node))\n       then\n          return Is_Variable_Prefix (Original_Node (Prefix (N)));\n@@ -6271,26 +6780,29 @@ package body Sem_Util is\n \n          --  Test prefix of component or attribute\n \n-         when N_Attribute_Reference  |\n-              N_Expanded_Name        |\n+         when N_Attribute_Reference =>\n+            return N = Prefix (P)\n+              and then Name_Modifies_Prefix (Attribute_Name (P));\n+\n+         when N_Expanded_Name        |\n               N_Explicit_Dereference |\n               N_Indexed_Component    |\n               N_Reference            |\n               N_Selected_Component   |\n               N_Slice                =>\n             return N = Prefix (P);\n \n-            --  Function call arguments are never lvalues\n+         --  Function call arguments are never lvalues\n \n          when N_Function_Call =>\n             return False;\n \n          --  Positional parameter for procedure, entry,  or accept call\n \n          when N_Procedure_Call_Statement |\n-              N_Entry_Call_Statement |\n+              N_Entry_Call_Statement     |\n               N_Accept_Statement\n-          =>\n+         =>\n             declare\n                Proc : Entity_Id;\n                Form : Entity_Id;\n@@ -6385,6 +6897,40 @@ package body Sem_Util is\n       end case;\n    end May_Be_Lvalue;\n \n+   ------------------------------\n+   -- Mark_Static_Coextensions --\n+   ------------------------------\n+\n+   procedure Mark_Static_Coextensions (Root_Node : Node_Id) is\n+      function Mark_Allocator (N : Node_Id) return Traverse_Result;\n+      --  Recognize an allocator node and label it as a static coextension\n+\n+      --------------------\n+      -- Mark_Allocator --\n+      --------------------\n+\n+      function Mark_Allocator (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Allocator then\n+            Set_Is_Static_Coextension (N);\n+         end if;\n+\n+         return OK;\n+      end Mark_Allocator;\n+\n+      procedure Mark_Allocators is new Traverse_Proc (Mark_Allocator);\n+\n+   --  Start of processing for Mark_Static_Coextensions\n+\n+   begin\n+      --  Do not mark allocators that stem from an initial allocator because\n+      --  these will never be static.\n+\n+      if Nkind (Root_Node) /= N_Allocator then\n+         Mark_Allocators (Root_Node);\n+      end if;\n+   end Mark_Static_Coextensions;\n+\n    ----------------------\n    -- Needs_One_Actual --\n    ----------------------\n@@ -6901,6 +7447,8 @@ package body Sem_Util is\n                if Modification_Comes_From_Source then\n                   Generate_Reference (Ent, Exp, 'm');\n                end if;\n+\n+               Check_Nested_Access (Ent);\n             end if;\n \n             Kill_Checks (Ent);\n@@ -7060,191 +7608,6 @@ package body Sem_Util is\n       end if;\n    end Object_Access_Level;\n \n-   --------------------------------------\n-   -- Overrides_Synchronized_Primitive --\n-   --------------------------------------\n-\n-   function Overrides_Synchronized_Primitive\n-     (Def_Id      : Entity_Id;\n-      First_Hom   : Entity_Id;\n-      Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean := True) return Entity_Id\n-   is\n-      Candidate : Entity_Id;\n-      Hom       : Entity_Id;\n-\n-      function Matches_Prefixed_View_Profile\n-        (Subp_Params : List_Id;\n-         Over_Params : List_Id) return Boolean;\n-      --  Determine if a subprogram parameter profile (Subp_Params)\n-      --  matches that of a potentially overriden subprogram (Over_Params).\n-      --  Determine if the type of first parameter in the list Over_Params\n-      --  is an implemented interface, that is to say, the interface is in\n-      --  Ifaces_List.\n-\n-      -----------------------------------\n-      -- Matches_Prefixed_View_Profile --\n-      -----------------------------------\n-\n-      function Matches_Prefixed_View_Profile\n-        (Subp_Params : List_Id;\n-         Over_Params : List_Id) return Boolean\n-      is\n-         Subp_Param     : Node_Id;\n-         Over_Param     : Node_Id;\n-         Over_Param_Typ : Entity_Id;\n-\n-         function Is_Implemented (Iface : Entity_Id) return Boolean;\n-         --  Determine if Iface is implemented by the current task or\n-         --  protected type.\n-\n-         --------------------\n-         -- Is_Implemented --\n-         --------------------\n-\n-         function Is_Implemented (Iface : Entity_Id) return Boolean is\n-            Iface_Elmt : Elmt_Id;\n-\n-         begin\n-            Iface_Elmt := First_Elmt (Ifaces_List);\n-            while Present (Iface_Elmt) loop\n-               if Node (Iface_Elmt) = Iface then\n-                  return True;\n-               end if;\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-\n-            return False;\n-         end Is_Implemented;\n-\n-      --  Start of processing for Matches_Prefixed_View_Profile\n-\n-      begin\n-         Subp_Param := First (Subp_Params);\n-         Over_Param := First (Over_Params);\n-\n-         if Nkind (Parameter_Type (Over_Param)) = N_Access_Definition then\n-            Over_Param_Typ :=\n-              Etype (Subtype_Mark (Parameter_Type (Over_Param)));\n-         else\n-            Over_Param_Typ := Etype (Parameter_Type (Over_Param));\n-         end if;\n-\n-         --  The first parameter of the potentially overriden subprogram\n-         --  must be an interface implemented by Def_Id.\n-\n-         if not Is_Interface (Over_Param_Typ)\n-           or else not Is_Implemented (Over_Param_Typ)\n-         then\n-            return False;\n-         end if;\n-\n-         --  This may be a primitive declared after a task or protected type.\n-         --  We need to skip the first parameter since it is irrelevant.\n-\n-         if not In_Scope then\n-            Subp_Param := Next (Subp_Param);\n-         end if;\n-         Over_Param := Next (Over_Param);\n-\n-         while Present (Subp_Param) and then Present (Over_Param) loop\n-\n-            --  The two parameters must be mode conformant and both types\n-            --  must be the same.\n-\n-            if Ekind (Defining_Identifier (Subp_Param)) /=\n-                 Ekind (Defining_Identifier (Over_Param))\n-              or else\n-                not Conforming_Types\n-                  (Etype (Parameter_Type (Subp_Param)),\n-                   Etype (Parameter_Type (Over_Param)),\n-                   Subtype_Conformant)\n-            then\n-               return False;\n-            end if;\n-\n-            Next (Subp_Param);\n-            Next (Over_Param);\n-         end loop;\n-\n-         --  One of the two lists contains more parameters than the other\n-\n-         if Present (Subp_Param) or else Present (Over_Param) then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end Matches_Prefixed_View_Profile;\n-\n-   --  Start of processing for Overrides_Synchronized_Primitive\n-\n-   begin\n-      --  At this point the caller should have collected the interfaces\n-      --  implemented by the synchronized type.\n-\n-      pragma Assert (Present (Ifaces_List));\n-\n-      --  Traverse the homonym chain, looking at a potentially overriden\n-      --  subprogram that belongs to an implemented interface.\n-\n-      Hom := First_Hom;\n-      while Present (Hom) loop\n-         Candidate := Hom;\n-\n-         --  Entries can override abstract or null interface procedures\n-\n-         if Ekind (Def_Id) = E_Entry\n-           and then Ekind (Candidate) = E_Procedure\n-           and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n-           and then (Is_Abstract_Subprogram (Candidate)\n-                       or else Null_Present (Parent (Candidate)))\n-         then\n-            while Present (Alias (Candidate)) loop\n-               Candidate := Alias (Candidate);\n-            end loop;\n-\n-            if Matches_Prefixed_View_Profile\n-                 (Parameter_Specifications (Parent (Def_Id)),\n-                  Parameter_Specifications (Parent (Candidate)))\n-            then\n-               return Candidate;\n-            end if;\n-\n-         --  Procedure can override abstract or null interface procedures\n-\n-         elsif Ekind (Def_Id) = E_Procedure\n-           and then Ekind (Candidate) = E_Procedure\n-           and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n-           and then (Is_Abstract_Subprogram (Candidate)\n-                       or else Null_Present (Parent (Candidate)))\n-           and then Matches_Prefixed_View_Profile\n-                      (Parameter_Specifications (Parent (Def_Id)),\n-                       Parameter_Specifications (Parent (Candidate)))\n-         then\n-            return Candidate;\n-\n-         --  Function can override abstract interface functions\n-\n-         elsif Ekind (Def_Id) = E_Function\n-           and then Ekind (Candidate) = E_Function\n-           and then Nkind (Parent (Candidate)) = N_Function_Specification\n-           and then Is_Abstract_Subprogram (Candidate)\n-           and then Matches_Prefixed_View_Profile\n-                      (Parameter_Specifications (Parent (Def_Id)),\n-                       Parameter_Specifications (Parent (Candidate)))\n-           and then Etype (Result_Definition (Parent (Def_Id))) =\n-                    Etype (Result_Definition (Parent (Candidate)))\n-         then\n-            return Candidate;\n-         end if;\n-\n-         Hom := Homonym (Hom);\n-      end loop;\n-\n-      return Empty;\n-   end Overrides_Synchronized_Primitive;\n-\n    -----------------------\n    -- Private_Component --\n    -----------------------\n@@ -7628,44 +7991,27 @@ package body Sem_Util is\n       elsif Is_Tagged_Type (Typ)\n         or else Has_Controlled_Component (Typ)\n       then\n-         return True;\n+         return not Is_Value_Type (Typ);\n \n       --  Record type\n \n       elsif Is_Record_Type (Typ) then\n+         declare\n+            Comp : Entity_Id;\n+         begin\n+            Comp := First_Entity (Typ);\n+            while Present (Comp) loop\n+               if Ekind (Comp) = E_Component\n+                  and then Requires_Transient_Scope (Etype (Comp))\n+               then\n+                  return True;\n+               else\n+                  Next_Entity (Comp);\n+               end if;\n+            end loop;\n+         end;\n \n-         --  In GCC 2, discriminated records always require a transient\n-         --  scope because the back end otherwise tries to allocate a\n-         --  variable length temporary for the particular variant.\n-\n-         if Opt.GCC_Version = 2\n-           and then Has_Discriminants (Typ)\n-         then\n-            return True;\n-\n-         --  For GCC 3, or for a non-discriminated record in GCC 2, we are\n-         --  OK if none of the component types requires a transient scope.\n-         --  Note that we already know that this is a definite type (i.e.\n-         --  has discriminant defaults if it is a discriminated record).\n-\n-         else\n-            declare\n-               Comp : Entity_Id;\n-            begin\n-               Comp := First_Entity (Typ);\n-               while Present (Comp) loop\n-                  if Ekind (Comp) = E_Component\n-                     and then Requires_Transient_Scope (Etype (Comp))\n-                  then\n-                     return True;\n-                  else\n-                     Next_Entity (Comp);\n-                  end if;\n-               end loop;\n-            end;\n-\n-            return False;\n-         end if;\n+         return False;\n \n       --  String literal types never require transient scope\n \n@@ -7778,11 +8124,13 @@ package body Sem_Util is\n \n       --  Skip volatile and aliased variables, since funny things might\n       --  be going on in these cases which we cannot necessarily track.\n-      --  Also skip any variable for which an address clause is given.\n+      --  Also skip any variable for which an address clause is given,\n+      --  or whose address is taken\n \n       if Treat_As_Volatile (Ent)\n         or else Is_Aliased (Ent)\n         or else Present (Address_Clause (Ent))\n+        or else Address_Taken (Ent)\n       then\n          return False;\n       end if;\n@@ -8252,39 +8600,60 @@ package body Sem_Util is\n       Btyp : Entity_Id;\n \n    begin\n-      --  If the type is an anonymous access type we treat it as being\n-      --  declared at the library level to ensure that names such as\n-      --  X.all'access don't fail static accessibility checks.\n-\n-      --  Ada 2005 (AI-230): In case of anonymous access types that are\n-      --  component_definition or discriminants of a nonlimited type,\n-      --  the level is the same as that of the enclosing component type.\n-\n       Btyp := Base_Type (Typ);\n \n+      --  Ada 2005 (AI-230): For most cases of anonymous access types, we\n+      --  simply use the level where the type is declared. This is true for\n+      --  stand-alone object declarations, and for anonymous access types\n+      --  associated with components the level is the same as that of the\n+      --  enclosing composite type. However, special treatment is needed for\n+      --  the cases of access parameters, return objects of an anonymous access\n+      --  type, and, in Ada 95, access discriminants of limited types.\n+\n       if Ekind (Btyp) in Access_Kind then\n-         if Ekind (Btyp) = E_Anonymous_Access_Type\n-           and then not Is_Local_Anonymous_Access (Typ) -- Ada 2005 (AI-230)\n-         then\n+         if Ekind (Btyp) = E_Anonymous_Access_Type then\n+\n+            --  If the type is a nonlocal anonymous access type (such as for\n+            --  an access parameter) we treat it as being declared at the\n+            --  library level to ensure that names such as X.all'access don't\n+            --  fail static accessibility checks.\n+\n+            if not Is_Local_Anonymous_Access (Typ) then\n+               return Scope_Depth (Standard_Standard);\n \n-            --  If this is a return_subtype, the accessibility level is that\n-            --  of the result subtype of the enclosing function.\n+            --  If this is a return object, the accessibility level is that of\n+            --  the result subtype of the enclosing function. The test here is\n+            --  little complicated, because we have to account for extended\n+            --  return statements that have been rewritten as blocks, in which\n+            --  case we have to find and the Is_Return_Object attribute of the\n+            --  itype's associated object. It would be nice to find a way to\n+            --  simplify this test, but it doesn't seem worthwhile to add a new\n+            --  flag just for purposes of this test. ???\n \n-            if Ekind (Scope (Btyp)) = E_Return_Statement then\n+            elsif Ekind (Scope (Btyp)) = E_Return_Statement\n+              or else\n+                (Is_Itype (Btyp)\n+                  and then Nkind (Associated_Node_For_Itype (Btyp)) =\n+                             N_Object_Declaration\n+                  and then Is_Return_Object\n+                             (Defining_Identifier\n+                                (Associated_Node_For_Itype (Btyp))))\n+            then\n                declare\n                   Scop : Entity_Id;\n+\n                begin\n                   Scop := Scope (Scope (Btyp));\n                   while Present (Scop) loop\n                      exit when Ekind (Scop) = E_Function;\n                      Scop := Scope (Scop);\n                   end loop;\n \n-                  return Scope_Depth (Scope (Scop));\n-               end;\n+                  --  Treat the return object's type as having the level of the\n+                  --  function's result subtype (as per RM05-6.5(5.3/2)).\n \n-            else\n-               return Scope_Depth (Standard_Standard);\n+                  return Type_Access_Level (Etype (Scop));\n+               end;\n             end if;\n          end if;\n \n@@ -8295,8 +8664,8 @@ package body Sem_Util is\n          --  that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n \n          --  AI-402: access discriminants have accessibility based on the\n-         --  object rather than the type in Ada2005, so the above\n-         --  paragraph doesn't apply\n+         --  object rather than the type in Ada 2005, so the above paragraph\n+         --  doesn't apply.\n \n          --  ??? Needs completion with rules from AI-416\n "}, {"sha": "0a891326e516e45f3c3d9a2c1228dfd93e95e459", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f377c995c321326e3ec619bc4aea45fc27ce8281/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f377c995c321326e3ec619bc4aea45fc27ce8281/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f377c995c321326e3ec619bc4aea45fc27ce8281", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,7 @@\n --  Package containing utility procedures used throughout the semantics\n \n with Einfo;  use Einfo;\n+with Namet;  use Namet;\n with Types;  use Types;\n with Uintp;  use Uintp;\n with Urealp; use Urealp;\n@@ -41,6 +42,14 @@ package Sem_Util is\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n \n+   procedure Add_Global_Declaration (N : Node_Id);\n+   --  These procedures adds a declaration N at the library level, to be\n+   --  elaborated before any other code in the unit. It is used for example\n+   --  for the entity that marks whether a unit has been elaborated. The\n+   --  declaration is added to the Declarations list of the Aux_Decls_Node\n+   --  for the current unit. The declarations are added in the current scope,\n+   --  so the caller should push a new scope as required before the call.\n+\n    function Alignment_In_Bits (E : Entity_Id) return Uint;\n    --  If the alignment of the type or object E is currently known to the\n    --  compiler, then this function returns the alignment value in bits.\n@@ -120,6 +129,11 @@ package Sem_Util is\n    --  place error message on node N. Used in  object declarations, type\n    --  conversions, qualified expressions.\n \n+   procedure Check_Nested_Access (Ent : Entity_Id);\n+   --  Check whether Ent denotes an entity declared in an uplevel scope, which\n+   --  is accessed inside a nested procedure, and set Has_Up_Level_Access flag\n+   --  accordingly. This is currently only enabled for VM_Target /= No_VM.\n+\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n@@ -138,6 +152,12 @@ package Sem_Util is\n    --  directly or indirectly implemented by T. Exclude_Parent_Interfaces is\n    --  used to avoid addition of inherited interfaces to the generated list.\n \n+   procedure Collect_Interface_Components\n+     (Tagged_Type     : Entity_Id;\n+      Components_List : out Elist_Id);\n+   --  Ada 2005 (AI-251): Collect all the tag components associated with the\n+   --  secondary dispatch tables of a tagged type.\n+\n    function Collect_Primitive_Operations (T : Entity_Id) return Elist_Id;\n    --  Called upon type derivation and extension. We scan the declarative\n    --  part in  which the type appears, and collect subprograms that have\n@@ -258,6 +278,18 @@ package Sem_Util is\n    --  denotes when analyzed. Subsequent uses of this id on a different\n    --  type denote the discriminant at the same position in this new type.\n \n+   function Find_Overridden_Synchronized_Primitive\n+     (Def_Id      : Entity_Id;\n+      First_Hom   : Entity_Id;\n+      Ifaces_List : Elist_Id;\n+      In_Scope    : Boolean := True) return Entity_Id;\n+   --  Determine whether entry or subprogram Def_Id overrides a primitive\n+   --  operation that belongs to one of the interfaces in Ifaces_List. A\n+   --  specific homonym chain can be specified by setting First_Hom. Flag\n+   --  In_Scope is used to designate whether the entry or subprogram was\n+   --  declared inside the scope of the synchronized type or after. Return\n+   --  the overridden entity or Empty.\n+\n    function First_Actual (Node : Node_Id) return Node_Id;\n    --  Node is an N_Function_Call or N_Procedure_Call_Statement node. The\n    --  result returned is the first actual parameter in declaration order\n@@ -371,6 +403,12 @@ package Sem_Util is\n    --  which is the innermost visible entity with the given name. See the\n    --  body of Sem_Ch8 for further details on handling of entity visibility.\n \n+   function Get_Renamed_Entity (E : Entity_Id) return Entity_Id;\n+   --  Given an entity for an exception, package, subprogram or generic unit,\n+   --  returns the ultimately renamed entity if this is a renaming. If this is\n+   --  not a renamed entity, returns its argument. It is an error to call this\n+   --  with any any other kind of entity.\n+\n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or\n    --  an accept statement node. This procedure finds the Entity_Id of the\n@@ -524,6 +562,10 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense\n    --  of the legality checks described in RM C.6(12).\n \n+   function Is_Coextension_Root (N : Node_Id) return Boolean;\n+   --  Determine whether node N is an allocator which acts as a coextension\n+   --  root.\n+\n    function Is_Controlling_Limited_Procedure\n      (Proc_Nam : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-345): Determine whether Proc_Nam is a primitive procedure\n@@ -657,6 +699,12 @@ package Sem_Util is\n    --  Boolean operand (i.e. is either 0 for False, or 1 for True). This\n    --  function simply tests if it is True (i.e. non-zero)\n \n+   function Is_Value_Type (T : Entity_Id) return Boolean;\n+   --  Returns true if type T represents a value type. This is only relevant to\n+   --  CIL, will always return false for other targets.\n+   --  What is a \"value type\", since this is not an Ada term, it should be\n+   --  defined here ???\n+\n    function Is_Variable (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents a variable, i.e.\n    --  can appear on the left side of an assignment. There is one situation,\n@@ -705,6 +753,11 @@ package Sem_Util is\n    --  direction. Cases which may possibly be assignments but are not known to\n    --  be may return True from May_Be_Lvalue, but False from this function.\n \n+   procedure Mark_Static_Coextensions (Root_Node : Node_Id);\n+   --  Perform a tree traversal starting from Root_Node while marking every\n+   --  allocator as a static coextension. Cleanup for this action is performed\n+   --  in Resolve_Allocator.\n+\n    function May_Be_Lvalue (N : Node_Id) return Boolean;\n    --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n    --  An lvalue is defined as any expression which appears in a context where\n@@ -783,18 +836,6 @@ package Sem_Util is\n    --  For convenience, qualified expressions applied to object names\n    --  are also allowed as actuals for this function.\n \n-   function Overrides_Synchronized_Primitive\n-     (Def_Id      : Entity_Id;\n-      First_Hom   : Entity_Id;\n-      Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean := True) return Entity_Id;\n-   --  Determine whether entry or subprogram Def_Id overrides a primitive\n-   --  operation that belongs to one of the interfaces in Ifaces_List. A\n-   --  specific homonym chain can be specified by setting First_Hom. Flag\n-   --  In_Scope is used to designate whether the entry or subprogram was\n-   --  declared inside the scope of the synchronized type or after. Return\n-   --  the overriden entity or Empty.\n-\n    function Private_Component (Type_Id : Entity_Id) return Entity_Id;\n    --  Returns some private component (if any) of the given Type_Id.\n    --  Used to enforce the rules on visibility of operations on composite"}]}