{"sha": "28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlZDA2NWVmOWYzNDUwYzVjN2Y3ZmU1M2EzYWZmNjZjMTcyMWE2ZA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-09-02T21:13:34Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-09-02T21:13:34Z"}, "message": "expr.h (emit_storent_insn, [...]): Declare.\n\n\t* expr.h (emit_storent_insn, expand_expr_real_1,\n\texpand_expr_real_2): Declare.\n\t* expr.c (emit_storent_insn, expand_expr_real_1,\n\texpand_expr_real_2): Export.\n\t(store_expr): Setting and evaluating dont_return_target is\n\tuseless.\n\t(expand_expr_real_1, <case GOTO_EXPR, RETURN_EXPR, SWITCH_EXPR,\n\tLABEL_EXPR and ASM_EXPR>): Move to gcc_unreachable.\n\t* except.c (expand_resx_expr): Rename to ...\n\t(expand_resx_stmt): ... this.  Rewrite to take gimple statement.\n\t* except.h (expand_resx_stmt): Declare.\n\t* stmt.c: Add include gimple.h\n\t(expand_asm_expr): Rename to ...\n\t(expand_asm_stmt): ... this. Rewrite to take gimple statement.\n\t(expand_case): Rewrite to take gimple statement.\n\t* tree.h (expand_asm_stmt): Declare.\n\t(expand_case): Change prototype.\n\t* Makefile.in (stmt.o): Depend on gimple.h.\n\t* builtins.c (expand_builtin_synchronize): Build gimple asm\n\tstatement, not an ASM_EXPR.\n\t* cfgexpand.c (gimple_cond_pred_to_tree, set_expr_location_r,\n\tgimple_to_tree, release_stmt_tree): Remove.\n\t(expand_gimple_cond): Don't call gimple_cond_pred_to_tree or\n\tggc_free, but hold comparison code and operands separately.\n\tCall jumpif_1 and jumpifnot_1 instead of jumpif and jumpifnot.\n\t(expand_call_stmt, expand_gimple_stmt_1,\n\texpand_gimple_stmt): New helpers.\n\t(expand_gimple_tailcall): Don't call gimple_to_tree, expand_expr_stmt,\n\trelease_stmt_tree.  Call expand_gimple_stmt instead.\n\t(expand_gimple_basic_block): Ditto.\n\n\t* calls.c (emit_call_1): Don't look at EH regions here, make\n\tfntree parameter useless.\n\t(expand_call): New local rettype for TREE_TYPE(exp), use it\n\tthroughout.  Remove local p, use addr instead.\n\tDon't look at EH regions here.\n\nFrom-SVN: r151350", "tree": {"sha": "dcf22487df72f428cf2839f64e5d177bc055f7b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf22487df72f428cf2839f64e5d177bc055f7b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f6924a4846fdb6e9fb51c5fca7d0f7e6336145d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6924a4846fdb6e9fb51c5fca7d0f7e6336145d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6924a4846fdb6e9fb51c5fca7d0f7e6336145d"}], "stats": {"total": 943, "additions": 464, "deletions": 479}, "files": [{"sha": "fce97535542ad62f03bdebbc687e7fea306b5aab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -1,3 +1,42 @@\n+2009-09-01  Michael Matz  <matz@suse.de>\n+\n+\t* expr.h (emit_storent_insn, expand_expr_real_1,\n+\texpand_expr_real_2): Declare.\n+\t* expr.c (emit_storent_insn, expand_expr_real_1,\n+\texpand_expr_real_2): Export.\n+\t(store_expr): Setting and evaluating dont_return_target is\n+\tuseless.\n+\t(expand_expr_real_1, <case GOTO_EXPR, RETURN_EXPR, SWITCH_EXPR,\n+\tLABEL_EXPR and ASM_EXPR>): Move to gcc_unreachable.\n+\t* except.c (expand_resx_expr): Rename to ...\n+\t(expand_resx_stmt): ... this.  Rewrite to take gimple statement.\n+\t* except.h (expand_resx_stmt): Declare.\n+\t* stmt.c: Add include gimple.h\n+\t(expand_asm_expr): Rename to ...\n+\t(expand_asm_stmt): ... this. Rewrite to take gimple statement.\n+\t(expand_case): Rewrite to take gimple statement.\n+\t* tree.h (expand_asm_stmt): Declare.\n+\t(expand_case): Change prototype.\n+\t* Makefile.in (stmt.o): Depend on gimple.h.\n+\t* builtins.c (expand_builtin_synchronize): Build gimple asm\n+\tstatement, not an ASM_EXPR.\n+\t* cfgexpand.c (gimple_cond_pred_to_tree, set_expr_location_r,\n+\tgimple_to_tree, release_stmt_tree): Remove.\n+\t(expand_gimple_cond): Don't call gimple_cond_pred_to_tree or\n+\tggc_free, but hold comparison code and operands separately.\n+\tCall jumpif_1 and jumpifnot_1 instead of jumpif and jumpifnot.\n+\t(expand_call_stmt, expand_gimple_stmt_1,\n+\texpand_gimple_stmt): New helpers.\n+\t(expand_gimple_tailcall): Don't call gimple_to_tree, expand_expr_stmt,\n+\trelease_stmt_tree.  Call expand_gimple_stmt instead.\n+\t(expand_gimple_basic_block): Ditto.\n+\n+\t* calls.c (emit_call_1): Don't look at EH regions here, make\n+\tfntree parameter useless.\n+\t(expand_call): New local rettype for TREE_TYPE(exp), use it\n+\tthroughout.  Remove local p, use addr instead.\n+\tDon't look at EH regions here.\n+\n 2009-09-02  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* doc/invoke.texi (-fsched-pressure): Document it."}, {"sha": "53c7ffed1b699e2c23686772a33636567e91008d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -2284,7 +2284,7 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n    $(CFGLOOP_H) alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) \\\n    $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \\\n-   $(DBGCNT_H)\n+   $(DBGCNT_H) tree-scalar-evolution.h\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(CFGLOOP_H) \\\n@@ -2675,7 +2675,7 @@ statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) insn-config.h hard-reg-set.h $(EXPR_H) \\\n    libfuncs.h $(EXCEPT_H) $(RECOG_H) $(TOPLEV_H) output.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H) $(MACHMODE_H) \\\n+   langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H) gimple.h $(MACHMODE_H) \\\n    $(REGS_H) alloc-pool.h\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXCEPT_H) $(FUNCTION_H) $(EXPR_H) libfuncs.h \\"}, {"sha": "d4801b14e55dc06a8fc0b43f1199b04a5cb5a327", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -6235,7 +6235,7 @@ expand_builtin_lock_test_and_set (enum machine_mode mode, tree exp,\n static void\n expand_builtin_synchronize (void)\n {\n-  tree x;\n+  gimple x;\n \n #ifdef HAVE_memory_barrier\n   if (HAVE_memory_barrier)\n@@ -6253,10 +6253,10 @@ expand_builtin_synchronize (void)\n \n   /* If no explicit memory barrier instruction is available, create an\n      empty asm stmt with a memory clobber.  */\n-  x = build4 (ASM_EXPR, void_type_node, build_string (0, \"\"), NULL, NULL,\n-\t      tree_cons (NULL, build_string (6, \"memory\"), NULL));\n-  ASM_VOLATILE_P (x) = 1;\n-  expand_asm_expr (x);\n+  x = gimple_build_asm (\"\", 0, 0, 1,\n+\t\t\ttree_cons (NULL, build_string (6, \"memory\"), NULL));\n+  gimple_asm_set_volatile (x, true);\n+  expand_asm_stmt (x);\n }\n \n /* Expand the __sync_lock_release intrinsic.  EXP is the CALL_EXPR.  */"}, {"sha": "20639098e02b3d7f68fde549a10627335b02f3e2", "filename": "gcc/calls.c", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -238,7 +238,7 @@ prepare_call_address (rtx funexp, rtx static_chain_value,\n    denote registers used by the called function.  */\n \n static void\n-emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n+emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNUSED,\n \t     tree funtype ATTRIBUTE_UNUSED,\n \t     HOST_WIDE_INT stack_size ATTRIBUTE_UNUSED,\n \t     HOST_WIDE_INT rounded_stack_size,\n@@ -380,15 +380,6 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n      effect.  */\n   if (ecf_flags & ECF_NOTHROW)\n     add_reg_note (call_insn, REG_EH_REGION, const0_rtx);\n-  else\n-    {\n-      int rn = lookup_expr_eh_region (fntree);\n-\n-      /* If rn < 0, then either (1) tree-ssa not used or (2) doesn't\n-\t throw, which we already took care of.  */\n-      if (rn > 0)\n-\tadd_reg_note (call_insn, REG_EH_REGION, GEN_INT (rn));\n-    }\n \n   if (ecf_flags & ECF_NORETURN)\n     add_reg_note (call_insn, REG_NORETURN, const0_rtx);\n@@ -1927,6 +1918,7 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Data type of the function.  */\n   tree funtype;\n   tree type_arg_types;\n+  tree rettype;\n   /* Declaration of the function being called,\n      or 0 if the function is computed (not known by name).  */\n   tree fndecl = 0;\n@@ -2022,7 +2014,6 @@ expand_call (tree exp, rtx target, int ignore)\n   int old_stack_pointer_delta = 0;\n \n   rtx call_fusage;\n-  tree p = CALL_EXPR_FN (exp);\n   tree addr = CALL_EXPR_FN (exp);\n   int i;\n   /* The alignment of the stack, in bits.  */\n@@ -2045,15 +2036,16 @@ expand_call (tree exp, rtx target, int ignore)\n     }\n   else\n     {\n-      fntype = TREE_TYPE (TREE_TYPE (p));\n+      fntype = TREE_TYPE (TREE_TYPE (addr));\n       flags |= flags_from_decl_or_type (fntype);\n     }\n+  rettype = TREE_TYPE (exp);\n \n   struct_value = targetm.calls.struct_value_rtx (fntype, 0);\n \n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n-  if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+  if (AGGREGATE_TYPE_P (rettype))\n     warning (OPT_Waggregate_return, \"function call has aggregate value\");\n \n   /* If the result of a non looping pure or const function call is\n@@ -2063,7 +2055,7 @@ expand_call (tree exp, rtx target, int ignore)\n   if ((flags & (ECF_CONST | ECF_PURE))\n       && (!(flags & ECF_LOOPING_CONST_OR_PURE))\n       && (ignore || target == const0_rtx\n-\t  || TYPE_MODE (TREE_TYPE (exp)) == VOIDmode))\n+\t  || TYPE_MODE (rettype) == VOIDmode))\n     {\n       bool volatilep = false;\n       tree arg;\n@@ -2106,7 +2098,7 @@ expand_call (tree exp, rtx target, int ignore)\n       }\n #else /* not PCC_STATIC_STRUCT_RETURN */\n       {\n-\tstruct_value_size = int_size_in_bytes (TREE_TYPE (exp));\n+\tstruct_value_size = int_size_in_bytes (rettype);\n \n \tif (target && MEM_P (target) && CALL_EXPR_RETURN_SLOT_OPT (exp))\n \t  structure_value_addr = XEXP (target, 0);\n@@ -2115,7 +2107,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    /* For variable-sized objects, we must be called with a target\n \t       specified.  If we were to allocate space on the stack here,\n \t       we would have no way of knowing when to free it.  */\n-\t    rtx d = assign_temp (TREE_TYPE (exp), 0, 1, 1);\n+\t    rtx d = assign_temp (rettype, 0, 1, 1);\n \n \t    mark_temp_addr_taken (d);\n \t    structure_value_addr = XEXP (d, 0);\n@@ -2286,7 +2278,6 @@ expand_call (tree exp, rtx target, int ignore)\n   if (currently_expanding_call++ != 0\n       || !flag_optimize_sibling_calls\n       || args_size.var\n-      || lookup_expr_eh_region (exp) >= 0\n       || dbg_cnt (tail_call) == false)\n     try_tail_call = 0;\n \n@@ -2693,14 +2684,14 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* Figure out the register where the value, if any, will come back.  */\n       valreg = 0;\n-      if (TYPE_MODE (TREE_TYPE (exp)) != VOIDmode\n+      if (TYPE_MODE (rettype) != VOIDmode\n \t  && ! structure_value_addr)\n \t{\n \t  if (pcc_struct_value)\n-\t    valreg = hard_function_value (build_pointer_type (TREE_TYPE (exp)),\n+\t    valreg = hard_function_value (build_pointer_type (rettype),\n \t\t\t\t\t  fndecl, NULL, (pass == 0));\n \t  else\n-\t    valreg = hard_function_value (TREE_TYPE (exp), fndecl, fntype,\n+\t    valreg = hard_function_value (rettype, fndecl, fntype,\n \t\t\t\t\t  (pass == 0));\n \n \t  /* If VALREG is a PARALLEL whose first member has a zero\n@@ -2865,12 +2856,12 @@ expand_call (tree exp, rtx target, int ignore)\n \t group load/store machinery below.  */\n       if (!structure_value_addr\n \t  && !pcc_struct_value\n-\t  && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n-\t  && targetm.calls.return_in_msb (TREE_TYPE (exp)))\n+\t  && TYPE_MODE (rettype) != BLKmode\n+\t  && targetm.calls.return_in_msb (rettype))\n \t{\n-\t  if (shift_return_value (TYPE_MODE (TREE_TYPE (exp)), false, valreg))\n+\t  if (shift_return_value (TYPE_MODE (rettype), false, valreg))\n \t    sibcall_failure = 1;\n-\t  valreg = gen_rtx_REG (TYPE_MODE (TREE_TYPE (exp)), REGNO (valreg));\n+\t  valreg = gen_rtx_REG (TYPE_MODE (rettype), REGNO (valreg));\n \t}\n \n       if (pass && (flags & ECF_MALLOC))\n@@ -2879,7 +2870,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  rtx last, insns;\n \n \t  /* The return value from a malloc-like function is a pointer.  */\n-\t  if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n+\t  if (TREE_CODE (rettype) == POINTER_TYPE)\n \t    mark_reg_pointer (temp, BIGGEST_ALIGNMENT);\n \n \t  emit_move_insn (temp, valreg);\n@@ -2929,28 +2920,28 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* If value type not void, return an rtx for the value.  */\n \n-      if (TYPE_MODE (TREE_TYPE (exp)) == VOIDmode\n+      if (TYPE_MODE (rettype) == VOIDmode\n \t  || ignore)\n \ttarget = const0_rtx;\n       else if (structure_value_addr)\n \t{\n \t  if (target == 0 || !MEM_P (target))\n \t    {\n \t      target\n-\t\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t       memory_address (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t= gen_rtx_MEM (TYPE_MODE (rettype),\n+\t\t\t       memory_address (TYPE_MODE (rettype),\n \t\t\t\t\t       structure_value_addr));\n-\t      set_mem_attributes (target, exp, 1);\n+\t      set_mem_attributes (target, rettype, 1);\n \t    }\n \t}\n       else if (pcc_struct_value)\n \t{\n \t  /* This is the special C++ case where we need to\n \t     know what the true target was.  We take care to\n \t     never use this value more than once in one expression.  */\n-\t  target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n+\t  target = gen_rtx_MEM (TYPE_MODE (rettype),\n \t\t\t\tcopy_to_reg (valreg));\n-\t  set_mem_attributes (target, exp, 1);\n+\t  set_mem_attributes (target, rettype, 1);\n \t}\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n@@ -2959,22 +2950,22 @@ expand_call (tree exp, rtx target, int ignore)\n \t  if (target == 0)\n \t    {\n \t      /* This will only be assigned once, so it can be readonly.  */\n-\t      tree nt = build_qualified_type (TREE_TYPE (exp),\n-\t\t\t\t\t      (TYPE_QUALS (TREE_TYPE (exp))\n+\t      tree nt = build_qualified_type (rettype,\n+\t\t\t\t\t      (TYPE_QUALS (rettype)\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \n \t      target = assign_temp (nt, 0, 1, 1);\n \t    }\n \n \t  if (! rtx_equal_p (target, valreg))\n-\t    emit_group_store (target, valreg, TREE_TYPE (exp),\n-\t\t\t      int_size_in_bytes (TREE_TYPE (exp)));\n+\t    emit_group_store (target, valreg, rettype,\n+\t\t\t      int_size_in_bytes (rettype));\n \n \t  /* We can not support sibling calls for this case.  */\n \t  sibcall_failure = 1;\n \t}\n       else if (target\n-\t       && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp))\n+\t       && GET_MODE (target) == TYPE_MODE (rettype)\n \t       && GET_MODE (target) == GET_MODE (valreg))\n \t{\n \t  bool may_overlap = false;\n@@ -3019,9 +3010,9 @@ expand_call (tree exp, rtx target, int ignore)\n \t\tsibcall_failure = 1;\n \t    }\n \t}\n-      else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n+      else if (TYPE_MODE (rettype) == BLKmode)\n \t{\n-\t  target = copy_blkmode_from_reg (target, valreg, TREE_TYPE (exp));\n+\t  target = copy_blkmode_from_reg (target, valreg, rettype);\n \n \t  /* We can not support sibling calls for this case.  */\n \t  sibcall_failure = 1;\n@@ -3032,10 +3023,10 @@ expand_call (tree exp, rtx target, int ignore)\n       /* If we promoted this return value, make the proper SUBREG.\n          TARGET might be const0_rtx here, so be careful.  */\n       if (REG_P (target)\n-\t  && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n-\t  && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n+\t  && TYPE_MODE (rettype) != BLKmode\n+\t  && GET_MODE (target) != TYPE_MODE (rettype))\n \t{\n-\t  tree type = TREE_TYPE (exp);\n+\t  tree type = rettype;\n \t  int unsignedp = TYPE_UNSIGNED (type);\n \t  int offset = 0;\n \t  enum machine_mode pmode;"}, {"sha": "e840da88bcf3d91bc4404d6f98c59971ed560685", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 301, "deletions": 342, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -86,326 +86,6 @@ gimple_assign_rhs_to_tree (gimple stmt)\n   return t;\n }\n \n-/* Return an expression tree corresponding to the PREDICATE of GIMPLE_COND\n-   statement STMT.  */\n-\n-static tree\n-gimple_cond_pred_to_tree (gimple stmt)\n-{\n-  /* We're sometimes presented with such code:\n-       D.123_1 = x < y;\n-       if (D.123_1 != 0)\n-         ...\n-     This would expand to two comparisons which then later might\n-     be cleaned up by combine.  But some pattern matchers like if-conversion\n-     work better when there's only one compare, so make up for this\n-     here as special exception if TER would have made the same change.  */\n-  tree lhs = gimple_cond_lhs (stmt);\n-  if (SA.values\n-      && TREE_CODE (lhs) == SSA_NAME\n-      && bitmap_bit_p (SA.values, SSA_NAME_VERSION (lhs)))\n-    lhs = gimple_assign_rhs_to_tree (SSA_NAME_DEF_STMT (lhs));\n-\n-  return build2 (gimple_cond_code (stmt), boolean_type_node,\n-\t\t lhs, gimple_cond_rhs (stmt));\n-}\n-\n-/* Helper for gimple_to_tree.  Set EXPR_LOCATION for every expression\n-   inside *TP.  DATA is the location to set.  */\n-\n-static tree\n-set_expr_location_r (tree *tp, int *ws ATTRIBUTE_UNUSED, void *data)\n-{\n-  location_t *loc = (location_t *) data;\n-  if (EXPR_P (*tp))\n-    SET_EXPR_LOCATION (*tp, *loc);\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* RTL expansion has traditionally been done on trees, so the\n-   transition to doing it on GIMPLE tuples is very invasive to the RTL\n-   expander.  To facilitate the transition, this function takes a\n-   GIMPLE tuple STMT and returns the same statement in the form of a\n-   tree.  */\n-\n-static tree\n-gimple_to_tree (gimple stmt)\n-{\n-  tree t;\n-  int rn;\n-  tree_ann_common_t ann;\n-  location_t loc;\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      {\n-\ttree lhs = gimple_assign_lhs (stmt);\n-\n-\tt = gimple_assign_rhs_to_tree (stmt);\n-\tt = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, t);\n-\tif (gimple_assign_nontemporal_move_p (stmt))\n-\t  MOVE_NONTEMPORAL (t) = true;\n-      }\n-      break;\n-\t                                 \n-    case GIMPLE_COND:\n-      t = gimple_cond_pred_to_tree (stmt);\n-      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-      break;\n-\n-    case GIMPLE_GOTO:\n-      t = build1 (GOTO_EXPR, void_type_node, gimple_goto_dest (stmt));\n-      break;\n-\n-    case GIMPLE_LABEL:\n-      t = build1 (LABEL_EXPR, void_type_node, gimple_label_label (stmt));\n-      break;\n-\n-    case GIMPLE_RETURN:\n-      {\n-\ttree retval = gimple_return_retval (stmt);\n-\n-\tif (retval && retval != error_mark_node)\n-\t  {\n-\t    tree result = DECL_RESULT (current_function_decl);\n-\n-\t    /* If we are not returning the current function's RESULT_DECL,\n-\t       build an assignment to it.  */\n-\t    if (retval != result)\n-\t      {\n-\t\t/* I believe that a function's RESULT_DECL is unique.  */\n-\t\tgcc_assert (TREE_CODE (retval) != RESULT_DECL);\n-\n-\t\tretval = build2 (MODIFY_EXPR, TREE_TYPE (result),\n-\t\t\t\t result, retval);\n-\t      }\n-\t  }\n-\tt = build1 (RETURN_EXPR, void_type_node, retval);\n-      }\n-      break;\n-\n-    case GIMPLE_ASM:\n-      {\n-\tsize_t i, n;\n-\ttree out, in, cl;\n-\tconst char *s;\n-\n-\tout = NULL_TREE;\n-\tn = gimple_asm_noutputs (stmt);\n-\tif (n > 0)\n-\t  {\n-\t    t = out = gimple_asm_output_op (stmt, 0);\n-\t    for (i = 1; i < n; i++)\n-\t      {\n-\t\tTREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n-\t\tt = gimple_asm_output_op (stmt, i);\n-\t      }\n-\t  }\n-\n-\tin = NULL_TREE;\n-\tn = gimple_asm_ninputs (stmt);\n-\tif (n > 0)\n-\t  {\n-\t    t = in = gimple_asm_input_op (stmt, 0);\n-\t    for (i = 1; i < n; i++)\n-\t      {\n-\t\tTREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n-\t\tt = gimple_asm_input_op (stmt, i);\n-\t      }\n-\t  }\n-\n-\tcl = NULL_TREE;\n-\tn = gimple_asm_nclobbers (stmt);\n-\tif (n > 0)\n-\t  {\n-\t    t = cl = gimple_asm_clobber_op (stmt, 0);\n-\t    for (i = 1; i < n; i++)\n-\t      {\n-\t\tTREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n-\t\tt = gimple_asm_clobber_op (stmt, i);\n-\t      }\n-\t  }\n-\n-\ts = gimple_asm_string (stmt);\n-\tt = build4 (ASM_EXPR, void_type_node, build_string (strlen (s), s),\n-\t            out, in, cl);\n-        ASM_VOLATILE_P (t) = gimple_asm_volatile_p (stmt);\n-        ASM_INPUT_P (t) = gimple_asm_input_p (stmt);\n-      }\n-    break;\n-\n-    case GIMPLE_CALL:\n-      {\n-\tsize_t i;\n-        tree fn;\n-\ttree_ann_common_t ann;\n-        \n-\tt = build_vl_exp (CALL_EXPR, gimple_call_num_args (stmt) + 3);\n-\n-        CALL_EXPR_FN (t) = gimple_call_fn (stmt);\n-        TREE_TYPE (t) = gimple_call_return_type (stmt);\n-\tCALL_EXPR_STATIC_CHAIN (t) = gimple_call_chain (stmt);\n-\n-\tfor (i = 0; i < gimple_call_num_args (stmt); i++)\n-\t  CALL_EXPR_ARG (t, i) = gimple_call_arg (stmt, i);\n-\n-\tif (!(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\n-\tif (gimple_call_flags (stmt) & ECF_NOTHROW)\n-\t  TREE_NOTHROW (t) = 1;\n-\n-        CALL_EXPR_TAILCALL (t) = gimple_call_tail_p (stmt);\n-        CALL_EXPR_RETURN_SLOT_OPT (t) = gimple_call_return_slot_opt_p (stmt);\n-        CALL_FROM_THUNK_P (t) = gimple_call_from_thunk_p (stmt);\n-        CALL_CANNOT_INLINE_P (t) = gimple_call_cannot_inline_p (stmt);\n-        CALL_EXPR_VA_ARG_PACK (t) = gimple_call_va_arg_pack_p (stmt);\n-\n-        /* If the call has a LHS then create a MODIFY_EXPR to hold it.  */\n-\t{\n-\t  tree lhs = gimple_call_lhs (stmt);\n-\n-\t  if (lhs)\n-\t    t = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, t);\n-\t}\n-\n-        /* Record the original call statement, as it may be used\n-           to retrieve profile information during expansion.  */\n-\n-\tif ((fn = gimple_call_fndecl (stmt)) != NULL_TREE\n-\t    && DECL_BUILT_IN (fn))\n-\t  {\n-\t    ann = get_tree_common_ann (t);\n-\t    ann->stmt = stmt;\n-\t  }\n-      }\n-    break;\n-\n-    case GIMPLE_SWITCH:\n-      {\n-\ttree label_vec;\n-\tsize_t i;\n-\ttree elt = gimple_switch_label (stmt, 0);\n-\n-\tlabel_vec = make_tree_vec (gimple_switch_num_labels (stmt));\n-\n-\tif (!CASE_LOW (elt) && !CASE_HIGH (elt))\n-\t  {\n-\t    for (i = 1; i < gimple_switch_num_labels (stmt); i++)\n-\t      TREE_VEC_ELT (label_vec, i - 1) = gimple_switch_label (stmt, i);\n-\n-\t    /* The default case in a SWITCH_EXPR must be at the end of\n-\t       the label vector.  */\n-\t    TREE_VEC_ELT (label_vec, i - 1) = gimple_switch_label (stmt, 0);\n-\t  }\n-\telse\n-\t  {\n-\t    for (i = 0; i < gimple_switch_num_labels (stmt); i++)\n-\t      TREE_VEC_ELT (label_vec, i) = gimple_switch_label (stmt, i);\n-\t  }\n-\n-\tt = build3 (SWITCH_EXPR, void_type_node, gimple_switch_index (stmt),\n-\t\t    NULL, label_vec);\n-      }\n-    break;\n-\n-    case GIMPLE_NOP:\n-    case GIMPLE_PREDICT:\n-      t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n-      break;\n-\n-    case GIMPLE_RESX:\n-      t = build_resx (gimple_resx_region (stmt));\n-      break;\n-\t\n-    default:\n-      if (errorcount == 0)\n-\t{\n-\t  error (\"Unrecognized GIMPLE statement during RTL expansion\");\n-\t  print_gimple_stmt (stderr, stmt, 4, 0);\n-\t  gcc_unreachable ();\n-\t}\n-      else\n-\t{\n-\t  /* Ignore any bad gimple codes if we're going to die anyhow,\n-\t     so we can at least set TREE_ASM_WRITTEN and have the rest\n-\t     of compilation advance without sudden ICE death.  */\n-\t  t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n-\t  break;\n-\t}\n-    }\n-\n-  /* If STMT is inside an exception region, record it in the generated\n-     expression.  */\n-  rn = lookup_stmt_eh_region (stmt);\n-  if (rn >= 0)\n-    {\n-      tree call = get_call_expr_in (t);\n-\n-      ann = get_tree_common_ann (t);\n-      ann->rn = rn;\n-      \n-      /* For a CALL_EXPR on the RHS of an assignment, calls.c looks up\n- \t the CALL_EXPR not the assignment statment for EH region number. */\n-      if (call && call != t)\n-\t{\n-\t  ann = get_tree_common_ann (call);\n-\t  ann->rn = rn;\n-\t}\n-    }\n-\n-  /* Set EXPR_LOCATION in all the embedded expressions.  */\n-  loc = gimple_location (stmt);\n-  walk_tree (&t, set_expr_location_r, (void *) &loc, NULL);\n-\n-  TREE_BLOCK (t) = gimple_block (stmt);\n-\n-  return t;\n-}\n-\n-\n-/* Release back to GC memory allocated by gimple_to_tree.  */\n-\n-static void\n-release_stmt_tree (gimple stmt, tree stmt_tree)\n-{\n-  tree_ann_common_t ann;\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      if (get_gimple_rhs_class (gimple_expr_code (stmt)) != GIMPLE_SINGLE_RHS)\n-\tggc_free (TREE_OPERAND (stmt_tree, 1));\n-      break;\n-    case GIMPLE_COND:\n-      ggc_free (COND_EXPR_COND (stmt_tree));\n-      break;\n-    case GIMPLE_RETURN:\n-      if (TREE_OPERAND (stmt_tree, 0)\n-\t  && TREE_CODE (TREE_OPERAND (stmt_tree, 0)) == MODIFY_EXPR)\n-\tggc_free (TREE_OPERAND (stmt_tree, 0));\n-      break;\n-    case GIMPLE_CALL:\n-      if (gimple_call_lhs (stmt))\n-\t{\n-\t  ann = tree_common_ann (TREE_OPERAND (stmt_tree, 1));\n-\t  if (ann)\n-\t    ggc_free (ann);\n-\t  ggc_free (TREE_OPERAND (stmt_tree, 1));\n-\t}\n-      break;\n-    default:\n-      break;\n-    }\n-  ann = tree_common_ann (stmt_tree);\n-  if (ann)\n-    ggc_free (ann);\n-  ggc_free (stmt_tree);\n-}\n-\n \n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n@@ -1935,7 +1615,6 @@ maybe_cleanup_end_of_block (edge e)\n     }\n }\n \n-\n /* A subroutine of expand_gimple_basic_block.  Expand one GIMPLE_COND.\n    Returns a new basic block if we've terminated the current basic\n    block and created a new one.  */\n@@ -1947,8 +1626,36 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n   edge new_edge;\n   edge true_edge;\n   edge false_edge;\n-  tree pred = gimple_cond_pred_to_tree (stmt);\n   rtx last2, last;\n+  enum tree_code code;\n+  tree op0, op1;\n+\n+  code = gimple_cond_code (stmt);\n+  op0 = gimple_cond_lhs (stmt);\n+  op1 = gimple_cond_rhs (stmt);\n+  /* We're sometimes presented with such code:\n+       D.123_1 = x < y;\n+       if (D.123_1 != 0)\n+         ...\n+     This would expand to two comparisons which then later might\n+     be cleaned up by combine.  But some pattern matchers like if-conversion\n+     work better when there's only one compare, so make up for this\n+     here as special exception if TER would have made the same change.  */\n+  if (gimple_cond_single_var_p (stmt)\n+      && SA.values\n+      && TREE_CODE (op0) == SSA_NAME\n+      && bitmap_bit_p (SA.values, SSA_NAME_VERSION (op0)))\n+    {\n+      gimple second = SSA_NAME_DEF_STMT (op0);\n+      if (gimple_code (second) == GIMPLE_ASSIGN\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (second))\n+\t     == tcc_comparison)\n+\t{\n+\t  code = gimple_assign_rhs_code (second);\n+\t  op0 = gimple_assign_rhs1 (second);\n+\t  op1 = gimple_assign_rhs2 (second);\n+\t}\n+    }\n \n   last2 = last = get_last_insn ();\n \n@@ -1967,7 +1674,7 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n      two-way jump that needs to be decomposed into two basic blocks.  */\n   if (false_edge->dest == bb->next_bb)\n     {\n-      jumpif (pred, label_rtx_for_bb (true_edge->dest));\n+      jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest));\n       add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (true_edge->goto_locus)\n@@ -1978,13 +1685,12 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n \t}\n       true_edge->goto_block = NULL;\n       false_edge->flags |= EDGE_FALLTHRU;\n-      ggc_free (pred);\n       maybe_cleanup_end_of_block (false_edge);\n       return NULL;\n     }\n   if (true_edge->dest == bb->next_bb)\n     {\n-      jumpifnot (pred, label_rtx_for_bb (false_edge->dest));\n+      jumpifnot_1 (code, op0, op1, label_rtx_for_bb (false_edge->dest));\n       add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (false_edge->goto_locus)\n@@ -1995,12 +1701,11 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n \t}\n       false_edge->goto_block = NULL;\n       true_edge->flags |= EDGE_FALLTHRU;\n-      ggc_free (pred);\n       maybe_cleanup_end_of_block (true_edge);\n       return NULL;\n     }\n \n-  jumpif (pred, label_rtx_for_bb (true_edge->dest));\n+  jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest));\n   add_reg_br_prob_note (last, true_edge->probability);\n   last = get_last_insn ();\n   if (false_edge->goto_locus)\n@@ -2040,10 +1745,275 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n     }\n   true_edge->goto_block = NULL;\n \n-  ggc_free (pred);\n   return new_bb;\n }\n \n+/* A subroutine of expand_gimple_stmt_1, expanding one GIMPLE_CALL\n+   statement STMT.  */\n+\n+static void\n+expand_call_stmt (gimple stmt)\n+{\n+  tree exp;\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  size_t i;\n+\n+  exp = build_vl_exp (CALL_EXPR, gimple_call_num_args (stmt) + 3);\n+\n+  CALL_EXPR_FN (exp) = gimple_call_fn (stmt);\n+  TREE_TYPE (exp) = gimple_call_return_type (stmt);\n+  CALL_EXPR_STATIC_CHAIN (exp) = gimple_call_chain (stmt);\n+\n+  for (i = 0; i < gimple_call_num_args (stmt); i++)\n+    CALL_EXPR_ARG (exp, i) = gimple_call_arg (stmt, i);\n+\n+  if (!(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n+    TREE_SIDE_EFFECTS (exp) = 1;\n+\n+  if (gimple_call_flags (stmt) & ECF_NOTHROW)\n+    TREE_NOTHROW (exp) = 1;\n+\n+  CALL_EXPR_TAILCALL (exp) = gimple_call_tail_p (stmt);\n+  CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);\n+  CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n+  CALL_CANNOT_INLINE_P (exp) = gimple_call_cannot_inline_p (stmt);\n+  CALL_EXPR_VA_ARG_PACK (exp) = gimple_call_va_arg_pack_p (stmt);\n+  SET_EXPR_LOCATION (exp, gimple_location (stmt));\n+  TREE_BLOCK (exp) = gimple_block (stmt);\n+\n+  /* Record the original call statement, as it may be used\n+     to retrieve profile information during expansion.  */\n+\n+  if (fndecl && DECL_BUILT_IN (fndecl))\n+    {\n+      tree_ann_common_t ann = get_tree_common_ann (exp);\n+      ann->stmt = stmt;\n+    }\n+\n+  if (lhs)\n+    expand_assignment (lhs, exp, false);\n+  else\n+    expand_expr_real_1 (exp, const0_rtx, VOIDmode, EXPAND_NORMAL, NULL);\n+}\n+\n+/* A subroutine of expand_gimple_stmt, expanding one gimple statement\n+   STMT that doesn't require special handling for outgoing edges.  That\n+   is no tailcalls and no GIMPLE_COND.  */\n+\n+static void\n+expand_gimple_stmt_1 (gimple stmt)\n+{\n+  tree op0;\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_GOTO:\n+      op0 = gimple_goto_dest (stmt);\n+      if (TREE_CODE (op0) == LABEL_DECL)\n+\texpand_goto (op0);\n+      else\n+\texpand_computed_goto (op0);\n+      break;\n+    case GIMPLE_LABEL:\n+      expand_label (gimple_label_label (stmt));\n+      break;\n+    case GIMPLE_NOP:\n+    case GIMPLE_PREDICT:\n+      break;\n+    case GIMPLE_RESX:\n+      expand_resx_stmt (stmt);\n+      break;\n+    case GIMPLE_SWITCH:\n+      expand_case (stmt);\n+      break;\n+    case GIMPLE_ASM:\n+      expand_asm_stmt (stmt);\n+      break;\n+    case GIMPLE_CALL:\n+      expand_call_stmt (stmt);\n+      break;\n+\n+    case GIMPLE_RETURN:\n+      op0 = gimple_return_retval (stmt);\n+\n+      if (op0 && op0 != error_mark_node)\n+\t{\n+\t  tree result = DECL_RESULT (current_function_decl);\n+\n+\t  /* If we are not returning the current function's RESULT_DECL,\n+\t     build an assignment to it.  */\n+\t  if (op0 != result)\n+\t    {\n+\t      /* I believe that a function's RESULT_DECL is unique.  */\n+\t      gcc_assert (TREE_CODE (op0) != RESULT_DECL);\n+\n+\t      /* ??? We'd like to use simply expand_assignment here,\n+\t         but this fails if the value is of BLKmode but the return\n+\t\t decl is a register.  expand_return has special handling\n+\t\t for this combination, which eventually should move\n+\t\t to common code.  See comments there.  Until then, let's\n+\t\t build a modify expression :-/  */\n+\t      op0 = build2 (MODIFY_EXPR, TREE_TYPE (result),\n+\t\t\t    result, op0);\n+\t    }\n+\t}\n+      if (!op0)\n+\texpand_null_return ();\n+      else\n+\texpand_return (op0);\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      {\n+\ttree lhs = gimple_assign_lhs (stmt);\n+\n+\t/* Tree expand used to fiddle with |= and &= of two bitfield\n+\t   COMPONENT_REFs here.  This can't happen with gimple, the LHS\n+\t   of binary assigns must be a gimple reg.  */\n+\n+\tif (TREE_CODE (lhs) != SSA_NAME\n+\t    || get_gimple_rhs_class (gimple_expr_code (stmt))\n+\t       == GIMPLE_SINGLE_RHS)\n+\t  {\n+\t    tree rhs = gimple_assign_rhs1 (stmt);\n+\t    gcc_assert (get_gimple_rhs_class (gimple_expr_code (stmt))\n+\t\t\t== GIMPLE_SINGLE_RHS);\n+\t    if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (rhs))\n+\t      SET_EXPR_LOCATION (rhs, gimple_location (stmt));\n+\t    expand_assignment (lhs, rhs,\n+\t\t\t       gimple_assign_nontemporal_move_p (stmt));\n+\t  }\n+\telse\n+\t  {\n+\t    rtx target, temp;\n+\t    bool nontemporal = gimple_assign_nontemporal_move_p (stmt);\n+\t    struct separate_ops ops;\n+\t    bool promoted = false;\n+\n+\t    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\t    if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n+\t      promoted = true;\n+\n+\t    ops.code = gimple_assign_rhs_code (stmt);\n+\t    ops.type = TREE_TYPE (lhs);\n+\t    switch (get_gimple_rhs_class (gimple_expr_code (stmt)))\n+\t      {\n+\t\tcase GIMPLE_BINARY_RHS:\n+\t\t  ops.op1 = gimple_assign_rhs2 (stmt);\n+\t\t  /* Fallthru */\n+\t\tcase GIMPLE_UNARY_RHS:\n+\t\t  ops.op0 = gimple_assign_rhs1 (stmt);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t      }\n+\t    ops.location = gimple_location (stmt);\n+\n+\t    /* If we want to use a nontemporal store, force the value to\n+\t       register first.  If we store into a promoted register,\n+\t       don't directly expand to target.  */\n+\t    temp = nontemporal || promoted ? NULL_RTX : target;\n+\t    temp = expand_expr_real_2 (&ops, temp, GET_MODE (target),\n+\t\t\t\t       EXPAND_NORMAL);\n+\n+\t    if (temp == target)\n+\t      ;\n+\t    else if (promoted)\n+\t      {\n+\t\tbool unsigndp = SUBREG_PROMOTED_UNSIGNED_P (target);\n+\t\t/* If TEMP is a VOIDmode constant, use convert_modes to make\n+\t\t   sure that we properly convert it.  */\n+\t\tif (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)\n+\t\t  {\n+\t\t    temp = convert_modes (GET_MODE (target),\n+\t\t\t\t\t  TYPE_MODE (ops.type),\n+\t\t\t\t\t  temp, unsigndp);\n+\t\t    temp = convert_modes (GET_MODE (SUBREG_REG (target)),\n+\t\t\t\t\t  GET_MODE (target), temp, unsigndp);\n+\t\t  }\n+\n+\t\tconvert_move (SUBREG_REG (target), temp, unsigndp);\n+\t      }\n+\t    else if (nontemporal && emit_storent_insn (target, temp))\n+\t      ;\n+\t    else\n+\t      {\n+\t\ttemp = force_operand (temp, target);\n+\t\tif (temp != target)\n+\t\t  emit_move_insn (target, temp);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Expand one gimple statement STMT and return the last RTL instruction\n+   before any of the newly generated ones.\n+\n+   In addition to generating the necessary RTL instructions this also\n+   sets REG_EH_REGION notes if necessary and sets the current source\n+   location for diagnostics.  */\n+\n+static rtx\n+expand_gimple_stmt (gimple stmt)\n+{\n+  int rn = -1;\n+  rtx last = NULL;\n+  location_t saved_location = input_location;\n+\n+  last = get_last_insn ();\n+\n+  /* If this is an expression of some kind and it has an associated line\n+     number, then emit the line number before expanding the expression.\n+\n+     We need to save and restore the file and line information so that\n+     errors discovered during expansion are emitted with the right\n+     information.  It would be better of the diagnostic routines\n+     used the file/line information embedded in the tree nodes rather\n+     than globals.  */\n+  gcc_assert (cfun);\n+\n+  if (gimple_has_location (stmt))\n+    {\n+      input_location = gimple_location (stmt);\n+      set_curr_insn_source_location (input_location);\n+\n+      /* Record where the insns produced belong.  */\n+      set_curr_insn_block (gimple_block (stmt));\n+    }\n+\n+  expand_gimple_stmt_1 (stmt);\n+  /* Free any temporaries used to evaluate this statement.  */\n+  free_temp_slots ();\n+\n+  input_location = saved_location;\n+\n+  /* Mark all insns that may trap.  */\n+  rn = lookup_stmt_eh_region (stmt);\n+  if (rn >= 0)\n+    {\n+      rtx insn;\n+      for (insn = next_real_insn (last); insn;\n+\t   insn = next_real_insn (insn))\n+\t{\n+\t  if (! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n+\t      /* If we want exceptions for non-call insns, any\n+\t\t may_trap_p instruction may throw.  */\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t      && GET_CODE (PATTERN (insn)) != USE\n+\t      && (CALL_P (insn)\n+\t\t  || (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))))\n+\t    add_reg_note (insn, REG_EH_REGION, GEN_INT (rn));\n+\t}\n+    }\n+\n+  return last;\n+}\n+\n /* A subroutine of expand_gimple_basic_block.  Expand one GIMPLE_CALL\n    that has CALL_EXPR_TAILCALL set.  Returns non-null if we actually\n    generated a tail call (something that might be denied by the ABI\n@@ -2062,13 +2032,8 @@ expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n   edge_iterator ei;\n   int probability;\n   gcov_type count;\n-  tree stmt_tree = gimple_to_tree (stmt);\n \n-  last2 = last = get_last_insn ();\n-\n-  expand_expr_stmt (stmt_tree);\n-\n-  release_stmt_tree (stmt, stmt_tree);\n+  last2 = last = expand_gimple_stmt (stmt);\n \n   for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n     if (CALL_P (last) && SIBLING_CALL_P (last))\n@@ -3018,9 +2983,7 @@ expand_gimple_basic_block (basic_block bb)\n \n       if (stmt)\n \t{\n-\t  tree stmt_tree = gimple_to_tree (stmt);\n-\t  expand_expr_stmt (stmt_tree);\n-\t  release_stmt_tree (stmt, stmt_tree);\n+\t  expand_gimple_stmt (stmt);\n \t  gsi_next (&gsi);\n \t}\n \n@@ -3126,7 +3089,6 @@ expand_gimple_basic_block (basic_block bb)\n \t  else\n \t    {\n \t      def_operand_p def_p;\n-\t      tree stmt_tree;\n \t      def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);\n \n \t      if (def_p != NULL)\n@@ -3138,11 +3100,8 @@ expand_gimple_basic_block (basic_block bb)\n \t\t\t\t       SSA_NAME_VERSION (DEF_FROM_PTR (def_p))))\n \t\t    continue;\n \t\t}\n-\t      stmt_tree = gimple_to_tree (stmt);\n-\t      last = get_last_insn ();\n-\t      expand_expr_stmt (stmt_tree);\n+\t      last = expand_gimple_stmt (stmt);\n \t      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n-\t      release_stmt_tree (stmt, stmt_tree);\n \t    }\n \t}\n     }"}, {"sha": "ed489d9604c989096100b9e3fef127b61af60b87", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -437,9 +437,9 @@ set_eh_region_tree_label (struct eh_region_d *region, tree lab)\n }\n \f\n void\n-expand_resx_expr (tree exp)\n+expand_resx_stmt (gimple stmt)\n {\n-  int region_nr = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n+  int region_nr = gimple_resx_region (stmt);\n   rtx insn;\n   struct eh_region_d *reg = VEC_index (eh_region,\n \t\t\t\t       cfun->eh->region_array, region_nr);"}, {"sha": "f332b2b1bb70bf733a31c5fb50f847bacd4166ce", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -198,7 +198,7 @@ extern void foreach_reachable_handler (int, bool, bool,\n \t\t\t\t       void *);\n \n extern void collect_eh_region_array (void);\n-extern void expand_resx_expr (tree);\n+extern void expand_resx_stmt (gimple);\n extern void verify_eh_tree (struct function *);\n extern void dump_eh_tree (FILE *, struct function *);\n void debug_eh_tree (struct function *);"}, {"sha": "cd5eae16880ff31634c8061b5f5ed13a9d8a66db", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 56, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -4435,7 +4435,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n /* Emits nontemporal store insn that moves FROM to TO.  Returns true if this\n    succeeded, false otherwise.  */\n \n-static bool\n+bool\n emit_storent_insn (rtx to, rtx from)\n {\n   enum machine_mode mode = GET_MODE (to), imode;\n@@ -4485,7 +4485,6 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n-  int dont_return_target = 0;\n   location_t loc = EXPR_LOCATION (exp);\n \n   if (VOID_TYPE_P (TREE_TYPE (exp)))\n@@ -4646,19 +4645,6 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n \t\t\t       &alt_rtl);\n-      /* Return TARGET if it's a specified hardware register.\n-\t If TARGET is a volatile mem ref, either return TARGET\n-\t or return a reg copied *from* TARGET; ANSI requires this.\n-\n-\t Otherwise, if TEMP is not TARGET, return TEMP\n-\t if it is constant (for efficiency),\n-\t or if we really want the correct value.  */\n-      if (!(target && REG_P (target)\n-\t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\t  && !(MEM_P (target) && MEM_VOLATILE_P (target))\n-\t  && ! rtx_equal_p (temp, target)\n-\t  && CONSTANT_P (temp))\n-\tdont_return_target = 1;\n     }\n \n   /* If TEMP is a VOIDmode constant and the mode of the type of EXP is not\n@@ -4707,15 +4693,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t  && GET_MODE (temp) != VOIDmode)\n \t{\n \t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n-\t  if (dont_return_target)\n-\t    {\n-\t      /* In this case, we will return TEMP,\n-\t\t so make sure it has the proper mode.\n-\t\t But don't forget to store the value into TARGET.  */\n-\t      temp = convert_to_mode (GET_MODE (target), temp, unsignedp);\n-\t      emit_move_insn (target, temp);\n-\t    }\n-\t  else if (GET_MODE (target) == BLKmode\n+\t  if (GET_MODE (target) == BLKmode\n \t\t   || GET_MODE (temp) == BLKmode)\n \t    emit_block_move (target, temp, expr_size (exp),\n \t\t\t     (call_param_p\n@@ -7128,9 +7106,6 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n    COMPOUND_EXPR whose second argument is such a VAR_DECL, and so on\n    recursively.  */\n \n-static rtx expand_expr_real_1 (tree, rtx, enum machine_mode,\n-\t\t\t       enum expand_modifier, rtx *);\n-\n rtx\n expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t  enum expand_modifier modifier, rtx *alt_rtl)\n@@ -7203,7 +7178,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n   return ret;\n }\n \n-static rtx\n+rtx\n expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier)\n {\n@@ -8251,7 +8226,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n }\n #undef REDUCE_BIT_FIELD\n \n-static rtx\n+rtx\n expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier, rtx *alt_rtl)\n {\n@@ -8611,12 +8586,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return ret;\n       }\n \n-    case GOTO_EXPR:\n-      if (TREE_CODE (treeop0) == LABEL_DECL)\n-\texpand_goto (treeop0);\n-      else\n-\texpand_computed_goto (treeop0);\n-      return const0_rtx;\n \n     case CONSTRUCTOR:\n       /* If we don't need the result, just ensure we evaluate any\n@@ -9505,13 +9474,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn const0_rtx;\n       }\n \n-    case RETURN_EXPR:\n-      if (!treeop0)\n-\texpand_null_return ();\n-      else\n-\texpand_return (treeop0);\n-      return const0_rtx;\n-\n     case ADDR_EXPR:\n       return expand_expr_addr_expr (exp, target, tmode, modifier);\n \n@@ -9523,9 +9485,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       op0 = expand_normal (treeop0);\n       return read_complex_part (op0, true);\n \n+    case RETURN_EXPR:\n+    case LABEL_EXPR:\n+    case GOTO_EXPR:\n+    case SWITCH_EXPR:\n+    case ASM_EXPR:\n     case RESX_EXPR:\n-      expand_resx_expr (exp);\n-      return const0_rtx;\n+      /* Expanded in cfgexpand.c.  */\n+      gcc_unreachable ();\n \n     case TRY_CATCH_EXPR:\n     case CATCH_EXPR:\n@@ -9563,18 +9530,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t initialization constants, and should not be expanded.  */\n       gcc_unreachable ();\n \n-    case SWITCH_EXPR:\n-      expand_case (exp);\n-      return const0_rtx;\n-\n-    case LABEL_EXPR:\n-      expand_label (treeop0);\n-      return const0_rtx;\n-\n-    case ASM_EXPR:\n-      expand_asm_expr (exp);\n-      return const0_rtx;\n-\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR expands to its first argument.  The caller should\n \t have pulled out the size to use in whatever context it needed.  */"}, {"sha": "8eddb44be4351659101eb9756dd0176542f4c223", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -426,6 +426,7 @@ extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n extern rtx emit_block_move_via_libcall (rtx, rtx, rtx, bool);\n extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n \t\t\t          unsigned int, HOST_WIDE_INT);\n+extern bool emit_storent_insn (rtx to, rtx from);\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n@@ -539,9 +540,13 @@ extern rtx store_expr (tree, rtx, int, bool);\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand (rtx, rtx);\n \n-/* Work horse for expand_expr.  */\n+/* Work horses for expand_expr.  */\n extern rtx expand_expr_real (tree, rtx, enum machine_mode, \n \t\t\t     enum expand_modifier, rtx *);\n+extern rtx expand_expr_real_1 (tree, rtx, enum machine_mode,\n+\t\t\t       enum expand_modifier, rtx *);\n+extern rtx expand_expr_real_2 (sepops, rtx, enum machine_mode,\n+\t\t\t       enum expand_modifier);\n \n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null."}, {"sha": "23fdd08dd302f0ef96ce8360d9a71430503d348e", "filename": "gcc/stmt.c", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"optabs.h\"\n #include \"target.h\"\n+#include \"gimple.h\"\n #include \"regs.h\"\n #include \"alloc-pool.h\"\n #include \"pretty-print.h\"\n@@ -1075,20 +1076,65 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n }\n \n void\n-expand_asm_expr (tree exp)\n+expand_asm_stmt (gimple stmt)\n {\n-  int noutputs, i;\n-  tree outputs, tail;\n+  int noutputs;\n+  tree outputs, tail, t;\n   tree *o;\n+  size_t i, n;\n+  const char *s;\n+  tree str, out, in, cl;\n+\n+  /* Meh... convert the gimple asm operands into real tree lists.\n+     Eventually we should make all routines work on the vectors instead\n+     of relying on TREE_CHAIN.  */\n+  out = NULL_TREE;\n+  n = gimple_asm_noutputs (stmt);\n+  if (n > 0)\n+    {\n+      t = out = gimple_asm_output_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\t{\n+\t  TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n+\t  t = gimple_asm_output_op (stmt, i);\n+\t}\n+    }\n+\n+  in = NULL_TREE;\n+  n = gimple_asm_ninputs (stmt);\n+  if (n > 0)\n+    {\n+      t = in = gimple_asm_input_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\t{\n+\t  TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n+\t  t = gimple_asm_input_op (stmt, i);\n+\t}\n+    }\n+\n+  cl = NULL_TREE;\n+  n = gimple_asm_nclobbers (stmt);\n+  if (n > 0)\n+    {\n+      t = cl = gimple_asm_clobber_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\t{\n+\t  TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+\t  t = gimple_asm_clobber_op (stmt, i);\n+\t}\n+    }\n \n-  if (ASM_INPUT_P (exp))\n+  s = gimple_asm_string (stmt);\n+  str = build_string (strlen (s), s);\n+\n+  if (gimple_asm_input_p (stmt))\n     {\n-      expand_asm_loc (ASM_STRING (exp), ASM_VOLATILE_P (exp), input_location);\n+      expand_asm_loc (str, gimple_asm_volatile_p (stmt), input_location);\n       return;\n     }\n \n-  outputs = ASM_OUTPUTS (exp);\n-  noutputs = list_length (outputs);\n+  outputs = out;\n+  noutputs = gimple_asm_noutputs (stmt);\n   /* o[I] is the place that output number I should be written.  */\n   o = (tree *) alloca (noutputs * sizeof (tree));\n \n@@ -1098,8 +1144,7 @@ expand_asm_expr (tree exp)\n \n   /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n      OUTPUTS some trees for where the values were actually stored.  */\n-  expand_asm_operands (ASM_STRING (exp), outputs, ASM_INPUTS (exp),\n-\t\t       ASM_CLOBBERS (exp), ASM_VOLATILE_P (exp),\n+  expand_asm_operands (str, outputs, in, cl, gimple_asm_volatile_p (stmt),\n \t\t       input_location);\n \n   /* Copy all the intermediate outputs into the specified outputs.  */\n@@ -2154,7 +2199,7 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n    Generate the code to test it and jump to the right place.  */\n \n void\n-expand_case (tree exp)\n+expand_case (gimple stmt)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx default_label = 0;\n@@ -2167,9 +2212,7 @@ expand_case (tree exp)\n   int i;\n   rtx before_case, end, lab;\n \n-  tree vec = SWITCH_LABELS (exp);\n-  tree orig_type = TREE_TYPE (exp);\n-  tree index_expr = SWITCH_COND (exp);\n+  tree index_expr = gimple_switch_index (stmt);\n   tree index_type = TREE_TYPE (index_expr);\n   int unsignedp = TYPE_UNSIGNED (index_type);\n \n@@ -2188,36 +2231,31 @@ expand_case (tree exp)\n                                                  sizeof (struct case_node),\n                                                  100);\n \n-  /* The switch body is lowered in gimplify.c, we should never have\n-     switches with a non-NULL SWITCH_BODY here.  */\n-  gcc_assert (!SWITCH_BODY (exp));\n-  gcc_assert (SWITCH_LABELS (exp));\n-\n   do_pending_stack_adjust ();\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n       tree elt;\n       bitmap label_bitmap;\n-      int vl = TREE_VEC_LENGTH (vec);\n+      int stopi = 0;\n \n       /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n \t expressions being INTEGER_CST.  */\n       gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n \n-      /* The default case, if ever taken, is at the end of TREE_VEC.  */\n-      elt = TREE_VEC_ELT (vec, vl - 1);\n+      /* The default case, if ever taken, is the first element.  */\n+      elt = gimple_switch_label (stmt, 0);\n       if (!CASE_LOW (elt) && !CASE_HIGH (elt))\n \t{\n \t  default_label_decl = CASE_LABEL (elt);\n-\t  --vl;\n+\t  stopi = 1;\n \t}\n \n-      for (i = vl - 1; i >= 0; --i)\n+      for (i = gimple_switch_num_labels (stmt) - 1; i >= stopi; --i)\n \t{\n \t  tree low, high;\n-\t  elt = TREE_VEC_ELT (vec, i);\n+\t  elt = gimple_switch_label (stmt, i);\n \n \t  low = CASE_LOW (elt);\n \t  gcc_assert (low);\n@@ -2371,9 +2409,7 @@ expand_case (tree exp)\n \t     decision tree an unconditional jump to the\n \t     default code is emitted.  */\n \n-\t  use_cost_table\n-\t    = (TREE_CODE (orig_type) != ENUMERAL_TYPE\n-\t       && estimate_case_costs (case_list));\n+\t  use_cost_table = estimate_case_costs (case_list);\n \t  balance_case_nodes (&case_list, NULL);\n \t  emit_case_nodes (index, case_list, default_label, index_type);\n \t  if (default_label)"}, {"sha": "4d0cfd346716c8f6e44d9241f5c2446f0ab5cb6a", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=28ed065ef9f3450c5c7f7fe53a3aff66c1721a6d", "patch": "@@ -5054,9 +5054,9 @@ extern bool parse_output_constraint (const char **, int, int, int,\n \t\t\t\t     bool *, bool *, bool *);\n extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n-extern void expand_asm_expr (tree);\n+extern void expand_asm_stmt (gimple);\n extern tree resolve_asm_operand_names (tree, tree, tree);\n-extern void expand_case (tree);\n+extern void expand_case (gimple);\n extern void expand_decl (tree);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */"}]}