{"sha": "8c354a412f1d5fb32a44baff649eb21d67ac4a16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzNTRhNDEyZjFkNWZiMzJhNDRiYWZmNjQ5ZWIyMWQ2N2FjNGExNg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-16T17:34:35Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-16T17:34:35Z"}, "message": "loop.c (strength_reduce): Calculate maybe_dead before calling recombine_givs.\n\n\t* loop.c (strength_reduce): Calculate maybe_dead before\n\tcalling recombine_givs.\n\nFrom-SVN: r25251", "tree": {"sha": "163da2e367f4d231b64af0c0b9417c77704a1a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/163da2e367f4d231b64af0c0b9417c77704a1a7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c354a412f1d5fb32a44baff649eb21d67ac4a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c354a412f1d5fb32a44baff649eb21d67ac4a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c354a412f1d5fb32a44baff649eb21d67ac4a16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c354a412f1d5fb32a44baff649eb21d67ac4a16/comments", "author": null, "committer": null, "parents": [{"sha": "1ccf8937264c876660424c047431c8b353537e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccf8937264c876660424c047431c8b353537e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccf8937264c876660424c047431c8b353537e90"}], "stats": {"total": 57, "additions": 35, "deletions": 22}, "files": [{"sha": "d51cea9a627438ead27e8b15fd3d6fdc98d08367", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c354a412f1d5fb32a44baff649eb21d67ac4a16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c354a412f1d5fb32a44baff649eb21d67ac4a16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c354a412f1d5fb32a44baff649eb21d67ac4a16", "patch": "@@ -1,3 +1,8 @@\n+Wed Feb 17 01:29:07 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (strength_reduce): Calculate maybe_dead before\n+\tcalling recombine_givs.\n+\n Wed Feb 17 00:43:12 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (strength_reduce): Dump biv increment -> giv conversions."}, {"sha": "0979b999e5cc6becf095f96bca5859bca0d5eff7", "filename": "gcc/loop.c", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c354a412f1d5fb32a44baff649eb21d67ac4a16/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c354a412f1d5fb32a44baff649eb21d67ac4a16/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8c354a412f1d5fb32a44baff649eb21d67ac4a16", "patch": "@@ -4621,6 +4621,35 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    }\n \t}\n \n+      /* Check for givs whose first use is their definition and whose\n+\t last use is the definition of another giv.  If so, it is likely\n+\t dead and should not be used to derive another giv nor to\n+\t eliminate a biv.  */\n+      for (v = bl->giv; v; v = v->next_iv)\n+\t{\n+\t  if (v->ignore\n+\t      || (v->same && v->same->ignore))\n+\t    continue;\n+\n+\t  if (v->last_use)\n+\t    {\n+\t      struct induction *v1;\n+\n+\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n+\t\tif (v->last_use == v1->insn)\n+\t\t  v->maybe_dead = 1;\n+\t    }\n+\t  else if (v->giv_type == DEST_REG\n+\t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n+\t    {\n+\t      struct induction *v1;\n+\n+\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n+\t\tif (REGNO_LAST_UID (REGNO (v->dest_reg)) == INSN_UID (v1->insn))\n+\t\t  v->maybe_dead = 1;\n+\t    }\n+\t}\n+\n #if 0\n       /* XXX Temporary.  */\n       /* Now that we know which givs will be reduced, try to rearrange the\n@@ -4789,11 +4818,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t \n \t For each giv register that can be reduced now: if replaceable,\n \t substitute reduced reg wherever the old giv occurs;\n-\t else add new move insn \"giv_reg = reduced_reg\".\n+\t else add new move insn \"giv_reg = reduced_reg\".  */\n \n-\t Also check for givs whose first use is their definition and whose\n-\t last use is the definition of another giv.  If so, it is likely\n-\t dead and should not be used to eliminate a biv.  */\n       for (v = bl->giv; v; v = v->next_iv)\n \t{\n \t  if (v->same && v->same->ignore)\n@@ -4802,24 +4828,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  if (v->ignore)\n \t    continue;\n \n-\t  if (v->last_use)\n-\t    {\n-\t      struct induction *v1;\n-\n-\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n-\t\tif (v->last_use == v1->insn)\n-\t\t  v->maybe_dead = 1;\n-\t    }\n-\t  else if (v->giv_type == DEST_REG\n-\t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n-\t    {\n-\t      struct induction *v1;\n-\n-\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n-\t\tif (REGNO_LAST_UID (REGNO (v->dest_reg)) == INSN_UID (v1->insn))\n-\t\t  v->maybe_dead = 1;\n-\t    }\n-\n \t  /* Update expression if this was combined, in case other giv was\n \t     replaced.  */\n \t  if (v->same)"}]}