{"sha": "4b6c167260f42134dc465ccd05b68d38a3b275d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2YzE2NzI2MGY0MjEzNGRjNDY1Y2NkMDViNjhkMzhhM2IyNzVkMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-23T22:59:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-23T22:59:15Z"}, "message": "builtins.c (expand_builtin_setjmp): Only call convert_memory_address if needed.\n\n\t* builtins.c (expand_builtin_setjmp): Only call convert_memory_address\n\tif needed.\n\t(expand_builtin_longjmp, expand_builtin_alloca): Likewise.\n\t* except.c (expand_builtin_frob_return_addr): Likewise.\n\t(expand_builtin_eh_return): Likewise.\n\t* stmt.c (expand_computed_goto): Likewise.\n\t* explow.c (memory_address): Likewise.\n\t(allocate_dynamic_stack_space): Clean up predicate testing.\n\t(probe_stack_range): Convert SIZE to Pmode.\n\t* calls.c (rtx_for_function_call): Only call convert_memory_address\n\tif needed.\n\tPass function call operand as ptr_mode, not Pmode.\n\t* expr.c (expand_assignment): Clean up calls to convert_memory\n\taddress by only doing so when needed and making offsets Pmode.\n\t(store_constructor, expand_expr, expand_expr_unaligned): Likewise.\n\t* function.c (assign_parms): Ensure address in MEM for RESULT_DECL\n\tis in Pmode, not ptr_mode.\n\nFrom-SVN: r46448", "tree": {"sha": "fa0e244bdad0d095044fbe7bb7bb53c3b667a4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa0e244bdad0d095044fbe7bb7bb53c3b667a4bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b6c167260f42134dc465ccd05b68d38a3b275d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6c167260f42134dc465ccd05b68d38a3b275d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6c167260f42134dc465ccd05b68d38a3b275d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6c167260f42134dc465ccd05b68d38a3b275d3/comments", "author": null, "committer": null, "parents": [{"sha": "91dc3130bf8964ab890918269fc3f69539c42bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dc3130bf8964ab890918269fc3f69539c42bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91dc3130bf8964ab890918269fc3f69539c42bb8"}], "stats": {"total": 106, "additions": 71, "deletions": 35}, "files": [{"sha": "59580c516fcf8b1b0afc8dfc572c8d4871924901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -1,3 +1,23 @@\n+Tue Oct 23 13:05:53 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.\n+\n+\t* builtins.c (expand_builtin_setjmp): Only call convert_memory_address\n+\tif needed.\n+\t(expand_builtin_longjmp, expand_builtin_alloca): Likewise.\n+\t* except.c (expand_builtin_frob_return_addr): Likewise.\n+\t(expand_builtin_eh_return): Likewise.\n+\t* stmt.c (expand_computed_goto): Likewise.\n+\t* explow.c (memory_address): Likewise.\n+\t(allocate_dynamic_stack_space): Clean up predicate testing.\n+\t(probe_stack_range): Convert SIZE to Pmode.\n+\t* calls.c (rtx_for_function_call): Only call convert_memory_address\n+\tif needed.\n+\tPass function call operand as ptr_mode, not Pmode.\n+\t* expr.c (expand_assignment): Clean up calls to convert_memory\n+\taddress by only doing so when needed and making offsets Pmode.\n+\t(store_constructor, expand_expr, expand_expr_unaligned): Likewise.\n+\t* function.c (assign_parms): Ensure address in MEM for RESULT_DECL\n+\tis in Pmode, not ptr_mode.\n+\n 2001-10-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* darwin-protos.h (constructor_section, destructor_section,"}, {"sha": "2ff203e578f00e22f67eb34bc299083fb592e1e7", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -456,7 +456,8 @@ expand_builtin_setjmp_setup (buf_addr, receiver_label)\n     setjmp_alias_set = new_alias_set ();\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  buf_addr = convert_memory_address (Pmode, buf_addr);\n+  if (GET_MODE (buf_addr) != Pmode)\n+    buf_addr = convert_memory_address (Pmode, buf_addr);\n #endif\n \n   buf_addr = force_reg (Pmode, force_operand (buf_addr, NULL_RTX));\n@@ -642,8 +643,10 @@ expand_builtin_longjmp (buf_addr, value)\n     setjmp_alias_set = new_alias_set ();\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  buf_addr = convert_memory_address (Pmode, buf_addr);\n+  if (GET_MODE (buf_addr) != Pmode)\n+    buf_addr = convert_memory_address (Pmode, buf_addr);\n #endif\n+\n   buf_addr = force_reg (Pmode, buf_addr);\n \n   /* We used to store value in static_chain_rtx, but that fails if pointers\n@@ -3104,7 +3107,8 @@ expand_builtin_alloca (arglist, target)\n   result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  result = convert_memory_address (ptr_mode, result);\n+  if (GET_MODE (result) != ptr_mode)\n+    result = convert_memory_address (ptr_mode, result);\n #endif\n \n   return result;"}, {"sha": "a0c451c42fd2495c58665c40d5ee435dbc27edbd", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -1673,21 +1673,19 @@ rtx_for_function_call (fndecl, exp)\n     {\n       rtx funaddr;\n       push_temp_slots ();\n-      funaddr = funexp =\n-\texpand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+      funaddr = funexp\n+\t= expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       pop_temp_slots ();\t/* FUNEXP can't be BLKmode.  */\n \n       /* Check the function is executable.  */\n       if (current_function_check_memory_usage)\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t  /* It might be OK to convert funexp in place, but there's\n-\t     a lot going on between here and when it happens naturally\n-\t     that this seems safer.  */\n-\t  funaddr = convert_memory_address (Pmode, funexp);\n+\t  if (GET_MODE (funexp) != ptr_mode)\n+\t    funaddr = convert_memory_address (ptr_mode, funexp);\n #endif\n \t  emit_library_call (chkr_check_exec_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t     VOIDmode, 1, funaddr, Pmode);\n+\t\t\t     VOIDmode, 1, funaddr, ptr_mode);\n \t}\n       emit_queue ();\n     }"}, {"sha": "0a33b180bfa1b606c5bf35899609d5f584dc374d", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -2944,10 +2944,11 @@ rtx\n expand_builtin_frob_return_addr (addr_tree)\n      tree addr_tree;\n {\n-  rtx addr = expand_expr (addr_tree, NULL_RTX, Pmode, 0);\n+  rtx addr = expand_expr (addr_tree, NULL_RTX, ptr_mode, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  addr = convert_memory_address (Pmode, addr);\n+  if (GET_MODE (addr) != Pmode)\n+    addr = convert_memory_address (Pmode, addr);\n #endif\n \n #ifdef RETURN_ADDR_OFFSET\n@@ -2971,8 +2972,11 @@ expand_builtin_eh_return (stackadj_tree, handler_tree)\n   handler = expand_expr (handler_tree, cfun->eh->ehr_handler, VOIDmode, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  stackadj = convert_memory_address (Pmode, stackadj);\n-  handler = convert_memory_address (Pmode, handler);\n+  if (GET_MODE (stackadj) != Pmode)\n+    stackadj = convert_memory_address (Pmode, stackadj);\n+\n+  if (GET_MODE (handler) != Pmode)\n+    handler = convert_memory_address (Pmode, handler);\n #endif\n \n   if (! cfun->eh->ehr_label)"}, {"sha": "d0735aab78a3fd54175fdfafc8eeaae1cd2ec317", "filename": "gcc/explow.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -472,7 +472,7 @@ memory_address (mode, x)\n     return x;\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  if (GET_MODE (x) == ptr_mode)\n+  if (GET_MODE (x) != Pmode)\n     x = convert_memory_address (Pmode, x);\n #endif\n \n@@ -1318,16 +1318,12 @@ allocate_dynamic_stack_space (size, target, known_align)\n       enum machine_mode mode = STACK_SIZE_MODE;\n       insn_operand_predicate_fn pred;\n \n-      pred = insn_data[(int) CODE_FOR_allocate_stack].operand[0].predicate;\n-      if (pred && ! ((*pred) (target, Pmode)))\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\ttarget = convert_memory_address (Pmode, target);\n-#else\n-\ttarget = copy_to_mode_reg (Pmode, target);\n-#endif\n-\n+      /* We don't have to check against the predicate for operand 0 since\n+\t TARGET is known to be a pseudo of the proper mode, which must\n+\t be valid for the operand.  For operand 1, convert to the\n+\t proper mode and validate.  */\n       if (mode == VOIDmode)\n-\tmode = Pmode;\n+\tmode = insn_data[(int) CODE_FOR_allocate_stack].operand[1].mode;\n \n       pred = insn_data[(int) CODE_FOR_allocate_stack].operand[1].predicate;\n       if (pred && ! ((*pred) (size, mode)))\n@@ -1461,7 +1457,11 @@ probe_stack_range (first, size)\n      HOST_WIDE_INT first;\n      rtx size;\n {\n-  /* First see if the front end has set up a function for us to call to\n+  /* First ensure SIZE is Pmode.  */\n+  if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n+    size = convert_to_mode (Pmode, size, 1);\n+\n+  /* Next see if the front end has set up a function for us to call to\n      check the stack.  */\n   if (stack_check_libfunc != 0)\n     {"}, {"sha": "3eebaa25483870419d787230db33c97f606a6754", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -3732,13 +3732,12 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t    abort ();\n \n \t  if (GET_MODE (offset_rtx) != ptr_mode)\n-\t    {\n+\t    offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t      offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n-#else\n-\t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\t  if (GET_MODE (offset_rtx) != Pmode)\n+\t    offset_rtx = convert_memory_address (Pmode, offset_rtx);\n #endif\n-\t    }\n \n \t  /* A constant address in TO_RTX can have VOIDmode, we must not try\n \t     to call force_reg for that case.  Avoid that case.  */\n@@ -4637,7 +4636,8 @@ store_constructor (exp, target, align, cleared, size)\n \t\toffset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t      offset_rtx = convert_memory_address (Pmode, offset_rtx);\n+\t      if (GET_MODE (offset_rtx) != Pmode)\n+\t\toffset_rtx = convert_memory_address (Pmode, offset_rtx);\n #endif\n \n \t      to_rtx = offset_address (to_rtx, offset_rtx,\n@@ -7044,7 +7044,8 @@ expand_expr (exp, target, tmode, modifier)\n \t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t    offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n+\t    if (GET_MODE (offset_rtx) != Pmode)\n+\t      offset_rtx = convert_memory_address (Pmode, offset_rtx);\n #endif\n \n \t    /* A constant address in OP0 can have VOIDmode, we must not try\n@@ -9057,7 +9058,8 @@ expand_expr_unaligned (exp, palign)\n \t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t    offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n+\t    if (GET_MODE (offset_rtx) != Pmode)\n+\t      offset_rtx = convert_memory_address (Pmode, offset_rtx);\n #endif\n \n \t    op0 = offset_address (op0, offset_rtx,"}, {"sha": "f4d0fff26350f899e48d42d542a0706eb56d12f9", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -5018,8 +5018,15 @@ assign_parms (fndecl)\n       if (parm == function_result_decl)\n \t{\n \t  tree result = DECL_RESULT (fndecl);\n-\t  rtx x = gen_rtx_MEM (DECL_MODE (result), DECL_RTL (parm));\n+\t  rtx addr = DECL_RTL (parm);\n+\t  rtx x;\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t  if (GET_MODE (addr) != Pmode)\n+\t    addr = convert_memory_address (Pmode, addr);\n+#endif\n+\n+\t  x = gen_rtx_MEM (DECL_MODE (result), addr);\n \t  set_mem_attributes (x, result, 1);\n \t  SET_DECL_RTL (result, x);\n \t}"}, {"sha": "4943397d220b1e29528a444aac0ee8237153cc8a", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6c167260f42134dc465ccd05b68d38a3b275d3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4b6c167260f42134dc465ccd05b68d38a3b275d3", "patch": "@@ -707,7 +707,8 @@ expand_computed_goto (exp)\n   rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-  x = convert_memory_address (Pmode, x);\n+  if (GET_MODE (x) != Pmode)\n+    x = convert_memory_address (Pmode, x);\n #endif\n \n   emit_queue ();"}]}