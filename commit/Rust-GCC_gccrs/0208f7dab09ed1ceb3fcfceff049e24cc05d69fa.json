{"sha": "0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwOGY3ZGFiMDllZDFjZWIzZmNmY2VmZjA0OWUyNGNjMDVkNjlmYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-03-29T18:07:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-03-29T18:07:34Z"}, "message": "lto-cgraph.c (output_profile_summary, [...]): Use gcov streaming; stream hot bb threshold to ltrans.\n\n\n\t* lto-cgraph.c (output_profile_summary, input_profile_summary): Use\n\tgcov streaming; stream hot bb threshold to ltrans.\n\t* predict.c (get_hot_bb_threshold): Break out from ....\n\t(maybe_hot_count_p): ... here.\n\t(set_hot_bb_threshold): New function.\n\t* lto-section-in.c (lto_section_name): Add profile.\n\t* profile.h (get_hot_bb_threshold, set_hot_bb_threshold): Declare.\n\t* ipa.c: Include hash-table.h, tree-inline.h, profile.h, lto-streamer.h\n\tand data-streamer.h\n\t(histogram_entry): New structure.\n\t(histogram, histogram_pool): New global vars.\n\t(histogram_hash): New structure.\n\t(histogram_hash::hash): New method.\n\t(histogram_hash::equal): Likewise.\n\t(account_time_size): New function.\n\t(cmp_counts): New function.\n\t(dump_histogram): New function.\n\t(ipa_profile_generate_summary): New function.\n\t(ipa_profile_write_summary): New function.\n\t(ipa_profile_read_summary): New function.\n\t(ipa_profile): Decide on threshold.\n\t(pass_ipa_profile): Add ipa_profile_write_summary and ipa_profile_read_summary.\n\t* Makefile.in (ipa.o): Update dependencies.\n\t* lto-streamer.h (LTO_section_ipa_profile): New section.\n\nFrom-SVN: r197243", "tree": {"sha": "9b74c5279cc4912f4df1c50d5e555c5dc9cf64ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b74c5279cc4912f4df1c50d5e555c5dc9cf64ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/comments", "author": null, "committer": null, "parents": [{"sha": "5a6ccc943fa6c7f121a47e96a19d73a7531de311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a6ccc943fa6c7f121a47e96a19d73a7531de311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a6ccc943fa6c7f121a47e96a19d73a7531de311"}], "stats": {"total": 378, "additions": 354, "deletions": 24}, "files": [{"sha": "3c5351303e92b54828dfbf4012a6d0341a57fbd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -1,3 +1,30 @@\n+2013-03-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-cgraph.c (output_profile_summary, input_profile_summary): Use\n+\tgcov streaming; stream hot bb threshold to ltrans.\n+\t* predict.c (get_hot_bb_threshold): Break out from ....\n+\t(maybe_hot_count_p): ... here.\n+\t(set_hot_bb_threshold): New function.\n+\t* lto-section-in.c (lto_section_name): Add profile.\n+\t* profile.h (get_hot_bb_threshold, set_hot_bb_threshold): Declare.\n+\t* ipa.c: Include hash-table.h, tree-inline.h, profile.h, lto-streamer.h\n+\tand data-streamer.h\n+\t(histogram_entry): New structure.\n+\t(histogram, histogram_pool): New global vars.\n+\t(histogram_hash): New structure.\n+\t(histogram_hash::hash): New method.\n+\t(histogram_hash::equal): Likewise.\n+\t(account_time_size): New function.\n+\t(cmp_counts): New function.\n+\t(dump_histogram): New function.\n+\t(ipa_profile_generate_summary): New function.\n+\t(ipa_profile_write_summary): New function.\n+\t(ipa_profile_read_summary): New function.\n+\t(ipa_profile): Decide on threshold.\n+\t(pass_ipa_profile): Add ipa_profile_write_summary and ipa_profile_read_summary.\n+\t* Makefile.in (ipa.o): Update dependencies.\n+\t* lto-streamer.h (LTO_section_ipa_profile): New section.\n+\n 2013-03-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* tree.h (VAR_P): New."}, {"sha": "19377a9a8a5d7bdaa343984cc8321a52e10c945c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -2903,7 +2903,8 @@ varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) \n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n-   $(IPA_UTILS_H)\n+   $(IPA_UTILS_H) tree-inline.h $(HASH_TABLE_H) profile.h $(PARAMS_H) \\\n+   $(LTO_STREAMER_H) $(DATA_STREAMER_H)\n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\"}, {"sha": "0ea73dd8e8656b44f93b45fe114893e0e338004e", "filename": "gcc/ipa.c", "status": "modified", "additions": 273, "deletions": 3, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -32,6 +32,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"pointer-set.h\"\n #include \"ipa-inline.h\"\n+#include \"hash-table.h\"\n+#include \"tree-inline.h\"\n+#include \"profile.h\"\n+#include \"params.h\"\n+#include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n \n /* Look for all functions inlined to NODE and update their inlined_to pointers\n    to INLINED_TO.  */\n@@ -1040,6 +1046,201 @@ struct ipa_opt_pass_d pass_ipa_whole_program_visibility =\n  NULL,\t\t\t\t\t/* variable_transform */\n };\n \n+/* Entry in the histogram.  */\n+\n+struct histogram_entry\n+{\n+  gcov_type count;\n+  int time;\n+  int size;\n+};\n+\n+/* Histogram of profile values.\n+   The histogram is represented as an ordered vector of entries allocated via\n+   histogram_pool. During construction a separate hashtable is kept to lookup\n+   duplicate entries.  */\n+\n+vec<histogram_entry *> histogram;\n+static alloc_pool histogram_pool;\n+\n+/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n+\n+struct histogram_hash : typed_noop_remove <histogram_entry>\n+{\n+  typedef histogram_entry value_type;\n+  typedef histogram_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+histogram_hash::hash (const histogram_entry *val)\n+{\n+  return val->count;\n+}\n+\n+inline int\n+histogram_hash::equal (const histogram_entry *val, const histogram_entry *val2)\n+{\n+  return val->count == val2->count;\n+}\n+\n+/* Account TIME and SIZE executed COUNT times into HISTOGRAM.\n+   HASHTABLE is the on-side hash kept to avoid duplicates.  */\n+\n+static void\n+account_time_size (hash_table <histogram_hash> hashtable,\n+\t\t   vec<histogram_entry *> &histogram,\n+\t\t   gcov_type count, int time, int size)\n+{\n+  histogram_entry key = {count, 0, 0};\n+  histogram_entry **val = hashtable.find_slot (&key, INSERT);\n+\n+  if (!*val)\n+    {\n+      *val = (histogram_entry *) pool_alloc (histogram_pool);\n+      **val = key;\n+      histogram.safe_push (*val);\n+    }\n+  (*val)->time += time;\n+  (*val)->size += size;\n+}\n+\n+int\n+cmp_counts (const void *v1, const void *v2)\n+{\n+  const histogram_entry *h1 = *(const histogram_entry * const *)v1;\n+  const histogram_entry *h2 = *(const histogram_entry * const *)v2;\n+  if (h1->count < h2->count)\n+    return 1;\n+  if (h1->count > h2->count)\n+    return -1;\n+  return 0;\n+}\n+\n+/* Dump HISTOGRAM to FILE.  */\n+\n+static void\n+dump_histogram (FILE *file, vec<histogram_entry *> histogram)\n+{\n+  unsigned int i;\n+  gcov_type overall_time = 0, cumulated_time = 0, cumulated_size = 0, overall_size = 0;\n+  \n+  fprintf (dump_file, \"Histogram:\\n\");\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      overall_time += histogram[i]->count * histogram[i]->time;\n+      overall_size += histogram[i]->size;\n+    }\n+  if (!overall_time)\n+    overall_time = 1;\n+  if (!overall_size)\n+    overall_size = 1;\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      cumulated_time += histogram[i]->count * histogram[i]->time;\n+      cumulated_size += histogram[i]->size;\n+      fprintf (file, \"  \"HOST_WIDEST_INT_PRINT_DEC\": time:%i (%2.2f) size:%i (%2.2f)\\n\",\n+\t       (HOST_WIDEST_INT) histogram[i]->count,\n+\t       histogram[i]->time,\n+\t       cumulated_time * 100.0 / overall_time,\n+\t       histogram[i]->size,\n+\t       cumulated_size * 100.0 / overall_size);\n+   }\n+}\n+\n+/* Collect histogram from CFG profiles.  */\n+\n+static void\n+ipa_profile_generate_summary (void)\n+{\n+  struct cgraph_node *node;\n+  gimple_stmt_iterator gsi;\n+  hash_table <histogram_hash> hashtable;\n+  basic_block bb;\n+\n+  hashtable.create (10);\n+  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n+\t\t\t\t      10);\n+  \n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->symbol.decl))\n+      {\n+\tint time = 0;\n+\tint size = 0;\n+        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    time += estimate_num_insns (gsi_stmt (gsi), &eni_time_weights);\n+\t    size += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);\n+\t  }\n+\taccount_time_size (hashtable, histogram, bb->count, time, size);\n+      }\n+  hashtable.dispose ();\n+  histogram.qsort (cmp_counts);\n+}\n+\n+/* Serialize the ipa info for lto.  */\n+\n+static void\n+ipa_profile_write_summary (void)\n+{\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_ipa_profile);\n+  unsigned int i;\n+\n+  streamer_write_uhwi_stream (ob->main_stream, histogram.length());\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      streamer_write_gcov_count_stream (ob->main_stream, histogram[i]->count);\n+      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->time);\n+      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->size);\n+    }\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+/* Deserialize the ipa info for lto.  */\n+\n+static void\n+ipa_profile_read_summary (void)\n+{\n+  struct lto_file_decl_data ** file_data_vec\n+    = lto_get_file_decl_data ();\n+  struct lto_file_decl_data * file_data;\n+  hash_table <histogram_hash> hashtable;\n+  int j = 0;\n+\n+  hashtable.create (10);\n+  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n+\t\t\t\t      10);\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_ipa_profile,\n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{\n+          unsigned int num = streamer_read_uhwi (ib);\n+\t  unsigned int n;\n+\t  for (n = 0; n < num; n++)\n+\t    {\n+\t      gcov_type count = streamer_read_gcov_count (ib);\n+\t      int time = streamer_read_uhwi (ib);\n+\t      int size = streamer_read_uhwi (ib);\n+\t      account_time_size (hashtable, histogram,\n+\t\t\t\t count, time, size);\n+\t    }\n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_ipa_profile,\n+\t\t\t\t\t  ib, data, len);\n+\t}\n+    }\n+  hashtable.dispose ();\n+  histogram.qsort (cmp_counts);\n+}\n \n /* Simple ipa profile pass propagating frequencies across the callgraph.  */\n \n@@ -1051,6 +1252,75 @@ ipa_profile (void)\n   int order_pos;\n   bool something_changed = false;\n   int i;\n+  gcov_type overall_time = 0, cutoff = 0, cumulated = 0, overall_size = 0;\n+\n+  if (dump_file)\n+    dump_histogram (dump_file, histogram);\n+  for (i = 0; i < (int)histogram.length (); i++)\n+    {\n+      overall_time += histogram[i]->count * histogram[i]->time;\n+      overall_size += histogram[i]->size;\n+    }\n+  if (overall_time)\n+    {\n+      gcov_type threshold;\n+\n+      gcc_assert (overall_size);\n+      if (dump_file)\n+\t{\n+\t  gcov_type min, cumulated_time = 0, cumulated_size = 0;\n+\n+\t  fprintf (dump_file, \"Overall time: \"HOST_WIDEST_INT_PRINT_DEC\"\\n\", \n+\t\t   (HOST_WIDEST_INT)overall_time);\n+\t  min = get_hot_bb_threshold ();\n+          for (i = 0; i < (int)histogram.length () && histogram[i]->count >= min;\n+\t       i++)\n+\t    {\n+\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n+\t      cumulated_size += histogram[i]->size;\n+\t    }\n+\t  fprintf (dump_file, \"GCOV min count: \"HOST_WIDEST_INT_PRINT_DEC\n+\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n+\t\t   (HOST_WIDEST_INT)min,\n+\t\t   cumulated_time * 100.0 / overall_time,\n+\t\t   cumulated_size * 100.0 / overall_size);\n+\t}\n+      cutoff = (overall_time * PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE) + 500) / 1000;\n+      threshold = 0;\n+      for (i = 0; cumulated < cutoff; i++)\n+\t{\n+\t  cumulated += histogram[i]->count * histogram[i]->time;\n+          threshold = histogram[i]->count;\n+\t}\n+      if (!threshold)\n+\tthreshold = 1;\n+      if (dump_file)\n+\t{\n+\t  gcov_type cumulated_time = 0, cumulated_size = 0;\n+\n+          for (i = 0;\n+\t       i < (int)histogram.length () && histogram[i]->count >= threshold;\n+\t       i++)\n+\t    {\n+\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n+\t      cumulated_size += histogram[i]->size;\n+\t    }\n+\t  fprintf (dump_file, \"Determined min count: \"HOST_WIDEST_INT_PRINT_DEC\n+\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n+\t\t   (HOST_WIDEST_INT)threshold,\n+\t\t   cumulated_time * 100.0 / overall_time,\n+\t\t   cumulated_size * 100.0 / overall_size);\n+\t}\n+      if (threshold > get_hot_bb_threshold ()\n+\t  || in_lto_p)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Threshold updated.\\n\");\n+          set_hot_bb_threshold (threshold);\n+\t}\n+    }\n+  histogram.release();\n+  free_alloc_pool (histogram_pool);\n \n   order_pos = ipa_reverse_postorder (order);\n   for (i = order_pos - 1; i >= 0; i--)\n@@ -1112,9 +1382,9 @@ struct ipa_opt_pass_d pass_ipa_profile =\n   0,\t\t\t\t\t/* todo_flags_start */\n   0                                     /* todo_flags_finish */\n  },\n- NULL,\t\t\t\t        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n+ ipa_profile_generate_summary,\t        /* generate_summary */\n+ ipa_profile_write_summary,\t\t/* write_summary */\n+ ipa_profile_read_summary,\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* write_optimization_summary */\n  NULL,\t\t\t\t\t/* read_optimization_summary */\n  NULL,\t\t\t\t\t/* stmt_fixup */"}, {"sha": "c619197d5ddf084cc33d08110b54b41776b691c0", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -604,11 +604,11 @@ output_profile_summary (struct lto_simple_output_block *ob)\n          units.  */\n       gcc_assert (profile_info->runs);\n       streamer_write_uhwi_stream (ob->main_stream, profile_info->runs);\n-      streamer_write_uhwi_stream (ob->main_stream, profile_info->sum_max);\n+      streamer_write_gcov_count_stream (ob->main_stream, profile_info->sum_max);\n \n       /* sum_all is needed for computing the working set with the\n          histogram.  */\n-      streamer_write_uhwi_stream (ob->main_stream, profile_info->sum_all);\n+      streamer_write_gcov_count_stream (ob->main_stream, profile_info->sum_all);\n \n       /* Create and output a bitpack of non-zero histogram entries indices.  */\n       bp = bitpack_create (ob->main_stream);\n@@ -620,13 +620,18 @@ output_profile_summary (struct lto_simple_output_block *ob)\n         {\n           if (!profile_info->histogram[h_ix].num_counters)\n             continue;\n-          streamer_write_uhwi_stream (ob->main_stream,\n+          streamer_write_gcov_count_stream (ob->main_stream,\n                                       profile_info->histogram[h_ix].num_counters);\n-          streamer_write_uhwi_stream (ob->main_stream,\n+          streamer_write_gcov_count_stream (ob->main_stream,\n                                       profile_info->histogram[h_ix].min_value);\n-          streamer_write_uhwi_stream (ob->main_stream,\n+          streamer_write_gcov_count_stream (ob->main_stream,\n                                       profile_info->histogram[h_ix].cum_value);\n-        }\n+         }\n+      /* IPA-profile computes hot bb threshold based on cumulated\n+\t whole program profile.  We need to stream it down to ltrans.  */\n+       if (flag_wpa)\n+         streamer_write_gcov_count_stream (ob->main_stream,\n+\t\t\t\t\t   get_hot_bb_threshold ());\n     }\n   else\n     streamer_write_uhwi_stream (ob->main_stream, 0);\n@@ -1259,8 +1264,8 @@ input_profile_summary (struct lto_input_block *ib,\n   if (runs)\n     {\n       file_data->profile_info.runs = runs;\n-      file_data->profile_info.sum_max = streamer_read_uhwi (ib);\n-      file_data->profile_info.sum_all = streamer_read_uhwi (ib);\n+      file_data->profile_info.sum_max = streamer_read_gcov_count (ib);\n+      file_data->profile_info.sum_all = streamer_read_gcov_count (ib);\n \n       memset (file_data->profile_info.histogram, 0,\n               sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n@@ -1279,12 +1284,16 @@ input_profile_summary (struct lto_input_block *ib,\n             continue;\n \n           file_data->profile_info.histogram[h_ix].num_counters\n-              = streamer_read_uhwi (ib);\n+              = streamer_read_gcov_count (ib);\n           file_data->profile_info.histogram[h_ix].min_value\n-              = streamer_read_uhwi (ib);\n+              = streamer_read_gcov_count (ib);\n           file_data->profile_info.histogram[h_ix].cum_value\n-              = streamer_read_uhwi (ib);\n+              = streamer_read_gcov_count (ib);\n         }\n+      /* IPA-profile computes hot bb threshold based on cumulated\n+\t whole program profile.  We need to stream it down to ltrans.  */\n+      if (flag_ltrans)\n+\tset_hot_bb_threshold (streamer_read_gcov_count (ib));\n     }\n \n }"}, {"sha": "0ef421f6167db674a8d0ff13dcd6a3529e9f8a95", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -55,6 +55,7 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"jmpfuncs\",\n   \"pureconst\",\n   \"reference\",\n+  \"profile\",\n   \"symbol_nodes\",\n   \"opts\",\n   \"cgraphopt\","}, {"sha": "95fe33ae1a7c17fe6453e6b9371e31f1553c26cb", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -243,6 +243,7 @@ enum lto_section_type\n   LTO_section_jump_functions,\n   LTO_section_ipa_pure_const,\n   LTO_section_ipa_reference,\n+  LTO_section_ipa_profile,\n   LTO_section_symtab_nodes,\n   LTO_section_opts,\n   LTO_section_cgraph_opt_sum,"}, {"sha": "5394ef587b6f0e953d2d4a78ac7061b7beb6040a", "filename": "gcc/predict.c", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -128,25 +128,42 @@ maybe_hot_frequency_p (struct function *fun, int freq)\n   return true;\n }\n \n+static gcov_type min_count = -1;\n+\n+/* Determine the threshold for hot BB counts.  */\n+\n+gcov_type\n+get_hot_bb_threshold ()\n+{\n+  gcov_working_set_t *ws;\n+  if (min_count == -1)\n+    {\n+      ws = find_working_set (PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE));\n+      gcc_assert (ws);\n+      min_count = ws->min_counter;\n+    }\n+  return min_count;\n+}\n+\n+/* Set the threshold for hot BB counts.  */\n+\n+void\n+set_hot_bb_threshold (gcov_type min)\n+{\n+  min_count = min;\n+}\n+\n /* Return TRUE if frequency FREQ is considered to be hot.  */\n \n static inline bool\n maybe_hot_count_p (struct function *fun, gcov_type count)\n {\n-  gcov_working_set_t *ws;\n-  static gcov_type min_count = -1;\n   if (fun && profile_status_for_function (fun) != PROFILE_READ)\n     return true;\n   /* Code executed at most once is not hot.  */\n   if (profile_info->runs >= count)\n     return false;\n-  if (min_count == -1)\n-    {\n-      ws = find_working_set (PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE));\n-      gcc_assert (ws);\n-      min_count = ws->min_counter;\n-    }\n-  return (count >= min_count);\n+  return (count >= get_hot_bb_threshold ());\n }\n \n /* Return true in case BB can be CPU intensive and should be optimized"}, {"sha": "c7d5f1aa62cdc5a78dca09d4cbfc2b0ad0aa956b", "filename": "gcc/profile.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0208f7dab09ed1ceb3fcfceff049e24cc05d69fa/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=0208f7dab09ed1ceb3fcfceff049e24cc05d69fa", "patch": "@@ -48,4 +48,8 @@ extern void del_node_map (void);\n \n extern void compute_working_sets (void);\n \n+/* In predict.c.  */\n+extern gcov_type get_hot_bb_threshold (void);\n+extern void set_hot_bb_threshold (gcov_type);\n+\n #endif /* PROFILE_H */"}]}