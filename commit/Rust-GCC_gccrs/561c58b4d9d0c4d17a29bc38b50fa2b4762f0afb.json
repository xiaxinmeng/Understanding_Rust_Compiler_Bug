{"sha": "561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxYzU4YjRkOWQwYzRkMTdhMjliYzM4YjUwZmEyYjQ3NjJmMGFmYg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2017-11-29T22:19:25Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2017-11-29T22:19:25Z"}, "message": "re PR rtl-optimization/80818 (LRA clobbers live hard reg clobbered during rematerialization)\n\n2017-11-29  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/80818\n\t* lra.c (collect_non_operand_hard_regs): New arg insn.  Pass it\n\trecursively.  Use insn code for clobber.\n\t(lra_set_insn_recog_data): Pass the new arg to\n\tcollect_non_operand_hard_regs.\n\t(add_regs_to_insn_regno_info): Pass insn instead of uid.  Use insn\n\tcode for clobber.\n\t(lra_update_insn_regno_info): Pass insn to\n\tadd_regs_to_insn_regno_info.\n\nFrom-SVN: r255258", "tree": {"sha": "c54428aef5fb6767ddb65edb4298c7f368b938d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c54428aef5fb6767ddb65edb4298c7f368b938d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08539f3e949c37dcfe6e128d78c527db47cc609d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08539f3e949c37dcfe6e128d78c527db47cc609d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08539f3e949c37dcfe6e128d78c527db47cc609d"}], "stats": {"total": 89, "additions": 55, "deletions": 34}, "files": [{"sha": "8bc4a063697a7f2e74067d673fee1391800607be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "patch": "@@ -1,3 +1,15 @@\n+2017-11-29  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/80818\n+\t* lra.c (collect_non_operand_hard_regs): New arg insn.  Pass it\n+\trecursively.  Use insn code for clobber.\n+\t(lra_set_insn_recog_data): Pass the new arg to\n+\tcollect_non_operand_hard_regs.\n+\t(add_regs_to_insn_regno_info): Pass insn instead of uid.  Use insn\n+\tcode for clobber.\n+\t(lra_update_insn_regno_info): Pass insn to\n+\tadd_regs_to_insn_regno_info.\n+\n 2017-11-29  Jim Wilson  <jimw@sifive.com>\n \t    Andrew Waterman  <andrew@sifive.com>\n "}, {"sha": "f49c50a40362655431393190b059ade94ac5a2aa", "filename": "gcc/lra.c", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=561c58b4d9d0c4d17a29bc38b50fa2b4762f0afb", "patch": "@@ -807,7 +807,8 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n    to LIST.  X is a part of insn given by DATA.\t Return the result\n    list.  */\n static struct lra_insn_reg *\n-collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n+collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n+\t\t\t       lra_insn_recog_data_t data,\n \t\t\t       struct lra_insn_reg *list,\n \t\t\t       enum op_type type, bool early_clobber)\n {\n@@ -881,38 +882,41 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n   switch (code)\n     {\n     case SET:\n-      list = collect_non_operand_hard_regs (&SET_DEST (op), data,\n+      list = collect_non_operand_hard_regs (insn, &SET_DEST (op), data,\n \t\t\t\t\t    list, OP_OUT, false);\n-      list = collect_non_operand_hard_regs (&SET_SRC (op), data,\n+      list = collect_non_operand_hard_regs (insn, &SET_SRC (op), data,\n \t\t\t\t\t    list, OP_IN, false);\n       break;\n     case CLOBBER:\n-      /* We treat clobber of non-operand hard registers as early\n-\t clobber (the behavior is expected from asm).  */\n-      list = collect_non_operand_hard_regs (&XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_OUT, true);\n-      break;\n+      {\n+\tint code = INSN_CODE (insn);\n+\t/* We treat clobber of non-operand hard registers as early\n+\t   clobber (the behavior is expected from asm).  */\n+\tlist = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n+\t\t\t\t\t      list, OP_OUT, code < 0);\n+\tbreak;\n+      }\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n-      list = collect_non_operand_hard_regs (&XEXP (op, 0), data,\n+      list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n \t\t\t\t\t    list, OP_INOUT, false);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n-      list = collect_non_operand_hard_regs (&XEXP (op, 0), data,\n+      list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n \t\t\t\t\t    list, OP_INOUT, false);\n-      list = collect_non_operand_hard_regs (&XEXP (op, 1), data,\n+      list = collect_non_operand_hard_regs (insn, &XEXP (op, 1), data,\n \t\t\t\t\t    list, OP_IN, false);\n       break;\n     default:\n       fmt = GET_RTX_FORMAT (code);\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n-\t    list = collect_non_operand_hard_regs (&XEXP (op, i), data,\n+\t    list = collect_non_operand_hard_regs (insn, &XEXP (op, i), data,\n \t\t\t\t\t\t  list, OP_IN, false);\n \t  else if (fmt[i] == 'E')\n \t    for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n-\t      list = collect_non_operand_hard_regs (&XVECEXP (op, i, j), data,\n-\t\t\t\t\t\t    list, OP_IN, false);\n+\t      list = collect_non_operand_hard_regs (insn, &XVECEXP (op, i, j),\n+\t\t\t\t\t\t    data, list, OP_IN, false);\n \t}\n     }\n   return list;\n@@ -1055,7 +1059,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n     insn_static_data->hard_regs = NULL;\n   else\n     insn_static_data->hard_regs\n-      = collect_non_operand_hard_regs (&PATTERN (insn), data,\n+      = collect_non_operand_hard_regs (insn, &PATTERN (insn), data,\n \t\t\t\t       NULL, OP_IN, false);\n   data->arg_hard_regs = NULL;\n   if (CALL_P (insn))\n@@ -1402,13 +1406,14 @@ lra_get_copy (int n)\n /* This page contains code dealing with info about registers in\n    insns.  */\n \n-/* Process X of insn UID recursively and add info (operand type is\n+/* Process X of INSN recursively and add info (operand type is\n    given by TYPE, flag of that it is early clobber is EARLY_CLOBBER)\n    about registers in X to the insn DATA.  If X can be early clobbered,\n    alternatives in which it can be early clobbered are given by\n    EARLY_CLOBBER_ALTS.  */\n static void\n-add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n+add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n+\t\t\t     rtx_insn *insn,\n \t\t\t     enum op_type type, bool early_clobber,\n \t\t\t     alternative_mask early_clobber_alts)\n {\n@@ -1436,7 +1441,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       /* Process all regs even unallocatable ones as we need info about\n \t all regs for rematerialization pass.  */\n       expand_reg_info ();\n-      if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, uid))\n+      if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, INSN_UID (insn)))\n \t{\n \t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n \t\t\t\t     early_clobber, early_clobber_alts,\n@@ -1471,20 +1476,25 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   switch (code)\n     {\n     case SET:\n-      add_regs_to_insn_regno_info (data, SET_DEST (x), uid, OP_OUT, false, 0);\n-      add_regs_to_insn_regno_info (data, SET_SRC (x), uid, OP_IN, false, 0);\n+      add_regs_to_insn_regno_info (data, SET_DEST (x), insn, OP_OUT, false, 0);\n+      add_regs_to_insn_regno_info (data, SET_SRC (x), insn, OP_IN, false, 0);\n       break;\n     case CLOBBER:\n-      /* We treat clobber of non-operand hard registers as early\n-\t clobber (the behavior is expected from asm).  */\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_OUT, true, ALL_ALTERNATIVES);\n-      break;\n+      {\n+\tint code = INSN_CODE (insn);\n+\n+\t/* We treat clobber of non-operand hard registers as early\n+\t   clobber (the behavior is expected from asm).  */\n+\tadd_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_OUT,\n+\t\t\t\t     code < 0, code < 0 ? ALL_ALTERNATIVES : 0);\n+\tbreak;\n+      }\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, false, 0);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false, 0);\n-      add_regs_to_insn_regno_info (data, XEXP (x, 1), uid, OP_IN, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 1), insn, OP_IN, false, 0);\n       break;\n     default:\n       if ((code != PARALLEL && code != EXPR_LIST) || type != OP_OUT)\n@@ -1505,11 +1515,11 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n-\t    add_regs_to_insn_regno_info (data, XEXP (x, i), uid, type, false, 0);\n+\t    add_regs_to_insn_regno_info (data, XEXP (x, i), insn, type, false, 0);\n \t  else if (fmt[i] == 'E')\n \t    {\n \t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t\tadd_regs_to_insn_regno_info (data, XVECEXP (x, i, j), uid,\n+\t\tadd_regs_to_insn_regno_info (data, XVECEXP (x, i, j), insn,\n \t\t\t\t\t     type, false, 0);\n \t    }\n \t}\n@@ -1585,7 +1595,7 @@ setup_insn_reg_info (lra_insn_recog_data_t data, int freq)\n void\n lra_update_insn_regno_info (rtx_insn *insn)\n {\n-  int i, uid, freq;\n+  int i, freq;\n   lra_insn_recog_data_t data;\n   struct lra_static_insn_data *static_data;\n   enum rtx_code code;\n@@ -1597,14 +1607,13 @@ lra_update_insn_regno_info (rtx_insn *insn)\n   static_data = data->insn_static_data;\n   freq = get_insn_freq (insn);\n   invalidate_insn_data_regno_info (data, insn, freq);\n-  uid = INSN_UID (insn);\n   for (i = static_data->n_operands - 1; i >= 0; i--)\n-    add_regs_to_insn_regno_info (data, *data->operand_loc[i], uid,\n+    add_regs_to_insn_regno_info (data, *data->operand_loc[i], insn,\n \t\t\t\t static_data->operand[i].type,\n \t\t\t\t static_data->operand[i].early_clobber,\n \t\t\t\t static_data->operand[i].early_clobber_alts);\n   if ((code = GET_CODE (PATTERN (insn))) == CLOBBER || code == USE)\n-    add_regs_to_insn_regno_info (data, XEXP (PATTERN (insn), 0), uid,\n+    add_regs_to_insn_regno_info (data, XEXP (PATTERN (insn), 0), insn,\n \t\t\t\t code == USE ? OP_IN : OP_OUT, false, 0);\n   if (CALL_P (insn))\n     /* On some targets call insns can refer to pseudos in memory in\n@@ -1616,7 +1625,7 @@ lra_update_insn_regno_info (rtx_insn *insn)\n \t link = XEXP (link, 1))\n       if (((code = GET_CODE (XEXP (link, 0))) == USE || code == CLOBBER)\n \t  && MEM_P (XEXP (XEXP (link, 0), 0)))\n-\tadd_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), uid,\n+\tadd_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), insn,\n \t\t\t\t     code == USE ? OP_IN : OP_OUT, false, 0);\n   if (NONDEBUG_INSN_P (insn))\n     setup_insn_reg_info (data, freq);"}]}