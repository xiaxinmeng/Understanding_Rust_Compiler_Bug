{"sha": "df3834838116b327a61f5a9e271e54c75ad34085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzODM0ODM4MTE2YjMyN2E2MWY1YTllMjcxZTU0Yzc1YWQzNDA4NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-22T22:02:16Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-22T22:02:16Z"}, "message": "cpperror.c: Fix formatting.\n\n\t* cpperror.c: Fix formatting.\n\t* cppexp.c: Likewise.\n\t* cppfiles.c: Likewise.\n\t* cpphash.c: Likewise.\n\t* cpphash.h: Likewise.\n\t* cppinit.c: Likewise.\n\t* cpplex.c: Likewise.\n\t* cpplib.c: Likewise.\n\t* cppmacro.c: Likewise.\n\t* cppmain.c: Likewise.\n\t* cppspec.c: Likewise.\n\nFrom-SVN: r53751", "tree": {"sha": "d48c115c626bc1be9e16db74afd070b025a875ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48c115c626bc1be9e16db74afd070b025a875ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df3834838116b327a61f5a9e271e54c75ad34085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3834838116b327a61f5a9e271e54c75ad34085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3834838116b327a61f5a9e271e54c75ad34085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3834838116b327a61f5a9e271e54c75ad34085/comments", "author": null, "committer": null, "parents": [{"sha": "2dd36f90d8c4f5b86667cbb11c86f6c790bd784b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd36f90d8c4f5b86667cbb11c86f6c790bd784b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dd36f90d8c4f5b86667cbb11c86f6c790bd784b"}], "stats": {"total": 244, "additions": 129, "deletions": 115}, "files": [{"sha": "7f8208c5367a4e0354602e02e455145732b98d4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -1,3 +1,17 @@\n+2002-05-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cpperror.c: Fix formatting.\n+\t* cppexp.c: Likewise.\n+\t* cppfiles.c: Likewise.\n+\t* cpphash.c: Likewise.\n+\t* cpphash.h: Likewise.\n+\t* cppinit.c: Likewise.\n+\t* cpplex.c: Likewise.\n+\t* cpplib.c: Likewise.\n+\t* cppmacro.c: Likewise.\n+\t* cppmain.c: Likewise.\n+\t* cppspec.c: Likewise.\n+\n 2002-05-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* combine.c (force_to_mode): Use gen_int_mode."}, {"sha": "5ba7f4d798373c07687fab00795ef3565f84a434", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -98,7 +98,7 @@ _cpp_begin_message (pfile, code, line, column)\n       else if (CPP_OPTION (pfile, inhibit_warnings))\n \treturn 0;\n       break;\n-\t\n+\n     case DL_ERROR:\n       if (CPP_OPTION (pfile, inhibit_errors))\n \treturn 0;"}, {"sha": "2d2ce489c0330cc2377b03ade1ca370ded86d9b9", "filename": "gcc/cppexp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -150,7 +150,7 @@ parse_number (pfile, tok)\n \t  || (base == 16 && (c == 'P' || c == 'p')\n \t      && p+1 < end && (p[1] == '+' || p[1] == '-')))\n \tSYNTAX_ERROR (\"floating point numbers are not valid in #if\");\n-  \n+\n       /* Determine the suffix. l means long, and u means unsigned.\n \t See the suffix tables, above.  */\n       switch (end - p)\n@@ -177,7 +177,7 @@ parse_number (pfile, tok)\n \tcpp_error (pfile, DL_PEDWARN,\n \t\t   \"too many 'l' suffixes in integer constant\");\n     }\n-  \n+\n   if (base <= largest_digit)\n     cpp_error (pfile, DL_PEDWARN,\n \t       \"integer constant contains digits beyond the radix\");\n@@ -491,7 +491,7 @@ static const struct operator\n     top->value = PSH (pfile, v1, unsigned1, v2);\n \n /* Parse and evaluate a C expression, reading from PFILE.\n-   Returns the truth value of the expression.  \n+   Returns the truth value of the expression.\n \n    The implementation is an operator precedence parser, i.e. a\n    bottom-up parser, using a stack for not-yet-reduced tokens.\n@@ -631,7 +631,7 @@ _cpp_parse_expr (pfile)\n       /* Check for and handle stack overflow.  */\n       if (++top == pfile->op_limit)\n \ttop = _cpp_expand_op_stack (pfile);\n-      \n+\n       top->op = op.op;\n     }\n "}, {"sha": "85c9b6e5544d7ee5241da3744dd2ac54415d25f4", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -250,7 +250,7 @@ open_file (pfile, filename)\n   /* Don't reopen an idempotent file.  */\n   if (DO_NOT_REREAD (file))\n     return file;\n-      \n+\n   /* Don't reopen one which is already loaded.  */\n   if (file->buffer != NULL)\n     return file;\n@@ -276,7 +276,7 @@ open_file (pfile, filename)\n       /* For DJGPP redirected input is opened in text mode. Change it\n          to binary mode.  */\n       if (! isatty (file->fd))\n-        setmode (file->fd, O_BINARY);\n+\tsetmode (file->fd, O_BINARY);\n #endif\n     }\n   else\n@@ -520,7 +520,7 @@ cpp_included (pfile, fname)\n       nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n       return (nd && nd->value);\n     }\n-      \n+\n   /* Search directory path for the file.  */\n   name = (char *) alloca (strlen (fname) + pfile->max_include_len + 2);\n   for (path = CPP_OPTION (pfile, quote_include); path; path = path->next)\n@@ -712,7 +712,7 @@ _cpp_compare_file_date (pfile, header)\n      const cpp_token *header;\n {\n   struct include_file *inc = find_include_file (pfile, header, 0);\n-  \n+\n   if (inc == NULL || inc == NO_INCLUDE_PATH)\n     return -1;\n \n@@ -721,7 +721,7 @@ _cpp_compare_file_date (pfile, header)\n       close (inc->fd);\n       inc->fd = -1;\n     }\n-    \n+\n   return inc->st.st_mtime > pfile->buffer->inc->st.st_mtime;\n }\n \n@@ -936,7 +936,7 @@ read_name_map (pfile, dirname)\n \t      ptr->map_to[dirlen] = '/';\n \t      strcpy (ptr->map_to + dirlen + 1, to);\n \t      free (to);\n-\t    }\t      \n+\t    }\n \n \t  ptr->map_next = map_list_ptr->map_list_map;\n \t  map_list_ptr->map_list_map = ptr;\n@@ -947,13 +947,13 @@ read_name_map (pfile, dirname)\n \t}\n       fclose (f);\n     }\n-  \n+\n   /* Add this information to the cache.  */\n   map_list_ptr->map_list_next = CPP_OPTION (pfile, map_list);\n   CPP_OPTION (pfile, map_list) = map_list_ptr;\n \n   return map_list_ptr->map_list_map;\n-}  \n+}\n \n /* Remap an unsimplified path NAME based on the file_name_map (if any)\n    for LOC.  */\n@@ -978,10 +978,10 @@ remap_filename (pfile, name, loc)\n       if (! loc->name_map)\n \treturn name;\n     }\n-  \n+\n   /* This works since NAME has not been simplified yet.  */\n   from = name + loc->len + 1;\n-  \n+\n   for (map = loc->name_map; map; map = map->map_next)\n     if (!strcmp (map->map_from, from))\n       return map->map_to;\n@@ -1002,7 +1002,7 @@ remap_filename (pfile, name, loc)\n   memcpy (dir, name, p - name);\n   dir[p - name] = '\\0';\n   from = p + 1;\n-  \n+\n   for (map = read_name_map (pfile, dir); map; map = map->map_next)\n     if (! strcmp (map->map_from, from))\n       return map->map_to;\n@@ -1052,7 +1052,7 @@ remove_component_p (path)\n    nonzero if an error occurred when using stat () or lstat ().  */\n char *\n _cpp_simplify_pathname (path)\n-    char *path;\n+     char *path;\n {\n #ifndef VMS\n   char *from, *to;\n@@ -1068,7 +1068,7 @@ _cpp_simplify_pathname (path)\n   /* Convert all backslashes to slashes.  */\n   for (from = path; *from; from++)\n     if (*from == '\\\\') *from = '/';\n-    \n+\n   /* Skip over leading drive letter if present.  */\n   if (ISALPHA (path[0]) && path[1] == ':')\n     from = to = &path[2];\n@@ -1077,7 +1077,7 @@ _cpp_simplify_pathname (path)\n #else\n   from = to = path;\n #endif\n-    \n+\n   /* Remove redundant leading /s.  */\n   if (*from == '/')\n     {\n@@ -1152,7 +1152,7 @@ _cpp_simplify_pathname (path)\n       if (move_base)\n \tbase = to;\n     }\n-    \n+\n   /* Change the empty string to \".\" so that it is not treated as stdin.\n      Null terminate.  */\n   if (to == path)"}, {"sha": "98d51be0a4c0be6c26a6db02b9cf29dfcd2cb21e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -37,7 +37,7 @@ alloc_node (table)\n      hash_table *table;\n {\n   cpp_hashnode *node;\n-  \n+\n   node = (cpp_hashnode *) obstack_alloc (&table->pfile->hash_ob,\n \t\t\t\t\t sizeof (cpp_hashnode));\n   memset ((PTR) node, 0, sizeof (cpp_hashnode));"}, {"sha": "a059e2b0aac26b4e08912e195a42d5f8c3c97eb8", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -173,7 +173,7 @@ struct lexer_state\n   unsigned char poisoned_ok;\n \n   /* Nonzero to prevent macro expansion.  */\n-  unsigned char prevent_expansion;  \n+  unsigned char prevent_expansion;\n \n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n@@ -338,7 +338,7 @@ struct cpp_reader\n   /* Call backs.  */\n   struct cpp_callbacks cb;\n \n-  /* Identifier hash table.  */ \n+  /* Identifier hash table.  */\n   struct ht *hash_table;\n \n   /* Expression parser stack.  */"}, {"sha": "fd7c88031aec02d72d931c29883a5230b992e217", "filename": "gcc/cppinit.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -303,7 +303,7 @@ remove_dup_dirs (pfile, head)\n   for (cur = head; cur; cur = cur->next)\n     {\n       for (other = head; other != cur; other = other->next)\n-        if (INO_T_EQ (cur->ino, other->ino) && cur->dev == other->dev)\n+\tif (INO_T_EQ (cur->ino, other->ino) && cur->dev == other->dev)\n \t  {\n \t    if (cur->sysp && !other->sysp)\n \t      {\n@@ -419,7 +419,7 @@ set_lang (pfile, lang)\n      enum c_lang lang;\n {\n   const struct lang_flags *l = &lang_defaults[(int) lang];\n-  \n+\n   CPP_OPTION (pfile, lang) = lang;\n \n   CPP_OPTION (pfile, c99)\t\t = l->c99;\n@@ -1013,7 +1013,7 @@ _cpp_maybe_push_include_file (pfile)\n   if (pfile->next_include_file)\n     {\n       struct pending_option *head = *pfile->next_include_file;\n-  \n+\n       while (head && !push_include (pfile, head))\n \thead = head->next;\n \n@@ -1373,10 +1373,10 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t  CPP_OPTION (pfile, help_only) = 1;\n \t  break;\n \tcase OPT_target__help:\n-          /* Print if any target specific options. cpplib has none, but\n+\t  /* Print if any target specific options. cpplib has none, but\n \t     make sure help_only gets set.  */\n \t  CPP_OPTION (pfile, help_only) = 1;\n-          break;\n+\t  break;\n \n \t  /* --version inhibits compilation, -version doesn't. -v means\n \t     verbose and -version.  Historical reasons, don't ask.  */\n@@ -1415,11 +1415,11 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t  CPP_OPTION (pfile, pedantic_errors) = 1;\n \t  /* fall through */\n \tcase OPT_pedantic:\n- \t  CPP_OPTION (pfile, pedantic) = 1;\n+\t  CPP_OPTION (pfile, pedantic) = 1;\n \t  CPP_OPTION (pfile, warn_endif_labels) = 1;\n \t  break;\n \tcase OPT_trigraphs:\n- \t  CPP_OPTION (pfile, trigraphs) = 1;\n+\t  CPP_OPTION (pfile, trigraphs) = 1;\n \t  break;\n \tcase OPT_remap:\n \t  CPP_OPTION (pfile, remap) = 1;\n@@ -1489,13 +1489,13 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t  /* Args to -d specify what parts of macros to dump.\n \t     Silently ignore unrecognised options; they may\n \t     be aimed at the compiler proper.  */\n- \t  {\n+\t  {\n \t    char c;\n \n \t    while ((c = *arg++) != '\\0')\n- \t      switch (c)\n- \t\t{\n- \t\tcase 'M':\n+\t      switch (c)\n+\t\t{\n+\t\tcase 'M':\n \t\t  CPP_OPTION (pfile, dump_macros) = dump_only;\n \t\t  break;\n \t\tcase 'N':\n@@ -1529,7 +1529,7 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \tcase OPT_MF:\n \t  CPP_OPTION (pfile, deps_file) = arg;\n \t  break;\n- \tcase OPT_MP:\n+\tcase OPT_MP:\n \t  CPP_OPTION (pfile, deps_phony_targets) = 1;\n \t  break;\n \tcase OPT_MQ:\n@@ -1575,7 +1575,7 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t  break;\n \tcase OPT_I:           /* Add directory to path for includes.  */\n \t  if (!strcmp (arg, \"-\"))\n- \t    {\n+\t    {\n \t      /* -I- means:\n \t\t Use the preceding -I directories for #include \"...\"\n \t\t but not #include <...>.\n@@ -1595,8 +1595,8 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t\t  cpp_error (pfile, DL_FATAL, \"-I- specified twice\");\n \t\t  return argc;\n \t\t}\n- \t    }\n- \t  else\n+\t    }\n+\t  else\n \t    append_include_chain (pfile, xstrdup (arg), BRACKET, 0);\n \t  break;\n \tcase OPT_isystem:\n@@ -1701,7 +1701,7 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t  else if (! ignore)\n \t    return i;\n \t  break;\n- \t}\n+\t}\n     }\n   return i + 1;\n }"}, {"sha": "2baa3e00a0260a66d18df6badaa3fda8496b6a2c", "filename": "gcc/cpplex.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -71,7 +71,7 @@ static void adjust_column PARAMS ((cpp_reader *));\n static int skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n static uchar *parse_slow PARAMS ((cpp_reader *, const uchar *, int,\n-\t\t\t\t   unsigned int *));\n+\t\t\t\t  unsigned int *));\n static void parse_number PARAMS ((cpp_reader *, cpp_string *, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const uchar *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n@@ -247,7 +247,7 @@ get_effective_char (pfile)\n   if (__builtin_expect (next == '?' || next == '\\\\', 0))\n     next = skip_escaped_newlines (pfile);\n \n-   return next;\n+  return next;\n }\n \n /* Skip a C-style block comment.  We find the end of the comment by\n@@ -424,7 +424,7 @@ name_p (pfile, string)\n     if (!is_idchar (string->text[i]))\n       return 0;\n \n-  return 1;  \n+  return 1;\n }\n \n /* Parse an identifier, skipping embedded backslash-newlines.  This is\n@@ -533,15 +533,15 @@ parse_slow (pfile, cur, number_p, plen)\n \n       /* Handle normal identifier characters in this loop.  */\n       do\n-        {\n+\t{\n \t  prevc = c;\n-          obstack_1grow (stack, c);\n+\t  obstack_1grow (stack, c);\n \n-          if (c == '$')\n-            saw_dollar++;\n+\t  if (c == '$')\n+\t    saw_dollar++;\n \n-          c = *buffer->cur++;\n-        }\n+\t  c = *buffer->cur++;\n+\t}\n       while (is_idchar (c));\n     }\n \n@@ -665,7 +665,7 @@ parse_string (pfile, token, terminator)\n       if (char_len == -1)\n \t{\n \t  cpp_error (pfile, DL_WARNING,\n-\t\t       \"ignoring invalid multibyte character\");\n+\t\t     \"ignoring invalid multibyte character\");\n \t  char_len = 1;\n \t  c = *buffer->cur++;\n \t}\n@@ -739,7 +739,7 @@ save_comment (pfile, token, from, type)\n {\n   unsigned char *buffer;\n   unsigned int len, clen;\n-  \n+\n   len = pfile->buffer->cur - from + 1; /* + 1 for the initial '/'.  */\n \n   /* C++ comments probably (not definitely) have moved past a new\n@@ -756,7 +756,7 @@ save_comment (pfile, token, from, type)\n   clen = (pfile->state.in_directive && type == '/') ? len + 2 : len;\n \n   buffer = _cpp_unaligned_alloc (pfile, clen);\n-  \n+\n   token->type = CPP_COMMENT;\n   token->val.str.len = clen;\n   token->val.str.text = buffer;\n@@ -888,7 +888,7 @@ continue_after_nul (pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   bool more = false;\n-  \n+\n   buffer->saved_flags = BOL;\n   if (CPP_OPTION (pfile, traditional))\n     more = _cpp_read_logical_line_trad (pfile);\n@@ -1029,19 +1029,19 @@ _cpp_lex_direct (pfile)\n \n     case 'L':\n       /* 'L' may introduce wide characters or strings.  */\n-\t{\n-\t  const unsigned char *pos = buffer->cur;\n+      {\n+\tconst unsigned char *pos = buffer->cur;\n \n-\t  c = get_effective_char (pfile);\n-\t  if (c == '\\'' || c == '\"')\n-\t    {\n-\t      result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n-\t      parse_string (pfile, result, c);\n-\t      break;\n-\t    }\n-\t  buffer->cur = pos;\n-\t}\n-\t/* Fall through.  */\n+\tc = get_effective_char (pfile);\n+\tif (c == '\\'' || c == '\"')\n+\t  {\n+\t    result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n+\t    parse_string (pfile, result, c);\n+\t    break;\n+\t  }\n+\tbuffer->cur = pos;\n+      }\n+      /* Fall through.  */\n \n     start_ident:\n     case '_':\n@@ -1091,7 +1091,7 @@ _cpp_lex_direct (pfile)\n \t      && ! buffer->warned_cplusplus_comments)\n \t    {\n \t      cpp_error (pfile, DL_PEDWARN,\n-\t\t\t   \"C++ style comments are not allowed in ISO C89\");\n+\t\t\t \"C++ style comments are not allowed in ISO C89\");\n \t      cpp_error (pfile, DL_PEDWARN,\n \t\t\t \"(this will be reported only once per input file)\");\n \t      buffer->warned_cplusplus_comments = 1;\n@@ -1274,7 +1274,7 @@ _cpp_lex_direct (pfile)\n \t  result->type = CPP_AND;\n \t}\n       break;\n-\t  \n+\n     case '|':\n       c = get_effective_char (pfile);\n       if (c == '|')\n@@ -1381,7 +1381,7 @@ cpp_spell_token (pfile, token, buffer)\n \t  goto spell_ident;\n \telse\n \t  spelling = TOKEN_NAME (token);\n-\t\n+\n \twhile ((c = *spelling++) != '\\0')\n \t  *buffer++ = c;\n       }\n@@ -1789,7 +1789,7 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n \t\t   \"non-ISO-standard escape sequence, '\\\\%c'\", (int) c);\n       c = TARGET_ESC;\n       break;\n-      \n+\n     case 'u': case 'U':\n       unknown = maybe_read_ucs (pfile, &str, limit, &c);\n       break;\n@@ -1799,33 +1799,33 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n \tcpp_error (pfile, DL_WARNING,\n \t\t   \"the meaning of '\\\\x' is different in traditional C\");\n \n-\t{\n-\t  cppchar_t i = 0, overflow = 0;\n-\t  int digits_found = 0;\n+      {\n+\tcppchar_t i = 0, overflow = 0;\n+\tint digits_found = 0;\n \n-\t  while (str < limit)\n-\t    {\n-\t      c = *str;\n-\t      if (! ISXDIGIT (c))\n-\t\tbreak;\n-\t      str++;\n-\t      overflow |= i ^ (i << 4 >> 4);\n-\t      i = (i << 4) + hex_digit_value (c);\n-\t      digits_found = 1;\n-\t    }\n+\twhile (str < limit)\n+\t  {\n+\t    c = *str;\n+\t    if (! ISXDIGIT (c))\n+\t      break;\n+\t    str++;\n+\t    overflow |= i ^ (i << 4 >> 4);\n+\t    i = (i << 4) + hex_digit_value (c);\n+\t    digits_found = 1;\n+\t  }\n \n-\t  if (!digits_found)\n-\t    cpp_error (pfile, DL_ERROR, \n+\tif (!digits_found)\n+\t  cpp_error (pfile, DL_ERROR,\n \t\t       \"\\\\x used with no following hex digits\");\n \n-\t  if (overflow | (i != (i & mask)))\n-\t    {\n-\t      cpp_error (pfile, DL_PEDWARN,\n-\t\t\t \"hex escape sequence out of range\");\n-\t      i &= mask;\n-\t    }\n-\t  c = i;\n-\t}\n+\tif (overflow | (i != (i & mask)))\n+\t  {\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"hex escape sequence out of range\");\n+\t    i &= mask;\n+\t  }\n+\tc = i;\n+      }\n       break;\n \n     case '0':  case '1':  case '2':  case '3':\n@@ -1949,7 +1949,7 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n       if (ISPRINT (c))\n \tc = MAP_CHARACTER (c);\n #endif\n-      \n+\n       chars_seen++;\n \n       /* Truncate the character, scale the result and merge the two.  */"}, {"sha": "df33af8d00269e95f208a2e6d45a22d8db303d64", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -400,8 +400,8 @@ _cpp_handle_directive (pfile, indented)\n \t requested to expand comments into macros, then re-enable\n \t saving of comments.  */\n       if (dir == &dtable[T_DEFINE])\n-        pfile->state.save_comments =\n-          ! CPP_OPTION (pfile, discard_comments_in_macro_exp);\n+\tpfile->state.save_comments =\n+\t  ! CPP_OPTION (pfile, discard_comments_in_macro_exp);\n \n       pfile->directive = dir;\n       (*pfile->directive->handler) (pfile);\n@@ -514,7 +514,7 @@ static void\n do_undef (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_hashnode *node = lex_macro_node (pfile);  \n+  cpp_hashnode *node = lex_macro_node (pfile);\n \n   /* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified identifier\n      is not currently defined as a macro name.  */\n@@ -787,7 +787,7 @@ do_line (pfile)\n \t\t \"\\\"%s\\\" after #line is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n-    }      \n+    }\n \n   if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n     cpp_error (pfile, DL_PEDWARN, \"line number out of range\");\n@@ -839,7 +839,7 @@ do_linemarker (pfile)\n       cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" after # is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n-    }      \n+    }\n \n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n@@ -1112,7 +1112,7 @@ do_pragma_once (pfile)\n      cpp_reader *pfile;\n {\n   cpp_error (pfile, DL_WARNING, \"#pragma once is obsolete\");\n- \n+\n   if (pfile->buffer->prev == NULL)\n     cpp_error (pfile, DL_WARNING, \"#pragma once in main file\");\n   else\n@@ -1187,7 +1187,7 @@ do_pragma_dependency (pfile)\n {\n   const cpp_token *header;\n   int ordering;\n- \n+\n   header = parse_include (pfile);\n   if (!header)\n     return;\n@@ -1664,7 +1664,7 @@ do_assert (pfile)\n {\n   struct answer *new_answer;\n   cpp_hashnode *node;\n-  \n+\n   node = parse_assertion (pfile, &new_answer, T_ASSERT);\n   if (node)\n     {\n@@ -1698,7 +1698,7 @@ do_unassert (pfile)\n {\n   cpp_hashnode *node;\n   struct answer *answer;\n-  \n+\n   node = parse_assertion (pfile, &answer, T_UNASSERT);\n   /* It isn't an error to #unassert something that isn't asserted.  */\n   if (node && node->type == NT_ASSERTION)\n@@ -1739,7 +1739,7 @@ cpp_define (pfile, str)\n   char *buf, *p;\n   size_t count;\n \n-  /* Copy the entire option so we can modify it. \n+  /* Copy the entire option so we can modify it.\n      Change the first \"=\" in the string to a space.  If there is none,\n      tack \" 1\" on the end.  */\n \n@@ -1794,7 +1794,7 @@ cpp_unassert (pfile, str)\n      const char *str;\n {\n   handle_assertion (pfile, str, T_UNASSERT);\n-}  \n+}\n \n /* Common code for cpp_assert (-A) and cpp_unassert (-A-).  */\n static void"}, {"sha": "40a9a0780453188933e265017edf25880f1e9627", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -569,7 +569,7 @@ collect_args (pfile, node)\n \t the invocation at all.\n \t e.g. #define debug(format, args...) something\n \t debug(\"string\");\n-\t \n+\n \t This is exactly the same as if there had been an empty rest\n \t argument - debug(\"string\", ).  */\n \n@@ -1035,7 +1035,7 @@ cpp_get_token (pfile)\n \n       if (node->type != NT_MACRO || (result->flags & NO_EXPAND))\n \tbreak;\n-      \n+\n       if (!(node->flags & NODE_DISABLED))\n \t{\n \t  if (!pfile->state.prevent_expansion\n@@ -1480,7 +1480,7 @@ check_trad_stringification (pfile, macro, string)\n {\n   unsigned int i, len;\n   const uchar *p, *q, *limit = string->text + string->len;\n-  \n+\n   /* Loop over the string.  */\n   for (p = string->text; p < limit; p = q)\n     {\n@@ -1584,9 +1584,9 @@ cpp_macro_definition (pfile, node)\n \t    }\n \n \t  if (i + 1 < macro->paramc)\n-            /* Don't emit a space after the comma here; we're trying\n-               to emit a Dwarf-friendly definition, and the Dwarf spec\n-               forbids spaces in the argument list.  */\n+\t    /* Don't emit a space after the comma here; we're trying\n+\t       to emit a Dwarf-friendly definition, and the Dwarf spec\n+\t       forbids spaces in the argument list.  */\n \t    *buffer++ = ',';\n \t  else if (macro->variadic)\n \t    *buffer++ = '.', *buffer++ = '.', *buffer++ = '.';"}, {"sha": "b04e86f2695a89b3c6004aa2d0bba923cb068193", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -78,7 +78,7 @@ cpp_preprocess_file (pfile)\n   print.printed = 0;\n   print.prev = 0;\n   print.map = 0;\n-  \n+\n   /* Open the output now.  We must do so even if no_output is on,\n      because there may be other output than from the actual\n      preprocessing (e.g. from -dM).  */\n@@ -264,7 +264,7 @@ print_line (map, line, special_flags)\n       size_t to_file_len = strlen (map->to_file);\n       unsigned char *to_file_quoted = alloca (to_file_len * 4 + 1);\n       unsigned char *p;\n-      \n+\n       /* cpp_quote_string does not nul-terminate, so we have to do it\n \t ourselves.  */\n       p = cpp_quote_string (to_file_quoted,"}, {"sha": "ee19b7226350f787a56163fe5008ea5db5adbde7", "filename": "gcc/cppspec.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3834838116b327a61f5a9e271e54c75ad34085/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=df3834838116b327a61f5a9e271e54c75ad34085", "patch": "@@ -90,7 +90,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n   /* Have we seen an input file? */\n   int seen_input = 0;\n-  \n+\n   /* Positions to insert -xc, -xassembler-with-cpp, and -o, if necessary.\n      0 means unnecessary.  */\n   int lang_c_here = 0;\n@@ -99,7 +99,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n   /* Do we need to fix up an input file with an unrecognized suffix? */\n   int need_fixups = 1;\n-  \n+\n   int i, j, quote = 0;\n   const char **new_argv;\n   int new_argc;\n@@ -117,7 +117,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t  quote = 0;\n \t  continue;\n \t}\n-      \n+\n       if (argv[i][0] == '-')\n \t{\n \t  if (argv[i][1] == '\\0')\n@@ -228,7 +228,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   new_argv[j] = NULL;\n   *in_argc = new_argc;\n   *in_argv = new_argv;\n-} \n+}\n \n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n int lang_specific_pre_link ()"}]}