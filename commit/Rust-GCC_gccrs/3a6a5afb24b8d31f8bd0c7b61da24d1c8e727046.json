{"sha": "3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E2YTVhZmIyNGI4ZDMxZjhiZDBjN2I2MWRhMjRkMWM4ZTcyNzA0Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-12-08T23:39:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-12-08T23:39:20Z"}, "message": "combine.c (setup_incoming_promotions): Fix sign-extend of zero-extend case; tidy conditions.\n\n        * combine.c (setup_incoming_promotions): Fix sign-extend of\n        zero-extend case; tidy conditions.\n\nFrom-SVN: r155095", "tree": {"sha": "03a371ed0efdfeaa97c661a2f063a8779fa112b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03a371ed0efdfeaa97c661a2f063a8779fa112b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046/comments", "author": null, "committer": null, "parents": [{"sha": "6c6859a104d22fceff987192c2bc3ffa4c7783f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6859a104d22fceff987192c2bc3ffa4c7783f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6859a104d22fceff987192c2bc3ffa4c7783f0"}], "stats": {"total": 67, "additions": 38, "deletions": 29}, "files": [{"sha": "b32aa3d11f4007bb2c3e9c0e33dba6995306f844", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "patch": "@@ -1,3 +1,8 @@\n+2009-12-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* combine.c (setup_incoming_promotions): Fix sign-extend of\n+\tzero-extend case; tidy conditions.\n+\n 2009-12-08  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/38474"}, {"sha": "2c60ae5640fb8c58090e26feaf71376e049c7bf6", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3a6a5afb24b8d31f8bd0c7b61da24d1c8e727046", "patch": "@@ -1343,7 +1343,7 @@ setup_incoming_promotions (rtx first)\n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n     {\n-      rtx reg = DECL_INCOMING_RTL (arg);\n+      rtx x, reg = DECL_INCOMING_RTL (arg);\n       int uns1, uns3;\n       enum machine_mode mode1, mode2, mode3, mode4;\n \n@@ -1375,34 +1375,38 @@ setup_incoming_promotions (rtx first)\n       /* The mode of the register in which the argument is being passed.  */\n       mode4 = GET_MODE (reg);\n \n-      /* Eliminate sign extensions in the callee when possible.  Only\n-         do this when:\n-\t (a) A mode promotion has occurred;\n-\t (b) The mode of the register is the same as the mode of\n-\t     the argument as it is passed; and\n-\t (c) Either there's no language level extension, or the extension\n-\t     from source to end result is valid.  The later case is true\n-\t     when the signedness of the extensions match, or when the \n-\t     language level extension is unsigned.  In the later case,\n-\t     a zero extension followed by a sign extension is the same\n-\t     as one big zero extension.\n-\t (d) When no language-level promotions (which we cannot guarantee\n-\t     will have been done by an external caller) are necessary,\n-\t     unless we know that this function is only ever called from\n-\t     the current compilation unit -- all of whose call sites will\n-\t     do the mode1 --> mode2 promotion.  */\n-      if (mode1 != mode3\n-          && mode3 == mode4\n-\t  && (mode1 == mode2 || ((uns1 || !uns3) && strictly_local)))\n-        {\n-\t  /* Record that the value was promoted from mode1 to mode3,\n-\t     so that any sign extension at the head of the current\n-\t     function may be eliminated.  */\n-\t  rtx x;\n-\t  x = gen_rtx_CLOBBER (mode1, const0_rtx);\n-\t  x = gen_rtx_fmt_e ((uns3 ? ZERO_EXTEND : SIGN_EXTEND), mode3, x);\n-\t  record_value_for_reg (reg, first, x);\n-\t}\n+      /* Eliminate sign extensions in the callee when:\n+\t (a) A mode promotion has occurred;  */\n+      if (mode1 == mode3)\n+\tcontinue;\n+      /* (b) The mode of the register is the same as the mode of\n+\t     the argument as it is passed; */\n+      if (mode3 != mode4)\n+\tcontinue;\n+      /* (c) There's no language level extension;  */\n+      if (mode1 == mode2)\n+\t;\n+      /* (c.1) All callers are from the current compilation unit.  If that's\n+\t the case we don't have to rely on an ABI, we only have to know\n+\t what we're generating right now, and we know that we will do the\n+\t mode1 to mode2 promotion with the given sign.  */\n+      else if (!strictly_local)\n+\tcontinue;\n+      /* (c.2) The combination of the two promotions is useful.  This is\n+\t true when the signs match, or if the first promotion is unsigned.\n+\t In the later case, (sign_extend (zero_extend x)) is the same as\n+\t (zero_extend (zero_extend x)), so make sure to force UNS3 true.  */\n+      else if (uns1)\n+\tuns3 = true;\n+      else if (uns3)\n+\tcontinue;\n+\n+      /* Record that the value was promoted from mode1 to mode3,\n+\t so that any sign extension at the head of the current\n+\t function may be eliminated.  */\n+      x = gen_rtx_CLOBBER (mode1, const0_rtx);\n+      x = gen_rtx_fmt_e ((uns3 ? ZERO_EXTEND : SIGN_EXTEND), mode3, x);\n+      record_value_for_reg (reg, first, x);\n     }\n }\n "}]}