{"sha": "f444e36b2dc2956e620d60257116379647ed886c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ0NGUzNmIyZGMyOTU2ZTYyMGQ2MDI1NzExNjM3OTY0N2VkODg2Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-09-12T06:46:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-09-12T06:46:00Z"}, "message": "c-common.h (genrtl_clear_out_block): Remove.\n\n\t* c-common.h (genrtl_clear_out_block): Remove.\n\t* c-semantics.c (genrtl_clear_out_block): Remove.\n\t(genrtl_while_stmt): Don't call it.\n\t(genrtl_for_stmt): Likewise.\n\n\t* cp-tree.h (struct saved_scope): Remove x_function_parms.\n\t(current_function_parms): Don't define.\n\t(struct cp_language_function): Remove parms_stored.\n\t(current_function_just_assigned_this): Don't define.\n\t(current_function_parms_stored): Likewise.\n\t(static_ctors): Declare.\n\t(static_dtors): Likewise.\n\t(SF_EXPAND): Don't define.\n\t(expand_start_early_try_stmts): Remove declaration.\n\t(store_parm_decls): Likewise.\n\t* decl.c (static_ctors): Don't declare.\n\t(static_dtors): Likewise.\n\t(struct binding_level): Remove this_block.\n\t(poplevel): Remove dead code.\n\t(set_block): Likewise.\n\t(mark_binding_level): Don't mark this_block.\n\t(mark_saved_scope): Don't mark x_function_parms.\n\t(init_decl_processing): Don't add current_function_parms as a GC\n\troot.\n\t(check_function_type): Change prototype.\n\t(start_function): Remove RTL-generation code.\n\t(expand_start_early_try_stmts): Remove.\n\t(store_parm_decls): Give it internal linkage.  Remove\n\tRTL-generation code.\n\t(finish_function): Remove RTL-generation code.\n\t* decl2.c (static_ctors): Fix formatting.\n\t(static_dtors): Likewise.\n\t* method.c (use_thunk): Don't call store_parm_decls.\n\t(synthesize_method): Likewise.\n\t* optimize.c (maybe_clone_body): Likewise.\n\t* parse.y (fn.def2): Likewise.\n\t(.set_base_init): Likewise.\n\t(nodecls): Likewise.\n\t* pt.c (instantiate_decl): Likewise.\n\t* rtti.c (synthesize_tinfo_fn): Likewise.\n\t* semantics.c (genrtl_try_block): Simplify.\n\t(expand_body): Use genrtl_start_function and\n\tgenrtl_finish_function.\n\t(genrtl_start_function): New function.\n\t(genrtl_finish_function): Likewise.\n\nFrom-SVN: r36350", "tree": {"sha": "48e27599dd31176197bc0261eb53a641f597be0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e27599dd31176197bc0261eb53a641f597be0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f444e36b2dc2956e620d60257116379647ed886c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f444e36b2dc2956e620d60257116379647ed886c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f444e36b2dc2956e620d60257116379647ed886c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f444e36b2dc2956e620d60257116379647ed886c/comments", "author": null, "committer": null, "parents": [{"sha": "484d9e58a414a2675e9130abdccf58f64f4c259c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/484d9e58a414a2675e9130abdccf58f64f4c259c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/484d9e58a414a2675e9130abdccf58f64f4c259c"}], "stats": {"total": 841, "additions": 412, "deletions": 429}, "files": [{"sha": "fff0a3152e8af3d089bdf2c988c5c0954bdd9236", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -1,3 +1,10 @@\n+2000-09-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (genrtl_clear_out_block): Remove.\n+\t* c-semantics.c (genrtl_clear_out_block): Remove.\n+\t(genrtl_while_stmt): Don't call it.\n+\t(genrtl_for_stmt): Likewise.\n+\n 2000-09-11  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppfiles.c: Move all default-#defines to top of file."}, {"sha": "389f32a32333bcb3b78bc267fb7b3c08ecc17a10", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -570,7 +570,6 @@ enum c_tree_code {\n \n extern void add_c_tree_codes\t\t        PARAMS ((void));\n extern void genrtl_do_pushlevel                 PARAMS ((void));\n-extern void genrtl_clear_out_block              PARAMS ((void));\n extern void genrtl_goto_stmt                    PARAMS ((tree));\n extern void genrtl_expr_stmt                    PARAMS ((tree));\n extern void genrtl_decl_stmt                    PARAMS ((tree));"}, {"sha": "756c40fd5581db31b0c15255b06ba99189656e57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -1,3 +1,46 @@\n+2000-09-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (struct saved_scope): Remove x_function_parms.\n+\t(current_function_parms): Don't define.\n+\t(struct cp_language_function): Remove parms_stored.\n+\t(current_function_just_assigned_this): Don't define.\n+\t(current_function_parms_stored): Likewise.\n+\t(static_ctors): Declare.\n+\t(static_dtors): Likewise.\n+\t(SF_EXPAND): Don't define.\n+\t(expand_start_early_try_stmts): Remove declaration.\n+\t(store_parm_decls): Likewise.\n+\t* decl.c (static_ctors): Don't declare.\n+\t(static_dtors): Likewise.\n+\t(struct binding_level): Remove this_block.\n+\t(poplevel): Remove dead code.\n+\t(set_block): Likewise.\n+\t(mark_binding_level): Don't mark this_block.\n+\t(mark_saved_scope): Don't mark x_function_parms.\n+\t(init_decl_processing): Don't add current_function_parms as a GC\n+\troot.\n+\t(check_function_type): Change prototype.\n+\t(start_function): Remove RTL-generation code.\n+\t(expand_start_early_try_stmts): Remove.\n+\t(store_parm_decls): Give it internal linkage.  Remove\n+\tRTL-generation code.\n+\t(finish_function): Remove RTL-generation code.\n+\t* decl2.c (static_ctors): Fix formatting.\n+\t(static_dtors): Likewise.\n+\t* method.c (use_thunk): Don't call store_parm_decls.\n+\t(synthesize_method): Likewise.\n+\t* optimize.c (maybe_clone_body): Likewise.\n+\t* parse.y (fn.def2): Likewise.\n+\t(.set_base_init): Likewise.\n+\t(nodecls): Likewise.\n+\t* pt.c (instantiate_decl): Likewise.\n+\t* rtti.c (synthesize_tinfo_fn): Likewise.\n+\t* semantics.c (genrtl_try_block): Simplify.\n+\t(expand_body): Use genrtl_start_function and\n+\tgenrtl_finish_function.\n+\t(genrtl_start_function): New function.\n+\t(genrtl_finish_function): Likewise.\n+\n 2000-09-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* error.c (cp_tree_printer, case 'P'): Append break."}, {"sha": "de76e5293f5d26d45512a74b531294112f9c05e5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -792,7 +792,6 @@ struct saved_scope {\n   varray_type lang_base;\n   tree *lang_stack;\n   tree lang_name;\n-  tree x_function_parms;\n   tree template_parms;\n   tree x_previous_class_type;\n   tree x_previous_class_values;\n@@ -841,7 +840,6 @@ struct saved_scope {\n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */\n \n-#define current_function_parms scope_chain->x_function_parms\n #define current_template_parms scope_chain->template_parms\n \n #define processing_template_decl scope_chain->x_processing_template_decl\n@@ -889,7 +887,6 @@ struct cp_language_function\n \n   int returns_value;\n   int returns_null;\n-  int parms_stored;\n   int in_function_try_handler;\n   int x_expanding_p;\n   int name_declared;\n@@ -956,12 +953,6 @@ struct cp_language_function\n \n #define current_function_returns_null cp_function_chain->returns_null\n \n-#define current_function_just_assigned_this \\\n-  cp_function_chain->just_assigned_this\n-\n-#define current_function_parms_stored \\\n-  cp_function_chain->parms_stored\n-\n /* Nonzero if we have already generated code to initialize virtual\n    function tables in this function.  */\n \n@@ -3509,6 +3500,11 @@ extern int flag_inline_trees;\n \n extern int at_eof;\n \n+/* Functions called along with real static constructors and destructors.  */\n+\n+extern tree static_ctors;\n+extern tree static_dtors;\n+\n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n /* Some macros for char-based bitfields.  */\n@@ -3637,8 +3633,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \t\t\t\t   already been parsed.  */\n #define SF_INCLASS_INLINE    2  /* The function is an inline, defined\n \t\t\t\t   in the class body.  */\n-#define SF_EXPAND            4  /* Generate RTL for this function.  */\n-\n \n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, or if TYPE2\n    is derived from TYPE1, or if TYPE2 is a pointer (reference) to a\n@@ -3905,8 +3899,6 @@ extern tree start_enum\t\t\t\tPARAMS ((tree));\n extern tree finish_enum\t\t\t\tPARAMS ((tree));\n extern void build_enumerator\t\t\tPARAMS ((tree, tree, tree));\n extern int start_function\t\t\tPARAMS ((tree, tree, tree, int));\n-extern void expand_start_early_try_stmts\tPARAMS ((void));\n-extern void store_parm_decls\t\t\tPARAMS ((void));\n extern tree finish_function\t\t\tPARAMS ((int));\n extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n extern tree finish_method\t\t\tPARAMS ((tree));"}, {"sha": "78a2f760fdf76a04f40146fa1e48ca04b6981c57", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 67, "deletions": 387, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -46,8 +46,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern int current_class_depth;\n \n-extern tree static_ctors, static_dtors;\n-\n extern tree global_namespace;\n \n extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n@@ -163,7 +161,7 @@ static void mark_saved_scope PARAMS ((void *));\n static void mark_lang_function PARAMS ((struct cp_language_function *));\n static void mark_stmt_tree PARAMS ((stmt_tree));\n static void save_function_data PARAMS ((tree));\n-static void check_function_type PARAMS ((tree));\n+static void check_function_type PARAMS ((tree, tree));\n static void destroy_local_var PARAMS ((tree));\n static void finish_constructor_body PARAMS ((void));\n static void finish_destructor_body PARAMS ((void));\n@@ -179,6 +177,7 @@ static tree check_special_function_return_type\n static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n static int case_compare PARAMS ((splay_tree_key, splay_tree_key));\n+static void store_parm_decls PARAMS ((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PARAMS ((void));\n@@ -447,10 +446,6 @@ struct binding_level\n        that were entered and exited one level down.  */\n     tree blocks;\n \n-    /* The BLOCK node for this level, if one has been preallocated.\n-       If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n-    tree this_block;\n-\n     /* The _TYPE node for this level, if parm_flag == 2.  */\n     tree this_class;\n \n@@ -1288,7 +1283,6 @@ poplevel (keep, reverse, functionbody)\n   tree subblocks;\n   tree block = NULL_TREE;\n   tree decl;\n-  int block_previously_created;\n   int leaving_for_scope;\n \n   if (cfun && !doing_semantic_analysis_p ())\n@@ -1396,34 +1390,12 @@ poplevel (keep, reverse, functionbody)\n      or if this level is a function body,\n      create a BLOCK to record them for the life of this function.  */\n   block = NULL_TREE;\n-  block_previously_created = (current_binding_level->this_block != NULL_TREE);\n-  if (block_previously_created)\n-    block = current_binding_level->this_block;\n-  else if (keep == 1 || functionbody)\n+  if (keep == 1 || functionbody)\n     block = make_node (BLOCK);\n   if (block != NULL_TREE)\n     {\n-      if (block_previously_created)\n-\t{\n-\t  if (decls || tags || subblocks)\n-\t    {\n-\t      if (BLOCK_VARS (block))\n-\t\twarning (\"internal compiler error: debugging info corrupted\");\n-\n-\t      BLOCK_VARS (block) = decls;\n-\n-\t      /* We can have previous subblocks and new subblocks when\n-\t\t doing fixup_gotos with complex cleanups.  We chain the new\n-\t\t subblocks onto the end of any pre-existing subblocks.  */\n-\t      BLOCK_SUBBLOCKS (block) = chainon (BLOCK_SUBBLOCKS (block),\n-\t\t\t\t\t\t subblocks);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  BLOCK_VARS (block) = decls;\n-\t  BLOCK_SUBBLOCKS (block) = subblocks;\n-\t}\n+      BLOCK_VARS (block) = decls;\n+      BLOCK_SUBBLOCKS (block) = subblocks;\n     }\n \n   /* In each subblock, record that this is its superior.  */\n@@ -1574,11 +1546,9 @@ poplevel (keep, reverse, functionbody)\n   if (functionbody)\n     DECL_INITIAL (current_function_decl) = block;\n   else if (block)\n-    {\n-      if (!block_previously_created)\n-        current_binding_level->blocks\n-          = chainon (current_binding_level->blocks, block);\n-    }\n+    current_binding_level->blocks\n+      = chainon (current_binding_level->blocks, block);\n+\n   /* If we did not make a block for the level just exited,\n      any blocks made for inner levels\n      (since they cannot be recorded as subblocks in that level)\n@@ -1655,9 +1625,11 @@ insert_block (block)\n \n void\n set_block (block)\n-    register tree block;\n+    tree block ATTRIBUTE_UNUSED;\n {\n-  current_binding_level->this_block = block;\n+  /* The RTL expansion machinery requires us to provide this callback,\n+     but it is not applicable in function-at-a-time mode.  */\n+  my_friendly_assert (cfun && !doing_semantic_analysis_p (), 20000911);\n }\n \n /* Do a pushlevel for class declarations.  */\n@@ -2011,7 +1983,6 @@ mark_binding_level (arg)\n       ggc_mark_tree (lvl->type_shadowed);\n       ggc_mark_tree (lvl->shadowed_labels);\n       ggc_mark_tree (lvl->blocks);\n-      ggc_mark_tree (lvl->this_block);\n       ggc_mark_tree (lvl->this_class);\n       ggc_mark_tree (lvl->incomplete);\n       ggc_mark_tree (lvl->dead_vars_from_for);\n@@ -2469,7 +2440,6 @@ mark_saved_scope (arg)\n       if (t->lang_base)\n \tggc_mark_tree_varray (t->lang_base);\n       ggc_mark_tree (t->lang_name);\n-      ggc_mark_tree (t->x_function_parms);\n       ggc_mark_tree (t->template_parms);\n       ggc_mark_tree (t->x_previous_class_type);\n       ggc_mark_tree (t->x_previous_class_values);\n@@ -6868,7 +6838,6 @@ init_decl_processing ()\n \n   ggc_add_tree_root (&last_function_parm_tags, 1);\n   ggc_add_tree_root (&current_function_return_value, 1);\n-  ggc_add_tree_root (&current_function_parms, 1);\n   ggc_add_tree_root (&current_function_parm_tags, 1);\n   ggc_add_tree_root (&last_function_parms, 1);\n   ggc_add_tree_root (&error_mark_list, 1);\n@@ -13593,8 +13562,9 @@ build_enumerator (name, value, enumtype)\n /* We're defining DECL.  Make sure that it's type is OK.  */\n \n static void\n-check_function_type (decl)\n+check_function_type (decl, current_function_parms)\n      tree decl;\n+     tree current_function_parms;\n {\n   tree fntype = TREE_TYPE (decl);\n   tree return_type = complete_type (TREE_TYPE (fntype));\n@@ -13636,9 +13606,7 @@ check_function_type (decl)\n    FLAGS is a bitwise or of SF_PRE_PARSED (indicating that the\n    DECLARATOR is really the DECL for the function we are about to\n    process and that DECLSPECS should be ignored), SF_INCLASS_INLINE\n-   indicating that the function is an inline defined in-class, and\n-   SF_EXPAND indicating that we should generate RTL for this\n-   function.\n+   indicating that the function is an inline defined in-class.\n \n    This function creates a binding context for the function body\n    as well as setting up the FUNCTION_DECL in current_function_decl.\n@@ -13665,6 +13633,7 @@ start_function (declspecs, declarator, attrs, flags)\n   extern int used_extern_spec;\n   int doing_friend = 0;\n   struct binding_level *bl;\n+  tree current_function_parms;\n \n   /* Sanity check.  */\n   my_friendly_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE, 160);\n@@ -13812,7 +13781,7 @@ start_function (declspecs, declarator, attrs, flags)\n      you declare a function, these types can be incomplete, but they\n      must be complete when you define the function.  */\n   if (! processing_template_decl)\n-    check_function_type (decl1);\n+    check_function_type (decl1, current_function_parms);\n \n   /* Build the return declaration for the function.  */\n   restype = TREE_TYPE (fntype);\n@@ -13837,7 +13806,6 @@ start_function (declspecs, declarator, attrs, flags)\n   bl = current_binding_level;\n   init_function_start (decl1, input_filename, lineno);\n   current_binding_level = bl;\n-  expanding_p = (flags & SF_EXPAND) != 0;\n \n   /* Even though we're inside a function body, we still don't want to\n      call expand_expr to calculate the size of a variable-sized array.\n@@ -13846,9 +13814,8 @@ start_function (declspecs, declarator, attrs, flags)\n   immediate_size_expand = 0;\n   cfun->x_dont_save_pending_sizes_p = 1;\n \n-  /* If we're building a statement-tree, start the tree now.  */\n-  if (processing_template_decl || !expanding_p)\n-    begin_stmt_tree (&DECL_SAVED_TREE (decl1));\n+  /* Start the statement-tree, start the tree now.  */\n+  begin_stmt_tree (&DECL_SAVED_TREE (decl1));\n \n   /* Let the user know we're compiling this function.  */\n   announce_function (decl1);\n@@ -13877,29 +13844,11 @@ start_function (declspecs, declarator, attrs, flags)\n   current_function_decl = decl1;\n   cfun->decl = decl1;\n \n-  /* Initialize the per-function data.  */\n-  if (!DECL_PENDING_INLINE_P (decl1) && DECL_SAVED_FUNCTION_DATA (decl1))\n-    {\n-      /* If we already parsed this function, and we're just expanding it\n-\t now, restore saved state.  */\n-      struct binding_level *bl = current_binding_level;\n-      *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (decl1);\n-      current_binding_level = bl;\n-\n-      /* This function is being processed in whole-function mode; we\n-\t already did semantic analysis.  */\n-      cfun->x_whole_function_mode_p = 1;\n+  my_friendly_assert ((DECL_PENDING_INLINE_P (decl1) \n+\t\t       || !DECL_SAVED_FUNCTION_DATA (decl1)),\n+\t\t      20000911);\n \n-      /* If we decided that we didn't want to inline this function,\n-\t make sure the back-end knows that.  */\n-      if (!current_function_cannot_inline)\n-\tcurrent_function_cannot_inline = cp_function_chain->cannot_inline;\n-\n-      /* We don't need the saved data anymore.  */\n-      free (DECL_SAVED_FUNCTION_DATA (decl1));\n-      DECL_SAVED_FUNCTION_DATA (decl1) = NULL;\n-    }\n-  else if (ctype && !doing_friend && !DECL_STATIC_FUNCTION_P (decl1))\n+  if (ctype && !doing_friend && !DECL_STATIC_FUNCTION_P (decl1))\n     {\n       /* We know that this was set up by `grokclassfn'.  We do not\n \t wait until `store_parm_decls', since evil parse errors may\n@@ -13987,18 +13936,12 @@ start_function (declspecs, declarator, attrs, flags)\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n \n-  if (doing_semantic_analysis_p ())\n-    {\n-      pushlevel (0);\n-      current_binding_level->parm_flag = 1;\n-    }\n+  pushlevel (0);\n+  current_binding_level->parm_flag = 1;\n \n   if (attrs)\n     cplus_decl_attributes (decl1, NULL_TREE, attrs);\n \n-  if (!building_stmt_tree ())\n-    GNU_xref_function (decl1, current_function_parms);\n-\n   /* We need to do this even if we aren't expanding yet so that\n      assemble_external works.  */\n   make_function_rtl (decl1);\n@@ -14038,25 +13981,20 @@ start_function (declspecs, declarator, attrs, flags)\n       DECL_CONTEXT (ctor_label) = current_function_decl;\n     }\n \n+  store_parm_decls (current_function_parms);\n+\n   return 1;\n }\n \f\n-/* Called after store_parm_decls for a function-try-block.  */\n-\n-void\n-expand_start_early_try_stmts ()\n-{\n-  expand_start_try_stmts ();\n-}\n-\n /* Store the parameter declarations into the current function declaration.\n    This is called after parsing the parameter declarations, before\n    digesting the body of the function.\n \n    Also install to binding contour return value identifier, if any.  */\n \n-void\n-store_parm_decls ()\n+static void\n+store_parm_decls (current_function_parms)\n+     tree current_function_parms;\n {\n   register tree fndecl = current_function_decl;\n   register tree parm;\n@@ -14071,10 +14009,6 @@ store_parm_decls ()\n      then CONST_DECLs for foo and bar are put here.  */\n   tree nonparms = NULL_TREE;\n \n-  /* Create a binding level for the parms.  */\n-  if (!building_stmt_tree ())\n-    expand_start_bindings (2);\n-\n   if (current_function_parms)\n     {\n       /* This case is when the function was defined with an ANSI prototype.\n@@ -14085,45 +14019,34 @@ store_parm_decls ()\n       tree specparms = current_function_parms;\n       tree next;\n \n-      if (doing_semantic_analysis_p ())\n-\t{\n-\t  /* Must clear this because it might contain TYPE_DECLs declared\n+      /* Must clear this because it might contain TYPE_DECLs declared\n \t     at class level.  */\n-\t  storedecls (NULL_TREE);\n+      storedecls (NULL_TREE);\n \n-\t  /* If we're doing semantic analysis, then we'll call pushdecl\n+      /* If we're doing semantic analysis, then we'll call pushdecl\n \t     for each of these.  We must do them in reverse order so that\n \t     they end in the correct forward order.  */\n-\t  specparms = nreverse (specparms);\n-\t}\n+      specparms = nreverse (specparms);\n \n       for (parm = specparms; parm; parm = next)\n \t{\n \t  next = TREE_CHAIN (parm);\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n-\t      tree type = TREE_TYPE (parm);\n-\n-\t      if (doing_semantic_analysis_p ())\n-\t\t{\n-\t\t  tree cleanup;\n+\t      tree cleanup;\n \n-\t\t  if (DECL_NAME (parm) == NULL_TREE\n-\t\t      || TREE_CODE (parm) != VOID_TYPE)\n-\t\t    pushdecl (parm);\n-\t\t  else\n-\t\t    cp_error (\"parameter `%D' declared void\", parm);\n+\t      if (DECL_NAME (parm) == NULL_TREE\n+\t\t  || TREE_CODE (parm) != VOID_TYPE)\n+\t\tpushdecl (parm);\n+\t      else\n+\t\tcp_error (\"parameter `%D' declared void\", parm);\n \n-\t\t  cleanup = (processing_template_decl \n-\t\t\t     ? NULL_TREE\n-\t\t\t     : maybe_build_cleanup (parm));\n+\t      cleanup = (processing_template_decl \n+\t\t\t ? NULL_TREE\n+\t\t\t : maybe_build_cleanup (parm));\n \n-\t\t  if (cleanup)\n-\t\t    cleanups = tree_cons (parm, cleanup, cleanups);\n-\t\t}\n-\t      else if (type != error_mark_node\n-\t\t       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t\tparms_have_cleanups = 1;\n+\t      if (cleanup)\n+\t\tcleanups = tree_cons (parm, cleanup, cleanups);\n \t    }\n \t  else\n \t    {\n@@ -14134,14 +14057,11 @@ store_parm_decls ()\n \t    }\n \t}\n \n-      if (doing_semantic_analysis_p ())\n-\t{\n-\t  /* Get the decls in their original chain order\n-\t     and record in the function.  This is all and only the\n-\t     PARM_DECLs that were pushed into scope by the loop above.  */\n-\t  DECL_ARGUMENTS (fndecl) = getdecls ();\n-\t  storetags (chainon (parmtags, gettags ()));\n-\t}\n+      /* Get the decls in their original chain order and record in the\n+\t function.  This is all and only the PARM_DECLs that were\n+\t pushed into scope by the loop above.  */\n+      DECL_ARGUMENTS (fndecl) = getdecls ();\n+      storetags (chainon (parmtags, gettags ()));\n     }\n   else\n     DECL_ARGUMENTS (fndecl) = NULL_TREE;\n@@ -14150,20 +14070,7 @@ store_parm_decls ()\n      as the decl-chain of the current lexical scope.\n      Put the enumerators in as well, at the front so that\n      DECL_ARGUMENTS is not modified.  */\n-  if (doing_semantic_analysis_p ())\n-    storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n-\n-  /* Initialize the RTL code for the function.  */\n-  DECL_SAVED_INSNS (fndecl) = 0;\n-  if (! building_stmt_tree ())\n-    expand_function_start (fndecl, parms_have_cleanups);\n-\n-  current_function_parms_stored = 1;\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_MAIN_P (fndecl) && !building_stmt_tree ())\n-    expand_main_function ();\n+  storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n \n   /* Now that we have initialized the parms, we can start their\n      cleanups.  We cannot do this before, since expand_decl_cleanup\n@@ -14176,19 +14083,13 @@ store_parm_decls ()\n     }\n \n   /* Create a binding contour which can be used to catch\n-     cleanup-generated temporaries.  Also, if the return value needs or\n-     has initialization, deal with that now.  */\n+     cleanup-generated temporaries.  */\n   if (parms_have_cleanups)\n-    {\n-      pushlevel (0);\n-      if (!building_stmt_tree ())\n-\texpand_start_bindings (2);\n-    }\n+    pushlevel (0);\n \n   /* Do the starting of the exception specifications, if we have any.  */\n   if (flag_exceptions && !processing_template_decl\n       && flag_enforce_eh_specs\n-      && building_stmt_tree ()\n       && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n     current_eh_spec_try_block = expand_start_eh_spec ();\n }\n@@ -14384,13 +14285,9 @@ finish_function (flags)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n-  /* Label to use if this function is supposed to return a value.  */\n-  tree no_return_label = NULL_TREE;\n   int call_poplevel = (flags & 1) != 0;\n   int inclass_inline = (flags & 2) != 0;\n-  int expand_p;\n   int nested;\n-  int current_line = lineno;\n \n   /* When we get some parse errors, we can end up without a\n      current_function_decl, so cope.  */\n@@ -14404,18 +14301,11 @@ finish_function (flags)\n       This caused &foo to be of type ptr-to-const-function\n       which then got a warning when stored in a ptr-to-function variable.  */\n \n-  /* This happens on strange parse errors.  */\n-  if (! current_function_parms_stored)\n-    {\n-      call_poplevel = 0;\n-      store_parm_decls ();\n-    }\n+  my_friendly_assert (building_stmt_tree (), 20000911);\n \n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */\n-  if (building_stmt_tree () && DECL_CLONED_FUNCTION_P (fndecl))\n-    ;\n-  else if (building_stmt_tree ())\n+  if (!DECL_CLONED_FUNCTION_P (fndecl))\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n@@ -14443,132 +14333,16 @@ finish_function (flags)\n \t\t\t    (TREE_TYPE (current_function_decl)),\n \t\t\t    current_eh_spec_try_block);\n     }\n-  else\n-    {\n-#if 0\n-      if (write_symbols != NO_DEBUG /*&& TREE_CODE (fntype) != METHOD_TYPE*/)\n-\t{\n-\t  /* Keep this code around in case we later want to control debug info\n-\t     based on whether a type is \"used\".  (jason 1999-11-11) */\n-\n-\t  tree ttype = target_type (fntype);\n-\t  tree parmdecl;\n-\n-\t  if (IS_AGGR_TYPE (ttype))\n-\t    /* Let debugger know it should output info for this type.  */\n-\t    note_debug_info_needed (ttype);\n-\n-\t  for (parmdecl = DECL_ARGUMENTS (fndecl); parmdecl; parmdecl = TREE_CHAIN (parmdecl))\n-\t    {\n-\t      ttype = target_type (TREE_TYPE (parmdecl));\n-\t      if (IS_AGGR_TYPE (ttype))\n-\t\t/* Let debugger know it should output info for this type.  */\n-\t\tnote_debug_info_needed (ttype);\n-\t    }\n-\t}\n-#endif\n-\n-      /* Clean house because we will need to reorder insns here.  */\n-      do_pending_stack_adjust ();\n-\n-      if (dtor_label)\n-\t;\n-      else if (DECL_CONSTRUCTOR_P (fndecl))\n-\t{\n-\t  if (call_poplevel)\n-\t    do_poplevel ();\n-\t}\n-      else if (return_label != NULL_RTX\n-\t       && flag_this_is_variable <= 0\n-\t       && current_function_return_value == NULL_TREE\n-\t       && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n-\tno_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-      if (flag_exceptions)\n-\texpand_exception_blocks ();\n-\n-      /* If this function is supposed to return a value, ensure that\n-\t we do not fall into the cleanups by mistake.  The end of our\n-\t function will look like this:\n-\n-\t user code (may have return stmt somewhere)\n-\t goto no_return_label\n-\t cleanup_label:\n-\t cleanups\n-\t goto return_label\n-\t no_return_label:\n-\t NOTE_INSN_FUNCTION_END\n-\t return_label:\n-\t things for return\n-\n-\t If the user omits a return stmt in the USER CODE section, we\n-\t will have a control path which reaches NOTE_INSN_FUNCTION_END.\n-\t Otherwise, we won't.  */\n-      if (no_return_label)\n-\t{\n-\t  DECL_CONTEXT (no_return_label) = fndecl;\n-\t  DECL_INITIAL (no_return_label) = error_mark_node;\n-\t  DECL_SOURCE_FILE (no_return_label) = input_filename;\n-\t  DECL_SOURCE_LINE (no_return_label) = current_line;\n-\t  expand_goto (no_return_label);\n-\t}\n-\n-      if (cleanup_label)\n-\t{\n-\t  /* Remove the binding contour which is used\n-\t     to catch cleanup-generated temporaries.  */\n-\t  expand_end_bindings (0, 0, 0);\n-\t  poplevel (0, 0, 0);\n-\n-\t  /* Emit label at beginning of cleanup code for parameters.  */\n-\t  emit_label (cleanup_label);\n-\t}\n-\n-      /* Get return value into register if that's where it's supposed\n-\t to be.  */\n-      if (original_result_rtx)\n-\tfixup_result_decl (DECL_RESULT (fndecl), original_result_rtx);\n-\n-      /* Finish building code that will trigger warnings if users forget\n-\t to make their functions return values.  */\n-      if (no_return_label || cleanup_label)\n-\temit_jump (return_label);\n-      if (no_return_label)\n-\t{\n-\t  /* We don't need to call `expand_*_return' here because we\n-\t     don't need any cleanups here--this path of code is only\n-\t     for error checking purposes.  */\n-\t  expand_label (no_return_label);\n-\t}\n-\n-      /* We hard-wired immediate_size_expand to zero in\n-\t start_function.  Expand_function_end will decrement this\n-\t variable.  So, we set the variable to one here, so that after\n-\t the decrement it will remain zero.  */\n-      immediate_size_expand = 1;\n-\n-      /* Generate rtl for function exit.  */\n-      expand_function_end (input_filename, current_line, 1);\n-    }\n-\n-  /* We have to save this value here in case\n-     maybe_end_member_template_processing decides to pop all the\n-     template parameters.  */\n-  expand_p = !building_stmt_tree ();\n \n   /* If we're saving up tree structure, tie off the function now.  */\n-  if (!expand_p)\n-    finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n+  finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n \n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n      this function's blocks.  */\n-  if (doing_semantic_analysis_p ())\n-    {\n-      if (current_binding_level->parm_flag != 1)\n-\tmy_friendly_abort (122);\n-      poplevel (1, 0, 1);\n-    }\n+  if (current_binding_level->parm_flag != 1)\n+    my_friendly_abort (122);\n+  poplevel (1, 0, 1);\n \n   /* Remember that we were in class scope.  */\n   if (current_class_name)\n@@ -14582,7 +14356,7 @@ finish_function (flags)\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   /* Save away current state, if appropriate.  */\n-  if (!expanding_p && !processing_template_decl)\n+  if (!processing_template_decl)\n     save_function_data (fndecl);\n \n   /* If this function calls `setjmp' it cannot be inlined.  When\n@@ -14594,96 +14368,15 @@ finish_function (flags)\n      this function to modify local variables in `c', but their\n      addresses may have been stored somewhere accessible to this\n      function.)  */\n-  if (!expanding_p && !processing_template_decl && calls_setjmp_p (fndecl))\n+  if (!processing_template_decl && calls_setjmp_p (fndecl))\n     DECL_UNINLINABLE (fndecl) = 1;\n \n-  if (expand_p)\n-    {\n-      int returns_null;\n-      int returns_value;\n-\n-      /* So we can tell if jump_optimize sets it to 1.  */\n-      can_reach_end = 0;\n-\n-      /* Before we call rest_of_compilation (which will pop the\n-\t CURRENT_FUNCTION), we must save these values.  */\n-      returns_null = current_function_returns_null;\n-      returns_value = current_function_returns_value;\n-\n-      /* If this is a nested function (like a template instantiation\n-\t that we're compiling in the midst of compiling something\n-\t else), push a new GC context.  That will keep local variables\n-\t on the stack from being collected while we're doing the\n-\t compilation of this function.  */\n-      if (function_depth > 1)\n-\tggc_push_context ();\n-\n-      /* Run the optimizers and output the assembler code for this\n-         function.  */\n-      rest_of_compilation (fndecl);\n-\n-      /* Undo the call to ggc_push_context above.  */\n-      if (function_depth > 1)\n-\tggc_pop_context ();\n-\n-      if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n-\t{\n-\t  /* Set DECL_EXTERNAL so that assemble_external will be called as\n-\t     necessary.  We'll clear it again in finish_file.  */\n-\t  if (! DECL_EXTERNAL (fndecl))\n-\t    DECL_NOT_REALLY_EXTERN (fndecl) = 1;\n-\t  DECL_EXTERNAL (fndecl) = 1;\n-\t  defer_fn (fndecl);\n-\t}\n-\n-#if 0\n-      /* Keep this code around in case we later want to control debug info\n-\t based on whether a type is \"used\".  (jason 1999-11-11) */\n-\n-      if (ctype && TREE_ASM_WRITTEN (fndecl))\n-\tnote_debug_info_needed (ctype);\n-#endif\n-\n-      /* If this function is marked with the constructor attribute,\n-\t add it to the list of functions to be called along with\n-\t constructors from static duration objects.  */\n-      if (DECL_STATIC_CONSTRUCTOR (fndecl))\n-\tstatic_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n-\n-      /* If this function is marked with the destructor attribute,\n-\t add it to the list of functions to be called along with\n-\t destructors from static duration objects.  */\n-      if (DECL_STATIC_DESTRUCTOR (fndecl))\n-\tstatic_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n-\n-      if (DECL_NAME (DECL_RESULT (fndecl)))\n-\treturns_value |= can_reach_end;\n-      else\n-\treturns_null |= can_reach_end;\n-\n-      if (TREE_THIS_VOLATILE (fndecl) && returns_null)\n-\twarning (\"`noreturn' function does return\");\n-      else if (returns_null\n-\t       && TREE_CODE (TREE_TYPE (fntype)) != VOID_TYPE)\n-\t{\n-\t  /* Always complain if there's just no return statement.  */\n-\t  if (!returns_value)\n-\t    warning (\"no return statement in function returning non-void\");\n-\t  else if (warn_return_type || pedantic)\n-\t    /* If this function returns non-void and control can drop through,\n-\t       complain.  */\n-\t    warning (\"control reaches end of non-void function\");\n-\t}\n-    }\n-  else\n-    {\n-      /* Clear out memory we no longer need.  */\n-      free_after_parsing (cfun);\n-      /* Since we never call rest_of_compilation, we never clear\n-\t CFUN.  Do so explicitly.  */\n-      free_after_compilation (cfun);\n-      cfun = NULL;\n-    }\n+  /* Clear out memory we no longer need.  */\n+  free_after_parsing (cfun);\n+  /* Since we never call rest_of_compilation, we never clear\n+     CFUN.  Do so explicitly.  */\n+  free_after_compilation (cfun);\n+  cfun = NULL;\n \n   /* If this is a in-class inline definition, we may have to pop the\n      bindings for the template parameters that we added in\n@@ -14698,19 +14391,6 @@ finish_function (flags)\n \n   --function_depth;\n \n-  if (!DECL_SAVED_INSNS (fndecl) && !DECL_SAVED_FUNCTION_DATA (fndecl)\n-      && !(flag_inline_trees && DECL_INLINE (fndecl)))\n-    {\n-      tree t;\n-\n-      /* Stop pointing to the local nodes about to be freed.  */\n-      /* But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.  */\n-      DECL_INITIAL (fndecl) = error_mark_node;\n-      for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n-\tDECL_RTL (t) = DECL_INCOMING_RTL (t) = NULL_RTX;\n-    }\n-\n   /* Clean up.  */\n   if (! nested)\n     {"}, {"sha": "250068a1cb007387ce20cc71be9249eba944ee2a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -128,7 +128,8 @@ int at_eof;\n \n /* Functions called along with real static constructors and destructors.  */\n \n-tree static_ctors, static_dtors;\n+tree static_ctors;\n+tree static_dtors;\n \n /* The :: namespace. */\n "}, {"sha": "8bcc33377df33c7387ba47c96772c216c86973fa", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -2258,7 +2258,6 @@ use_thunk (thunk_fndecl, emit_p)\n     DECL_RESULT (thunk_fndecl) = NULL_TREE;\n \n     start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n-    store_parm_decls ();\n \n     /* Adjust the this pointer by the constant.  */\n     t = ssize_int (delta);\n@@ -2530,7 +2529,6 @@ synthesize_method (fndecl)\n \n   interface_unknown = 1;\n   start_function (NULL_TREE, fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n-  store_parm_decls ();\n   clear_last_expr ();\n \n   if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)"}, {"sha": "fdc1a524947255d7a147b44d2fc5a4bd5b98999c", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -932,7 +932,6 @@ maybe_clone_body (fn)\n       /* Start processing the function.  */\n       push_to_top_level ();\n       start_function (NULL_TREE, clone, NULL_TREE, SF_PRE_PARSED);\n-      store_parm_decls ();\n \n       /* Just clone the body, as if we were making an inline call.\n \t But, remap the parameters in the callee to the parameters of"}, {"sha": "75930f3469f806877d3695e6cc2cc8f02bbbb579", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -835,8 +835,6 @@ fn.def2:\n return_id:\n \t  RETURN_KEYWORD IDENTIFIER\n \t\t{\n-\t\t  if (! current_function_parms_stored)\n-\t\t    store_parm_decls ();\n \t\t  $$ = $2;\n \t\t}\n \t;\n@@ -863,9 +861,6 @@ base_init:\n .set_base_init:\n \t  /* empty */\n \t\t{\n-\t\t  if (! current_function_parms_stored)\n-\t\t    store_parm_decls ();\n-\n \t\t  if (DECL_CONSTRUCTOR_P (current_function_decl))\n \t\t    /* Make a contour for the initializer list.  */\n \t\t    do_pushlevel ();\n@@ -1723,8 +1718,6 @@ string:\n nodecls:\n \t  /* empty */\n \t\t{\n-\t\t  if (! current_function_parms_stored)\n-\t\t    store_parm_decls ();\n \t\t  setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n \t\t}\n \t;"}, {"sha": "99443b58841a99f5bcba2227ace4f95baf676dd7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -9686,7 +9686,6 @@ instantiate_decl (d, defer_ok)\n \n       /* Set up context.  */\n       start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n-      store_parm_decls ();\n \n       /* We already set up __FUNCTION__, etc., so we don't want to do\n \t it again now.  */"}, {"sha": "3eea2d2261eaf672ed413ee57715d526b5a49351", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -1195,7 +1195,6 @@ synthesize_tinfo_fn (fndecl)\n   start_function (NULL_TREE, fndecl, NULL_TREE, \n \t\t  SF_DEFAULT | SF_PRE_PARSED);\n   DECL_DEFER_OUTPUT (fndecl) = 1;\n-  store_parm_decls ();\n   clear_last_expr ();\n \n   /* Begin the body of the function.  */"}, {"sha": "88eaa72de4cc63882dd8e46d1402684fe79ea145", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 288, "deletions": 15, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f444e36b2dc2956e620d60257116379647ed886c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f444e36b2dc2956e620d60257116379647ed886c", "patch": "@@ -57,6 +57,8 @@ static void genrtl_ctor_stmt PARAMS ((tree));\n static void genrtl_subobject PARAMS ((tree));\n static void genrtl_named_return_value PARAMS ((void));\n static void cp_expand_stmt PARAMS ((tree));\n+static void genrtl_start_function PARAMS ((tree));\n+static void genrtl_finish_function PARAMS ((tree));\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n@@ -596,17 +598,9 @@ genrtl_try_block (t)\n     }\n   else\n     {\n-      if (FN_TRY_BLOCK_P (t)) \n-\t{\n-\t  if (! current_function_parms_stored)\n-\t    store_parm_decls ();\n-\t  expand_start_early_try_stmts ();\n-\t} \n-      else \n-\t{\n-\t  emit_line_note (input_filename, lineno);\n-\t  expand_start_try_stmts ();\n-\t}\n+      if (!FN_TRY_BLOCK_P (t)) \n+\temit_line_note (input_filename, lineno);\n+      expand_start_try_stmts ();\n \n       expand_stmt (TRY_STMTS (t));\n \n@@ -2387,7 +2381,6 @@ emit_associated_thunks (fn)\n     }\n }\n \n-\n /* Generate RTL for FN.  */\n \n void\n@@ -2484,8 +2477,7 @@ expand_body (fn)\n   lineno = DECL_SOURCE_LINE (fn);\n   input_filename = DECL_SOURCE_FILE (fn);\n \n-  start_function (NULL_TREE, fn, NULL_TREE, SF_PRE_PARSED | SF_EXPAND);\n-  store_parm_decls ();\n+  genrtl_start_function (fn);\n   current_function_is_thunk = DECL_THUNK_P (fn);\n \n   /* We don't need to redeclare __FUNCTION__, __PRETTY_FUNCTION__, or\n@@ -2505,7 +2497,7 @@ expand_body (fn)\n   lineno = STMT_LINENO (DECL_SAVED_TREE (fn));\n \n   /* Generate code for the function.  */\n-  finish_function (0);\n+  genrtl_finish_function (fn);\n \n   /* If possible, obliterate the body of the function so that it can\n      be garbage collected.  */\n@@ -2528,6 +2520,287 @@ expand_body (fn)\n   timevar_pop (TV_EXPAND);\n }\n \n+/* Start generating the RTL for FN.  */\n+\n+static void\n+genrtl_start_function (fn)\n+     tree fn;\n+{\n+  tree parm;\n+\n+  /* Tell everybody what function we're processing.  */\n+  current_function_decl = fn;\n+  /* Get the RTL machinery going for this function.  */\n+  init_function_start (fn, DECL_SOURCE_FILE (fn), DECL_SOURCE_LINE (fn));\n+  /* Let everybody know that we're expanding this function, not doing\n+     semantic analysis.  */\n+  expanding_p = 1;\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  immediate_size_expand = 0;\n+  cfun->x_dont_save_pending_sizes_p = 1;\n+\n+  /* Let the user know we're compiling this function.  */\n+  announce_function (fn);\n+\n+  /* Initialize the per-function data.  */\n+  my_friendly_assert (!DECL_PENDING_INLINE_P (fn), 20000911);\n+  if (DECL_SAVED_FUNCTION_DATA (fn))\n+    {\n+      /* If we already parsed this function, and we're just expanding it\n+\t now, restore saved state.  */\n+      *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (fn);\n+\n+      /* This function is being processed in whole-function mode; we\n+\t already did semantic analysis.  */\n+      cfun->x_whole_function_mode_p = 1;\n+\n+      /* If we decided that we didn't want to inline this function,\n+\t make sure the back-end knows that.  */\n+      if (!current_function_cannot_inline)\n+\tcurrent_function_cannot_inline = cp_function_chain->cannot_inline;\n+\n+      /* We don't need the saved data anymore.  */\n+      free (DECL_SAVED_FUNCTION_DATA (fn));\n+      DECL_SAVED_FUNCTION_DATA (fn) = NULL;\n+    }\n+\n+  /* Tell the cross-reference machinery that we're defining this\n+     function.  */\n+  GNU_xref_function (fn, DECL_ARGUMENTS (fn));\n+\n+  /* Keep track of how many functions we're presently expanding.  */\n+  ++function_depth;\n+\n+  /* Create a binding level for the parameters.  */\n+  expand_start_bindings (2);\n+  /* Clear out any previously saved instructions for this function, in\n+     case it was defined more than once.  */\n+  DECL_SAVED_INSNS (fn) = NULL;\n+  /* Go through the PARM_DECLs for this function to see if any need\n+     cleanups.  */\n+  for (parm = DECL_ARGUMENTS (fn); parm; parm = TREE_CHAIN (parm))\n+    if (TREE_TYPE (parm) != error_mark_node\n+\t&& TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (parm)))\n+      {\n+\texpand_function_start (fn, /*parms_have_cleanups=*/1);\n+\tbreak;\n+      }\n+  if (!parm)\n+    expand_function_start (fn, /*parms_have_cleanups=*/0);\n+  /* If this function is `main'.  */\n+  if (DECL_MAIN_P (fn))\n+    expand_main_function ();\n+  /* Create a binding contour which can be used to catch\n+     cleanup-generated temporaries.  */\n+  expand_start_bindings (2);\n+}\n+\n+/* Finish generating the RTL for FN.  */\n+\n+static void\n+genrtl_finish_function (fn)\n+     tree fn;\n+{\n+  int returns_null;\n+  int returns_value;\n+  tree no_return_label = NULL_TREE;\n+\n+#if 0\n+  if (write_symbols != NO_DEBUG)\n+    {\n+      /* Keep this code around in case we later want to control debug info\n+\t based on whether a type is \"used\".  (jason 1999-11-11) */\n+\n+      tree ttype = target_type (fntype);\n+      tree parmdecl;\n+\n+      if (IS_AGGR_TYPE (ttype))\n+\t/* Let debugger know it should output info for this type.  */\n+\tnote_debug_info_needed (ttype);\n+\n+      for (parmdecl = DECL_ARGUMENTS (fndecl); parmdecl; parmdecl = TREE_CHAIN (parmdecl))\n+\t{\n+\t  ttype = target_type (TREE_TYPE (parmdecl));\n+\t  if (IS_AGGR_TYPE (ttype))\n+\t    /* Let debugger know it should output info for this type.  */\n+\t    note_debug_info_needed (ttype);\n+\t}\n+    }\n+#endif\n+\n+  /* Clean house because we will need to reorder insns here.  */\n+  do_pending_stack_adjust ();\n+\n+  if (!dtor_label && !DECL_CONSTRUCTOR_P (fn)\n+      && return_label != NULL_RTX\n+      && current_function_return_value == NULL_TREE\n+      && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n+    no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+  if (flag_exceptions)\n+    expand_exception_blocks ();\n+\n+  /* If this function is supposed to return a value, ensure that\n+     we do not fall into the cleanups by mistake.  The end of our\n+     function will look like this:\n+\n+     user code (may have return stmt somewhere)\n+     goto no_return_label\n+     cleanup_label:\n+     cleanups\n+     goto return_label\n+     no_return_label:\n+     NOTE_INSN_FUNCTION_END\n+     return_label:\n+     things for return\n+\n+     If the user omits a return stmt in the USER CODE section, we\n+     will have a control path which reaches NOTE_INSN_FUNCTION_END.\n+     Otherwise, we won't.  */\n+  if (no_return_label)\n+    {\n+      DECL_CONTEXT (no_return_label) = fn;\n+      DECL_INITIAL (no_return_label) = error_mark_node;\n+      DECL_SOURCE_FILE (no_return_label) = input_filename;\n+      DECL_SOURCE_LINE (no_return_label) = lineno;\n+      expand_goto (no_return_label);\n+    }\n+\n+  if (cleanup_label)\n+    {\n+      /* Remove the binding contour which is used to catch\n+\t cleanup-generated temporaries.  */\n+      expand_end_bindings (0, 0, 0);\n+      poplevel (0, 0, 0);\n+\n+      /* Emit label at beginning of cleanup code for parameters.  */\n+      emit_label (cleanup_label);\n+    }\n+\n+  /* Get return value into register if that's where it's supposed to\n+     be.  */\n+  if (original_result_rtx)\n+    fixup_result_decl (DECL_RESULT (fn), original_result_rtx);\n+\n+  /* Finish building code that will trigger warnings if users forget\n+     to make their functions return values.  */\n+  if (no_return_label || cleanup_label)\n+    emit_jump (return_label);\n+  if (no_return_label)\n+    {\n+      /* We don't need to call `expand_*_return' here because we don't\n+\t need any cleanups here--this path of code is only for error\n+\t checking purposes.  */\n+      expand_label (no_return_label);\n+    }\n+\n+  /* We hard-wired immediate_size_expand to zero in start_function.\n+     Expand_function_end will decrement this variable.  So, we set the\n+     variable to one here, so that after the decrement it will remain\n+     zero.  */\n+  immediate_size_expand = 1;\n+\n+  /* Generate rtl for function exit.  */\n+  expand_function_end (input_filename, lineno, 1);\n+\n+  /* So we can tell if jump_optimize sets it to 1.  */\n+  can_reach_end = 0;\n+\n+  /* Before we call rest_of_compilation (which will pop the\n+     CURRENT_FUNCTION), we must save these values.  */\n+  returns_null = current_function_returns_null;\n+  returns_value = current_function_returns_value;\n+\n+  /* If this is a nested function (like a template instantiation that\n+     we're compiling in the midst of compiling something else), push a\n+     new GC context.  That will keep local variables on the stack from\n+     being collected while we're doing the compilation of this\n+     function.  */\n+  if (function_depth > 1)\n+    ggc_push_context ();\n+\n+  /* Run the optimizers and output the assembler code for this\n+     function.  */\n+  rest_of_compilation (fn);\n+\n+  /* Undo the call to ggc_push_context above.  */\n+  if (function_depth > 1)\n+    ggc_pop_context ();\n+\n+  if (DECL_SAVED_INSNS (fn) && ! TREE_ASM_WRITTEN (fn))\n+    {\n+      /* Set DECL_EXTERNAL so that assemble_external will be called as\n+\t necessary.  We'll clear it again in finish_file.  */\n+      if (! DECL_EXTERNAL (fn))\n+\tDECL_NOT_REALLY_EXTERN (fn) = 1;\n+      DECL_EXTERNAL (fn) = 1;\n+      defer_fn (fn);\n+    }\n+\n+#if 0\n+  /* Keep this code around in case we later want to control debug info\n+     based on whether a type is \"used\".  (jason 1999-11-11) */\n+\n+  if (ctype && TREE_ASM_WRITTEN (fn))\n+    note_debug_info_needed (ctype);\n+#endif\n+\n+  /* If this function is marked with the constructor attribute, add it\n+     to the list of functions to be called along with constructors\n+     from static duration objects.  */\n+  if (DECL_STATIC_CONSTRUCTOR (fn))\n+    static_ctors = tree_cons (NULL_TREE, fn, static_ctors);\n+\n+  /* If this function is marked with the destructor attribute, add it\n+     to the list of functions to be called along with destructors from\n+     static duration objects.  */\n+  if (DECL_STATIC_DESTRUCTOR (fn))\n+    static_dtors = tree_cons (NULL_TREE, fn, static_dtors);\n+\n+  if (DECL_NAME (DECL_RESULT (fn)))\n+    returns_value |= can_reach_end;\n+  else\n+    returns_null |= can_reach_end;\n+\n+  if (TREE_THIS_VOLATILE (fn) && returns_null)\n+    warning (\"`noreturn' function does return\");\n+  else if (returns_null\n+\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != VOID_TYPE)\n+    {\n+      /* Always complain if there's just no return statement.  */\n+      if (!returns_value)\n+\twarning (\"no return statement in function returning non-void\");\n+      else if (warn_return_type || pedantic)\n+\t/* If this function returns non-void and control can drop through,\n+\t       complain.  */\n+\twarning (\"control reaches end of non-void function\");\n+    }\n+\n+  --function_depth;\n+\n+  if (!DECL_SAVED_INSNS (fn)\n+      && !(flag_inline_trees && DECL_INLINE (fn)))\n+    {\n+      tree t;\n+\n+      /* Stop pointing to the local nodes about to be freed.  */\n+      /* But DECL_INITIAL must remain nonzero so we know this\n+\t was an actual function definition.  */\n+      DECL_INITIAL (fn) = error_mark_node;\n+      for (t = DECL_ARGUMENTS (fn); t; t = TREE_CHAIN (t))\n+\tDECL_RTL (t) = DECL_INCOMING_RTL (t) = NULL_RTX;\n+    }\n+\n+  /* Let the error reporting routines know that we're outside a\n+     function.  For a nested function, this value is used in\n+     pop_cp_function_context and then reset via pop_function_context.  */\n+  current_function_decl = NULL_TREE;\n+}\n+\n /* Perform initialization related to this module.  */\n \n void"}]}