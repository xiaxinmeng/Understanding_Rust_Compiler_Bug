{"sha": "c6c9b82bc17e957c621bfb58e33801f956c7c31c", "node_id": "C_kwDOANBUbNoAKGM2YzliODJiYzE3ZTk1N2M2MjFiZmI1OGUzMzgwMWY5NTZjN2MzMWM", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-04-08T15:24:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-18T08:41:08Z"}, "message": "[Ada] Adapt proof of double arithmetic runtime unit\n\nAfter changes in Why3 and generation of VCs, ghost code needs to be\nadapted for proofs to remain automatic.\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb (Big3): Change return type.\n\t(Lemma_Mult_Non_Negative, Lemma_Mult_Non_Positive): Reorder\n\talphabetically.\n\t(Lemma_Concat_Definition, Lemma_Double_Big_2xxsingle): New\n\tlemmas.\n\t(Double_Divide, Scaled_Divide): Add assertions.", "tree": {"sha": "ea0dac41b2513219767f914c701fda45f064dfb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea0dac41b2513219767f914c701fda45f064dfb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6c9b82bc17e957c621bfb58e33801f956c7c31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c9b82bc17e957c621bfb58e33801f956c7c31c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c9b82bc17e957c621bfb58e33801f956c7c31c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c9b82bc17e957c621bfb58e33801f956c7c31c/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8f9d1bcf55187cb81ef7b0ef1e23db1bc0d440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f8f9d1bcf55187cb81ef7b0ef1e23db1bc0d440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f8f9d1bcf55187cb81ef7b0ef1e23db1bc0d440"}], "stats": {"total": 83, "additions": 67, "deletions": 16}, "files": [{"sha": "e2afd524ec41028b4c25618ea848564dfa9065ee", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c9b82bc17e957c621bfb58e33801f956c7c31c/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c9b82bc17e957c621bfb58e33801f956c7c31c/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=c6c9b82bc17e957c621bfb58e33801f956c7c31c", "patch": "@@ -133,7 +133,7 @@ is\n      Post => Big_2xx'Result > 0;\n    --  2**N as a big integer\n \n-   function Big3 (X1, X2, X3 : Single_Uns) return Big_Integer is\n+   function Big3 (X1, X2, X3 : Single_Uns) return Big_Natural is\n      (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (X1))\n                     + Big_2xxSingle * Big (Double_Uns (X2))\n                                     + Big (Double_Uns (X3)))\n@@ -208,20 +208,6 @@ is\n      Ghost,\n      Post => abs (X * Y) = abs X * abs Y;\n \n-   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n-   with\n-     Ghost,\n-     Pre  => (X >= Big_0 and then Y >= Big_0)\n-       or else (X <= Big_0 and then Y <= Big_0),\n-     Post => X * Y >= Big_0;\n-\n-   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer)\n-   with\n-     Ghost,\n-     Pre  => (X <= Big_0 and then Y >= Big_0)\n-       or else (X >= Big_0 and then Y <= Big_0),\n-     Post => X * Y <= Big_0;\n-\n    procedure Lemma_Abs_Rem_Commutation (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -246,6 +232,12 @@ is\n      Pre  => M < N and then N < Double_Size,\n      Post => Double_Uns'(2)**M < Double_Uns'(2)**N;\n \n+   procedure Lemma_Concat_Definition (X, Y : Single_Uns)\n+   with\n+     Ghost,\n+     Post => Big (X & Y) = Big_2xxSingle * Big (Double_Uns (X))\n+                                         + Big (Double_Uns (Y));\n+\n    procedure Lemma_Deep_Mult_Commutation\n      (Factor : Big_Integer;\n       X, Y   : Single_Uns)\n@@ -289,6 +281,11 @@ is\n      Pre  => A * S = B * S + R and then S /= 0,\n      Post => A = B + R / S;\n \n+   procedure Lemma_Double_Big_2xxSingle\n+   with\n+     Ghost,\n+     Post => Big_2xxSingle * Big_2xxSingle = Big_2xxDouble;\n+\n    procedure Lemma_Double_Shift (X : Double_Uns; S, S1 : Double_Uns)\n    with\n      Ghost,\n@@ -419,6 +416,20 @@ is\n      Ghost,\n      Post => X * (Y + Z) = X * Y + X * Z;\n \n+   procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X >= Big_0 and then Y >= Big_0)\n+       or else (X <= Big_0 and then Y <= Big_0),\n+     Post => X * Y >= Big_0;\n+\n+   procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X <= Big_0 and then Y >= Big_0)\n+       or else (X >= Big_0 and then Y <= Big_0),\n+     Post => X * Y <= Big_0;\n+\n    procedure Lemma_Neg_Div (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -552,6 +563,7 @@ is\n    procedure Lemma_Add_Commutation (X : Double_Uns; Y : Single_Uns) is null;\n    procedure Lemma_Add_One (X : Double_Uns) is null;\n    procedure Lemma_Bounded_Powers_Of_2_Increasing (M, N : Natural) is null;\n+   procedure Lemma_Concat_Definition (X, Y : Single_Uns) is null;\n    procedure Lemma_Deep_Mult_Commutation\n      (Factor : Big_Integer;\n       X, Y   : Single_Uns)\n@@ -566,6 +578,7 @@ is\n    procedure Lemma_Div_Ge (X, Y, Z : Big_Integer) is null;\n    procedure Lemma_Div_Lt (X, Y, Z : Big_Natural) is null;\n    procedure Lemma_Div_Eq (A, B, S, R : Big_Integer) is null;\n+   procedure Lemma_Double_Big_2xxSingle is null;\n    procedure Lemma_Double_Shift (X : Double_Uns; S, S1 : Double_Uns) is null;\n    procedure Lemma_Double_Shift (X : Single_Uns; S, S1 : Natural) is null;\n    procedure Lemma_Double_Shift_Right (X : Double_Uns; S, S1 : Double_Uns)\n@@ -929,10 +942,18 @@ is\n                pragma Assert (Big (Double_Uns'(Yhi * Zhi)) >= 1);\n                if Yhi > 1 or else Zhi > 1 then\n                   pragma Assert (Big (Double_Uns'(Yhi * Zhi)) > 1);\n+                  pragma Assert (if X = Double_Int'First and then Round then\n+                                    Mult > Big_2xxDouble);\n                elsif Zlo > 0 then\n                   pragma Assert (Big (Double_Uns'(Yhi * Zlo)) > 0);\n+                  pragma Assert (if X = Double_Int'First and then Round then\n+                                    Mult > Big_2xxDouble);\n                elsif Ylo > 0 then\n                   pragma Assert (Big (Double_Uns'(Ylo * Zhi)) > 0);\n+                  pragma Assert (if X = Double_Int'First and then Round then\n+                                    Mult > Big_2xxDouble);\n+               else\n+                  pragma Assert (not (X = Double_Int'First and then Round));\n                end if;\n                Prove_Quotient_Zero;\n             end if;\n@@ -976,6 +997,7 @@ is\n       Lemma_Mult_Distribution (Big_2xxSingle,\n                                Big (Double_Uns (Hi (T2))),\n                                Big (Double_Uns (Lo (T2))));\n+      Lemma_Double_Big_2xxSingle;\n       pragma Assert\n         (Mult = Big_2xxDouble * Big (Double_Uns (Hi (T2)))\n               + Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n@@ -1890,7 +1912,14 @@ is\n                         Big_2xx (Scale), Big_2xxDouble);\n          Lemma_Lt_Mult (Big (Double_Uns (D (4))), Big_2xxSingle,\n                         Big_2xx (Scale), Big_2xxDouble);\n-         Lemma_Mult_Commutation (2 ** Scale, D (1) & D (2), T1);\n+         declare\n+            Two_xx_Scale : constant Double_Uns := Double_Uns'(2 ** Scale);\n+            D12          : constant Double_Uns := D (1) & D (2);\n+         begin\n+            pragma Assert (Big_2xx (Scale) * Big (D12) < Big_2xxDouble);\n+            pragma Assert (Big (Two_xx_Scale) * Big (D12) < Big_2xxDouble);\n+            Lemma_Mult_Commutation (Two_xx_Scale, D12, T1);\n+         end;\n          declare\n             Big_D12 : constant Big_Integer :=\n               Big_2xx (Scale) * Big (D (1) & D (2));\n@@ -1954,6 +1983,10 @@ is\n          pragma Assert\n            (Big (Double_Uns (Hi (T3))) + Big (Double_Uns (Hi (T2))) =\n               Big (Double_Uns (S1)));\n+         pragma Assert\n+           (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T3)))\n+            = Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (S1)));\n       end Prove_Multiplication;\n \n       -----------------------------\n@@ -2092,6 +2125,9 @@ is\n          Lemma_Div_Lt (Big (T1), Big_2xxSingle, Big (Double_Uns (Zlo)));\n          Lemma_Div_Commutation (T1, Double_Uns (Zlo));\n          Lemma_Lo_Is_Ident (T1 / Zlo);\n+         pragma Assert\n+           (Big (T2) <= Big_2xxSingle * (Big (Double_Uns (Zlo)) - 1)\n+                                      + Big (Double_Uns (D (4))));\n          Lemma_Div_Lt (Big (T2), Big_2xxSingle, Big (Double_Uns (Zlo)));\n          Lemma_Div_Commutation (T2, Double_Uns (Zlo));\n          Lemma_Lo_Is_Ident (T2 / Zlo);\n@@ -2304,6 +2340,9 @@ is\n          --  First normalize the divisor so that it has the leading bit on.\n          --  We do this by finding the appropriate left shift amount.\n \n+         Lemma_Lt_Commutation (D (1) & D (2), Zu);\n+         pragma Assert (Mult < Big_2xxDouble * Big (Zu));\n+\n          Shift := Single_Size;\n          Mask  := Single_Uns'Last;\n          Scale := 0;\n@@ -2376,6 +2415,8 @@ is\n                procedure Prove_Shift_Progress is null;\n \n             begin\n+               pragma Assert (Mask = Shift_Left (Single_Uns'Last,\n+                              Single_Size - Shift_Prev));\n                Prove_Power;\n \n                Shift := Shift / 2;\n@@ -2470,6 +2511,16 @@ is\n                                           + Big (Double_Uns (D (3))),\n             Big3 (D (1), D (2), D (3)),\n             Big (Double_Uns (D (4))));\n+         Lemma_Concat_Definition (D (1), D (2));\n+         Lemma_Double_Big_2xxSingle;\n+         Lemma_Substitution\n+           (Mult * Big_2xx (Scale), Big_2xxSingle * Big_2xxSingle,\n+              Big_2xxSingle * Big (Double_Uns (D (1)))\n+                            + Big (Double_Uns (D (2))),\n+              Big (D (1) & D (2)),\n+              Big_2xxSingle * Big (Double_Uns (D (3)))\n+                            + Big (Double_Uns (D (4))));\n+         pragma Assert (Big (D (1) & D (2)) < Big (Zu));\n \n          --  Loop to compute quotient digits, runs twice for Qd (1) and Qd (2)\n "}]}