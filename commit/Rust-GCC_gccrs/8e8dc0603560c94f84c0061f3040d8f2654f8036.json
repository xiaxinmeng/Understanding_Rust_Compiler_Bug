{"sha": "8e8dc0603560c94f84c0061f3040d8f2654f8036", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4ZGMwNjAzNTYwYzk0Zjg0YzAwNjFmMzA0MGQ4ZjI2NTRmODAzNg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-09-25T14:27:20Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-09-25T14:27:20Z"}, "message": "re PR fortran/45776 (Full implementation of variable definition contexts (and related checks))\n\n2010-09-25  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/45776\n\t* gfortran.h (struct gfc_dt): New member `dt_io_kind'.\n\t* io.c (resolve_tag): F2008 check for NEWUNIT and variable\n\tdefinition checks for NEWUNIT, IOSTAT, SIZE and IOMSG.\n\t(gfc_free_dt): Correctly handle freeing of `dt_io_kind' and\n\t`extra_comma' with changed semantics.\n\t(gfc_resolve_dt): Check variable definitions.\n\t(match_io_element): Remove INTENT and PURE checks here and\n\tinitialize code->ext.dt member.\n\t(match_io): Set dt->dt_io_kind.\n\t(gfc_resolve_inquire): Check variable definition for all tags\n\texcept UNIT, FILE and ID.\n\t* resolve.c (resolve_transfer): Variable definition check.\n\n2010-09-25  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/45776\n\t* gfortran.dg/io_constraints_6.f03: New test.\n\t* gfortran.dg/io_constraints_7.f03: New test.\n\t* gfortran.dg/newunit_2.f90: New test.\n\nFrom-SVN: r164619", "tree": {"sha": "545accb9fd475dcf562501179762b5ef130d655c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/545accb9fd475dcf562501179762b5ef130d655c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8dc0603560c94f84c0061f3040d8f2654f8036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8dc0603560c94f84c0061f3040d8f2654f8036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8dc0603560c94f84c0061f3040d8f2654f8036", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8dc0603560c94f84c0061f3040d8f2654f8036/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c21136eebbf57975d027b64730703553fcbc1b09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21136eebbf57975d027b64730703553fcbc1b09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21136eebbf57975d027b64730703553fcbc1b09"}], "stats": {"total": 329, "additions": 239, "deletions": 90}, "files": [{"sha": "40b472080cc59687b987c6d1876b2b094618c753", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -1,3 +1,19 @@\n+2010-09-25  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/45776\n+\t* gfortran.h (struct gfc_dt): New member `dt_io_kind'.\n+\t* io.c (resolve_tag): F2008 check for NEWUNIT and variable\n+\tdefinition checks for NEWUNIT, IOSTAT, SIZE and IOMSG.\n+\t(gfc_free_dt): Correctly handle freeing of `dt_io_kind' and\n+\t`extra_comma' with changed semantics.\n+\t(gfc_resolve_dt): Check variable definitions.\n+\t(match_io_element): Remove INTENT and PURE checks here and\n+\tinitialize code->ext.dt member.\n+\t(match_io): Set dt->dt_io_kind.\n+\t(gfc_resolve_inquire): Check variable definition for all tags\n+\texcept UNIT, FILE and ID.\n+\t* resolve.c (resolve_transfer): Variable definition check.\n+\n 2010-09-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* interface.c (gfc_match_end_interface): Constify char pointer"}, {"sha": "b9c79f26878f764eb98648e4b689208a89eb7425", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -2000,7 +2000,7 @@ typedef struct\n {\n   gfc_expr *io_unit, *format_expr, *rec, *advance, *iostat, *size, *iomsg,\n \t   *id, *pos, *asynchronous, *blank, *decimal, *delim, *pad, *round,\n-\t   *sign, *extra_comma;\n+\t   *sign, *extra_comma, *dt_io_kind;\n \n   gfc_symbol *namelist;\n   /* A format_label of `format_asterisk' indicates the \"*\" format */"}, {"sha": "e80202fab06273cd8fd031a11f495c40bc573353", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 116, "deletions": 89, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -1505,13 +1505,31 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n \treturn FAILURE;\n     }\n \n+  if (tag == &tag_newunit)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: NEWUNIT specifier\"\n+\t\t\t  \" at %L\", &e->where) == FAILURE)\n+\treturn FAILURE;\n+    }\n+\n+  /* NEWUNIT, IOSTAT, SIZE and IOMSG are variable definition contexts.  */\n+  if (tag == &tag_newunit || tag == &tag_iostat\n+      || tag == &tag_size || tag == &tag_iomsg)\n+    {\n+      char context[64];\n+\n+      sprintf (context, _(\"%s tag\"), tag->name);\n+      if (gfc_check_vardef_context (e, false, context) == FAILURE)\n+\treturn FAILURE;\n+    }\n+  \n   if (tag == &tag_convert)\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: CONVERT tag at %L\",\n \t\t\t  &e->where) == FAILURE)\n \treturn FAILURE;\n     }\n-  \n+\n   return SUCCESS;\n }\n \n@@ -2707,8 +2725,9 @@ gfc_free_dt (gfc_dt *dt)\n   gfc_free_expr (dt->round);\n   gfc_free_expr (dt->blank);\n   gfc_free_expr (dt->decimal);\n-  gfc_free_expr (dt->extra_comma);\n   gfc_free_expr (dt->pos);\n+  gfc_free_expr (dt->dt_io_kind);\n+  /* dt->extra_comma is a link to dt_io_kind if it is set.  */\n   gfc_free (dt);\n }\n \n@@ -2719,6 +2738,11 @@ gfc_try\n gfc_resolve_dt (gfc_dt *dt, locus *loc)\n {\n   gfc_expr *e;\n+  io_kind k;\n+\n+  /* This is set in any case.  */\n+  gcc_assert (dt->dt_io_kind);\n+  k = dt->dt_io_kind->value.iokind;\n \n   RESOLVE_TAG (&tag_format, dt->format_expr);\n   RESOLVE_TAG (&tag_rec, dt->rec);\n@@ -2761,16 +2785,13 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t     type character, we assume its really the \"format\" form of the I/O\n \t     statement.  We set the io_unit to the default unit and format to\n \t     the character expression.  See F95 Standard section 9.4.  */\n-\t  io_kind k;\n-\t  k = dt->extra_comma->value.iokind;\n \t  if (e->ts.type == BT_CHARACTER && (k == M_READ || k == M_PRINT))\n \t    {\n \t      dt->format_expr = dt->io_unit;\n \t      dt->io_unit = default_unit (k);\n \n-\t      /* Free this pointer now so that a warning/error is not triggered\n-\t\t below for the \"Extension\".  */\n-\t      gfc_free_expr (dt->extra_comma);\n+\t      /* Nullify this pointer now so that a warning/error is not\n+\t\t triggered below for the \"Extension\".  */\n \t      dt->extra_comma = NULL;\n \t    }\n \n@@ -2790,6 +2811,13 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t  gfc_error (\"Internal unit with vector subscript at %L\", &e->where);\n \t  return FAILURE;\n \t}\n+\n+      /* If we are writing, make sure the internal unit can be changed.  */\n+      gcc_assert (k != M_PRINT);\n+      if (k == M_WRITE\n+\t  && gfc_check_vardef_context (e, false, _(\"internal unit in WRITE\"))\n+\t       == FAILURE)\n+\treturn FAILURE;\n     }\n \n   if (e->rank && e->ts.type != BT_CHARACTER)\n@@ -2801,10 +2829,36 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n   if (e->expr_type == EXPR_CONSTANT && e->ts.type == BT_INTEGER\n       && mpz_sgn (e->value.integer) < 0)\n     {\n-      gfc_error (\"UNIT number in statement at %L must be non-negative\", &e->where);\n+      gfc_error (\"UNIT number in statement at %L must be non-negative\",\n+\t\t &e->where);\n       return FAILURE;\n     }\n \n+  /* If we are reading and have a namelist, check that all namelist symbols\n+     can appear in a variable definition context.  */\n+  if (k == M_READ && dt->namelist)\n+    {\n+      gfc_namelist* n;\n+      for (n = dt->namelist->namelist; n; n = n->next)\n+\t{\n+\t  gfc_expr* e;\n+\t  gfc_try t;\n+\n+\t  e = gfc_get_variable_expr (gfc_find_sym_in_symtree (n->sym));\n+\t  t = gfc_check_vardef_context (e, false, NULL);\n+\t  gfc_free_expr (e);\n+\n+\t  if (t == FAILURE)\n+\t    {\n+\t      gfc_error (\"NAMELIST '%s' in READ statement at %L contains\"\n+\t\t\t \" the symbol '%s' which may not appear in a\"\n+\t\t\t \" variable definition context\",\n+\t\t\t dt->namelist->name, loc, n->sym->name);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+    }\n+\n   if (dt->extra_comma\n       && gfc_notify_std (GFC_STD_GNU, \"Extension: Comma before i/o \"\n \t\t\t \"item list at %L\", &dt->extra_comma->where) == FAILURE)\n@@ -2854,6 +2908,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t\t &dt->format_label->where);\n       return FAILURE;\n     }\n+\n   return SUCCESS;\n }\n \n@@ -3012,50 +3067,8 @@ match_io_element (io_kind k, gfc_code **cpp)\n \t\t   io_kind_name (k));\n     }\n \n-  if (m == MATCH_YES)\n-    switch (k)\n-      {\n-      case M_READ:\n-\tif (expr->symtree->n.sym->attr.intent == INTENT_IN)\n-\t  {\n-\t    gfc_error (\"Variable '%s' in input list at %C cannot be \"\n-\t\t       \"INTENT(IN)\", expr->symtree->n.sym->name);\n-\t    m = MATCH_ERROR;\n-\t  }\n-\n-\tif (gfc_pure (NULL)\n-\t    && gfc_impure_variable (expr->symtree->n.sym)\n-\t    && current_dt->io_unit\n-\t    && current_dt->io_unit->ts.type == BT_CHARACTER)\n-\t  {\n-\t    gfc_error (\"Cannot read to variable '%s' in PURE procedure at %C\",\n-\t\t       expr->symtree->n.sym->name);\n-\t    m = MATCH_ERROR;\n-\t  }\n-\n-\tif (gfc_check_do_variable (expr->symtree))\n-\t  m = MATCH_ERROR;\n-\n-\tbreak;\n-\n-      case M_WRITE:\n-\tif (current_dt->io_unit\n-\t    && current_dt->io_unit->ts.type == BT_CHARACTER\n-\t    && gfc_pure (NULL)\n-\t    && current_dt->io_unit->expr_type == EXPR_VARIABLE\n-\t    && gfc_impure_variable (current_dt->io_unit->symtree->n.sym))\n-\t  {\n-\t    gfc_error (\"Cannot write to internal file unit '%s' at %C \"\n-\t\t       \"inside a PURE procedure\",\n-\t\t       current_dt->io_unit->symtree->n.sym->name);\n-\t    m = MATCH_ERROR;\n-\t  }\n-\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n+  if (m == MATCH_YES && k == M_READ && gfc_check_do_variable (expr->symtree))\n+    m = MATCH_ERROR;\n \n   if (m != MATCH_YES)\n     {\n@@ -3066,6 +3079,7 @@ match_io_element (io_kind k, gfc_code **cpp)\n   cp = gfc_get_code ();\n   cp->op = EXEC_TRANSFER;\n   cp->expr1 = expr;\n+  cp->ext.dt = current_dt;\n \n   *cpp = cp;\n   return MATCH_YES;\n@@ -3657,14 +3671,14 @@ match_io (io_kind k)\n   /* Used in check_io_constraints, where no locus is available.  */\n   spec_end = gfc_current_locus;\n \n+  /* Save the IO kind for later use.  */\n+  dt->dt_io_kind = gfc_get_iokind_expr (&gfc_current_locus, k);\n+\n   /* Optional leading comma (non-standard).  We use a gfc_expr structure here\n      to save the locus.  This is used later when resolving transfer statements\n      that might have a format expression without unit number.  */\n   if (!comma_flag && gfc_match_char (',') == MATCH_YES)\n-    {\n-      /* Save the iokind and locus for later use in resolution.  */\n-      dt->extra_comma = gfc_get_iokind_expr (&gfc_current_locus, k);\n-    }\n+    dt->extra_comma = dt->dt_io_kind;\n \n   io_code = NULL;\n   if (gfc_match_eos () != MATCH_YES)\n@@ -3973,41 +3987,54 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n {\n   RESOLVE_TAG (&tag_unit, inquire->unit);\n   RESOLVE_TAG (&tag_file, inquire->file);\n-  RESOLVE_TAG (&tag_iomsg, inquire->iomsg);\n-  RESOLVE_TAG (&tag_iostat, inquire->iostat);\n-  RESOLVE_TAG (&tag_exist, inquire->exist);\n-  RESOLVE_TAG (&tag_opened, inquire->opened);\n-  RESOLVE_TAG (&tag_number, inquire->number);\n-  RESOLVE_TAG (&tag_named, inquire->named);\n-  RESOLVE_TAG (&tag_name, inquire->name);\n-  RESOLVE_TAG (&tag_s_access, inquire->access);\n-  RESOLVE_TAG (&tag_sequential, inquire->sequential);\n-  RESOLVE_TAG (&tag_direct, inquire->direct);\n-  RESOLVE_TAG (&tag_s_form, inquire->form);\n-  RESOLVE_TAG (&tag_formatted, inquire->formatted);\n-  RESOLVE_TAG (&tag_unformatted, inquire->unformatted);\n-  RESOLVE_TAG (&tag_s_recl, inquire->recl);\n-  RESOLVE_TAG (&tag_nextrec, inquire->nextrec);\n-  RESOLVE_TAG (&tag_s_blank, inquire->blank);\n-  RESOLVE_TAG (&tag_s_position, inquire->position);\n-  RESOLVE_TAG (&tag_s_action, inquire->action);\n-  RESOLVE_TAG (&tag_read, inquire->read);\n-  RESOLVE_TAG (&tag_write, inquire->write);\n-  RESOLVE_TAG (&tag_readwrite, inquire->readwrite);\n-  RESOLVE_TAG (&tag_s_delim, inquire->delim);\n-  RESOLVE_TAG (&tag_s_pad, inquire->pad);\n-  RESOLVE_TAG (&tag_s_encoding, inquire->encoding);\n-  RESOLVE_TAG (&tag_s_round, inquire->round);\n-  RESOLVE_TAG (&tag_iolength, inquire->iolength);\n-  RESOLVE_TAG (&tag_convert, inquire->convert);\n-  RESOLVE_TAG (&tag_strm_out, inquire->strm_pos);\n-  RESOLVE_TAG (&tag_s_async, inquire->asynchronous);\n-  RESOLVE_TAG (&tag_s_sign, inquire->sign);\n-  RESOLVE_TAG (&tag_s_round, inquire->round);\n-  RESOLVE_TAG (&tag_pending, inquire->pending);\n-  RESOLVE_TAG (&tag_size, inquire->size);\n   RESOLVE_TAG (&tag_id, inquire->id);\n \n+  /* For INQUIRE, all tags except FILE, ID and UNIT are variable definition\n+     contexts.  Thus, use an extended RESOLVE_TAG macro for that.  */\n+#define INQUIRE_RESOLVE_TAG(tag, expr) \\\n+  RESOLVE_TAG (tag, expr); \\\n+  if (expr) \\\n+    { \\\n+      char context[64]; \\\n+      sprintf (context, _(\"%s tag with INQUIRE\"), (tag)->name); \\\n+      if (gfc_check_vardef_context ((expr), false, context) == FAILURE) \\\n+\treturn FAILURE; \\\n+    }\n+  INQUIRE_RESOLVE_TAG (&tag_iomsg, inquire->iomsg);\n+  INQUIRE_RESOLVE_TAG (&tag_iostat, inquire->iostat);\n+  INQUIRE_RESOLVE_TAG (&tag_exist, inquire->exist);\n+  INQUIRE_RESOLVE_TAG (&tag_opened, inquire->opened);\n+  INQUIRE_RESOLVE_TAG (&tag_number, inquire->number);\n+  INQUIRE_RESOLVE_TAG (&tag_named, inquire->named);\n+  INQUIRE_RESOLVE_TAG (&tag_name, inquire->name);\n+  INQUIRE_RESOLVE_TAG (&tag_s_access, inquire->access);\n+  INQUIRE_RESOLVE_TAG (&tag_sequential, inquire->sequential);\n+  INQUIRE_RESOLVE_TAG (&tag_direct, inquire->direct);\n+  INQUIRE_RESOLVE_TAG (&tag_s_form, inquire->form);\n+  INQUIRE_RESOLVE_TAG (&tag_formatted, inquire->formatted);\n+  INQUIRE_RESOLVE_TAG (&tag_unformatted, inquire->unformatted);\n+  INQUIRE_RESOLVE_TAG (&tag_s_recl, inquire->recl);\n+  INQUIRE_RESOLVE_TAG (&tag_nextrec, inquire->nextrec);\n+  INQUIRE_RESOLVE_TAG (&tag_s_blank, inquire->blank);\n+  INQUIRE_RESOLVE_TAG (&tag_s_position, inquire->position);\n+  INQUIRE_RESOLVE_TAG (&tag_s_action, inquire->action);\n+  INQUIRE_RESOLVE_TAG (&tag_read, inquire->read);\n+  INQUIRE_RESOLVE_TAG (&tag_write, inquire->write);\n+  INQUIRE_RESOLVE_TAG (&tag_readwrite, inquire->readwrite);\n+  INQUIRE_RESOLVE_TAG (&tag_s_delim, inquire->delim);\n+  INQUIRE_RESOLVE_TAG (&tag_s_pad, inquire->pad);\n+  INQUIRE_RESOLVE_TAG (&tag_s_encoding, inquire->encoding);\n+  INQUIRE_RESOLVE_TAG (&tag_s_round, inquire->round);\n+  INQUIRE_RESOLVE_TAG (&tag_iolength, inquire->iolength);\n+  INQUIRE_RESOLVE_TAG (&tag_convert, inquire->convert);\n+  INQUIRE_RESOLVE_TAG (&tag_strm_out, inquire->strm_pos);\n+  INQUIRE_RESOLVE_TAG (&tag_s_async, inquire->asynchronous);\n+  INQUIRE_RESOLVE_TAG (&tag_s_sign, inquire->sign);\n+  INQUIRE_RESOLVE_TAG (&tag_s_round, inquire->round);\n+  INQUIRE_RESOLVE_TAG (&tag_pending, inquire->pending);\n+  INQUIRE_RESOLVE_TAG (&tag_size, inquire->size);\n+#undef INQUIRE_RESOLVE_TAG\n+\n   if (gfc_reference_st_label (inquire->err, ST_LABEL_TARGET) == FAILURE)\n     return FAILURE;\n "}, {"sha": "0dce3f86b180d12c2c5f0ea86de5495a840d2063", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -7916,6 +7916,13 @@ resolve_transfer (gfc_code *code)\n \t\t      && exp->expr_type != EXPR_FUNCTION))\n     return;\n \n+  /* If we are reading, the variable will be changed.  Note that\n+     code->ext.dt may be NULL if the TRANSFER is related to\n+     an INQUIRE statement -- but in this case, we are not reading, either.  */\n+  if (code->ext.dt && code->ext.dt->dt_io_kind->value.iokind == M_READ\n+      && gfc_check_vardef_context (exp, false, _(\"item in READ\")) == FAILURE)\n+    return;\n+\n   sym = exp->symtree->n.sym;\n   ts = &sym->ts;\n "}, {"sha": "6a65c793d11b428180d3ddf3d9b183df242de2da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -1,3 +1,10 @@\n+2010-09-25  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/45776\n+\t* gfortran.dg/io_constraints_6.f03: New test.\n+\t* gfortran.dg/io_constraints_7.f03: New test.\n+\t* gfortran.dg/newunit_2.f90: New test.\n+\n 2010-09-24  Steven G. Kargl  < kargl@gcc.gnu.org>\n \n \t* testsuite/gfortran.dg/operator_c1202.f90: New test."}, {"sha": "d0484f5f4fe1b542f18619290c251152f3ee96b6", "filename": "gcc/testsuite/gfortran.dg/io_constraints_6.f03", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_6.f03?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+\n+! PR fortran/45776\n+! Variable definition context checks related to IO.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+module m\n+  implicit none\n+\n+  integer, protected :: a\n+  character(len=128), protected :: str\n+end module m\n+\n+program main\n+  use :: m\n+  integer, parameter :: b = 42\n+  integer :: x\n+  character(len=128) :: myStr\n+\n+  namelist /definable/ x, myStr\n+  namelist /undefinable/ x, a\n+\n+  ! These are invalid.\n+  read (myStr, *) a ! { dg-error \"variable definition context\" }\n+  read (myStr, *) x, b ! { dg-error \"variable definition context\" }\n+  write (str, *) 5 ! { dg-error \"variable definition context\" }\n+  read (*, nml=undefinable) ! { dg-error \"contains the symbol 'a' which may not\" }\n+\n+  ! These are ok.\n+  read (str, *) x\n+  write (myStr, *) a\n+  write (myStr, *) b\n+  print *, a, b\n+  write (*, nml=undefinable)\n+  read (*, nml=definable)\n+  write (*, nml=definable)\n+end program main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "4d1849198148299dd149e76d2e1e4694f791471e", "filename": "gcc/testsuite/gfortran.dg/io_constraints_7.f03", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_7.f03?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+\n+! PR fortran/45776\n+! Variable definition context checks related to IO.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+module m\n+  implicit none\n+  integer, protected :: a\n+  character(len=128), protected :: msg\n+end module m\n+\n+program main\n+  use :: m\n+  integer :: x\n+  logical :: bool\n+\n+  write (*, iostat=a) 42 ! { dg-error \"variable definition context\" }\n+  write (*, iomsg=msg) 42 ! { dg-error \"variable definition context\" }\n+  read (*, '(I2)', advance='no', size=a) x ! { dg-error \"variable definition context\" }\n+\n+  ! These are ok.\n+  inquire (unit=a)\n+  inquire (file=msg, id=a, pending=bool)\n+  inquire (file=msg)\n+\n+  ! These not, but list is not extensive.\n+  inquire (unit=1, number=a) ! { dg-error \"variable definition context\" }\n+  inquire (unit=1, encoding=msg) ! { dg-error \"variable definition context\" }\n+  inquire (unit=1, formatted=msg) ! { dg-error \"variable definition context\" }\n+\n+  open (newunit=a, file=\"foo\") ! { dg-error \"variable definition context\" }\n+  close (unit=a)\n+end program main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "b0f797a0736ed3ef570586ccde64ee95903bc20f", "filename": "gcc/testsuite/gfortran.dg/newunit_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fnewunit_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8dc0603560c94f84c0061f3040d8f2654f8036/gcc%2Ftestsuite%2Fgfortran.dg%2Fnewunit_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnewunit_2.f90?ref=8e8dc0603560c94f84c0061f3040d8f2654f8036", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! PR40008 F2008: Add NEWUNIT= for OPEN statement \n+! Check for rejection with pre-F2008 standard.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+program main\n+  character(len=25) :: str\n+  integer(1) :: myunit\n+\n+  open (newunit=myunit, file=\"some_file\") ! { dg-error \"Fortran 2008\" }\n+  close (unit=myunit)\n+end program main"}]}