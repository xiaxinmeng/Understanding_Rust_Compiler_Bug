{"sha": "e85baec793f3560bdace25d061dd05874ff5cd2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg1YmFlYzc5M2YzNTYwYmRhY2UyNWQwNjFkZDA1ODc0ZmY1Y2QyZg==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-04-17T20:42:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-04-17T20:42:31Z"}, "message": "compiler: Use backend interface for constant expressions.\n\n\t* go-gcc.cc (Gcc_backend::named_constant_expression): New\n\tfunction.\n\nFrom-SVN: r209495", "tree": {"sha": "0f0a7fc9a1aefaaab07c083ef183efc2a474f3d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f0a7fc9a1aefaaab07c083ef183efc2a474f3d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e85baec793f3560bdace25d061dd05874ff5cd2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85baec793f3560bdace25d061dd05874ff5cd2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85baec793f3560bdace25d061dd05874ff5cd2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85baec793f3560bdace25d061dd05874ff5cd2f/comments", "author": null, "committer": null, "parents": [{"sha": "be7341a882e4ee6d493b2b2940f9cbb37b15d515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7341a882e4ee6d493b2b2940f9cbb37b15d515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7341a882e4ee6d493b2b2940f9cbb37b15d515"}], "stats": {"total": 98, "additions": 54, "deletions": 44}, "files": [{"sha": "c8beaec2c94568a157c8cbaf70e1f4bc8fb8ab34", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e85baec793f3560bdace25d061dd05874ff5cd2f", "patch": "@@ -1,3 +1,8 @@\n+2014-04-17  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::named_constant_expression): New\n+\tfunction.\n+\n 2014-04-14  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc: Include \"convert.h\"."}, {"sha": "1af639ef1acd6f8694c25ee5ddd4bb0c422d73f7", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=e85baec793f3560bdace25d061dd05874ff5cd2f", "patch": "@@ -226,6 +226,10 @@ class Gcc_backend : public Backend\n   Bexpression*\n   indirect_expression(Bexpression* expr, bool known_valid, Location);\n \n+  Bexpression*\n+  named_constant_expression(Btype* btype, const std::string& name,\n+\t\t\t    Bexpression* val, Location);\n+\n   Bexpression*\n   integer_constant_expression(Btype* btype, mpz_t val);\n \n@@ -962,6 +966,29 @@ Gcc_backend::indirect_expression(Bexpression* expr, bool known_valid,\n   return tree_to_expr(ret);\n }\n \n+// Return an expression that declares a constant named NAME with the\n+// constant value VAL in BTYPE.\n+\n+Bexpression*\n+Gcc_backend::named_constant_expression(Btype* btype, const std::string& name,\n+\t\t\t\t       Bexpression* val, Location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  tree const_val = val->get_tree();\n+  if (type_tree == error_mark_node || const_val == error_mark_node)\n+    return this->error_expression();\n+\n+  tree name_tree = get_identifier_from_string(name);\n+  tree decl = build_decl(location.gcc_location(), CONST_DECL, name_tree,\n+\t\t\t type_tree);\n+  DECL_INITIAL(decl) = const_val;\n+  TREE_CONSTANT(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+\n+  go_preserve_from_gc(decl);\n+  return this->make_expression(decl);\n+}\n+\n // Return a typed value as a constant integer.\n \n Bexpression*"}, {"sha": "dd76204e70c76e927ae17223dc55bd6b7833670d", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=e85baec793f3560bdace25d061dd05874ff5cd2f", "patch": "@@ -257,6 +257,12 @@ class Backend\n   virtual Bexpression*\n   indirect_expression(Bexpression* expr, bool known_valid, Location) = 0;\n \n+  // Return an expression that declares a constant named NAME with the\n+  // constant value VAL in BTYPE.\n+  virtual Bexpression*\n+  named_constant_expression(Btype* btype, const std::string& name,\n+                             Bexpression* val, Location) = 0;\n+\n   // Return an expression for the multi-precision integer VAL in BTYPE.\n   virtual Bexpression*\n   integer_constant_expression(Btype* btype, mpz_t val) = 0;"}, {"sha": "74ae9ddcd7d63bcea9b6c1a9b607f6af470f9eeb", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e85baec793f3560bdace25d061dd05874ff5cd2f", "patch": "@@ -2792,12 +2792,12 @@ Const_expression::do_get_tree(Translate_context* context)\n   // If the type has been set for this expression, but the underlying\n   // object is an abstract int or float, we try to get the abstract\n   // value.  Otherwise we may lose something in the conversion.\n+  Expression* expr = this->constant_->const_value()->expr();\n   if (this->type_ != NULL\n       && this->type_->is_numeric_type()\n       && (this->constant_->const_value()->type() == NULL\n \t  || this->constant_->const_value()->type()->is_abstract()))\n     {\n-      Expression* expr = this->constant_->const_value()->expr();\n       Numeric_constant nc;\n       if (expr->numeric_constant_value(&nc)\n \t  && nc.set_type(this->type_, false, this->location()))\n@@ -2807,15 +2807,9 @@ Const_expression::do_get_tree(Translate_context* context)\n \t}\n     }\n \n-  Gogo* gogo = context->gogo();\n-  Bexpression* ret =\n-      tree_to_expr(this->constant_->get_tree(gogo, context->function()));\n   if (this->type_ != NULL)\n-    {\n-      Btype* btype = this->type_->get_backend(gogo);\n-      ret = gogo->backend()->convert_expression(btype, ret, this->location());\n-    }\n-  return expr_to_tree(ret);\n+    expr = Expression::make_cast(this->type_, expr, this->location());\n+  return expr->get_tree(context);\n }\n \n // Dump ast representation for constant expression."}, {"sha": "32a7f38093fb277cd11a21618e8a1b6f2090bde7", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e85baec793f3560bdace25d061dd05874ff5cd2f/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=e85baec793f3560bdace25d061dd05874ff5cd2f", "patch": "@@ -1015,44 +1015,22 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n     {\n     case NAMED_OBJECT_CONST:\n       {\n-\tNamed_constant* named_constant = this->u_.const_value;\n \tTranslate_context subcontext(gogo, function, NULL, NULL);\n-\ttree expr_tree = named_constant->expr()->get_tree(&subcontext);\n-\tif (expr_tree == error_mark_node)\n-\t  decl = error_mark_node;\n-\telse\n+\tType* type = this->u_.const_value->type();\n+\tLocation loc = this->location();\n+\n+\tExpression* const_ref = Expression::make_const_reference(this, loc);\n+        Bexpression* const_decl =\n+\t  tree_to_expr(const_ref->get_tree(&subcontext));\n+\tif (type != NULL && type->is_numeric_type())\n \t  {\n-\t    Type* type = named_constant->type();\n-\t    if (type != NULL && !type->is_abstract())\n-\t      {\n-\t\tif (type->is_error())\n-\t\t  expr_tree = error_mark_node;\n-\t\telse\n-\t\t  {\n-\t\t    Btype* btype = type->get_backend(gogo);\n-\t\t    expr_tree = fold_convert(type_to_tree(btype), expr_tree);\n-\t\t  }\n-\t      }\n-\t    if (expr_tree == error_mark_node)\n-\t      decl = error_mark_node;\n-\t    else if (INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n-\t      {\n-                tree name = get_identifier_from_string(this->get_id(gogo));\n-\t\tdecl = build_decl(named_constant->location().gcc_location(),\n-                                  CONST_DECL, name, TREE_TYPE(expr_tree));\n-\t\tDECL_INITIAL(decl) = expr_tree;\n-\t\tTREE_CONSTANT(decl) = 1;\n-\t\tTREE_READONLY(decl) = 1;\n-\t      }\n-\t    else\n-\t      {\n-\t\t// A CONST_DECL is only for an enum constant, so we\n-\t\t// shouldn't use for non-integral types.  Instead we\n-\t\t// just return the constant itself, rather than a\n-\t\t// decl.\n-\t\tdecl = expr_tree;\n-\t      }\n+\t    Btype* btype = type->get_backend(gogo);\n+\t    std::string name = this->get_id(gogo);\n+            const_decl =\n+\t      gogo->backend()->named_constant_expression(btype, name,\n+\t\t\t\t\t\t\t const_decl, loc);\n \t  }\n+\tdecl = expr_to_tree(const_decl);\n       }\n       break;\n "}]}