{"sha": "4359b6318f9cb0861b25cd174e8a1a07f1740c27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1OWI2MzE4ZjljYjA4NjFiMjVjZDE3NGU4YTFhMDdmMTc0MGMyNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-11-16T16:25:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-11-16T16:25:12Z"}, "message": "tree-switch-conversion.h (switch_decision_tree::emit_case_nodes): Add location_t parameter.\n\n\t* tree-switch-conversion.h (switch_decision_tree::emit_case_nodes): Add\n\tlocation_t parameter.\n\t(switch_decision_tree::emit_cmp_and_jump_insns): Likewise.\n\t(switch_decision_tree::do_jump_if_equal): Likewise.\n\t* tree-switch-conversion.c (switch_decision_tree::emit): Pass location\n\tof switch statement to emit_case_nodes.\n\t(switch_decision_tree::emit_cmp_and_jump_insns): Add LOC parameter and\n\tset it on the newly built GIMPLE comparison statement.\n\t(switch_decision_tree::do_jump_if_equal): Likewise.\n\t(switch_decision_tree::emit_case_nodes): Add LOC parameter and pass it\n\tin calls to do_jump_if_equal as well as recursive calls.\n\nFrom-SVN: r266213", "tree": {"sha": "ab78cd034280d2cd5b2839d4bfa3ee373ceb277e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab78cd034280d2cd5b2839d4bfa3ee373ceb277e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4359b6318f9cb0861b25cd174e8a1a07f1740c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4359b6318f9cb0861b25cd174e8a1a07f1740c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4359b6318f9cb0861b25cd174e8a1a07f1740c27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4359b6318f9cb0861b25cd174e8a1a07f1740c27/comments", "author": null, "committer": null, "parents": [{"sha": "83044e4fcc7b3f7514eaa84b31f44608ae5fbaf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83044e4fcc7b3f7514eaa84b31f44608ae5fbaf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83044e4fcc7b3f7514eaa84b31f44608ae5fbaf1"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "a7171079517222e2349f0c7d7e40aa92ac9d5fec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4359b6318f9cb0861b25cd174e8a1a07f1740c27", "patch": "@@ -1,3 +1,17 @@\n+2018-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-switch-conversion.h (switch_decision_tree::emit_case_nodes): Add\n+\tlocation_t parameter.\n+\t(switch_decision_tree::emit_cmp_and_jump_insns): Likewise.\n+\t(switch_decision_tree::do_jump_if_equal): Likewise.\n+\t* tree-switch-conversion.c (switch_decision_tree::emit): Pass location\n+\tof switch statement to emit_case_nodes.\n+\t(switch_decision_tree::emit_cmp_and_jump_insns): Add LOC parameter and\n+\tset it on the newly built GIMPLE comparison statement.\n+\t(switch_decision_tree::do_jump_if_equal): Likewise.\n+\t(switch_decision_tree::emit_case_nodes): Add LOC parameter and pass it\n+\tin calls to do_jump_if_equal as well as recursive calls.\n+\n 2018-11-16  Andi Kleen  <ak@linux.intel.com>\n \n \t* config/i386/i386.md: Allow memory operands to ptwrite."}, {"sha": "2f1ee8cef862ba214ff2dd5cbb649c2c457ad24e", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=4359b6318f9cb0861b25cd174e8a1a07f1740c27", "patch": "@@ -1942,7 +1942,8 @@ switch_decision_tree::emit (basic_block bb, tree index_expr,\n       dump_case_nodes (dump_file, m_case_list, indent_step, 0);\n     }\n \n-  bb = emit_case_nodes (bb, index_expr, m_case_list, default_prob, index_type);\n+  bb = emit_case_nodes (bb, index_expr, m_case_list, default_prob, index_type,\n+\t\t\tgimple_location (m_switch));\n \n   if (bb)\n     emit_jump (bb, m_default_bb);\n@@ -2085,12 +2086,14 @@ basic_block\n switch_decision_tree::emit_cmp_and_jump_insns (basic_block bb, tree op0,\n \t\t\t\t\t       tree op1, tree_code comparison,\n \t\t\t\t\t       basic_block label_bb,\n-\t\t\t\t\t       profile_probability prob)\n+\t\t\t\t\t       profile_probability prob,\n+\t\t\t\t\t       location_t loc)\n {\n   // TODO: it's once called with lhs != index.\n   op1 = fold_convert (TREE_TYPE (op0), op1);\n \n   gcond *cond = gimple_build_cond (comparison, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_set_location (cond, loc);\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   gsi_insert_after (&gsi, cond, GSI_NEW_STMT);\n \n@@ -2114,11 +2117,13 @@ switch_decision_tree::emit_cmp_and_jump_insns (basic_block bb, tree op0,\n basic_block\n switch_decision_tree::do_jump_if_equal (basic_block bb, tree op0, tree op1,\n \t\t\t\t\tbasic_block label_bb,\n-\t\t\t\t\tprofile_probability prob)\n+\t\t\t\t\tprofile_probability prob,\n+\t\t\t\t\tlocation_t loc)\n {\n   op1 = fold_convert (TREE_TYPE (op0), op1);\n \n   gcond *cond = gimple_build_cond (EQ_EXPR, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_set_location (cond, loc);\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   gsi_insert_before (&gsi, cond, GSI_SAME_STMT);\n \n@@ -2145,7 +2150,7 @@ basic_block\n switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t\t\t\t       case_tree_node *node,\n \t\t\t\t       profile_probability default_prob,\n-\t\t\t\t       tree index_type)\n+\t\t\t\t       tree index_type, location_t loc)\n {\n   profile_probability p;\n \n@@ -2160,7 +2165,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t this node and then check our children, if any.  */\n       p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n       bb = do_jump_if_equal (bb, index, node->m_c->get_low (),\n-\t\t\t     node->m_c->m_case_bb, p);\n+\t\t\t     node->m_c->m_case_bb, p, loc);\n       /* Since this case is taken at this point, reduce its weight from\n \t subtree_weight.  */\n       node->m_c->m_subtree_prob -= p;\n@@ -2181,12 +2186,12 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      p = (node->m_right->m_c->m_prob\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = do_jump_if_equal (bb, index, node->m_right->m_c->get_low (),\n-\t\t\t\t     node->m_right->m_c->m_case_bb, p);\n+\t\t\t\t     node->m_right->m_c->m_case_bb, p, loc);\n \n \t      p = (node->m_left->m_c->m_prob\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = do_jump_if_equal (bb, index, node->m_left->m_c->get_low (),\n-\t\t\t\t     node->m_left->m_c->m_case_bb, p);\n+\t\t\t\t     node->m_left->m_c->m_case_bb, p, loc);\n \t    }\n \t  else\n \t    {\n@@ -2199,20 +2204,20 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t\t    + default_prob.apply_scale (1, 2))\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n-\t\t\t\t\t    GT_EXPR, test_bb, p);\n+\t\t\t\t\t    GT_EXPR, test_bb, p, loc);\n \t      default_prob = default_prob.apply_scale (1, 2);\n \n \t      /* Handle the left-hand subtree.  */\n \t      bb = emit_case_nodes (bb, index, node->m_left,\n-\t\t\t\t    default_prob, index_type);\n+\t\t\t\t    default_prob, index_type, loc);\n \n \t      /* If the left-hand subtree fell through,\n \t\t don't let it fall into the right-hand subtree.  */\n \t      if (bb && m_default_bb)\n \t\temit_jump (bb, m_default_bb);\n \n \t      bb = emit_case_nodes (test_bb, index, node->m_right,\n-\t\t\t\t    default_prob, index_type);\n+\t\t\t\t    default_prob, index_type, loc);\n \t    }\n \t}\n       else if (node->m_left == NULL && node->m_right != NULL)\n@@ -2232,11 +2237,11 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      p = (default_prob.apply_scale (1, 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n-\t\t\t\t\t    LT_EXPR, m_default_bb, p);\n+\t\t\t\t\t    LT_EXPR, m_default_bb, p, loc);\n \t      default_prob = default_prob.apply_scale (1, 2);\n \n \t      bb = emit_case_nodes (bb, index, node->m_right, default_prob,\n-\t\t\t\t    index_type);\n+\t\t\t\t    index_type, loc);\n \t    }\n \t  else\n \t    {\n@@ -2246,7 +2251,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      p = (node->m_right->m_c->m_subtree_prob\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = do_jump_if_equal (bb, index, node->m_right->m_c->get_low (),\n-\t\t\t\t     node->m_right->m_c->m_case_bb, p);\n+\t\t\t\t     node->m_right->m_c->m_case_bb, p, loc);\n \t    }\n \t}\n       else if (node->m_left != NULL && node->m_right == NULL)\n@@ -2259,11 +2264,11 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      p = (default_prob.apply_scale (1, 2)\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n-\t\t\t\t\t    GT_EXPR, m_default_bb, p);\n+\t\t\t\t\t    GT_EXPR, m_default_bb, p, loc);\n \t\t  default_prob = default_prob.apply_scale (1, 2);\n \n \t      bb = emit_case_nodes (bb, index, node->m_left, default_prob,\n-\t\t\t\t    index_type);\n+\t\t\t\t    index_type, loc);\n \t    }\n \t  else\n \t    {\n@@ -2273,7 +2278,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t      p = (node->m_left->m_c->m_subtree_prob\n \t\t   / (node->m_c->m_subtree_prob + default_prob));\n \t      bb = do_jump_if_equal (bb, index, node->m_left->m_c->get_low (),\n-\t\t\t\t     node->m_left->m_c->m_case_bb, p);\n+\t\t\t\t     node->m_left->m_c->m_case_bb, p, loc);\n \t    }\n \t}\n     }\n@@ -2297,25 +2302,25 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t       / (node->m_c->m_subtree_prob + default_prob));\n \n \t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n-\t\t\t\t\tGT_EXPR, test_bb, p);\n+\t\t\t\t\tGT_EXPR, test_bb, p, loc);\n \t  default_prob = default_prob.apply_scale (1, 2);\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \t  p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n \t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n-\t\t\t\t\tGE_EXPR, node->m_c->m_case_bb, p);\n+\t\t\t\t\tGE_EXPR, node->m_c->m_case_bb, p, loc);\n \n \t  /* Handle the left-hand subtree.  */\n \t  bb = emit_case_nodes (bb, index, node->m_left,\n-\t\t\t\tdefault_prob, index_type);\n+\t\t\t\tdefault_prob, index_type, loc);\n \n \t  /* If the left-hand subtree fell through,\n \t     don't let it fall into the right-hand subtree.  */\n \t  if (bb && m_default_bb)\n \t    emit_jump (bb, m_default_bb);\n \n \t  bb = emit_case_nodes (test_bb, index, node->m_right,\n-\t\t\t\tdefault_prob, index_type);\n+\t\t\t\tdefault_prob, index_type, loc);\n \t}\n       else\n \t{\n@@ -2328,7 +2333,7 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t  p = default_prob / (node->m_c->m_subtree_prob + default_prob);\n \n \t  bb = emit_cmp_and_jump_insns (bb, lhs, rhs, GT_EXPR,\n-\t\t\t\t\tm_default_bb, p);\n+\t\t\t\t\tm_default_bb, p, loc);\n \n \t  emit_jump (bb, node->m_c->m_case_bb);\n \t  return NULL;"}, {"sha": "2e1da298dcc0d5f3b89eea006dfa1393506f3c94", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4359b6318f9cb0861b25cd174e8a1a07f1740c27/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=4359b6318f9cb0861b25cd174e8a1a07f1740c27", "patch": "@@ -566,7 +566,7 @@ struct switch_decision_tree\n   basic_block emit_case_nodes (basic_block bb, tree index,\n \t\t\t       case_tree_node *node,\n \t\t\t       profile_probability default_prob,\n-\t\t\t       tree index_type);\n+\t\t\t       tree index_type, location_t);\n \n   /* Take an ordered list of case nodes\n      and transform them into a near optimal binary tree,\n@@ -594,13 +594,15 @@ struct switch_decision_tree\n   static basic_block emit_cmp_and_jump_insns (basic_block bb, tree op0,\n \t\t\t\t\t      tree op1, tree_code comparison,\n \t\t\t\t\t      basic_block label_bb,\n-\t\t\t\t\t      profile_probability prob);\n+\t\t\t\t\t      profile_probability prob,\n+\t\t\t\t\t      location_t);\n \n   /* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.\n      PROB is the probability of jumping to LABEL_BB.  */\n   static basic_block do_jump_if_equal (basic_block bb, tree op0, tree op1,\n \t\t\t\t       basic_block label_bb,\n-\t\t\t\t       profile_probability prob);\n+\t\t\t\t       profile_probability prob,\n+\t\t\t\t       location_t);\n \n   /* Reset the aux field of all outgoing edges of switch basic block.  */\n   static inline void reset_out_edges_aux (gswitch *swtch);"}]}