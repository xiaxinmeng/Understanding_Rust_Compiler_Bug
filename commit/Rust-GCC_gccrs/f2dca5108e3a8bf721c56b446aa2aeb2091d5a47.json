{"sha": "f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkY2E1MTA4ZTNhOGJmNzIxYzU2YjQ0NmFhMmFlYjIwOTFkNWE0Nw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-03-02T20:21:14Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-03-02T20:21:14Z"}, "message": "cfgloop.h (struct loop_desc): Removed.\n\n\t* cfgloop.h (struct loop_desc): Removed.\n\t(struct loop): Fields simple, desc and has_desc removed.\n\t(simple_loop_p, count_loop_iterations): Declaration removed.\n\t* cfgloopanal.c (struct unmark_altered_insn_data): Removed.\n\t(unmark_altered, blocks_invariant_registers, unmark_altered_insn\n\tblocks_single_set_registers, invariant_rtx_wrto_regs_p_helper,\n\tinvariant_rtx_wrto_regs_p, test_for_iteration, constant_iterations,\n\tsimple_loop_exit_p, variable_initial_value, variable_initial_values,\n\tsimple_condition_p, simple_increment, count_strange_loop_iterations,\n\tinverse, fits_in_mode_p, simple_loop_p, count_loop_iterations):\n\tRemoved.\n\t* loop-iv.c (check_simple_exit, find_simple_exit): Update comments.\n\nFrom-SVN: r78777", "tree": {"sha": "03d6330174d251bdfd1929424a8e069dabc26ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03d6330174d251bdfd1929424a8e069dabc26ca6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/comments", "author": null, "committer": null, "parents": [{"sha": "ec2075e96246b5275a3b277fd401a57cafbf73e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2075e96246b5275a3b277fd401a57cafbf73e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2075e96246b5275a3b277fd401a57cafbf73e2"}], "stats": {"total": 1118, "additions": 20, "deletions": 1098}, "files": [{"sha": "31cafc8e44b6d7da4cb38397f1322ed677fa3134", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "patch": "@@ -1,3 +1,18 @@\n+2004-03-02  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloop.h (struct loop_desc): Removed.\n+\t(struct loop): Fields simple, desc and has_desc removed.\n+\t(simple_loop_p, count_loop_iterations): Declaration removed.\n+\t* cfgloopanal.c (struct unmark_altered_insn_data): Removed.\n+\t(unmark_altered, blocks_invariant_registers, unmark_altered_insn\n+\tblocks_single_set_registers, invariant_rtx_wrto_regs_p_helper,\n+\tinvariant_rtx_wrto_regs_p, test_for_iteration, constant_iterations,\n+\tsimple_loop_exit_p, variable_initial_value, variable_initial_values,\n+\tsimple_condition_p, simple_increment, count_strange_loop_iterations,\n+\tinverse, fits_in_mode_p, simple_loop_p, count_loop_iterations):\n+\tRemoved.\n+\t* loop-iv.c (check_simple_exit, find_simple_exit): Update comments.\n+\n 2004-03-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* genattrtab.c: Don't handle MATCH_INSN."}, {"sha": "8a24c15f27160cd885514c9483470c82db9aacff", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "patch": "@@ -36,29 +36,6 @@ struct lpt_decision\n   unsigned times;\n };\n \n-/* Description of loop for simple loop unrolling.  */\n-struct loop_desc\n-{\n-  int postincr;\t\t/* 1 if increment/decrement is done after loop exit condition.  */\n-  rtx stride;\t\t/* Value added to VAR in each iteration.  */\n-  rtx var;\t\t/* Loop control variable.  */\n-  enum machine_mode inner_mode;\n-\t\t\t/* The mode from that it is extended.  */\n-  enum rtx_code extend;\t/* With this extend.  */\n-  rtx var_alts;\t\t/* List of definitions of its initial value.  */\n-  rtx lim;\t\t/* Expression var is compared with.  */\n-  rtx lim_alts;\t\t/* List of definitions of its initial value.  */\n-  bool const_iter;      /* True if it iterates constant number of times.  */\n-  unsigned HOST_WIDE_INT niter;\n-\t\t\t/* Number of iterations if it is constant.  */\n-  bool may_be_zero;     /* If we cannot determine that the first iteration will pass.  */\n-  enum rtx_code cond;\t/* Exit condition.  */\n-  int neg;\t\t/* Set to 1 if loop ends when condition is satisfied.  */\n-  edge out_edge;\t/* The exit edge.  */\n-  edge in_edge;\t\t/* And the other one.  */\n-  int n_branches;\t/* Number of branches inside the loop.  */\n-};\n-\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n@@ -77,11 +54,6 @@ struct loop\n   /* For loop unrolling/peeling decision.  */\n   struct lpt_decision lpt_decision;\n \n-  /* Simple loop description.  */\n-  int simple;\n-  struct loop_desc desc;\n-  int has_desc;\n-\n   /* Number of loop insns.  */\n   unsigned ninsns;\n \n@@ -305,8 +277,6 @@ extern void force_single_succ_latches (struct loops *);\n extern void verify_loop_structure (struct loops *);\n \n /* Loop analysis.  */\n-extern bool simple_loop_p (struct loop *, struct loop_desc *);\n-extern rtx count_loop_iterations (struct loop_desc *, rtx, rtx);\n extern bool just_once_each_iteration_p (struct loop *, basic_block);\n extern unsigned expected_loop_iterations (const struct loop *);\n \n@@ -370,8 +340,8 @@ struct rtx_iv\n   unsigned first_special : 1;\n };\n \n-/* This should replace struct loop_desc.  We keep this just so that we are\n-   able to compare the results.  */\n+/* The description of an exit from the loop and of the number of iterations\n+   till we take the exit.  */\n \n struct niter_desc\n {"}, {"sha": "9b3ffa0c8aed5de6ac362931d7f45a4077c70e1d", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 1, "deletions": 1063, "changes": 1064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "patch": "@@ -29,48 +29,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"output.h\"\n \n-struct unmark_altered_insn_data;\n-static void unmark_altered (rtx, rtx, regset);\n-static void blocks_invariant_registers (basic_block *, int, regset);\n-static void unmark_altered_insn (rtx, rtx, struct unmark_altered_insn_data *);\n-static void blocks_single_set_registers (basic_block *, int, rtx *);\n-static int invariant_rtx_wrto_regs_p_helper (rtx *, regset);\n-static bool invariant_rtx_wrto_regs_p (rtx, regset);\n-static rtx test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT);\n-static bool constant_iterations (struct loop_desc *, unsigned HOST_WIDE_INT *,\n-\t\t\t\t bool *);\n-static bool simple_loop_exit_p (struct loop *, edge, regset,\n-\t\t\t\trtx *, struct loop_desc *);\n-static rtx variable_initial_value (rtx, regset, rtx, rtx *, enum machine_mode);\n-static rtx variable_initial_values (edge, rtx, enum machine_mode);\n-static bool simple_condition_p (struct loop *, rtx, regset,\n-\t\t\t\tstruct loop_desc *);\n-static basic_block simple_increment (struct loop *, rtx *, struct loop_desc *);\n-static rtx count_strange_loop_iterations (rtx, rtx, enum rtx_code,\n-\t\t\t\t\t  int, rtx, enum machine_mode,\n-\t\t\t\t\t  enum machine_mode);\n-static unsigned HOST_WIDEST_INT inverse (unsigned HOST_WIDEST_INT, int);\n-static bool fits_in_mode_p (enum machine_mode mode, rtx expr);\n-\n-/* Computes inverse to X modulo (1 << MOD).  */\n-static unsigned HOST_WIDEST_INT\n-inverse (unsigned HOST_WIDEST_INT x, int mod)\n-{\n-  unsigned HOST_WIDEST_INT mask =\n-\t  ((unsigned HOST_WIDEST_INT) 1 << (mod - 1) << 1) - 1;\n-  unsigned HOST_WIDEST_INT rslt = 1;\n-  int i;\n-\n-  for (i = 0; i < mod - 1; i++)\n-    {\n-      rslt = (rslt * x) & mask;\n-      x = (x * x) & mask;\n-    }\n-\n-  return rslt;\n-}\n-\n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n+\n bool\n just_once_each_iteration_p (struct loop *loop, basic_block bb)\n {\n@@ -89,1028 +49,6 @@ just_once_each_iteration_p (struct loop *loop, basic_block bb)\n   return true;\n }\n \n-\n-/* Unmarks modified registers; helper to blocks_invariant_registers.  */\n-static void\n-unmark_altered (rtx what, rtx by ATTRIBUTE_UNUSED, regset regs)\n-{\n-  if (GET_CODE (what) == SUBREG)\n-    what = SUBREG_REG (what);\n-  if (!REG_P (what))\n-    return;\n-  CLEAR_REGNO_REG_SET (regs, REGNO (what));\n-}\n-\n-/* Marks registers that are invariant inside blocks BBS.  */\n-static void\n-blocks_invariant_registers (basic_block *bbs, int nbbs, regset regs)\n-{\n-  rtx insn;\n-  int i;\n-\n-  for (i = 0; i < max_reg_num (); i++)\n-    SET_REGNO_REG_SET (regs, i);\n-  for (i = 0; i < nbbs; i++)\n-    for (insn = BB_HEAD (bbs[i]);\n-\t insn != NEXT_INSN (BB_END (bbs[i]));\n-\t insn = NEXT_INSN (insn))\n-      if (INSN_P (insn))\n-\tnote_stores (PATTERN (insn),\n-\t\t     (void (*) (rtx, rtx, void *)) unmark_altered,\n-\t\t     regs);\n-}\n-\n-/* Unmarks modified registers; helper to blocks_single_set_registers.  */\n-struct unmark_altered_insn_data\n-{\n-  rtx *regs;\n-  rtx insn;\n-};\n-\n-static void\n-unmark_altered_insn (rtx what, rtx by ATTRIBUTE_UNUSED,\n-\t\t     struct unmark_altered_insn_data *data)\n-{\n-  int rn;\n-\n-  if (GET_CODE (what) == SUBREG)\n-    what = SUBREG_REG (what);\n-  if (!REG_P (what))\n-    return;\n-  rn = REGNO (what);\n-  if (data->regs[rn] == data->insn)\n-    return;\n-  data->regs[rn] = NULL;\n-}\n-\n-/* Marks registers that have just single simple set in BBS; the relevant\n-   insn is returned in REGS.  */\n-static void\n-blocks_single_set_registers (basic_block *bbs, int nbbs, rtx *regs)\n-{\n-  rtx insn;\n-  int i;\n-  struct unmark_altered_insn_data data;\n-\n-  for (i = 0; i < max_reg_num (); i++)\n-    regs[i] = NULL;\n-\n-  for (i = 0; i < nbbs; i++)\n-    for (insn = BB_HEAD (bbs[i]);\n-\t insn != NEXT_INSN (BB_END (bbs[i]));\n-\t insn = NEXT_INSN (insn))\n-      {\n-\trtx set = single_set (insn);\n-\tif (!set)\n-\t  continue;\n-\tif (!REG_P (SET_DEST (set)))\n-\t  continue;\n-\tregs[REGNO (SET_DEST (set))] = insn;\n-      }\n-\n-  data.regs = regs;\n-  for (i = 0; i < nbbs; i++)\n-    for (insn = BB_HEAD (bbs[i]);\n-\t insn != NEXT_INSN (BB_END (bbs[i]));\n-\t insn = NEXT_INSN (insn))\n-      {\n-        if (!INSN_P (insn))\n-\t  continue;\n-\tdata.insn = insn;\n-\tnote_stores (PATTERN (insn),\n-\t    (void (*) (rtx, rtx, void *)) unmark_altered_insn,\n-\t    &data);\n-      }\n-}\n-\n-/* Helper for invariant_rtx_wrto_regs_p.  */\n-static int\n-invariant_rtx_wrto_regs_p_helper (rtx *expr, regset invariant_regs)\n-{\n-  switch (GET_CODE (*expr))\n-    {\n-    case CC0:\n-    case PC:\n-    case UNSPEC_VOLATILE:\n-      return 1;\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case ASM_OPERANDS:\n-      return MEM_VOLATILE_P (*expr);\n-\n-    case MEM:\n-      /* If the memory is not constant, assume it is modified.  If it is\n-\t constant, we still have to check the address.  */\n-      return !RTX_UNCHANGING_P (*expr);\n-\n-    case REG:\n-      return !REGNO_REG_SET_P (invariant_regs, REGNO (*expr));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant.  */\n-static bool\n-invariant_rtx_wrto_regs_p (rtx expr, regset invariant_regs)\n-{\n-  return !for_each_rtx (&expr, (rtx_function) invariant_rtx_wrto_regs_p_helper,\n-\t\t\tinvariant_regs);\n-}\n-\n-/* Checks whether CONDITION is a simple comparison in that one of operands\n-   is register and the other one is invariant in the LOOP. Fills var, lim\n-   and cond fields in DESC.  */\n-static bool\n-simple_condition_p (struct loop *loop ATTRIBUTE_UNUSED, rtx condition,\n-\t\t    regset invariant_regs, struct loop_desc *desc)\n-{\n-  rtx op0, op1;\n-\n-  /* Check condition.  */\n-  switch (GET_CODE (condition))\n-    {\n-      case EQ:\n-      case NE:\n-      case LE:\n-      case LT:\n-      case GE:\n-      case GT:\n-      case GEU:\n-      case GTU:\n-      case LEU:\n-      case LTU:\n-\tbreak;\n-      default:\n-\treturn false;\n-    }\n-\n-  /* Of integers or pointers.  */\n-  if (GET_MODE_CLASS (GET_MODE (XEXP (condition, 0))) != MODE_INT\n-      && GET_MODE_CLASS (GET_MODE (XEXP (condition, 0))) != MODE_PARTIAL_INT)\n-    return false;\n-\n-  /* One of operands must be a simple register.  */\n-  op0 = XEXP (condition, 0);\n-  op1 = XEXP (condition, 1);\n-\n-  /* One of operands must be invariant.  */\n-  if (invariant_rtx_wrto_regs_p (op0, invariant_regs))\n-    {\n-      /* And the other one must be a register.  */\n-      if (!REG_P (op1))\n-\treturn false;\n-      desc->var = op1;\n-      desc->lim = op0;\n-\n-      desc->cond = swap_condition (GET_CODE (condition));\n-      if (desc->cond == UNKNOWN)\n-\treturn false;\n-      return true;\n-    }\n-\n-  /* Check the other operand.  */\n-  if (!invariant_rtx_wrto_regs_p (op1, invariant_regs))\n-    return false;\n-  if (!REG_P (op0))\n-    return false;\n-\n-  desc->var = op0;\n-  desc->lim = op1;\n-\n-  desc->cond = GET_CODE (condition);\n-\n-  return true;\n-}\n-\n-/* Checks whether DESC->var is incremented/decremented exactly once each\n-   iteration.  Fills in DESC->stride and returns block in that DESC->var is\n-   modified.  */\n-static basic_block\n-simple_increment (struct loop *loop, rtx *simple_increment_regs,\n-\t\t  struct loop_desc *desc)\n-{\n-  rtx mod_insn, mod_insn1, set, set_src, set_add;\n-  basic_block mod_bb, mod_bb1;\n-\n-  /* Find insn that modifies var.  */\n-  mod_insn = simple_increment_regs[REGNO (desc->var)];\n-  if (!mod_insn)\n-    return NULL;\n-  mod_bb = BLOCK_FOR_INSN (mod_insn);\n-\n-  /* Check that it is executed exactly once each iteration.  */\n-  if (!just_once_each_iteration_p (loop, mod_bb))\n-    return NULL;\n-\n-  /* mod_insn must be a simple increment/decrement.  */\n-  set = single_set (mod_insn);\n-  if (!set)\n-    abort ();\n-  if (!rtx_equal_p (SET_DEST (set), desc->var))\n-    abort ();\n-\n-  set_src = find_reg_equal_equiv_note (mod_insn);\n-  if (!set_src)\n-    set_src = SET_SRC (set);\n-\n-  /* Check for variables that iterate in narrower mode.  */\n-  if (GET_CODE (set_src) == SIGN_EXTEND\n-      || GET_CODE (set_src) == ZERO_EXTEND)\n-    {\n-      /* If we are sign extending variable that is then compared unsigned\n-\t or vice versa, there is something weird happening.  */\n-      if (desc->cond != EQ\n-\t  && desc->cond != NE\n-\t  && ((desc->cond == LEU\n-\t       || desc->cond == LTU\n-\t       || desc->cond == GEU\n-\t       || desc->cond == GTU)\n-\t      ^ (GET_CODE (set_src) == ZERO_EXTEND)))\n-\treturn NULL;\n-\n-      if (GET_CODE (XEXP (set_src, 0)) != SUBREG\n-\t  || SUBREG_BYTE (XEXP (set_src, 0)) != 0\n-\t  || GET_MODE (SUBREG_REG (XEXP (set_src, 0))) != GET_MODE (desc->var))\n-\treturn NULL;\n-\n-      desc->inner_mode = GET_MODE (XEXP (set_src, 0));\n-      desc->extend = GET_CODE (set_src);\n-      set_src = SUBREG_REG (XEXP (set_src, 0));\n-\n-      if (GET_CODE (set_src) != REG)\n-\treturn NULL;\n-\n-      /* Find where the reg is set.  */\n-      mod_insn1 = simple_increment_regs[REGNO (set_src)];\n-      if (!mod_insn1)\n-\treturn NULL;\n-\n-      mod_bb1 = BLOCK_FOR_INSN (mod_insn1);\n-      if (!dominated_by_p (CDI_DOMINATORS, mod_bb, mod_bb1))\n-\treturn NULL;\n-      if (mod_bb1 == mod_bb)\n-\t{\n-\t  for (;\n-\t       mod_insn != PREV_INSN (BB_HEAD (mod_bb));\n-\t       mod_insn = PREV_INSN (mod_insn))\n-\t    if (mod_insn == mod_insn1)\n-\t      break;\n-\n-\t  if (mod_insn == PREV_INSN (BB_HEAD (mod_bb)))\n-\t    return NULL;\n-\t}\n-\n-      /* Replace the source with the possible place of increment.  */\n-      set = single_set (mod_insn1);\n-      if (!set)\n-\tabort ();\n-      if (!rtx_equal_p (SET_DEST (set), set_src))\n-\tabort ();\n-\n-      set_src = find_reg_equal_equiv_note (mod_insn1);\n-      if (!set_src)\n-\tset_src = SET_SRC (set);\n-    }\n-  else\n-    {\n-      desc->inner_mode = GET_MODE (desc->var);\n-      desc->extend = NIL;\n-    }\n-\n-  if (GET_CODE (set_src) != PLUS)\n-    return NULL;\n-  if (!rtx_equal_p (XEXP (set_src, 0), desc->var))\n-    return NULL;\n-\n-  /* Set desc->stride.  */\n-  set_add = XEXP (set_src, 1);\n-  if (CONSTANT_P (set_add))\n-    desc->stride = set_add;\n-  else\n-    return NULL;\n-\n-  return mod_bb;\n-}\n-\n-/* Tries to find initial value of VAR in INSN.  This value must be invariant\n-   wrto INVARIANT_REGS.  If SET_INSN is not NULL, insn in that var is set is\n-   placed here.  INNER_MODE is mode in that induction variable VAR iterates.  */\n-static rtx\n-variable_initial_value (rtx insn, regset invariant_regs,\n-\t\t\trtx var, rtx *set_insn, enum machine_mode inner_mode)\n-{\n-  basic_block bb;\n-  rtx set;\n-  rtx ret = NULL;\n-\n-  /* Go back through cfg.  */\n-  bb = BLOCK_FOR_INSN (insn);\n-  while (1)\n-    {\n-      for (; insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n-\t{\n-\t  if (INSN_P (insn))\n-\t    note_stores (PATTERN (insn),\n-\t\t(void (*) (rtx, rtx, void *)) unmark_altered,\n-\t\tinvariant_regs);\n-\t  if (modified_between_p (var, PREV_INSN (insn), NEXT_INSN (insn)))\n-\t    break;\n-\t}\n-\n-      if (insn != BB_HEAD (bb))\n-\t{\n-\t  /* We found place where var is set.  */\n-\t  rtx set_dest;\n-\t  rtx val;\n-\t  rtx note;\n-\n-\t  set = single_set (insn);\n-\t  if (!set)\n-\t    return NULL;\n-\t  set_dest = SET_DEST (set);\n-\t  if (!rtx_equal_p (set_dest, var))\n-\t    return NULL;\n-\n-\t  note = find_reg_equal_equiv_note (insn);\n-\t  if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n-\t    val = XEXP (note, 0);\n-\t  else\n-\t    val = SET_SRC (set);\n-\n-\t  /* If we know that the initial value is indeed in range of\n-\t     the inner mode, record the fact even in case the value itself\n-\t     is useless.  */\n-\t  if ((GET_CODE (val) == SIGN_EXTEND\n-\t       || GET_CODE (val) == ZERO_EXTEND)\n-\t      && GET_MODE (XEXP (val, 0)) == inner_mode)\n-\t    ret = gen_rtx_fmt_e (GET_CODE (val),\n-\t\t\t\t GET_MODE (var),\n-\t\t\t\t gen_rtx_fmt_ei (SUBREG,\n-\t\t\t\t\t\t inner_mode,\n-\t\t\t\t\t\t var, 0));\n-\n-\t  if (!invariant_rtx_wrto_regs_p (val, invariant_regs))\n-\t    return ret;\n-\n-\t  if (set_insn)\n-\t    *set_insn = insn;\n-\t  return val;\n-\t}\n-\n-\n-      if (bb->pred->pred_next || bb->pred->src == ENTRY_BLOCK_PTR)\n-\treturn NULL;\n-\n-      bb = bb->pred->src;\n-      insn = BB_END (bb);\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Returns list of definitions of initial value of VAR at edge E.  INNER_MODE\n-   is mode in that induction variable VAR really iterates.  */\n-static rtx\n-variable_initial_values (edge e, rtx var, enum machine_mode inner_mode)\n-{\n-  rtx set_insn, list;\n-  regset invariant_regs;\n-  regset_head invariant_regs_head;\n-  int i;\n-\n-  invariant_regs = INITIALIZE_REG_SET (invariant_regs_head);\n-  for (i = 0; i < max_reg_num (); i++)\n-    SET_REGNO_REG_SET (invariant_regs, i);\n-\n-  list = alloc_EXPR_LIST (0, copy_rtx (var), NULL);\n-\n-  if (e->src == ENTRY_BLOCK_PTR)\n-    return list;\n-\n-  set_insn = BB_END (e->src);\n-  while (REG_P (var)\n-\t && (var = variable_initial_value (set_insn, invariant_regs, var,\n-\t\t\t\t\t   &set_insn, inner_mode)))\n-    list = alloc_EXPR_LIST (0, copy_rtx (var), list);\n-\n-  FREE_REG_SET (invariant_regs);\n-  return list;\n-}\n-\n-/* Counts constant number of iterations of the loop described by DESC;\n-   returns false if impossible.  */\n-static bool\n-constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n-\t\t     bool *may_be_zero)\n-{\n-  rtx test, expr;\n-  rtx ainit, alim;\n-\n-  test = test_for_iteration (desc, 0);\n-  if (test == const0_rtx)\n-    {\n-      *niter = 0;\n-      *may_be_zero = false;\n-      return true;\n-    }\n-\n-  *may_be_zero = (test != const_true_rtx);\n-\n-  /* It would make a little sense to check every with every when we\n-     know that all but the first alternative are simply registers.  */\n-  for (ainit = desc->var_alts; ainit; ainit = XEXP (ainit, 1))\n-    {\n-      alim = XEXP (desc->lim_alts, 0);\n-      if (!(expr = count_loop_iterations (desc, XEXP (ainit, 0), alim)))\n-\tcontinue;\n-      if (GET_CODE (expr) == CONST_INT)\n-\t{\n-\t  *niter = INTVAL (expr);\n-\t  return true;\n-\t}\n-    }\n-  for (alim = XEXP (desc->lim_alts, 1); alim; alim = XEXP (alim, 1))\n-    {\n-      ainit = XEXP (desc->var_alts, 0);\n-      if (!(expr = count_loop_iterations (desc, ainit, XEXP (alim, 0))))\n-\tcontinue;\n-      if (GET_CODE (expr) == CONST_INT)\n-\t{\n-\t  *niter = INTVAL (expr);\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-/* Attempts to determine a number of iterations of a \"strange\" loop.\n-   Its induction variable starts with value INIT, is compared by COND\n-   with LIM.  If POSTINCR, it is incremented after the test.  It is incremented\n-   by STRIDE each iteration, has mode MODE but iterates in INNER_MODE.\n-\n-   By \"strange\" we mean loops where induction variable increases in the wrong\n-   direction wrto comparison, i.e. for (i = 6; i > 5; i++).  */\n-static rtx\n-count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n-\t\t\t       int postincr, rtx stride, enum machine_mode mode,\n-\t\t\t       enum machine_mode inner_mode)\n-{\n-  rtx rqmt, n_to_wrap, before_wrap, after_wrap;\n-  rtx mode_min, mode_max;\n-  int size;\n-\n-  /* This could be handled, but it is not important enough to lose time with\n-     it just now.  */\n-  if (mode != inner_mode)\n-    return NULL_RTX;\n-\n-  if (!postincr)\n-    init = simplify_gen_binary (PLUS, mode, init, stride);\n-\n-  /* If we are able to prove that we don't pass the first test, we are\n-     done.  */\n-  rqmt = simplify_relational_operation (cond, mode, init, lim);\n-  if (rqmt == const0_rtx)\n-    return const0_rtx;\n-\n-  /* And if we don't know we pass it, the things are too complicated for us.  */\n-  if (rqmt != const_true_rtx)\n-    return NULL_RTX;\n-\n-  switch (cond)\n-    {\n-    case GE:\n-    case GT:\n-    case LE:\n-    case LT:\n-      size = GET_MODE_BITSIZE (mode);\n-      mode_min = GEN_INT (-((unsigned HOST_WIDEST_INT) 1 << (size - 1)));\n-      mode_max = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1)) - 1);\n-\t\t\t      \n-      break;\n-\n-    case GEU:\n-    case GTU:\n-    case LEU:\n-    case LTU:\n-    case EQ:\n-      mode_min = const0_rtx;\n-      mode_max = simplify_gen_binary (MINUS, mode, const0_rtx, const1_rtx);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  switch (cond)\n-    {\n-    case EQ:\n-      /* This iterates once, as init == lim.  */\n-      return const1_rtx;\n-\n-      /* The behavior is undefined in signed cases.  Never mind, we still\n-\t try to behave sanely.  */\n-    case GE:\n-    case GT:\n-    case GEU:\n-    case GTU:\n-      if (INTVAL (stride) <= 0)\n-\tabort ();\n-      n_to_wrap = simplify_gen_binary (MINUS, mode, mode_max, copy_rtx (init));\n-      n_to_wrap = simplify_gen_binary (UDIV, mode, n_to_wrap, stride);\n-      before_wrap = simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t copy_rtx (n_to_wrap), stride);\n-      before_wrap = simplify_gen_binary (PLUS, mode,\n-\t\t\t\t\t before_wrap, copy_rtx (init));\n-      after_wrap = simplify_gen_binary (PLUS, mode,\n-\t\t\t\t\tbefore_wrap, stride);\n-      if (GET_CODE (after_wrap) != CONST_INT)\n-\t{\n-\t  after_wrap = simplify_gen_binary (PLUS, mode, mode_min, stride);\n-\t  after_wrap = simplify_gen_binary (MINUS, mode, after_wrap, const1_rtx);\n-\t}\n-      break;\n-\n-    case LE:\n-    case LT:\n-    case LEU:\n-    case LTU:\n-      if (INTVAL (stride) >= 0)\n-\tabort ();\n-      stride = simplify_gen_unary (NEG, mode, stride, mode);\n-      n_to_wrap = simplify_gen_binary (MINUS, mode, copy_rtx (init), mode_min);\n-      n_to_wrap = simplify_gen_binary (UDIV, mode, n_to_wrap, stride);\n-      before_wrap = simplify_gen_binary (MULT, mode,\n-\t\t\t\t\t copy_rtx (n_to_wrap), stride);\n-      before_wrap = simplify_gen_binary (MINUS, mode,\n-\t\t\t\t\t copy_rtx (init), before_wrap);\n-      after_wrap = simplify_gen_binary (MINUS, mode,\n-\t\t\t\t\tbefore_wrap, stride);\n-      if (GET_CODE (after_wrap) != CONST_INT)\n-\t{\n-\t  after_wrap = simplify_gen_binary (MINUS, mode, mode_max, stride);\n-\t  after_wrap = simplify_gen_binary (PLUS, mode, after_wrap, const1_rtx);\n-\t}\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  /* If this is const_true_rtx and we did not take a conservative approximation\n-     of after_wrap above, we might iterate the calculation (but of course we\n-     would have to take care about infinite cases).  Ignore this for now.  */\n-  rqmt = simplify_relational_operation (cond, mode, after_wrap, lim);\n-  if (rqmt != const0_rtx)\n-    return NULL_RTX;\n-\n-  return simplify_gen_binary (PLUS, mode, n_to_wrap, const1_rtx);\n-}\n-\n-/* Checks whether value of EXPR fits into range of MODE.  */\n-static bool\n-fits_in_mode_p (enum machine_mode mode, rtx expr)\n-{\n-  unsigned HOST_WIDEST_INT val;\n-  int n_bits = 0;\n-\n-  if (GET_CODE (expr) == CONST_INT)\n-    {\n-      for (val = INTVAL (expr); val; val >>= 1)\n-\tn_bits++;\n-\n-      return n_bits <= GET_MODE_BITSIZE (mode);\n-    }\n-\n-  if (GET_CODE (expr) == SIGN_EXTEND\n-      || GET_CODE (expr) == ZERO_EXTEND)\n-    return GET_MODE (XEXP (expr, 0)) == mode;\n-\n-  return false;\n-}\n-\n-/* Return RTX expression representing number of iterations of loop as bounded\n-   by test described by DESC (in the case loop really has multiple exit\n-   edges, fewer iterations may happen in the practice).\n-\n-   Return NULL if it is unknown.  Additionally the value may be invalid for\n-   paradoxical loop (lets define paradoxical loops as loops whose test is\n-   failing at -1th iteration, for instance \"for (i=5;i<1;i++);\").\n-\n-   These cases needs to be either cared by copying the loop test in the front\n-   of loop or keeping the test in first iteration of loop.\n-\n-   When INIT/LIM are set, they are used instead of var/lim of DESC.  */\n-rtx\n-count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n-{\n-  enum rtx_code cond = desc->cond;\n-  rtx stride = desc->stride;\n-  rtx mod, exp, ainit, bound;\n-  rtx overflow_check, mx, mxp;\n-  enum machine_mode mode = GET_MODE (desc->var);\n-  unsigned HOST_WIDEST_INT s, size, d;\n-\n-  /* Give up on floating point modes and friends.  It can be possible to do\n-     the job for constant loop bounds, but it is probably not worthwhile.  */\n-  if (!INTEGRAL_MODE_P (mode))\n-    return NULL;\n-\n-  init = copy_rtx (init ? init : desc->var);\n-  lim = copy_rtx (lim ? lim : desc->lim);\n-\n-  /* Ensure that we always handle the condition to stay inside loop.  */\n-  if (desc->neg)\n-    cond = reverse_condition (cond);\n-\n-  if (desc->inner_mode != mode)\n-    {\n-      /* We have a case when the variable in fact iterates in the narrower\n-\t mode.  This has following consequences:\n-\t \n-\t For induction variable itself, if !desc->postincr, it does not mean\n-\t anything too special, since we know the variable is already in range\n-\t of the inner mode when we compare it (so it is just needed to shorten\n-\t it into the mode before calculations are done, so that we don't risk\n-\t wrong results).  More complicated case is when desc->postincr; then\n-\t the first two iterations are special (the first one because the value\n-\t may be out of range, the second one because after shortening it to the\n-\t range it may have absolutely any value), and we do not handle this in\n-\t unrolling.  So if we aren't able to prove that the initial value is in\n-\t the range, we fail in this case.\n-\t \n-\t Step is just moduled to fit into inner mode.\n-\n-\t If lim is out of range, then either the loop is infinite (and then\n-\t we may unroll however we like to), or exits in the first iteration\n-\t (this is also ok, since we handle it specially for this case anyway).\n-\t So we may safely assume that it fits into the inner mode.  */\n-\n-      for (ainit = desc->var_alts; ainit; ainit = XEXP (ainit, 1))\n-\tif (fits_in_mode_p (desc->inner_mode, XEXP (ainit, 0)))\n-\t  break;\n-\n-      if (!ainit)\n-\t{\n-\t  if (desc->postincr)\n-\t    return NULL_RTX;\n-\n-\t  init = simplify_gen_unary (desc->extend,\n-\t\t\t\t     mode,\n-\t\t\t\t     simplify_gen_subreg (desc->inner_mode,\n-\t\t\t\t\t\t\t  init,\n-\t\t\t\t\t\t\t  mode,\n-\t\t\t\t\t\t\t  0),\n-\t\t\t\t     desc->inner_mode);\n-\t}\n-\n-      stride = simplify_gen_subreg (desc->inner_mode, stride, mode, 0);\n-      if (stride == const0_rtx)\n-\treturn NULL_RTX;\n-    }\n-\n-  /* Prepare condition to verify that we do not risk overflow.  */\n-  if (stride == const1_rtx\n-      || stride == constm1_rtx\n-      || cond == NE\n-      || cond == EQ)\n-    {\n-      /* Overflow at NE conditions does not occur.  EQ condition\n-\t is weird and is handled in count_strange_loop_iterations.\n-\t If stride is 1, overflow may occur only for <= and >= conditions,\n-\t and then they are infinite, so it does not bother us.  */\n-      overflow_check = const0_rtx;\n-    }\n-  else\n-    {\n-      if (cond == LT || cond == LTU)\n-\tmx = simplify_gen_binary (MINUS, mode, lim, const1_rtx);\n-      else if (cond == GT || cond == GTU)\n-\tmx = simplify_gen_binary (PLUS, mode, lim, const1_rtx);\n-      else\n-\tmx = lim;\n-      if (mode != desc->inner_mode)\n-\tmxp = simplify_gen_subreg (desc->inner_mode, mx, mode, 0);\n-      else\n-\tmxp = mx;\n-      mxp = simplify_gen_binary (PLUS, desc->inner_mode, mxp, stride);\n-      if (mode != desc->inner_mode)\n-\tmxp = simplify_gen_unary (desc->extend, mode, mxp, desc->inner_mode);\n-      overflow_check = simplify_gen_relational (cond, SImode, mode, mx, mxp);\n-    }\n-    \n-  /* Compute absolute value of the difference of initial and final value.  */\n-  if (INTVAL (stride) > 0)\n-    {\n-      /* Handle strange tests specially.  */\n-      if (cond == EQ || cond == GE || cond == GT || cond == GEU\n-\t  || cond == GTU)\n-\treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n-\t\t\t\t\t      stride, mode, desc->inner_mode);\n-      exp = simplify_gen_binary (MINUS, mode, lim, init);\n-    }\n-  else\n-    {\n-      if (cond == EQ || cond == LE || cond == LT || cond == LEU\n-\t  || cond == LTU)\n-\treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n-\t\t\t\t\t      stride, mode, desc->inner_mode);\n-      exp = simplify_gen_binary (MINUS, mode, init, lim);\n-      stride = simplify_gen_unary (NEG, mode, stride, mode);\n-    }\n-\n-  /* If there is a risk of overflow (i.e. when we increment value satisfying\n-     a condition, we may again obtain a value satisfying the condition),\n-     fail.  */\n-  if (overflow_check != const0_rtx)\n-    return NULL_RTX;\n-\n-  /* Normalize difference so the value is always first examined\n-     and later incremented.  */\n-  if (!desc->postincr)\n-    exp = simplify_gen_binary (MINUS, mode, exp, stride);\n-\n-  /* Determine delta caused by exit condition.  */\n-  switch (cond)\n-    {\n-    case NE:\n-      /* NE tests are easy to handle, because we just perform simple\n-\t arithmetics modulo power of 2.  Let's use the fact to compute the\n-\t number of iterations exactly.  We are now in situation when we want to\n-\t solve an equation stride * i = c (mod size of inner_mode).\n-\t Let nsd (stride, size of mode) = d.  If d does not divide c, the\n-\t loop is infinite.  Otherwise, the number of iterations is\n-\t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n-      size = GET_MODE_BITSIZE (desc->inner_mode);\n-      s = INTVAL (stride);\n-      d = 1;\n-      while (s % 2 != 1)\n-\t{\n-\t  s /= 2;\n-\t  d *= 2;\n-\t  size--;\n-\t}\n-      bound = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1 ) << 1) - 1);\n-      exp = simplify_gen_binary (UDIV, mode, exp, GEN_INT (d));\n-      exp = simplify_gen_binary (MULT, mode,\n-\t\t\t\t exp, GEN_INT (inverse (s, size)));\n-      exp = simplify_gen_binary (AND, mode, exp, bound);\n-      break;\n-\n-    case LT:\n-    case GT:\n-    case LTU:\n-    case GTU:\n-      break;\n-    case LE:\n-    case GE:\n-    case LEU:\n-    case GEU:\n-      exp = simplify_gen_binary (PLUS, mode, exp, const1_rtx);\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  if (cond != NE && stride != const1_rtx)\n-    {\n-      /* Number of iterations is now (EXP + STRIDE - 1 / STRIDE),\n-\t but we need to take care for overflows.  */\n-\n-      mod = simplify_gen_binary (UMOD, mode, exp, stride);\n-\n-      /* This is dirty trick.  When we can't compute number of iterations\n-\t to be constant, we simply ignore the possible overflow, as\n-\t runtime unroller always use power of 2 amounts and does not\n-\t care about possible lost bits.  */\n-\n-      if (GET_CODE (mod) != CONST_INT)\n-\t{\n-\t  rtx stridem1 = simplify_gen_binary (PLUS, mode, stride, constm1_rtx);\n-\t  exp = simplify_gen_binary (PLUS, mode, exp, stridem1);\n-\t  exp = simplify_gen_binary (UDIV, mode, exp, stride);\n-\t}\n-      else\n-\t{\n-\t  exp = simplify_gen_binary (UDIV, mode, exp, stride);\n-\t  if (mod != const0_rtx)\n-\t    exp = simplify_gen_binary (PLUS, mode, exp, const1_rtx);\n-\t}\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \";  Number of iterations: \");\n-      print_simple_rtl (dump_file, exp);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  return exp;\n-}\n-\n-/* Return simplified RTX expression representing the value of test\n-   described of DESC at given iteration of loop.  */\n-\n-static rtx\n-test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT iter)\n-{\n-  enum rtx_code cond = desc->cond;\n-  rtx exp = XEXP (desc->var_alts, 0);\n-  rtx addval;\n-\n-  /* Give up on floating point modes and friends.  It can be possible to do\n-     the job for constant loop bounds, but it is probably not worthwhile.  */\n-  if (!INTEGRAL_MODE_P (GET_MODE (desc->var)))\n-    return NULL;\n-\n-  /* Ensure that we always handle the condition to stay inside loop.  */\n-  if (desc->neg)\n-    cond = reverse_condition (cond);\n-\n-  /* Compute the value of induction variable.  */\n-  addval = simplify_gen_binary (MULT, GET_MODE (desc->var),\n-\t\t\t\tdesc->stride,\n-\t\t\t\tgen_int_mode (desc->postincr\n-\t\t\t\t\t      ? iter : iter + 1,\n-\t\t\t\t\t      GET_MODE (desc->var)));\n-  exp = simplify_gen_binary (PLUS, GET_MODE (desc->var), exp, addval);\n-  /* Test at given condition.  */\n-  exp = simplify_gen_relational (cond, SImode,\n-\t\t\t\t GET_MODE (desc->var), exp, desc->lim);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \";  Conditional to continue loop at \"\n-\t       HOST_WIDE_INT_PRINT_UNSIGNED \"th iteration: \", iter);\n-      print_simple_rtl (dump_file, exp);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  return exp;\n-}\n-\n-\n-/* Tests whether exit at EXIT_EDGE from LOOP is simple.  Returns simple loop\n-   description joined to it in in DESC.  INVARIANT_REGS and SINGLE_SET_REGS\n-   are results of blocks_{invariant,single_set}_regs over BODY.  */\n-static bool\n-simple_loop_exit_p (struct loop *loop, edge exit_edge,\n-\t\t    regset invariant_regs, rtx *single_set_regs,\n-\t\t    struct loop_desc *desc)\n-{\n-  basic_block mod_bb, exit_bb;\n-  int fallthru_out;\n-  rtx condition;\n-  edge ei, e;\n-\n-  exit_bb = exit_edge->src;\n-\n-  fallthru_out = (exit_edge->flags & EDGE_FALLTHRU);\n-\n-  if (!exit_bb)\n-    return false;\n-\n-  /* It must be tested (at least) once during any iteration.  */\n-  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb))\n-    return false;\n-\n-  /* It must end in a simple conditional jump.  */\n-  if (!any_condjump_p (BB_END (exit_bb)))\n-    return false;\n-\n-  ei = exit_bb->succ;\n-  if (ei == exit_edge)\n-    ei = ei->succ_next;\n-\n-  desc->out_edge = exit_edge;\n-  desc->in_edge = ei;\n-\n-  /* Condition must be a simple comparison in that one of operands\n-     is register and the other one is invariant.  */\n-  if (!(condition = get_condition (BB_END (exit_bb), NULL, false)))\n-    return false;\n-\n-  if (!simple_condition_p (loop, condition, invariant_regs, desc))\n-    return false;\n-\n-  /*  Var must be simply incremented or decremented in exactly one insn that\n-     is executed just once every iteration.  */\n-  if (!(mod_bb = simple_increment (loop, single_set_regs, desc)))\n-    return false;\n-\n-  /* OK, it is simple loop.  Now just fill in remaining info.  */\n-  desc->postincr = !dominated_by_p (CDI_DOMINATORS, exit_bb, mod_bb);\n-  desc->neg = !fallthru_out;\n-\n-  /* Find initial value of var and alternative values for lim.  */\n-  e = loop_preheader_edge (loop);\n-  desc->var_alts = variable_initial_values (e, desc->var, desc->inner_mode);\n-  desc->lim_alts = variable_initial_values (e, desc->lim, desc->inner_mode);\n-\n-  /* Number of iterations.  */\n-  desc->const_iter =\n-    constant_iterations (desc, &desc->niter, &desc->may_be_zero);\n-  if (!desc->const_iter && !count_loop_iterations (desc, NULL, NULL))\n-    return false;\n-  return true;\n-}\n-\n-/* Tests whether LOOP is simple for loop.  Returns simple loop description\n-   in DESC.  */\n-bool\n-simple_loop_p (struct loop *loop, struct loop_desc *desc)\n-{\n-  unsigned i;\n-  basic_block *body;\n-  edge e;\n-  struct loop_desc act;\n-  bool any = false;\n-  regset invariant_regs;\n-  regset_head invariant_regs_head;\n-  rtx *single_set_regs;\n-  int n_branches;\n-\n-  body = get_loop_body (loop);\n-\n-  invariant_regs = INITIALIZE_REG_SET (invariant_regs_head);\n-  single_set_regs = xmalloc (max_reg_num () * sizeof (rtx));\n-\n-  blocks_invariant_registers (body, loop->num_nodes, invariant_regs);\n-  blocks_single_set_registers (body, loop->num_nodes, single_set_regs);\n-\n-  n_branches = 0;\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      for (e = body[i]->succ; e; e = e->succ_next)\n-\tif (!flow_bb_inside_loop_p (loop, e->dest)\n-\t    && simple_loop_exit_p (loop, e,\n-\t\t   invariant_regs, single_set_regs, &act))\n-\t  {\n-\t    /* Prefer constant iterations; the less the better.  */\n-\t    if (!any)\n-\t      any = true;\n-\t    else if (!act.const_iter\n-\t\t     || (desc->const_iter && act.niter >= desc->niter))\n-\t      continue;\n-\t    *desc = act;\n-\t  }\n-\n-      if (body[i]->succ && body[i]->succ->succ_next)\n-\tn_branches++;\n-    }\n-  desc->n_branches = n_branches;\n-\n-  if (dump_file && any)\n-    {\n-      fprintf (dump_file, \"; Simple loop %i\\n\", loop->num);\n-      if (desc->postincr)\n-\tfprintf (dump_file,\n-\t\t \";  does postincrement after loop exit condition\\n\");\n-\n-      fprintf (dump_file, \";  Induction variable:\");\n-      print_simple_rtl (dump_file, desc->var);\n-      fputc ('\\n', dump_file);\n-\n-      fprintf (dump_file, \";  Initial values:\");\n-      print_simple_rtl (dump_file, desc->var_alts);\n-      fputc ('\\n', dump_file);\n-\n-      fprintf (dump_file, \";  Stride:\");\n-      print_simple_rtl (dump_file, desc->stride);\n-      fputc ('\\n', dump_file);\n-\n-      fprintf (dump_file, \";  Compared with:\");\n-      print_simple_rtl (dump_file, desc->lim);\n-      fputc ('\\n', dump_file);\n-\n-      fprintf (dump_file, \";  Alternative values:\");\n-      print_simple_rtl (dump_file, desc->lim_alts);\n-      fputc ('\\n', dump_file);\n-\n-      fprintf (dump_file, \";  Exit condition:\");\n-      if (desc->neg)\n-\tfprintf (dump_file, \"(negated)\");\n-      fprintf (dump_file, \"%s\\n\", GET_RTX_NAME (desc->cond));\n-\n-      fprintf (dump_file, \";  Number of branches:\");\n-      fprintf (dump_file, \"%d\\n\", desc->n_branches);\n-\n-      fputc ('\\n', dump_file);\n-    }\n-\n-  free (body);\n-  FREE_REG_SET (invariant_regs);\n-  free (single_set_regs);\n-  return any;\n-}\n-\n /* Structure representing edge of a graph.  */\n \n struct edge"}, {"sha": "ccc239a3652c1492467edba37631f8a2b917ebef", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2dca5108e3a8bf721c56b446aa2aeb2091d5a47/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=f2dca5108e3a8bf721c56b446aa2aeb2091d5a47", "patch": "@@ -2306,7 +2306,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n }\n \n /* Checks whether E is a simple exit from LOOP and stores its description\n-   into DESC.  TODO Should replace cfgloopanal.c:simple_loop_exit_p.  */\n+   into DESC.  */\n \n static void\n check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n@@ -2353,8 +2353,7 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n   iv_number_of_iterations (loop, at, condition, desc);\n }\n \n-/* Finds a simple exit of LOOP and stores its description into DESC.\n-   TODO Should replace cfgloopanal.c:simple_loop_p.  */\n+/* Finds a simple exit of LOOP and stores its description into DESC.  */\n \n void\n find_simple_exit (struct loop *loop, struct niter_desc *desc)"}]}