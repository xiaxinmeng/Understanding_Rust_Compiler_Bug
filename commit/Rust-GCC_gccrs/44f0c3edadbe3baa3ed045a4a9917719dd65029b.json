{"sha": "44f0c3edadbe3baa3ed045a4a9917719dd65029b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmMGMzZWRhZGJlM2JhYTNlZDA0NWE0YTk5MTc3MTlkZDY1MDI5Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T05:08:50Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T05:08:50Z"}, "message": "Initial revision\n\nFrom-SVN: r220", "tree": {"sha": "528fc67e4c28d99522e751defec64cbd745ca9e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528fc67e4c28d99522e751defec64cbd745ca9e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44f0c3edadbe3baa3ed045a4a9917719dd65029b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f0c3edadbe3baa3ed045a4a9917719dd65029b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f0c3edadbe3baa3ed045a4a9917719dd65029b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f0c3edadbe3baa3ed045a4a9917719dd65029b/comments", "author": null, "committer": null, "parents": [{"sha": "047292d2b480af7c123fb25f0e4a7ebaf2645493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047292d2b480af7c123fb25f0e4a7ebaf2645493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/047292d2b480af7c123fb25f0e4a7ebaf2645493"}], "stats": {"total": 1601, "additions": 1601, "deletions": 0}, "files": [{"sha": "3d50048a13a0dded561039162d15e0acd4ec6e91", "filename": "gcc/config/gmicro/gmicro.h", "status": "added", "additions": 1601, "deletions": 0, "changes": 1601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f0c3edadbe3baa3ed045a4a9917719dd65029b/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f0c3edadbe3baa3ed045a4a9917719dd65029b/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=44f0c3edadbe3baa3ed045a4a9917719dd65029b", "patch": "@@ -0,0 +1,1601 @@\n+/* Definitions of target machine for GNU compiler.  Gmicro (TRON) version.\n+   Ported by Masanobu Yuhara, Fujitsu Laboratories LTD.\n+   (yuhara@flab.fujitsu.co.jp)\n+\n+   Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Among other things, the copyright\n+notice and this notice must be preserved on all copies.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+*/\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dgmicro\"\n+\n+/* #define CPP_SPEC    ** currently not defined **/\n+\n+/* #define CC1_SPEC    ** currently not defined **/\n+\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+/*\n+#define TARGET_VERSION fprintf (stderr, \" (Gmicro syntax)\");\n+*/\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Compile for a Gmicro/300.  */\n+#define TARGET_G300 (target_flags & 1)\n+/* Compile for a Gmicro/200. */\n+#define TARGET_G200 (target_flags & 2)\n+/* Compile for a Gmicro/100. */\n+#define TARGET_G100 (target_flags & 4)\n+\n+/* Compile FPU insns for floating point (not library calls).  */\n+#define TARGET_FPU (target_flags & 8)\n+\n+/* Pop up arguments by called function. */\n+#define TARGET_RTD (target_flags & 0x10)\n+\n+/* Compile passing first args in regs 0 and 1.\n+   This exists only to test compiler features that will be needed for\n+   RISC chips. It is not usable and is not intended to be usable on\n+   this cpu ;-< */\n+#define TARGET_REGPARM (target_flags & 0x20)\n+\n+#define TARGET_BITFIELD (target_flags & 0x40)\n+\n+#define TARGET_NEWRETURN (target_flags & 0x80)\n+\n+/* Do not expand __builtin_smov (strcpy) to multiple movs.\n+   Use the smov instruction. */\n+#define TARGET_FORCE_SMOV (target_flags & 0x100)\n+\n+/* default options are -m300, -mFPU,\n+   with bitfield instructions added because it won't always work otherwise.\n+   If there are versions of the gmicro that don't support bitfield instructions\n+   then it will take some thinking to figure out how to make them work.  */\n+#define TARGET_DEFAULT 0x49\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"g300\", 1},\t\t\t\t\\\n+    { \"g200\", 2},\t\t\t\t\\\n+    { \"g100\", 4},\t\t\t\t\\\n+    { \"fpu\", 8},\t\t\t\t\\\n+    { \"soft-float\", -8},\t\t\t\\\n+    { \"rtd\", 0x10},\t\t\t\t\\\n+    { \"no-rtd\", -0x10},\t\t\t\t\\\n+    { \"regparm\", 0x20},\t\t\t\t\\\n+    { \"no-regparm\", -0x20},\t\t\t\\\n+#if 0 /* Since we don't define PCC_BITFIELD_TYPE_MATTERS or use a large\n+\t STRUCTURE_SIZE_BOUNDARY, we must have bitfield instructions.  */\n+    { \"bitfield\", 0x40},\t\t\t\\\n+    { \"no-bitfield\", -0x40},\t\t\t\\\n+#endif\n+    { \"newreturn\", 0x80},\t\t\t\\\n+    { \"no-newreturn\", -0x80},\t\t\t\\\n+    { \"force-smov\", 0x100},\t\t\t\\\n+    { \"no-force-smov\", -0x100},\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\n+\n+/* Blow away G100 flag silently off TARGET_fpu (since we can't clear\n+   any bits in TARGET_SWITCHES above) */\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (TARGET_G100) target_flags &= ~8;\t\\\n+}\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is true for Gmicro insns.\n+   We make it true always by avoiding using the single-bit insns\n+   except in special cases with constant bit numbers.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the Gmicro.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* For Gmicro we can decide arbitrarily\n+   since there are no machine instructions for them.  ????? */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register. */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+/* Instructions of the Gmicro should be on half-word boundary */\n+/* But word boundary gets better performance */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* No data type wants to be aligned rounder than this. */\n+/* This is not necessarily 32 on the Gmicro */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* Unaligned data is allowed on Gmicro, though the access is slow. */\n+/* But now STRICT is defined */\n+#define STRICT_ALIGNMENT\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define number of bits in most basic integer type.\n+   (If undefined, default is BITS_PER_WORD).  */\n+#define INT_TYPE_SIZE 32\n+\n+/* #define PCC_BITFIELD_TYPE_MATTERS 1 ????? */\n+\n+/* #define CHECK_FLOAT_VALUE (MODE, VALUE) ????? */\n+\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+   For the Gmicro, we give the general registers numbers 0-15,\n+   and the FPU floating point registers numbers 16-31.  */\n+#define FIRST_PSEUDO_REGISTER 32\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the Gmicro, the stack pointer and the frame pointer are\n+   such registers.  */\n+/* frame pointer is not indicated as fixed, because fp may be used freely\n+   when a frame is not built. */\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 1, \\\n+  /* FPU registers.  */   \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 1, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 1, \\\n+  /* FPU registers.  */   \\\n+  1, 1, 1, 1, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, }\n+\n+\n+/* Make sure everything's fine if we *don't* have a given processor.\n+   This assumes that putting a register in fixed_regs will keep the\n+   compilers mitt's completely off it.  We don't bother to zero it out\n+   of register classes.  If TARGET_FPU is not set,\n+   the compiler won't touch since no instructions that use these\n+   registers will be valid.  */\n+/*  This Macro is not defined now.\n+    #define CONDITIONAL_REGISTER_USAGE */\n+\n+/* The Gmicro has no overlapping register */\n+/* #define OVERLAPPING_REGNO_P(REGNO) */\n+\n+/* #define INSN_CLOBBERS_REGNO_P(INSN,REGNO)  */\n+/* #define PRESERVE_DEATH_INFO_REGNO_P(REGNO)  */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the Gmicro, ordinary registers hold 32 bits worth;\n+   for the Gmicro/FPU registers, a single register is always enough for\n+   anything that can be stored in them at all.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((REGNO) >= 16 ? 1\t\t\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the Gmicro, the cpu registers can hold any mode but the FPU registers\n+   can hold only SFmode or DFmode.  And the FPU registers can't hold anything\n+   if FPU use is disabled. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) < 16\t\t\t\t\t\t\t\t\\\n+   || ((REGNO) < 32\t\t\t\t\t\t\t\\\n+       ? TARGET_FPU && (GET_MODE_CLASS (MODE) == MODE_FLOAT ||\t\t\\\n+\t\t\tGET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n+       : 0 ))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n+  (! TARGET_FPU\t\t\t\t\t\t\\\n+   || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\\\n+\tGET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n+       == ((MODE2) == SFmode || (MODE2) == DFmode)))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Gmicro pc isn't overloaded on a register.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+/* The Gmicro does not have hardware ap. Fp is treated as ap */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 1\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The Gmicro has two kinds of registers, so four classes would be\n+   a complete set.  */\n+\n+enum reg_class { NO_REGS, FPU_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+   { \"NO_REGS\", \"FPU_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t\t\t\\\n+     0,\t\t\t/* NO_REGS */\t\t\\\n+     0xffff0000,\t/* FPU_REGS */\t\t\\\n+     0x0000ffff,\t/* GENERAL_REGS */\t\\\n+     0xffffffff\t\t/* ALL_REGS */\t\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+extern enum reg_class regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) ( (REGNO < 16) ? GENERAL_REGS : FPU_REGS )\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS  GENERAL_REGS\n+  \n+/* Get reg_class from a letter such as appears in the machine description.\n+   We do a trick here to modify the effective constraints on the\n+   machine description; we zorch the constraint letters that aren't\n+   appropriate for a specific target.  This allows us to guarantee\n+   that a specific kind of register will not be used for a given taget\n+   without fiddling with the register classes above. */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'r' ? GENERAL_REGS :\t\t\t\\\n+   ((C) == 'f' ? (TARGET_FPU ? FPU_REGS : NO_REGS) :\t\\\n+     NO_REGS))\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the Gmicro, all immediate value optimizations are done \n+   by assember, so no machine dependent definition is necessary ??? */\n+\n+/* #define CONST_OK_FOR_LETTER_P(VALUE, C) ((C) == 'I') */\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+/*\n+ * The letters G defines all of the floating constants tha are *NOT*\n+ * Gmicro-FPU constant.\n+ */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n+    ((C) == 'F' ||\t\t\t\t\\\n+     (C) == 'G' && !(TARGET_FPU && standard_fpu_constant_p (VALUE)))\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class. */\n+/* On the Gmicro series, there is no restricton on GENERAL_REGS,\n+   so CLASS is returned. I do not know whether I should treat FPU_REGS\n+   specially or not (at least, m68k does not). */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the Gmicro, this is the size of MODE in words,\n+   except in the FPU regs, where a single reg is always enough.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FPU_REGS ? \\\n+   1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+/* On the Gmicro, FP points to the old FP and the first local variables are\n+   at (FP - 4). */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by. */\n+/* On the Gmicro, sp is decrimented by the exact size of the operand */\n+#define PUSH_ROUNDING(BYTES) (BYTES)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* On the Gmicro, the first argument is found at (ap + 8) where ap is fp. */\n+#define FIRST_PARM_OFFSET(FNDECL) 8\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack. \n+\n+   On the Gmicro, the EXITD insn may be used to pop them if the number\n+   of args is fixed, but if the number is variable then the caller must pop\n+   them all. The adjsp operand of the EXITD insn can't be used for library\n+   calls now because the library is compiled with the standard compiler.\n+   Use of adjsp operand is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.\n+   On the m68k this is an RTD option, so I use the same name\n+   for the Gmicro. The option name may be changed in the future. */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  ((TARGET_RTD && TREE_CODE (FUNTYPE) != IDENTIFIER_NODE\t\\\n+    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t    = void_type_node)))\t\t\t\t\t\\\n+   ? (SIZE) : 0)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the Gmicro the floating return value is in fr0 not r0.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\\\n+  (gen_rtx (REG, (MODE),\t\t\\\n+    ((TARGET_FPU && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0)))\n+\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the Gmicro, r0 and fp0 are the possible registers.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 16)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the Gmicro, no registers are used in this way.  */\n+/* Really? For the performance improvement, registers should be used !! */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the Gmicro, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the Gmicro, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the Gmicro all args are pushed, except if -mregparm is specified\n+   then the first two words of arguments are passed in d0, d1.\n+   *NOTE* -mregparm does not work.\n+   It exists only to test register calling conventions.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n+  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n+\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n+\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n+ ? 2 - (CUM) / 4 : 0)\n+\n+/* The following macro is defined to output register list.\n+   The LSB of Mask is the lowest number register.\n+   Regoff is MY_GREG_OFF or MY_FREG_OFF.\n+   Do NOT use <i> in File, Mask, Regoff !!\n+   Should be changed from macros to functions.    M.Yuhara */\n+\n+#define MY_GREG_OFF 0\n+#define MY_FREG_OFF 16\n+\n+#define MY_PRINT_MASK(File, Mask, Regoff)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+    int i, first = -1;\t\t\t\t\t\\\n+    if ((Mask) == 0) {\t\t\t\t\t\\\n+\tfprintf(File, \"#0\");\t\t\t\t\\\n+    } else {\t\t\t\t\t\t\\\n+\tfprintf(File, \"(\");\t\t\t\t\\\n+\tfor (i = 0; i < 16; i++) {\t\t\t\\\n+\t    if ( (Mask) & (1 << i) ) {\t\t\t\\\n+\t\tif (first < 0) {\t\t\t\\\n+\t\t    if (first == -2) {\t\t\t\\\n+\t\t\tfprintf(File, \",\");\t\t\\\n+\t\t    }\t\t\t\t\t\\\n+\t\t    first = i;\t\t\t\t\\\n+\t\t    fprintf(File, \"%s\", reg_names[Regoff + i]);\t\\\n+\t\t}\t\t\t\t\t\\\n+\t    } else if (first >= 0) {\t\t\t\\\n+\t\tif (i > first + 1) {\t\t\t\\\n+\t\t    fprintf(File, \"-%s\", reg_names[Regoff + i - 1]);\t\\\n+\t\t}\t\t\t\t\t\\\n+\t\tfirst = -2;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\tif ( (first >= 0) && (first != 15) )\t\t\\\n+\t    fprintf(File, \"-%s\", reg_names[Regoff + 15]);\\\n+\tfprintf(File, \")\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+\n+#define MY_PRINT_ONEREG_L(FILE,MASK)\t\t\\\n+{   register int i;\t\t\t\t\\\n+    for (i = 0; i < 16; i++)\t\t\t\\\n+\tif ( (1 << i) & (MASK)) {\t\t\\\n+\t    fprintf(FILE, \"%s\", reg_names[i]);\t\\\n+\t    (MASK) &= ~(1 << i);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+}\n+\n+\n+#define MY_PRINT_ONEREG_H(FILE,MASK)\t\t\\\n+{   register int i;\t\t\t\t\\\n+    for (i = 15; i >= 0; i--)\t\t\t\\\n+\tif ( (1 << i) & (MASK)) {\t\t\\\n+\t    fprintf(FILE, \"%s\", reg_names[i]);\t\\\n+\t    (MASK) &= ~(1 << i);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+/* The next macro needs much optimization !!\n+   M.Yuhara */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  register int nregs = 0;\t\t\t\t\t\\\n+  static char *reg_names[] = REGISTER_NAMES;\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n+\tmask |= (1 << regno);\t\t\t\t\t\\\n+\tnregs++;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) {\t\t\t\t\t\\\n+    mask &= ~(1 << FRAME_POINTER_REGNUM);\t\t\t\\\n+    if (nregs > 4) {\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tenter.w #%d,\", fsize);\t\t\t\\\n+\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n+\tfprintf(FILE,\"\\n\");\t\t\t\t\t\\\n+    } else {\t\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tmov.w fp,@-sp\\n\");\t\t\t\\\n+\tfprintf(FILE, \"\\tmov.w sp,fp\\n\");\t\t\t\\\n+\tif (fsize > 0)\t\t\t\t\t\t\\\n+\t    myoutput_sp_adjust(FILE, \"sub\", fsize);\t\t\\\n+\twhile (nregs--) {\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tmov.w \");\t\t\t\t\\\n+\t    MY_PRINT_ONEREG_H(FILE, mask);\t\t\t\\\n+\t    fprintf(FILE, \",@-sp\\n\");\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\\\n+    if (fsize > 0)\t\t\t\t\t\t\\\n+\tmyoutput_sp_adjust(FILE, \"sub\", fsize);\t\t\t\\\n+    if (mask != 0) {\t\t\t\t\t\t\\\n+\tif (nregs > 4) {\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tstm.w \");\t\t\t\t\\\n+\t    MY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\\\n+\t    fprintf(FILE, \",@-sp\\n\");\t\t\t\t\\\n+\t} else {\t\t\t\t\t\t\\\n+\t    while (nregs--) {\t\t\t\t\t\\\n+\t\tfprintf(FILE, \"\\tmov.w \");\t\t\t\\\n+\t\tMY_PRINT_ONEREG_H(FILE, mask);\t\t\t\\\n+\t\tfprintf(FILE, \",@-sp\\n\");\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 16; regno < 32; regno++)\t\t\t\t\\\n+        if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+            mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if (mask != 0) {\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tfstm.w \");\t\t\t\t\\\n+\tMY_PRINT_MASK(FILE, mask, MY_FREG_OFF);\t\t\t\\\n+\tfprintf(FILE, \",@-sp\\n\", mask);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+}\n+\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+/* ??? M.Yuhara */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tmova @LP%d,r0\\n\\tjsr mcount\\n\", (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tcmp #0,@LPBX0\\n\\tbne LPI%d\\n\\tpusha @LPBX0\\n\\tjsr ___bb_init_func\\n\\tadd #4,sp\\nLPI%d:\\n\",  \\\n+\t   LABELNO, LABELNO);\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+  fprintf (FILE, \"\\tadd #1,@(LPBX2+%d)\\n\", 4 * BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer (when\n+   frame_pinter_needed)  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+/* The Gmicro FPU seems to be unable to fldm/fstm double or single\n+   floating. It only allows extended !! */\n+/* Optimization is not enough, especially FREGs load !! M.Yuhara */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs, nfregs;\t\t\t\t\t\\\n+  int offset, foffset;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  static char *reg_names[] = REGISTER_NAMES;\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  FUNCTION_EXTRA_EPILOGUE (FILE, SIZE);\t\t\t\t\\\n+  nfregs = 0;  fmask = 0; \t\t\t\t\t\\\n+  for (regno = 16; regno < 31; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nfregs++; fmask |= 1 << (regno - 16); }\t\t\t\\\n+  foffset = nfregs * 12;\t\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  if (frame_pointer_needed) {\t\t\t\t\t\\\n+    offset = nregs * 4 + fsize;\t\t\t\t\t\\\n+    if (nfregs > 0) {\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tfldm.x @(%d,fp),\", -(foffset + offset));\\\n+\tMY_PRINT_MASK(FILE, fmask, MY_FREG_OFF);\t\t\\\n+\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+    if (nregs > 4\t\t\t\t\t\t\\\n+\t|| current_function_pops_args) {\t\t\t\\\n+\tfprintf(FILE, \"\\tmova @(%d,fp),sp\\n\", -offset);\t\t\\\n+\tfprintf(FILE, \"\\texitd \");\t\t\t\t\\\n+\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n+\tfprintf(FILE, \",#%d\\n\", current_function_pops_args);\t\\\n+    } else {\t\t\t\t\t\t\t\\\n+\twhile (nregs--) {\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tmov:l.w @(%d,fp),\", -offset);\t\\\n+\t    MY_PRINT_ONEREG_L(FILE, mask);\t\t\t\\\n+\t    fprintf(FILE, \"\\n\");\t\t\t\t\\\n+\t    offset -= 4;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\tif (TARGET_NEWRETURN) {\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tmova.w @(4,fp),sp\\n\");\t\t\\\n+\t    fprintf(FILE, \"\\tmov:l.w @fp,fp\\n\");\t\t\\\n+\t} else {\t\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tmov.w fp,sp\\n\");\t\t\t\\\n+\t    fprintf(FILE, \"\\tmov.w @sp+,fp\\n\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\trts\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\\\n+    if (nfregs > 0) {\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tfldm.w @sp+,\");\t\t\t\\\n+\tMY_PRINT_MASK(FILE, fmask, MY_FREG_OFF);\t\t\\\n+\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+    if (nregs > 4) {\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tldm.w @sp+,\");\t\t\t\t\\\n+\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n+\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n+    } else {\t\t\t\t\t\t\t\\\n+\twhile (nregs--) {\t\t\t\t\t\\\n+\t    fprintf(FILE, \"\\tmov.w @sp+,\");\t\t\t\\\n+\t    MY_PRINT_ONEREG_L(FILE,mask);\t\t\t\\\n+\t    fprintf(FILE, \"\\n\");\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+      if (current_function_pops_args) {\t\t\t\t\\\n+\tmyoutput_sp_adjust(FILE, \"add\", \t\t\t\\\n+\t    (fsize + 4 + current_function_pops_args));\t\t\\\n+\tfprintf(FILE, \"\\tjmp @(%d,sp)\\n\", current_function_pops_args);\\\n+    } else {\t\t\t\t\t\t\t\\\n+\tif (fsize > 0)\t\t\t\t\t\t\\\n+\t    myoutput_sp_adjust(FILE, \"add\", fsize);\t\t\\\n+\tfprintf(FILE, \"\\trts\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This is a hook for other tm files to change.  */\n+#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\n+\n+/* If the memory address ADDR is relative to the frame pointer,\n+   correct it to be relative to the stack pointer instead.\n+   This is for when we don't use a frame pointer.\n+   ADDR should be a variable name.  */\n+\n+/* You have to change the next macro if you want to use more complex\n+   addressing modes (such as double indirection and  more than one\n+   chain-addressing stages). */\n+\n+#define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH)  \\\n+{ int offset = -1;\t\t\t\t\t\t\t\\\n+  rtx regs = stack_pointer_rtx;\t\t\t\t\t\t\\\n+  if (ADDR == frame_pointer_rtx)\t\t\t\t\t\\\n+    offset = 0;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx \\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n+    offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx) \\\n+    { rtx other_reg = XEXP (ADDR, 1);\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx) \\\n+    { rtx other_reg = XEXP (ADDR, 0);\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n+\t   && XEXP (XEXP (ADDR, 0), 0) == frame_pointer_rtx\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n+    { rtx other_reg = XEXP (XEXP (ADDR, 0), 1);\t\t\t\t\\\n+      offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n+\t   && XEXP (XEXP (ADDR, 0), 1) == frame_pointer_rtx\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n+    { rtx other_reg = XEXP (XEXP (ADDR, 0), 0);\t\t\t\t\\\n+      offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n+      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+  if (offset >= 0)\t\t\t\t\t\t\t\\\n+    { int regno;\t\t\t\t\t\t\t\\\n+      extern char call_used_regs[];\t\t\t\t\t\\\n+      for (regno = 16; regno < 32; regno++)\t\t\t\t\\\n+        if (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+          offset += 12;\t\t\t\t\t\t\t\\\n+      for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+\t  offset += 4;\t\t\t\t\t\t\t\\\n+      offset -= 4;\t\t\t\t\t\t\t\\\n+      ADDR = plus_constant (regs, offset + (DEPTH)); } }\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+/* Gmicro */\n+#define REGNO_OK_FOR_GREG_P(REGNO) \\\n+((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n+#define REGNO_OK_FOR_FPU_P(REGNO) \\\n+(((REGNO) ^ 0x10) < 16 || (unsigned) (reg_renumber[REGNO] ^ 0x10) < 16)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_GREG_P(REGNO)\n+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_GREG_P(REGNO)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the Gmicro, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fpu register.  */\n+\n+#define FPU_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FPU_P (REGNO (X)))\n+\n+/* I used GREG_P in the gmicro.md file. */\n+\n+#ifdef REG_OK_STRICT\n+#define GREG_P(X) (REG_P (X) && REGNO_OK_FOR_GREG_P (REGNO(X)))\n+#else\n+#define GREG_P(X) (REG_P (X) && ((REGNO (X) & ~0xf) != 0x10))\n+#endif\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+/* The Gmicro allows more registers in the chained addressing mode.\n+   But I do not know gcc supports such an architecture. */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) ((REGNO (X) & ~0xf) != 0x10)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) ((REGNO (X) & ~0xf) != 0x10)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* The gcc uses the following effective address of the Gmicro.\n+\t\t\t\t\t       (without using PC!!).\n+   {@} ( {Rbase} + {Disp} + {Rindex * [1,2,4,8]} )\n+\twhere\n+\t\t@:     memory indirection.\n+\t\tRbase: Base Register = General Register.\n+\t\tDisp:  Displacement (up to 32bits)\n+\t\tRindex: Index Register = General Register.\n+\t\t[1,2,4,8]: Scale of Index. 1 or 2 or 4 or 8.\n+\t\tThe inside of { } can be omitted.\n+    This restricts the chained addressing up to 1 stage.  */\n+\n+\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+#define REG_CODE_BASE_P(X) \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+#define REG_CODE_INDEX_P(X) \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n+/* GET_CODE(X) must be PLUS. This macro does not check for PLUS! */\n+#define BASE_PLUS_DISP_P(X) \\\n+   ( REG_CODE_BASE_P (XEXP (X, 0)) \t\t\\\n+     && CONSTANT_ADDRESS_P (XEXP (X, 1))\t\\\n+    ||\t\t\t\t\t\t\\\n+     REG_CODE_BASE_P (XEXP (X, 1)) \t\t\\\n+     && CONSTANT_ADDRESS_P (XEXP (X, 0)) )\n+\n+/* 1 if X is {0,Rbase} + {0,disp}.  */\n+#define BASED_ADDRESS_P(X)  \\\n+  (CONSTANT_ADDRESS_P (X)\t\\\n+   || REG_CODE_BASE_P (X)\t\\\n+   || (GET_CODE (X) == PLUS)\t\\\n+       && BASE_PLUS_DISP_P (X))\n+\n+/* 1 if X is 1 or 2 or 4 or 8. GET_CODE(X) must be CONST_INT. */\n+#define SCALE_OF_INDEX_P(X) \\\n+  ( INTVAL(X) == 4\t\\\n+    || INTVAL(X) == 2\t\\\n+    || INTVAL(X) == 8\t\\\n+    || INTVAL(X) == 1 )\n+\n+/* #define INDEX_TERM_P(X,MODE)  */\n+#define INDEX_TERM_P(X)  \\\n+  ( REG_CODE_INDEX_P(X)\t\t\t\t\t\\\n+    || (GET_CODE (X) == MULT\t\t\t\t\\\n+\t&& ( (xfoo0 = XEXP (X, 0)), (xfoo1 = XEXP(X, 1)), \\\n+\t     ( ( (GET_CODE (xfoo0) == CONST_INT)\t\\\n+\t       && SCALE_OF_INDEX_P (xfoo0)\t\t\\\n+\t       && REG_CODE_INDEX_P (xfoo1) )\t\t\\\n+\t      ||\t\t\t\t\t\\\n+\t       ( (GET_CODE (xfoo1) == CONST_INT)\t\t\\\n+\t       && SCALE_OF_INDEX_P (xfoo1)\t\t\\\n+\t       && REG_CODE_INDEX_P (xfoo0) ) ))))\n+\n+/* Assumes there are no cases such that X = (Ireg + Disp) + Disp */\n+#define BASE_DISP_INDEX_P(X)  \\\n+  ( BASED_ADDRESS_P (X)\t\t\t\t\t\t\t\\\n+   || ( (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+      && ( ( (xboo0 = XEXP (X, 0)), (xboo1 = XEXP (X, 1)),\t\t\\\n+\t  (REG_CODE_BASE_P (xboo0)\t\t\t\t\t\\\n+\t    && (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n+\t    && ( ( CONSTANT_ADDRESS_P (XEXP (xboo1, 0))\t\t\t\\\n+\t\t   && INDEX_TERM_P (XEXP (xboo1, 1)) )\t\t\t\\\n+\t         || ( CONSTANT_ADDRESS_P (XEXP (xboo1, 1))\t\t\\\n+\t\t     && INDEX_TERM_P (XEXP (xboo1, 0))) )))\t\t\\\n+\t ||\t\t\t\t\t\t\t\t\\\n+\t  (CONSTANT_ADDRESS_P (xboo0)\t\t\t\t\t\\\n+\t    && (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n+\t    && ( ( REG_CODE_BASE_P (XEXP (xboo1, 0))\t\t\t\\\n+\t \t   && INDEX_TERM_P (XEXP (xboo1, 1)) )\t\t\t\\\n+\t         || ( REG_CODE_BASE_P (XEXP (xboo1, 1))\t\t\t\\\n+\t\t      && INDEX_TERM_P (XEXP (xboo1, 0))) ))\t\t\\\n+\t||\t\t\t\t\t\t\t\t\\\n+\t  (INDEX_TERM_P (xboo0)\t\t\t\t\t\t\\\n+\t    && ( ( (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n+\t          && ( ( REG_CODE_BASE_P (XEXP (xboo1, 0))\t\t\\\n+\t\t      && CONSTANT_ADDRESS_P (XEXP (xboo1, 1)) )\t\t\\\n+\t               || ( REG_CODE_BASE_P (XEXP (xboo1, 1))   \t\\\n+\t\t      && CONSTANT_ADDRESS_P (XEXP (xboo1, 0))) ))\t\\\n+\t\t||\t\t\t\t\t\t\t\\\n+\t\t (CONSTANT_ADDRESS_P (xboo1))\t\t\t\t\\\n+\t\t||\t\t\t\t\t\t\t\\\n+\t\t (REG_CODE_BASE_P (xboo1)) )))))\n+\n+/*\n+\tIf you want to allow double-indirection,\n+\tyou have to change the <fp-relative> => <sp-relative> conversion\n+\troutine. M.Yuhara\n+\n+#ifdef REG_OK_STRICT\n+#define DOUBLE_INDIRECTION(X,ADDR) {\\\n+    if (BASE_DISP_INDEX_P (XEXP (XEXP (X, 0), 0) )) goto ADDR; \\\n+    }\n+#else\n+#define DOUBLE_INDIRECTION(X,ADDR) { }\n+#endif\n+*/\n+\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) {\\\n+  register rtx xboo0, xboo1, xfoo0, xfoo1;\t\t\\\n+  if (GET_CODE (X) == MEM) { \t\t\t\t\\\n+    /*\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X,0)) == MEM) {\t\t\t\\\n+\tDOUBLE_INDIRECTION(X,ADDR);\t\t\t\\\n+    } else {\t\t\t\t\t\t\\\n+\tif (BASE_DISP_INDEX_P (XEXP (X, 0))) goto ADDR;\t\\\n+    }\t\t\t\t\t\t\t\\\n+    */\t\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\\\n+\tif (BASE_DISP_INDEX_P (X)) goto ADDR;\t\t\\\n+\tif ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\\\n+\t    && REG_P (XEXP (X, 0))\t\t\t\t\t\\\n+\t    && (REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM))\t\t\\\n+\t\tgoto ADDR;\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the Gmicro, nothing is done now. */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the VAX, the predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand)\n+   and all indexed address depend thus (because the index scale factor\n+   is the length of the operand).\n+   The Gmicro mimics the VAX now. Since ADDE is legitimate, it cannot\n+   include auto-inc/dec. */\n+\n+/* Unnecessary ??? */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n+     goto LABEL; }\n+\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+/* #define CASE_VECTOR_MODE HImode */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+/* #define STORE_FLAG_VALUE -1 */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if ((unsigned) INTVAL (RTX) < 8) return 0;\t\t\t\\\n+    if ((unsigned) (INTVAL (RTX) + 0x80) < 0x100) return 1;\t\\\n+    if ((unsigned) (INTVAL (RTX) + 0x8000) < 0x10000) return 2;\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\f\n+/* Define subroutines to call to handle multiply and divide.\n+   The `*' prevents an underscore from being prepended by the compiler.  */\n+/* Use libgcc on Gmicro */\n+/* #define UDIVSI3_LIBCALL \"*udiv\" */\n+/* #define UMODSI3_LIBCALL \"*urem\" */\n+\n+\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* Set if the cc value is actually in the FPU, so a floating point\n+   conditional branch must be output.  */\n+#define CC_IN_FPU 04000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* Since Gmicro's compare instructions depend on the branch condition,\n+   all branch should be kept.\n+   More work must be done to optimize condition code !! M.Yuhara */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) {CC_STATUS_INIT;}\n+\n+/* The skelton of the next macro is taken from \"vax.h\".\n+   FPU-reg manipulation is added.  M.Yuhara */\n+/* Now comment out.\n+#define NOTICE_UPDATE_CC(EXP, INSN) {\t\\\n+  if (GET_CODE (EXP) == SET) {\t\t\t\t\t\\\n+      if ( !FPU_REG_P (XEXP (EXP, 0))\t\t\t\t\\\n+\t  && (XEXP (EXP, 0) != cc0_rtx)\t\t\t\t\\\n+\t  && (FPU_REG_P (XEXP (EXP, 1))\t\t\t\t\\\n+\t      || GET_CODE (XEXP (EXP, 1)) == FIX\t\t\\\n+\t      || GET_CODE (XEXP (EXP, 1)) == FLOAT_TRUNCATE\t\\\n+\t      || GET_CODE (XEXP (EXP, 1)) == FLOAT_EXTEND)) {\t\\\n+\t CC_STATUS_INIT;\t\t\t\t\t\\\n+      } else if (GET_CODE (SET_SRC (EXP)) == CALL) {\t\t\\\n+\t CC_STATUS_INIT;\t\t\t\t\t\\\n+      } else if (GET_CODE (SET_DEST (EXP)) != PC) {\t\t\\\n+\t  cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n+\t  cc_status.value2 = SET_SRC (EXP);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n+\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET\t\t\\\n+\t   && GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC) {\\\n+      cc_status.flags = 0;\t\t\t\t\t\\\n+      cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n+      cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); \t\\\n+  /* PARALLELs whose first element sets the PC are aob, sob VAX insns.\t\\\n+     They do change the cc's.  So drop through and forget the cc's. * / \\\n+  } else CC_STATUS_INIT;\t\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n+    cc_status.value2 = 0;\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n+    cc_status.value2 = 0;\t\t\t\t\t\\\n+  if ( (cc_status.value1 && FPU_REG_P (cc_status.value1))\t\\\n+      || (cc_status.value2 && FPU_REG_P (cc_status.value2)))\t\\\n+    cc_status.flags = CC_IN_FPU;\t\t\t\t\\\n+}\n+*/\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n+{ if (cc_prev_status.flags & CC_IN_FPU)\t\t\\\n+    return FLOAT;\t\t\t\t\\\n+  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\\\n+    return NO_OV;\t\t\t\t\\\n+  return NORMAL; }\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section text,code,align=4\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.section data,data,align=4\"\n+\n+/* Output before uninitialized data. */\n+\n+#define BSS_SECTION_ASM_OP \"\\t.section bss,data,align=4\"\n+\n+#define EXTRA_SECTIONS in_bss\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\\\n+void\t\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+    if (in_section != in_bss) {\t\t\t\t\t\\\n+\tfprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\t\\\n+\tin_section = in_bss;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Output at beginning of assembler file.\n+   It is not appropriate for this to print a list of the options used,\n+   since that's not the convention that we use.  */\n+\n+#define ASM_FILE_START(FILE)\n+\n+/* Output at the end of assembler file. */\n+\n+#define ASM_FILE_END(FILE)  fprintf (FILE, \"\\t.end\\n\");\n+\n+\n+/* Don't try to define `gcc_compiled.' since the assembler do not\n+   accept symbols with periods and GDB doesn't run on this machine anyway.  */\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+/* #define ASM_APP_ON \"#APP\\n\" */\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+/* #define ASM_APP_OFF \";#NO_APP\\n\" */\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n+ \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"fp\", \"sp\",\t\\\n+ \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\", \\\n+ \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\"}\n+\n+/* How to renumber registers for dbx and gdb. */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Define this if gcc should produce debugging output for dbx in response\n+   to the -g flag. This does not work for the Gmicro now */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME) {\t\\\n+    assemble_name (FILE, NAME);\t\\\n+    fputs (\":\\n\", FILE);\t\\\n+}\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME) {\\\n+    fputs (\"\\t.global \", FILE);\t\\\n+    assemble_name (FILE, NAME);\t\\\n+    fputs (\"\\n\", FILE);\t\t\\\n+}\n+\n+/* This is how to output a command to make the external label named NAME\n+   which are not defined in the file to be referable */\n+/* \".import\" does not work ??? */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) { \\\n+    fputs (\"\\t.global \", FILE);\t\\\n+    assemble_name (FILE, NAME);\t\\\n+    fputs (\"\\n\", FILE);\t\t\\\n+}\n+\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+/* do {...} while(0) is necessary, because these macros are used as\n+    if (xxx) MACRO; else ....\n+\t\t  ^\n+*/\n+\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { union { double d; long l[2];} tem;\t\t\t\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.fdata.d h'%x%08x.d\\n\", tem.l[0], tem.l[1]);\t\\\n+} while(0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.fdata.s h'%x.s\\n\", tem.l);\t\\\n+} while(0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.data.w \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.data.h \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.data.b \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.data.b h'%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ASCII(FILE,P,SIZE)  \\\n+  output_ascii ((FILE), (P), (SIZE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov %s,@-sp\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov @sp+,%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The Gmicro does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.data.w L%d\\n\", VALUE)\n+\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.data.w L%d-L%d\\n\", VALUE, REL)\n+\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  fprintf (FILE, \"\\t.align %d\\n\", (1 << (LOG)));\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.res.b %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( bss_section (),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \":\\t.res.b %d\\n\", (ROUNDED)),\\\n+  fprintf ((FILE), \"\\t.export \"),\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \"\\n\") )\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( bss_section (),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \":\\t.res.b %d\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+/* $__ is unique ????? M.Yuhara */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"$__%s%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Output a float value (represented as a C double) as an immediate operand.\n+   This macro is a Gmicro/68k-specific macro.  */\n+\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\\\n+do { union { float f; long l;} tem;\t\t\\\n+  tem.f = (VALUE);\t\t\t\t\\\n+  fprintf (FILE, \"#h'%x.s\", tem.l);\t\t\\\n+} while(0)\n+\n+\n+/* Output a double value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\\\n+do { union { double d; long l[2];} tem;\t\t\\\n+  tem.d = (VALUE);\t\t\t\t\\\n+  fprintf (FILE, \"#h'%x%08x.d\", tem.l[0], tem.l[1]);\t\\\n+} while(0)\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   On the Gmicro, we use several CODE characters:\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'b' for branch target label.\n+   '-' for an operand pushing on the stack.\n+   '+' for an operand pushing on the stack.\n+   '#' for an immediate operand prefix \n+*/\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n+  ( (CODE) == '#' || (CODE) == '-'\t\t\\\n+     || (CODE) == '+' || (CODE) == '@' || (CODE) == '!')\n+\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ int i;\t\t\t\t\t\t\t\t\\\n+  static char *reg_name[] = REGISTER_NAMES;\t\t\t\t\\\n+/* fprintf (stderr, \"PRINT_OPERAND CODE=%c(0x%x), \", CODE, CODE);\\\n+myprcode(GET_CODE(X)); */\t\\\n+  if (CODE == '#') fprintf (FILE, \"#\");\t\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"@-sp\");\t\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"@sp+\");\t\t\t\t\\\n+  else if (CODE == 's') fprintf (stderr, \"err: PRINT_OPERAND <s>\\n\"); \t\\\n+  else if (CODE == '!') fprintf (stderr, \"err: PRINT_OPERAND <!>\\n\"); \t\\\n+  else if (CODE == '.') fprintf (stderr, \"err: PRINT_OPERAND <.>\\n\"); \t\\\n+  else if (CODE == 'b') {\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+\toutput_addr_const (FILE, XEXP (X, 0));  /* for bsr */\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+\toutput_addr_const (FILE, X);  /* for bcc */\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  else if (CODE == 'p')\t\t\t\t\t\t\t\\\n+    print_operand_address (FILE, X);\t\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_name[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+\tASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"#h'%x\", u1.i); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      ASM_OUTPUT_DOUBLE_OPERAND (FILE, u.d); }\t\t\t\t\\\n+  else { putc ('#', FILE);\t\t\t\t\t\t\\\n+output_addr_const (FILE, X); }}\n+\f\n+/* Note that this contains a kludge that knows that the only reason\n+   we have an address (plus (label_ref...) (reg...))\n+   is in the insn before a tablejump, and we know that m68k.md\n+   generates a label LInnn: on such an insn.  */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n+    { print_operand_address (FILE, ADDR); }\n+\f\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}]}