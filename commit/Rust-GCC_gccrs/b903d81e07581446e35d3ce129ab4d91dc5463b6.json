{"sha": "b903d81e07581446e35d3ce129ab4d91dc5463b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkwM2Q4MWUwNzU4MTQ0NmUzNWQzY2UxMjlhYjRkOTFkYzU0NjNiNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-01-12T01:54:31Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-01-12T01:54:31Z"}, "message": "2000-01-12  Gabriel Dos Reis <gdr@codesourcery.com>\n\n         Implement automatic line wrapping mode in the g++ front-end.\n\nFrom-SVN: r31343", "tree": {"sha": "59ef54b6938fec73026db4d078e3259d6f372fb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59ef54b6938fec73026db4d078e3259d6f372fb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b903d81e07581446e35d3ce129ab4d91dc5463b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b903d81e07581446e35d3ce129ab4d91dc5463b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b903d81e07581446e35d3ce129ab4d91dc5463b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b903d81e07581446e35d3ce129ab4d91dc5463b6/comments", "author": null, "committer": null, "parents": [{"sha": "40c79d58a3f379be9eb020e7d338319bf0e93907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c79d58a3f379be9eb020e7d338319bf0e93907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c79d58a3f379be9eb020e7d338319bf0e93907"}], "stats": {"total": 467, "additions": 437, "deletions": 30}, "files": [{"sha": "2dd20554befedca56b8ae1518af8710453e23388", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b903d81e07581446e35d3ce129ab4d91dc5463b6", "patch": "@@ -1,3 +1,25 @@\n+2000-01-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n+ \n+       * toplev.h (set_message_length): Declare.\n+ \n+       * diagnostic.c (obstack_chunk_alloc): Define macro.\n+       (obstack_chunk_free): Likewise.\n+       (struct output_buffer): New data structure.\n+       (vmessage): Remove.\n+       (output_maximum_width): New variable.\n+       (doing_line_wrapping, set_message_length, init_output_buffer,\n+       get_output_prefix, output_space_left, emit_output_prefix,\n+       output_newline, output_append, output_puts, dump_output,\n+       vbuild_message_string, build_message_string, build_location_prefix,\n+       voutput_notice, output_printf, line_wrapper_printf,\n+       vline_wrapper_message_with_location):  New functions. Implement\n+       automatic line wrapping.\n+       (v_message_with_decl): Make it handle automatic line wrapping.\n+       (v_error_with_file_and_line): Likewise.\n+       (v_warning_with_file_and_line): Likewise.\n+       (announce_function): Likewise.\n+       (default_print_error_function): Likewise.\n+\t\n 2000-01-11 16:24 -0800  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.h (struct cpp_options): Change lang_asm to char."}, {"sha": "031947e586cc389f9f39aae2d0c1ee69b4bb2366", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b903d81e07581446e35d3ce129ab4d91dc5463b6", "patch": "@@ -1,3 +1,8 @@\n+2000-01-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n+ \n+       * decl2.c (lang_decode_option): Handle automatic line wrapping\n+       option.\n+\t\n 2000-01-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* friend.c (do_friend): Don't resolve scopes when processing"}, {"sha": "9d2eead4d120372c99e8e20efa02573c878e5990", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 409, "deletions": 30, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b903d81e07581446e35d3ce129ab4d91dc5463b6", "patch": "@@ -37,11 +37,41 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"toplev.h\"\n #include \"intl.h\"\n+#include \"obstack.h\"\n \n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free  free\n+\n+struct output_buffer\n+{\n+  struct obstack obstack;       /* where we build the text to output */\n+  const char *prefix;           /* prefix of every new line  */\n+  int line_length;              /* current line length (in characters) */\n+  int max_length;               /* maximum characters per line */\n+};\n \n /* Prototypes. */\n+static int doing_line_wrapping PROTO((void));\n+static void init_output_buffer PROTO((struct output_buffer*,\n+                                      const char *, int));\n+static const char *get_output_prefix PROTO((const struct output_buffer *));\n+static int output_space_left PROTO((const struct output_buffer *));\n+static void emit_output_prefix PROTO((struct output_buffer *));\n+static void output_newline PROTO((struct output_buffer *));\n+static void output_append PROTO((struct output_buffer *, const char *,\n+                                 const char *));\n+static void output_puts PROTO((struct output_buffer *, const char *));\n+static void dump_output PROTO((struct output_buffer *, FILE *));\n+static const char *vbuild_message_string PROTO((const char *, va_list));\n+static const char *build_message_string PVPROTO((const char *, ...));\n+static const char *build_location_prefix PROTO((const char *, int, int));\n+static void voutput_notice PROTO((struct output_buffer *, const char *,\n+                                  va_list));\n+static void output_printf PVPROTO((struct output_buffer *, const char *, ...));\n+static void line_wrapper_printf PVPROTO((FILE *, const char *, ...));\n+static void vline_wrapper_message_with_location PROTO((const char *, int, int,\n+                                                       const char *, va_list));\n static void notice PVPROTO((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n-static void vmessage PROTO((const char *, const char *, va_list));\n static void v_message_with_file_and_line PROTO((const char *, int, int,\n \t\t\t\t\t\tconst char *, va_list));\n static void v_message_with_decl PROTO((tree, int, const char *, va_list));\n@@ -88,7 +118,296 @@ static int last_error_tick;\n void (*print_error_function) PROTO((const char *)) =\n   default_print_error_function;\n \n+/* Maximum characters per line in automatic line wrapping mode.\n+   Non Zero means don't wrap lines. */\n+\n+static int output_maximum_width = 0;\n \f\n+/* Predicate. Return 1 if we're in automatic line wrapping mode.  */\n+\n+static int\n+doing_line_wrapping ()\n+{\n+  return output_maximum_width > 0;\n+}\n+\n+/* Set Maximum characters per line in automatic line wrapping mode.  */\n+\n+void\n+set_message_length (n)\n+     int n;\n+{\n+    output_maximum_width = n;\n+}\n+\n+/* Construct an output BUFFER with PREFIX and of MAX_LENGTH characters\n+   per line.  */\n+\n+static void\n+init_output_buffer (buffer, prefix, max_length)\n+     struct output_buffer *buffer;\n+     const char *prefix;\n+     int max_length;\n+{\n+  obstack_init (&buffer->obstack);\n+  buffer->prefix = prefix;\n+  buffer->line_length = 0;\n+  buffer->max_length = max_length;\n+}\n+\n+/* Return BUFFER's prefix.  */\n+\n+static const char *\n+get_output_prefix (buffer)\n+     const struct output_buffer *buffer;\n+{\n+  return buffer->prefix;\n+}\n+\n+/* Return the amount of characters BUFFER can accept to\n+   make a full line.  */\n+\n+static int\n+output_space_left (buffer)\n+     const struct output_buffer *buffer;\n+{\n+  return buffer->max_length - buffer->line_length;\n+}\n+\n+/* Dump BUFFER's prefix.  */\n+\n+static void\n+emit_output_prefix (buffer)\n+     struct output_buffer *buffer;\n+{\n+  if (buffer->prefix)\n+    {\n+      buffer->line_length = strlen (buffer->prefix);\n+      obstack_grow (&buffer->obstack, buffer->prefix, buffer->line_length);\n+    }\n+}\n+\n+/* Have BUFFER start a new line.  */\n+\n+static void\n+output_newline (buffer)\n+     struct output_buffer *buffer;\n+{\n+  obstack_1grow (&buffer->obstack, '\\n');\n+  buffer->line_length = 0;\n+}\n+\n+/* Append a string deliminated by START and END to BUFFER.  No wrapping is\n+   done.  The caller must ensure that it is safe to do so.  */\n+\n+static void\n+output_append (buffer, start, end)\n+     struct output_buffer *buffer;\n+     const char *start;\n+     const char *end;\n+{\n+  int n;\n+\n+  /* Emit prefix and skip whitespace if we're starting a new line.  */\n+  if (buffer->line_length == 0)\n+    {\n+      emit_output_prefix (buffer);\n+      while (start != end && *start == ' ')\n+        ++start;\n+    }\n+  n = end - start;\n+  obstack_grow (&buffer->obstack, start, n);\n+  buffer->line_length += n;\n+}\n+\n+/* Wrap a STRing into BUFFER.  */\n+\n+static void\n+output_puts (buffer, str)\n+     struct output_buffer *buffer;\n+     const char *str;\n+{\n+  const char *p = str;\n+  \n+  while (*str)\n+    {\n+      while (*p && *p != ' ' && *p != '\\n')\n+        ++p;\n+      \n+      if (p - str < output_space_left (buffer))\n+        output_append (buffer, str, p);\n+      else\n+        {\n+          output_newline (buffer);\n+          output_append (buffer, str, p);\n+        }\n+      \n+      while (*p && *p == '\\n')\n+        {\n+          output_newline (buffer);\n+          ++p;\n+        }\n+\n+      str = p++;\n+    }\n+}\n+\n+/* Dump the content of BUFFER into FILE.  */\n+\n+static void\n+dump_output (buffer, file)\n+     struct output_buffer *buffer;\n+     FILE *file;\n+{\n+  const char *text;\n+  \n+  obstack_1grow (&buffer->obstack, '\\0');\n+  text = obstack_finish (&buffer->obstack);\n+  fputs (text, file);\n+  obstack_free (&buffer->obstack, (char *)text);\n+  buffer->line_length = 0;\n+}\n+\n+static const char *\n+vbuild_message_string (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+  char *str;\n+\n+  vasprintf (&str, msgid, ap);\n+  return str;\n+}\n+\n+/*  Return a malloc'd string containing MSGID formatted a la\n+    printf.  The caller is reponsible for freeing the memory.  */\n+\n+static const char *\n+build_message_string VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  const char *str;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  str = vbuild_message_string (msgid, ap);\n+\n+  va_end (ap);\n+\n+  return str;\n+}\n+\n+\n+/* Return a malloc'd string describing a location.  The caller is\n+   responsible for freeing the memory.  */\n+\n+static const char *\n+build_location_prefix (file, line, warn)\n+     const char *file;\n+     int line;\n+     int warn;\n+{\n+  const char *fmt = file\n+    ? (warn ? \"%s:%d: warning: \" : \"%s:%d: \")\n+    : (warn ? \"%s: warning: \" : \"%s: \");\n+\n+  return file\n+    ? build_message_string (fmt, file, line)\n+    : build_message_string (fmt, progname);\n+}\n+\n+/* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */\n+\n+static void\n+voutput_notice (buffer, msgid, ap)\n+     struct output_buffer *buffer;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  const char *message = vbuild_message_string (msgid, ap);\n+\n+  output_puts (buffer, message);\n+  free ((char *)message);\n+}\n+\n+\n+/* Format a message into BUFFER a la printf.  */\n+\n+static void\n+output_printf VPROTO((struct output_buffer *buffer, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  struct output_buffer *buffer;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  buffer = va_arg (ap, struct output_buffer *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  voutput_notice (buffer, msgid, ap);\n+  va_end (ap);\n+}\n+\n+\n+/* Format a MESSAGE into FILE.  Do line wrapping, starting new lines\n+   with PREFIX.  */\n+\n+static void\n+line_wrapper_printf VPROTO((FILE *file, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  FILE *file;\n+  const char *msgid;\n+#endif\n+  struct output_buffer buffer;\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  file = va_arg (ap, FILE *);\n+  msgid = va_arg (ap, const char *);\n+#endif  \n+\n+  init_output_buffer (&buffer, (const char *)NULL, output_maximum_width);\n+  voutput_notice (&buffer, msgid, ap);\n+  dump_output (&buffer, file);\n+\n+  va_end (ap);\n+}\n+\n+\n+static void\n+vline_wrapper_message_with_location (file, line, warn, msgid, ap)\n+     const char *file;\n+     int line;\n+     int warn;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  struct output_buffer buffer;\n+  \n+  init_output_buffer\n+    (&buffer, build_location_prefix (file, line, warn), output_maximum_width);\n+  voutput_notice (&buffer, msgid, ap);\n+  dump_output (&buffer, stderr);\n+  free ((char*)get_output_prefix (&buffer));\n+  fputc ('\\n', stderr);\n+}\n+\n+\n /* Print the message MSGID in FILE.  */\n \n static void\n@@ -137,20 +456,6 @@ report_file_and_line (file, line, warn)\n     notice (\"warning: \");\n }\n \n-/* Print a PREFIXed MSGID.  */\n-\n-static void\n-vmessage (prefix, msgid, ap)\n-     const char *prefix;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (prefix)\n-    fprintf (stderr, \"%s: \", prefix);\n-\n-  vfprintf (stderr, msgid, ap);\n-}\n-\n /* Print a message relevant to line LINE of file FILE.  */\n \n static void\n@@ -176,9 +481,17 @@ v_message_with_decl (decl, warn, msgid, ap)\n      va_list ap;\n {\n   const char *p;\n-\n-  report_file_and_line (DECL_SOURCE_FILE (decl),\n-\t\t\tDECL_SOURCE_LINE (decl), warn);\n+  struct output_buffer buffer;\n+\n+  if (doing_line_wrapping ())\n+    init_output_buffer\n+      (&buffer,\n+       build_location_prefix (DECL_SOURCE_FILE (decl),\n+                              DECL_SOURCE_LINE (decl), warn),\n+       output_maximum_width);\n+  else\n+    report_file_and_line (DECL_SOURCE_FILE (decl),\n+                          DECL_SOURCE_LINE (decl), warn);\n \n   /* Do magic to get around lack of varargs support for insertion\n      of arguments into existing list.  We know that the decl is first;\n@@ -198,14 +511,22 @@ v_message_with_decl (decl, warn, msgid, ap)\n     }\n \n   if (p > _(msgid))\t\t\t/* Print the left-hand substring.  */\n-    fprintf (stderr, \"%.*s\", (int)(p - _(msgid)), _(msgid));\n+    {\n+      if (doing_line_wrapping ())\n+        output_printf (&buffer, \"%.*s\", (int)(p - _(msgid)), _(msgid));\n+      else\n+        fprintf (stderr, \"%.*s\", (int)(p - _(msgid)), _(msgid));\n+    }\n \n   if (*p == '%')\t\t/* Print the name.  */\n     {\n       const char *n = (DECL_NAME (decl)\n \t\t ? (*decl_printable_name) (decl, 2)\n \t\t : \"((anonymous))\");\n-      fputs (n, stderr);\n+      if (doing_line_wrapping ())\n+        output_puts (&buffer, n);\n+      else\n+        fputs (n, stderr);\n       while (*p)\n \t{\n \t  ++p;\n@@ -215,8 +536,19 @@ v_message_with_decl (decl, warn, msgid, ap)\n     }\n \n   if (*p)\t\t\t/* Print the rest of the message.  */\n-    vmessage ((char *)NULL, p, ap);\n+    {\n+      if (doing_line_wrapping ())\n+        voutput_notice (&buffer, p, ap);\n+      else\n+        vfprintf (stderr, p, ap);\n+    }\n \n+  if (doing_line_wrapping())\n+    {\n+      dump_output (&buffer, stderr);\n+      free ((char *)get_output_prefix (&buffer));\n+    }\n+  \n   fputc ('\\n', stderr);\n }\n \n@@ -268,7 +600,10 @@ v_error_with_file_and_line (file, line, msgid, ap)\n {\n   count_error (0);\n   report_error_function (file);\n-  v_message_with_file_and_line (file, line, 0, msgid, ap);\n+  if (doing_line_wrapping ())\n+    vline_wrapper_message_with_location (file, line, 0, msgid, ap);\n+  else\n+    v_message_with_file_and_line (file, line, 0, msgid, ap);\n }\n \n /* Report an error at the declaration DECL.\n@@ -347,7 +682,10 @@ v_warning_with_file_and_line (file, line, msgid, ap)\n   if (count_error (1))\n     {\n       report_error_function (file);\n-      v_message_with_file_and_line (file, line, 1, msgid, ap);\n+      if (doing_line_wrapping ())\n+        vline_wrapper_message_with_location (file, line, 1, msgid, ap);\n+      else\n+        v_message_with_file_and_line (file, line, 1, msgid, ap);\n     }\n }\n \n@@ -635,7 +973,13 @@ announce_function (decl)\n       if (rtl_dump_and_exit)\n \tfprintf (stderr, \"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n-\tfprintf (stderr, \" %s\", (*decl_printable_name) (decl, 2));\n+        {\n+          if (doing_line_wrapping ())\n+            line_wrapper_printf\n+              (stderr, \" %s\", (*decl_printable_name) (decl, 2));\n+          else\n+            fprintf (stderr, \" %s\", (*decl_printable_name) (decl, 2));\n+        }\n       fflush (stderr);\n       need_error_newline = 1;\n       last_error_function = current_function_decl;\n@@ -651,22 +995,57 @@ default_print_error_function (file)\n {\n   if (last_error_function != current_function_decl)\n     {\n+      const char *prefix = NULL;\n+      struct output_buffer buffer;\n+      \n       if (file)\n-\tfprintf (stderr, \"%s: \", file);\n+        prefix = build_message_string (\"%s: \", file);\n \n+      if (doing_line_wrapping ())\n+        init_output_buffer (&buffer, prefix, output_maximum_width);\n+      else\n+        {\n+          if (file)\n+            fprintf (stderr, \"%s: \", file);\n+        }\n+      \n       if (current_function_decl == NULL)\n-\tnotice (\"At top level:\\n\");\n+        {\n+          if (doing_line_wrapping ())\n+            output_printf (&buffer, \"At top level:\\n\");\n+          else\n+            notice (\"At top level:\\n\");\n+        }\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n-\t    notice (\"In method `%s':\\n\",\n-\t\t    (*decl_printable_name) (current_function_decl, 2));\n+            {\n+              if (doing_line_wrapping ())\n+                output_printf\n+                  (&buffer, \"In method `%s':\\n\",\n+                   (*decl_printable_name) (current_function_decl, 2));\n+              else\n+                notice (\"In method `%s':\\n\",\n+                        (*decl_printable_name) (current_function_decl, 2));\n+            }\n \t  else\n-\t    notice (\"In function `%s':\\n\",\n-\t\t    (*decl_printable_name) (current_function_decl, 2));\n+            {\n+              if (doing_line_wrapping ())\n+                output_printf\n+                  (&buffer, \"In function `%s':\\n\",\n+                   (*decl_printable_name) (current_function_decl, 2));\n+              else\n+                notice (\"In function `%s':\\n\",\n+                        (*decl_printable_name) (current_function_decl, 2));\n+            }\n \t}\n \n       last_error_function = current_function_decl;\n+\n+      if (doing_line_wrapping ())\n+        dump_output (&buffer, stderr);\n+      \n+      free ((char *)prefix);\n     }\n }\n "}, {"sha": "11c72ae693a95e98eb85e5db03cc7f3a17824294", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b903d81e07581446e35d3ce129ab4d91dc5463b6/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=b903d81e07581446e35d3ce129ab4d91dc5463b6", "patch": "@@ -128,6 +128,7 @@ extern void fnotice\t\t\tPROTO ((FILE *, const char *, ...))\n extern int wrapup_global_declarations   PROTO ((union tree_node **, int));\n extern void check_global_declarations   PROTO ((union tree_node **, int));\n extern void note_deferral_of_defined_inline_function PROTO ((union tree_node *));\n+extern void set_message_length\t\tPROTO ((int));\n extern int errorcount;\n extern int warningcount;\n extern int sorrycount;"}]}