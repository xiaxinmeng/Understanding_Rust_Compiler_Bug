{"sha": "c856f5362741637da6fccdfc08f51a2890d5e39a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg1NmY1MzYyNzQxNjM3ZGE2ZmNjZGZjMDhmNTFhMjg5MGQ1ZTM5YQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-12-17T20:29:02Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-12-17T20:29:02Z"}, "message": "ia64.c: Add more comments about insn bundling.\n\n2003-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* config/ia64/ia64.c: Add more comments about insn bundling.\n\nFrom-SVN: r74751", "tree": {"sha": "bfe8c723dd2620f4ab6043899632019373b0650a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe8c723dd2620f4ab6043899632019373b0650a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c856f5362741637da6fccdfc08f51a2890d5e39a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c856f5362741637da6fccdfc08f51a2890d5e39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c856f5362741637da6fccdfc08f51a2890d5e39a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c856f5362741637da6fccdfc08f51a2890d5e39a/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d450e9ac8afcf340b62980a0a24c44f2c217092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d450e9ac8afcf340b62980a0a24c44f2c217092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d450e9ac8afcf340b62980a0a24c44f2c217092"}], "stats": {"total": 137, "additions": 121, "deletions": 16}, "files": [{"sha": "fb94d1f40e60b5c4057d0debc9f24315692dc3e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c856f5362741637da6fccdfc08f51a2890d5e39a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c856f5362741637da6fccdfc08f51a2890d5e39a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c856f5362741637da6fccdfc08f51a2890d5e39a", "patch": "@@ -1,3 +1,7 @@\n+2003-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c: Add more comments about insn bundling.\n+\n 2003-12-17  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR optimization/10592"}, {"sha": "beba14fe42907c8ca73274d028c31c6be543e2b0", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 117, "deletions": 16, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c856f5362741637da6fccdfc08f51a2890d5e39a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c856f5362741637da6fccdfc08f51a2890d5e39a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c856f5362741637da6fccdfc08f51a2890d5e39a", "patch": "@@ -6557,13 +6557,44 @@ get_next_important_insn (rtx insn, rtx tail)\n   return NULL_RTX;\n }\n \n-/* The following function does insn bundling.  Bundling algorithm is\n-   based on dynamic programming.  It tries to insert different number of\n-   nop insns before/after the real insns.  At the end of EBB, it chooses the\n-   best alternative and then, moving back in EBB, inserts templates for\n-   the best alternative.  The algorithm is directed by information\n-   (changes of simulated processor cycle) created by the 2nd insn\n-   scheduling.  */\n+/* The following function does insn bundling.  Bundling means\n+   inserting templates and nop insns to fit insn groups into permitted\n+   templates.  Instruction scheduling uses NDFA (non-deterministic\n+   finite automata) encoding informations about the templates and the\n+   inserted nops.  Nondeterminism of the automata permits follows\n+   all possible insn sequences very fast.\n+\n+   Unfortunately it is not possible to get information about inserting\n+   nop insns and used templates from the automata states.  The\n+   automata only says that we can issue an insn possibly inserting\n+   some nops before it and using some template.  Therefore insn\n+   bundling in this function is implemented by using DFA\n+   (deterministic finite automata).  We follows all possible insn\n+   sequences by inserting 0-2 nops (that is what the NDFA describe for\n+   insn scheduling) before/after each insn being bundled.  We know the\n+   start of simulated processor cycle from insn scheduling (insn\n+   starting a new cycle has TImode).\n+\n+   Simple implementation of insn bundling would create enormous\n+   number of possible insn sequences satisfying information about new\n+   cycle ticks taken from the insn scheduling.  To make the algorithm\n+   practical we use dynamic programming.  Each decision (about\n+   inserting nops and implicitly about previous decisions) is described\n+   by structure bundle_state (see above).  If we generate the same\n+   bundle state (key is automaton state after issuing the insns and\n+   nops for it), we reuse already generated one.  As consequence we\n+   reject some decisions which can not improve the solution and\n+   reduce memory for the algorithm.\n+\n+   When we reach the end of EBB (extended basic block), we choose the\n+   best sequence and then, moving back in EBB, insert templates for\n+   the best alternative.  The templates are taken from querying\n+   automaton state for each insn in chosen bundle states.\n+\n+   So the algorithm makes two (forward and backward) passes through\n+   EBB.  There is an additional forward pass through EBB for Itanium1\n+   processor.  This pass inserts more nops to make dependency between\n+   a producer insn and MMMUL/MMSHF at least 4 cycles long.  */\n \n static void\n bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n@@ -6578,6 +6609,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n   enum attr_type type;\n \n   insn_num = 0;\n+  /* Count insns in the EBB.  */\n   for (insn = NEXT_INSN (prev_head_insn);\n        insn && insn != tail;\n        insn = NEXT_INSN (insn))\n@@ -6590,7 +6622,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n   initiate_bundle_state_table ();\n   index_to_bundle_states = xmalloc ((insn_num + 2)\n \t\t\t\t    * sizeof (struct bundle_state *));\n-  /* First (forward) pass -- generates states. */\n+  /* First (forward) pass -- generation of bundle states. */\n   curr_state = get_free_bundle_state ();\n   curr_state->insn = NULL;\n   curr_state->before_nops_num = 0;\n@@ -6604,6 +6636,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n   state_reset (curr_state->dfa_state);\n   index_to_bundle_states [0] = curr_state;\n   insn_num = 0;\n+  /* Shift cycle mark if it is put on insn which could be ignored.  */\n   for (insn = NEXT_INSN (prev_head_insn);\n        insn != tail;\n        insn = NEXT_INSN (insn))\n@@ -6626,6 +6659,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t      break;\n \t    }\n       }\n+  /* Froward pass: generation of bundle states.  */\n   for (insn = get_next_important_insn (NEXT_INSN (prev_head_insn), tail);\n        insn != NULL_RTX;\n        insn = next_insn)\n@@ -6645,19 +6679,25 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t{\n \t  pos = curr_state->accumulated_insns_num % 3;\n \t  next_state = curr_state->next;\n-\t  /* Finish the current bundle in order to start a subsequent\n-\t     asm insn in a new bundle.  */\n+\t  /* We must fill up the current bundle in order to start a\n+\t     subsequent asm insn in a new bundle.  Asm insn is always\n+\t     placed in a separate bundle.  */\n \t  only_bundle_end_p\n \t    = (next_insn != NULL_RTX\n \t       && INSN_CODE (insn) == CODE_FOR_insn_group_barrier\n \t       && ia64_safe_type (next_insn) == TYPE_UNKNOWN);\n+\t  /* We may fill up the current bundle if it is the cycle end\n+\t     without a group barrier.  */\n \t  bundle_end_p\n \t    = (only_bundle_end_p || next_insn == NULL_RTX\n \t       || (GET_MODE (next_insn) == TImode\n \t\t   && INSN_CODE (insn) != CODE_FOR_insn_group_barrier));\n \t  if (type == TYPE_F || type == TYPE_B || type == TYPE_L\n \t      || type == TYPE_S\n-\t      /* We need to insert 2 Nops for cases like M_MII.  */\n+\t      /* We need to insert 2 nops for cases like M_MII.  To\n+\t\t guarantee issuing all insns on the same cycle for\n+\t\t Itanium 1, we need to issue 2 nops after the first M\n+\t\t insn (MnnMII where n is a nop insn).  */\n \t      || (type == TYPE_M && ia64_tune == PROCESSOR_ITANIUM\n \t\t  && !bundle_end_p && pos == 1))\n \t    issue_nops_and_insn (curr_state, 2, insn, bundle_end_p,\n@@ -6674,6 +6714,10 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t   curr_state = curr_state->next)\n \tif (verbose >= 2 && dump)\n \t  {\n+\t    /* This structure is taken from generated code of the\n+\t       pipeline hazard recognizer (see file insn-attrtab.c).\n+\t       Please don't forget to change the structure if a new\n+\t       automaton is added to .md file.  */\n \t    struct DFA_chip\n \t    {\n \t      unsigned short one_automaton_state;\n@@ -6698,12 +6742,18 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t  }\n     }\n   if (index_to_bundle_states [insn_num] == NULL)\n+    /* We should find a solution because the 2nd insn scheduling has\n+       found one.  */\n     abort ();\n-  /* Finding state with a minimal cost:  */\n+  /* Find a state corresponding to the best insn sequence.  */\n   best_state = NULL;\n   for (curr_state = index_to_bundle_states [insn_num];\n        curr_state != NULL;\n        curr_state = curr_state->next)\n+    /* We are just looking at the states with fully filled up last\n+       bundle.  The first we prefer insn sequences with minimal cost\n+       then with minimal inserted nops and finally with branch insns\n+       placed in the 3rd slots.  */\n     if (curr_state->accumulated_insns_num % 3 == 0\n \t&& (best_state == NULL || best_state->cost > curr_state->cost\n \t    || (best_state->cost == curr_state->cost\n@@ -6714,7 +6764,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t\t\t&& curr_state->branch_deviation\n \t\t\t< best_state->branch_deviation)))))\n       best_state = curr_state;\n-  /* Second (backward) pass: adding nops and templates:  */\n+  /* Second (backward) pass: adding nops and templates.  */\n   insn_num = best_state->before_nops_num;\n   template0 = template1 = -1;\n   for (curr_state = best_state;\n@@ -6749,9 +6799,17 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t      : ((struct DFA_chip *) curr_state->dfa_state)->twob_automaton_state),\n \t     INSN_UID (insn));\n \t}\n+      /* Find the position in the current bundle window.  The window can\n+\t contain at most two bundles.  Two bundle window means that\n+\t the processor will make two bundle rotation.  */\n       max_pos = get_max_pos (curr_state->dfa_state);\n-      if (max_pos == 6 || (max_pos == 3 && template0 < 0))\n+      if (max_pos == 6\n+\t  /* The following (negative template number) means that the\n+\t     processor did one bundle rotation.  */\n+\t  || (max_pos == 3 && template0 < 0))\n \t{\n+\t  /* We are at the end of the window -- find template(s) for\n+\t     its bundle(s).  */\n \t  pos = max_pos;\n \t  if (max_pos == 3)\n \t    template0 = get_template (curr_state->dfa_state, 3);\n@@ -6762,13 +6820,15 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t    }\n \t}\n       if (max_pos > 3 && template1 < 0)\n+\t/* It may happen when we have the stop inside a bundle.  */\n \t{\n \t  if (pos > 3)\n \t    abort ();\n \t  template1 = get_template (curr_state->dfa_state, 3);\n \t  pos += 3;\n \t}\n       if (!asm_p)\n+\t/* Emit nops after the current insn.  */\n \tfor (i = 0; i < curr_state->after_nops_num; i++)\n \t  {\n \t    nop = gen_nop ();\n@@ -6778,18 +6838,26 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t      abort ();\n \t    if (pos % 3 == 0)\n \t      {\n+\t\t/* We are at the start of a bundle: emit the template\n+\t\t   (it should be defined).  */\n \t\tif (template0 < 0)\n \t\t  abort ();\n \t\tb = gen_bundle_selector (GEN_INT (template0));\n \t\tia64_emit_insn_before (b, nop);\n+\t\t/* If we have two bundle window, we make one bundle\n+\t\t   rotation.  Otherwise template0 will be undefined\n+\t\t   (negative value).  */\n \t\ttemplate0 = template1;\n \t\ttemplate1 = -1;\n \t      }\n \t  }\n+      /* Move the position backward in the window.  Group barrier has\n+\t no slot.  Asm insn takes all bundle.  */\n       if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier\n \t  && GET_CODE (PATTERN (insn)) != ASM_INPUT\n \t  && asm_noperands (PATTERN (insn)) < 0)\n \tpos--;\n+      /* Long insn takes 2 slots.  */\n       if (ia64_safe_type (insn) == TYPE_L)\n \tpos--;\n       if (pos < 0)\n@@ -6799,15 +6867,20 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t  && GET_CODE (PATTERN (insn)) != ASM_INPUT\n \t  && asm_noperands (PATTERN (insn)) < 0)\n \t{\n+\t  /* The current insn is at the bundle start: emit the\n+\t     template.  */\n \t  if (template0 < 0)\n \t    abort ();\n \t  b = gen_bundle_selector (GEN_INT (template0));\n \t  ia64_emit_insn_before (b, insn);\n \t  b = PREV_INSN (insn);\n \t  insn = b;\n+\t  /* See comment above in analogous place for emiting nops\n+\t     after the insn.  */\n \t  template0 = template1;\n \t  template1 = -1;\n \t}\n+      /* Emit nops after the current insn.  */\n       for (i = 0; i < curr_state->before_nops_num; i++)\n \t{\n \t  nop = gen_nop ();\n@@ -6819,6 +6892,8 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t    abort ();\n \t  if (pos % 3 == 0)\n \t    {\n+\t      /* See comment above in analogous place for emiting nops\n+\t\t after the insn.  */\n \t      if (template0 < 0)\n \t\tabort ();\n \t      b = gen_bundle_selector (GEN_INT (template0));\n@@ -6831,7 +6906,11 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t}\n     }\n   if (ia64_tune == PROCESSOR_ITANIUM)\n-    /* Insert additional cycles for MM-insns: */\n+    /* Insert additional cycles for MM-insns (MMMUL and MMSHF).\n+       Itanium1 has a strange design, if the distance between an insn\n+       and dependent MM-insn is less 4 then we have a 6 additional\n+       cycles stall.  So we make the distance equal to 4 cycles if it\n+       is less.  */\n     for (insn = get_next_important_insn (NEXT_INSN (prev_head_insn), tail);\n \t insn != NULL_RTX;\n \t insn = next_insn)\n@@ -6843,11 +6922,16 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t  abort ();\n \tnext_insn = get_next_important_insn (NEXT_INSN (insn), tail);\n \tif (INSN_UID (insn) < clocks_length && add_cycles [INSN_UID (insn)])\n+\t  /* We found a MM-insn which needs additional cycles.  */\n \t  {\n \t    rtx last;\n \t    int i, j, n;\n \t    int pred_stop_p;\n \n+\t    /* Now we are searching for a template of the bundle in\n+\t       which the MM-insn is placed and the position of the\n+\t       insn in the bundle (0, 1, 2).  Also we are searching\n+\t       for that there is a stop before the insn.  */\n \t    last = prev_active_insn (insn);\n \t    pred_stop_p = recog_memoized (last) == CODE_FOR_insn_group_barrier;\n \t    if (pred_stop_p)\n@@ -6858,17 +6942,27 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t\t{\n \t\t  template0 = XINT (XVECEXP (PATTERN (last), 0, 0), 0);\n \t\t  if (template0 == 9)\n+\t\t    /* The insn is in MLX bundle.  Change the template\n+\t\t       onto MFI because we will add nops before the\n+\t\t       insn.  It simplifies subsequent code a lot.  */\n \t\t    PATTERN (last)\n \t\t      = gen_bundle_selector (GEN_INT (2)); /* -> MFI */\n \t\t  break;\n \t\t}\n \t      else if (recog_memoized (last) != CODE_FOR_insn_group_barrier)\n \t\tn++;\n+\t    /* Some check of correctness: the stop is not at the\n+\t       bundle start, there are no more 3 insns in the bundle,\n+\t       and the MM-insn is not at the start of bundle with\n+\t       template MLX.  */\n \t    if ((pred_stop_p && n == 0) || n > 2\n \t\t|| (template0 == 9 && n != 0))\n \t      abort ();\n+\t    /* Put nops after the insn in the bundle.  */\n \t    for (j = 3 - n; j > 0; j --)\n \t      ia64_emit_insn_before (gen_nop (), insn);\n+\t    /* It takes into account that we will add more N nops\n+\t       before the insn lately -- please see code below.  */\n \t    add_cycles [INSN_UID (insn)]--;\n \t    if (!pred_stop_p || add_cycles [INSN_UID (insn)])\n \t      ia64_emit_insn_before (gen_insn_group_barrier (GEN_INT (3)),\n@@ -6877,13 +6971,15 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t      add_cycles [INSN_UID (insn)]--;\n \t    for (i = add_cycles [INSN_UID (insn)]; i > 0; i--)\n \t      {\n-\t\t/* Insert .MII bundle.  */\n+\t\t/* Insert \"MII;\" template.  */\n \t\tia64_emit_insn_before (gen_bundle_selector (GEN_INT (0)),\n \t\t\t\t       insn);\n \t\tia64_emit_insn_before (gen_nop (), insn);\n \t\tia64_emit_insn_before (gen_nop (), insn);\n \t\tif (i > 1)\n \t\t  {\n+\t\t    /* To decrease code size, we use \"MI;I;\"\n+\t\t       template.  */\n \t\t    ia64_emit_insn_before\n \t\t      (gen_insn_group_barrier (GEN_INT (3)), insn);\n \t\t    i--;\n@@ -6892,10 +6988,15 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t\tia64_emit_insn_before (gen_insn_group_barrier (GEN_INT (3)),\n \t\t\t\t       insn);\n \t      }\n+\t    /* Put the MM-insn in the same slot of a bundle with the\n+\t       same template as the original one.  */\n \t    ia64_emit_insn_before (gen_bundle_selector (GEN_INT (template0)),\n \t\t\t\t   insn);\n+\t    /* To put the insn in the same slot, add necessary number\n+\t       of nops.  */\n \t    for (j = n; j > 0; j --)\n \t      ia64_emit_insn_before (gen_nop (), insn);\n+\t    /* Put the stop if the original bundle had it.  */\n \t    if (pred_stop_p)\n \t      ia64_emit_insn_before (gen_insn_group_barrier (GEN_INT (3)),\n \t\t\t\t     insn);"}]}