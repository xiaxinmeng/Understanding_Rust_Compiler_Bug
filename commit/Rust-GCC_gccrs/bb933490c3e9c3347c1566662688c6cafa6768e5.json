{"sha": "bb933490c3e9c3347c1566662688c6cafa6768e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5MzM0OTBjM2U5YzMzNDdjMTU2NjY2MjY4OGM2Y2FmYTY3NjhlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:21:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:21:59Z"}, "message": "Makefile.in (build/read-md.o): Depend on errors.h.\n\ngcc/\n\t* Makefile.in (build/read-md.o): Depend on errors.h.\n\t* read-md.h (error_with_line): Declare.\n\t* read-md.c: Include errors.h.\n\t(message_with_line_1): New function, extracted from...\n\t(message_with_line): ...here.\n\t(error_with_line): New function.\n\t* genattrtab.c: If a call to message_with_line is followed by\n\t\"have_error = 1;\", replace both statements with a call to\n\terror_with_line.\n\t* genoutput.c: Likewise.\n\t* genpreds.c: Likewise.\n\t* genrecog.c: If a call to message_with_line is followed by\n\t\"error_count++;\", replace both statements with a call to\n\terror_with_line.\n\t(errorcount): Delete.\n\t(main): Don't check it.\n\t* gensupport.c: If a call to message_with_line is followed by\n\t\"errors = 1;\", replace both statements with a call to error_with_line.\n\t(errors): Delete.\n\t(process_define_cond_exec): Check have_error instead of errors.\n\t(init_md_reader_args_cb): Likewise.  Don't set errors.\n\nFrom-SVN: r160573", "tree": {"sha": "2e3c136c636393db4c15e2660800e0141d0d6d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3c136c636393db4c15e2660800e0141d0d6d70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb933490c3e9c3347c1566662688c6cafa6768e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb933490c3e9c3347c1566662688c6cafa6768e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb933490c3e9c3347c1566662688c6cafa6768e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb933490c3e9c3347c1566662688c6cafa6768e5/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9"}], "stats": {"total": 512, "additions": 219, "deletions": 293}, "files": [{"sha": "698371543ba0699a975692e89b7ce25022990850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -1,3 +1,27 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (build/read-md.o): Depend on errors.h.\n+\t* read-md.h (error_with_line): Declare.\n+\t* read-md.c: Include errors.h.\n+\t(message_with_line_1): New function, extracted from...\n+\t(message_with_line): ...here.\n+\t(error_with_line): New function.\n+\t* genattrtab.c: If a call to message_with_line is followed by\n+\t\"have_error = 1;\", replace both statements with a call to\n+\terror_with_line.\n+\t* genoutput.c: Likewise.\n+\t* genpreds.c: Likewise.\n+\t* genrecog.c: If a call to message_with_line is followed by\n+\t\"error_count++;\", replace both statements with a call to\n+\terror_with_line.\n+\t(errorcount): Delete.\n+\t(main): Don't check it.\n+\t* gensupport.c: If a call to message_with_line is followed by\n+\t\"errors = 1;\", replace both statements with a call to error_with_line.\n+\t(errors): Delete.\n+\t(process_define_cond_exec): Check have_error instead of errors.\n+\t(init_md_reader_args_cb): Likewise.  Don't set errors.\n+\n 2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* read-md.h (read_md_file): Declare."}, {"sha": "f3a354caaf1d6d61afa9aae5acb5947f1ce99429", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -3775,7 +3775,7 @@ build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n build/print-rtl.o: print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H)\n build/read-md.o: read-md.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n-  $(HASHTAB_H) $(READ_MD_H)\n+  $(HASHTAB_H) errors.h $(READ_MD_H)\n build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) $(READ_MD_H)\t\t\\\n   gensupport.h"}, {"sha": "545cd8ebce0d1b1300042fc4f28120687e8fdd7e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 44, "deletions": 74, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -886,19 +886,17 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case CONST_INT:\n       if (attr && ! attr->is_numeric)\n \t{\n-\t  message_with_line (attr->lineno,\n-\t\t\t     \"CONST_INT not valid for non-numeric attribute %s\",\n-\t\t\t     attr->name);\n-\t  have_error = 1;\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"CONST_INT not valid for non-numeric attribute %s\",\n+\t\t\t   attr->name);\n \t  break;\n \t}\n \n       if (INTVAL (exp) < 0)\n \t{\n-\t  message_with_line (attr->lineno,\n-\t\t\t     \"negative numeric value specified for attribute %s\",\n-\t\t\t     attr->name);\n-\t  have_error = 1;\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"negative numeric value specified for attribute %s\",\n+\t\t\t   attr->name);\n \t  break;\n \t}\n       break;\n@@ -913,10 +911,9 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \t  for (; *p; p++)\n \t    if (! ISDIGIT (*p))\n \t      {\n-\t\tmessage_with_line (attr ? attr->lineno : 0,\n-\t\t\t\t   \"non-numeric value for numeric attribute %s\",\n-\t\t\t\t   attr ? attr->name : \"internal\");\n-\t\thave_error = 1;\n+\t\terror_with_line (attr ? attr->lineno : 0,\n+\t\t\t\t \"non-numeric value for numeric attribute %s\",\n+\t\t\t\t attr ? attr->name : \"internal\");\n \t\tbreak;\n \t      }\n \t  break;\n@@ -928,12 +925,9 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \t  break;\n \n       if (av == NULL)\n-\t{\n-\t  message_with_line (attr->lineno,\n-\t\t\t     \"unknown value `%s' for `%s' attribute\",\n-\t\t\t     XSTR (exp, 0), attr ? attr->name : \"internal\");\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (attr->lineno,\n+\t\t\t \"unknown value `%s' for `%s' attribute\",\n+\t\t\t XSTR (exp, 0), attr ? attr->name : \"internal\");\n       break;\n \n     case IF_THEN_ELSE:\n@@ -951,10 +945,9 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case MOD:\n       if (attr && !attr->is_numeric)\n \t{\n-\t  message_with_line (attr->lineno,\n-\t\t\t     \"invalid operation `%s' for non-numeric attribute value\",\n-\t\t\t     GET_RTX_NAME (GET_CODE (exp)));\n-\t  have_error = 1;\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"invalid operation `%s' for non-numeric\"\n+\t\t\t   \" attribute value\", GET_RTX_NAME (GET_CODE (exp)));\n \t  break;\n \t}\n       /* Fall through.  */\n@@ -977,9 +970,8 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n     case COND:\n       if (XVECLEN (exp, 0) % 2 != 0)\n \t{\n-\t  message_with_line (attr->lineno,\n-\t\t\t     \"first operand of COND must have even length\");\n-\t  have_error = 1;\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"first operand of COND must have even length\");\n \t  break;\n \t}\n \n@@ -999,27 +991,18 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n       {\n \tstruct attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n-\t  {\n-\t    message_with_line (attr ? attr->lineno : 0,\n-\t\t\t       \"unknown attribute `%s' in ATTR\",\n-\t\t\t       XSTR (exp, 0));\n-\t    have_error = 1;\n-\t  }\n+\t  error_with_line (attr ? attr->lineno : 0,\n+\t\t\t   \"unknown attribute `%s' in ATTR\",\n+\t\t\t   XSTR (exp, 0));\n \telse if (attr && attr->is_const && ! attr2->is_const)\n-\t  {\n-\t    message_with_line (attr->lineno,\n-\t\t\"non-constant attribute `%s' referenced from `%s'\",\n-\t\tXSTR (exp, 0), attr->name);\n-\t    have_error = 1;\n-\t  }\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"non-constant attribute `%s' referenced from `%s'\",\n+\t\t\t   XSTR (exp, 0), attr->name);\n \telse if (attr\n \t\t && attr->is_numeric != attr2->is_numeric)\n-\t  {\n-\t    message_with_line (attr->lineno,\n-\t\t\"numeric attribute mismatch calling `%s' from `%s'\",\n-\t\tXSTR (exp, 0), attr->name);\n-\t    have_error = 1;\n-\t  }\n+\t  error_with_line (attr->lineno,\n+\t\t\t   \"numeric attribute mismatch calling `%s' from `%s'\",\n+\t\t\t   XSTR (exp, 0), attr->name);\n       }\n       break;\n \n@@ -1030,10 +1013,9 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n       return attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n \n     default:\n-      message_with_line (attr ? attr->lineno : 0,\n-\t\t\t \"invalid operation `%s' for attribute value\",\n-\t\t\t GET_RTX_NAME (GET_CODE (exp)));\n-      have_error = 1;\n+      error_with_line (attr ? attr->lineno : 0,\n+\t\t       \"invalid operation `%s' for attribute value\",\n+\t\t       GET_RTX_NAME (GET_CODE (exp)));\n       break;\n     }\n \n@@ -1052,9 +1034,8 @@ convert_set_attr_alternative (rtx exp, struct insn_def *id)\n \n   if (XVECLEN (exp, 1) != num_alt)\n     {\n-      message_with_line (id->lineno,\n-\t\t\t \"bad number of entries in SET_ATTR_ALTERNATIVE\");\n-      have_error = 1;\n+      error_with_line (id->lineno,\n+\t\t       \"bad number of entries in SET_ATTR_ALTERNATIVE\");\n       return NULL_RTX;\n     }\n \n@@ -1133,8 +1114,7 @@ check_defs (void)\n \t    case SET:\n \t      if (GET_CODE (XEXP (value, 0)) != ATTR)\n \t\t{\n-\t\t  message_with_line (id->lineno, \"bad attribute set\");\n-\t\t  have_error = 1;\n+\t\t  error_with_line (id->lineno, \"bad attribute set\");\n \t\t  value = NULL_RTX;\n \t\t}\n \t      break;\n@@ -1148,19 +1128,17 @@ check_defs (void)\n \t      break;\n \n \t    default:\n-\t      message_with_line (id->lineno, \"invalid attribute code %s\",\n-\t\t\t\t GET_RTX_NAME (GET_CODE (value)));\n-\t      have_error = 1;\n+\t      error_with_line (id->lineno, \"invalid attribute code %s\",\n+\t\t\t       GET_RTX_NAME (GET_CODE (value)));\n \t      value = NULL_RTX;\n \t    }\n \t  if (value == NULL_RTX)\n \t    continue;\n \n \t  if ((attr = find_attr (&XSTR (XEXP (value, 0), 0), 0)) == NULL)\n \t    {\n-\t      message_with_line (id->lineno, \"unknown attribute %s\",\n-\t\t\t\t XSTR (XEXP (value, 0), 0));\n-\t      have_error = 1;\n+\t      error_with_line (id->lineno, \"unknown attribute %s\",\n+\t\t\t       XSTR (XEXP (value, 0), 0));\n \t      continue;\n \t    }\n \n@@ -2937,10 +2915,9 @@ gen_attr (rtx exp, int lineno)\n   attr = find_attr (&XSTR (exp, 0), 1);\n   if (attr->default_val)\n     {\n-      message_with_line (lineno, \"duplicate definition for attribute %s\",\n-\t\t\t attr->name);\n+      error_with_line (lineno, \"duplicate definition for attribute %s\",\n+\t\t       attr->name);\n       message_with_line (attr->lineno, \"previous definition\");\n-      have_error = 1;\n       return;\n     }\n   attr->lineno = lineno;\n@@ -2966,22 +2943,15 @@ gen_attr (rtx exp, int lineno)\n     {\n       attr->is_const = 1;\n       if (attr->is_numeric)\n-\t{\n-\t  message_with_line (lineno,\n-\t\t\t     \"constant attributes may not take numeric values\");\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (lineno,\n+\t\t\t \"constant attributes may not take numeric values\");\n \n       /* Get rid of the CONST node.  It is allowed only at top-level.  */\n       XEXP (exp, 2) = XEXP (XEXP (exp, 2), 0);\n     }\n \n   if (! strcmp_check (attr->name, length_str) && ! attr->is_numeric)\n-    {\n-      message_with_line (lineno,\n-\t\t\t \"`length' attribute must take numeric values\");\n-      have_error = 1;\n-    }\n+    error_with_line (lineno, \"`length' attribute must take numeric values\");\n \n   /* Set up the default value.  */\n   XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n@@ -3115,9 +3085,9 @@ gen_delay (rtx def, int lineno)\n \n   if (XVECLEN (def, 1) % 3 != 0)\n     {\n-      message_with_line (lineno,\n-\t\t\t \"number of elements in DEFINE_DELAY must be multiple of three\");\n-      have_error = 1;\n+      error_with_line (lineno,\n+\t\t       \"number of elements in DEFINE_DELAY must\"\n+\t\t       \" be multiple of three\");\n       return;\n     }\n "}, {"sha": "c3ce33db65b4e157f197596030c92b6b8fb2fbc0", "filename": "gcc/genoutput.c", "status": "modified", "additions": 35, "deletions": 66, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -446,17 +446,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"maximum number of operands exceeded\");\n-\t  have_error = 1;\n+\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"repeated operand number %d\\n\", opno);\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -475,17 +469,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"maximum number of operands exceeded\");\n-\t  have_error = 1;\n+\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"repeated operand number %d\\n\", opno);\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -505,17 +493,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"maximum number of operands exceeded\");\n-\t  have_error = 1;\n+\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"repeated operand number %d\\n\", opno);\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -717,11 +699,8 @@ process_template (struct data *d, const char *template_code)\n \tmessage_with_line (d->lineno,\n \t\t\t   \"'@' is redundant for output template with single alternative\");\n       if (i != d->n_alternatives)\n-\t{\n-\t  message_with_line (d->lineno,\n-\t\t\t     \"wrong number of alternatives in the output template\");\n-\t  have_error = 1;\n-\t}\n+\terror_with_line (d->lineno,\n+\t\t\t \"wrong number of alternatives in the output template\");\n \n       printf (\"};\\n\");\n     }\n@@ -770,11 +749,11 @@ validate_insn_alternatives (struct data *d)\n \n \t    if (len < 1 || (len > 1 && strchr (\",#*+=&%!0123456789\", c)))\n \t      {\n-\t\tmessage_with_line (d->lineno,\n-\t\t\t\t   \"invalid length %d for char '%c' in alternative %d of operand %d\",\n-\t\t\t\t    len, c, which_alternative, start);\n+\t\terror_with_line (d->lineno,\n+\t\t\t\t \"invalid length %d for char '%c' in\"\n+\t\t\t\t \" alternative %d of operand %d\",\n+\t\t\t\t len, c, which_alternative, start);\n \t\tlen = 1;\n-\t\thave_error = 1;\n \t      }\n #endif\n \n@@ -787,30 +766,28 @@ validate_insn_alternatives (struct data *d)\n \t    for (i = 1; i < len; i++)\n \t      if (p[i] == '\\0')\n \t\t{\n-\t\t  message_with_line (d->lineno,\n-\t\t\t\t     \"NUL in alternative %d of operand %d\",\n-\t\t\t\t     which_alternative, start);\n+\t\t  error_with_line (d->lineno,\n+\t\t\t\t   \"NUL in alternative %d of operand %d\",\n+\t\t\t\t   which_alternative, start);\n \t\t  alternative_count_unsure = 1;\n \t\t  break;\n \t\t}\n \t      else if (strchr (\",#*\", p[i]))\n \t\t{\n-\t\t  message_with_line (d->lineno,\n-\t\t\t\t     \"'%c' in alternative %d of operand %d\",\n-\t\t\t\t     p[i], which_alternative, start);\n+\t\t  error_with_line (d->lineno,\n+\t\t\t\t   \"'%c' in alternative %d of operand %d\",\n+\t\t\t\t   p[i], which_alternative, start);\n \t\t  alternative_count_unsure = 1;\n \t\t}\n \t  }\n-\tif (alternative_count_unsure)\n-\t  have_error = 1;\n-\telse if (n == 0)\n-\t  n = d->operand[start].n_alternatives;\n-\telse if (n != d->operand[start].n_alternatives)\n+\tif (!alternative_count_unsure)\n \t  {\n-\t    message_with_line (d->lineno,\n+\t    if (n == 0)\n+\t      n = d->operand[start].n_alternatives;\n+\t    else if (n != d->operand[start].n_alternatives)\n+\t      error_with_line (d->lineno,\n \t\t\t       \"wrong number of alternatives in operand %d\",\n \t\t\t       start);\n-\t    have_error = 1;\n \t  }\n       }\n \n@@ -827,10 +804,7 @@ validate_insn_operands (struct data *d)\n \n   for (i = 0; i < d->n_operands; ++i)\n     if (d->operand[i].seen == 0)\n-      {\n-\tmessage_with_line (d->lineno, \"missing operand %d\", i);\n-\thave_error = 1;\n-      }\n+      error_with_line (d->lineno, \"missing operand %d\", i);\n }\n \n static void\n@@ -1148,13 +1122,12 @@ note_constraint (rtx exp, int lineno)\n   if (strchr (indep_constraints, name[0]) && name[0] != 'm')\n     {\n       if (name[1] == '\\0')\n-\tmessage_with_line (lineno, \"constraint letter '%s' cannot be \"\n-\t\t\t   \"redefined by the machine description\", name);\n+\terror_with_line (lineno, \"constraint letter '%s' cannot be \"\n+\t\t\t \"redefined by the machine description\", name);\n       else\n-\tmessage_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n-\t\t\t   \"the machine description, as it begins with '%c'\",\n-\t\t\t   name, name[0]);\n-      have_error = 1;\n+\terror_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n+\t\t\t \"the machine description, as it begins with '%c'\",\n+\t\t\t name, name[0]);\n       return;\n     }\n \n@@ -1171,25 +1144,22 @@ note_constraint (rtx exp, int lineno)\n \n       if (!strcmp ((*iter)->name, name))\n \t{\n-\t  message_with_line (lineno, \"redefinition of constraint '%s'\", name);\n+\t  error_with_line (lineno, \"redefinition of constraint '%s'\", name);\n \t  message_with_line ((*iter)->lineno, \"previous definition is here\");\n-\t  have_error = 1;\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n \t{\n-\t  message_with_line (lineno, \"defining constraint '%s' here\", name);\n+\t  error_with_line (lineno, \"defining constraint '%s' here\", name);\n \t  message_with_line ((*iter)->lineno, \"renders constraint '%s' \"\n \t\t\t     \"(defined here) a prefix\", (*iter)->name);\n-\t  have_error = 1;\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, namelen))\n \t{\n-\t  message_with_line (lineno, \"constraint '%s' is a prefix\", name);\n+\t  error_with_line (lineno, \"constraint '%s' is a prefix\", name);\n \t  message_with_line ((*iter)->lineno, \"of constraint '%s' \"\n \t\t\t     \"(defined here)\", (*iter)->name);\n-\t  have_error = 1;\n \t  return;\n \t}\n     }\n@@ -1217,11 +1187,10 @@ mdep_constraint_len (const char *s, int lineno, int opno)\n       if (!strncmp (s, p->name, p->namelen))\n \treturn p->namelen;\n \n-  message_with_line (lineno,\n-\t\t     \"error: undefined machine-specific constraint \"\n-\t\t     \"at this point: \\\"%s\\\"\", s);\n+  error_with_line (lineno,\n+\t\t   \"error: undefined machine-specific constraint \"\n+\t\t   \"at this point: \\\"%s\\\"\", s);\n   message_with_line (lineno, \"note:  in operand %d\", opno);\n-  have_error = 1;\n   return 1; /* safe */\n }\n "}, {"sha": "cd53845735320332baa62e0fa5d7571e5afdbda8", "filename": "gcc/genpreds.c", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -67,9 +67,8 @@ validate_exp (rtx exp, const char *name, int lineno)\n \t  {\n \t    if (!ISDIGIT (*p) && !ISLOWER (*p))\n \t      {\n-\t\tmessage_with_line (lineno, \"%s: invalid character in path \"\n-\t\t\t\t   \"string '%s'\", name, XSTR (exp, 1));\n-\t\thave_error = 1;\n+\t\terror_with_line (lineno, \"%s: invalid character in path \"\n+\t\t\t\t \"string '%s'\", name, XSTR (exp, 1));\n \t\treturn true;\n \t      }\n \t  }\n@@ -82,10 +81,9 @@ validate_exp (rtx exp, const char *name, int lineno)\n       return false;\n \n     default:\n-      message_with_line (lineno,\n-\t\t\t \"%s: cannot use '%s' in a predicate expression\",\n-\t\t\t name, GET_RTX_NAME (GET_CODE (exp)));\n-      have_error = 1;\n+      error_with_line (lineno,\n+\t\t       \"%s: cannot use '%s' in a predicate expression\",\n+\t\t       name, GET_RTX_NAME (GET_CODE (exp)));\n       return true;\n     }\n }\n@@ -119,10 +117,9 @@ process_define_predicate (rtx defn, int lineno)\n   return;\n \n  bad_name:\n-  message_with_line (lineno,\n-\t\t     \"%s: predicate name must be a valid C function name\",\n-\t\t     XSTR (defn, 0));\n-  have_error = 1;\n+  error_with_line (lineno,\n+\t\t   \"%s: predicate name must be a valid C function name\",\n+\t\t   XSTR (defn, 0));\n   return;\n }\n \n@@ -765,12 +762,11 @@ add_constraint (const char *name, const char *regclass,\n   if (!ISALPHA (name[0]) && name[0] != '_')\n     {\n       if (name[1] == '\\0')\n-\tmessage_with_line (lineno, \"constraint name '%s' is not \"\n-\t\t\t   \"a letter or underscore\", name);\n+\terror_with_line (lineno, \"constraint name '%s' is not \"\n+\t\t\t \"a letter or underscore\", name);\n       else\n-\tmessage_with_line (lineno, \"constraint name '%s' does not begin \"\n-\t\t\t   \"with a letter or underscore\", name);\n-      have_error = 1;\n+\terror_with_line (lineno, \"constraint name '%s' does not begin \"\n+\t\t\t \"with a letter or underscore\", name);\n       return;\n     }\n   for (p = name; *p; p++)\n@@ -780,25 +776,23 @@ add_constraint (const char *name, const char *regclass,\n \t  need_mangled_name = true;\n \telse\n \t  {\n-\t    message_with_line (lineno,\n-\t\t\t       \"constraint name '%s' must be composed of \"\n-\t\t\t       \"letters, digits, underscores, and \"\n-\t\t\t       \"angle brackets\", name);\n-\t    have_error = 1;\n+\t    error_with_line (lineno,\n+\t\t\t     \"constraint name '%s' must be composed of \"\n+\t\t\t     \"letters, digits, underscores, and \"\n+\t\t\t     \"angle brackets\", name);\n \t    return;\n \t  }\n       }\n \n   if (strchr (generic_constraint_letters, name[0]))\n     {\n       if (name[1] == '\\0')\n-\tmessage_with_line (lineno, \"constraint letter '%s' cannot be \"\n-\t\t\t   \"redefined by the machine description\", name);\n+\terror_with_line (lineno, \"constraint letter '%s' cannot be \"\n+\t\t\t \"redefined by the machine description\", name);\n       else\n-\tmessage_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n-\t\t\t   \"the machine description, as it begins with '%c'\",\n-\t\t\t   name, name[0]);\n-      have_error = 1;\n+\terror_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n+\t\t\t \"the machine description, as it begins with '%c'\",\n+\t\t\t name, name[0]);\n       return;\n     }\n \n@@ -817,25 +811,22 @@ add_constraint (const char *name, const char *regclass,\n \n       if (!strcmp ((*iter)->name, name))\n \t{\n-\t  message_with_line (lineno, \"redefinition of constraint '%s'\", name);\n+\t  error_with_line (lineno, \"redefinition of constraint '%s'\", name);\n \t  message_with_line ((*iter)->lineno, \"previous definition is here\");\n-\t  have_error = 1;\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n \t{\n-\t  message_with_line (lineno, \"defining constraint '%s' here\", name);\n+\t  error_with_line (lineno, \"defining constraint '%s' here\", name);\n \t  message_with_line ((*iter)->lineno, \"renders constraint '%s' \"\n \t\t\t     \"(defined here) a prefix\", (*iter)->name);\n-\t  have_error = 1;\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, namelen))\n \t{\n-\t  message_with_line (lineno, \"constraint '%s' is a prefix\", name);\n+\t  error_with_line (lineno, \"constraint '%s' is a prefix\", name);\n \t  message_with_line ((*iter)->lineno, \"of constraint '%s' \"\n \t\t\t     \"(defined here)\", (*iter)->name);\n-\t  have_error = 1;\n \t  return;\n \t}\n     }\n@@ -856,43 +847,36 @@ add_constraint (const char *name, const char *regclass,\n \t\t     GET_RTX_NAME (appropriate_code)))\n \t{\n \t  if (name[1] == '\\0')\n-\t    message_with_line (lineno, \"constraint letter '%c' is reserved \"\n-\t\t\t       \"for %s constraints\",\n-\t\t\t       name[0], GET_RTX_NAME (appropriate_code));\n+\t    error_with_line (lineno, \"constraint letter '%c' is reserved \"\n+\t\t\t     \"for %s constraints\",\n+\t\t\t     name[0], GET_RTX_NAME (appropriate_code));\n \t  else\n-\t    message_with_line (lineno, \"constraint names beginning with '%c' \"\n-\t\t\t       \"(%s) are reserved for %s constraints\",\n-\t\t\t       name[0], name,\n-\t\t\t       GET_RTX_NAME (appropriate_code));\n-\n-\t  have_error = 1;\n+\t    error_with_line (lineno, \"constraint names beginning with '%c' \"\n+\t\t\t     \"(%s) are reserved for %s constraints\",\n+\t\t\t     name[0], name, GET_RTX_NAME (appropriate_code));\n \t  return;\n \t}\n \n       if (is_memory)\n \t{\n \t  if (name[1] == '\\0')\n-\t    message_with_line (lineno, \"constraint letter '%c' cannot be a \"\n-\t\t\t       \"memory constraint\", name[0]);\n+\t    error_with_line (lineno, \"constraint letter '%c' cannot be a \"\n+\t\t\t     \"memory constraint\", name[0]);\n \t  else\n-\t    message_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n-\t\t\t       \"and therefore cannot be a memory constraint\",\n-\t\t\t       name, name[0]);\n-\n-\t  have_error = 1;\n+\t    error_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n+\t\t\t     \"and therefore cannot be a memory constraint\",\n+\t\t\t     name, name[0]);\n \t  return;\n \t}\n       else if (is_address)\n \t{\n \t  if (name[1] == '\\0')\n-\t    message_with_line (lineno, \"constraint letter '%c' cannot be a \"\n-\t\t\t       \"memory constraint\", name[0]);\n+\t    error_with_line (lineno, \"constraint letter '%c' cannot be a \"\n+\t\t\t     \"memory constraint\", name[0]);\n \t  else\n-\t    message_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n-\t\t\t       \"and therefore cannot be a memory constraint\",\n-\t\t\t       name, name[0]);\n-\n-\t  have_error = 1;\n+\t    error_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n+\t\t\t     \"and therefore cannot be a memory constraint\",\n+\t\t\t     name, name[0]);\n \t  return;\n \t}\n     }"}, {"sha": "a5e069f2dac722480292acb689a9d5b31127cc85", "filename": "gcc/genrecog.c", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -170,9 +170,6 @@ static int max_depth;\n \n /* The line number of the start of the pattern currently being processed.  */\n static int pattern_lineno;\n-\n-/* Count of errors.  */\n-static int error_count;\n \f\n /* Predicate handling.\n \n@@ -289,8 +286,7 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n \n \tif (*next_code == '\\0')\n \t  {\n-\t    message_with_line (pattern_lineno, \"empty match_code expression\");\n-\t    error_count++;\n+\t    error_with_line (pattern_lineno, \"empty match_code expression\");\n \t    break;\n \t  }\n \n@@ -309,9 +305,9 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n \t\t}\n \t    if (!found_it)\n \t      {\n-\t\tmessage_with_line (pattern_lineno, \"match_code \\\"%.*s\\\" matches nothing\",\n-\t\t\t\t   (int) n, code);\n-\t\terror_count ++;\n+\t\terror_with_line (pattern_lineno,\n+\t\t\t\t \"match_code \\\"%.*s\\\" matches nothing\",\n+\t\t\t\t (int) n, code);\n \t\tfor (i = 0; i < NUM_RTX_CODE; i++)\n \t\t  if (!strncasecmp (code, GET_RTX_NAME (i), n)\n \t\t      && GET_RTX_NAME (i)[n] == '\\0'\n@@ -333,10 +329,9 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n \tstruct pred_data *p = lookup_predicate (XSTR (exp, 1));\n \tif (!p)\n \t  {\n-\t    message_with_line (pattern_lineno,\n-\t\t\t       \"reference to unknown predicate '%s'\",\n-\t\t\t       XSTR (exp, 1));\n-\t    error_count++;\n+\t    error_with_line (pattern_lineno,\n+\t\t\t     \"reference to unknown predicate '%s'\",\n+\t\t\t     XSTR (exp, 1));\n \t    break;\n \t  }\n \tfor (i = 0; i < NUM_RTX_CODE; i++)\n@@ -351,10 +346,9 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n       break;\n \n     default:\n-      message_with_line (pattern_lineno,\n-\t \"'%s' cannot be used in a define_predicate expression\",\n-\t GET_RTX_NAME (GET_CODE (exp)));\n-      error_count++;\n+      error_with_line (pattern_lineno,\n+\t\t       \"'%s' cannot be used in a define_predicate expression\",\n+\t\t       GET_RTX_NAME (GET_CODE (exp)));\n       memset (codes, I, NUM_RTX_CODE);\n       break;\n     }\n@@ -634,12 +628,9 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n     case MATCH_OP_DUP:\n     case MATCH_PAR_DUP:\n       if (find_operand (insn, XINT (pattern, 0), pattern) == pattern)\n-\t{\n-\t  message_with_line (pattern_lineno,\n-\t\t\t     \"operand %i duplicated before defined\",\n-\t\t\t     XINT (pattern, 0));\n-          error_count++;\n-\t}\n+\terror_with_line (pattern_lineno,\n+\t\t\t \"operand %i duplicated before defined\",\n+\t\t\t XINT (pattern, 0));\n       break;\n     case MATCH_OPERAND:\n     case MATCH_OPERATOR:\n@@ -695,20 +686,14 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t\t\t     && find_matching_operand (insn, XINT (pattern, 0)))\n \t\t      ;\n \t\t    else\n-\t\t      {\n-\t\t\tmessage_with_line (pattern_lineno,\n-\t\t\t\t\t   \"operand %d missing in-out reload\",\n-\t\t\t\t\t   XINT (pattern, 0));\n-\t\t\terror_count++;\n-\t\t      }\n-\t\t  }\n-\t\telse if (constraints0 != '=' && constraints0 != '+')\n-\t\t  {\n-\t\t    message_with_line (pattern_lineno,\n-\t\t\t\t       \"operand %d missing output reload\",\n+\t\t      error_with_line (pattern_lineno,\n+\t\t\t\t       \"operand %d missing in-out reload\",\n \t\t\t\t       XINT (pattern, 0));\n-\t\t    error_count++;\n \t\t  }\n+\t\telse if (constraints0 != '=' && constraints0 != '+')\n+\t\t  error_with_line (pattern_lineno,\n+\t\t\t\t   \"operand %d missing output reload\",\n+\t\t\t\t   XINT (pattern, 0));\n \t      }\n \t  }\n \n@@ -782,12 +767,9 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n         /* The operands of a SET must have the same mode unless one\n \t   is VOIDmode.  */\n         else if (dmode != VOIDmode && smode != VOIDmode && dmode != smode)\n-\t  {\n-\t    message_with_line (pattern_lineno,\n-\t\t\t       \"mode mismatch in set: %smode vs %smode\",\n-\t\t\t       GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n-\t    error_count++;\n-\t  }\n+\t  error_with_line (pattern_lineno,\n+\t\t\t   \"mode mismatch in set: %smode vs %smode\",\n+\t\t\t   GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n \n \t/* If only one of the operands is VOIDmode, and PC or CC0 is\n \t   not involved, it's probably a mistake.  */\n@@ -828,12 +810,9 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \n     case LABEL_REF:\n       if (GET_MODE (XEXP (pattern, 0)) != VOIDmode)\n-\t{\n-\t  message_with_line (pattern_lineno,\n-\t\t\t     \"operand to label_ref %smode not VOIDmode\",\n-\t\t\t     GET_MODE_NAME (GET_MODE (XEXP (pattern, 0))));\n-\t  error_count++;\n-\t}\n+\terror_with_line (pattern_lineno,\n+\t\t\t \"operand to label_ref %smode not VOIDmode\",\n+\t\t\t GET_MODE_NAME (GET_MODE (XEXP (pattern, 0))));\n       break;\n \n     default:\n@@ -1494,12 +1473,11 @@ merge_accept_insn (struct decision *oldd, struct decision *addd)\n     }\n   else\n     {\n-      message_with_line (add->u.insn.lineno, \"`%s' matches `%s'\",\n-\t\t\t get_insn_name (add->u.insn.code_number),\n-\t\t\t get_insn_name (old->u.insn.code_number));\n+      error_with_line (add->u.insn.lineno, \"`%s' matches `%s'\",\n+\t\t       get_insn_name (add->u.insn.code_number),\n+\t\t       get_insn_name (old->u.insn.code_number));\n       message_with_line (old->u.insn.lineno, \"previous definition of `%s'\",\n \t\t\t get_insn_name (old->u.insn.code_number));\n-      error_count++;\n     }\n }\n \n@@ -2771,7 +2749,7 @@ main (int argc, char **argv)\n \t}\n     }\n \n-  if (error_count || have_error)\n+  if (have_error)\n     return FATAL_EXIT_CODE;\n \n   puts (\"\\n\\n\");"}, {"sha": "df0ad5f352ba5b3471f885df84086d9bad1f5090", "filename": "gcc/gensupport.c", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -45,7 +45,6 @@ static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n \n static int sequence_num;\n-static int errors;\n \n static int predicable_default;\n static const char *predicable_true;\n@@ -222,8 +221,7 @@ process_include (rtx desc, int lineno)\n   if (input_file == NULL)\n     {\n       free (pathname);\n-      message_with_line (lineno, \"include file `%s' not found\", filename);\n-      errors = 1;\n+      error_with_line (lineno, \"include file `%s' not found\", filename);\n       return;\n     }\n  success:\n@@ -369,9 +367,8 @@ is_predicable (struct queue_elem *elem)\n \tcase SET_ATTR_ALTERNATIVE:\n \t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n \t    {\n-\t      message_with_line (elem->lineno,\n-\t\t\t\t \"multiple alternatives for `predicable'\");\n-\t      errors = 1;\n+\t      error_with_line (elem->lineno,\n+\t\t\t       \"multiple alternatives for `predicable'\");\n \t      return 0;\n \t    }\n \t  break;\n@@ -390,9 +387,8 @@ is_predicable (struct queue_elem *elem)\n \t  /* ??? It would be possible to handle this if we really tried.\n \t     It's not easy though, and I'm not going to bother until it\n \t     really proves necessary.  */\n-\t  message_with_line (elem->lineno,\n-\t\t\t     \"non-constant value for `predicable'\");\n-\t  errors = 1;\n+\t  error_with_line (elem->lineno,\n+\t\t\t   \"non-constant value for `predicable'\");\n \t  return 0;\n \n \tdefault:\n@@ -409,9 +405,7 @@ is_predicable (struct queue_elem *elem)\n      to do this.  Delay this until we've got the basics solid.  */\n   if (strchr (value, ',') != NULL)\n     {\n-      message_with_line (elem->lineno,\n-\t\t\t \"multiple alternatives for `predicable'\");\n-      errors = 1;\n+      error_with_line (elem->lineno, \"multiple alternatives for `predicable'\");\n       return 0;\n     }\n \n@@ -421,10 +415,8 @@ is_predicable (struct queue_elem *elem)\n   if (strcmp (value, predicable_false) == 0)\n     return 0;\n \n-  message_with_line (elem->lineno,\n-\t\t     \"unknown value `%s' for `predicable' attribute\",\n-\t\t     value);\n-  errors = 1;\n+  error_with_line (elem->lineno,\n+\t\t   \"unknown value `%s' for `predicable' attribute\", value);\n   return 0;\n }\n \n@@ -443,9 +435,8 @@ identify_predicable_attribute (void)\n     if (strcmp (XSTR (elem->data, 0), \"predicable\") == 0)\n       goto found;\n \n-  message_with_line (define_cond_exec_queue->lineno,\n-\t\t     \"attribute `predicable' not defined\");\n-  errors = 1;\n+  error_with_line (define_cond_exec_queue->lineno,\n+\t\t   \"attribute `predicable' not defined\");\n   return;\n \n  found:\n@@ -454,9 +445,7 @@ identify_predicable_attribute (void)\n   p_true = strchr (p_false, ',');\n   if (p_true == NULL || strchr (++p_true, ',') != NULL)\n     {\n-      message_with_line (elem->lineno,\n-\t\t\t \"attribute `predicable' is not a boolean\");\n-      errors = 1;\n+      error_with_line (elem->lineno, \"attribute `predicable' is not a boolean\");\n       if (p_false)\n         free (p_false);\n       return;\n@@ -473,17 +462,14 @@ identify_predicable_attribute (void)\n       break;\n \n     case CONST:\n-      message_with_line (elem->lineno,\n-\t\t\t \"attribute `predicable' cannot be const\");\n-      errors = 1;\n+      error_with_line (elem->lineno, \"attribute `predicable' cannot be const\");\n       if (p_false)\n \tfree (p_false);\n       return;\n \n     default:\n-      message_with_line (elem->lineno,\n-\t\t\t \"attribute `predicable' must have a constant default\");\n-      errors = 1;\n+      error_with_line (elem->lineno,\n+\t\t       \"attribute `predicable' must have a constant default\");\n       if (p_false)\n \tfree (p_false);\n       return;\n@@ -495,10 +481,8 @@ identify_predicable_attribute (void)\n     predicable_default = 0;\n   else\n     {\n-      message_with_line (elem->lineno,\n-\t\t\t \"unknown value `%s' for `predicable' attribute\",\n-\t\t\t value);\n-      errors = 1;\n+      error_with_line (elem->lineno,\n+\t\t       \"unknown value `%s' for `predicable' attribute\", value);\n       if (p_false)\n \tfree (p_false);\n     }\n@@ -592,10 +576,8 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \n \tif (n_alternatives (c) != 1)\n \t  {\n-\t    message_with_line (lineno,\n-\t\t\t       \"too many alternatives for operand %d\",\n-\t\t\t       XINT (pattern, 0));\n-\t    errors = 1;\n+\t    error_with_line (lineno, \"too many alternatives for operand %d\",\n+\t\t\t     XINT (pattern, 0));\n \t    return NULL;\n \t  }\n \n@@ -783,9 +765,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \n       if (XVECLEN (ce_elem->data, 0) != 1)\n \t{\n-\t  message_with_line (ce_elem->lineno,\n-\t\t\t     \"too many patterns in predicate\");\n-\t  errors = 1;\n+\t  error_with_line (ce_elem->lineno, \"too many patterns in predicate\");\n \t  return;\n \t}\n \n@@ -882,7 +862,7 @@ process_define_cond_exec (void)\n   struct queue_elem *elem;\n \n   identify_predicable_attribute ();\n-  if (errors)\n+  if (have_error)\n     return;\n \n   for (elem = define_cond_exec_queue; elem ; elem = elem->next)\n@@ -972,7 +952,6 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n   condition_table = htab_create (500, hash_c_test, cmp_c_test, NULL);\n   init_predicate_table ();\n   obstack_init (rtl_obstack);\n-  errors = 0;\n   sequence_num = 0;\n   no_more_options = false;\n   already_read_stdin = false;\n@@ -1052,7 +1031,7 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n   if (define_cond_exec_queue != NULL)\n     process_define_cond_exec ();\n \n-  return errors ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n+  return have_error ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n }\n \n /* Programs that don't have their own options can use this entry point"}, {"sha": "654e625d1942b014312a0a41fda25f08315edacf", "filename": "gcc/read-md.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"hashtab.h\"\n+#include \"errors.h\"\n #include \"read-md.h\"\n \n /* Associates PTR (which can be a string, etc.) with the file location\n@@ -174,6 +175,17 @@ print_c_condition (const char *cond)\n     }\n }\n \n+/* A vfprintf-like function for reporting an error against line LINENO\n+   of the current MD file.  */\n+\n+static void ATTRIBUTE_PRINTF(2,0)\n+message_with_line_1 (int lineno, const char *msg, va_list ap)\n+{\n+  fprintf (stderr, \"%s:%d: \", read_md_filename, lineno);\n+  vfprintf (stderr, msg, ap);\n+  fputc ('\\n', stderr);\n+}\n+\n /* A printf-like function for reporting an error against line LINENO\n    in the current MD file.  */\n \n@@ -183,12 +195,21 @@ message_with_line (int lineno, const char *msg, ...)\n   va_list ap;\n \n   va_start (ap, msg);\n+  message_with_line_1 (lineno, msg, ap);\n+  va_end (ap);\n+}\n \n-  fprintf (stderr, \"%s:%d: \", read_md_filename, lineno);\n-  vfprintf (stderr, msg, ap);\n-  fputc ('\\n', stderr);\n+/* Like message_with_line, but treat the condition as an error.  */\n+\n+void\n+error_with_line (int lineno, const char *msg, ...)\n+{\n+  va_list ap;\n \n+  va_start (ap, msg);\n+  message_with_line_1 (lineno, msg, ap);\n   va_end (ap);\n+  have_error = 1;\n }\n \n /* A printf-like function for reporting an error against the current"}, {"sha": "075260b82b61031039be823eb7f3e7835825c150", "filename": "gcc/read-md.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb933490c3e9c3347c1566662688c6cafa6768e5/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=bb933490c3e9c3347c1566662688c6cafa6768e5", "patch": "@@ -47,6 +47,7 @@ extern void print_md_ptr_loc (const void *);\n extern const char *join_c_conditions (const char *, const char *);\n extern void print_c_condition (const char *);\n extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void error_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_with_file_and_line (const char *, ...)\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n extern void fatal_expected_char (int, int) ATTRIBUTE_NORETURN;"}]}