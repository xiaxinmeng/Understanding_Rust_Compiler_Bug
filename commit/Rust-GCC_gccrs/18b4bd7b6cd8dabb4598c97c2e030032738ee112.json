{"sha": "18b4bd7b6cd8dabb4598c97c2e030032738ee112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThiNGJkN2I2Y2Q4ZGFiYjQ1OThjOTdjMmUwMzAwMzI3MzhlZTExMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-10-28T22:03:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-28T22:03:56Z"}, "message": "morestack.S: Correct CFI information to do proper returns throughout function.\n\n\t* config/i386/morestack.S: Correct CFI information to do proper\n\treturns throughout function.  In 32-bit mode, save %ebx so that it\n\tis restored on unwind.\n\nFrom-SVN: r180633", "tree": {"sha": "b087dac48b5582e2d244b01939bb8dae93938c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b087dac48b5582e2d244b01939bb8dae93938c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18b4bd7b6cd8dabb4598c97c2e030032738ee112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b4bd7b6cd8dabb4598c97c2e030032738ee112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18b4bd7b6cd8dabb4598c97c2e030032738ee112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b4bd7b6cd8dabb4598c97c2e030032738ee112/comments", "author": null, "committer": null, "parents": [{"sha": "4356b75d984e19b079b04a1e737271734a95a4b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4356b75d984e19b079b04a1e737271734a95a4b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4356b75d984e19b079b04a1e737271734a95a4b2"}], "stats": {"total": 94, "additions": 64, "deletions": 30}, "files": [{"sha": "a261e7524cdd7f3040c9f96af026075ef2235cb1", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b4bd7b6cd8dabb4598c97c2e030032738ee112/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b4bd7b6cd8dabb4598c97c2e030032738ee112/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=18b4bd7b6cd8dabb4598c97c2e030032738ee112", "patch": "@@ -1,3 +1,9 @@\n+2011-10-28  Ian Lance Taylor  <iant@google.com>\n+\n+\t* config/i386/morestack.S: Correct CFI information to do proper\n+\treturns throughout function.  In 32-bit mode, save %ebx so that it\n+\tis restored on unwind.\n+\n 2011-10-25  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config/c6x/pr-support.c (__gnu_unwind_24bit): Correct logic for the"}, {"sha": "85c20ed7e9319a1318d71cab206d98c4fc7a6882", "filename": "libgcc/config/i386/morestack.S", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b4bd7b6cd8dabb4598c97c2e030032738ee112/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b4bd7b6cd8dabb4598c97c2e030032738ee112/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fmorestack.S?ref=18b4bd7b6cd8dabb4598c97c2e030032738ee112", "patch": "@@ -139,44 +139,68 @@ __morestack:\n \t.cfi_lsda 0x1b,.LLSDA1\n #endif\n \n-\t# Set up a normal backtrace.\n-\tpushl\t%ebp\n-\t.cfi_def_cfa_offset 8\n-\t.cfi_offset %ebp, -8\n-\tmovl\t%esp, %ebp\n-\t.cfi_def_cfa_register %ebp\n-\n \t# We return below with a ret $8.  We will return to a single\n \t# return instruction, which will return to the caller of our\n \t# caller.  We let the unwinder skip that single return\n \t# instruction, and just return to the real caller.\n-\t.cfi_offset 8, 8\n+\n+\t# Here CFA points just past the return address on the stack,\n+\t# e.g., on function entry it is %esp + 4.  Later we will\n+\t# change it to %ebp + 8, as set by .cfi_def_cfa_register and\n+\t# .cfi_def_cfa_offset above.  The stack looks like this:\n+\t#\tCFA + 12:\tstack pointer after two returns\n+\t#\tCFA + 8:\treturn address of morestack caller's caller\n+\t#\tCFA + 4:\tsize of parameters\n+\t#\tCFA:\t\tnew stack frame size\n+\t#\tCFA - 4:\treturn address of this function\n+\t#\tCFA - 8:\tprevious value of %ebp; %ebp points here\n+\t# We want to set %esp to the stack pointer after the double\n+\t# return, which is CFA + 12.\n+\t.cfi_offset 8, 8\t\t# New PC stored at CFA + 8\n \t.cfi_escape 0x15, 4, 0x7d\t# DW_CFA_val_offset_sf, %esp, 12/-4\n+\t\t\t\t\t# i.e., next %esp is CFA + 12\n+\n+\t# Set up a normal backtrace.\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset %ebp, -8\n+\tmovl\t%esp,%ebp\n+\t.cfi_def_cfa_register %ebp\n \n \t# In 32-bit mode the parameters are pushed on the stack.  The\n \t# argument size is pushed then the new stack frame size is\n \t# pushed.\n \n+\t# Align stack to 16-byte boundary with enough space for saving\n+\t# registers and passing parameters to functions we call.\n+\tsubl\t$40,%esp\n+\n+\t# Because our cleanup code may need to clobber %ebx, we need\n+\t# to save it here so the unwinder can restore the value used\n+\t# by the caller.  Note that we don't have to restore the\n+\t# register, since we don't change it, we just have to save it\n+\t# for the unwinder.\n+\tmovl\t%ebx,-4(%ebp)\n+\t.cfi_offset %ebx, -12\n+\n \t# In 32-bit mode the registers %eax, %edx, and %ecx may be\n \t# used for parameters, depending on the regparm and fastcall\n \t# attributes.\n \n-\tpushl\t%eax\n-\tpushl\t%edx\n-\tpushl\t%ecx\n+\tmovl\t%eax,-8(%ebp)\n+\tmovl\t%edx,-12(%ebp)\n+\tmovl\t%ecx,-16(%ebp)\n \n \tcall\t__morestack_block_signals\n \n-\tpushl\t12(%ebp)\t\t# The size of the parameters.\n+\tmovl\t12(%ebp),%eax\t\t# The size of the parameters.\n+\tmovl\t%eax,8(%esp)\n \tleal\t20(%ebp),%eax\t\t# Address of caller's parameters.\n-\tpushl\t%eax\n+\tmovl\t%eax,4(%esp)\n \taddl\t$BACKOFF,8(%ebp)\t# Ask for backoff bytes.\n \tleal\t8(%ebp),%eax\t\t# The address of the new frame size.\n-\tpushl\t%eax\n+\tmovl\t%eax,(%esp)\n \n-\t# Note that %esp is exactly 32 bytes below the CFA -- perfect for\n-\t# a 16-byte aligned stack.  That said, we still ought to compile\n-\t# generic-morestack.c with -mpreferred-stack-boundary=2.  FIXME.\n \tcall\t__generic_morestack\n \n \tmovl\t%eax,%esp\t\t# Switch to the new stack.\n@@ -191,21 +215,21 @@ __morestack:\n \n \tcall\t__morestack_unblock_signals\n \n-\tmovl\t-8(%ebp),%edx\t\t# Restore registers.\n-\tmovl\t-12(%ebp),%ecx\n+\tmovl\t-12(%ebp),%edx\t\t# Restore registers.\n+\tmovl\t-16(%ebp),%ecx\n \n \tmovl\t4(%ebp),%eax\t\t# Increment the return address\n \tcmpb\t$0xc3,(%eax)\t\t# to skip the ret instruction;\n \tje\t1f\t\t\t# see above.\n \taddl\t$2,%eax\n 1:\tinc\t%eax\n \n-\tmovl\t%eax,-8(%ebp)\t\t# Store return address in an\n+\tmovl\t%eax,-12(%ebp)\t\t# Store return address in an\n \t\t\t\t\t# unused slot.\n \n-\tmovl\t-4(%ebp),%eax\t\t# Restore the last register.\n+\tmovl\t-8(%ebp),%eax\t\t# Restore the last register.\n \n-\tcall\t*-8(%ebp)\t\t# Call our caller!\n+\tcall\t*-12(%ebp)\t\t# Call our caller!\n \n \t# The caller will return here, as predicted.\n \n@@ -255,9 +279,13 @@ __morestack:\n \tpopl\t%eax\n \n \t.cfi_remember_state\n+\n+\t# We never changed %ebx, so we don't have to actually restore it.\n+\t.cfi_restore %ebx\n+\n \tpopl\t%ebp\n \t.cfi_restore %ebp\n-\t.cfi_def_cfa %esp, 12\n+\t.cfi_def_cfa %esp, 4\n \tret\t$8\t\t\t# Return to caller, which will\n \t\t\t\t\t# immediately return.  Pop\n \t\t\t\t\t# arguments as we go.\n@@ -300,20 +328,20 @@ __morestack:\n \t.cfi_lsda 0x1b,.LLSDA1\n #endif\n \n-\t# Set up a normal backtrace.\n-\tpushq\t%rbp\n-\t.cfi_def_cfa_offset 16\n-\t.cfi_offset %rbp, -16\n-\tmovq\t%rsp, %rbp\n-\t.cfi_def_cfa_register %rbp\n-\n \t# We will return a single return instruction, which will\n \t# return to the caller of our caller.  Let the unwinder skip\n \t# that single return instruction, and just return to the real\n \t# caller.\n \t.cfi_offset 16, 0\n \t.cfi_escape 0x15, 7, 0x7f\t# DW_CFA_val_offset_sf, %esp, 8/-8\n \n+\t# Set up a normal backtrace.\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset %rbp, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register %rbp\n+\n \t# In 64-bit mode the new stack frame size is passed in r10\n         # and the argument size is passed in r11.\n "}]}