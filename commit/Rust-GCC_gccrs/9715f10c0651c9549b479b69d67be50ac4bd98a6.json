{"sha": "9715f10c0651c9549b479b69d67be50ac4bd98a6", "node_id": "C_kwDOANBUbNoAKDk3MTVmMTBjMDY1MWM5NTQ5YjQ3OWI2OWQ2N2JlNTBhYzRiZDk4YTY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-27T06:34:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-27T06:34:18Z"}, "message": "asan: Fix up asan_redzone_buffer::emit_redzone_byte [PR105396]\n\nOn the following testcase, we have in main's frame 3 variables,\nsome red zone padding, 4 byte d, followed by 12 bytes of red zone padding, then\n8 byte b followed by 24 bytes of red zone padding, then 40 bytes c followed\nby some red zone padding.\nThe intended content of shadow memory for that is (note, each byte describes\n8 bytes of memory):\nf1 f1 f1 f1 04 f2 00 f2 f2 f2 00 00 00 00 00 f3 f3 f3 f3 f3\nleft red    d  mr b  middle r c              right red zone\n\nf1 is left red zone magic\nf2 is middle red zone magic\nf3 is right red zone magic\n00 when all 8 bytes are accessible\n01-07 when only 1 to 7 bytes are accessible followed by inaccessible bytes\n\nThe -fdump-rtl-expand-details dump makes it clear that it misbehaves:\nFlushing rzbuffer at offset -160 with: f1 f1 f1 f1\nFlushing rzbuffer at offset -128 with: 04 f2 00 00\nFlushing rzbuffer at offset -128 with: 00 00 00 f2\nFlushing rzbuffer at offset -96 with: f2 f2 00 00\nFlushing rzbuffer at offset -64 with: 00 00 00 f3\nFlushing rzbuffer at offset -32 with: f3 f3 f3 f3\nIn the end we end up with\nf1 f1 f1 f1 00 00 00 f2 f2 f2 00 00 00 00 00 f3 f3 f3 f3 f3\nshadow bytes because at offset -128 there are 2 overlapping stores\nas asan_redzone_buffer::emit_redzone_byte has flushed the temporary 4 byte\nbuffer in the middle.\n\nThe function is called with an offset and value.  If the passed offset is\nconsecutive with the prev_offset + buffer size (off == offset), then\nwe handle it correctly, similarly if the new offset is far enough from the\nold one (we then flush whatever was in the buffer and if needed add up to 3\nbytes of 00 before actually pushing value.\n\nBut what isn't handled correctly is when the offset isn't consecutive to\nwhat has been added last time, but it is in the same 4 byte word of shadow\nmemory (32 bytes of actual memory), like the above case where\nwe have consecutive 04 f2 and then skip one shadow memory byte (aka 8 bytes\nof real memory) and then want to emit f2.  Emitting that as a store\nof little-endian 0x0000f204 followed by a store of 0xf2000000 to the same\naddress doesn't work, we want to emit 0xf200f204.\n\nThe following patch does that by pushing 1 or 2 00 bytes.\nAdditionally, as a small cleanup, instead of using\n      m_shadow_bytes.safe_push (value);\n      flush_if_full ();\nin all of if, else if and else bodies it sinks those 2 stmts to the end\nof function as all do the same thing.\n\n2022-04-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR sanitizer/105396\n\t* asan.cc (asan_redzone_buffer::emit_redzone_byte): Handle the case\n\twhere offset is bigger than off but smaller than m_prev_offset + 32\n\tbits by pushing one or more 0 bytes.  Sink the\n\tm_shadow_bytes.safe_push (value); flush_if_full (); statements from\n\tall cases to the end of the function.\n\n\t* gcc.dg/asan/pr105396.c: New test.", "tree": {"sha": "166d8f115aa0dcbf6fa4be18666a8c5b11fef9b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/166d8f115aa0dcbf6fa4be18666a8c5b11fef9b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9715f10c0651c9549b479b69d67be50ac4bd98a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9715f10c0651c9549b479b69d67be50ac4bd98a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9715f10c0651c9549b479b69d67be50ac4bd98a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9715f10c0651c9549b479b69d67be50ac4bd98a6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d2411c787493adb1e1ae894cbef161cb7a114f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d2411c787493adb1e1ae894cbef161cb7a114f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d2411c787493adb1e1ae894cbef161cb7a114f"}], "stats": {"total": 33, "additions": 28, "deletions": 5}, "files": [{"sha": "ef59b77ebc2e56dc379e241e6f9131289e827440", "filename": "gcc/asan.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9715f10c0651c9549b479b69d67be50ac4bd98a6/gcc%2Fasan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9715f10c0651c9549b479b69d67be50ac4bd98a6/gcc%2Fasan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.cc?ref=9715f10c0651c9549b479b69d67be50ac4bd98a6", "patch": "@@ -1497,10 +1497,14 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,\n   HOST_WIDE_INT off\n     = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();\n   if (off == offset)\n+    /* Consecutive shadow memory byte.  */;\n+  else if (offset < m_prev_offset + (HOST_WIDE_INT) (ASAN_SHADOW_GRANULARITY\n+\t\t\t\t\t\t     * RZ_BUFFER_SIZE)\n+\t   && !m_shadow_bytes.is_empty ())\n     {\n-      /* Consecutive shadow memory byte.  */\n-      m_shadow_bytes.safe_push (value);\n-      flush_if_full ();\n+      /* Shadow memory byte with a small gap.  */\n+      for (; off < offset; off += ASAN_SHADOW_GRANULARITY)\n+\tm_shadow_bytes.safe_push (0);\n     }\n   else\n     {\n@@ -1521,9 +1525,9 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,\n       m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,\n \t\t\t\t     diff >> ASAN_SHADOW_SHIFT);\n       m_prev_offset = offset;\n-      m_shadow_bytes.safe_push (value);\n-      flush_if_full ();\n     }\n+  m_shadow_bytes.safe_push (value);\n+  flush_if_full ();\n }\n \n /* Emit RTX emission of the content of the buffer.  */"}, {"sha": "d4bd7f12476318e78f1d23651ef9e73961f2c7f9", "filename": "gcc/testsuite/gcc.dg/asan/pr105396.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9715f10c0651c9549b479b69d67be50ac4bd98a6/gcc%2Ftestsuite%2Fgcc.dg%2Fasan%2Fpr105396.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9715f10c0651c9549b479b69d67be50ac4bd98a6/gcc%2Ftestsuite%2Fgcc.dg%2Fasan%2Fpr105396.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasan%2Fpr105396.c?ref=9715f10c0651c9549b479b69d67be50ac4bd98a6", "patch": "@@ -0,0 +1,19 @@\n+/* PR sanitizer/105396 */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+int\n+main ()\n+{\n+  int a;\n+  int *b[1];\n+  int c[10];\n+  int d[1][1];\n+  for (a = 0; a < 1; a++)\n+    d[1][a] = 0;\n+  return 0;\n+}\n+\n+/* { dg-output \"ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"WRITE of size.*\" } */"}]}