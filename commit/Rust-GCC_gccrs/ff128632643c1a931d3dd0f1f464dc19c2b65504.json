{"sha": "ff128632643c1a931d3dd0f1f464dc19c2b65504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYxMjg2MzI2NDNjMWE5MzFkM2RkMGYxZjQ2NGRjMTljMmI2NTUwNA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2009-01-13T14:31:56Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2009-01-13T14:31:56Z"}, "message": "arm.c (output_move_double): Don't synthesize thumb-2 ldrd/strd with two 32-bit instructions.\n\n\t* arm.c (output_move_double): Don't synthesize thumb-2 ldrd/strd with\n\ttwo 32-bit instructions.\n\nFrom-SVN: r143339", "tree": {"sha": "7992941d9a3dabf25e0767f4cd187a14d79363a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7992941d9a3dabf25e0767f4cd187a14d79363a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff128632643c1a931d3dd0f1f464dc19c2b65504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff128632643c1a931d3dd0f1f464dc19c2b65504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff128632643c1a931d3dd0f1f464dc19c2b65504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff128632643c1a931d3dd0f1f464dc19c2b65504/comments", "author": null, "committer": null, "parents": [{"sha": "d5a0a47beef90da73f9f105c30ed380dce36e26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a0a47beef90da73f9f105c30ed380dce36e26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5a0a47beef90da73f9f105c30ed380dce36e26b"}], "stats": {"total": 63, "additions": 33, "deletions": 30}, "files": [{"sha": "d5c7e9e785a0ec293b9f0b0cdfe3a20200817750", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff128632643c1a931d3dd0f1f464dc19c2b65504/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff128632643c1a931d3dd0f1f464dc19c2b65504/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff128632643c1a931d3dd0f1f464dc19c2b65504", "patch": "@@ -1,3 +1,8 @@\n+2009-01-13  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (output_move_double): Don't synthesize thumb-2 ldrd/strd with\n+\ttwo 32-bit instructions.\n+\n 2009-01-13  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (struct processors): Pass for speed down into cost helper"}, {"sha": "209682bb0fea215b88eaa042abf22c88c5754182", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff128632643c1a931d3dd0f1f464dc19c2b65504/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff128632643c1a931d3dd0f1f464dc19c2b65504/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ff128632643c1a931d3dd0f1f464dc19c2b65504", "patch": "@@ -6377,7 +6377,7 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n       break;\t\t\t\t\t\\\n     }\n \n-  unsigned int i, elsize, idx = 0, n_elts = CONST_VECTOR_NUNITS (op);\n+  unsigned int i, elsize = 0, idx = 0, n_elts = CONST_VECTOR_NUNITS (op);\n   unsigned int innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n   unsigned char bytes[16];\n   int immtype = -1, matches;\n@@ -10391,36 +10391,36 @@ output_move_double (rtx *operands)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* IWMMXT allows offsets larger than ldrd can handle,\n-\t\t     fix these up with a pair of ldr.  */\n-\t\t  if (GET_CODE (otherops[2]) == CONST_INT\n-\t\t      && (INTVAL(otherops[2]) <= -256\n-\t\t\t  || INTVAL(otherops[2]) >= 256))\n+\t\t  /* Use a single insn if we can.\n+\t\t     FIXME: IWMMXT allows offsets larger than ldrd can\n+\t\t     handle, fix these up with a pair of ldr.  */\n+\t\t  if (TARGET_THUMB2\n+\t\t      || GET_CODE (otherops[2]) != CONST_INT\n+\t\t      || (INTVAL (otherops[2]) > -256\n+\t\t\t  && INTVAL (otherops[2]) < 256))\n+\t\t    output_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]!\", otherops);\n+\t\t  else\n \t\t    {\n \t\t      output_asm_insn (\"ldr%?\\t%0, [%1, %2]!\", otherops);\n-\t\t      otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n-\t\t      output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t      output_asm_insn (\"ldr%?\\t%H0, [%1, #4]\", otherops);\n \t\t    }\n-\t\t  else\n-\t\t    output_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]!\", otherops);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      /* IWMMXT allows offsets larger than ldrd can handle,\n+\t      /* Use a single insn if we can.\n+\t\t FIXME: IWMMXT allows offsets larger than ldrd can handle,\n \t\t fix these up with a pair of ldr.  */\n-\t      if (GET_CODE (otherops[2]) == CONST_INT\n-\t\t  && (INTVAL(otherops[2]) <= -256\n-\t\t      || INTVAL(otherops[2]) >= 256))\n+\t      if (TARGET_THUMB2\n+\t\t  || GET_CODE (otherops[2]) != CONST_INT\n+\t\t  || (INTVAL (otherops[2]) > -256\n+\t\t      && INTVAL (otherops[2]) < 256))\n+\t\toutput_asm_insn (\"ldr%(d%)\\t%0, [%1], %2\", otherops);\n+\t      else\n \t\t{\n-\t\t  otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n-\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n-\t\t  otherops[0] = operands[0];\n+\t\t  output_asm_insn (\"ldr%?\\t%H0, [%1, #4]\", otherops);\n \t\t  output_asm_insn (\"ldr%?\\t%0, [%1], %2\", otherops);\n \t\t}\n-\t      else\n-\t\t/* We only allow constant increments, so this is safe.  */\n-\t\toutput_asm_insn (\"ldr%(d%)\\t%0, [%1], %2\", otherops);\n \t    }\n \t  break;\n \n@@ -10474,6 +10474,7 @@ output_move_double (rtx *operands)\n \t\t  operands[1] = otherops[0];\n \t\t  if (TARGET_LDRD\n \t\t      && (GET_CODE (otherops[2]) == REG\n+\t\t\t  || TARGET_THUMB2\n \t\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n \t\t\t      && INTVAL (otherops[2]) > -256\n \t\t\t      && INTVAL (otherops[2]) < 256)))\n@@ -10586,23 +10587,19 @@ output_move_double (rtx *operands)\n \n \t  /* IWMMXT allows offsets larger than ldrd can handle,\n \t     fix these up with a pair of ldr.  */\n-\t  if (GET_CODE (otherops[2]) == CONST_INT\n+\t  if (!TARGET_THUMB2\n+\t      && GET_CODE (otherops[2]) == CONST_INT\n \t      && (INTVAL(otherops[2]) <= -256\n \t\t  || INTVAL(otherops[2]) >= 256))\n \t    {\n-\t      rtx reg1;\n-\t      reg1 = gen_rtx_REG (SImode, 1 + REGNO (operands[1]));\n \t      if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)\n \t\t{\n \t\t  output_asm_insn (\"ldr%?\\t%0, [%1, %2]!\", otherops);\n-\t\t  otherops[0] = reg1;\n-\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t  output_asm_insn (\"ldr%?\\t%H0, [%1, #4]\", otherops);\n \t\t}\n \t      else\n \t\t{\n-\t\t  otherops[0] = reg1;\n-\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n-\t\t  otherops[0] = operands[1];\n+\t\t  output_asm_insn (\"ldr%?\\t%H0, [%1, #4]\", otherops);\n \t\t  output_asm_insn (\"ldr%?\\t%0, [%1], %2\", otherops);\n \t\t}\n \t    }\n@@ -10637,6 +10634,7 @@ output_move_double (rtx *operands)\n \t    }\n \t  if (TARGET_LDRD\n \t      && (GET_CODE (otherops[2]) == REG\n+\t\t  || TARGET_THUMB2\n \t\t  || (GET_CODE (otherops[2]) == CONST_INT\n \t\t      && INTVAL (otherops[2]) > -256\n \t\t      && INTVAL (otherops[2]) < 256)))\n@@ -10650,9 +10648,9 @@ output_move_double (rtx *operands)\n \n         default:\n \t  otherops[0] = adjust_address (operands[0], SImode, 4);\n-\t  otherops[1] = gen_rtx_REG (SImode, 1 + REGNO (operands[1]));\n+\t  otherops[1] = operands[1];\n \t  output_asm_insn (\"str%?\\t%1, %0\", operands);\n-\t  output_asm_insn (\"str%?\\t%1, %0\", otherops);\n+\t  output_asm_insn (\"str%?\\t%H1, %0\", otherops);\n \t}\n     }\n "}]}