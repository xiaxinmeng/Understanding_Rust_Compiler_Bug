{"sha": "ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY3ZmZiOGYyYTQ2NzAyOTdiNTNmMzhjMGE3NTFkZWZjNTliYjQ3Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-22T08:30:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-22T08:30:34Z"}, "message": "tree-ssa-propagate.h (ssa_prop_fold_stmt_fn): Declare.\n\n2009-09-22  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-propagate.h (ssa_prop_fold_stmt_fn): Declare.\n\t(substitute_and_fold): Adjust prototype.\n\t* tree-vrp.c (vrp_evaluate_conditional): Make static.\n\t(simplify_stmt_using_ranges): Likewise.\n\t(fold_predicate_in): Move here from tree-ssa-propagate.c.\n\t(vrp_fold_stmt): New function.\n\t(vrp_finalize): Pass it to substitute_and_fold.\n\t* tree-flow.h (vrp_evaluate_conditional): Remove.\n\t(simplify_stmt_using_ranges): Likewise.\n\t* tree-ssa-ccp.c (ccp_finalize): Adjust call to substitute_and_fold.\n\t* tree-ssa-copy.c (fini_copy_prop): Likewise.\n\t* tree-ssa-propagate.c (struct prop_stats_d): Rename num_pred_folded\n\tmember.\n\t(fold_predicate_in): Move to tree-vrp.c.\n\t(substitute_and_fold): Use the callback instead of calling into\n\ttree-vrp.c functions directly.\n\nFrom-SVN: r151968", "tree": {"sha": "051a9f785512d04b8b2f8278b342dada185c9d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051a9f785512d04b8b2f8278b342dada185c9d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b659ecb8ea30d4f15c973d114c28f0c46ad96d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b659ecb8ea30d4f15c973d114c28f0c46ad96d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b659ecb8ea30d4f15c973d114c28f0c46ad96d6"}], "stats": {"total": 216, "additions": 114, "deletions": 102}, "files": [{"sha": "97dd74b3d1f7aa56b60863f2fc96bfba956856f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -1,3 +1,22 @@\n+2009-09-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-propagate.h (ssa_prop_fold_stmt_fn): Declare.\n+\t(substitute_and_fold): Adjust prototype.\n+\t* tree-vrp.c (vrp_evaluate_conditional): Make static.\n+\t(simplify_stmt_using_ranges): Likewise.\n+\t(fold_predicate_in): Move here from tree-ssa-propagate.c.\n+\t(vrp_fold_stmt): New function.\n+\t(vrp_finalize): Pass it to substitute_and_fold.\n+\t* tree-flow.h (vrp_evaluate_conditional): Remove.\n+\t(simplify_stmt_using_ranges): Likewise.\n+\t* tree-ssa-ccp.c (ccp_finalize): Adjust call to substitute_and_fold.\n+\t* tree-ssa-copy.c (fini_copy_prop): Likewise.\n+\t* tree-ssa-propagate.c (struct prop_stats_d): Rename num_pred_folded\n+\tmember.\n+\t(fold_predicate_in): Move to tree-vrp.c.\n+\t(substitute_and_fold): Use the callback instead of calling into\n+\ttree-vrp.c functions directly.\n+\n 2009-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (address_of_int_loc_descriptor): Avoid signed/unsigned"}, {"sha": "77cd80bdfe93108917161d8269d46aa6f5b98016", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -680,10 +680,6 @@ tree fold_const_aggregate_ref (tree);\n bool may_propagate_address_into_dereference (tree, tree);\n \n \n-/* In tree-vrp.c  */\n-tree vrp_evaluate_conditional (enum tree_code, tree, tree, gimple);\n-bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n-\n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);\n extern void debug_dominator_optimization_stats (void);"}, {"sha": "5e305880bb738ecc2b44446691f9d2b18011a934", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -724,7 +724,7 @@ ccp_finalize (void)\n \n   do_dbg_cnt ();\n   /* Perform substitutions based on the known constant values.  */\n-  something_changed = substitute_and_fold (const_val, false);\n+  something_changed = substitute_and_fold (const_val, NULL);\n \n   free (const_val);\n   const_val = NULL;"}, {"sha": "986ad454e7425a1f63a75005187b1e8ba6563dd0", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -847,7 +847,7 @@ fini_copy_prop (void)\n \tduplicate_ssa_name_ptr_info (tmp[i].value, SSA_NAME_PTR_INFO (var));\n     }\n \n-  substitute_and_fold (tmp, false);\n+  substitute_and_fold (tmp, NULL);\n \n   free (cached_last_copy_of);\n   free (copy_of);"}, {"sha": "ec0ecf3d3bb15824cf905c60fc1188c8bf588812", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 16, "deletions": 92, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -856,7 +856,7 @@ struct prop_stats_d\n {\n   long num_const_prop;\n   long num_copy_prop;\n-  long num_pred_folded;\n+  long num_stmts_folded;\n   long num_dce;\n };\n \n@@ -958,92 +958,24 @@ replace_phi_args_in (gimple phi, prop_value_t *prop_value)\n }\n \n \n-/* If the statement pointed by SI has a predicate whose value can be\n-   computed using the value range information computed by VRP, compute\n-   its value and return true.  Otherwise, return false.  */\n-\n-static bool\n-fold_predicate_in (gimple_stmt_iterator *si)\n-{\n-  bool assignment_p = false;\n-  tree val;\n-  gimple stmt = gsi_stmt (*si);\n-\n-  if (is_gimple_assign (stmt)\n-      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n-    {\n-      assignment_p = true;\n-      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n-\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t      gimple_assign_rhs2 (stmt),\n-\t\t\t\t      stmt);\n-    }\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n-    val = vrp_evaluate_conditional (gimple_cond_code (stmt),\n-\t\t\t\t    gimple_cond_lhs (stmt),\n-\t\t\t\t    gimple_cond_rhs (stmt),\n-\t\t\t\t    stmt);\n-  else\n-    return false;\n-\n-\n-  if (val)\n-    {\n-      if (assignment_p)\n-        val = fold_convert (gimple_expr_type (stmt), val);\n-      \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Folding predicate \");\n-\t  print_gimple_expr (dump_file, stmt, 0, 0);\n-\t  fprintf (dump_file, \" to \");\n-\t  print_generic_expr (dump_file, val, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      prop_stats.num_pred_folded++;\n-\n-      if (is_gimple_assign (stmt))\n-\tgimple_assign_set_rhs_from_tree (si, val);\n-      else\n-\t{\n-\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n-\t  if (integer_zerop (val))\n-\t    gimple_cond_make_false (stmt);\n-\t  else if (integer_onep (val))\n-\t    gimple_cond_make_true (stmt);\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Perform final substitution and folding of propagated values.\n \n    PROP_VALUE[I] contains the single value that should be substituted\n    at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are\n    substituted.\n \n-   If USE_RANGES_P is true, statements that contain predicate\n-   expressions are evaluated with a call to vrp_evaluate_conditional.\n-   This will only give meaningful results when called from tree-vrp.c\n-   (the information used by vrp_evaluate_conditional is built by the\n-   VRP pass).  \n+   If FOLD_FN is non-NULL the function will be invoked on all statements\n+   before propagating values for pass specific simplification.\n \n    Return TRUE when something changed.  */\n \n bool\n-substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n+substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n {\n   basic_block bb;\n   bool something_changed = false;\n \n-  if (prop_value == NULL && !use_ranges_p)\n+  if (prop_value == NULL && !fold_fn)\n     return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1114,13 +1046,16 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t    }\n \n-\t  /* If we have range information, see if we can fold\n-\t     predicate expressions.  */\n-\t  if (use_ranges_p)\n+\t  old_stmt = stmt;\n+\n+\t  /* Some statements may be simplified using propagator\n+\t     specific information.  Do this before propagating\n+\t     into the stmt to not disturb pass specific information.  */\n+\t  if (fold_fn\n+\t      && (*fold_fn)(&i))\n \t    {\n-\t      did_replace = fold_predicate_in (&i);\n-\t      /* fold_predicate_in should not have reallocated STMT.  */\n-\t      gcc_assert (gsi_stmt (i) == stmt);\n+\t      did_replace = true;\n+\t      prop_stats.num_stmts_folded++;\n \t    }\n \n \t  /* Only replace real uses if we couldn't fold the\n@@ -1130,20 +1065,9 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t    did_replace |= replace_uses_in (stmt, prop_value);\n \n \t  /* If we made a replacement, fold the statement.  */\n-\n-\t  old_stmt = stmt;\n \t  if (did_replace)\n \t    fold_stmt (&i);\n \n-\t  /* Some statements may be simplified using ranges.  For\n-\t     example, division may be replaced by shifts, modulo\n-\t     replaced with bitwise and, etc.   Do this after \n-\t     substituting constants, folding, etc so that we're\n-\t     presented with a fully propagated, canonicalized\n-\t     statement.  */\n-\t  if (use_ranges_p)\n-\t    did_replace |= simplify_stmt_using_ranges (&i);\n-\n \t  /* Now cleanup.  */\n \t  if (did_replace)\n \t    {\n@@ -1190,8 +1114,8 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t\t\t    prop_stats.num_const_prop);\n   statistics_counter_event (cfun, \"Copies propagated\",\n \t\t\t    prop_stats.num_copy_prop);\n-  statistics_counter_event (cfun, \"Predicates folded\",\n-\t\t\t    prop_stats.num_pred_folded);\n+  statistics_counter_event (cfun, \"Statements folded\",\n+\t\t\t    prop_stats.num_stmts_folded);\n   statistics_counter_event (cfun, \"Statements deleted\",\n \t\t\t    prop_stats.num_dce);\n   return something_changed;"}, {"sha": "e8f4f03dfb318b641f8829e1788a4c4e847c2590", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -110,6 +110,7 @@ typedef struct value_range_d value_range_t;\n /* Call-back functions used by the value propagation engine.  */\n typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (gimple, edge *, tree *);\n typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (gimple);\n+typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n \n \n /* In tree-ssa-propagate.c  */\n@@ -119,6 +120,6 @@ bool valid_gimple_call_p (tree);\n void move_ssa_defining_stmt_for_defs (gimple, gimple);\n bool update_call_from_tree (gimple_stmt_iterator *, tree);\n bool stmt_makes_single_store (gimple);\n-bool substitute_and_fold (prop_value_t *, bool);\n+bool substitute_and_fold (prop_value_t *, ssa_prop_fold_stmt_fn);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "57800075e94b3f3a64003715a5e4a10c569d0222", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7ffb8f2a4670297b53f38c0a751defc59bb47f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ff7ffb8f2a4670297b53f38c0a751defc59bb47f", "patch": "@@ -5678,7 +5678,7 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n    based on undefined signed overflow, issue a warning if\n    appropriate.  */\n \n-tree\n+static tree\n vrp_evaluate_conditional (enum tree_code code, tree op0, tree op1, gimple stmt)\n {\n   bool sop;\n@@ -6945,7 +6945,7 @@ simplify_switch_using_ranges (gimple stmt)\n \n /* Simplify STMT using ranges if possible.  */\n \n-bool\n+static bool\n simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n@@ -6998,6 +6998,78 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* If the statement pointed by SI has a predicate whose value can be\n+   computed using the value range information computed by VRP, compute\n+   its value and return true.  Otherwise, return false.  */\n+\n+static bool\n+fold_predicate_in (gimple_stmt_iterator *si)\n+{\n+  bool assignment_p = false;\n+  tree val;\n+  gimple stmt = gsi_stmt (*si);\n+\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n+    {\n+      assignment_p = true;\n+      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n+\t\t\t\t      gimple_assign_rhs1 (stmt),\n+\t\t\t\t      gimple_assign_rhs2 (stmt),\n+\t\t\t\t      stmt);\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_COND)\n+    val = vrp_evaluate_conditional (gimple_cond_code (stmt),\n+\t\t\t\t    gimple_cond_lhs (stmt),\n+\t\t\t\t    gimple_cond_rhs (stmt),\n+\t\t\t\t    stmt);\n+  else\n+    return false;\n+\n+  if (val)\n+    {\n+      if (assignment_p)\n+        val = fold_convert (gimple_expr_type (stmt), val);\n+      \n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Folding predicate \");\n+\t  print_gimple_expr (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \" to \");\n+\t  print_generic_expr (dump_file, val, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      if (is_gimple_assign (stmt))\n+\tgimple_assign_set_rhs_from_tree (si, val);\n+      else\n+\t{\n+\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n+\t  if (integer_zerop (val))\n+\t    gimple_cond_make_false (stmt);\n+\t  else if (integer_onep (val))\n+\t    gimple_cond_make_true (stmt);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Callback for substitute_and_fold folding the stmt at *SI.  */\n+\n+static bool\n+vrp_fold_stmt (gimple_stmt_iterator *si)\n+{\n+  if (fold_predicate_in (si))\n+    return true;\n+\n+  return simplify_stmt_using_ranges (si);\n+}\n+\n /* Stack of dest,src equivalency pairs that need to be restored after\n    each attempt to thread a block's incoming edge to an outgoing edge. \n \n@@ -7187,7 +7259,7 @@ vrp_finalize (void)\n       single_val_range = NULL;\n     }\n \n-  substitute_and_fold (single_val_range, true);\n+  substitute_and_fold (single_val_range, vrp_fold_stmt);\n \n   if (warn_array_bounds)\n       check_all_array_refs ();"}]}