{"sha": "58b6e04789a04563418234e753835ee6248bf4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThiNmUwNDc4OWEwNDU2MzQxODIzNGU3NTM4MzVlZTYyNDhiZjRkOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-05T06:27:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-05T06:27:48Z"}, "message": "2006-11-05  Francois-Xavier Coudert  <fxcoudert@gcc.gnu,org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24518\n\t* trans-intrinsic.c (gfc_conv_intrinsic_mod): Use built_in fmod\n\tfor both MOD and MODULO, if it is available.\n\n\tPR fortran/29565\n\t* trans-expr.c (gfc_conv_aliased_arg): For an INTENT(OUT), save\n\tthe declarations from the unused loops by merging the block\n\tscope for each; this ensures that the temporary is declared.\n\n2006-11-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29565\n\t* gfortran.dg/gfortran.dg/aliasing_dummy_3.f90: New test.\n\nFrom-SVN: r118492", "tree": {"sha": "d03b8048cc4743b2d76e030ab691c2db5c79c4b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03b8048cc4743b2d76e030ab691c2db5c79c4b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58b6e04789a04563418234e753835ee6248bf4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b6e04789a04563418234e753835ee6248bf4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b6e04789a04563418234e753835ee6248bf4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b6e04789a04563418234e753835ee6248bf4d8/comments", "author": null, "committer": null, "parents": [{"sha": "cb60c134e23d6c8c013ad89a4c1cb6e28cac94b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb60c134e23d6c8c013ad89a4c1cb6e28cac94b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb60c134e23d6c8c013ad89a4c1cb6e28cac94b6"}], "stats": {"total": 122, "additions": 115, "deletions": 7}, "files": [{"sha": "e22e33fa4b1d531bb3a4738fdc351e73b5543118", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -1,3 +1,15 @@\n+2006-11-05  Francois-Xavier Coudert  <fxcoudert@gcc.gnu,org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24518\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_mod): Use built_in fmod\n+\tfor both MOD and MODULO, if it is available.\n+\n+\tPR fortran/29565\n+\t* trans-expr.c (gfc_conv_aliased_arg): For an INTENT(OUT), save\n+\tthe declarations from the unused loops by merging the block\n+\tscope for each; this ensures that the temporary is declared.\n+\n 2006-11-04  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* error.c (show_locus): Add trailing colon in error messages."}, {"sha": "52c0b5f5adbb2c4ce5c639ab79a92bdaa235c2e8", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -896,6 +896,13 @@ gfc_init_builtin_functions (void)\n \t\t      BUILT_IN_COPYSIGN, \"copysign\", true);\n   gfc_define_builtin (\"__builtin_copysignf\", mfunc_float[1], \n \t\t      BUILT_IN_COPYSIGNF, \"copysignf\", true);\n+ \n+  gfc_define_builtin (\"__builtin_fmodl\", mfunc_longdouble[1], \n+\t\t      BUILT_IN_FMODL, \"fmodl\", true);\n+  gfc_define_builtin (\"__builtin_fmod\", mfunc_double[1], \n+\t\t      BUILT_IN_FMOD, \"fmod\", true);\n+  gfc_define_builtin (\"__builtin_fmodf\", mfunc_float[1], \n+\t\t      BUILT_IN_FMODF, \"fmodf\", true);\n \n   /* These are used to implement the ** operator.  */\n   gfc_define_builtin (\"__builtin_powl\", mfunc_longdouble[1], "}, {"sha": "9e44bfd34352241906710d99463a57e903c0fbc1", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -1715,9 +1715,14 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n     }\n   else\n     {\n-      /* Make sure that the temporary declaration survives.  */\n-      tmp = gfc_finish_block (&body);\n-      gfc_add_expr_to_block (&loop.pre, tmp);\n+      /* Make sure that the temporary declaration survives by merging\n+       all the loop declarations into the current context.  */\n+      for (n = 0; n < loop.dimen; n++)\n+\t{\n+\t  gfc_merge_block_scope (&body);\n+\t  body = loop.code[loop.order[n]];\n+\t}\n+      gfc_merge_block_scope (&body);\n     }\n \n   /* Add the post block after the second loop, so that any"}, {"sha": "5389c0b3708e0b5c4083f5f739963286bf5703c8", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -976,26 +976,85 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n   int n, ikind;\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n \n   switch (expr->ts.type)\n     {\n     case BT_INTEGER:\n       /* Integer case is easy, we've got a builtin op.  */\n+      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+      arg = TREE_VALUE (arg);\n+      type = TREE_TYPE (arg);\n+\n       if (modulo)\n        se->expr = build2 (FLOOR_MOD_EXPR, type, arg, arg2);\n       else\n        se->expr = build2 (TRUNC_MOD_EXPR, type, arg, arg2);\n       break;\n \n     case BT_REAL:\n-      /* Real values we have to do the hard way.  */\n+      n = END_BUILTINS;\n+      /* Check if we have a builtin fmod.  */\n+      switch (expr->ts.kind)\n+\t{\n+\tcase 4:\n+\t  n = BUILT_IN_FMODF;\n+\t  break;\n+\n+\tcase 8:\n+\t  n = BUILT_IN_FMOD;\n+\t  break;\n+\n+\tcase 10:\n+\tcase 16:\n+\t  n = BUILT_IN_FMODL;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* Use it if it exists.  */\n+      if (n != END_BUILTINS)\n+\t{\n+\t  tmp = built_in_decls[n];\n+\t  se->expr = build_function_call_expr (tmp, arg);\n+\t  if (modulo == 0)\n+\t    return;\n+\t}\n+\n+      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+      arg = TREE_VALUE (arg);\n+      type = TREE_TYPE (arg);\n+\n       arg = gfc_evaluate_now (arg, &se->pre);\n       arg2 = gfc_evaluate_now (arg2, &se->pre);\n \n+      /* Definition:\n+\t modulo = arg - floor (arg/arg2) * arg2, so\n+\t\t= test ? fmod (arg, arg2) : fmod (arg, arg2) + arg2, \n+\t where\n+\t  test  = (fmod (arg, arg2) != 0) && ((arg < 0) xor (arg2 < 0))\n+\t thereby avoiding another division and retaining the accuracy\n+\t of the builtin function.  */\n+      if (n != END_BUILTINS && modulo)\n+\t{\n+\t  tree zero = gfc_build_const (type, integer_zero_node);\n+\t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n+\t  test = build2 (LT_EXPR, boolean_type_node, arg, zero);\n+\t  test2 = build2 (LT_EXPR, boolean_type_node, arg2, zero);\n+\t  test2 = build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n+\t  test = build2 (NE_EXPR, boolean_type_node, tmp, zero);\n+\t  test = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+\t  test = gfc_evaluate_now (test, &se->pre);\n+\t  se->expr = build3 (COND_EXPR, type, test,\n+\t\t\t     build2 (PLUS_EXPR, type, tmp, arg2), tmp);\n+\t  return;\n+\t}\n+\n+      /* If we do not have a built_in fmod, the calculation is going to\n+\t have to be done longhand.  */\n       tmp = build2 (RDIV_EXPR, type, arg, arg2);\n+\n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n       mpfr_init (huge);"}, {"sha": "8d4b189f87a16fe97024ee644498fa52dd62442b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -1,3 +1,8 @@\n+2006-11-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29565\n+\t* gfortran.dg/gfortran.dg/aliasing_dummy_3.f90: New test.\n+\n 2006-11-04  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* lib/gfortran-dg.exp (gfortran-dg-test): Adjust pattern"}, {"sha": "f09028062d10300c978168ff67905efd99aae40f", "filename": "gcc/testsuite/gfortran.dg/aliasing_dummy_3.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b6e04789a04563418234e753835ee6248bf4d8/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_3.f90?ref=58b6e04789a04563418234e753835ee6248bf4d8", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! This tests the fix for PR29565, which failed in the gimplifier\n+! with the third call to has_read_key because this lost the first\n+! temporary array declaration from the current context.\n+!\n+! Contributed by William Mitchell  <william.mitchell@nist.gov>\n+!\n+  type element_t\n+    integer :: gid\n+  end type element_t\n+\n+  type(element_t) :: element(1)\n+   call hash_read_key(element%gid)\n+   call hash_read_key(element%gid)\n+   call hash_read_key(element%gid)\n+contains\n+  subroutine hash_read_key(key)\n+    integer, intent(out) :: key(1)\n+  end subroutine hash_read_key\n+end"}]}