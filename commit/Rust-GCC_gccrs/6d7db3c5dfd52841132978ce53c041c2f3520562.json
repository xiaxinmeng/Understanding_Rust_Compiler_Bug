{"sha": "6d7db3c5dfd52841132978ce53c041c2f3520562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3ZGIzYzVkZmQ1Mjg0MTEzMjk3OGNlNTNjMDQxYzJmMzUyMDU2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-07-27T07:39:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-07-27T07:39:09Z"}, "message": "expr.h (store_bit_field): Don't return a value.\n\ngcc/\n\t* expr.h (store_bit_field): Don't return a value.\n\t* expmed.c (check_predicate_volatile_ok): New function.\n\t(store_bit_field_1): New function, extracted from store_bit_field.\n\tTake a fallback_p argument and return true if the operation succeeded.\n\tOnly use store_fixed_bit_field if fallback_p.  Don't recompute\n\tmode_for_extraction; use op_mode instead.  Try forcing memories\n\tinto registers if the insv expander fails.\n\t(store_bit_field): Use store_bit_field_1 with fallback_p true.\n\tDon't return a value.\n\t(convert_extracted_bit_field): New function, extracted from\n\tstore_bit_field.\n\t(extract_bit_field_1): Likewise.  Take a fallback_p argument\n\tand return NULL if the operation succeeded.  Only use\n\textract_fixed_bit_field if fallback_p.  Only calculate one\n\textraction mode.  Combine code for extv and extzv.  Try forcing\n\tmemories into registers if the ext(z)v expander fails.\n\t(extract_bit_field): Use extract_bit_field_1 with fallback_p true.\n\ngcc/testsuite/\n\t* gcc.target/mips/ins-1.c: New test.\n\nFrom-SVN: r126972", "tree": {"sha": "8ce86442f4e4bba58a4e2f1291077a1a62140ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce86442f4e4bba58a4e2f1291077a1a62140ae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d7db3c5dfd52841132978ce53c041c2f3520562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7db3c5dfd52841132978ce53c041c2f3520562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7db3c5dfd52841132978ce53c041c2f3520562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7db3c5dfd52841132978ce53c041c2f3520562/comments", "author": null, "committer": null, "parents": [{"sha": "ab34041dfea64dec723185694ad33af0b8d76f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab34041dfea64dec723185694ad33af0b8d76f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab34041dfea64dec723185694ad33af0b8d76f78"}], "stats": {"total": 734, "additions": 346, "deletions": 388}, "files": [{"sha": "8b2c452618041138125de6380197caef4a1ff9ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d7db3c5dfd52841132978ce53c041c2f3520562", "patch": "@@ -1,3 +1,23 @@\n+2007-07-27  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* expr.h (store_bit_field): Don't return a value.\n+\t* expmed.c (check_predicate_volatile_ok): New function.\n+\t(store_bit_field_1): New function, extracted from store_bit_field.\n+\tTake a fallback_p argument and return true if the operation succeeded.\n+\tOnly use store_fixed_bit_field if fallback_p.  Don't recompute\n+\tmode_for_extraction; use op_mode instead.  Try forcing memories\n+\tinto registers if the insv expander fails.\n+\t(store_bit_field): Use store_bit_field_1 with fallback_p true.\n+\tDon't return a value.\n+\t(convert_extracted_bit_field): New function, extracted from\n+\tstore_bit_field.\n+\t(extract_bit_field_1): Likewise.  Take a fallback_p argument\n+\tand return NULL if the operation succeeded.  Only use\n+\textract_fixed_bit_field if fallback_p.  Only calculate one\n+\textraction mode.  Combine code for extv and extzv.  Try forcing\n+\tmemories into registers if the ext(z)v expander fails.\n+\t(extract_bit_field): Use extract_bit_field_1 with fallback_p true.\n+\n 2007-07-27  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* df.h (df_mw_hardreg): Turn df_ref_type and df_ref_flags"}, {"sha": "4f8c58d0f4d68e52486d57cab6824ad3b0cbfec2", "filename": "gcc/expmed.c", "status": "modified", "additions": 304, "deletions": 386, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6d7db3c5dfd52841132978ce53c041c2f3520562", "patch": "@@ -327,26 +327,33 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n   return data->operand[opno].mode;\n }\n \n-\f\n-/* Generate code to store value from rtx VALUE\n-   into a bit-field within structure STR_RTX\n-   containing BITSIZE bits starting at bit BITNUM.\n-   FIELDMODE is the machine-mode of the FIELD_DECL node for this field.\n-   ALIGN is the alignment that STR_RTX is known to have.\n-   TOTAL_SIZE is the size of the structure in bytes, or -1 if varying.  */\n+/* Return true if X, of mode MODE, matches the predicate for operand\n+   OPNO of instruction ICODE.  Allow volatile memories, regardless of\n+   the ambient volatile_ok setting.  */\n \n-/* ??? Note that there are two different ideas here for how\n-   to determine the size to count bits within, for a register.\n-   One is BITS_PER_WORD, and the other is the size of operand 3\n-   of the insv pattern.\n+static bool\n+check_predicate_volatile_ok (enum insn_code icode, int opno,\n+\t\t\t     rtx x, enum machine_mode mode)\n+{\n+  bool save_volatile_ok, result;\n \n-   If operand 3 of the insv pattern is VOIDmode, then we will use BITS_PER_WORD\n-   else, we use the mode of operand 3.  */\n+  save_volatile_ok = volatile_ok;\n+  result = insn_data[(int) icode].operand[opno].predicate (x, mode);\n+  volatile_ok = save_volatile_ok;\n+  return result;\n+}\n+\f\n+/* A subroutine of store_bit_field, with the same arguments.  Return true\n+   if the operation could be implemented.\n \n-rtx\n-store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n-\t\t rtx value)\n+   If FALLBACK_P is true, fall back to store_fixed_bit_field if we have\n+   no other way of implementing the operation.  If FALLBACK_P is false,\n+   return false instead.  */\n+\n+static bool\n+store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t   unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n+\t\t   rtx value, bool fallback_p)\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -390,7 +397,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      lies completely outside that register.  This can occur if the source\n      code contains an out-of-bounds access to a small array.  */\n   if (REG_P (op0) && bitnum >= GET_MODE_BITSIZE (GET_MODE (op0)))\n-    return value;\n+    return true;\n \n   /* Use vec_set patterns for inserting parts of vectors whenever\n      available.  */\n@@ -434,7 +441,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  emit_insn (seq);\n \t  emit_insn (pat);\n-\t  return dest;\n+\t  return true;\n \t}\n     }\n \n@@ -466,7 +473,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \top0 = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n \t\t\t\t   byte_offset);\n       emit_move_insn (op0, value);\n-      return value;\n+      return true;\n     }\n \n   /* Make sure we are playing with integral modes.  Pun with subregs\n@@ -543,7 +550,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t  + (offset * UNITS_PER_WORD)),\n \t\t\t\t  value));\n \n-      return value;\n+      return true;\n     }\n \n   /* Handle fields bigger than a word.  */\n@@ -559,6 +566,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned int backwards = WORDS_BIG_ENDIAN && fieldmode != BLKmode;\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n+      rtx last;\n \n       /* This is the mode we must force value to, so that there will be enough\n \t subwords to extract.  Note that fieldmode will often (always?) be\n@@ -569,6 +577,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (fieldmode == VOIDmode)\n \tfieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);\n \n+      last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n \t{\n \t  /* If I is 0, use the low-order word in both field and target;\n@@ -579,13 +588,18 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\t    * BITS_PER_WORD,\n \t\t\t\t\t    0)\n \t\t\t\t     : (int) i * BITS_PER_WORD);\n+\t  rtx value_word = operand_subword_force (value, wordnum, fieldmode);\n \n-\t  store_bit_field (op0, MIN (BITS_PER_WORD,\n-\t\t\t\t     bitsize - i * BITS_PER_WORD),\n-\t\t\t   bitnum + bit_offset, word_mode,\n-\t\t\t   operand_subword_force (value, wordnum, fieldmode));\n+\t  if (!store_bit_field_1 (op0, MIN (BITS_PER_WORD,\n+\t\t\t\t\t    bitsize - i * BITS_PER_WORD),\n+\t\t\t\t  bitnum + bit_offset, word_mode,\n+\t\t\t\t  value_word, fallback_p))\n+\t    {\n+\t      delete_insns_since (last);\n+\t      return false;\n+\t    }\n \t}\n-      return value;\n+      return true;\n     }\n \n   /* From here on we can assume that the field to be stored in is\n@@ -639,74 +653,27 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n \t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode)))\n       && insn_data[CODE_FOR_insv].operand[1].predicate (GEN_INT (bitsize),\n-\t\t\t\t\t\t\tVOIDmode))\n+\t\t\t\t\t\t\tVOIDmode)\n+      && check_predicate_volatile_ok (CODE_FOR_insv, 0, op0, VOIDmode))\n     {\n       int xbitpos = bitpos;\n       rtx value1;\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n       rtx pat;\n-      enum machine_mode maxmode = mode_for_extraction (EP_insv, 3);\n-      int save_volatile_ok = volatile_ok;\n-\n-      volatile_ok = 1;\n-\n-      /* If this machine's insv can only insert into a register, copy OP0\n-\t into a register and save it back later.  */\n-      if (MEM_P (op0)\n-\t  && ! ((*insn_data[(int) CODE_FOR_insv].operand[0].predicate)\n-\t\t(op0, VOIDmode)))\n-\t{\n-\t  rtx tempreg;\n-\t  enum machine_mode bestmode;\n-\n-\t  /* Get the mode to use for inserting into this field.  If OP0 is\n-\t     BLKmode, get the smallest mode consistent with the alignment. If\n-\t     OP0 is a non-BLKmode object that is no wider than MAXMODE, use its\n-\t     mode. Otherwise, use the smallest mode containing the field.  */\n-\n-\t  if (GET_MODE (op0) == BLKmode\n-\t      || GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (maxmode))\n-\t    bestmode\n-\t      = get_best_mode (bitsize, bitnum, MEM_ALIGN (op0), maxmode,\n-\t\t\t       MEM_VOLATILE_P (op0));\n-\t  else\n-\t    bestmode = GET_MODE (op0);\n-\n-\t  if (bestmode == VOIDmode\n-\t      || GET_MODE_SIZE (bestmode) < GET_MODE_SIZE (fieldmode)\n-\t      || (SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n-\t\t  && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n-\t    goto insv_loses;\n-\n-\t  /* Adjust address to point to the containing unit of that mode.\n-\t     Compute offset as multiple of this unit, counting in bytes.  */\n-\t  unit = GET_MODE_BITSIZE (bestmode);\n-\t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t  bitpos = bitnum % unit;\n-\t  op0 = adjust_address (op0, bestmode,  offset);\n-\n-\t  /* Fetch that unit, store the bitfield in it, then store\n-\t     the unit.  */\n-\t  tempreg = copy_to_reg (op0);\n-\t  store_bit_field (tempreg, bitsize, bitpos, fieldmode, orig_value);\n-\t  emit_move_insn (op0, tempreg);\n-\t  return value;\n-\t}\n-      volatile_ok = save_volatile_ok;\n \n       /* Add OFFSET into OP0's address.  */\n       if (MEM_P (xop0))\n \txop0 = adjust_address (xop0, byte_mode, offset);\n \n-      /* If xop0 is a register, we need it in MAXMODE\n+      /* If xop0 is a register, we need it in OP_MODE\n \t to make it acceptable to the format of insv.  */\n       if (GET_CODE (xop0) == SUBREG)\n \t/* We can't just change the mode, because this might clobber op0,\n \t   and we will need the original value of op0 if insv fails.  */\n-\txop0 = gen_rtx_SUBREG (maxmode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n-      if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n-\txop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n+\txop0 = gen_rtx_SUBREG (op_mode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n+      if (REG_P (xop0) && GET_MODE (xop0) != op_mode)\n+\txop0 = gen_rtx_SUBREG (op_mode, xop0, 0);\n \n       /* On big-endian machines, we count bits from the most significant.\n \t If the bit field insn does not, we must invert.  */\n@@ -717,37 +684,37 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       /* We have been counting XBITPOS within UNIT.\n \t Count instead within the size of the register.  */\n       if (BITS_BIG_ENDIAN && !MEM_P (xop0))\n-\txbitpos += GET_MODE_BITSIZE (maxmode) - unit;\n+\txbitpos += GET_MODE_BITSIZE (op_mode) - unit;\n \n-      unit = GET_MODE_BITSIZE (maxmode);\n+      unit = GET_MODE_BITSIZE (op_mode);\n \n-      /* Convert VALUE to maxmode (which insv insn wants) in VALUE1.  */\n+      /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */\n       value1 = value;\n-      if (GET_MODE (value) != maxmode)\n+      if (GET_MODE (value) != op_mode)\n \t{\n \t  if (GET_MODE_BITSIZE (GET_MODE (value)) >= bitsize)\n \t    {\n \t      /* Optimization: Don't bother really extending VALUE\n \t\t if it has all the bits we will actually use.  However,\n \t\t if we must narrow it, be sure we do it correctly.  */\n \n-\t      if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (maxmode))\n+\t      if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (op_mode))\n \t\t{\n \t\t  rtx tmp;\n \n-\t\t  tmp = simplify_subreg (maxmode, value1, GET_MODE (value), 0);\n+\t\t  tmp = simplify_subreg (op_mode, value1, GET_MODE (value), 0);\n \t\t  if (! tmp)\n-\t\t    tmp = simplify_gen_subreg (maxmode,\n+\t\t    tmp = simplify_gen_subreg (op_mode,\n \t\t\t\t\t       force_reg (GET_MODE (value),\n \t\t\t\t\t\t\t  value1),\n \t\t\t\t\t       GET_MODE (value), 0);\n \t\t  value1 = tmp;\n \t\t}\n \t      else\n-\t\tvalue1 = gen_lowpart (maxmode, value1);\n+\t\tvalue1 = gen_lowpart (op_mode, value1);\n \t    }\n \t  else if (GET_CODE (value) == CONST_INT)\n-\t    value1 = gen_int_mode (INTVAL (value), maxmode);\n+\t    value1 = gen_int_mode (INTVAL (value), op_mode);\n \t  else\n \t    /* Parse phase is supposed to make VALUE's data type\n \t       match that of the component reference, which is a type\n@@ -759,23 +726,89 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       /* If this machine's insv insists on a register,\n \t get VALUE1 into a register.  */\n       if (! ((*insn_data[(int) CODE_FOR_insv].operand[3].predicate)\n-\t     (value1, maxmode)))\n-\tvalue1 = force_reg (maxmode, value1);\n+\t     (value1, op_mode)))\n+\tvalue1 = force_reg (op_mode, value1);\n \n       pat = gen_insv (xop0, GEN_INT (bitsize), GEN_INT (xbitpos), value1);\n       if (pat)\n-\temit_insn (pat);\n+\t{\n+\t  emit_insn (pat);\n+\t  return true;\n+\t}\n+      delete_insns_since (last);\n+    }\n+\n+  /* If OP0 is a memory, try copying it to a register and seeing if a\n+     cheap register alternative is available.  */\n+  if (HAVE_insv && MEM_P (op0))\n+    {\n+      enum machine_mode bestmode;\n+\n+      /* Get the mode to use for inserting into this field.  If OP0 is\n+\t BLKmode, get the smallest mode consistent with the alignment. If\n+\t OP0 is a non-BLKmode object that is no wider than OP_MODE, use its\n+\t mode. Otherwise, use the smallest mode containing the field.  */\n+\n+      if (GET_MODE (op0) == BLKmode\n+\t  || (op_mode != MAX_MACHINE_MODE\n+\t      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (op_mode)))\n+\tbestmode = get_best_mode (bitsize, bitnum, MEM_ALIGN (op0),\n+\t\t\t\t  (op_mode == MAX_MACHINE_MODE\n+\t\t\t\t   ? VOIDmode : op_mode),\n+\t\t\t\t  MEM_VOLATILE_P (op0));\n       else\n+\tbestmode = GET_MODE (op0);\n+\n+      if (bestmode != VOIDmode\n+\t  && GET_MODE_SIZE (bestmode) >= GET_MODE_SIZE (fieldmode)\n+\t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n+\t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t{\n+\t  rtx last, tempreg, xop0;\n+\t  unsigned HOST_WIDE_INT xoffset, xbitpos;\n+\n+\t  last = get_last_insn ();\n+\n+\t  /* Adjust address to point to the containing unit of\n+\t     that mode.  Compute the offset as a multiple of this unit,\n+\t     counting in bytes.  */\n+\t  unit = GET_MODE_BITSIZE (bestmode);\n+\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n+\t  xbitpos = bitnum % unit;\n+\t  xop0 = adjust_address (op0, bestmode, xoffset);\n+\n+\t  /* Fetch that unit, store the bitfield in it, then store\n+\t     the unit.  */\n+\t  tempreg = copy_to_reg (xop0);\n+\t  if (store_bit_field_1 (tempreg, bitsize, xbitpos,\n+\t\t\t\t fieldmode, orig_value, false))\n+\t    {\n+\t      emit_move_insn (xop0, tempreg);\n+\t      return true;\n+\t    }\n \t  delete_insns_since (last);\n-\t  store_fixed_bit_field (op0, offset, bitsize, bitpos, value);\n \t}\n     }\n-  else\n-    insv_loses:\n-    /* Insv is not available; store using shifts and boolean ops.  */\n-    store_fixed_bit_field (op0, offset, bitsize, bitpos, value);\n-  return value;\n+\n+  if (!fallback_p)\n+    return false;\n+\n+  store_fixed_bit_field (op0, offset, bitsize, bitpos, value);\n+  return true;\n+}\n+\n+/* Generate code to store value from rtx VALUE\n+   into a bit-field within structure STR_RTX\n+   containing BITSIZE bits starting at bit BITNUM.\n+   FIELDMODE is the machine-mode of the FIELD_DECL node for this field.  */\n+\n+void\n+store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n+\t\t rtx value)\n+{\n+  if (!store_bit_field_1 (str_rtx, bitsize, bitnum, fieldmode, value, true))\n+    gcc_unreachable ();\n }\n \f\n /* Use shifts and boolean operations to store VALUE\n@@ -1067,40 +1100,52 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     }\n }\n \f\n-/* Generate code to extract a byte-field from STR_RTX\n-   containing BITSIZE bits, starting at BITNUM,\n-   and put it in TARGET if possible (if TARGET is nonzero).\n-   Regardless of TARGET, we return the rtx for where the value is placed.\n+/* A subroutine of extract_bit_field_1 that converts return value X\n+   to either MODE or TMODE.  MODE, TMODE and UNSIGNEDP are arguments\n+   to extract_bit_field.  */\n \n-   STR_RTX is the structure containing the byte (a REG or MEM).\n-   UNSIGNEDP is nonzero if this is an unsigned bit field.\n-   MODE is the natural mode of the field value once extracted.\n-   TMODE is the mode the caller would like the value to have;\n-   but the value may be returned with type MODE instead.\n+static rtx\n+convert_extracted_bit_field (rtx x, enum machine_mode mode,\n+\t\t\t     enum machine_mode tmode, bool unsignedp)\n+{\n+  if (GET_MODE (x) == tmode || GET_MODE (x) == mode)\n+    return x;\n \n-   TOTAL_SIZE is the size in bytes of the containing structure,\n-   or -1 if varying.\n+  /* If the x mode is not a scalar integral, first convert to the\n+     integer mode of that size and then access it as a floating-point\n+     value via a SUBREG.  */\n+  if (!SCALAR_INT_MODE_P (tmode))\n+    {\n+      enum machine_mode smode;\n \n-   If a TARGET is specified and we can store in it at no extra cost,\n-   we do so, and return TARGET.\n-   Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred\n-   if they are equally easy.  */\n+      smode = mode_for_size (GET_MODE_BITSIZE (tmode), MODE_INT, 0);\n+      x = convert_to_mode (smode, x, unsignedp);\n+      x = force_reg (smode, x);\n+      return gen_lowpart (tmode, x);\n+    }\n \n-rtx\n-extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   enum machine_mode mode, enum machine_mode tmode)\n+  return convert_to_mode (tmode, x, unsignedp);\n+}\n+\n+/* A subroutine of extract_bit_field, with the same arguments.\n+   If FALLBACK_P is true, fall back to extract_fixed_bit_field\n+   if we can find no other means of implementing the operation.\n+   if FALLBACK_P is false, return NULL instead.  */\n+\n+static rtx\n+extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n+\t\t     enum machine_mode mode, enum machine_mode tmode,\n+\t\t     bool fallback_p)\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n   unsigned HOST_WIDE_INT offset, bitpos;\n   rtx op0 = str_rtx;\n-  rtx spec_target = target;\n-  rtx spec_target_subreg = 0;\n   enum machine_mode int_mode;\n-  enum machine_mode extv_mode = mode_for_extraction (EP_extv, 0);\n-  enum machine_mode extzv_mode = mode_for_extraction (EP_extzv, 0);\n+  enum machine_mode ext_mode;\n   enum machine_mode mode1;\n+  enum insn_code icode;\n   int byte_offset;\n \n   if (tmode == VOIDmode)\n@@ -1409,299 +1454,172 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     }\n \n   /* Now OFFSET is nonzero only for memory operands.  */\n-\n-  if (unsignedp)\n+  ext_mode = mode_for_extraction (unsignedp ? EP_extzv : EP_extv, 0);\n+  icode = unsignedp ? CODE_FOR_extzv : CODE_FOR_extv;\n+  if (ext_mode != MAX_MACHINE_MODE\n+      && bitsize > 0\n+      && GET_MODE_BITSIZE (ext_mode) >= bitsize\n+      /* If op0 is a register, we need it in EXT_MODE to make it\n+\t acceptable to the format of ext(z)v.  */\n+      && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)\n+      && !((REG_P (op0) || GET_CODE (op0) == SUBREG)\n+\t   && (bitsize + bitpos > GET_MODE_BITSIZE (ext_mode)))\n+      && check_predicate_volatile_ok (icode, 1, op0, GET_MODE (op0)))\n     {\n-      if (HAVE_extzv\n-\t  && bitsize > 0\n-\t  && GET_MODE_BITSIZE (extzv_mode) >= bitsize\n-\t  && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extzv_mode))))\n-\t{\n-\t  unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n-\t  rtx bitsize_rtx, bitpos_rtx;\n-\t  rtx last = get_last_insn ();\n-\t  rtx xop0 = op0;\n-\t  rtx xtarget = target;\n-\t  rtx xspec_target = spec_target;\n-\t  rtx xspec_target_subreg = spec_target_subreg;\n-\t  rtx pat;\n-\t  enum machine_mode maxmode = mode_for_extraction (EP_extzv, 0);\n-\n-\t  if (MEM_P (xop0))\n-\t    {\n-\t      int save_volatile_ok = volatile_ok;\n-\t      volatile_ok = 1;\n-\n-\t      /* Is the memory operand acceptable?  */\n-\t      if (! ((*insn_data[(int) CODE_FOR_extzv].operand[1].predicate)\n-\t\t     (xop0, GET_MODE (xop0))))\n-\t\t{\n-\t\t  /* No, load into a reg and extract from there.  */\n-\t\t  enum machine_mode bestmode;\n-\n-\t\t  /* Get the mode to use for inserting into this field.  If\n-\t\t     OP0 is BLKmode, get the smallest mode consistent with the\n-\t\t     alignment. If OP0 is a non-BLKmode object that is no\n-\t\t     wider than MAXMODE, use its mode. Otherwise, use the\n-\t\t     smallest mode containing the field.  */\n-\n-\t\t  if (GET_MODE (xop0) == BLKmode\n-\t\t      || (GET_MODE_SIZE (GET_MODE (op0))\n-\t\t\t  > GET_MODE_SIZE (maxmode)))\n-\t\t    bestmode = get_best_mode (bitsize, bitnum,\n-\t\t\t\t\t      MEM_ALIGN (xop0), maxmode,\n-\t\t\t\t\t      MEM_VOLATILE_P (xop0));\n-\t\t  else\n-\t\t    bestmode = GET_MODE (xop0);\n-\n-\t\t  if (bestmode == VOIDmode\n-\t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (xop0))\n-\t\t\t  && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (xop0)))\n-\t\t    goto extzv_loses;\n-\n-\t\t  /* Compute offset as multiple of this unit,\n-\t\t     counting in bytes.  */\n-\t\t  unit = GET_MODE_BITSIZE (bestmode);\n-\t\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t\t  xbitpos = bitnum % unit;\n-\t\t  xop0 = adjust_address (xop0, bestmode, xoffset);\n-\n-\t\t  /* Make sure register is big enough for the whole field. */\n-\t\t  if (xoffset * BITS_PER_UNIT + unit \n-\t\t      < offset * BITS_PER_UNIT + bitsize)\n-\t\t    goto extzv_loses;\n-\n-\t\t  /* Fetch it to a register in that size.  */\n-\t\t  xop0 = force_reg (bestmode, xop0);\n-\n-\t\t  /* XBITPOS counts within UNIT, which is what is expected.  */\n-\t\t}\n-\t      else\n-\t\t/* Get ref to first byte containing part of the field.  */\n-\t\txop0 = adjust_address (xop0, byte_mode, xoffset);\n-\n-\t      volatile_ok = save_volatile_ok;\n-\t    }\n+      unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n+      rtx bitsize_rtx, bitpos_rtx;\n+      rtx last = get_last_insn ();\n+      rtx xop0 = op0;\n+      rtx xtarget = target;\n+      rtx xspec_target = target;\n+      rtx xspec_target_subreg = 0;\n+      rtx pat;\n \n-\t  /* If op0 is a register, we need it in MAXMODE (which is usually\n-\t     SImode). to make it acceptable to the format of extzv.  */\n-\t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n-\t    goto extzv_loses;\n-\t  if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n-\t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n+      /* If op0 is a register, we need it in EXT_MODE to make it\n+\t acceptable to the format of ext(z)v.  */\n+      if (REG_P (xop0) && GET_MODE (xop0) != ext_mode)\n+\txop0 = gen_rtx_SUBREG (ext_mode, xop0, 0);\n+      if (MEM_P (xop0))\n+\t/* Get ref to first byte containing part of the field.  */\n+\txop0 = adjust_address (xop0, byte_mode, xoffset);\n \n-\t  /* On big-endian machines, we count bits from the most significant.\n-\t     If the bit field insn does not, we must invert.  */\n-\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\t    xbitpos = unit - bitsize - xbitpos;\n+      /* On big-endian machines, we count bits from the most significant.\n+\t If the bit field insn does not, we must invert.  */\n+      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\txbitpos = unit - bitsize - xbitpos;\n \n-\t  /* Now convert from counting within UNIT to counting in MAXMODE.  */\n-\t  if (BITS_BIG_ENDIAN && !MEM_P (xop0))\n-\t    xbitpos += GET_MODE_BITSIZE (maxmode) - unit;\n+      /* Now convert from counting within UNIT to counting in EXT_MODE.  */\n+      if (BITS_BIG_ENDIAN && !MEM_P (xop0))\n+\txbitpos += GET_MODE_BITSIZE (ext_mode) - unit;\n \n-\t  unit = GET_MODE_BITSIZE (maxmode);\n+      unit = GET_MODE_BITSIZE (ext_mode);\n \n-\t  if (xtarget == 0)\n-\t    xtarget = xspec_target = gen_reg_rtx (tmode);\n+      if (xtarget == 0)\n+\txtarget = xspec_target = gen_reg_rtx (tmode);\n \n-\t  if (GET_MODE (xtarget) != maxmode)\n+      if (GET_MODE (xtarget) != ext_mode)\n+\t{\n+\t  if (REG_P (xtarget))\n \t    {\n-\t      if (REG_P (xtarget))\n-\t\t{\n-\t\t  int wider = (GET_MODE_SIZE (maxmode)\n-\t\t\t       > GET_MODE_SIZE (GET_MODE (xtarget)));\n-\t\t  xtarget = gen_lowpart (maxmode, xtarget);\n-\t\t  if (wider)\n-\t\t    xspec_target_subreg = xtarget;\n-\t\t}\n-\t      else\n-\t\txtarget = gen_reg_rtx (maxmode);\n+\t      xtarget = gen_lowpart (ext_mode, xtarget);\n+\t      if (GET_MODE_SIZE (ext_mode)\n+\t\t  > GET_MODE_SIZE (GET_MODE (xspec_target)))\n+\t\txspec_target_subreg = xtarget;\n \t    }\n+\t  else\n+\t    xtarget = gen_reg_rtx (ext_mode);\n+\t}\n \n-\t  /* If this machine's extzv insists on a register target,\n-\t     make sure we have one.  */\n-\t  if (! ((*insn_data[(int) CODE_FOR_extzv].operand[0].predicate)\n-\t\t (xtarget, maxmode)))\n-\t    xtarget = gen_reg_rtx (maxmode);\n+      /* If this machine's ext(z)v insists on a register target,\n+\t make sure we have one.  */\n+      if (!insn_data[(int) icode].operand[0].predicate (xtarget, ext_mode))\n+\txtarget = gen_reg_rtx (ext_mode);\n \n-\t  bitsize_rtx = GEN_INT (bitsize);\n-\t  bitpos_rtx = GEN_INT (xbitpos);\n+      bitsize_rtx = GEN_INT (bitsize);\n+      bitpos_rtx = GEN_INT (xbitpos);\n \n-\t  pat = gen_extzv (xtarget, xop0, bitsize_rtx, bitpos_rtx);\n-\t  if (pat)\n-\t    {\n-\t      emit_insn (pat);\n-\t      target = xtarget;\n-\t      spec_target = xspec_target;\n-\t      spec_target_subreg = xspec_target_subreg;\n-\t    }\n-\t  else\n-\t    {\n-\t      delete_insns_since (last);\n-\t      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t\t\tbitpos, target, 1);\n-\t    }\n+      pat = (unsignedp\n+\t     ? gen_extzv (xtarget, xop0, bitsize_rtx, bitpos_rtx)\n+\t     : gen_extv (xtarget, xop0, bitsize_rtx, bitpos_rtx));\n+      if (pat)\n+\t{\n+\t  emit_insn (pat);\n+\t  if (xtarget == xspec_target)\n+\t    return xtarget;\n+\t  if (xtarget == xspec_target_subreg)\n+\t    return xspec_target;\n+\t  return convert_extracted_bit_field (xtarget, mode, tmode, unsignedp);\n \t}\n-      else\n-      extzv_loses:\n-\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t\t  bitpos, target, 1);\n+      delete_insns_since (last);\n     }\n-  else\n-    {\n-      if (HAVE_extv\n-\t  && bitsize > 0\n-\t  && GET_MODE_BITSIZE (extv_mode) >= bitsize\n-\t  && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extv_mode))))\n-\t{\n-\t  int xbitpos = bitpos, xoffset = offset;\n-\t  rtx bitsize_rtx, bitpos_rtx;\n-\t  rtx last = get_last_insn ();\n-\t  rtx xop0 = op0, xtarget = target;\n-\t  rtx xspec_target = spec_target;\n-\t  rtx xspec_target_subreg = spec_target_subreg;\n-\t  rtx pat;\n-\t  enum machine_mode maxmode = mode_for_extraction (EP_extv, 0);\n-\n-\t  if (MEM_P (xop0))\n-\t    {\n-\t      /* Is the memory operand acceptable?  */\n-\t      if (! ((*insn_data[(int) CODE_FOR_extv].operand[1].predicate)\n-\t\t     (xop0, GET_MODE (xop0))))\n-\t\t{\n-\t\t  /* No, load into a reg and extract from there.  */\n-\t\t  enum machine_mode bestmode;\n-\n-\t\t  /* Get the mode to use for inserting into this field.  If\n-\t\t     OP0 is BLKmode, get the smallest mode consistent with the\n-\t\t     alignment. If OP0 is a non-BLKmode object that is no\n-\t\t     wider than MAXMODE, use its mode. Otherwise, use the\n-\t\t     smallest mode containing the field.  */\n-\n-\t\t  if (GET_MODE (xop0) == BLKmode\n-\t\t      || (GET_MODE_SIZE (GET_MODE (op0))\n-\t\t\t  > GET_MODE_SIZE (maxmode)))\n-\t\t    bestmode = get_best_mode (bitsize, bitnum,\n-\t\t\t\t\t      MEM_ALIGN (xop0), maxmode,\n-\t\t\t\t\t      MEM_VOLATILE_P (xop0));\n-\t\t  else\n-\t\t    bestmode = GET_MODE (xop0);\n-\n-\t\t  if (bestmode == VOIDmode\n-\t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (xop0))\n-\t\t\t  && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (xop0)))\n-\t\t    goto extv_loses;\n-\n-\t\t  /* Compute offset as multiple of this unit,\n-\t\t     counting in bytes.  */\n-\t\t  unit = GET_MODE_BITSIZE (bestmode);\n-\t\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t\t  xbitpos = bitnum % unit;\n-\t\t  xop0 = adjust_address (xop0, bestmode, xoffset);\n-\n-\t\t  /* Make sure register is big enough for the whole field. */\n-\t\t  if (xoffset * BITS_PER_UNIT + unit \n-\t\t      < offset * BITS_PER_UNIT + bitsize)\n-\t\t    goto extv_loses;\n-\n-\t\t  /* Fetch it to a register in that size.  */\n-\t\t  xop0 = force_reg (bestmode, xop0);\n-\n-\t\t  /* XBITPOS counts within UNIT, which is what is expected.  */\n-\t\t}\n-\t      else\n-\t\t/* Get ref to first byte containing part of the field.  */\n-\t\txop0 = adjust_address (xop0, byte_mode, xoffset);\n-\t    }\n-\n-\t  /* If op0 is a register, we need it in MAXMODE (which is usually\n-\t     SImode) to make it acceptable to the format of extv.  */\n-\t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n-\t    goto extv_loses;\n-\t  if (REG_P (xop0) && GET_MODE (xop0) != maxmode)\n-\t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n-\t  /* On big-endian machines, we count bits from the most significant.\n-\t     If the bit field insn does not, we must invert.  */\n-\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\t    xbitpos = unit - bitsize - xbitpos;\n-\n-\t  /* XBITPOS counts within a size of UNIT.\n-\t     Adjust to count within a size of MAXMODE.  */\n-\t  if (BITS_BIG_ENDIAN && !MEM_P (xop0))\n-\t    xbitpos += (GET_MODE_BITSIZE (maxmode) - unit);\n+  /* If OP0 is a memory, try copying it to a register and seeing if a\n+     cheap register alternative is available.  */\n+  if (ext_mode != MAX_MACHINE_MODE && MEM_P (op0))\n+    {\n+      enum machine_mode bestmode;\n+\n+      /* Get the mode to use for inserting into this field.  If\n+\t OP0 is BLKmode, get the smallest mode consistent with the\n+\t alignment. If OP0 is a non-BLKmode object that is no\n+\t wider than EXT_MODE, use its mode. Otherwise, use the\n+\t smallest mode containing the field.  */\n+\n+      if (GET_MODE (op0) == BLKmode\n+\t  || (ext_mode != MAX_MACHINE_MODE\n+\t      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (ext_mode)))\n+\tbestmode = get_best_mode (bitsize, bitnum, MEM_ALIGN (op0),\n+\t\t\t\t  (ext_mode == MAX_MACHINE_MODE\n+\t\t\t\t   ? VOIDmode : ext_mode),\n+\t\t\t\t  MEM_VOLATILE_P (op0));\n+      else\n+\tbestmode = GET_MODE (op0);\n \n-\t  unit = GET_MODE_BITSIZE (maxmode);\n+      if (bestmode != VOIDmode\n+\t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n+\t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n+\t{\n+\t  unsigned HOST_WIDE_INT xoffset, xbitpos;\n \n-\t  if (xtarget == 0)\n-\t    xtarget = xspec_target = gen_reg_rtx (tmode);\n+\t  /* Compute the offset as a multiple of this unit,\n+\t     counting in bytes.  */\n+\t  unit = GET_MODE_BITSIZE (bestmode);\n+\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n+\t  xbitpos = bitnum % unit;\n \n-\t  if (GET_MODE (xtarget) != maxmode)\n+\t  /* Make sure the register is big enough for the whole field.  */\n+\t  if (xoffset * BITS_PER_UNIT + unit\n+\t      >= offset * BITS_PER_UNIT + bitsize)\n \t    {\n-\t      if (REG_P (xtarget))\n-\t\t{\n-\t\t  int wider = (GET_MODE_SIZE (maxmode)\n-\t\t\t       > GET_MODE_SIZE (GET_MODE (xtarget)));\n-\t\t  xtarget = gen_lowpart (maxmode, xtarget);\n-\t\t  if (wider)\n-\t\t    xspec_target_subreg = xtarget;\n-\t\t}\n-\t      else\n-\t\txtarget = gen_reg_rtx (maxmode);\n-\t    }\n+\t      rtx last, result, xop0;\n \n-\t  /* If this machine's extv insists on a register target,\n-\t     make sure we have one.  */\n-\t  if (! ((*insn_data[(int) CODE_FOR_extv].operand[0].predicate)\n-\t\t (xtarget, maxmode)))\n-\t    xtarget = gen_reg_rtx (maxmode);\n+\t      last = get_last_insn ();\n \n-\t  bitsize_rtx = GEN_INT (bitsize);\n-\t  bitpos_rtx = GEN_INT (xbitpos);\n+\t      /* Fetch it to a register in that size.  */\n+\t      xop0 = adjust_address (op0, bestmode, xoffset);\n+\t      xop0 = force_reg (bestmode, xop0);\n+\t      result = extract_bit_field_1 (xop0, bitsize, xbitpos,\n+\t\t\t\t\t    unsignedp, target,\n+\t\t\t\t\t    mode, tmode, false);\n+\t      if (result)\n+\t\treturn result;\n \n-\t  pat = gen_extv (xtarget, xop0, bitsize_rtx, bitpos_rtx);\n-\t  if (pat)\n-\t    {\n-\t      emit_insn (pat);\n-\t      target = xtarget;\n-\t      spec_target = xspec_target;\n-\t      spec_target_subreg = xspec_target_subreg;\n-\t    }\n-\t  else\n-\t    {\n \t      delete_insns_since (last);\n-\t      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t\t\tbitpos, target, 0);\n \t    }\n \t}\n-      else\n-      extv_loses:\n-\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t\t  bitpos, target, 0);\n     }\n-  if (target == spec_target)\n-    return target;\n-  if (target == spec_target_subreg)\n-    return spec_target;\n-  if (GET_MODE (target) != tmode && GET_MODE (target) != mode)\n-    {\n-      /* If the target mode is not a scalar integral, first convert to the\n-\t integer mode of that size and then access it as a floating-point\n-\t value via a SUBREG.  */\n-      if (!SCALAR_INT_MODE_P (tmode))\n-\t{\n-\t  enum machine_mode smode\n-\t    = mode_for_size (GET_MODE_BITSIZE (tmode), MODE_INT, 0);\n-\t  target = convert_to_mode (smode, target, unsignedp);\n-\t  target = force_reg (smode, target);\n-\t  return gen_lowpart (tmode, target);\n-\t}\n \n-      return convert_to_mode (tmode, target, unsignedp);\n-    }\n-  return target;\n+  if (!fallback_p)\n+    return NULL;\n+\n+  target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n+\t\t\t\t    bitpos, target, unsignedp);\n+  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+}\n+\n+/* Generate code to extract a byte-field from STR_RTX\n+   containing BITSIZE bits, starting at BITNUM,\n+   and put it in TARGET if possible (if TARGET is nonzero).\n+   Regardless of TARGET, we return the rtx for where the value is placed.\n+\n+   STR_RTX is the structure containing the byte (a REG or MEM).\n+   UNSIGNEDP is nonzero if this is an unsigned bit field.\n+   MODE is the natural mode of the field value once extracted.\n+   TMODE is the mode the caller would like the value to have;\n+   but the value may be returned with type MODE instead.\n+\n+   If a TARGET is specified and we can store in it at no extra cost,\n+   we do so, and return TARGET.\n+   Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred\n+   if they are equally easy.  */\n+\n+rtx\n+extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n+\t\t   enum machine_mode mode, enum machine_mode tmode)\n+{\n+  return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n+\t\t\t      target, mode, tmode, true);\n }\n \f\n /* Extract a bit field using shifts and boolean operations"}, {"sha": "64604d75f95a8b72158c288c4fe0753fca3ba90f", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6d7db3c5dfd52841132978ce53c041c2f3520562", "patch": "@@ -731,8 +731,8 @@ enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n extern enum machine_mode\n mode_for_extraction (enum extraction_pattern, int);\n \n-extern rtx store_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t    unsigned HOST_WIDE_INT, enum machine_mode, rtx);\n+extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t     unsigned HOST_WIDE_INT, enum machine_mode, rtx);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n \t\t\t      enum machine_mode, enum machine_mode);"}, {"sha": "50f12361f08933e85f41922c2f66854615fbb2f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d7db3c5dfd52841132978ce53c041c2f3520562", "patch": "@@ -1,3 +1,7 @@\n+2007-07-27  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.target/mips/ins-1.c: New test.\n+\n 2007-07-26  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR/19232"}, {"sha": "abce7d55396887754718bb0cb9d7785b34de6d71", "filename": "gcc/testsuite/gcc.target/mips/ins-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fins-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7db3c5dfd52841132978ce53c041c2f3520562/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fins-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fins-1.c?ref=6d7db3c5dfd52841132978ce53c041c2f3520562", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -march=mips32r2 -mno-mips16\" } */\n+/* { dg-final { scan-assembler \"\\tins\\t\" } } */\n+\n+struct\n+{\n+  unsigned int i : 2;\n+  unsigned int j : 3;\n+  unsigned int k : 4;\n+} s;\n+\n+void\n+foo (void)\n+{\n+  s.j = 1;\n+}"}]}