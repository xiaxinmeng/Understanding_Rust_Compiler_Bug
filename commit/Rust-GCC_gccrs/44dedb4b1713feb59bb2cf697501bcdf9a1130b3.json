{"sha": "44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRkZWRiNGIxNzEzZmViNTliYjJjZjY5NzUwMWJjZGY5YTExMzBiMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-05-09T07:57:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-05-09T07:57:04Z"}, "message": "tree-vrp.c (vrp_int_const_binop): Use wide-ints and simplify.\n\n2017-05-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.c (vrp_int_const_binop): Use wide-ints and simplify.\n\t(extract_range_from_multiplicative_op_1): Adjust.\n\t(extract_range_from_binary_expr_1): Use int_const_binop.\n\nFrom-SVN: r247779", "tree": {"sha": "60a26ca96ee329a169ffc257c872fa8b62b90cd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60a26ca96ee329a169ffc257c872fa8b62b90cd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44dedb4b1713feb59bb2cf697501bcdf9a1130b3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631238ac3f50b42dd55e87cd8bea02c7fbec0f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/631238ac3f50b42dd55e87cd8bea02c7fbec0f53"}], "stats": {"total": 262, "additions": 133, "deletions": 129}, "files": [{"sha": "6e5056facf00802455c04b5741e2918489e96e42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44dedb4b1713feb59bb2cf697501bcdf9a1130b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44dedb4b1713feb59bb2cf697501bcdf9a1130b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "patch": "@@ -1,3 +1,9 @@\n+2017-05-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (vrp_int_const_binop): Use wide-ints and simplify.\n+\t(extract_range_from_multiplicative_op_1): Adjust.\n+\t(extract_range_from_binary_expr_1): Use int_const_binop.\n+\n 2017-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/80101"}, {"sha": "bcd3fd97f993e38e19d5827fc545bfd52d34b17b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 127, "deletions": 129, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44dedb4b1713feb59bb2cf697501bcdf9a1130b3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44dedb4b1713feb59bb2cf697501bcdf9a1130b3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=44dedb4b1713feb59bb2cf697501bcdf9a1130b3", "patch": "@@ -1618,66 +1618,91 @@ extract_range_from_ssa_name (value_range *vr, tree var)\n /* Wrapper around int_const_binop.  If the operation overflows and we\n    are not using wrapping arithmetic, then adjust the result to be\n    -INF or +INF depending on CODE, VAL1 and VAL2.  This can return\n-   NULL_TREE if we need to use an overflow infinity representation but\n-   the type does not support it.  */\n+   NULL_TREE for division by zero.  */\n \n-static tree\n-vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n+static wide_int\n+vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n+\t\t     bool *overflow_p)\n {\n-  tree res;\n-\n-  res = int_const_binop (code, val1, val2);\n+  bool overflow = false;\n+  signop sign = TYPE_SIGN (TREE_TYPE (val1));\n+  wide_int res;\n \n-  /* If we are using unsigned arithmetic, operate symbolically\n-     on -INF and +INF as int_const_binop only handles signed overflow.  */\n-  if (TYPE_UNSIGNED (TREE_TYPE (val1)))\n+  switch (code)\n     {\n-      int checkz = compare_values (res, val1);\n-      bool overflow = false;\n+    case RSHIFT_EXPR:\n+    case LSHIFT_EXPR:\n+      {\n+\twide_int wval2 = wi::to_wide (val2, TYPE_PRECISION (TREE_TYPE (val1)));\n+\tif (wi::neg_p (wval2))\n+\t  {\n+\t    wval2 = -wval2;\n+\t    if (code == RSHIFT_EXPR)\n+\t      code = LSHIFT_EXPR;\n+\t    else\n+\t      code = RSHIFT_EXPR;\n+\t  }\n \n-      /* Ensure that res = val1 [+*] val2 >= val1\n-         or that res = val1 - val2 <= val1.  */\n-      if ((code == PLUS_EXPR\n-\t   && !(checkz == 1 || checkz == 0))\n-          || (code == MINUS_EXPR\n-\t      && !(checkz == 0 || checkz == -1)))\n+\tif (code == RSHIFT_EXPR)\n+\t  /* It's unclear from the C standard whether shifts can overflow.\n+\t     The following code ignores overflow; perhaps a C standard\n+\t     interpretation ruling is needed.  */\n+\t  res = wi::rshift (val1, wval2, sign);\n+\telse\n+\t  res = wi::lshift (val1, wval2);\n+\tbreak;\n+      }\n+\n+    case MULT_EXPR:\n+      res = wi::mul (val1, val2, sign, &overflow);\n+      break;\n+\n+    case TRUNC_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      if (val2 == 0)\n \t{\n-\t  overflow = true;\n+\t  *overflow_p = true;\n+\t  return res;\n \t}\n-      /* Checking for multiplication overflow is done by dividing the\n-\t output of the multiplication by the first input of the\n-\t multiplication.  If the result of that division operation is\n-\t not equal to the second input of the multiplication, then the\n-\t multiplication overflowed.  */\n-      else if (code == MULT_EXPR && !integer_zerop (val1))\n+      else\n+\tres = wi::div_trunc (val1, val2, sign, &overflow);\n+      break;\n+\n+    case FLOOR_DIV_EXPR:\n+      if (val2 == 0)\n \t{\n-\t  tree tmp = int_const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t      res,\n-\t\t\t\t      val1);\n-\t  int check = compare_values (tmp, val2);\n+\t  *overflow_p = true;\n+\t  return res;\n+\t}\n+      res = wi::div_floor (val1, val2, sign, &overflow);\n+      break;\n \n-\t  if (check != 0)\n-\t    overflow = true;\n+    case CEIL_DIV_EXPR:\n+      if (val2 == 0)\n+\t{\n+\t  *overflow_p = true;\n+\t  return res;\n \t}\n+      res = wi::div_ceil (val1, val2, sign, &overflow);\n+      break;\n \n-      if (overflow)\n+    case ROUND_DIV_EXPR:\n+      if (val2 == 0)\n \t{\n-\t  res = copy_node (res);\n-\t  TREE_OVERFLOW (res) = 1;\n+\t  *overflow_p = 0;\n+\t  return res;\n \t}\n+      res = wi::div_round (val1, val2, sign, &overflow);\n+      break;\n \n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (val1)))\n-    /* If the singed operation wraps then int_const_binop has done\n-       everything we want.  */\n-    ;\n-  /* Signed division of -1/0 overflows and by the time it gets here\n-     returns NULL_TREE.  */\n-  else if (!res)\n-    return NULL_TREE;\n-  else if (TREE_OVERFLOW (res)\n-\t   && ! TREE_OVERFLOW (val1)\n-\t   && ! TREE_OVERFLOW (val2))\n+\n+  *overflow_p = overflow;\n+\n+  if (overflow\n+      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n     {\n       /* If the operation overflowed but neither VAL1 nor VAL2 are\n \t overflown, return -INF or +INF depending on the operation\n@@ -1711,17 +1736,18 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \t     overflow direction is the same as the sign of val1.\n \t     Actually rshift does not overflow at all, but we only\n \t     handle the case of shifting overflowed -INF and +INF.  */\n-\t  || (code == RSHIFT_EXPR\n-\t      && sgn1 >= 0)\n+\t  || (code == RSHIFT_EXPR && sgn1 >= 0)\n \t  /* For division, the only case is -INF / -1 = +INF.  */\n \t  || code == TRUNC_DIV_EXPR\n \t  || code == FLOOR_DIV_EXPR\n \t  || code == CEIL_DIV_EXPR\n \t  || code == EXACT_DIV_EXPR\n \t  || code == ROUND_DIV_EXPR)\n-\treturn TYPE_MAX_VALUE (TREE_TYPE (res));\n+\treturn wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)),\n+\t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n       else\n-\treturn TYPE_MIN_VALUE (TREE_TYPE (res));\n+\treturn wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)),\n+\t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n     }\n \n   return res;\n@@ -1818,12 +1844,10 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n \t\t\t\t\tenum tree_code code,\n \t\t\t\t\tvalue_range *vr0, value_range *vr1)\n {\n-  enum value_range_type type;\n-  tree val[4];\n-  size_t i;\n-  tree min, max;\n+  enum value_range_type rtype;\n+  wide_int val, min, max;\n   bool sop;\n-  int cmp;\n+  tree type;\n \n   /* Multiplications, divisions and shifts are a bit tricky to handle,\n      depending on the mix of signs we have in the two ranges, we\n@@ -1849,88 +1873,69 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n \t       || (code == MULT_EXPR && vr0->type == VR_ANTI_RANGE))\n \t      && vr0->type == vr1->type);\n \n-  type = vr0->type;\n+  rtype = vr0->type;\n+  type = TREE_TYPE (vr0->min);\n+  signop sgn = TYPE_SIGN (type);\n \n-  /* Compute the 4 cross operations.  */\n+  /* Compute the 4 cross operations and their minimum and maximum value.  */\n   sop = false;\n-  val[0] = vrp_int_const_binop (code, vr0->min, vr1->min);\n-  if (val[0] == NULL_TREE)\n-    sop = true;\n+  val = vrp_int_const_binop (code, vr0->min, vr1->min, &sop);\n+  if (! sop)\n+    min = max = val;\n \n   if (vr1->max == vr1->min)\n-    val[1] = NULL_TREE;\n-  else\n+    ;\n+  else if (! sop)\n     {\n-      val[1] = vrp_int_const_binop (code, vr0->min, vr1->max);\n-      if (val[1] == NULL_TREE)\n-\tsop = true;\n+      val = vrp_int_const_binop (code, vr0->min, vr1->max, &sop);\n+      if (! sop)\n+\t{\n+\t  if (wi::lt_p (val, min, sgn))\n+\t    min = val;\n+\t  else if (wi::gt_p (val, max, sgn))\n+\t    max = val;\n+\t}\n     }\n \n   if (vr0->max == vr0->min)\n-    val[2] = NULL_TREE;\n-  else\n+    ;\n+  else if (! sop)\n     {\n-      val[2] = vrp_int_const_binop (code, vr0->max, vr1->min);\n-      if (val[2] == NULL_TREE)\n-\tsop = true;\n+      val = vrp_int_const_binop (code, vr0->max, vr1->min, &sop);\n+      if (! sop)\n+\t{\n+\t  if (wi::lt_p (val, min, sgn))\n+\t    min = val;\n+\t  else if (wi::gt_p (val, max, sgn))\n+\t    max = val;\n+\t}\n     }\n \n   if (vr0->min == vr0->max || vr1->min == vr1->max)\n-    val[3] = NULL_TREE;\n-  else\n+    ;\n+  else if (! sop)\n     {\n-      val[3] = vrp_int_const_binop (code, vr0->max, vr1->max);\n-      if (val[3] == NULL_TREE)\n-\tsop = true;\n+      val = vrp_int_const_binop (code, vr0->max, vr1->max, &sop);\n+      if (! sop)\n+\t{\n+\t  if (wi::lt_p (val, min, sgn))\n+\t    min = val;\n+\t  else if (wi::gt_p (val, max, sgn))\n+\t    max = val;\n+\t}\n     }\n \n+  /* If either operation overflowed, drop to VARYING.  */\n   if (sop)\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n-     of VAL[i].  */\n-  min = val[0];\n-  max = val[0];\n-  for (i = 1; i < 4; i++)\n-    {\n-      if (!is_gimple_min_invariant (min)\n-\t  || TREE_OVERFLOW (min)\n-\t  || !is_gimple_min_invariant (max)\n-\t  || TREE_OVERFLOW (max))\n-\tbreak;\n-\n-      if (val[i])\n-\t{\n-\t  if (!is_gimple_min_invariant (val[i])\n-\t      || TREE_OVERFLOW (val[i]))\n-\t    {\n-\t      /* If we found an overflowed value, set MIN and MAX\n-\t\t to it so that we set the resulting range to\n-\t\t VARYING.  */\n-\t      min = max = val[i];\n-\t      break;\n-\t    }\n-\n-\t  if (compare_values (val[i], min) == -1)\n-\t    min = val[i];\n-\n-\t  if (compare_values (val[i], max) == 1)\n-\t    max = val[i];\n-\t}\n-    }\n-\n-  /* If either MIN or MAX overflowed, then set the resulting range to\n-     VARYING.  But we do accept an overflow infinity\n-     representation.  */\n-  if (min == NULL_TREE\n-      || !is_gimple_min_invariant (min)\n-      || TREE_OVERFLOW (min)\n-      || max == NULL_TREE\n-      || !is_gimple_min_invariant (max)\n-      || TREE_OVERFLOW (max))\n+  /* If the new range has its limits swapped around (MIN > MAX),\n+     then the operation caused one of them to wrap around, mark\n+     the new range VARYING.  */\n+  if (wi::gt_p (min, max, sgn))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -1939,23 +1944,16 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n   /* We punt for [-INF, +INF].\n      We learn nothing when we have INF on both sides.\n      Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n-  if (vrp_val_is_min (min)\n-      && vrp_val_is_max (max))\n+  if (wi::eq_p (min, wi::min_value (TYPE_PRECISION (type), sgn))\n+      && wi::eq_p (max, wi::max_value (TYPE_PRECISION (type), sgn)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  cmp = compare_values (min, max);\n-  if (cmp == -2 || cmp == 1)\n-    {\n-      /* If the new range has its limits swapped around (MIN > MAX),\n-\t then the operation caused one of them to wrap around, mark\n-\t the new range VARYING.  */\n-      set_value_range_to_varying (vr);\n-    }\n-  else\n-    set_value_range (vr, type, min, max, NULL);\n+  set_value_range (vr, rtype,\n+\t\t   wide_int_to_tree (type, min),\n+\t\t   wide_int_to_tree (type, max), NULL);\n }\n \n /* Extract range information from a binary operation CODE based on\n@@ -2438,8 +2436,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      /* For operations that make the resulting range directly\n \t\t proportional to the original ranges, apply the operation to\n \t\t the same end of each range.  */\n-\t      min = vrp_int_const_binop (code, vr0.min, vr1.min);\n-\t      max = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\t      min = int_const_binop (code, vr0.min, vr1.min);\n+\t      max = int_const_binop (code, vr0.max, vr1.max);\n \t    }\n \t  else if (code == MIN_EXPR)\n \t    {"}]}