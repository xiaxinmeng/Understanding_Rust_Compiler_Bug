{"sha": "4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4NGNkMjdmYzA1ZDRiNGIxNDQwMWM2MzlmZTQ0MjdhM2JiYmUzZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-29T17:59:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-29T17:59:31Z"}, "message": "c-common.h (lang_post_pch_load): New variable.\n\n\t* c-common.h (lang_post_pch_load): New variable.\n\t* c-pch.c (lang_post_pch_load): Define it.\n\t(c_common_read_pch): Use it.\n\t* cgraphunit.c (record_call_1): Give the front end a chance to\n\trecord additional needed entities when a variable is marked as\n\tneeded.\n\t* tlink.c (recompile_files): Robustify.\n\t(scan_linker_output): If a symbol is assigned to a file,\n\tbut after recompilation is not present there, issue an error\n\tmessage.\n\n\t* cp-tree.h (IDENTIFIER_REPO_CHOSEN): Define.\n\t(lang_decl_flags): Narrow the width of \"languages\".  Add\n\trepo_available_p.\n\t(DECL_NEEDED_P): Remove.\n\t(FOR_EACH_CLONE): New macro.\n\t(DECL_REPO_AVAILABLE_P): Likewise.\n\t(DECL_TINFO_P): Likewise.\n\t(set_linkage_according_to_type): Declare.\n\t(import_export_vtable): Remove.\n\t(import_export_tinfo): Likewise.\n\t(mark_needed): New function.\n\t(decl_needed_p): Likewise.\n\t(note_vauge_linkage_fn): Likewise.\n\t(init_repo): Change prototype.\n\t(repo_template_used): Remove.\n\t(repo_template_instantiated): Likewise.\n\t(repo_emit_p): New function.\n\t(repo_export_class_p): Likewise.\n\t(no_linkage_check): Change prototype.\n\t* class.c (set_linkage_according_to_type): New function.\n\t(build_vtable): Use it.  Do not call import_export_vtable.  Set\n\tDECL_IGNORED_P if appropriate.\n\t* decl.c (duplicate_decls): Preserve DECL_REPO_AVAILABLE_P.\n\t(make_rtL_for_nonlocal_decls): Check for template instantiations\n\texplicitly.\n\t(grokfndecl): Adjust call to no_linkage_check.\n\t(set_linkage_for_static_data_member): New function.\n\t(grokvardecl): Use it.  Adjust call to no_linkage_check.\n\t(grokdeclarator): Use set_linkage_for_static_data_member.\n\t* decl2.c (note_vague_linkage_fn): New function.\n\t(note_vague_linkage_var): Likewise.\n\t(finish_static_data_member_decl): Use it.\n\t(import_export_vtable): Remove.\n\t(import_export_class): Use repo_export_class_p.\n\t(var_finalized_p): Simplify.\n\t(maybe_emit_vtables): Simplify.\n\t(mark_needed): New function.\n\t(decl_needed_p): Likewise.\n\t(import_export_decl): Add documentation and consistency checks.\n\tUse repo_emit_p.  Handle virtual tables and RTTI information\n\there.\n\t(import_export_tinfo): Remove.\n\t(write_out_vars): Call import_export_decl.\n\t(cxx_callgraph_analyze_expr): Ensure that all vtables are emitted\n\twhenever one is.\n\t(finish_file): Use decl_needed_p.  Do not call import_export_decl\n\tfor undefined static data members.  Do not warn about undefined\n\tinlines when using a repository.\n\t(mark_used): Use note_vague_linkage_fn.  Always defer template\n\tinstantiations.\n\t* lex.c (cxx_init): Adjust call to init_repo.  Always set\n\tflag_unit_at_a-time.\n\t* method.c (synthesize_method): Remove unncessary\n\timport_export_decl call.\n\t(implicitly_declare_fn): Use set_linkage_according_to_type.\n\t* optimize.c (maybe_clone_body): Use FOR_EACH_CLONE.\n\t* pt.c (instantiate_class_template): Don't redundantly add classes\n\tto keyed_classes.  Don't call repo_template_used.\n\t(tsubst_decl): Set DECL_INTERFACE_KNOWN for instantiations of\n\ttemplates with internal linkage.\n\t(check_instantiated_args): Adjust call to no_linkage_check.\n\t(instantiate_template): Use FOR_EACH_CLONE.\n\t(mark_definable): New function.\n\t(mark_decl_instantiated): Use it.\n\t(do_decl_instantiation): Adjust tests for explicit instantiation\n\tafter \"extern template\".\n\t(instantiate_class_member): Do not use repo_template_instantiated.\n\t(do_type_instantiation): Simplify.\n\t(instantiate_decl): Use mark_definable.  Check repo_emit_p.\n\tSimplify.\n\t* repo.c (repo_get_id): Remove.\n\t(original_repo): Remove.\n\t(IDENTIFIER_REPO_USED): Remove.\n\t(IDENTIFIER_REPO_CHOSEN): Remove.\n\tRemove all #if 0'd code.\n\t(repo_template_used): Remove.\n\t(repo_template_instantiated): Remove.\n\t(temporary_obstack_initialized_p): New variable.\n\t(init_repo): Register with lang_post_pch_load.  Avoid creating\n\tidentifiers unnecessarily.  Don't use original_repo.  Close the\n\tfile here.\n\t(reopen_repo_file_for_write): Not here.\n\t(finish_repo): Always write out a new repository file.\n\t(repo_emit_p): New function.\n\t(repo_export_class_p): Likewise.\n\t* rtti.c (get_tinfo_decl): Use set_linkage_according_to_type.\n\t(involves_incomplete_p): New function.\n\t(tinfo_base_init): Use it.\n\t(ptr_initializer): Remove non_public_ptr parameter.\n\t(ptm_initializer): Likewise.\n\t(get_pseudo_ti_init): Likewise.\n\t(unemitted_tinfo_decl_p): Remove.\n\t(emit_tinfo_decl): Use import_export_decl.\n\t* semantics.c (expand_body): Move updates of static_ctors and\n\tstatic_dtors to ...\n\t(expand_or_defer_fn): ... here.\n\t* tree.c (no_linkage_check): Add relaxed_p parameter.\n\n\t* g++.dg/abi/inline1.C: New test.\n\t* g++.dg/abi/local1-a.cc: Likewise.\n\t* g++.dg/abi/local1.C: Likewise.\n\t* g++.dg/abi/mangle11.C: Tweak location of warnings.\n\t* g++.dg/abi/mangle12.C: Likewise.\n\t* g++.dg/abi/mangle17.C: Likewise.\n\t* g++.dg/abi/mangle20-2.C: Likewise.\n\t* g++.dg/opt/interface1.C: Likewise.\n\t* g++.dg/opt/interface1.h: Likewise.\n\t* g++.dg/opt/interface1-a.cc: New test.\n\t* g++.dg/parse/repo1.C: New test.\n\t* g++.dg/template/repo1.C: Likewise.\n\t* g++.dg/warn/Winline-1.C: Likewise.\n\t* lib/gcc-dg.exp (gcc-dg-test-1): Fix -frepo handling.\n\nFrom-SVN: r85309", "tree": {"sha": "bd18935ca8aaabc7e84771ece8e457e583cfbf6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd18935ca8aaabc7e84771ece8e457e583cfbf6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/comments", "author": null, "committer": null, "parents": [{"sha": "b4042a039f664fe6e2cedc49cb74a65c159756fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4042a039f664fe6e2cedc49cb74a65c159756fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4042a039f664fe6e2cedc49cb74a65c159756fe"}], "stats": {"total": 1907, "additions": 1134, "deletions": 773}, "files": [{"sha": "1a6e4e130d3b2e47d13db0952f93791b5771416e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,3 +1,16 @@\n+2004-07-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (lang_post_pch_load): New variable.\n+\t* c-pch.c (lang_post_pch_load): Define it.\n+\t(c_common_read_pch): Use it.\n+\t* cgraphunit.c (record_call_1): Give the front end a chance to\n+\trecord additional needed entities when a variable is marked as\n+\tneeded.\n+\t* tlink.c (recompile_files): Robustify.\n+\t(scan_linker_output): If a symbol is assigned to a file,\n+\tbut after recompilation is not present there, issue an error\n+\tmessage.\n+\n 2004-07-29  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* tree-ssa-loop-im.c (force_move_till_expr, force_move_till):"}, {"sha": "63972dc96bb56a9748515ec4d605288f9950954b", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -286,6 +286,10 @@ extern void (*lang_expand_function_end) (void);\n    noreturn attribute.  */\n extern int (*lang_missing_noreturn_ok_p) (tree);\n \n+/* If non-NULL, this function is called after a precompile header file\n+   is loaded.  */\n+extern void (*lang_post_pch_load) (void);\n+\n extern void push_file_scope (void);\n extern void pop_file_scope (void);\n extern int yyparse (void);"}, {"sha": "21c3135b1102b0f4d0e2e791c3769913d5d87a13", "filename": "gcc/c-pch.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -384,6 +384,10 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n     return result == 0;\n }\n \n+/* If non-NULL, this function is called after a precompile header file\n+   is loaded.  */\n+void (*lang_post_pch_load) (void);\n+\n /* Load in the PCH file NAME, open on FD.  It was originally searched for\n    by ORIG_NAME.  */\n \n@@ -443,6 +447,11 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n     return;\n \n   fclose (f);\n+  \n+  /* Give the front end a chance to take action after a PCH file has\n+     been loadeded.  */\n+  if (lang_post_pch_load)\n+    (*lang_post_pch_load) ();\n }\n \n /* Indicate that no more PCH files should be read.  */"}, {"sha": "9e903e09b9db27a03657c1c14cf04bb6377062a7", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -400,7 +400,12 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \t by this function and re-examine whether the decl is actually used\n \t after rtl has been generated.  */\n       if (TREE_STATIC (t))\n-        cgraph_varpool_mark_needed_node (cgraph_varpool_node (t));\n+\t{\n+\t  cgraph_varpool_mark_needed_node (cgraph_varpool_node (t));\n+\t  if (lang_hooks.callgraph.analyze_expr)\n+\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees, \n+\t\t\t\t\t\t      data);\n+\t}\n       break;\n \n     case ADDR_EXPR:"}, {"sha": "d87584ec711181767084a29bac7d9a8a23cfc979", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,3 +1,103 @@\n+2004-07-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (IDENTIFIER_REPO_CHOSEN): Define.\n+\t(lang_decl_flags): Narrow the width of \"languages\".  Add\n+\trepo_available_p.\n+\t(DECL_NEEDED_P): Remove.\n+\t(FOR_EACH_CLONE): New macro.\n+\t(DECL_REPO_AVAILABLE_P): Likewise.\n+\t(DECL_TINFO_P): Likewise.\n+\t(set_linkage_according_to_type): Declare.\n+\t(import_export_vtable): Remove.\n+\t(import_export_tinfo): Likewise.\n+\t(mark_needed): New function.\n+\t(decl_needed_p): Likewise.\n+\t(note_vauge_linkage_fn): Likewise.\n+\t(init_repo): Change prototype.\n+\t(repo_template_used): Remove.\n+\t(repo_template_instantiated): Likewise.\n+\t(repo_emit_p): New function.\n+\t(repo_export_class_p): Likewise.\n+\t(no_linkage_check): Change prototype.\n+\t* class.c (set_linkage_according_to_type): New function.\n+\t(build_vtable): Use it.  Do not call import_export_vtable.  Set\n+\tDECL_IGNORED_P if appropriate.\n+\t* decl.c (duplicate_decls): Preserve DECL_REPO_AVAILABLE_P.\n+\t(make_rtL_for_nonlocal_decls): Check for template instantiations\n+\texplicitly.\n+\t(grokfndecl): Adjust call to no_linkage_check.\n+\t(set_linkage_for_static_data_member): New function.\n+\t(grokvardecl): Use it.  Adjust call to no_linkage_check.\n+\t(grokdeclarator): Use set_linkage_for_static_data_member.\n+\t* decl2.c (note_vague_linkage_fn): New function.\n+\t(note_vague_linkage_var): Likewise.\n+\t(finish_static_data_member_decl): Use it.\n+\t(import_export_vtable): Remove.\n+\t(import_export_class): Use repo_export_class_p.\n+\t(var_finalized_p): Simplify.\n+\t(maybe_emit_vtables): Simplify.\n+\t(mark_needed): New function.\n+\t(decl_needed_p): Likewise.\n+\t(import_export_decl): Add documentation and consistency checks.\n+\tUse repo_emit_p.  Handle virtual tables and RTTI information\n+\there.\n+\t(import_export_tinfo): Remove.\n+\t(write_out_vars): Call import_export_decl.\n+\t(cxx_callgraph_analyze_expr): Ensure that all vtables are emitted\n+\twhenever one is.\n+\t(finish_file): Use decl_needed_p.  Do not call import_export_decl\n+\tfor undefined static data members.  Do not warn about undefined\n+\tinlines when using a repository.\n+\t(mark_used): Use note_vague_linkage_fn.  Always defer template\n+\tinstantiations.\n+\t* lex.c (cxx_init): Adjust call to init_repo.  Always set\n+\tflag_unit_at_a-time.\n+\t* method.c (synthesize_method): Remove unncessary\n+\timport_export_decl call.\n+\t(implicitly_declare_fn): Use set_linkage_according_to_type.\n+\t* optimize.c (maybe_clone_body): Use FOR_EACH_CLONE.\n+\t* pt.c (instantiate_class_template): Don't redundantly add classes\n+\tto keyed_classes.  Don't call repo_template_used.\n+\t(tsubst_decl): Set DECL_INTERFACE_KNOWN for instantiations of\n+\ttemplates with internal linkage.\n+\t(check_instantiated_args): Adjust call to no_linkage_check.\n+\t(instantiate_template): Use FOR_EACH_CLONE.\n+\t(mark_definable): New function.\n+\t(mark_decl_instantiated): Use it.\n+\t(do_decl_instantiation): Adjust tests for explicit instantiation\n+\tafter \"extern template\".\n+\t(instantiate_class_member): Do not use repo_template_instantiated.\n+\t(do_type_instantiation): Simplify.\n+\t(instantiate_decl): Use mark_definable.  Check repo_emit_p.\n+\tSimplify.\n+\t* repo.c (repo_get_id): Remove.\n+\t(original_repo): Remove.\n+\t(IDENTIFIER_REPO_USED): Remove.\n+\t(IDENTIFIER_REPO_CHOSEN): Remove.\n+\tRemove all #if 0'd code.\n+\t(repo_template_used): Remove.\n+\t(repo_template_instantiated): Remove.\n+\t(temporary_obstack_initialized_p): New variable.\n+\t(init_repo): Register with lang_post_pch_load.  Avoid creating\n+\tidentifiers unnecessarily.  Don't use original_repo.  Close the\n+\tfile here.\n+\t(reopen_repo_file_for_write): Not here.\n+\t(finish_repo): Always write out a new repository file.\n+\t(repo_emit_p): New function.\n+\t(repo_export_class_p): Likewise.\n+\t* rtti.c (get_tinfo_decl): Use set_linkage_according_to_type.\n+\t(involves_incomplete_p): New function.\n+\t(tinfo_base_init): Use it.\n+\t(ptr_initializer): Remove non_public_ptr parameter.\n+\t(ptm_initializer): Likewise.\n+\t(get_pseudo_ti_init): Likewise.\n+\t(unemitted_tinfo_decl_p): Remove.\n+\t(emit_tinfo_decl): Use import_export_decl.\n+\t* semantics.c (expand_body): Move updates of static_ctors and\n+\tstatic_dtors to ...\n+\t(expand_or_defer_fn): ... here.\n+\t* tree.c (no_linkage_check): Add relaxed_p parameter.\n+\t\n 2004-07-28  Eric Christopher  <echristo@redhat.com>\n \n \t* cp-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete."}, {"sha": "365febbb7040ecd9a8cecc7bb8f433d2d22da908", "filename": "gcc/cp/class.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -581,6 +581,32 @@ get_vtt_name (tree type)\n   return mangle_vtt_for_type (type);\n }\n \n+/* DECL is an entity associated with TYPE, like a virtual table or an\n+   implicitly generated constructor.  Determine whether or not DECL\n+   should have external or internal linkage at the object file\n+   level.  This routine does not deal with COMDAT linkage and other\n+   similar complexities; it simply sets TREE_PUBLIC if it possible for\n+   entities in other translation units to contain copies of DECL, in\n+   the abstract.  */\n+\n+void\n+set_linkage_according_to_type (tree type, tree decl)\n+{\n+  /* If TYPE involves a local class in a function with internal\n+     linkage, then DECL should have internal linkage too.  Other local\n+     classes have no linkage -- but if their containing functions\n+     have external linkage, it makes sense for DECL to have external\n+     linkage too.  That will allow template definitions to be merged,\n+     for example.  */\n+  if (no_linkage_check (type, /*relaxed_p=*/true))\n+    {\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+    }\n+  else\n+    TREE_PUBLIC (decl) = 1;\n+}\n+\n /* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.\n    (For a secondary vtable for B-in-D, CLASS_TYPE should be D, not B.)\n    Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */\n@@ -601,17 +627,42 @@ build_vtable (tree class_type, tree name, tree vtable_type)\n   DECL_VIRTUAL_P (decl) = 1;\n   DECL_ALIGN (decl) = TARGET_VTABLE_ENTRY_ALIGN;\n   DECL_VTABLE_OR_VTT_P (decl) = 1;\n-\n   /* At one time the vtable info was grabbed 2 words at a time.  This\n      fails on sparc unless you have 8-byte alignment.  (tiemann) */\n   DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n \t\t\t   DECL_ALIGN (decl));\n+  set_linkage_according_to_type (class_type, decl);\n+  /* The vtable has not been defined -- yet.  */\n+  DECL_EXTERNAL (decl) = 1;\n+  DECL_NOT_REALLY_EXTERN (decl) = 1;\n+\n+  if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n+    /* Mark the VAR_DECL node representing the vtable itself as a\n+       \"gratuitous\" one, thereby forcing dwarfout.c to ignore it.  It\n+       is rather important that such things be ignored because any\n+       effort to actually generate DWARF for them will run into\n+       trouble when/if we encounter code like:\n+       \n+         #pragma interface\n+\t struct S { virtual void member (); };\n+\t   \n+       because the artificial declaration of the vtable itself (as\n+       manufactured by the g++ front end) will say that the vtable is\n+       a static member of `S' but only *after* the debug output for\n+       the definition of `S' has already been output.  This causes\n+       grief because the DWARF entry for the definition of the vtable\n+       will try to refer back to an earlier *declaration* of the\n+       vtable as a static member of `S' and there won't be one.  We\n+       might be able to arrange to have the \"vtable static member\"\n+       attached to the member list for `S' before the debug info for\n+       `S' get written (which would solve the problem) but that would\n+       require more intrusive changes to the g++ front end.  */\n+    DECL_IGNORED_P (decl) = 1;\n \n   /* The vtable's visibility is the class visibility.  There is no way\n      to override the visibility for just the vtable. */\n   DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n   DECL_VISIBILITY_SPECIFIED (decl) = CLASSTYPE_VISIBILITY_SPECIFIED (class_type);\n-  import_export_vtable (decl, class_type, 0);\n \n   return decl;\n }"}, {"sha": "8d14911235d56df59240aaf15f2f7f310ca12273", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -48,15 +48,15 @@ struct diagnostic_context;\n       STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n       EXPR_STMT_STMT_EXPR_RESULT (in EXPR_STMT)\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n-   1: IDENTIFIER_VIRTUAL_P.\n+   1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (in _TYPE).\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       DECL_INITIALIZED_P (in VAR_DECL)\n-   2: IDENTIFIER_OPNAME_P.\n+   2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n       TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -70,9 +70,10 @@ struct diagnostic_context;\n    4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n+      DECL_TINFO_P (in VAR_DECL)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n-   6: For future expansion\n+   6: IDENTIFIER_REPO_CHOSEN (in IDENTIFIER_NODE)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n@@ -375,6 +376,12 @@ typedef enum cp_id_kind\n #define IDENTIFIER_CTOR_OR_DTOR_P(NODE) \\\n   TREE_LANG_FLAG_3 (NODE)\n \n+/* True iff NAME is the DECL_ASSEMBLER_NAME for an entity with vague\n+   linkage which the prelinker has assigned to this translation\n+   unit.  */\n+#define IDENTIFIER_REPO_CHOSEN(NAME) \\\n+  (TREE_LANG_FLAG_6 (NAME))\n+\n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n #define C_TYPE_FIELDS_READONLY(TYPE) \\\n   (LANG_TYPE_CLASS_CHECK (TYPE)->fields_readonly)\n@@ -1515,7 +1522,11 @@ struct lang_type GTY(())\n \n struct lang_decl_flags GTY(())\n {\n-  ENUM_BITFIELD(languages) language : 8;\n+  ENUM_BITFIELD(languages) language : 4;\n+  unsigned global_ctor_p : 1;\n+  unsigned global_dtor_p : 1;\n+  unsigned anticipated_p : 1;\n+  unsigned template_conv_p : 1;\n \n   unsigned operator_attr : 1;\n   unsigned constructor_attr : 1;\n@@ -1534,14 +1545,12 @@ struct lang_decl_flags GTY(())\n   unsigned initialized_in_class : 1;\n   unsigned assignment_operator_p : 1;\n \n-  unsigned global_ctor_p : 1;\n-  unsigned global_dtor_p : 1;\n-  unsigned anticipated_p : 1;\n-  unsigned template_conv_p : 1;\n   unsigned u1sel : 1;\n   unsigned u2sel : 1;\n   unsigned can_be_full : 1;\n   unsigned this_thunk_p : 1;\n+  unsigned repo_available_p : 1;\n+  unsigned dummy : 3;\n \n   union lang_decl_u {\n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n@@ -1631,19 +1640,6 @@ struct lang_decl GTY(())\n \n #endif /* ENABLE_TREE_CHECKING */\n \n-/* DECL_NEEDED_P holds of a declaration when we need to emit its\n-   definition.  This is true when the back-end tells us that\n-   the symbol has been referenced in the generated code.  If, however,\n-   we are not generating code, then it is also true when a symbol has\n-   just been used somewhere, even if it's not really needed.  We need\n-   anything that isn't comdat, but we don't know for sure whether or\n-   not something is comdat until end-of-file.  */\n-#define DECL_NEEDED_P(DECL)\t\t\t\t\t\\\n-  ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\\\n-   || (DECL_ASSEMBLER_NAME_SET_P (DECL)\t\t\t\t\\\n-       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)))\t\\\n-   || (((flag_syntax_only || flag_unit_at_a_time) && TREE_USED (DECL))))\n-\n /* For a FUNCTION_DECL or a VAR_DECL, the language linkage for the\n    declaration.  Some entities (like a member function in a local\n    class, or a local variable) do not have linkage at all, and this\n@@ -1730,6 +1726,21 @@ struct lang_decl GTY(())\n #define DECL_CLONED_FUNCTION(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->u.f.cloned_function)\n \n+/* Perform an action for each clone of FN, if FN is a function with\n+   clones.  This macro should be used like:\n+   \n+      FOR_EACH_CLONE (clone, fn)\n+        { ... }\n+\n+  */\n+#define FOR_EACH_CLONE(CLONE, FN)\t\t\t\\\n+  if (TREE_CODE (FN) == FUNCTION_DECL\t\t\t\\\n+      && (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (FN)\t\\\n+\t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (FN)))\t\\\n+     for (CLONE = TREE_CHAIN (FN);\t\t\t\\\n+\t  CLONE && DECL_CLONED_FUNCTION_P (CLONE);\t\\\n+\t  CLONE = TREE_CHAIN (CLONE))\n+\n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n #define DECL_DISCRIMINATOR_P(NODE)\t\\\n   (TREE_CODE (NODE) == VAR_DECL\t\t\\\n@@ -1921,6 +1932,11 @@ struct lang_decl GTY(())\n    DECL_LANG_SPECIFIC (NODE)->u.f.u3sel = 1,\t\t\t\\\n    DECL_LANG_SPECIFIC (NODE)->decl_flags.this_thunk_p = (THIS_ADJUSTING))\n \n+/* True iff DECL is an entity with vague linkage whose definition is\n+   available in this translation unit.  */\n+#define DECL_REPO_AVAILABLE_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.repo_available_p)\n+\n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n #define DECL_PRETTY_FUNCTION_P(NODE) \\\n@@ -1965,6 +1981,10 @@ struct lang_decl GTY(())\n   (DECL_CONTEXT (NODE) \\\n    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n \n+/* 1 iff VAR_DECL node NODE is a type-info decl.  This flag is set for\n+   both the primary typeinfo object and the associated NTBS name.  */\n+#define DECL_TINFO_P(NODE) TREE_LANG_FLAG_4 (VAR_DECL_CHECK (NODE))\n+\n /* 1 iff VAR_DECL node NODE is virtual table or VTT.  */\n #define DECL_VTABLE_OR_VTT_P(NODE) TREE_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n \n@@ -3643,6 +3663,7 @@ extern tree get_primary_binfo                   (tree);\n extern void debug_class\t\t\t\t(tree);\n extern void debug_thunks \t\t\t(tree);\n extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n+extern void set_linkage_according_to_type       (tree, tree);\n \n /* in cvt.c */\n extern tree convert_to_reference (tree, tree, int, int, tree);\n@@ -3787,9 +3808,7 @@ extern tree finish_table (tree, tree, tree, int);\n extern tree coerce_new_type (tree);\n extern tree coerce_delete_type (tree);\n extern void comdat_linkage (tree);\n-extern void import_export_vtable (tree, tree, int);\n extern void import_export_decl (tree);\n-extern void import_export_tinfo\t(tree, tree, bool);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n extern void check_default_args (tree);\n@@ -3801,6 +3820,9 @@ extern tree get_guard (tree);\n extern tree get_guard_cond (tree);\n extern tree set_guard (tree);\n extern tree cxx_callgraph_analyze_expr (tree *, int *, tree);\n+extern void mark_needed (tree);\n+extern bool decl_needed_p (tree);\n+extern void note_vague_linkage_fn (tree);\n \n /* XXX Not i18n clean.  */\n #define cp_deprecated(STR)\t\t\t\t\t\t\\\n@@ -3973,9 +3995,9 @@ extern bool reregister_specialization           (tree, tree, tree);\n extern tree fold_non_dependent_expr             (tree);\n \n /* in repo.c */\n-extern void repo_template_used (tree);\n-extern void repo_template_instantiated (tree, bool);\n-extern void init_repo (const char *);\n+extern void init_repo (void);\n+extern int repo_emit_p (tree);\n+extern bool repo_export_class_p (tree);\n extern void finish_repo (void);\n \n /* in rtti.c */\n@@ -4192,7 +4214,7 @@ extern tree error_type\t\t\t\t(tree);\n extern int varargs_function_p\t\t\t(tree);\n extern int really_overloaded_fn\t\t\t(tree);\n extern bool cp_tree_equal\t\t\t(tree, tree);\n-extern tree no_linkage_check\t\t\t(tree);\n+extern tree no_linkage_check\t\t\t(tree, bool);\n extern void debug_binfo\t\t\t\t(tree);\n extern tree build_dummy_object\t\t\t(tree);\n extern tree maybe_dummy_object\t\t\t(tree, tree *);"}, {"sha": "c84c4be7687fe9e36fc8f1196dd7d3a77f89143e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1753,6 +1753,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_LANG_SPECIFIC (newdecl)->decl_flags.u2 =\n \tDECL_LANG_SPECIFIC (olddecl)->decl_flags.u2;\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n+      DECL_REPO_AVAILABLE_P (newdecl) = DECL_REPO_AVAILABLE_P (olddecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n         |= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n@@ -4571,7 +4572,8 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n       defer_p = 1;\n     }\n   /* Likewise for template instantiations.  */\n-  else if (DECL_COMDAT (decl))\n+  else if (DECL_LANG_SPECIFIC (decl)\n+\t   && DECL_IMPLICIT_INSTANTIATION (decl))\n     defer_p = 1;\n \n   /* If we're deferring the variable, we only need to make RTL if\n@@ -5513,7 +5515,8 @@ grokfndecl (tree ctype,\n \t declare an entity with linkage.\n \n \t Only check this for public decls for now.  See core 319, 389.  */\n-      t = no_linkage_check (TREE_TYPE (decl));\n+      t = no_linkage_check (TREE_TYPE (decl),\n+\t\t\t    /*relaxed_p=*/false);\n       if (t)\n \t{\n \t  if (TYPE_ANONYMOUS_P (t))\n@@ -5723,6 +5726,25 @@ grokfndecl (tree ctype,\n   return decl;\n }\n \n+/* DECL is a VAR_DECL for a static data member.  Set flags to reflect\n+   the linkage that DECL will receive in the object file.  */\n+\n+static void\n+set_linkage_for_static_data_member (tree decl)\n+{\n+  /* A static data member always has static storage duration and\n+     external linkage.  Note that static data members are forbidden in\n+     local classes -- the only situation in which a class has\n+     non-external linkage.  */\n+  TREE_PUBLIC (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  /* For non-template classes, static data members are always put\n+     out in exactly those files where they are defined, just as\n+     with ordinarly namespace-scope variables.  */\n+  if (!processing_template_decl)\n+    DECL_INTERFACE_KNOWN (decl) = 1;\n+}\n+\n /* Create a VAR_DECL named NAME with the indicated TYPE.\n \n    If SCOPE is non-NULL, it is the class type or namespace containing\n@@ -5782,12 +5804,10 @@ grokvardecl (tree type,\n       DECL_EXTERNAL (decl) = !initialized;\n     }\n \n-  /* In class context, static means one per class,\n-     public access, and static storage.  */\n   if (DECL_CLASS_SCOPE_P (decl))\n     {\n-      TREE_PUBLIC (decl) = 1;\n-      TREE_STATIC (decl) = 1;\n+      set_linkage_for_static_data_member (decl);\n+      /* This function is only called with out-of-class definitions.  */\n       DECL_EXTERNAL (decl) = 0;\n     }\n   /* At top level, either `static' or no s.c. makes a definition\n@@ -5822,7 +5842,8 @@ grokvardecl (tree type,\n \t declare an entity with linkage.\n \n \t Only check this for public decls for now.  */\n-      tree t = no_linkage_check (TREE_TYPE (decl));\n+      tree t = no_linkage_check (TREE_TYPE (decl),\n+\t\t\t\t /*relaxed_p=*/false);\n       if (t)\n \t{\n \t  if (TYPE_ANONYMOUS_P (t))\n@@ -7859,9 +7880,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t/* C++ allows static class members.  All other work\n \t\t   for this is done by grokfield.  */\n \t\tdecl = build_lang_decl (VAR_DECL, unqualified_id, type);\n-\t\tTREE_STATIC (decl) = 1;\n-\t\t/* In class context, 'static' means public access.  */\n-\t\tTREE_PUBLIC (decl) = DECL_EXTERNAL (decl) = 1;\n+\t\tset_linkage_for_static_data_member (decl);\n+\t\t/* Even if there is an in-class initialization, DECL\n+\t\t   is considered undefined until an out-of-class\n+\t\t   definition is provided.  */\n+\t\tDECL_EXTERNAL (decl) = 1;\n \t      }\n \t    else\n \t      {\n@@ -9842,6 +9865,11 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tDECL_EXTERNAL (decl1) = 0;\n       DECL_NOT_REALLY_EXTERN (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n+      /* If this function is in an interface implemented in this file,\n+\t make sure that the backend knows to emit this function \n+\t here.  */\n+      if (!DECL_EXTERNAL (decl1))\n+\tmark_needed (decl1);\n     }\n   else if (interface_unknown && interface_only\n \t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))"}, {"sha": "40322ab31cc4e5362a5a6c60a73b380db33b94db", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 353, "deletions": 268, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -729,6 +729,33 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   return NULL_TREE;\n }\n \n+/* DECL is a function with vague linkage.  Remember it so that at the\n+   end of the translation unit we can decide whether or not to emit\n+   it.  */\n+\n+void\n+note_vague_linkage_fn (tree decl)\n+{\n+  if (!DECL_DEFERRED_FN (decl))\n+    {\n+      DECL_DEFERRED_FN (decl) = 1;\n+      DECL_DEFER_OUTPUT (decl) = 1;\n+      if (!deferred_fns)\n+\tVARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n+      VARRAY_PUSH_TREE (deferred_fns, decl);\n+    }\n+}\n+\n+/* Like note_vague_linkage_fn but for variables.  */\n+\n+static void\n+note_vague_linkage_var (tree var)\n+{\n+  if (!pending_statics)\n+    VARRAY_TREE_INIT (pending_statics, 32, \"pending_statics\");\n+  VARRAY_PUSH_TREE (pending_statics, var);\n+}\n+\n /* We have just processed the DECL, which is a static data member.\n    Its initializer, if present, is INIT.  The ASMSPEC_TREE, if\n    present, is the assembly-language name for the data member.\n@@ -750,11 +777,7 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n     DECL_INITIAL (decl) = error_mark_node;\n \n   if (! processing_template_decl)\n-    {\n-      if (!pending_statics)\n-\tVARRAY_TREE_INIT (pending_statics, 32, \"pending_statics\");\n-      VARRAY_PUSH_TREE (pending_statics, decl);\n-    }\n+    note_vague_linkage_var (decl);\n \n   if (LOCAL_CLASS_P (current_class_type))\n     pedwarn (\"local class `%#T' shall not have static data member `%#D'\",\n@@ -1403,51 +1426,6 @@ maybe_make_one_only (tree decl)\n     }\n }\n \n-/* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n-   based on TYPE and other static flags.\n-\n-   Note that anything public is tagged TREE_PUBLIC, whether\n-   it's public in this file or in another one.  */\n-\n-void\n-import_export_vtable (tree decl, tree type, int final)\n-{\n-  if (DECL_INTERFACE_KNOWN (decl))\n-    return;\n-\n-  if (TYPE_FOR_JAVA (type))\n-    {\n-      TREE_PUBLIC (decl) = 1;\n-      DECL_EXTERNAL (decl) = 1;\n-      DECL_INTERFACE_KNOWN (decl) = 1;\n-    }\n-  else if (CLASSTYPE_INTERFACE_KNOWN (type))\n-    {\n-      TREE_PUBLIC (decl) = 1;\n-      DECL_EXTERNAL (decl) = CLASSTYPE_INTERFACE_ONLY (type);\n-      DECL_INTERFACE_KNOWN (decl) = 1;\n-    }\n-  else\n-    {\n-      /* We can only wait to decide if we have real non-inline virtual\n-\t functions in our class, or if we come from a template.  */\n-\n-      int found = (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n-\t\t   || CLASSTYPE_KEY_METHOD (type) != NULL_TREE);\n-\n-      if (final || ! found)\n-\t{\n-\t  comdat_linkage (decl);\n-\t  DECL_EXTERNAL (decl) = 0;\n-\t}\n-      else\n-\t{\n-\t  TREE_PUBLIC (decl) = 1;\n-\t  DECL_EXTERNAL (decl) = 1;\n-\t}\n-    }\n-}\n-\n /* Determine whether or not we want to specifically import or export CTYPE,\n    using various heuristics.  */\n \n@@ -1479,21 +1457,18 @@ import_export_class (tree ctype)\n     import_export = -1;\n   else if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n     import_export = 1;\n-\n-  /* If we got -fno-implicit-templates, we import template classes that\n-     weren't explicitly instantiated.  */\n-  if (import_export == 0\n-      && CLASSTYPE_IMPLICIT_INSTANTIATION (ctype)\n-      && ! flag_implicit_templates)\n-    import_export = -1;\n-\n-  /* Base our import/export status on that of the first non-inline,\n-     non-pure virtual function, if any.  */\n-  if (import_export == 0\n-      && TYPE_POLYMORPHIC_P (ctype))\n-    {\n+  else if (CLASSTYPE_IMPLICIT_INSTANTIATION (ctype)\n+\t   && !flag_implicit_templates)\n+    /* For a template class, without -fimplicit-templates, check the\n+       repository.  If the virtual table is assigned to this\n+       translation unit, then export the class; otherwise, import\n+       it.  */\n+      import_export = repo_export_class_p (ctype) ? 1 : -1;\n+  else if (TYPE_POLYMORPHIC_P (ctype))\n+    {\n+      /* The ABI specifies that the virtual table and associated\n+\t information are emitted with the key method, if any.  */\n       tree method = CLASSTYPE_KEY_METHOD (ctype);\n-\n       /* If weak symbol support is not available, then we must be\n \t careful not to emit the vtable when the key function is\n \t inline.  An inline function can be defined in multiple\n@@ -1525,10 +1500,52 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  if (flag_unit_at_a_time)\n-    return cgraph_varpool_node (var)->finalized;\n-  else\n-    return TREE_ASM_WRITTEN (var);\n+  return cgraph_varpool_node (var)->finalized;\n+}\n+\n+/* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,\n+   must be emitted in this translation unit.  Mark it as such.  */\n+\n+void\n+mark_needed (tree decl)\n+{\n+  /* It's possible that we no longer need to set\n+     TREE_SYMBOL_REFERENCED here directly, but doing so is\n+     harmless.  */\n+  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)) = 1;\n+  mark_decl_referenced (decl);\n+}\n+\n+/* DECL is either a FUNCTION_DECL or a VAR_DECL.  This function\n+   returns true if a definition of this entity should be provided in\n+   this object file.  Callers use this function to determine whether\n+   or not to let the back end know that a definition of DECL is\n+   available in this translation unit.  */\n+\n+bool\n+decl_needed_p (tree decl)\n+{\n+  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n+\t\t      || TREE_CODE (decl) == FUNCTION_DECL,\n+\t\t      20040726);\n+  /* This function should only be called at the end of the translation\n+     unit.  We cannot be sure of whether or not something will be\n+     COMDAT until that point.  */\n+  my_friendly_assert (at_eof, 20040726);\n+\n+  /* All entities with external linkage that are not COMDAT should be\n+     emitted; they may be referred to from other object files.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n+    return true;\n+  /* If this entity was used, let the back-end see it; it will decide\n+     whether or not to emit it into the object file.  */\n+  if (TREE_USED (decl) \n+      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+      return true;\n+  /* Otherwise, DECL does not need to be emitted -- yet.  A subsequent\n+     reference to DECL might cause it to be emitted later.  */\n+  return false;\n }\n \n /* If necessary, write out the vtables for the dynamic class CTYPE.\n@@ -1539,8 +1556,7 @@ maybe_emit_vtables (tree ctype)\n {\n   tree vtbl;\n   tree primary_vtbl;\n-  bool needed = false;\n-  bool weaken_vtables;\n+  int needed = 0;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -1551,16 +1567,14 @@ maybe_emit_vtables (tree ctype)\n   if (TREE_TYPE (primary_vtbl) == void_type_node)\n     return false;\n \n-  import_export_class (ctype);\n-\n   /* See if any of the vtables are needed.  */\n   for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n     {\n-      import_export_vtable (vtbl, ctype, 1);\n-      if (!DECL_EXTERNAL (vtbl) && DECL_NEEDED_P (vtbl))\n-\tbreak;\n+      import_export_decl (vtbl);\n+      if (DECL_NOT_REALLY_EXTERN (vtbl) && decl_needed_p (vtbl))\n+\tneeded = 1;\n     }\n-  if (!vtbl)\n+  if (!needed)\n     {\n       /* If the references to this class' vtables are optimized away,\n \t still emit the appropriate debugging information.  See\n@@ -1570,82 +1584,23 @@ maybe_emit_vtables (tree ctype)\n \tnote_debug_info_needed (ctype);\n       return false;\n     }\n-  else if (TREE_PUBLIC (vtbl) && !DECL_COMDAT (vtbl))\n-    needed = true;\n-  \n-  /* Determine whether to make vtables weak.  The ABI requires that we\n-      do so.  There are two cases in which we have to violate the ABI\n-      specification: targets where we don't have weak symbols\n-      (obviously), and targets where weak symbols don't appear in\n-      static archives' tables of contents.  On such targets, avoiding\n-      undefined symbol link errors requires that we only make a symbol\n-      weak if we know that it will be emitted everywhere it's needed.\n-      So on such targets we don't make vtables weak in the common case\n-      where we're emitting a vtable of a nontemplate class in the \n-      translation unit containing the definition of a noninline key\n-      method. */\n-  if (flag_weak && !TARGET_WEAK_NOT_IN_ARCHIVE_TOC)\n-    weaken_vtables = true;\n-  else if (flag_weak)\n-    {\n-      if (CLASSTYPE_USE_TEMPLATE (ctype))\n- \tweaken_vtables = CLASSTYPE_IMPLICIT_INSTANTIATION (ctype);\n-      else\n- \tweaken_vtables = !CLASSTYPE_KEY_METHOD (ctype)\n- \t  || DECL_DECLARED_INLINE_P (CLASSTYPE_KEY_METHOD (ctype));\n-    }\n-  else\n-    weaken_vtables = false;\n \n   /* The ABI requires that we emit all of the vtables if we emit any\n      of them.  */\n   for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n     {\n-      /* Write it out.  */\n-      import_export_vtable (vtbl, ctype, 1);\n+      /* Mark entities references from the virtual table as used.  */\n       mark_vtable_entries (vtbl);\n \n-      /* If we know that DECL is needed, mark it as such for the varpool.  */\n-      if (needed)\n-\tcgraph_varpool_mark_needed_node (cgraph_varpool_node (vtbl));\n-\n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n \t  /* It had better be all done at compile-time.  */\n \t  if (store_init_value (vtbl, DECL_INITIAL (vtbl)))\n \t    abort ();\n \t}\n \n-      if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n-\t{\n-\t  /* Mark the VAR_DECL node representing the vtable itself as a\n-\t     \"gratuitous\" one, thereby forcing dwarfout.c to ignore it.\n-\t     It is rather important that such things be ignored because\n-\t     any effort to actually generate DWARF for them will run\n-\t     into trouble when/if we encounter code like:\n-\n-\t\t#pragma interface\n-\t\tstruct S { virtual void member (); };\n-\n-\t      because the artificial declaration of the vtable itself (as\n-\t      manufactured by the g++ front end) will say that the vtable\n-\t      is a static member of `S' but only *after* the debug output\n-\t      for the definition of `S' has already been output.  This causes\n-\t      grief because the DWARF entry for the definition of the vtable\n-\t      will try to refer back to an earlier *declaration* of the\n-\t      vtable as a static member of `S' and there won't be one.\n-\t      We might be able to arrange to have the \"vtable static member\"\n-\t      attached to the member list for `S' before the debug info for\n-\t      `S' get written (which would solve the problem) but that would\n-\t      require more intrusive changes to the g++ front end.  */\n-\n-\t  DECL_IGNORED_P (vtbl) = 1;\n-\t}\n-\n-      /* Always make vtables weak.  Or at least almost always; see above. */\n-      if (weaken_vtables)\n-\tcomdat_linkage (vtbl);\n-\n+      /* Write it out.  */\n+      DECL_EXTERNAL (vtbl) = 0;\n       rest_of_decl_compilation (vtbl, NULL, 1, 1);\n \n       /* Because we're only doing syntax-checking, we'll never end up\n@@ -1661,38 +1616,194 @@ maybe_emit_vtables (tree ctype)\n   return true;\n }\n \n-/* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n-   inline function or template instantiation at end-of-file.  */\n+/* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage\n+   for DECL has not already been determined, do so now by setting\n+   DECL_EXTERNAL, DECL_COMDAT and other related flags.  Until this\n+   function is called entities with vague linkage whose definitions\n+   are available must have TREE_PUBLIC set.\n+\n+   If this function decides to place DECL in COMDAT, it will set\n+   appropriate flags -- but will not clear DECL_EXTERNAL.  It is up to\n+   the caller to decide whether or not to clear DECL_EXTERNAL.  Some\n+   callers defer that decision until it is clear that DECL is actually\n+   required.  */\n \n void\n import_export_decl (tree decl)\n {\n+  int emit_p;\n+  bool comdat_p;\n+  bool import_p;\n+\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n \n-  if (DECL_TEMPLATE_INSTANTIATION (decl)\n-      || DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl))\n-    {\n-      DECL_NOT_REALLY_EXTERN (decl) = 1;\n-      if ((DECL_IMPLICIT_INSTANTIATION (decl)\n-\t   || DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl))\n-\t  && (flag_implicit_templates\n-\t      || (flag_implicit_inline_templates\n-\t\t  && TREE_CODE (decl) == FUNCTION_DECL \n-\t\t  && DECL_DECLARED_INLINE_P (decl))))\n+  /* We cannot determine what linkage to give to an entity with vague\n+     linkage until the end of the file.  For example, a virtual table\n+     for a class will be defined if and only if the key method is\n+     defined in this translation unit.  As a further example, consider\n+     that when compiling a translation unit that uses PCH file with\n+     \"-frepo\" it would be incorrect to make decisions about what\n+     entities to emit when building the PCH; those decisions must be\n+     delayed until the repository information has been processed.  */\n+  my_friendly_assert (at_eof, 20040727);\n+  /* Object file linkage for explicit instantiations is handled in\n+     mark_decl_instantiated.  For static variables in functions with\n+     vague linkage, maybe_commonize_var is used.\n+\n+     Therefore, the only declarations that should be provided to this\n+     function are those with external linkage that:\n+\n+     * implicit instantiations of function templates\n+\n+     * inline function\n+\n+     * implicit instantiations of static data members of class\n+       templates\n+\n+     * virtual tables\n+\n+     * typeinfo objects\n+\n+     Furthermore, all entities that reach this point must have a\n+     definition available in this translation unit.\n+\n+     The following assertions check these conditions.  */\n+  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t      || TREE_CODE (decl) == VAR_DECL,\n+\t\t      2004725);\n+  /* Any code that creates entities with TREE_PUBLIC cleared should\n+     also set DECL_INTERFACE_KNOWN.  */\n+  my_friendly_assert (TREE_PUBLIC (decl), 20040725);\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    my_friendly_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t\t|| DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl)\n+\t\t\t|| DECL_DECLARED_INLINE_P (decl),\n+\t\t\t20040725);\n+  else\n+    my_friendly_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t\t|| DECL_VTABLE_OR_VTT_P (decl)\n+\t\t\t|| DECL_TINFO_P (decl),\n+\t\t\t20040725);\n+  /* Check that a definition of DECL is available in this translation\n+     unit.  */\n+  my_friendly_assert (!DECL_REALLY_EXTERN (decl), 20040725);\n+\n+  /* Assume that DECL will not have COMDAT linkage.  */\n+  comdat_p = false;\n+  /* Assume that DECL will not be imported into this translation\n+     unit.  */\n+  import_p = false;\n+\n+  /* See if the repository tells us whether or not to emit DECL in\n+     this translation unit.  */\n+  emit_p = repo_emit_p (decl);\n+  if (emit_p == 0)\n+    import_p = true;\n+  else if (emit_p == 1)\n+    {\n+      /* The repository indicates that this entity should be defined\n+\t here.  Make sure the back end honors that request.  */\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\tmark_needed (decl);\n+      else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)\n+\t       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n \t{\n-\t  if (!TREE_PUBLIC (decl))\n-\t    /* Templates are allowed to have internal linkage.  See \n-\t       [basic.link].  */\n-\t    ;\n-\t  else\n-\t    comdat_linkage (decl);\n+\t  tree clone;\n+\t  FOR_EACH_CLONE (clone, decl)\n+\t    mark_needed (clone);\n \t}\n       else\n+\tmark_needed (decl);\n+      /* Output the definition as an ordinary strong definition.  */\n+      DECL_EXTERNAL (decl) = 0;\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+      return;\n+    }\n+\n+  if (import_p)\n+    /* We have already decided what to do with this DECL; there is no\n+       need to check anything further.  */\n+    ;\n+  else if (TREE_CODE (decl) == VAR_DECL && DECL_VTABLE_OR_VTT_P (decl))\n+    {\n+      tree type = DECL_CONTEXT (decl);\n+      import_export_class (type);\n+      if (TYPE_FOR_JAVA (type))\n+\timport_p = true;\n+      else if (CLASSTYPE_INTERFACE_KNOWN (type)\n+\t       && CLASSTYPE_INTERFACE_ONLY (type))\n+\timport_p = true;\n+      else if (TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n+\t       && !CLASSTYPE_USE_TEMPLATE (type)\n+\t       && CLASSTYPE_KEY_METHOD (type)\n+\t       && !DECL_DECLARED_INLINE_P (CLASSTYPE_KEY_METHOD (type)))\n+\t/* The ABI requires that all virtual tables be emitted with\n+\t   COMDAT linkage.  However, on systems where COMDAT symbols\n+\t   don't show up in the table of contents for a static\n+\t   archive, the linker will report errors about undefined\n+\t   symbols because it will not see the virtual table\n+\t   definition.  Therefore, in the case that we know that the\n+\t   virtual table will be emitted in only one translation\n+\t   unit, we make the virtual table an ordinary definition\n+\t   with external linkage.  */\n+\tDECL_EXTERNAL (decl) = 0;\n+      else if (CLASSTYPE_INTERFACE_KNOWN (type))\n \t{\n-\t  DECL_EXTERNAL (decl) = 1;\n-\t  DECL_NOT_REALLY_EXTERN (decl) = 0;\n+\t  /* TYPE is being exported from this translation unit, so DECL\n+\t     should be defined here.  The ABI requires COMDAT\n+\t     linkage.  Normally, we only emit COMDAT things when they\n+\t     are needed; make sure that we realize that this entity is\n+\t     indeed needed.  */\n+\t  comdat_p = true;\n+\t  mark_needed (decl);\n \t}\n+      else if (!flag_implicit_templates\n+\t       && CLASSTYPE_IMPLICIT_INSTANTIATION (type))\n+\timport_p = true;\n+      else\n+\tcomdat_p = true;\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl))\n+    {\n+      tree type = TREE_TYPE (DECL_NAME (decl));\n+      if (CLASS_TYPE_P (type))\n+\t{\n+\t  import_export_class (type);\n+\t  if (CLASSTYPE_INTERFACE_KNOWN (type)\n+\t      && TYPE_POLYMORPHIC_P (type)\n+\t      && CLASSTYPE_INTERFACE_ONLY (type)\n+\t      /* If -fno-rtti was specified, then we cannot be sure\n+\t\t that RTTI information will be emitted with the\n+\t\t virtual table of the class, so we must emit it\n+\t\t wherever it is used.  */\n+\t      && flag_rtti)\n+\t    import_p = true;\n+\t  else \n+\t    {\n+\t      comdat_p = true;\n+\t      if (CLASSTYPE_INTERFACE_KNOWN (type)\n+\t\t  && !CLASSTYPE_INTERFACE_ONLY (type))\n+\t\tmark_needed (decl);\n+\t    }\n+\t}\n+      else\n+\tcomdat_p = true;\n+    }\n+  else if (DECL_TEMPLATE_INSTANTIATION (decl)\n+\t   || DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl))\n+    {\n+      /* DECL is an implicit instantiation of a function or static\n+\t data member.  */\n+      if (flag_implicit_templates\n+\t  || (flag_implicit_inline_templates\n+\t      && TREE_CODE (decl) == FUNCTION_DECL \n+\t      && DECL_DECLARED_INLINE_P (decl)))\n+\tcomdat_p = true;\n+      else\n+\t/* If we are not implicitly generating templates, then mark\n+\t   this entity as undefined in this translation unit.  */\n+\timport_p = true;\n     }\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n@@ -1713,55 +1824,31 @@ import_export_decl (tree decl)\n \n \t      /* Always make artificials weak.  */\n \t      if (DECL_ARTIFICIAL (decl) && flag_weak)\n-\t\tcomdat_linkage (decl);\n+\t\tcomdat_p = true;\n \t      else\n \t\tmaybe_make_one_only (decl);\n \t    }\n \t}\n       else\n-\tcomdat_linkage (decl);\n+\tcomdat_p = true;\n     }\n   else\n-    comdat_linkage (decl);\n-\n-  DECL_INTERFACE_KNOWN (decl) = 1;\n-}\n-\n-/* Here, we only decide whether or not the tinfo node should be\n-   emitted with the vtable.  IS_IN_LIBRARY is nonzero iff the\n-   typeinfo for TYPE should be in the runtime library.  */\n+    comdat_p = true;\n \n-void\n-import_export_tinfo (tree decl, tree type, bool is_in_library)\n-{\n-  if (DECL_INTERFACE_KNOWN (decl))\n-    return;\n-  \n-  if (IS_AGGR_TYPE (type))\n-    import_export_class (type);\n-      \n-  if (IS_AGGR_TYPE (type) && CLASSTYPE_INTERFACE_KNOWN (type)\n-      && TYPE_POLYMORPHIC_P (type)\n-      /* If -fno-rtti, we're not necessarily emitting this stuff with\n-\t the class, so go ahead and emit it now.  This can happen when\n-\t a class is used in exception handling.  */\n-      && flag_rtti)\n+  if (import_p)\n     {\n-      DECL_NOT_REALLY_EXTERN (decl) = !CLASSTYPE_INTERFACE_ONLY (type);\n-      DECL_COMDAT (decl) = 0;\n+      /* If we are importing DECL into this translation unit, mark is\n+\t an undefined here.  */\n+      DECL_EXTERNAL (decl) = 1;\n+      DECL_NOT_REALLY_EXTERN (decl) = 0;\n     }\n-  else\n+  else if (comdat_p)\n     {\n-      DECL_NOT_REALLY_EXTERN (decl) = 1;\n-      DECL_COMDAT (decl) = 1;\n+      /* If we decided to put DECL in COMDAT, mark it accordingly at\n+\t this point.  */\n+      comdat_linkage (decl);\n     }\n \n-  /* Now override some cases.  */\n-  if (flag_weak)\n-    DECL_COMDAT (decl) = 1;\n-  else if (is_in_library)\n-    DECL_COMDAT (decl) = 0;\n-  \n   DECL_INTERFACE_KNOWN (decl) = 1;\n }\n \n@@ -2403,8 +2490,14 @@ write_out_vars (tree vars)\n   tree v;\n \n   for (v = vars; v; v = TREE_CHAIN (v))\n-    if (!var_finalized_p (TREE_VALUE (v)))\n-      rest_of_decl_compilation (TREE_VALUE (v), 0, 1, 1);\n+    {\n+      tree var = TREE_VALUE (v);\n+      if (!var_finalized_p (var))\n+\t{\n+\t  import_export_decl (var);\n+\t  rest_of_decl_compilation (var, 0, 1, 1);\n+\t}\n+    }\n }\n \n /* Generate a static constructor (if CONSTRUCTOR_P) or destructor\n@@ -2520,21 +2613,36 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n {\n   tree t = *tp;\n \n-  if (flag_unit_at_a_time)\n-    switch (TREE_CODE (t))\n-      {\n-      case PTRMEM_CST:\n-\tif (TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n-\t  cgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (t)));\n-\tbreak;\n-      case BASELINK:\n-\tif (TREE_CODE (BASELINK_FUNCTIONS (t)) == FUNCTION_DECL)\n-\t  cgraph_mark_needed_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n+  switch (TREE_CODE (t))\n+    {\n+    case PTRMEM_CST:\n+      if (TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n+\tcgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (t)));\n+      break;\n+    case BASELINK:\n+      if (TREE_CODE (BASELINK_FUNCTIONS (t)) == FUNCTION_DECL)\n+\tcgraph_mark_needed_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n+      break;\n+    case VAR_DECL:\n+      if (DECL_VTABLE_OR_VTT_P (t))\n+\t{\n+\t  /* The ABI requires that all virtual tables be emitted\n+\t     whenever one of them is.  */\n+\t  tree vtbl;\n+\t  for (vtbl = CLASSTYPE_VTABLES (DECL_CONTEXT (t));\n+\t       vtbl;\n+\t       vtbl = TREE_CHAIN (vtbl))\n+\t    mark_decl_referenced (vtbl);\n+\t}\n+      else if (DECL_CONTEXT (t) \n+\t       && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)\n+\t/* If we need a static variable in a function, then we\n+\t   need the containing function.  */\n+\tmark_decl_referenced (DECL_CONTEXT (t));\n+      break;\n+    default:\n+      break;\n+    }\n \n   return NULL;\n }\n@@ -2732,16 +2840,15 @@ finish_file (void)\n #endif\n \t}\n       \n+      /* Go through the set of inline functions whose bodies have not\n+\t been emitted yet.  If out-of-line copies of these functions\n+\t are required, emit them.  */\n       for (i = 0; i < deferred_fns_used; ++i)\n \t{\n \t  tree decl = VARRAY_TREE (deferred_fns, i);\n \n-\t  if (! DECL_DECLARED_INLINE_P (decl) || ! TREE_USED (decl))\n-\t    abort ();\n-\n \t  /* Does it need synthesizing?  */\n \t  if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t      && TREE_USED (decl)\n \t      && (! DECL_REALLY_EXTERN (decl) || DECL_INLINE (decl)))\n \t    {\n \t      /* Even though we're already at the top-level, we push\n@@ -2772,18 +2879,17 @@ finish_file (void)\n \t     function twice.  */\n \t  if (DECL_NOT_REALLY_EXTERN (decl)\n \t      && DECL_INITIAL (decl)\n-\t      && DECL_NEEDED_P (decl))\n+\t      && decl_needed_p (decl))\n \t    DECL_EXTERNAL (decl) = 0;\n \n \t  /* If we're going to need to write this function out, and\n \t     there's already a body for it, create RTL for it now.\n \t     (There might be no body if this is a method we haven't\n \t     gotten around to synthesizing yet.)  */\n \t  if (!DECL_EXTERNAL (decl)\n-\t      && DECL_NEEDED_P (decl)\n+\t      && decl_needed_p (decl)\n \t      && !TREE_ASM_WRITTEN (decl)\n-\t      && (!flag_unit_at_a_time \n-\t\t  || !cgraph_node (decl)->local.finalized))\n+\t      && !cgraph_node (decl)->local.finalized)\n \t    {\n \t      /* We will output the function; no longer consider it in this\n \t\t loop.  */\n@@ -2807,19 +2913,26 @@ finish_file (void)\n       for (i = 0; i < pending_statics_used; ++i) \n \t{\n \t  tree decl = VARRAY_TREE (pending_statics, i);\n-\t  if (var_finalized_p (decl))\n+\t  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl))\n \t    continue;\n \t  import_export_decl (decl);\n-\t  if (DECL_NOT_REALLY_EXTERN (decl) && ! DECL_IN_AGGR_P (decl))\n+\t  /* If this static data member is needed, provide it to the\n+\t     back end.  */\n+\t  if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))\n \t    DECL_EXTERNAL (decl) = 0;\n \t}\n       if (pending_statics\n \t  && wrapup_global_declarations (&VARRAY_TREE (pending_statics, 0),\n \t\t\t\t\t pending_statics_used))\n \treconsider = true;\n \n+      /* Ask the back end to emit functions and variables that are\n+\t enqued.  These emissions may result in marking more entities\n+\t as needed.  */\n       if (cgraph_assemble_pending_functions ())\n \treconsider = true;\n+      if (cgraph_varpool_assemble_pending_decls ())\n+\treconsider = true;\n     } \n   while (reconsider);\n \n@@ -2828,7 +2941,17 @@ finish_file (void)\n     {\n       tree decl = VARRAY_TREE (deferred_fns, i);\n \n-      if (!TREE_ASM_WRITTEN (decl) && !DECL_SAVED_TREE (decl)\n+      if (/* Check online inline functions that were actually used.  */\n+\t  TREE_USED (decl) && DECL_DECLARED_INLINE_P (decl)\n+\t  /* But not defined.  */\n+\t  && DECL_REALLY_EXTERN (decl)\n+\t  /* If we decided to emit this function in another\n+\t     translation unit, the fact that the definition was\n+\t     missing here likely indicates only that the repository\n+\t     decided to place the function elsewhere.  With -Winline,\n+\t     we will still warn if we could not inline the\n+\t     function.  */\n+\t  && !flag_use_repository\n \t  /* An explicit instantiation can be used to specify\n \t     that the body is in another unit. It will have\n \t     already verified there was a definition.  */\n@@ -2840,7 +2963,6 @@ finish_file (void)\n \t     warning.  */\n \t  TREE_PUBLIC (decl) = 1;\n \t}\n-      \n     }\n   \n   /* We give C linkage to static constructors and destructors.  */\n@@ -2871,11 +2993,8 @@ finish_file (void)\n      linkage now.  */\n   pop_lang_context ();\n \n-  if (flag_unit_at_a_time)\n-    {\n-      cgraph_finalize_compilation_unit ();\n-      cgraph_optimize ();\n-    }\n+  cgraph_finalize_compilation_unit ();\n+  cgraph_optimize ();\n \n   /* Emit mudflap static registration function.  This must be done\n      after all the user functions have been expanded.  */\n@@ -3009,12 +3128,7 @@ mark_used (tree decl)\n     {\n       if (DECL_DEFERRED_FN (decl))\n \treturn;\n-      DECL_DEFERRED_FN (decl) = 1;\n-      DECL_DEFER_OUTPUT (decl) = 1;\n-      if (!deferred_fns)\n-\tVARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n-      \n-      VARRAY_PUSH_TREE (deferred_fns, decl);\n+      note_vague_linkage_fn (decl);\n     }\n   \n   assemble_external (decl);\n@@ -3044,40 +3158,11 @@ mark_used (tree decl)\n \t  || (TREE_CODE (decl) == FUNCTION_DECL \n \t      && DECL_INLINE (DECL_TEMPLATE_RESULT \n \t\t\t      (template_for_substitution (decl))))))\n-    {\n-      bool defer;\n-\n-      /* Normally, we put off instantiating functions in order to\n-\t improve compile times.  Maintaining a stack of active\n-\t functions is expensive, and the inliner knows to\n-\t instantiate any functions it might need.\n-\n-\t However, if instantiating this function might help us mark\n-\t the current function TREE_NOTHROW, we go ahead and\n-\t instantiate it now.  \n-\t \n-\t This is not needed for unit-at-a-time since we reorder the functions\n-\t in topological order anyway.\n-\t */\n-      defer = (!flag_exceptions\n-\t       || flag_unit_at_a_time\n-\t       || !optimize\n-\t       || TREE_CODE (decl) != FUNCTION_DECL\n-\t       /* If the called function can't throw, we don't need to\n-\t\t  generate its body to find that out.  */\n-\t       || TREE_NOTHROW (decl)\n-\t       || !cfun\n-\t       || !current_function_decl\n-\t       /* If we already know the current function can't throw,\n-\t\t  then we don't need to work hard to prove it.  */\n-\t       || TREE_NOTHROW (current_function_decl)\n-\t       /* If we already know that the current function *can*\n-\t\t  throw, there's no point in gathering more\n-\t\t  information.  */\n-\t       || cp_function_chain->can_throw);\n-\n-      instantiate_decl (decl, defer, /*undefined_ok=*/0);\n-    }\n+    /* We put off instantiating functions in order to improve compile\n+       times.  Maintaining a stack of active functions is expensive,\n+       and the inliner knows to instantiate any functions it might\n+       need.  */\n+    instantiate_decl (decl, /*defer_ok=*/true, /*undefined_ok=*/0);\n }\n \n #include \"gt-cp-decl2.h\""}, {"sha": "00adb7239c50b7d0a9c2c24a728ea7196b325db3", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -361,6 +361,17 @@ cxx_init (void)\n \n   interface_unknown = 1;\n \n+  /* The fact that G++ uses COMDAT for many entities (inline\n+     functions, template instantiations, virtual tables, etc.) mean\n+     that it is fundamentally unreliable to try to make decisions\n+     about whether or not to output a particular entity until the end\n+     of the compilation.  However, the inliner requires that functions\n+     be provided to the back end if they are to be inlined.\n+     Therefore, we always use unit-at-a-time mode; in that mode, we\n+     can provide entities to the back end and it will decide what to\n+     emit based on what is actually needed.  */\n+  flag_unit_at_a_time = 1;\n+\n   if (c_common_init () == false)\n     {\n       pop_srcloc();\n@@ -369,7 +380,7 @@ cxx_init (void)\n \n   init_cp_pragma ();\n \n-  init_repo (main_input_filename);\n+  init_repo ();\n \n   pop_srcloc();\n   return true;"}, {"sha": "d741d3d3cd1e3b719d21cda2a62b020e1467dded", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -700,9 +700,6 @@ synthesize_method (tree fndecl)\n   bool need_body = true;\n   tree stmt;\n \n-  if (at_eof)\n-    import_export_decl (fndecl);\n-\n   /* If we've been asked to synthesize a clone, just synthesize the\n      cloned function instead.  Doing so will automatically fill in the\n      body for the clone.  */\n@@ -1014,7 +1011,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL,\n \t       TYPE_UNQUALIFIED);\n   grok_special_member_properties (fn);\n-  TREE_PUBLIC (fn) = !decl_function_context (TYPE_MAIN_DECL (type));\n+  set_linkage_according_to_type (type, fn);\n   rest_of_decl_compilation (fn, /*asmspec=*/NULL,\n \t\t\t    toplevel_bindings_p (), at_eof);\n   DECL_IN_AGGR_P (fn) = 1;"}, {"sha": "b94270eabd65cfe30ad8f4813912290276553fa3", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -89,9 +89,7 @@ maybe_clone_body (tree fn)\n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n   push_to_top_level ();\n-  for (clone = TREE_CHAIN (fn);\n-       clone && DECL_CLONED_FUNCTION_P (clone);\n-       clone = TREE_CHAIN (clone))\n+  FOR_EACH_CLONE (clone, fn)\n     {\n       tree parm;\n       tree clone_parm;"}, {"sha": "0ecbda0fa1566acc4b59f46a39f6a13fee5a7506", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 102, "deletions": 115, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -5693,10 +5693,7 @@ instantiate_class_template (tree type)\n \n   unreverse_member_declarations (type);\n   finish_struct_1 (type);\n-\n-  /* Clear this now so repo_template_used is happy.  */\n   TYPE_BEING_DEFINED (type) = 0;\n-  repo_template_used (type);\n \n   /* Now that the class is complete, instantiate default arguments for\n      any member functions.  We don't do this earlier because the\n@@ -5715,7 +5712,11 @@ instantiate_class_template (tree type)\n   pop_deferring_access_checks ();\n   pop_tinst_level ();\n \n-  if (TYPE_CONTAINS_VPTR_P (type))\n+  /* The vtable for a template class can be emitted in any translation\n+     unit in which the class is instantiated.  When there is no key\n+     method, however, finish_struct_1 will already have added TYPE to\n+     the keyed_classes list.  */\n+  if (TYPE_CONTAINS_VPTR_P (type) && CLASSTYPE_KEY_METHOD (type))\n     keyed_classes = tree_cons (NULL_TREE, type, keyed_classes);\n \n   return type;\n@@ -6235,7 +6236,10 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \tTREE_STATIC (r) = 0;\n \tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n \tDECL_EXTERNAL (r) = 1;\n-\tDECL_INTERFACE_KNOWN (r) = 0;\n+\t/* If this is an instantiation of a function with internal\n+\t   linkage, we already know what object file linkage will be\n+\t   assigned to the instantiation.  */\n+\tDECL_INTERFACE_KNOWN (r) = !TREE_PUBLIC (r);\n \tDECL_DEFER_OUTPUT (r) = 0;\n \tTREE_CHAIN (r) = NULL_TREE;\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n@@ -8564,7 +8568,7 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n \t     shall not be used to declare an entity with linkage.\n \t     This implies that names with no linkage cannot be used as\n \t     template arguments.  */\n-\t  tree nt = no_linkage_check (t);\n+\t  tree nt = no_linkage_check (t, /*relaxed_p=*/false);\n \n \t  if (nt)\n \t    {\n@@ -8628,9 +8632,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n \treturn error_mark_node;\n \n       /* Look for the clone.  */\n-      for (clone = TREE_CHAIN (spec);\n-\t   clone && DECL_CLONED_FUNCTION_P (clone);\n-\t   clone = TREE_CHAIN (clone))\n+      FOR_EACH_CLONE (clone, spec)\n \tif (DECL_NAME (clone) == DECL_NAME (tmpl))\n \t  return clone;\n       /* We should always have found the clone by now.  */\n@@ -10076,9 +10078,20 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     }\n }\n \f\n+/* Note that DECL can be defined in this translation unit, if\n+   required.  */\n+\n+static void\n+mark_definable (tree decl)\n+{\n+  tree clone;\n+  DECL_NOT_REALLY_EXTERN (decl) = 1;\n+  FOR_EACH_CLONE (clone, decl)\n+    DECL_NOT_REALLY_EXTERN (clone) = 1;\n+}\n+\n /* Called if RESULT is explicitly instantiated, or is a member of an\n-   explicitly instantiated class, or if using -frepo and the\n-   instantiation of RESULT has been assigned to this file.  */\n+   explicitly instantiated class.  */\n \n void\n mark_decl_instantiated (tree result, int extern_p)\n@@ -10098,11 +10111,11 @@ mark_decl_instantiated (tree result, int extern_p)\n   /* This might have been set by an earlier implicit instantiation.  */\n   DECL_COMDAT (result) = 0;\n \n-  if (! extern_p)\n+  if (extern_p)\n+    DECL_NOT_REALLY_EXTERN (result) = 0;\n+  else\n     {\n-      DECL_INTERFACE_KNOWN (result) = 1;\n-      DECL_NOT_REALLY_EXTERN (result) = 1;\n-\n+      mark_definable (result);\n       /* Always make artificials weak.  */\n       if (DECL_ARTIFICIAL (result) && flag_weak)\n \tcomdat_linkage (result);\n@@ -10111,6 +10124,13 @@ mark_decl_instantiated (tree result, int extern_p)\n       else if (TREE_PUBLIC (result))\n \tmaybe_make_one_only (result);\n     }\n+  \n+  /* If EXTERN_P, then this function will not be emitted -- unless\n+     followed by an explicit instantiation, at which point its linkage\n+     will be adjusted.  If !EXTERN_P, then this function will be\n+     emitted here.  In neither circumstance do we want\n+     import_export_decl to adjust the linkage.  */\n+  DECL_INTERFACE_KNOWN (result) = 1; \n }\n \n /* Given two function templates PAT1 and PAT2, return:\n@@ -10548,15 +10568,14 @@ do_decl_instantiation (tree decl, tree storage)\n \t No program shall explicitly instantiate any template more\n \t than once.  \n \n-\t We check DECL_INTERFACE_KNOWN so as not to complain when the first\n-\t instantiation was `extern' and the second is not, and EXTERN_P for\n-\t the opposite case.  If -frepo, chances are we already got marked\n-\t as an explicit instantiation because of the repo file.  */\n-      if (DECL_INTERFACE_KNOWN (result) && !extern_p && !flag_use_repository)\n+\t We check DECL_NOT_REALLY_EXTERN so as not to complain when\n+\t the first instantiation was `extern' and the second is not,\n+\t and EXTERN_P for the opposite case.  */\n+      if (DECL_NOT_REALLY_EXTERN (result) && !extern_p)\n \tpedwarn (\"duplicate explicit instantiation of `%#D'\", result);\n-\n-      /* If we've already instantiated the template, just return now.  */\n-      if (DECL_INTERFACE_KNOWN (result))\n+      /* If an \"extern\" explicit instantiation follows an ordinary\n+\t explicit instantiation, the template is instantiated.  */\n+      if (extern_p)\n \treturn;\n     }\n   else if (!DECL_IMPLICIT_INSTANTIATION (result))\n@@ -10583,7 +10602,6 @@ do_decl_instantiation (tree decl, tree storage)\n \t      storage);\n \n   mark_decl_instantiated (result, extern_p);\n-  repo_template_instantiated (result, extern_p);\n   if (! extern_p)\n     instantiate_decl (result, /*defer_ok=*/1, /*undefined_ok=*/0);\n }\n@@ -10621,7 +10639,6 @@ static void\n instantiate_class_member (tree decl, int extern_p)\n {\n   mark_decl_instantiated (decl, extern_p);\n-  repo_template_instantiated (decl, extern_p);\n   if (! extern_p)\n     instantiate_decl (decl, /*defer_ok=*/1, /* undefined_ok=*/1);\n }\n@@ -10701,14 +10718,10 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n          If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit\n \t instantiation was `extern'.  If EXTERN_P then the second is.\n-\t If -frepo, chances are we already got marked as an explicit\n-\t instantiation because of the repo file.  All these cases are\n-\t OK.  */\n-\n+\t These cases are OK.  */\n       previous_instantiation_extern_p = CLASSTYPE_INTERFACE_ONLY (t);\n \n       if (!previous_instantiation_extern_p && !extern_p\n-\t  && !flag_use_repository\n \t  && (complain & tf_error))\n \tpedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n       \n@@ -10718,7 +10731,6 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n     }\n \n   mark_class_instantiated (t, extern_p);\n-  repo_template_instantiated (t, extern_p);\n \n   if (nomem_p)\n     return;\n@@ -11001,38 +11013,22 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n     pattern_defined = (DECL_SAVED_TREE (code_pattern) != NULL_TREE);\n   else\n     pattern_defined = ! DECL_IN_AGGR_P (code_pattern);\n+  /* Unless an explicit instantiation directive has already determined\n+     the linkage of D, remember that a definition is available for\n+     this entity.  */\n+  if (pattern_defined \n+      && !DECL_INTERFACE_KNOWN (d)\n+      && !DECL_NOT_REALLY_EXTERN (d))\n+    mark_definable (d);\n \n   input_location = DECL_SOURCE_LOCATION (d);\n \n-  if (pattern_defined)\n+  if (! pattern_defined && DECL_EXPLICIT_INSTANTIATION (d) && undefined_ok)\n     {\n-      /* Let the repository code that this template definition is\n-\t available.\n-\n-\t The repository doesn't need to know about cloned functions\n-\t because they never actually show up in the object file.  It\n-\t does need to know about the clones; those are the symbols\n-\t that the linker will be emitting error messages about.  */\n-      if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (d)\n-\t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (d))\n-\t{\n-\t  tree t;\n-\n-\t  for (t = TREE_CHAIN (d);\n-\t       t && DECL_CLONED_FUNCTION_P (t); \n-\t       t = TREE_CHAIN (t))\n-\t    repo_template_used (t);\n-\t}\n-      else\n-\trepo_template_used (d);\n-\n-      if (at_eof)\n-\timport_export_decl (d);\n+      DECL_NOT_REALLY_EXTERN (d) = 0;\n+      SET_DECL_IMPLICIT_INSTANTIATION (d);\n     }\n \n-  if (! pattern_defined && DECL_EXPLICIT_INSTANTIATION (d) && undefined_ok)\n-    SET_DECL_IMPLICIT_INSTANTIATION (d);\n-\n   if (!defer_ok)\n     {\n       /* Recheck the substitutions to obtain any warning messages\n@@ -11061,15 +11057,19 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n       pop_access_scope (d);\n     }\n   \n-  if (TREE_CODE (d) == VAR_DECL && DECL_INITIALIZED_IN_CLASS_P (d)\n-      && DECL_INITIAL (d) == NULL_TREE)\n-    /* We should have set up DECL_INITIAL in instantiate_class_template.  */\n-    abort ();\n-  /* Reject all external templates except inline functions.  */\n-  else if (DECL_INTERFACE_KNOWN (d)\n-\t   && ! DECL_NOT_REALLY_EXTERN (d)\n-\t   && ! (TREE_CODE (d) == FUNCTION_DECL \n-\t\t && DECL_INLINE (d)))\n+  /* We should have set up DECL_INITIAL in instantiate_class_template\n+     for in-class definitions of static data members.  */\n+  my_friendly_assert (!(TREE_CODE (d) == VAR_DECL \n+\t\t\t&& DECL_INITIALIZED_IN_CLASS_P (d)\n+\t\t\t&& DECL_INITIAL (d) == NULL_TREE),\n+\t\t      20040726);\n+\n+  /* Do not instantiate templates that we know will be defined\n+     elsewhere.  */\n+  if (DECL_INTERFACE_KNOWN (d)\n+      && DECL_REALLY_EXTERN (d)\n+      && ! (TREE_CODE (d) == FUNCTION_DECL \n+\t    && DECL_INLINE (d)))\n     goto out;\n   /* Defer all other templates, unless we have been explicitly\n      forbidden from doing so.  We restore the source position here\n@@ -11093,6 +11093,22 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n       add_pending_template (d);\n       goto out;\n     }\n+  /* Tell the repository that D is available in this translation unit\n+     -- and see if it is supposed to be instantiated here.  */\n+  if (TREE_PUBLIC (d) && !DECL_REALLY_EXTERN (d) && !repo_emit_p (d))\n+    {\n+      /* In a PCH file, despite the fact that the repository hasn't\n+\t requested instantiation in the PCH it is still possible that\n+\t an instantiation will be required in a file that includes the\n+\t PCH.  */\n+      if (pch_file)\n+\tadd_pending_template (d);\n+      /* Instantiate inline functions so that the inliner can do its\n+\t job, even though we'll not be emitting a copy of this\n+\t function.  */\n+      if (!flag_inline_trees || !DECL_DECLARED_INLINE_P (d))\n+\tgoto out;\n+    }\n \n   need_push = !cfun || !global_bindings_p ();\n   if (need_push)\n@@ -11105,7 +11121,7 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n   /* Regenerate the declaration in case the template has been modified\n      by a subsequent redeclaration.  */\n   regenerate_decl_from_template (d, td);\n-  \n+\n   /* We already set the file and line above.  Reset them now in case\n      they changed as a result of calling regenerate_decl_from_template.  */\n   input_location = DECL_SOURCE_LOCATION (d);\n@@ -11115,51 +11131,27 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n       /* Clear out DECL_RTL; whatever was there before may not be right\n \t since we've reset the type of the declaration.  */\n       SET_DECL_RTL (d, NULL_RTX);\n-\n       DECL_IN_AGGR_P (d) = 0;\n-      import_export_decl (d);\n-      DECL_EXTERNAL (d) = ! DECL_NOT_REALLY_EXTERN (d);\n-\n-      if (DECL_EXTERNAL (d))\n-\t{\n-\t  /* The fact that this code is executing indicates that:\n-\t     \n-\t     (1) D is a template static data member, for which a\n-\t         definition is available.\n-\n-\t     (2) An implicit or explicit instantiation has occurred.\n-\n-\t     (3) We are not going to emit a definition of the static\n-\t         data member at this time.\n \n-\t     This situation is peculiar, but it occurs on platforms\n-\t     without weak symbols when performing an implicit\n-\t     instantiation.  There, we cannot implicitly instantiate a\n-\t     defined static data member in more than one translation\n-\t     unit, so import_export_decl marks the declaration as\n-\t     external; we must rely on explicit instantiation.\n-\n-             Reset instantiated marker to make sure that later\n-             explicit instantiation will be processed.  */\n-          DECL_TEMPLATE_INSTANTIATED (d) = 0;\n-\t}\n-      else\n-\t{\n-\t  /* This is done in analogous to `start_decl'.  It is\n-\t     required for correct access checking.  */\n-\t  push_nested_class (DECL_CONTEXT (d));\n-\t  cp_finish_decl (d, \n-\t\t\t  (!DECL_INITIALIZED_IN_CLASS_P (d) \n-\t\t\t   ? DECL_INITIAL (d) : NULL_TREE),\n-\t\t\t  NULL_TREE, 0);\n-\t  /* Normally, pop_nested_class is called by cp_finish_decl\n-\t     above.  But when instantiate_decl is triggered during\n-\t     instantiate_class_template processing, its DECL_CONTEXT\n-\t     is still not completed yet, and pop_nested_class isn't\n-\t     called.  */\n-\t  if (!COMPLETE_TYPE_P (DECL_CONTEXT (d)))\n-\t    pop_nested_class ();\n-\t}\n+      /* Clear DECL_EXTERNAL so that cp_finish_decl will process the\n+\t initializer.  That function will defer actual emission until\n+\t we have a chance to determine linkage.  */\n+      DECL_EXTERNAL (d) = 0;\n+\n+      /* This is done in analogous to `start_decl'.  It is required\n+\t for correct access checking.  */\n+      push_nested_class (DECL_CONTEXT (d));\n+      cp_finish_decl (d, \n+\t\t      (!DECL_INITIALIZED_IN_CLASS_P (d) \n+\t\t       ? DECL_INITIAL (d) : NULL_TREE),\n+\t\t      NULL_TREE, 0);\n+      /* Normally, pop_nested_class is called by cp_finish_decl above.\n+\t But when instantiate_decl is triggered during\n+\t instantiate_class_template processing, its DECL_CONTEXT is\n+\t still not completed yet, and pop_nested_class isn't\n+\t called.  */\n+      if (!COMPLETE_TYPE_P (DECL_CONTEXT (d)))\n+\tpop_nested_class ();\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n@@ -11168,10 +11160,6 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n       tree tmpl_parm;\n       tree spec_parm;\n \n-      /* Mark D as instantiated so that recursive calls to\n-\t instantiate_decl do not try to instantiate it again.  */\n-      DECL_TEMPLATE_INSTANTIATED (d) = 1;\n-\n       /* Save away the current list, in case we are instantiating one\n \t template from within the body of another.  */\n       saved_local_specializations = local_specializations;\n@@ -11183,7 +11171,6 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n \t\t\t\t\t   NULL);\n \n       /* Set up context.  */\n-      import_export_decl (d);\n       start_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n \n       /* Create substitution entries for the parameters.  */"}, {"sha": "b3edf4875fc0e08e87bd91b8a367a7d7a6afe885", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 107, "deletions": 212, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -37,170 +37,20 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"diagnostic.h\"\n \n-static tree repo_get_id (tree);\n static char *extract_string (char **);\n static const char *get_base_filename (const char *);\n static void open_repo_file (const char *);\n static char *afgets (FILE *);\n static void reopen_repo_file_for_write (void);\n \n static GTY(()) tree pending_repo;\n-static GTY(()) tree original_repo;\n static char *repo_name;\n static FILE *repo_file;\n \n static const char *old_args, *old_dir, *old_main;\n \n static struct obstack temporary_obstack;\n-\n-#define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))\n-#define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_4 (NODE))\n-\n-#if 0\n-/* Record the flags used to compile this translation unit.  */\n-\n-void\n-repo_compile_flags (int argc, char **argv)\n-{\n-}\n-\n-/* If this template has not been seen before, add a note to the repository\n-   saying where the declaration was.  This may be used to find the\n-   definition at link time.  */\n-\n-void\n-repo_template_declared (tree t)\n-{}\n-\n-/* Note where the definition of a template lives so that instantiations can\n-   be generated later.  */\n-\n-void\n-repo_template_defined (tree t)\n-{}\n-\n-/* Note where the definition of a class lives to that template\n-   instantiations can use it.  */\n-\n-void\n-repo_class_defined (tree t)\n-{}\n-#endif\n-\n-static tree\n-repo_get_id (tree t)\n-{\n-  if (TYPE_P (t))\n-    {\n-      tree vtable;\n-\n-      /* If we're not done setting up the class, we may not have set up\n-\t the vtable, so going ahead would give the wrong answer.\n-         See g++.pt/instantiate4.C.  */\n-      if (!COMPLETE_TYPE_P (t) || TYPE_BEING_DEFINED (t))\n-\tabort ();\n-\n-      vtable = get_vtbl_decl_for_binfo (TYPE_BINFO (t));\n-\n-      t = vtable;\n-      if (t == NULL_TREE)\n-\treturn t;\n-    }\n-  return DECL_ASSEMBLER_NAME (t);\n-}\n-\n-/* Note that a template has been used.  If we can see the definition, offer\n-   to emit it.  */\n-\n-void\n-repo_template_used (tree t)\n-{\n-  tree id;\n-\n-  if (! flag_use_repository)\n-    return;\n-\n-  id = repo_get_id (t);\n-  if (id == NULL_TREE)\n-    return;\n-  \n-  if (TYPE_P (t))\n-    {\n-      if (IDENTIFIER_REPO_CHOSEN (id))\n-\tmark_class_instantiated (t, 0);\n-    }\n-  else if (DECL_P (t))\n-    {\n-      if (IDENTIFIER_REPO_CHOSEN (id))\n-\t/* It doesn't make sense to instantiate a clone, so we\n-\t   instantiate the cloned function instead.  Note that this\n-\t   approach will not work correctly if collect2 assigns\n-\t   different clones to different files -- but it shouldn't.  */\n-\tmark_decl_instantiated (DECL_CLONED_FUNCTION_P (t)\n-\t\t\t\t? DECL_CLONED_FUNCTION (t) : t, \n-\t\t\t\t0);\n-    }\n-  else\n-    abort ();\n-\n-  if (! IDENTIFIER_REPO_USED (id))\n-    {\n-      IDENTIFIER_REPO_USED (id) = 1;\n-      pending_repo = tree_cons (NULL_TREE, id, pending_repo);\n-    }\n-}\n-\n-#if 0\n-/* Note that the vtable for a class has been used, and offer to emit it.  */\n-\n-static void\n-repo_vtable_used (tree t)\n-{\n-  if (! flag_use_repository)\n-    return;\n-\n-  pending_repo = tree_cons (NULL_TREE, t, pending_repo);\n-}\n-\n-/* Note that an inline with external linkage has been used, and offer to\n-   emit it.  */\n-\n-void\n-repo_inline_used (tree fn)\n-{\n-  if (! flag_use_repository)\n-    return;\n-\n-  /* Member functions of polymorphic classes go with their vtables.  */\n-  if (DECL_FUNCTION_MEMBER_P (fn) \n-      && TYPE_POLYMORPHIC_P (DECL_CONTEXT (fn)))\n-    {\n-      repo_vtable_used (DECL_CONTEXT (fn));\n-      return;\n-    }\n-\n-  pending_repo = tree_cons (NULL_TREE, fn, pending_repo);\n-}\n-\n-/* Note that a particular typeinfo node has been used, and offer to\n-   emit it.  */\n-\n-void\n-repo_tinfo_used (tree ti)\n-{\n-}\n-#endif\n-\n-void\n-repo_template_instantiated (tree t, bool extern_p)\n-{\n-  if (! extern_p)\n-    {\n-      tree id = repo_get_id (t);\n-      if (id)\n-\tIDENTIFIER_REPO_CHOSEN (id) = 1;\n-    }\n-}\n+static bool temporary_obstack_initialized_p;\n \n /* Parse a reasonable subset of shell quoting syntax.  */\n \n@@ -298,16 +148,22 @@ afgets (FILE *stream)\n }\n \n void\n-init_repo (const char *filename)\n+init_repo (void)\n {\n   char *buf;\n \n   if (! flag_use_repository)\n     return;\n \n-  gcc_obstack_init (&temporary_obstack);\n+  /* When a PCH file is loaded, the entire identifier table is\n+     replaced, with the result that IDENTIFIER_REPO_CHOSEN is cleared.\n+     So, we have to reread the repository file.  */\n+  lang_post_pch_load = init_repo;\n+\n+  if (!temporary_obstack_initialized_p)\n+    gcc_obstack_init (&temporary_obstack);\n \n-  open_repo_file (filename);\n+  open_repo_file (main_input_filename);\n \n   if (repo_file == 0)\n     return;\n@@ -325,35 +181,29 @@ init_repo (const char *filename)\n \tcase 'M':\n \t  old_main = ggc_strdup (buf + 2);\n \t  break;\n-\tcase 'C':\n \tcase 'O':\n+\t  /* A symbol that we were able to define the last time this\n+\t     file was compiled.  */\n+\t  break;\n+\tcase 'C':\n+\t  /* A symbol that the prelinker has requested that we\n+\t     define.  */\n \t  {\n \t    tree id = get_identifier (buf + 2);\n-\t    tree orig;\n-\n-\t    if (buf[0] == 'C')\n-\t      {\n-\t\tIDENTIFIER_REPO_CHOSEN (id) = 1;\n-\t\torig = integer_one_node;\n-\t      }\n-\t    else\n-\t      orig = NULL_TREE;\n-\n-\t    original_repo = tree_cons (orig, id, original_repo);\n+\t    IDENTIFIER_REPO_CHOSEN (id) = 1;\n \t  }\n \t  break;\n \tdefault:\n \t  error (\"mysterious repository information in %s\", repo_name);\n \t}\n       obstack_free (&temporary_obstack, buf);\n     }\n+  fclose (repo_file);\n }\n \n static void\n reopen_repo_file_for_write (void)\n {\n-  if (repo_file)\n-    fclose (repo_file);\n   repo_file = fopen (repo_name, \"w\");\n \n   if (repo_file == 0)\n@@ -369,74 +219,119 @@ void\n finish_repo (void)\n {\n   tree t;\n-  bool repo_changed = false;\n   char *dir, *args;\n \n   if (!flag_use_repository)\n     return;\n \n-  /* Do we have to write out a new info file?  */\n-\n-  /* Are there any old templates that aren't used any longer or that are\n-     newly chosen?  */\n-  \n-  for (t = original_repo; t; t = TREE_CHAIN (t))\n-    {\n-      if (!IDENTIFIER_REPO_USED (TREE_VALUE (t))\n-\t  || (!TREE_PURPOSE (t) && IDENTIFIER_REPO_CHOSEN (TREE_VALUE (t))))\n-\t{\n-\t  repo_changed = true;\n-\t  break;\n-\t}\n-      IDENTIFIER_REPO_USED (TREE_VALUE (t)) = 0;\n-    }\n-\n-  /* Are there any templates that are newly used?  */\n-  \n-  if (!repo_changed)\n-    for (t = pending_repo; t; t = TREE_CHAIN (t))\n-      {\n-\tif (IDENTIFIER_REPO_USED (TREE_VALUE (t)))\n-\t  {\n-\t    repo_changed = true;\n-\t    break;\n-\t  }\n-      }\n-\n-  dir = getpwd ();\n-  args = getenv (\"COLLECT_GCC_OPTIONS\");\n-\n-  if (!repo_changed && pending_repo)\n-    if (strcmp (old_main, main_input_filename) != 0\n-\t|| strcmp (old_dir, dir) != 0\n-\t|| (args == NULL) != (old_args == NULL)\n-\t|| (args && strcmp (old_args, args) != 0))\n-      repo_changed = true;\n-\n-  if (!repo_changed || errorcount || sorrycount)\n+  if (errorcount || sorrycount)\n     goto out;\n \n   reopen_repo_file_for_write ();\n-\n   if (repo_file == 0)\n     goto out;\n \n   fprintf (repo_file, \"M %s\\n\", main_input_filename);\n+  dir = getpwd ();\n   fprintf (repo_file, \"D %s\\n\", dir);\n+  args = getenv (\"COLLECT_GCC_OPTIONS\");\n   if (args)\n     fprintf (repo_file, \"A %s\\n\", args);\n \n   for (t = pending_repo; t; t = TREE_CHAIN (t))\n     {\n       tree val = TREE_VALUE (t);\n-      char type = IDENTIFIER_REPO_CHOSEN (val) ? 'C' : 'O';\n-\n-      fprintf (repo_file, \"%c %s\\n\", type, IDENTIFIER_POINTER (val));\n+      tree name = DECL_ASSEMBLER_NAME (val);\n+      char type = IDENTIFIER_REPO_CHOSEN (name) ? 'C' : 'O';\n+      fprintf (repo_file, \"%c %s\\n\", type, IDENTIFIER_POINTER (name));\n     }\n \n  out:\n   if (repo_file)\n     fclose (repo_file);\n }\n \n+/* DECL is a FUNCTION_DECL or VAR_DECL with vague linkage whose\n+   definition is available in this translation unit.  Returns 0 if\n+   this definition should not be emitted in this translation unit\n+   because it will be emitted elsewhere.  Returns 1 if the repository\n+   file indicates that that DECL should be emitted in this translation\n+   unit, or 2 if the repository file is not in use.  */\n+\n+int\n+repo_emit_p (tree decl)\n+{\n+  my_friendly_assert (TREE_PUBLIC (decl), 20040725);\n+  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t      || TREE_CODE (decl) == VAR_DECL,\n+\t\t      20040725);\n+  my_friendly_assert (!DECL_REALLY_EXTERN (decl), 20040725);\n+\n+  /* When not using the repository, emit everything.  */\n+  if (!flag_use_repository)\n+    return 2;\n+\n+  /* Only template instantiations are managed by the repository.  This\n+     is an artificial restriction; the code in the prelinker and here\n+     will work fine if all entities with vague linkage are managed by\n+     the repository.  */\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      tree type = NULL_TREE;\n+      if (DECL_VTABLE_OR_VTT_P (decl))\n+\ttype = DECL_CONTEXT (decl);\n+      else if (DECL_TINFO_P (decl))\n+\ttype = TREE_TYPE (DECL_NAME (decl));\n+      if (!DECL_TEMPLATE_INSTANTIATION (decl)\n+\t  && !CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+\treturn 2;\n+    }\n+  else if (!DECL_TEMPLATE_INSTANTIATION (decl))\n+    return 2;\n+\n+  /* For constructors and destructors, the repository contains\n+     information about the clones -- not the original function --\n+     because only the clones are emitted in the object file.  */\n+  if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)\n+      || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n+    {\n+      int emit_p = 0;\n+      tree clone;\n+      /* There is no early exit from this loop because we want to\n+\t ensure that all of the clones are marked as available in this\n+\t object file.  */\n+      FOR_EACH_CLONE (clone, decl)\n+\t/* The only possible results from the recursive call to\n+\t   repo_emit_p are 0 or 1.  */\n+\tif (repo_emit_p (clone))\n+\t  emit_p = 1;\n+      return emit_p;\n+    }\n+\n+  /* Keep track of all available entities.  */\n+  if (!DECL_REPO_AVAILABLE_P (decl))\n+    {\n+      DECL_REPO_AVAILABLE_P (decl) = 1;\n+      pending_repo = tree_cons (NULL_TREE, decl, pending_repo);\n+    }\n+\n+  return IDENTIFIER_REPO_CHOSEN (DECL_ASSEMBLER_NAME (decl));\n+}\n+\n+/* Returns true iff the prelinker has explicitly marked CLASS_TYPE for\n+   export from this translation unit.  */\n+\n+bool\n+repo_export_class_p (tree class_type)\n+{\n+  if (!flag_use_repository)\n+    return false;\n+  if (!CLASSTYPE_VTABLES (class_type))\n+    return false;\n+  /* If the virtual table has been assigned to this translation unit,\n+     export the class.  */\n+  return (IDENTIFIER_REPO_CHOSEN \n+\t  (DECL_ASSEMBLER_NAME (CLASSTYPE_VTABLES (class_type))));\n+}\n+\n #include \"gt-cp-repo.h\""}, {"sha": "83e24c4e21c28aec70e87eaf17464ea5a3f72bb1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 103, "deletions": 89, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -89,18 +89,15 @@ static int qualifier_flags (tree);\n static bool target_incomplete_p (tree);\n static tree tinfo_base_init (tree, tree);\n static tree generic_initializer (tree, tree);\n-static tree ptr_initializer (tree, tree, bool *);\n-static tree ptm_initializer (tree, tree, bool *);\n static tree dfs_class_hint_mark (tree, void *);\n static tree dfs_class_hint_unmark (tree, void *);\n static int class_hint_flags (tree);\n static tree class_initializer (tree, tree, tree);\n static tree create_pseudo_type_info (const char *, int, ...);\n-static tree get_pseudo_ti_init (tree, tree, bool *);\n+static tree get_pseudo_ti_init (tree, tree);\n static tree get_pseudo_ti_desc (tree);\n static void create_tinfo_types (void);\n static bool typeinfo_in_lib_p (tree);\n-static bool unemitted_tinfo_decl_p (tree);\n \n static int doing_runtime = 0;\n \f\n@@ -348,14 +345,16 @@ get_tinfo_decl (tree type)\n       tree var_desc = get_pseudo_ti_desc (type);\n \n       d = build_lang_decl (VAR_DECL, name, TINFO_PSEUDO_TYPE (var_desc));\n-      \n+      SET_DECL_ASSEMBLER_NAME (d, name);\n+      DECL_TINFO_P (d) = 1;\n       DECL_ARTIFICIAL (d) = 1;\n       TREE_READONLY (d) = 1;\n       TREE_STATIC (d) = 1;\n+      /* Mark the variable as undefined -- but remember that we can\n+\t define it later if we need to do so.  */\n       DECL_EXTERNAL (d) = 1;\n-      DECL_COMDAT (d) = 1;\n-      TREE_PUBLIC (d) = 1;\n-      SET_DECL_ASSEMBLER_NAME (d, name);\n+      DECL_NOT_REALLY_EXTERN (d) = 1;\n+      set_linkage_according_to_type (type, d);\n \n       pushdecl_top_level_and_finish (d, NULL_TREE);\n \n@@ -732,6 +731,38 @@ target_incomplete_p (tree type)\n       return !COMPLETE_OR_VOID_TYPE_P (type);\n }\n \n+/* Returns true if TYPE involves an incomplete class type; in that\n+   case, typeinfo variables for TYPE should be emitted with internal\n+   linkage.  */\n+\n+static bool\n+involves_incomplete_p (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case POINTER_TYPE:\n+      return target_incomplete_p (TREE_TYPE (type));\n+\n+    case OFFSET_TYPE:\n+    ptrmem:\n+      return \n+\t(target_incomplete_p (TYPE_PTRMEM_POINTED_TO_TYPE (type))\n+\t || !COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)));\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\tgoto ptrmem;\n+      /* Fall through.  */\n+    case UNION_TYPE:\n+      if (!COMPLETE_TYPE_P (type))\n+\treturn true;\n+\n+    default:\n+      /* All other types do not involve incomplete class types.  */\n+      return false;\n+    }\n+}\n+\n /* Return a CONSTRUCTOR for the common part of the type_info objects. This\n    is the vtable pointer and NTBS name.  The NTBS name is emitted as a\n    comdat const char array, so it becomes a unique key for the type. Generate\n@@ -754,20 +785,32 @@ tinfo_base_init (tree desc, tree target)\n                      NULL_TREE);\n     tree name_string = tinfo_name (target);\n \n+    /* Determine the name of the variable -- and remember with which\n+       type it is associated.  */\n     name_name = mangle_typeinfo_string_for_type (target);\n+    TREE_TYPE (name_name) = target;\n+\n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n     \n     DECL_ARTIFICIAL (name_decl) = 1;\n     TREE_READONLY (name_decl) = 1;\n     TREE_STATIC (name_decl) = 1;\n     DECL_EXTERNAL (name_decl) = 0;\n-    TREE_PUBLIC (name_decl) = 1;\n+    DECL_TINFO_P (name_decl) = 1;\n     if (CLASS_TYPE_P (target))\n       {\n         DECL_VISIBILITY (name_decl) = CLASSTYPE_VISIBILITY (target);\n-        DECL_VISIBILITY_SPECIFIED (name_decl) = CLASSTYPE_VISIBILITY_SPECIFIED (target);\n+        DECL_VISIBILITY_SPECIFIED (name_decl) \n+\t  = CLASSTYPE_VISIBILITY_SPECIFIED (target);\n       }\n-    import_export_tinfo (name_decl, target, typeinfo_in_lib_p (target));\n+    if (involves_incomplete_p (target))\n+      {\n+\tTREE_PUBLIC (name_decl) = 0;\n+\tDECL_INTERFACE_KNOWN (name_decl) = 1;\n+      }\n+    else\n+      set_linkage_according_to_type (target, name_decl);\n+    import_export_decl (name_decl);\n     /* External name of the string containing the type's name has a\n        special name.  */\n     SET_DECL_ASSEMBLER_NAME (name_decl,\n@@ -843,18 +886,15 @@ generic_initializer (tree desc, tree target)\n    which adds target type and qualifier flags members to the type_info base.  */\n \n static tree\n-ptr_initializer (tree desc, tree target, bool *non_public_ptr)\n+ptr_initializer (tree desc, tree target)\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n   \n   if (incomplete)\n-    {\n-      flags |= 8;\n-      *non_public_ptr = true;\n-    }\n+    flags |= 8;\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n                     get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n@@ -873,7 +913,7 @@ ptr_initializer (tree desc, tree target, bool *non_public_ptr)\n    base.  */\n \n static tree\n-ptm_initializer (tree desc, tree target, bool *non_public_ptr)\n+ptm_initializer (tree desc, tree target)\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TYPE_PTRMEM_POINTED_TO_TYPE (target);\n@@ -882,15 +922,9 @@ ptm_initializer (tree desc, tree target, bool *non_public_ptr)\n   bool incomplete = target_incomplete_p (to);\n   \n   if (incomplete)\n-    {\n-      flags |= 0x8;\n-      *non_public_ptr = true;\n-    }\n+    flags |= 0x8;\n   if (!COMPLETE_TYPE_P (klass))\n-    {\n-      flags |= 0x10;\n-      *non_public_ptr = true;\n-    }\n+    flags |= 0x10;\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n@@ -1003,22 +1037,18 @@ typeinfo_in_lib_p (tree type)\n     }\n }\n \n-/* Generate the initializer for the type info describing\n-   TYPE. VAR_DESC is a . NON_PUBLIC_P is set nonzero, if the VAR_DECL\n-   should not be exported from this object file.  This should only be\n-   called at the end of translation, when we know that no further\n-   types will be completed.  */\n+/* Generate the initializer for the type info describing TYPE.  */\n \n static tree\n-get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n+get_pseudo_ti_init (tree type, tree var_desc)\n {\n   my_friendly_assert (at_eof, 20021120);\n   switch (TREE_CODE (type))\n     {\n     case OFFSET_TYPE:\n-      return ptm_initializer (var_desc, type, non_public_p);\n+      return ptm_initializer (var_desc, type);\n     case POINTER_TYPE:\n-      return ptr_initializer (var_desc, type, non_public_p);\n+      return ptr_initializer (var_desc, type);\n     case ENUMERAL_TYPE:\n       return generic_initializer (var_desc, type);\n       break;\n@@ -1031,14 +1061,9 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n     case UNION_TYPE:\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n-\treturn ptm_initializer (var_desc, type, non_public_p);\n+\treturn ptm_initializer (var_desc, type);\n       else if (var_desc == class_desc_type_node)\n-        {\n-\t  if (!COMPLETE_TYPE_P (type))\n-\t    /* Emit a non-public class_type_info.  */\n-\t    *non_public_p = true;\n-\t  return class_initializer (var_desc, type, NULL_TREE);\n-        }\n+\treturn class_initializer (var_desc, type, NULL_TREE);\n       else if (var_desc == si_class_desc_type_node)\n \t{\n           tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n@@ -1414,30 +1439,6 @@ emit_support_tinfos (void)\n     }\n }\n \n-/* Return true, iff T is a type_info variable which has not had a\n-   definition emitted for it.  */\n-\n-static bool\n-unemitted_tinfo_decl_p (tree t)\n-{\n-  if (/* It's a var decl */\n-      TREE_CODE (t) == VAR_DECL\n-      /* which has a name */\n-      && DECL_NAME (t)\n-      /* whose name points back to itself */\n-      && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (t)) == t\n-      /* whose name's type is non-null */\n-      && TREE_TYPE (DECL_NAME (t))\n-      /* and whose type is a struct */\n-      && TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE\n-      /* with a field */\n-      && TYPE_FIELDS (TREE_TYPE (t))\n-      /* which is our pseudo type info */\n-      && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (t))) == ti_desc_type_node)\n-    return true;\n-  return false;\n-}\n-\n /* Finish a type info decl. DECL_PTR is a pointer to an unemitted\n    tinfo decl.  Determine whether it needs emitting, and if so\n    generate the initializer.  */\n@@ -1446,35 +1447,48 @@ bool\n emit_tinfo_decl (tree decl)\n {\n   tree type = TREE_TYPE (DECL_NAME (decl));\n-  bool non_public;\n   int in_library = typeinfo_in_lib_p (type);\n   tree var_desc, var_init;\n \n-  my_friendly_assert (unemitted_tinfo_decl_p (decl), 20030307); \n+  my_friendly_assert (DECL_TINFO_P (decl), 20030307); \n   \n-  import_export_tinfo (decl, type, in_library);\n-  if (DECL_REALLY_EXTERN (decl) || !DECL_NEEDED_P (decl))\n-    return false;\n+  if (in_library)\n+    {\n+      if (doing_runtime)\n+\tDECL_EXTERNAL (decl) = 0;\n+      else\n+\t{\n+\t  /* If we're not in the runtime, then DECL (which is already\n+\t     DECL_EXTERNAL) will not be defined here.  */\n+\t  DECL_INTERFACE_KNOWN (decl) = 1;\n+\t  return false;\n+\t}\n+    }\n+  else if (involves_incomplete_p (type))\n+    {\n+      if (!decl_needed_p (decl))\n+\treturn false;\n+      /* If TYPE involves an incomplete class type, then the typeinfo\n+\t object will be emitted with internal linkage.  There is no\n+\t way to know whether or not types are incomplete until the end\n+\t of the compilation, so this determination must be deferred\n+\t until this point.  */\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_EXTERNAL (decl) = 0;\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+    }\n \n-  if (!doing_runtime && in_library)\n+  import_export_decl (decl);\n+  if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))\n+    {\n+      DECL_EXTERNAL (decl) = 0;\n+      var_desc = get_pseudo_ti_desc (type);\n+      var_init = get_pseudo_ti_init (type, var_desc);\n+      DECL_INITIAL (decl) = var_init;\n+      mark_used (decl);\n+      cp_finish_decl (decl, var_init, NULL_TREE, 0);\n+      return true;\n+    }\n+  else\n     return false;\n-\n-  non_public = false;\n-  var_desc = get_pseudo_ti_desc (type);\n-  var_init = get_pseudo_ti_init (type, var_desc, &non_public);\n-  \n-  DECL_EXTERNAL (decl) = 0;\n-  TREE_PUBLIC (decl) = !non_public;\n-  if (non_public)\n-    DECL_COMDAT (decl) = 0;\n-\n-  DECL_INITIAL (decl) = var_init;\n-  mark_used (decl);\n-  cp_finish_decl (decl, var_init, NULL_TREE, 0);\n-  /* cp_finish_decl will have dealt with linkage.  */\n-  \n-  /* Say we've dealt with it.  */\n-  TREE_TYPE (DECL_NAME (decl)) = NULL_TREE;\n-\n-  return true;\n }"}, {"sha": "152d75ca1f0f9c22c36dcd7a72f7018e40904433", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -2892,18 +2892,6 @@ expand_body (tree fn)\n \n   extract_interface_info ();\n \n-  /* If this function is marked with the constructor attribute, add it\n-     to the list of functions to be called along with constructors\n-     from static duration objects.  */\n-  if (DECL_STATIC_CONSTRUCTOR (fn))\n-    static_ctors = tree_cons (NULL_TREE, fn, static_ctors);\n-\n-  /* If this function is marked with the destructor attribute, add it\n-     to the list of functions to be called along with destructors from\n-     static duration objects.  */\n-  if (DECL_STATIC_DESTRUCTOR (fn))\n-    static_dtors = tree_cons (NULL_TREE, fn, static_dtors);\n-\n   if (DECL_CLONED_FUNCTION_P (fn))\n     {\n       /* If this is a clone, go through the other clones now and mark\n@@ -2957,15 +2945,39 @@ expand_or_defer_fn (tree fn)\n       return;\n     }\n \n+  /* If this function is marked with the constructor attribute, add it\n+     to the list of functions to be called along with constructors\n+     from static duration objects.  */\n+  if (DECL_STATIC_CONSTRUCTOR (fn))\n+    static_ctors = tree_cons (NULL_TREE, fn, static_ctors);\n+\n+  /* If this function is marked with the destructor attribute, add it\n+     to the list of functions to be called along with destructors from\n+     static duration objects.  */\n+  if (DECL_STATIC_DESTRUCTOR (fn))\n+    static_dtors = tree_cons (NULL_TREE, fn, static_dtors);\n+\n+  /* We make a decision about linkage for these functions at the end\n+     of the compilation.  Until that point, we do not want the back\n+     end to output them -- but we do want it to see the bodies of\n+     these fucntions so that it can inline them as appropriate.  */\n+  if (DECL_DECLARED_INLINE_P (fn) || DECL_IMPLICIT_INSTANTIATION (fn))\n+    {\n+      if (!at_eof)\n+\t{\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+\t  note_vague_linkage_fn (fn);\n+\t}\n+      else\n+\timport_export_decl (fn);\n+    }\n+\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)\n     return;\n \n-  /* Compute the appropriate object-file linkage for inline functions.  */\n-  if (DECL_DECLARED_INLINE_P (fn))\n-    import_export_decl (fn);\n-\n   function_depth++;\n \n   /* Expand or defer, at the whim of the compilation unit manager.  */"}, {"sha": "6a626e9470d21c497b336021117d7a4b213b2759", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1062,10 +1062,11 @@ find_tree (tree t, tree x)\n }\n \n /* Check if the type T depends on a type with no linkage and if so, return\n-   it.  */\n+   it.  If RELAXED_P then do not consider a class type declared within\n+   a TREE_PUBLIC function to have no linkage.  */\n \n tree\n-no_linkage_check (tree t)\n+no_linkage_check (tree t, bool relaxed_p)\n {\n   tree r;\n \n@@ -1076,6 +1077,8 @@ no_linkage_check (tree t)\n \n   switch (TREE_CODE (t))\n     {\n+      tree fn;\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \tgoto ptrmem;\n@@ -1085,25 +1088,28 @@ no_linkage_check (tree t)\n \treturn NULL_TREE;\n       /* Fall through.  */\n     case ENUMERAL_TYPE:\n-      if (decl_function_context (TYPE_MAIN_DECL (t))\n-\t  || TYPE_ANONYMOUS_P (t))\n+      if (TYPE_ANONYMOUS_P (t))\n+\treturn t;\n+      fn = decl_function_context (TYPE_MAIN_DECL (t));\n+      if (fn && (!relaxed_p || !TREE_PUBLIC (fn)))\n \treturn t;\n       return NULL_TREE;\n \n     case ARRAY_TYPE:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return no_linkage_check (TREE_TYPE (t));\n+      return no_linkage_check (TREE_TYPE (t), relaxed_p);\n \n     case OFFSET_TYPE:\n     ptrmem:\n-      r = no_linkage_check (TYPE_PTRMEM_POINTED_TO_TYPE (t));\n+      r = no_linkage_check (TYPE_PTRMEM_POINTED_TO_TYPE (t),\n+\t\t\t    relaxed_p);\n       if (r)\n \treturn r;\n-      return no_linkage_check (TYPE_PTRMEM_CLASS_TYPE (t));\n+      return no_linkage_check (TYPE_PTRMEM_CLASS_TYPE (t), relaxed_p);\n \n     case METHOD_TYPE:\n-      r = no_linkage_check (TYPE_METHOD_BASETYPE (t));\n+      r = no_linkage_check (TYPE_METHOD_BASETYPE (t), relaxed_p);\n       if (r)\n \treturn r;\n       /* Fall through.  */\n@@ -1114,11 +1120,11 @@ no_linkage_check (tree t)\n \t     parm && parm != void_list_node;\n \t     parm = TREE_CHAIN (parm))\n \t  {\n-\t    r = no_linkage_check (TREE_VALUE (parm));\n+\t    r = no_linkage_check (TREE_VALUE (parm), relaxed_p);\n \t    if (r)\n \t      return r;\n \t  }\n-\treturn no_linkage_check (TREE_TYPE (t));\n+\treturn no_linkage_check (TREE_TYPE (t), relaxed_p);\n       }\n \n     default:"}, {"sha": "5dc06fc7beb8100848e3028f24190591f7cd11cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,3 +1,20 @@\n+2004-07-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/inline1.C: New test.\n+\t* g++.dg/abi/local1-a.cc: Likewise.\n+\t* g++.dg/abi/local1.C: Likewise.\n+\t* g++.dg/abi/mangle11.C: Tweak location of warnings.\n+\t* g++.dg/abi/mangle12.C: Likewise.\n+\t* g++.dg/abi/mangle17.C: Likewise.\n+\t* g++.dg/abi/mangle20-2.C: Likewise.\n+\t* g++.dg/opt/interface1.C: Likewise.\n+\t* g++.dg/opt/interface1.h: Likewise.\n+\t* g++.dg/opt/interface1-a.cc: New test.\n+\t* g++.dg/parse/repo1.C: New test.\n+\t* g++.dg/template/repo1.C: Likewise.\n+\t* g++.dg/warn/Winline-1.C: Likewise.\n+\t* lib/gcc-dg.exp (gcc-dg-test-1): Fix -frepo handling.\n+\n 2004-07-29  Diego Novillo  <dnovillo@redhat.com>\n \n \t* gcc.dg/tree-ssa/20040729-1.c: New test."}, {"sha": "97082aa73770c765dc08dee32b3605a586593063", "filename": "gcc/testsuite/g++.dg/abi/inline1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Finline1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Finline1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Finline1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,6 @@\n+struct S {\n+  S() {}\n+  virtual void g() {}\n+};\n+\n+// { dg-final { scan-assembler-not \"_ZTV1S\" } }"}, {"sha": "638479e7459c7ca5b125610fc2247cc2f7fff065", "filename": "gcc/testsuite/g++.dg/abi/local1-a.cc", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1-a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1-a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1-a.cc?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,14 @@\n+struct B {\n+  virtual void b() {}\n+};\n+\n+static B* f() {\n+  struct D : public B {\n+  };\n+\n+  return new D;\n+}\n+\n+B* g() {\n+  return f();\n+}"}, {"sha": "518193c8980998a5f2db856bf4499a31a601534b", "filename": "gcc/testsuite/g++.dg/abi/local1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flocal1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do run }\n+// { dg-additional-sources \"local1-a.cc\" }\n+\n+#include <typeinfo>\n+\n+struct B {\n+  virtual void b() {}\n+};\n+\n+static B* f() {\n+  struct D : public B {\n+  };\n+\n+  return new D;\n+}\n+\n+extern B* g();\n+\n+int main () {\n+  if (typeid (*f()) == typeid (*g()))\n+    return 1;\n+}"}, {"sha": "6d09b51a6a11e1c0580af99bab22a645e7178b57", "filename": "gcc/testsuite/g++.dg/abi/mangle11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle11.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,10 +1,10 @@\n // { dg-options \"-Wabi -fabi-version=1\" }\n \n template <typename Q>\n-void f (typename Q::X) {}\n+void f (typename Q::X) {} // { dg-warning \"mangle\" }\n \n struct S {\n   typedef int X;\n };\n \n-template void f<S> (int); // { dg-warning \"mangle\" }\n+template void f<S> (int);"}, {"sha": "a3bd9ff6fa721da19e4f21837f758c14152fa09c", "filename": "gcc/testsuite/g++.dg/abi/mangle12.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle12.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,11 +1,11 @@\n // { dg-options \"-Wabi -fabi-version=1\" }\n \n template <template <typename> class Q>\n-void f (typename Q<int>::X) {}\n+void f (typename Q<int>::X) {} // { dg-warning \"mangle\" }\n \n template <typename Q>\n struct S {\n   typedef int X;\n };\n \n-template void f<S> (int); // { dg-warning \"mangle\" }\n+template void f<S> (int); "}, {"sha": "134b976a271519a3a57f6d62f6cbaf90ddafeb1e", "filename": "gcc/testsuite/g++.dg/abi/mangle17.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -4,8 +4,8 @@ enum E { e = 3 };\n \n template <int I> struct S {};\n \n-template <int I> void f (S<I + e + int (3.7)>) {}\n-template void f<7>(S<7 + e + int (3.7)>);  // { dg-warning \"mangle\" }\n+template <int I> void f (S<I + e + int (3.7)>) {} // { dg-warning \"mangle\" }\n+template void f<7>(S<7 + e + int (3.7)>);  \n \n-template <int I> void g (S<I + e + int (3.7)>) {}\n-template void g<7>(S<7 + e + int (3.7)>); // { dg-warning \"mangle\" }\n+template <int I> void g (S<I + e + int (3.7)>) {} // { dg-warning \"mangle\" }\n+template void g<7>(S<7 + e + int (3.7)>); "}, {"sha": "38ac52371abfc68f5f76284ecadbb89eed374e9d", "filename": "gcc/testsuite/g++.dg/abi/mangle20-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle20-2.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -7,10 +7,10 @@\n // PR 9043\n // mangled array types in templates\n \n-template <int I> void f(int (*)[2]) {}\n+template <int I> void f(int (*)[2]) {} // { dg-warning \"mangled name\" }\n template <int I> void g(int (*)[I+2]) {}\n \n-template void f<1>(int (*)[2]);  // { dg-warning \"mangled name\" }\n+template void f<1>(int (*)[2]);  \n //  { dg-final { scan-assembler \"\\n_?_Z1fILi1EEvPALi2E_i\\[: \\t\\n\\]\" } }\n template void g<1>(int (*)[3]);\n //  { dg-final { scan-assembler \"\\n_?_Z1gILi1EEvPAplT_Li2E_i\\[: \\t\\n\\]\" } }"}, {"sha": "595585257c18662b7f74b95e70c29992c5955908", "filename": "gcc/testsuite/g++.dg/opt/interface1-a.cc", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1-a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1-a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1-a.cc?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,9 @@\n+struct Test {\n+  void f();\n+};\n+\n+Test t;\n+\n+void g() {\n+  t.f();\n+}"}, {"sha": "850fe38401173ce4ee98f95490bc7ed41def6916", "filename": "gcc/testsuite/g++.dg/opt/interface1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-sources \"interface1-a.cc\" }\n+\n+#pragma implementation \"interface1.h\"\n+\n+#include \"interface1.h\"\n+\n+extern void g();\n+\n+int main () {\n+  g();\n+}"}, {"sha": "125f4b59ea0a6366cd4aebbcb9157d3795d1920b", "filename": "gcc/testsuite/g++.dg/opt/interface1.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finterface1.h?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,8 @@\n+#pragma interface \"interface1.h\"\n+\n+struct Test {\n+  void f();\n+};\n+\n+inline void Test::f() {\n+}"}, {"sha": "fa9a140927077f25775fa39daf3f3fcc6fc884f0", "filename": "gcc/testsuite/g++.dg/parse/repo1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options \"-frepo\" }\n+\n+extern \"C\" inline void f() {}\n+\n+int main () {\n+  f();\n+}"}, {"sha": "3650247cd128a42b1fbd0ad4c2e5e06617937f2d", "filename": "gcc/testsuite/g++.dg/template/repo1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-frepo\" }\n+\n+struct A {\n+  A();\n+};\n+\n+A::A() {}\n+\n+template <typename T>\n+struct B : public A {\n+  B() {} // { dg-bogus \"\" }\n+};\n+\n+B<int> b;\n+\n+int main () {}\n+"}, {"sha": "e1a7e832a30a934f974955f6348e423e1734be2d", "filename": "gcc/testsuite/g++.dg/warn/Winline-1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -1,10 +1,10 @@\n-// { dg-options \"-Winline -O2 -fno-unit-at-a-time\" }\n+// { dg-options \"-Winline -O2\" }\n \n-static inline int foo(int x); // { dg-warning \"\" }\n+static inline int foo(int x);\n \n int main()\n {\n-  return(foo(17)); // { dg-warning \"\" }\n+  return(foo(17));\n }\n \n inline int foo(int x) {  return(x);  }"}, {"sha": "7080df8267b5f864767fd57c64bea4847d1b0fba", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -119,8 +119,10 @@ proc gcc-dg-test-1 { target_compile prog do_what extra_tool_flags } {\n     if { $do_what == \"repo\" } {\n \tset object_file \"$output_file\"\n \tset output_file \"[file rootname [file tail $prog]].exe\"\n-\tconcat comp_output \\\n-\t       [$target_compile \"$object_file\" \"$output_file\" \"executable\" $options]\n+\tset comp_output \\\n+\t    [ concat $comp_output \\\n+\t\t  [$target_compile \"$object_file\" \"$output_file\" \\\n+\t\t       \"executable\" $options] ]\n     }\n \n     return [list $comp_output $output_file]"}, {"sha": "2c5da908394ae57041bbeabf156e1c598f661009", "filename": "gcc/tlink.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4684cd27fc05d4b4b14401c639fe4427a3bbbe3e/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=4684cd27fc05d4b4b14401c639fe4427a3bbbe3e", "patch": "@@ -470,6 +470,12 @@ recompile_files (void)\n       obstack_grow (&temporary_obstack, \"; \", 2);\n       obstack_grow (&temporary_obstack, c_file_name, strlen (c_file_name));\n       obstack_1grow (&temporary_obstack, ' ');\n+      if (!f->args)\n+\t{\n+\t  error (\"repository file `%s' does not contain command-line \"\n+\t\t \"arguments\", f->key);\n+\t  return 0;\n+\t}\n       obstack_grow (&temporary_obstack, f->args, strlen (f->args));\n       obstack_1grow (&temporary_obstack, ' ');\n       command = obstack_copy0 (&temporary_obstack, f->main, strlen (f->main));\n@@ -645,6 +651,9 @@ scan_linker_output (const char *fname)\n \n       if (sym && sym->tweaked)\n \t{\n+\t  error (\"`%s' was assigned to `%s', but was not defined \"\n+\t\t \"during recompilation, or vice versa\", \n+\t\t sym->key, sym->file->key);\n \t  fclose (stream);\n \t  return 0;\n \t}"}]}