{"sha": "88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhhZTIzZTcxZGZmY2QxOTdmYzU0MTBhNTgyYTQ3MGZjYmNjMmJhOQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-08T23:35:19Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-08T23:35:19Z"}, "message": "Makefile.in (LIBCPP_DEPS): New macro.\n\n\t* Makefile.in (LIBCPP_DEPS): New macro.\n\t(cpplib.o, cpphash.o, cpperror.o, cppexp.o, cppfiles.o): Use\n\tit to declare deps.\n\t* cpperror.c: Include cpphash.h.\n\t* cppexp.c: Include cpphash.h.  Remove MULTIBYTE_CHARS\n\tdingleberry.\n\t(lex): Don't use CPP_WARN_UNDEF.\n\t(_cpp_parse_expr): Return an int, the truth value.\n\t* cppfiles.c: Include cpphash.h.\n\t(_cpp_merge_include_chains): Move to cppinit.c and make static.\n\t* cppinit.c (include_defaults_array): Disentangle.\n\t(cpp_cleanup): Don't free the if stack here.\n\t(cpp_finish): Pop off all buffers, not just one.\n\t* cpplib.c (eval_if_expr): Return int.\n\t(do_xifdef): Rename do_ifdef.\n\t(handle_directive): Don't use CPP_PREPROCESSED.\n\t(cpp_get_token): Don't use CPP_C89.\n\t* fix-header.c: Don't use CPP_OPTIONS.\n\n\t* cpplib.h: Move U_CHAR, enum node_type, struct\n\tfile_name_list, struct ihash, is_idchar, is_idstart,\n\tis_numchar, is_numstart, is_hspace, is_space, CPP_BUF_PEEK,\n\tCPP_BUF_GET, CPP_FORWARD, CPP_PUTS, CPP_PUTS_Q, CPP_PUTC,\n\tCPP_PUTC_Q, CPP_NUL_TERMINATE, CPP_NUL_TERMINATE_Q,\n\tCPP_BUMP_BUFFER_LINE, CPP_BUMP_LINE, CPP_PREV_BUFFER,\n\tCPP_PRINT_DEPS, CPP_TRADITIONAL, CPP_PEDANTIC, and prototypes\n\tof _cpp_simplify_pathname, _cpp_find_include_file,\n\t_cpp_read_include_file, and _cpp_parse_expr to cpphash.h.\n\tMove struct if_stack to cpplib.c.  Move struct cpp_pending to\n\tcppinit.c.\n\tChange all uses of U_CHAR to be unsigned char instead.\n\tDelete CPP_WARN_UNDEF, CPP_C89, and CPP_PREPROCESSED.\n\nFrom-SVN: r32435", "tree": {"sha": "d22a67043ad8f0cb553637f8f1774978410ad8d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d22a67043ad8f0cb553637f8f1774978410ad8d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/comments", "author": null, "committer": null, "parents": [{"sha": "737faf1404678b40cb1f5dcf2ca816d2872fb347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737faf1404678b40cb1f5dcf2ca816d2872fb347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737faf1404678b40cb1f5dcf2ca816d2872fb347"}], "stats": {"total": 875, "additions": 451, "deletions": 424}, "files": [{"sha": "89c56a5572546d55a06ac3ccc882ec15de8431d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -1,3 +1,38 @@\n+2000-03-08  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* Makefile.in (LIBCPP_DEPS): New macro.\n+\t(cpplib.o, cpphash.o, cpperror.o, cppexp.o, cppfiles.o): Use\n+\tit to declare deps.\n+\t* cpperror.c: Include cpphash.h.\n+\t* cppexp.c: Include cpphash.h.  Remove MULTIBYTE_CHARS\n+\tdingleberry.\n+\t(lex): Don't use CPP_WARN_UNDEF.\n+\t(_cpp_parse_expr): Return an int, the truth value.\n+\t* cppfiles.c: Include cpphash.h.\n+\t(_cpp_merge_include_chains): Move to cppinit.c and make static.\n+\t* cppinit.c (include_defaults_array): Disentangle.\n+\t(cpp_cleanup): Don't free the if stack here.\n+\t(cpp_finish): Pop off all buffers, not just one.\n+\t* cpplib.c (eval_if_expr): Return int.\n+\t(do_xifdef): Rename do_ifdef.\n+\t(handle_directive): Don't use CPP_PREPROCESSED.\t\n+\t(cpp_get_token): Don't use CPP_C89.\n+\t* fix-header.c: Don't use CPP_OPTIONS.\n+\n+\t* cpplib.h: Move U_CHAR, enum node_type, struct\n+\tfile_name_list, struct ihash, is_idchar, is_idstart,\n+\tis_numchar, is_numstart, is_hspace, is_space, CPP_BUF_PEEK,\n+\tCPP_BUF_GET, CPP_FORWARD, CPP_PUTS, CPP_PUTS_Q, CPP_PUTC,\n+\tCPP_PUTC_Q, CPP_NUL_TERMINATE, CPP_NUL_TERMINATE_Q,\n+\tCPP_BUMP_BUFFER_LINE, CPP_BUMP_LINE, CPP_PREV_BUFFER,\n+\tCPP_PRINT_DEPS, CPP_TRADITIONAL, CPP_PEDANTIC, and prototypes\n+\tof _cpp_simplify_pathname, _cpp_find_include_file,\n+\t_cpp_read_include_file, and _cpp_parse_expr to cpphash.h.\n+\tMove struct if_stack to cpplib.c.  Move struct cpp_pending to\n+\tcppinit.c.\n+\tChange all uses of U_CHAR to be unsigned char instead.\n+\tDelete CPP_WARN_UNDEF, CPP_C89, and CPP_PREPROCESSED.\n+\n 2000-03-08  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* dwarf2out.c (dw_fde_struct): Add 'nothrow'."}, {"sha": "bbb29ed23049fcc7f78f7d3cbd30dd702922a13c", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -26,6 +26,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n+#include \"cpphash.h\"\n #include \"intl.h\"\n \n static void print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));"}, {"sha": "bb2ae7a3ad88bae84ff421a6539e6f2cddf27bd4", "filename": "gcc/cppexp.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -27,10 +27,7 @@ Written by Per Bothner 1994.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n-\n-#ifdef MULTIBYTE_CHARS\n-#include <locale.h>\n-#endif\n+#include \"cpphash.h\"\n \n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n@@ -453,7 +450,7 @@ lex (pfile, skip_evaluation)\n       op.unsignedp = 0;\n       op.value = 0;\n \n-      if (CPP_WARN_UNDEF (pfile) && !skip_evaluation)\n+      if (CPP_OPTIONS (pfile)->warn_undef && !skip_evaluation)\n \tcpp_warning (pfile, \"`%.*s' is not defined\",\n \t\t     (int) (tok_end - tok_start), tok_start);\n       return op;\n@@ -669,9 +666,9 @@ right_shift (pfile, a, unsignedp, b)\n   ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 : (v1 OP v2)\n \n /* Parse and evaluate a C expression, reading from PFILE.\n-   Returns the value of the expression.  */\n+   Returns the truth value of the expression.  */\n \n-HOST_WIDEST_INT\n+int\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n {\n@@ -1004,7 +1001,7 @@ _cpp_parse_expr (pfile)\n \t    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n \t  if (stack != init_stack)\n \t    free (stack);\n-\t  return top->value;\n+\t  return (top->value != 0);\n \t}\n       top++;\n       "}, {"sha": "43d9bfd505d80113e7ecfeb3d78a322010fd1ec1", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 141, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -27,6 +27,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n+#include \"cpphash.h\"\n #include \"intl.h\"\n \n static IHASH *include_hash\tPARAMS ((cpp_reader *, const char *, int));\n@@ -49,151 +50,10 @@ static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n static void hack_vms_include_specification PARAMS ((char *));\n #endif\n \n-/* Windows does not natively support inodes, and neither does MSDOS.\n-   Cygwin's emulation can generate non-unique inodes, so don't use it.\n-   VMS has non-numeric inodes. */\n-#ifdef VMS\n-#define INO_T_EQ(a, b) (!bcmp((char *) &(a), (char *) &(b), sizeof (a)))\n-#elif (defined _WIN32 && ! defined (_UWIN)) \\\n-       || defined __MSDOS__\n-#define INO_T_EQ(a, b) 0\n-#else\n-#define INO_T_EQ(a, b) ((a) == (b))\n-#endif\n-\n #ifndef INCLUDE_LEN_FUDGE\n #define INCLUDE_LEN_FUDGE 0\n #endif\n \n-/* Merge the four include chains together in the order quote, bracket,\n-   system, after.  Remove duplicate dirs (as determined by\n-   INO_T_EQ()).  The system_include and after_include chains are never\n-   referred to again after this function; all access is through the\n-   bracket_include path.\n-\n-   For the future: Check if the directory is empty (but\n-   how?) and possibly preload the include hash. */\n-\n-void\n-_cpp_merge_include_chains (opts)\n-     struct cpp_options *opts;\n-{\n-  struct file_name_list *prev, *cur, *other;\n-  struct file_name_list *quote, *brack, *systm, *after;\n-  struct file_name_list *qtail, *btail, *stail, *atail;\n-\n-  qtail = opts->pending->quote_tail;\n-  btail = opts->pending->brack_tail;\n-  stail = opts->pending->systm_tail;\n-  atail = opts->pending->after_tail;\n-\n-  quote = opts->pending->quote_head;\n-  brack = opts->pending->brack_head;\n-  systm = opts->pending->systm_head;\n-  after = opts->pending->after_head;\n-\n-  /* Paste together bracket, system, and after include chains. */\n-  if (stail)\n-    stail->next = after;\n-  else\n-    systm = after;\n-  if (btail)\n-    btail->next = systm;\n-  else\n-    brack = systm;\n-\n-  /* This is a bit tricky.\n-     First we drop dupes from the quote-include list.\n-     Then we drop dupes from the bracket-include list.\n-     Finally, if qtail and brack are the same directory,\n-     we cut out qtail.\n-\n-     We can't just merge the lists and then uniquify them because\n-     then we may lose directories from the <> search path that should\n-     be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux. It is however\n-     safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written\n-     -Ibar -I- -Ifoo -Iquux.\n-\n-     Note that this algorithm is quadratic in the number of -I switches,\n-     which is acceptable since there aren't usually that many of them.  */\n-\n-  for (cur = quote, prev = NULL; cur; cur = cur->next)\n-    {\n-      for (other = quote; other != cur; other = other->next)\n-        if (INO_T_EQ (cur->ino, other->ino)\n-\t    && cur->dev == other->dev)\n-          {\n-\t    if (opts->verbose)\n-\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n-\t\t       cur->name);\n-\n-\t    prev->next = cur->next;\n-\t    free (cur->name);\n-\t    free (cur);\n-\t    cur = prev;\n-\t    break;\n-\t  }\n-      prev = cur;\n-    }\n-  qtail = prev;\n-\n-  for (cur = brack; cur; cur = cur->next)\n-    {\n-      for (other = brack; other != cur; other = other->next)\n-        if (INO_T_EQ (cur->ino, other->ino)\n-\t    && cur->dev == other->dev)\n-          {\n-\t    if (opts->verbose)\n-\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n-\t\t       cur->name);\n-\n-\t    prev->next = cur->next;\n-\t    free (cur->name);\n-\t    free (cur);\n-\t    cur = prev;\n-\t    break;\n-\t  }\n-      prev = cur;\n-    }\n-\n-  if (quote)\n-    {\n-      if (INO_T_EQ (qtail->ino, brack->ino) && qtail->dev == brack->dev)\n-        {\n-\t  if (quote == qtail)\n-\t    {\n-\t      if (opts->verbose)\n-\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n-\t\t\t quote->name);\n-\n-\t      free (quote->name);\n-\t      free (quote);\n-\t      quote = brack;\n-\t    }\n-\t  else\n-\t    {\n-\t      cur = quote;\n-\t      while (cur->next != qtail)\n-\t\t  cur = cur->next;\n-\t      cur->next = brack;\n-\t      if (opts->verbose)\n-\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n-\t\t\t qtail->name);\n-\n-\t      free (qtail->name);\n-\t      free (qtail);\n-\t    }\n-\t}\n-      else\n-\t  qtail->next = brack;\n-    }\n-  else\n-      quote = brack;\n-\n-  opts->quote_include = quote;\n-  opts->bracket_include = brack;\n-}\n-\n /* Look up or add an entry to the table of all includes.  This table\n  is indexed by the name as it appears in the #include line.  The\n  ->next_this_file chain stores all different files with the same"}, {"sha": "d44299a27211735b79726ba03db0b56cc7045805", "filename": "gcc/cpphash.h", "status": "modified", "additions": 168, "deletions": 3, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -1,5 +1,5 @@\n-/* Part of CPP library.  (Macro hash table support.)\n-   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n+/* Part of CPP library.\n+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -15,9 +15,15 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n+/* This header defines all the internal data structures and functions\n+   that need to be visible across files.  It's called cpphash.h for\n+   historical reasons.  */\n+\n #ifndef __GCC_CPPHASH__\n #define __GCC_CPPHASH__\n \n+typedef unsigned char U_CHAR;\n+\n /* Structure allocated for every #define.  For a simple replacement\n    such as\n    \t#define foo bar ,\n@@ -70,6 +76,50 @@ struct definition\n   U_CHAR *argnames;\n };\n \n+/* The structure of a node in the hash table.  The hash table\n+   has entries for all tokens defined by #define commands (type T_MACRO),\n+   plus some special tokens like __LINE__ (these each have their own\n+   type, and the appropriate code is run when that type of node is seen.\n+   It does not contain control words like \"#define\", which are recognized\n+   by a separate piece of code. */\n+\n+/* different flavors of hash nodes --- also used in keyword table */\n+enum node_type\n+{\n+  T_DEFINE = 1,\t   /* `#define' */\n+  T_INCLUDE,\t   /* `#include' */\n+  T_INCLUDE_NEXT,  /* `#include_next' */\n+  T_IMPORT,        /* `#import' */\n+  T_IFDEF,\t   /* `#ifdef' */\n+  T_IFNDEF,\t   /* `#ifndef' */\n+  T_IF,\t\t   /* `#if' */\n+  T_ELSE,\t   /* `#else' */\n+  T_PRAGMA,\t   /* `#pragma' */\n+  T_ELIF,\t   /* `#elif' */\n+  T_UNDEF,\t   /* `#undef' */\n+  T_LINE,\t   /* `#line' */\n+  T_ERROR,\t   /* `#error' */\n+  T_WARNING,\t   /* `#warning' */\n+  T_ENDIF,\t   /* `#endif' */\n+  T_SCCS,\t   /* `#sccs' */\n+  T_IDENT,\t   /* `#ident' */\n+  T_ASSERT,\t   /* `#assert' */\n+  T_UNASSERT,\t   /* `#unassert', */\n+  T_SPECLINE,\t   /* `__LINE__' */\n+  T_DATE,\t   /* `__DATE__' */\n+  T_FILE,\t   /* `__FILE__' */\n+  T_BASE_FILE,\t   /* `__BASE_FILE__' */\n+  T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n+  T_VERSION,\t   /* `__VERSION__' */\n+  T_TIME,\t   /* `__TIME__' */\n+  T_STDC,\t   /* `__STDC__' */\n+  T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n+  T_MACRO,\t   /* macro defined by `#define' */\n+  T_DISABLED,\t   /* macro temporarily turned off for rescan */\n+  T_POISON,\t   /* macro defined with `#pragma poison' */\n+  T_UNUSED\t   /* Used for something not defined.  */\n+};\n+\n /* different kinds of things that can appear in the value field\n    of a hash node. */\n union hashval\n@@ -80,7 +130,8 @@ union hashval\n };\n \n typedef struct hashnode HASHNODE;\n-struct hashnode {\n+struct hashnode\n+{\n   struct hashnode *next;\t/* double links for easy deletion */\n   struct hashnode *prev;\n   struct hashnode **bucket_hdr;\t/* also, a back pointer to this node's hash\n@@ -92,6 +143,110 @@ struct hashnode {\n   union hashval value;\t\t/* pointer to expansion, or whatever */\n };\n \n+/* List of directories to look for include files in. */\n+struct file_name_list\n+{\n+  struct file_name_list *next;\n+  struct file_name_list *alloc; /* for the cache of\n+\t\t\t\t   current directory entries */\n+  char *name;\n+  unsigned int nlen;\n+  /* We use these to tell if the directory mentioned here is a duplicate\n+     of an earlier directory on the search path. */\n+  ino_t ino;\n+  dev_t dev;\n+  /* If the following is nonzero, it is a C-language system include\n+     directory.  */\n+  int sysp;\n+  /* Mapping of file names for this directory.\n+     Only used on MS-DOS and related platforms. */\n+  struct file_name_map *name_map;\n+};\n+#define ABSOLUTE_PATH ((struct file_name_list *)-1)\n+\n+/* This structure is used for the table of all includes.  It is\n+   indexed by the `short name' (the name as it appeared in the\n+   #include statement) which is stored in *nshort.  */\n+struct ihash\n+{\n+  struct ihash *next;\n+  /* Next file with the same short name but a\n+     different (partial) pathname). */\n+  struct ihash *next_this_file;\n+\n+  /* Location of the file in the include search path.\n+     Used for include_next */\n+  struct file_name_list *foundhere;\n+  const char *name;\t\t/* (partial) pathname of file */\n+  const char *nshort;\t\t/* name of file as referenced in #include */\n+  const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion -\n+\t\t\t\t   see redundant_include_p */\n+  char *buf, *limit;\t\t/* for file content cache,\n+\t\t\t\t   not yet implemented */\n+};\n+typedef struct ihash IHASH;\n+\n+/* Character classes.\n+   If the definition of `numchar' looks odd to you, please look up the\n+   definition of a pp-number in the C standard [section 6.4.8 of C99] */\n+#define ISidnum\t\t0x01\t/* a-zA-Z0-9_ */\n+#define ISidstart\t0x02\t/* _a-zA-Z */\n+#define ISnumstart\t0x04\t/* 0-9 */\n+#define IShspace\t0x08\t/* ' ' \\t \\f \\v */\n+#define ISspace\t\t0x10\t/* ' ' \\t \\f \\v \\n */\n+\n+#define _dollar_ok(x)\t((x) == '$' && CPP_OPTIONS (pfile)->dollars_in_ident)\n+\n+#define is_idchar(x)\t((_cpp_IStable[x] & ISidnum) || _dollar_ok(x))\n+#define is_idstart(x)\t((_cpp_IStable[x] & ISidstart) || _dollar_ok(x))\n+#define is_numchar(x)\t(_cpp_IStable[x] & ISidnum)\n+#define is_numstart(x)\t(_cpp_IStable[x] & ISnumstart)\n+#define is_hspace(x)\t(_cpp_IStable[x] & IShspace)\n+#define is_space(x)\t(_cpp_IStable[x] & ISspace)\n+\n+/* This table is constant if it can be initialized at compile time,\n+   which is the case if cpp was compiled with GCC >=2.7, or another\n+   compiler that supports C99.  */\n+#if (GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L)\n+extern const unsigned char _cpp_IStable[256];\n+#else\n+extern unsigned char _cpp_IStable[256];\n+#endif\n+\n+/* Macros.  */\n+\n+#define CPP_BUF_PEEK(BUFFER) \\\n+  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)\n+#define CPP_BUF_GET(BUFFER) \\\n+  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n+#define CPP_FORWARD(BUFFER, N) ((BUFFER)->cur += (N))\n+\n+/* Append string STR (of length N) to PFILE's output buffer.\n+   Assume there is enough space. */\n+#define CPP_PUTS_Q(PFILE, STR, N) \\\n+  (memcpy ((PFILE)->limit, STR, (N)), (PFILE)->limit += (N))\n+/* Append string STR (of length N) to PFILE's output buffer.  Make space. */\n+#define CPP_PUTS(PFILE, STR, N) CPP_RESERVE(PFILE, N), CPP_PUTS_Q(PFILE, STR,N)\n+/* Append character CH to PFILE's output buffer.  Assume sufficient space. */\n+#define CPP_PUTC_Q(PFILE, CH) (*(PFILE)->limit++ = (CH))\n+/* Append character CH to PFILE's output buffer.  Make space if need be. */\n+#define CPP_PUTC(PFILE, CH) (CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))\n+/* Make sure PFILE->limit is followed by '\\0'. */\n+#define CPP_NUL_TERMINATE_Q(PFILE) (*(PFILE)->limit = 0)\n+#define CPP_NUL_TERMINATE(PFILE) (CPP_RESERVE(PFILE, 1), *(PFILE)->limit = 0)\n+\n+/* Advance the current line by one. */\n+#define CPP_BUMP_BUFFER_LINE(PBUF) ((PBUF)->lineno++,\\\n+\t\t\t\t    (PBUF)->line_base = (PBUF)->cur)\n+#define CPP_BUMP_LINE(PFILE) CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))\n+#define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n+\n+#define CPP_PRINT_DEPS(PFILE) (CPP_OPTIONS (PFILE)->print_deps)\n+#define CPP_TRADITIONAL(PFILE) (CPP_OPTIONS(PFILE)->traditional)\n+#define CPP_PEDANTIC(PFILE) \\\n+  (CPP_OPTIONS (PFILE)->pedantic && !CPP_BUFFER (pfile)->system_header_p)\n+\n+/* In cpphash.c */\n extern HASHNODE *_cpp_install\t  PARAMS ((cpp_reader *, const U_CHAR *, int,\n \t\t\t\t\t   enum node_type, const char *));\n extern HASHNODE *_cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n@@ -106,4 +261,14 @@ extern void _cpp_macroexpand\t  PARAMS ((cpp_reader *, HASHNODE *));\n extern void _cpp_dump_definition  PARAMS ((cpp_reader *, const U_CHAR *, long,\n \t\t\t\t\t   DEFINITION *));\n \n+/* In cppfiles.c */\n+extern void _cpp_simplify_pathname\tPARAMS ((char *));\n+extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t\tstruct file_name_list *,\n+\t\t\t\t\t\tIHASH **, int *));\n+extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+\n+/* In cppexp.c */\n+extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n+\n #endif"}, {"sha": "c66f0456bbf8f879ea7947ee58935757d3a52c49", "filename": "gcc/cppinit.c", "status": "modified", "additions": 191, "deletions": 33, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -36,6 +36,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define GET_ENV_PATH_LIST(VAR,NAME)\tdo { (VAR) = getenv (NAME); } while (0)\n #endif\n \n+/* Windows does not natively support inodes, and neither does MSDOS.\n+   Cygwin's emulation can generate non-unique inodes, so don't use it.\n+   VMS has non-numeric inodes. */\n+#ifdef VMS\n+#define INO_T_EQ(a, b) (!memcmp (&(a), &(b), sizeof (a)))\n+#elif (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__\n+#define INO_T_EQ(a, b) 0\n+#else\n+#define INO_T_EQ(a, b) ((a) == (b))\n+#endif\n+\n #ifndef STANDARD_INCLUDE_DIR\n #define STANDARD_INCLUDE_DIR \"/usr/include\"\n #endif\n@@ -97,47 +108,51 @@ struct default_include\n \t\t\t\t   C++.  */\n };\n \n+#ifndef STANDARD_INCLUDE_COMPONENT\n+#define STANDARD_INCLUDE_COMPONENT 0\n+#endif\n+\n+#ifdef CROSS_COMPILE\n+#undef LOCAL_INCLUDE_DIR\n+#undef SYSTEM_INCLUDE_DIR\n+#undef STANDARD_INCLUDE_DIR\n+#else\n+#undef CROSS_INCLUDE_DIR\n+#endif\n+\n static const struct default_include include_defaults_array[]\n #ifdef INCLUDE_DEFAULTS\n = INCLUDE_DEFAULTS;\n #else\n = {\n+#ifdef GPLUSPLUS_INCLUDE_DIR\n     /* Pick up GNU C++ specific include files.  */\n     { GPLUSPLUS_INCLUDE_DIR, \"G++\", 1, 1 },\n-#ifdef CROSS_COMPILE\n-    /* This is the dir for fixincludes.  Put it just before\n-       the files that we fix.  */\n-    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\n-    /* For cross-compilation, this dir name is generated\n-       automatically in Makefile.in.  */\n-    { CROSS_INCLUDE_DIR, \"GCC\", 0, 0 },\n-#ifdef TOOL_INCLUDE_DIR\n-    /* This is another place that the target system's headers might be.  */\n-    { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\n #endif\n-#else /* not CROSS_COMPILE */\n #ifdef LOCAL_INCLUDE_DIR\n-    /* This should be /usr/local/include and should come before\n-       the fixincludes-fixed header files.  */\n+    /* /usr/local/include comes before the fixincluded header files.  */\n     { LOCAL_INCLUDE_DIR, 0, 0, 1 },\n #endif\n+#ifdef GCC_INCLUDE_DIR\n+    /* This is the dir for fixincludes and for gcc's private headers.  */\n+    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\n+#endif\n+#ifdef CROSS_INCLUDE_DIR\n+    /* One place the target system's headers might be.  */\n+    { CROSS_INCLUDE_DIR, \"GCC\", 0, 0 },\n+#endif\n #ifdef TOOL_INCLUDE_DIR\n-    /* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.\n-       Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */\n+    /* Another place the target system's headers might be.  */\n     { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\n #endif\n-    /* This is the dir for fixincludes.  Put it just before\n-       the files that we fix.  */\n-    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\n-    /* Some systems have an extra dir of include files.  */\n #ifdef SYSTEM_INCLUDE_DIR\n+    /* Some systems have an extra dir of include files.  */\n     { SYSTEM_INCLUDE_DIR, 0, 0, 0 },\n #endif\n-#ifndef STANDARD_INCLUDE_COMPONENT\n-#define STANDARD_INCLUDE_COMPONENT 0\n-#endif\n+#ifdef STANDARD_INCLUDE_DIR\n+    /* /usr/include comes dead last.  */\n     { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 },\n-#endif /* not CROSS_COMPILE */\n+#endif\n     { 0, 0, 0, 0 }\n   };\n #endif /* no INCLUDE_DEFAULTS */\n@@ -156,6 +171,24 @@ struct pending_option\n   int undef;\n };\n \n+/* The `pending' structure accumulates all the options that are not\n+   actually processed until we hit cpp_start_read.  It consists of\n+   several lists, one for each type of option.  We keep both head and\n+   tail pointers for quick insertion. */\n+struct cpp_pending\n+{\n+  struct pending_option *define_head, *define_tail;\n+  struct pending_option *assert_head, *assert_tail;\n+\n+  struct file_name_list *quote_head, *quote_tail;\n+  struct file_name_list *brack_head, *brack_tail;\n+  struct file_name_list *systm_head, *systm_tail;\n+  struct file_name_list *after_head, *after_tail;\n+\n+  struct pending_option *imacros_head, *imacros_tail;\n+  struct pending_option *include_head, *include_tail;\n+};\n+\n #ifdef __STDC__\n #define APPEND(pend, list, elt) \\\n   do {  if (!(pend)->list##_head) (pend)->list##_head = (elt); \\\n@@ -178,6 +211,8 @@ static void initialize_builtins\t\tPARAMS ((cpp_reader *));\n static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct cpp_pending *,\n \t\t\t\t\t\t char *, int, int));\n+static void merge_include_chains\tPARAMS ((struct cpp_options *));\n+\n static void dump_special_to_buffer\tPARAMS ((cpp_reader *, const char *));\n static void initialize_dependency_output PARAMS ((cpp_reader *));\n static void initialize_standard_includes PARAMS ((cpp_reader *));\n@@ -341,6 +376,135 @@ append_include_chain (pfile, pend, dir, path, cxx_aware)\n     }\n }\n \n+/* Merge the four include chains together in the order quote, bracket,\n+   system, after.  Remove duplicate dirs (as determined by\n+   INO_T_EQ()).  The system_include and after_include chains are never\n+   referred to again after this function; all access is through the\n+   bracket_include path.\n+\n+   For the future: Check if the directory is empty (but\n+   how?) and possibly preload the include hash. */\n+\n+static void\n+merge_include_chains (opts)\n+     struct cpp_options *opts;\n+{\n+  struct file_name_list *prev, *cur, *other;\n+  struct file_name_list *quote, *brack, *systm, *after;\n+  struct file_name_list *qtail, *btail, *stail, *atail;\n+\n+  qtail = opts->pending->quote_tail;\n+  btail = opts->pending->brack_tail;\n+  stail = opts->pending->systm_tail;\n+  atail = opts->pending->after_tail;\n+\n+  quote = opts->pending->quote_head;\n+  brack = opts->pending->brack_head;\n+  systm = opts->pending->systm_head;\n+  after = opts->pending->after_head;\n+\n+  /* Paste together bracket, system, and after include chains. */\n+  if (stail)\n+    stail->next = after;\n+  else\n+    systm = after;\n+  if (btail)\n+    btail->next = systm;\n+  else\n+    brack = systm;\n+\n+  /* This is a bit tricky.\n+     First we drop dupes from the quote-include list.\n+     Then we drop dupes from the bracket-include list.\n+     Finally, if qtail and brack are the same directory,\n+     we cut out qtail.\n+\n+     We can't just merge the lists and then uniquify them because\n+     then we may lose directories from the <> search path that should\n+     be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux. It is however\n+     safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written\n+     -Ibar -I- -Ifoo -Iquux.\n+\n+     Note that this algorithm is quadratic in the number of -I switches,\n+     which is acceptable since there aren't usually that many of them.  */\n+\n+  for (cur = quote, prev = NULL; cur; cur = cur->next)\n+    {\n+      for (other = quote; other != cur; other = other->next)\n+        if (INO_T_EQ (cur->ino, other->ino)\n+\t    && cur->dev == other->dev)\n+          {\n+\t    if (opts->verbose)\n+\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t       cur->name);\n+\n+\t    prev->next = cur->next;\n+\t    free (cur->name);\n+\t    free (cur);\n+\t    cur = prev;\n+\t    break;\n+\t  }\n+      prev = cur;\n+    }\n+  qtail = prev;\n+\n+  for (cur = brack; cur; cur = cur->next)\n+    {\n+      for (other = brack; other != cur; other = other->next)\n+        if (INO_T_EQ (cur->ino, other->ino)\n+\t    && cur->dev == other->dev)\n+          {\n+\t    if (opts->verbose)\n+\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t       cur->name);\n+\n+\t    prev->next = cur->next;\n+\t    free (cur->name);\n+\t    free (cur);\n+\t    cur = prev;\n+\t    break;\n+\t  }\n+      prev = cur;\n+    }\n+\n+  if (quote)\n+    {\n+      if (INO_T_EQ (qtail->ino, brack->ino) && qtail->dev == brack->dev)\n+        {\n+\t  if (quote == qtail)\n+\t    {\n+\t      if (opts->verbose)\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t\t quote->name);\n+\n+\t      free (quote->name);\n+\t      free (quote);\n+\t      quote = brack;\n+\t    }\n+\t  else\n+\t    {\n+\t      cur = quote;\n+\t      while (cur->next != qtail)\n+\t\t  cur = cur->next;\n+\t      cur->next = brack;\n+\t      if (opts->verbose)\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t\t qtail->name);\n+\n+\t      free (qtail->name);\n+\t      free (qtail);\n+\t    }\n+\t}\n+      else\n+\t  qtail->next = brack;\n+    }\n+  else\n+      quote = brack;\n+\n+  opts->quote_include = quote;\n+  opts->bracket_include = brack;\n+}\n+\n \n /* Write out a #define command for the special named MACRO_NAME\n    to PFILE's token_buffer.  */\n@@ -418,13 +582,6 @@ cpp_cleanup (pfile)\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n-  while (pfile->if_stack)\n-    {\n-      IF_STACK *temp = pfile->if_stack;\n-      pfile->if_stack = temp->next;\n-      free (temp);\n-    }\n-\n   for (i = ALL_INCLUDE_HASHSIZE; --i >= 0; )\n     {\n       IHASH *imp, *next;\n@@ -723,7 +880,7 @@ cpp_start_read (pfile, fname)\n   if (! opts->no_standard_includes)\n     initialize_standard_includes (pfile);\n \n-  _cpp_merge_include_chains (opts);\n+  merge_include_chains (opts);\n \n   /* With -v, print the list of dirs to search.  */\n   if (opts->verbose)\n@@ -844,9 +1001,10 @@ cpp_finish (pfile)\n {\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n \n-  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n+  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n     cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n-  cpp_pop_buffer (pfile);\n+  while (CPP_BUFFER (pfile))\n+    cpp_pop_buffer (pfile);\n \n   /* Don't write the deps file if preprocessing has failed.  */\n   if (opts->print_deps && pfile->errors == 0)"}, {"sha": "a4b7dd6cf4d7e2999d8903b23a3a60379a113597", "filename": "gcc/cpplib.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -52,6 +52,20 @@ struct directive\n   enum node_type type;\t\t/* Code which describes which directive.  */\n };\n \n+/* Stack of conditionals currently in progress\n+   (including both successful and failing conditionals).  */\n+\n+struct if_stack\n+{\n+  struct if_stack *next;\n+  int lineno;\t\t\t/* line number where condition started */\n+  int if_succeeded;\t\t/* truth of last condition in this group */\n+  const U_CHAR *control_macro;\t/* macro name for #ifndef around entire file */\n+  enum node_type type;\t\t/* type of last directive seen in this group */\n+};\n+typedef struct if_stack IF_STACK;\n+\n+\n /* These functions are declared to return int instead of void since they\n    are going to be placed in a table and some old compilers have trouble with\n    pointers to functions returning void.  */\n@@ -64,7 +78,7 @@ static int do_error PARAMS ((cpp_reader *, const struct directive *));\n static int do_pragma PARAMS ((cpp_reader *, const struct directive *));\n static int do_ident PARAMS ((cpp_reader *, const struct directive *));\n static int do_if PARAMS ((cpp_reader *, const struct directive *));\n-static int do_xifdef PARAMS ((cpp_reader *, const struct directive *));\n+static int do_ifdef PARAMS ((cpp_reader *, const struct directive *));\n static int do_else PARAMS ((cpp_reader *, const struct directive *));\n static int do_elif PARAMS ((cpp_reader *, const struct directive *));\n static int do_endif PARAMS ((cpp_reader *, const struct directive *));\n@@ -78,7 +92,7 @@ static int do_warning PARAMS ((cpp_reader *, const struct directive *));\n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n-static HOST_WIDEST_INT eval_if_expr\tPARAMS ((cpp_reader *));\n+static int eval_if_expr\t\t\tPARAMS ((cpp_reader *));\n static void conditional_skip\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t\tenum node_type, U_CHAR *));\n static void skip_if_group\t\tPARAMS ((cpp_reader *));\n@@ -118,10 +132,10 @@ static const struct directive directive_table[] = {\n   {  6, do_define,   \"define\",       T_DEFINE },\t/* 270554 */\n   {  7, do_include,  \"include\",      T_INCLUDE },\t/*  52262 */\n   {  5, do_endif,    \"endif\",        T_ENDIF },\t\t/*  45855 */\n-  {  5, do_xifdef,   \"ifdef\",        T_IFDEF },\t\t/*  22000 */\n+  {  5, do_ifdef,   \"ifdef\",        T_IFDEF },\t\t/*  22000 */\n   {  2, do_if,       \"if\",           T_IF },\t\t/*  18162 */\n   {  4, do_else,     \"else\",         T_ELSE },\t\t/*   9863 */\n-  {  6, do_xifdef,   \"ifndef\",       T_IFNDEF },\t/*   9675 */\n+  {  6, do_ifdef,   \"ifndef\",       T_IFNDEF },\t/*   9675 */\n   {  5, do_undef,    \"undef\",        T_UNDEF },\t\t/*   4837 */\n   {  4, do_line,     \"line\",         T_LINE },\t\t/*   2465 */\n   {  4, do_elif,     \"elif\",         T_ELIF },\t\t/*    610 */\n@@ -529,7 +543,7 @@ handle_directive (pfile)\n \treturn 0;\n \n       if (CPP_PEDANTIC (pfile)\n-\t  && ! CPP_PREPROCESSED (pfile)\n+\t  && ! CPP_OPTIONS (pfile)->preprocessed\n \t  && ! CPP_BUFFER (pfile)->manual_pop)\n \tcpp_pedwarn (pfile, \"`#' followed by integer\");\n       do_line (pfile, NULL);\n@@ -538,7 +552,7 @@ handle_directive (pfile)\n \n   /* If we are rescanning preprocessed input, don't obey any directives\n      other than # nnn.  */\n-  if (CPP_PREPROCESSED (pfile))\n+  if (CPP_OPTIONS (pfile)->preprocessed)\n     return 0;\n \n   /* Now find the directive name.  */\n@@ -1842,16 +1856,8 @@ detect_if_not_defined (pfile)\n }\n \n /*\n- * handle #if command by\n- *   1) inserting special `defined' keyword into the hash table\n- *\tthat gets turned into 0 or 1 by special_symbol (thus,\n- *\tif the luser has a symbol called `defined' already, it won't\n- *      work inside the #if command)\n- *   2) rescan the input into a temporary output buffer\n- *   3) pass the output buffer to the yacc parser and collect a value\n- *   4) clean up the mess left from steps 1 and 2.\n- *   5) call conditional_skip to skip til the next #endif (etc.),\n- *      or not, depending on the value from step 3.\n+ * #if is straightforward; just call eval_if_expr, then conditional_skip.\n+ * Also, check for a reinclude preventer of the form #if !defined (MACRO).\n  */\n \n static int\n@@ -1860,7 +1866,7 @@ do_if (pfile, keyword)\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *control_macro = detect_if_not_defined (pfile);\n-  HOST_WIDEST_INT value = eval_if_expr (pfile);\n+  int value = eval_if_expr (pfile);\n   conditional_skip (pfile, value == 0, T_IF, control_macro);\n   return 0;\n }\n@@ -1895,7 +1901,7 @@ do_elif (pfile, keyword)\n     skip_if_group (pfile);\n   else\n     {\n-      HOST_WIDEST_INT value = eval_if_expr (pfile);\n+      int value = eval_if_expr (pfile);\n       if (value == 0)\n \tskip_if_group (pfile);\n       else\n@@ -1907,16 +1913,15 @@ do_elif (pfile, keyword)\n   return 0;\n }\n \n-/*\n- * evaluate a #if expression in BUF, of length LENGTH,\n- * then parse the result as a C expression and return the value as an int.\n+/* Thin wrapper around _cpp_parse_expr, which doesn't have access to\n+ * skip_rest_of_line.  Also centralizes toggling parsing_if_directive.\n  */\n \n-static HOST_WIDEST_INT\n+static int\n eval_if_expr (pfile)\n      cpp_reader *pfile;\n {\n-  HOST_WIDEST_INT value;\n+  int value;\n   long old_written = CPP_WRITTEN (pfile);\n \n   pfile->parsing_if_directive++;\n@@ -1936,7 +1941,7 @@ eval_if_expr (pfile)\n  */\n \n static int\n-do_xifdef (pfile, keyword)\n+do_ifdef (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword;\n {\n@@ -2578,7 +2583,8 @@ cpp_get_token (pfile)\n \t\tbreak;\n \t      if (!is_numchar(c) && c != '.'\n \t\t  && ((c2 != 'e' && c2 != 'E'\n-\t\t       && ((c2 != 'p' && c2 != 'P') || CPP_C89 (pfile)))\n+\t\t       && ((c2 != 'p' && c2 != 'P')\n+\t\t\t   || CPP_OPTIONS (pfile)->c89))\n \t\t      || (c != '+' && c != '-')))\n \t\tbreak;\n \t      FORWARD(1);"}, {"sha": "a7dc4f7f2340a86c91113becc93b978debe6b64e", "filename": "gcc/cpplib.h", "status": "modified", "additions": 18, "deletions": 213, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -28,8 +28,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n extern \"C\" {\n #endif\n \n-typedef unsigned char U_CHAR;\n-\n typedef struct cpp_reader cpp_reader;\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n@@ -63,14 +61,6 @@ enum cpp_token\n \n typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n-extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n-extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n-extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n-extern enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n-\n-/* This frees resources used by PFILE. */\n-extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n-\n struct cpp_buffer\n {\n   unsigned char *cur;\t /* current position */\n@@ -227,79 +217,34 @@ struct cpp_reader\n   /* A buffer and a table, used only by read_and_prescan (in cppfiles.c)\n      which are allocated once per cpp_reader object to keep them off the\n      stack and avoid setup costs.  */\n-  U_CHAR *input_buffer;\n-  U_CHAR *input_speccase;\n+  unsigned char *input_buffer;\n+  unsigned char *input_speccase;\n   size_t input_buffer_len;\n };\n \n #define CPP_FATAL_LIMIT 1000\n /* True if we have seen a \"fatal\" error. */\n #define CPP_FATAL_ERRORS(READER) ((READER)->errors >= CPP_FATAL_LIMIT)\n \n-#define CPP_BUF_PEEK(BUFFER) \\\n-  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)\n-#define CPP_BUF_GET(BUFFER) \\\n-  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n-#define CPP_FORWARD(BUFFER, N) ((BUFFER)->cur += (N))\n-\n /* Macros for manipulating the token_buffer. */\n \n-#define CPP_OUT_BUFFER(PFILE) ((PFILE)->token_buffer)\n-\n /* Number of characters currently in PFILE's output buffer. */\n #define CPP_WRITTEN(PFILE) ((size_t)((PFILE)->limit - (PFILE)->token_buffer))\n #define CPP_PWRITTEN(PFILE) ((PFILE)->limit)\n+#define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n+#define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n \n /* Make sure PFILE->token_buffer has space for at least N more characters. */\n #define CPP_RESERVE(PFILE, N) \\\n   (CPP_WRITTEN (PFILE) + (size_t)(N) > (PFILE)->token_buffer_size \\\n    && (cpp_grow_buffer (PFILE, N), 0))\n \n-/* Append string STR (of length N) to PFILE's output buffer.\n-   Assume there is enough space. */\n-#define CPP_PUTS_Q(PFILE, STR, N) \\\n-  (memcpy ((PFILE)->limit, STR, (N)), (PFILE)->limit += (N))\n-/* Append string STR (of length N) to PFILE's output buffer.  Make space. */\n-#define CPP_PUTS(PFILE, STR, N) CPP_RESERVE(PFILE, N), CPP_PUTS_Q(PFILE, STR,N)\n-/* Append character CH to PFILE's output buffer.  Assume sufficient space. */\n-#define CPP_PUTC_Q(PFILE, CH) (*(PFILE)->limit++ = (CH))\n-/* Append character CH to PFILE's output buffer.  Make space if need be. */\n-#define CPP_PUTC(PFILE, CH) (CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))\n-/* Make sure PFILE->limit is followed by '\\0'. */\n-#define CPP_NUL_TERMINATE_Q(PFILE) (*(PFILE)->limit = 0)\n-#define CPP_NUL_TERMINATE(PFILE) (CPP_RESERVE(PFILE, 1), *(PFILE)->limit = 0)\n-#define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n-#define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n-\n-/* Advance the current line by one. */\n-#define CPP_BUMP_BUFFER_LINE(PBUF) ((PBUF)->lineno++,\\\n-\t\t\t\t    (PBUF)->line_base = (PBUF)->cur)\n-#define CPP_BUMP_LINE(PFILE) CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))\n-\n #define CPP_OPTIONS(PFILE) ((PFILE)->opts)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n-#define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n-\n-/* The `pending' structure accumulates all the options that are not\n-   actually processed until we hit cpp_start_read.  It consists of\n-   several lists, one for each type of option.  We keep both head and\n-   tail pointers for quick insertion. */\n-struct cpp_pending\n-{\n-  struct pending_option *define_head, *define_tail;\n-  struct pending_option *assert_head, *assert_tail;\n-\n-  struct file_name_list *quote_head, *quote_tail;\n-  struct file_name_list *brack_head, *brack_tail;\n-  struct file_name_list *systm_head, *systm_tail;\n-  struct file_name_list *after_head, *after_tail;\n-\n-  struct pending_option *imacros_head, *imacros_tail;\n-  struct pending_option *include_head, *include_tail;\n-};\n \n /* Pointed to by cpp_reader.opts. */\n-struct cpp_options {\n+struct cpp_options\n+{\n   char *in_fname;\n \n   /* Name of output file, for error messages.  */\n@@ -488,144 +433,19 @@ struct cpp_options {\n   char *deps_target;\n };\n \n-#define CPP_TRADITIONAL(PFILE) (CPP_OPTIONS(PFILE)-> traditional)\n-#define CPP_WARN_UNDEF(PFILE) (CPP_OPTIONS(PFILE)->warn_undef)\n-#define CPP_C89(PFILE) (CPP_OPTIONS(PFILE)->c89)\n-#define CPP_PREPROCESSED(PFILE) (CPP_OPTIONS (PFILE)->preprocessed)\n-#define CPP_PRINT_DEPS(PFILE) (CPP_OPTIONS (PFILE)->print_deps)\n-\n-#define CPP_PEDANTIC(PFILE) \\\n-  (CPP_OPTIONS (PFILE)->pedantic && !CPP_BUFFER (pfile)->system_header_p)\n-\n-/* List of directories to look for include files in. */\n-struct file_name_list\n-{\n-  struct file_name_list *next;\n-  struct file_name_list *alloc; /* for the cache of\n-\t\t\t\t   current directory entries */\n-  char *name;\n-  unsigned int nlen;\n-  /* We use these to tell if the directory mentioned here is a duplicate\n-     of an earlier directory on the search path. */\n-  ino_t ino;\n-  dev_t dev;\n-  /* If the following is nonzero, it is a C-language system include\n-     directory.  */\n-  int sysp;\n-  /* Mapping of file names for this directory.\n-     Only used on MS-DOS and related platforms. */\n-  struct file_name_map *name_map;\n-};\n-#define ABSOLUTE_PATH ((struct file_name_list *)-1)\n-\n-/* This structure is used for the table of all includes.  It is\n-   indexed by the `short name' (the name as it appeared in the\n-   #include statement) which is stored in *nshort.  */\n-struct ihash\n-{\n-  struct ihash *next;\n-  /* Next file with the same short name but a\n-     different (partial) pathname). */\n-  struct ihash *next_this_file;\n-\n-  /* Location of the file in the include search path.\n-     Used for include_next */\n-  struct file_name_list *foundhere;\n-  const char *name;\t\t/* (partial) pathname of file */\n-  const char *nshort;\t\t/* name of file as referenced in #include */\n-  const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion -\n-\t\t\t\t   see redundant_include_p */\n-  char *buf, *limit;\t\t/* for file content cache,\n-\t\t\t\t   not yet implemented */\n-};\n-typedef struct ihash IHASH;\n-\n /* Name under which this program was invoked.  */\n-\n extern const char *progname;\n \n-/* The structure of a node in the hash table.  The hash table\n-   has entries for all tokens defined by #define commands (type T_MACRO),\n-   plus some special tokens like __LINE__ (these each have their own\n-   type, and the appropriate code is run when that type of node is seen.\n-   It does not contain control words like \"#define\", which are recognized\n-   by a separate piece of code. */\n-\n-/* different flavors of hash nodes --- also used in keyword table */\n-enum node_type {\n- T_DEFINE = 1,\t/* the `#define' keyword */\n- T_INCLUDE,\t/* the `#include' keyword */\n- T_INCLUDE_NEXT, /* the `#include_next' keyword */\n- T_IMPORT,      /* the `#import' keyword */\n- T_IFDEF,\t/* the `#ifdef' keyword */\n- T_IFNDEF,\t/* the `#ifndef' keyword */\n- T_IF,\t\t/* the `#if' keyword */\n- T_ELSE,\t/* `#else' */\n- T_PRAGMA,\t/* `#pragma' */\n- T_ELIF,\t/* `#elif' */\n- T_UNDEF,\t/* `#undef' */\n- T_LINE,\t/* `#line' */\n- T_ERROR,\t/* `#error' */\n- T_WARNING,\t/* `#warning' */\n- T_ENDIF,\t/* `#endif' */\n- T_SCCS,\t/* `#sccs', used on system V.  */\n- T_IDENT,\t/* `#ident', used on system V.  */\n- T_ASSERT,\t/* `#assert', taken from system V.  */\n- T_UNASSERT,\t/* `#unassert', taken from system V.  */\n- T_SPECLINE,\t/* special symbol `__LINE__' */\n- T_DATE,\t/* `__DATE__' */\n- T_FILE,\t/* `__FILE__' */\n- T_BASE_FILE,\t/* `__BASE_FILE__' */\n- T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n- T_VERSION,\t/* `__VERSION__' */\n- T_TIME,\t/* `__TIME__' */\n- T_STDC,\t/* `__STDC__' */\n- T_CONST,\t/* Constant string, used by `__SIZE_TYPE__' etc */\n- T_MACRO,\t/* macro defined by `#define' */\n- T_DISABLED,\t/* macro temporarily turned off for rescan */\n- T_POISON,\t/* defined with `#pragma poison' */\n- T_UNUSED\t/* Used for something not defined.  */\n- };\n-\n-/* Character classes.\n-   If the definition of `numchar' looks odd to you, please look up the\n-   definition of a pp-number in the C standard [section 6.4.8 of C99] */\n-#define ISidnum\t\t0x01\t/* a-zA-Z0-9_ */\n-#define ISidstart\t0x02\t/* _a-zA-Z */\n-#define ISnumstart\t0x04\t/* 0-9 */\n-#define IShspace\t0x08\t/* ' ' \\t \\f \\v */\n-#define ISspace\t\t0x10\t/* ' ' \\t \\f \\v \\n */\n-\n-#define _dollar_ok(x)\t((x) == '$' && CPP_OPTIONS (pfile)->dollars_in_ident)\n-\n-#define is_idchar(x)\t((_cpp_IStable[x] & ISidnum) || _dollar_ok(x))\n-#define is_idstart(x)\t((_cpp_IStable[x] & ISidstart) || _dollar_ok(x))\n-#define is_numchar(x)\t(_cpp_IStable[x] & ISidnum)\n-#define is_numstart(x)\t(_cpp_IStable[x] & ISnumstart)\n-#define is_hspace(x)\t(_cpp_IStable[x] & IShspace)\n-#define is_space(x)\t(_cpp_IStable[x] & ISspace)\n-\n-/* This table is constant if it can be initialized at compile time,\n-   which is the case if cpp was compiled with GCC >=2.7, or another\n-   compiler that supports C99.  */\n-#if (GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L)\n-extern const unsigned char _cpp_IStable[256];\n-#else\n-extern unsigned char _cpp_IStable[256];\n-#endif\n-\n-/* Stack of conditionals currently in progress\n-   (including both successful and failing conditionals).  */\n+extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n+extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n+extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n+extern enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n \n-struct if_stack\n-{\n-  struct if_stack *next;\n-  int lineno;\t\t\t/* line number where condition started */\n-  int if_succeeded;\t\t/* truth of last condition in this group */\n-  const U_CHAR *control_macro;\t/* macro name for #ifndef around entire file */\n-  enum node_type type;\t\t/* type of last directive seen in this group */\n-};\n-typedef struct if_stack IF_STACK;\n+extern void cpp_reader_init PARAMS ((cpp_reader *));\n+extern void cpp_options_init PARAMS ((cpp_options *));\n+extern int cpp_start_read PARAMS ((cpp_reader *, char *));\n+extern void cpp_finish PARAMS ((cpp_reader *));\n+extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n \n extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n extern cpp_buffer *cpp_file_buffer PARAMS((cpp_reader *));\n@@ -667,16 +487,11 @@ extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    unsigned char *, long));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n-extern int cpp_defined PARAMS ((cpp_reader *, const U_CHAR *, int));\n-\n-extern void cpp_reader_init PARAMS ((cpp_reader *));\n-extern void cpp_options_init PARAMS ((cpp_options *));\n-extern int cpp_start_read PARAMS ((cpp_reader *, char *));\n-extern void cpp_finish PARAMS ((cpp_reader *));\n+extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));\n-extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t\t int));\n+extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char *, int));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n \n /* Last arg to output_line_command.  */\n@@ -688,16 +503,6 @@ extern void output_line_command\t\tPARAMS ((cpp_reader *,\n extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n \n-extern void _cpp_simplify_pathname\tPARAMS ((char *));\n-extern void _cpp_merge_include_chains\tPARAMS ((struct cpp_options *));\n-extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tIHASH **, int *));\n-extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n-\n-/* In cppexp.c */\n-extern HOST_WIDEST_INT _cpp_parse_expr\tPARAMS ((cpp_reader *));\n-\n \n #ifdef __cplusplus\n }"}, {"sha": "c4d7e728ae16f841f785101f654ad9ae0e04eaeb", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ae23e71dffcd197fc5410a582a470fcbcc2ba9/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=88ae23e71dffcd197fc5410a582a470fcbcc2ba9", "patch": "@@ -631,6 +631,7 @@ read_scan_file (in_fname, argc, argv)\n      so ignore warnings and errors.  */\n   scan_options.inhibit_warnings = 1;\n   scan_options.inhibit_errors = 1;\n+  scan_options.no_line_commands = 1;\n   i = cpp_handle_options (&scan_in, argc, argv);\n   if (i < argc && ! CPP_FATAL_ERRORS (&scan_in))\n     cpp_fatal (&scan_in, \"Invalid option `%s'\", argv[i]);\n@@ -639,7 +640,6 @@ read_scan_file (in_fname, argc, argv)\n \n   if (! cpp_start_read (&scan_in, in_fname))\n     exit (FATAL_EXIT_CODE);\n-  CPP_OPTIONS (&scan_in)->no_line_commands = 1;\n \n   scan_decls (&scan_in, argc, argv);\n   for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)"}]}