{"sha": "95726648efb29340078bdea2a882341c867434ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU3MjY2NDhlZmIyOTM0MDA3OGJkZWEyYTg4MjM0MWM4Njc0MzRiYQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-09T19:46:19Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-09T19:46:19Z"}, "message": "sparc.c (sp64_medium_pic_operand): New function.\n\n\t* sparc/sparc.c (sp64_medium_pic_operand): New function.\n\t(move_pic_label): Delete.\n\t(legitimize_pic_address): Simplify using some named patterns.\n\t(finalize_pic): Add preliminary sparc64 support.\n\t(emit_move_sequence): Reorganize.\n\t* sparc/sparc.md (pic_lo_sum_si,pic_sethi_si,get_pc_sp32,get_pc_sp64,\n\tmove_pic_label_si,move_label_di,sethi_di_sp64): Make named patterns.\n\t(sethi_di_sp64_const,sethi_di_medium_pic): New anonymous patterns.\n\t(move_pic_label_si,move_label_di): Optimize for near labels.\n\t(tablejump): Use for TARGET_MEDANY.\n\t(casesi): Delete.\n\nFrom-SVN: r11185", "tree": {"sha": "1b23a367e8b6d084b07c71823f46bae715fba5ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b23a367e8b6d084b07c71823f46bae715fba5ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95726648efb29340078bdea2a882341c867434ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95726648efb29340078bdea2a882341c867434ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95726648efb29340078bdea2a882341c867434ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95726648efb29340078bdea2a882341c867434ba/comments", "author": null, "committer": null, "parents": [{"sha": "cd9784dbc9c186c05d41bae330c5946a8324ccad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9784dbc9c186c05d41bae330c5946a8324ccad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9784dbc9c186c05d41bae330c5946a8324ccad"}], "stats": {"total": 387, "additions": 204, "deletions": 183}, "files": [{"sha": "4dc9e5b2dc8608dbbed589458315528bd7f32277", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 114, "deletions": 94, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95726648efb29340078bdea2a882341c867434ba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95726648efb29340078bdea2a882341c867434ba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=95726648efb29340078bdea2a882341c867434ba", "patch": "@@ -341,6 +341,31 @@ symbolic_memory_operand (op, mode)\n \t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n }\n \n+/* Return 1 if the operand is an argument used in generating pic references\n+   in either the medium/low or medium/anywhere code models of sparc64.  */\n+\n+int\n+sp64_medium_pic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Check for (const (minus (symbol_ref:GOT)\n+                             (const (minus (label) (pc))))).  */\n+  if (GET_CODE (op) != CONST)\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) != MINUS)\n+    return 0;\n+  if (GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n+    return 0;\n+  /* ??? Ensure symbol is GOT.  */\n+  if (GET_CODE (XEXP (op, 1)) != CONST)\n+    return 0;\n+  if (GET_CODE (XEXP (XEXP (op, 1), 0)) != MINUS)\n+    return 0;\n+  return 1;\n+}\n+\n /* Return 1 if the operand is a data segment reference.  This includes\n    the readonly data segment, or in other words anything but the text segment.\n    This is needed in the medium/anywhere code model on v9.  These values\n@@ -356,7 +381,8 @@ data_segment_operand (op, mode)\n     case SYMBOL_REF :\n       return ! SYMBOL_REF_FLAG (op);\n     case PLUS :\n-      /* Assume canonical format of symbol + constant.  */\n+      /* Assume canonical format of symbol + constant.\n+\t Fall through.  */\n     case CONST :\n       return data_segment_operand (XEXP (op, 0));\n     default :\n@@ -379,7 +405,8 @@ text_segment_operand (op, mode)\n     case SYMBOL_REF :\n       return SYMBOL_REF_FLAG (op);\n     case PLUS :\n-      /* Assume canonical format of symbol + constant.  */\n+      /* Assume canonical format of symbol + constant.\n+\t Fall through.  */\n     case CONST :\n       return text_segment_operand (XEXP (op, 0));\n     default :\n@@ -452,17 +479,6 @@ move_operand (op, mode)\n   return memory_address_p (mode, op);\n }\n \n-int\n-move_pic_label (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  /* Special case for PIC.  */\n-  if (flag_pic && GET_CODE (op) == LABEL_REF)\n-    return 1;\n-  return 0;\n-}\n-\n int\n splittable_symbolic_memory_operand (op, mode)\n      rtx op;\n@@ -1150,16 +1166,9 @@ legitimize_pic_address (orig, mode, reg)\n \t     won't get confused into thinking that these two instructions\n \t     are loading in the true address of the symbol.  If in the\n \t     future a PIC rtx exists, that should be used instead.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n-\t\t\t      gen_rtx (HIGH, Pmode,\n-\t\t\t\t       gen_rtx (UNSPEC, Pmode,\n-\t\t\t\t\t\tgen_rtvec (1, orig),\n-\t\t\t\t\t\t0))));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n-\t\t\t      gen_rtx (LO_SUM, Pmode, temp_reg,\n-\t\t\t\t       gen_rtx (UNSPEC, Pmode,\n-\t\t\t\t\t\tgen_rtvec (1, orig),\n-\t\t\t\t\t\t0))));\n+\t  emit_insn (gen_pic_sethi_si (temp_reg, orig));\n+\t  emit_insn (gen_pic_lo_sum_si (temp_reg, temp_reg, orig));\n+\n \t  address = temp_reg;\n \t}\n       else\n@@ -1215,6 +1224,7 @@ legitimize_pic_address (orig, mode, reg)\n       return gen_rtx (PLUS, Pmode, base, offset);\n     }\n   else if (GET_CODE (orig) == LABEL_REF)\n+    /* ??? Why do we do this?  */\n     current_function_uses_pic_offset_table = 1;\n \n   return orig;\n@@ -1247,18 +1257,12 @@ finalize_pic ()\n     abort ();\n \n   flag_pic = 0;\n-  l1 = gen_label_rtx ();\n-  l2 = gen_label_rtx ();\n+\n+  /* ??? sparc64 pic currently under construction.  */\n \n   start_sequence ();\n \n-  emit_label (l1);\n-  /* Note that we pun calls and jumps here!  */\n-  emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n-                         gen_rtvec (2,\n-                                    gen_rtx (SET, VOIDmode, pc_rtx, gen_rtx (LABEL_REF, VOIDmode, l2)),\n-                                    gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 15), gen_rtx (LABEL_REF, VOIDmode, l2)))));\n-  emit_label (l2);\n+  l1 = gen_label_rtx ();\n \n   /* Initialize every time through, since we can't easily\n      know this to be permanent.  */\n@@ -1271,27 +1275,57 @@ finalize_pic ()\n \t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n \t\t\t\t\t\t   pc_rtx))));\n \n-  if (Pmode == DImode)\n-    emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\tgen_rtvec (2,\n-\t\t\t\t   gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\t\t\t    gen_rtx (HIGH, Pmode, pic_pc_rtx)),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 1)))));\n+  if (! TARGET_ARCH64)\n+    {\n+      l2 = gen_label_rtx ();\n+      emit_label (l1);\n+      /* Note that we pun calls and jumps here!  */\n+      emit_jump_insn (gen_get_pc_sp32 (l2));\n+      emit_label (l2);\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\t  gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  pic_offset_table_rtx,\n+\t\t\t  gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t   pic_offset_table_rtx, pic_pc_rtx)));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  pic_offset_table_rtx,\n+\t\t\t  gen_rtx (PLUS, Pmode,\n+\t\t\t\t   pic_offset_table_rtx,\n+\t\t\t\t   gen_rtx (REG, Pmode, 15))));\n+\n+      /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n+      LABEL_PRESERVE_P (l1) = 1;\n+      LABEL_PRESERVE_P (l2) = 1;\n+    }\n   else\n-    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (LO_SUM, Pmode,\n-\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (PLUS, Pmode,\n-\t\t\t       pic_offset_table_rtx, gen_rtx (REG, Pmode, 15))));\n-  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n-  LABEL_PRESERVE_P (l1) = 1;\n-  LABEL_PRESERVE_P (l2) = 1;\n+    {\n+      /* ??? This definately isn't right for -mfullany.  */\n+      /* ??? And it doesn't quite seem right for the others either.  */\n+      emit_label (l1);\n+      emit_insn (gen_get_pc_sp64 (gen_rtx (REG, Pmode, 1)));\n+\n+      /* Don't let the scheduler separate the previous insn from `l1'.  */\n+      emit_insn (gen_blockage ());\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\t  gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  pic_offset_table_rtx,\n+\t\t\t  gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t   pic_offset_table_rtx, pic_pc_rtx)));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  pic_offset_table_rtx,\n+\t\t\t  gen_rtx (PLUS, Pmode,\n+\t\t\t\t   pic_offset_table_rtx, gen_rtx (REG, Pmode, 1))));\n+\n+      /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n+      LABEL_PRESERVE_P (l1) = 1;\n+    }\n+\n   flag_pic = orig_flag_pic;\n \n   seq = gen_sequence ();\n@@ -1352,10 +1386,33 @@ emit_move_sequence (operands, mode)\n \t}\n     }\n \n-  /* Simplify the source if we need to.  Must handle DImode HIGH operators\n-     here because such a move needs a clobber added.  */\n-  if ((GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n-      || (GET_CODE (operand1) == HIGH && GET_MODE (operand1) == DImode))\n+  if (GET_CODE (operand1) == LABEL_REF\n+      && mode == SImode && flag_pic)\n+    {\n+      if (TARGET_ARCH64)\n+\tabort ();\n+      emit_insn (gen_move_pic_label_si (operand0, XEXP (operand1, 0)));\n+      return 1;\n+    }\n+  /* Non-pic LABEL_REF's in sparc64 are expensive to do the normal way,\n+     so always use special code.  */\n+  else if (GET_CODE (operand1) == LABEL_REF\n+\t   && mode == DImode)\n+    {\n+      if (! TARGET_ARCH64)\n+\tabort ();\n+      emit_insn (gen_move_label_di (operands[0], XEXP (operands[1], 0)));\n+      return 1;\n+    }\n+  /* DImode HIGH values in sparc64 need a clobber added.  */\n+  else if (TARGET_ARCH64\n+      && GET_CODE (operand1) == HIGH && GET_MODE (operand1) == DImode)\n+    {\n+      emit_insn (gen_sethi_di_sp64 (operand0, XEXP (operand1, 0)));\n+      return 1;\n+    }\n+  /* Simplify the source if we need to.  */\n+  else if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n     {\n       if (flag_pic && symbolic_operand (operand1, mode))\n \t{\n@@ -1387,29 +1444,7 @@ emit_move_sequence (operands, mode)\n \t\t      ? operand0 : gen_reg_rtx (mode));\n \n \t  if (TARGET_ARCH64 && mode == DImode)\n-\t    {\n-\t      int high_operand = 0;\n-\n-\t      /* If the operand is already a HIGH, then remove the HIGH so\n-\t\t that we won't get duplicate HIGH operators in this insn.\n-\t\t Also, we must store the result into the original dest,\n-\t\t because that is where the following LO_SUM expects it.  */\n-\t      if (GET_CODE (operand1) == HIGH)\n-\t\t{\n-\t\t  operand1 = XEXP (operand1, 0);\n-\t\t  high_operand = 1;\n-\t\t}\n-\n-\t      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t  gen_rtvec (2,\n-\t\t\t\t\t     gen_rtx (SET, VOIDmode, temp,\n-\t\t\t\t\t\t      gen_rtx (HIGH, mode, operand1)),\n-\t\t\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, DImode, 1)))));\n-\n-\t      /* If this was a high operand, then we are now finished.  */\n-\t      if (high_operand)\n-\t\treturn 1;\n-\t    }\n+\t    emit_insn (gen_sethi_di_sp64 (temp, operand1));\n \t  else\n \t    emit_insn (gen_rtx (SET, VOIDmode, temp,\n \t\t\t\tgen_rtx (HIGH, mode, operand1)));\n@@ -1418,21 +1453,6 @@ emit_move_sequence (operands, mode)\n \t}\n     }\n \n-  if (GET_CODE (operand1) == LABEL_REF && flag_pic)\n-    {\n-      /* The procedure for doing this involves using a call instruction to\n-\t get the pc into o7.  We need to indicate this explicitly because\n-\t the tablejump pattern assumes that it can use this value also.  */\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t  gen_rtvec (2,\n-\t\t\t\t     gen_rtx (SET, VOIDmode, operand0,\n-\t\t\t\t\t      operand1),\n-\t\t\t\t     gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, mode, 15),\n-\t\t\t\t\t      pc_rtx))));\n-      return 1;\n-    }\n-\n   /* Now have insn-emit do whatever it normally does.  */\n   return 0;\n }"}, {"sha": "d454a6f010557e2f5023b6c2812c645a68586cd9", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 90, "deletions": 89, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95726648efb29340078bdea2a882341c867434ba/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95726648efb29340078bdea2a882341c867434ba/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=95726648efb29340078bdea2a882341c867434ba", "patch": "@@ -1467,13 +1467,29 @@\n   ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n+(define_insn \"*sethi_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*sethi_hi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(high:HI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n ;; For PIC, symbol_refs are put inside unspec so that the optimizer will not\n ;; confuse them with real addresses.\n-(define_insn \"*pic_lo_sum_si\"\n+(define_insn \"pic_lo_sum_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (unspec:SI [(match_operand:SI 2 \"immediate_operand\" \"in\")] 0)))]\n-  \"\"\n+  \"flag_pic\"\n   ;; V9 needs \"add\" because of the code models.  We still use \"or\" for v8\n   ;; so we can compare the old compiler with the new.\n   \"* return TARGET_ARCH64 ? \\\"add %1,%%lo(%a2),%0\\\" : \\\"or %1,%%lo(%a2),%0\\\";\"\n@@ -1483,53 +1499,77 @@\n \n ;; For PIC, symbol_refs are put inside unspec so that the optimizer will not\n ;; confuse them with real addresses.\n-(define_insn \"*pic_sethi_si\"\n+(define_insn \"pic_sethi_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (unspec:SI [(match_operand 1 \"\" \"\")] 0)))]\n-  \"check_pic (1)\"\n+  \"flag_pic && check_pic (1)\"\n   \"sethi %%hi(%a1),%0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*sethi_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(high:SI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1)\"\n-  \"sethi %%hi(%a1),%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n+(define_insn \"get_pc_sp32\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n+   (set (reg:SI 15) (label_ref (match_dup 0)))]\n+  \"! TARGET_PTR64\"\n+  \"call %l0%#\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n \n-(define_insn \"*sethi_hi\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(high:HI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1)\"\n-  \"sethi %%hi(%a1),%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n+(define_insn \"get_pc_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\") (pc))]\n+  \"TARGET_PTR64\"\n+  \"rd %%pc,%0\"\n+  [(set_attr \"type\" \"move\")])\n \n ;; Special pic pattern, for loading the address of a label into a register.\n ;; It clobbers o7 because the call puts the return address (i.e. pc value)\n-;; there.\n+;; there.  The pic tablejump pattern also uses this.\n \n-(define_insn \"*move_pic_label_si\"\n+(define_insn \"move_pic_label_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"move_pic_label\" \"i\"))\n+\t(label_ref:SI (match_operand 1 \"\" \"\")))\n    (set (reg:SI 15) (pc))]\n-  \"\"\n-  \"\\\\n1:\\;call 2f\\;sethi %%hi(%l1-1b),%0\\\\n2:\\\\tor %0,%%lo(%l1-1b),%0\\;add %0,%%o7,%0\"\n+  \"flag_pic\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"\\\\n1:\\;call 2f\\;add %%o7,%%lo(%l1-1b),%0\\\\n2:\\\";\n+  else\n+    return \\\"\\\\n1:\\;call 2f\\;sethi %%hi(%l1-1b),%0\\\\n2:\\\\tor %0,%%lo(%l1-1b),%0\\;add %0,%%o7,%0\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; v9 special pic pattern, for loading the address of a label into a register.\n+   ; 1024 = 4096 bytes / 4 bytes/insn\n+   (set (attr \"length\") (if_then_else (ltu (minus (match_dup 1) (pc))\n+\t\t\t\t\t   (const_int 1024))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 4)))])\n+\n+;; Special sparc64 pattern for loading the address of a label into a register.\n+;; The pic and non-pic cases are the same since it's the most efficient way.\n+;;\n+;; ??? The non-pic case doesn't need to use %o7, we could use a scratch\n+;; instead.  But the pic case doesn't need to use %o7 either.  We handle them\n+;; both here so that when this is fixed, they can both be fixed together.\n+;; Don't forget that the pic jump table stuff uses %o7 (that will need to be\n+;; changed too).\n \n-(define_insn \"*move_pic_label_di\"\n+(define_insn \"move_label_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"move_pic_label\" \"i\"))\n+\t(label_ref:DI (match_operand 1 \"\" \"\")))\n    (set (reg:DI 15) (pc))]\n   \"TARGET_ARCH64\"\n-  \"\\\\n1:\\;call 2f\\;sethi %%hi(%l1-1b),%0\\\\n2:\\\\tor %0,%%lo(%l1-1b),%0\\;add %0,%%o7,%0\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"\\\\n1:\\;rd %%pc,%%o7\\;add %%o7,%l1-1b,%0\\\";\n+  else\n+    return \\\"\\\\n1:\\;rd %%pc,%%o7\\;sethi %%hi(%l1-1b),%0\\;add %0,%%lo(%l1-1b),%0\\;sra %0,0,%0\\;add %0,%%o7,%0\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")])\n+   ; 1024 = 4096 bytes / 4 bytes/insn\n+   (set (attr \"length\") (if_then_else (ltu (minus (match_dup 1) (pc))\n+\t\t\t\t\t   (const_int 1024))\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 5)))])\n \n (define_insn \"*lo_sum_di_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -1548,8 +1588,6 @@\n   ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n-;; ??? Gas does not handle %lo(DI), so we use the same code for ! TARGET_ARCH64.\n-;; ??? The previous comment is obsolete.\n ;; ??? Optimizer does not handle \"or %o1,%lo(0),%o1\". How about add?\n \n (define_insn \"*lo_sum_di_sp64\"\n@@ -1617,12 +1655,15 @@\n ;;; e.g. by using a toc like the romp and rs6000 ports do for addresses, reg\n ;;; 1 will then no longer need to be considered a fixed reg.\n \n-;;; Gas doesn't have any 64 bit constant support, so don't use %uhi and %ulo\n-;;; on constants.  Symbols have to be handled by the linker, so we must use\n-;;; %uhi and %ulo for them, but gas will handle these correctly.\n-;;; ??? This comment is obsolete, gas handles them now.\n+(define_expand \"sethi_di_sp64\"\n+  [(parallel\n+     [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t   (high:DI (match_operand 1 \"general_operand\" \"\")))\n+      (clobber (reg:DI 1))])]\n+  \"TARGET_ARCH64\"\n+  \"\")\n \n-(define_insn \"*sethi_di_sp64\"\n+(define_insn \"*sethi_di_sp64_const\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(high:DI (match_operand 1 \"const_double_operand\" \"\")))\n    (clobber (reg:DI 1))]\n@@ -1661,9 +1702,9 @@\n \n ;; When TARGET_MEDLOW, assume that the upper 32 bits of symbol addresses are\n ;; always 0.\n-;; When TARGET_MEDANY, the upper 32 bits of function addresses are 0.\n-;; The data segment has a maximum size of 32 bits, but may be located anywhere.\n-;; MEDANY_BASE_REG contains the start address, currently %g4.\n+;; When TARGET_MEDANY, the text and data segments have a maximum size of 32\n+;; bits and may be located anywhere.  MEDANY_BASE_REG contains the start\n+;; address of the data segment, currently %g4.\n ;; When TARGET_FULLANY, symbolic addresses are 64 bits.\n \n (define_insn \"*sethi_di_medlow\"\n@@ -1676,6 +1717,14 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*sethi_di_medium_pic\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(high:DI (match_operand 1 \"sp64_medium_pic_operand\" \"\")))]\n+  \"(TARGET_MEDLOW || TARGET_MEDANY) && check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n ;; WARNING: %0 gets %hi(%1)+%g4.\n ;;          You cannot OR in %lo(%1), it must be added in.\n \n@@ -4782,7 +4831,7 @@\n (define_expand \"tablejump\"\n   [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"r\"))\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n-  \"! TARGET_MEDANY\"\n+  \"\"\n   \"\n {\n   if (GET_MODE (operands[0]) != Pmode)\n@@ -4830,54 +4879,6 @@\n   \"jmp %a0%#\"\n   [(set_attr \"type\" \"uncond_branch\")])\n \n-(define_insn \"*get_pc_sp32\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n-   (set (reg:SI 15) (label_ref (match_dup 0)))]\n-  \"! TARGET_PTR64\"\n-  \"call %l0%#\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n-\n-(define_insn \"*get_pc_sp64\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n-   (set (reg:DI 15) (label_ref (match_dup 0)))]\n-  \"TARGET_PTR64\"\n-  \"call %l0%#\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n-\n-;; Implement a switch statement for the medium/anywhere code model.\n-;; This wouldn't be necessary if we could distinguish label refs of the jump\n-;; table from other label refs.  The problem is that jump tables live in the\n-;; .rodata section and thus we need to add %g4 to get their address.\n-\n-(define_expand \"casesi\"\n-  [(set (match_dup 5)\n-\t(minus:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n-   (set (reg:CC 0)\n-\t(compare:CC (match_dup 5)\n-\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (gtu (reg:CC 0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))\n-   (parallel [(set (match_dup 6) (high:DI (label_ref (match_operand 3 \"\" \"\"))))\n-\t      (clobber (reg:DI 1))])\n-   (set (match_dup 6)\n-\t(lo_sum:DI (match_dup 6) (label_ref (match_dup 3))))\n-   (set (match_dup 6) (plus:DI (match_dup 6) (reg:DI 4)))\n-   (set (match_dup 7) (zero_extend:DI (match_dup 5)))\n-   (set (match_dup 7) (ashift:DI (match_dup 7) (const_int 3)))\n-   (set (match_dup 7) (mem:DI (plus:DI (match_dup 6) (match_dup 7))))\n-   (set (pc) (match_dup 7))]\n-  \"TARGET_MEDANY\"\n-  \"\n-{\n-  operands[5] = gen_reg_rtx (SImode);\n-  operands[6] = gen_reg_rtx (DImode);\n-  operands[7] = gen_reg_rtx (DImode);\n-}\")\n-\n ;; This pattern recognizes the \"instruction\" that appears in \n ;; a function call that wants a structure value, \n ;; to inform the called function if compiled with Sun CC."}]}