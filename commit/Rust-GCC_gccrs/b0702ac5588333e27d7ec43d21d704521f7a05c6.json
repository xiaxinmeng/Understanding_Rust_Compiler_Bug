{"sha": "b0702ac5588333e27d7ec43d21d704521f7a05c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3MDJhYzU1ODgzMzNlMjdkN2VjNDNkMjFkNzA0NTIxZjdhMDVjNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-10-27T13:51:19Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-10-27T13:51:19Z"}, "message": "analyzer: eliminate non-determinism in logs\n\nThis patch and the followup eliminate various forms of non-determinism\nin the analyzer due to changing pointer values.\n\nThis patch fixes churn seen when diffing analyzer logs.  The patch\navoids embedding pointers in various places, and adds sorting when\ndumping hash_set and hash_map for various analyzer types.  Doing so\nrequires implementing a way to sort svalue instances, and assigning UIDs\nto gimple statements.\n\nTested both patches together via a script that runs a testcase 100 times,\nand then using diff and md5sum to verify that the results are consistent\nin the face of address space randomization:\n\nFILENAME=$1\nrm $FILENAME.*\nfor i in `seq 1 100`; do\n    echo \"iteration: $i\"\n    ./xgcc -B. -fanalyzer -c ../../src/gcc/testsuite/gcc.dg/analyzer/$FILENAME \\\n       --Wanalyzer-too-complex \\\n       -fdump-analyzer-supergraph \\\n       -fdump-analyzer-exploded-graph \\\n       -fdump-analyzer \\\n       -fdump-noaddr \\\n       -fdump-analyzer-exploded-nodes-2\n    mv $FILENAME.supergraph.dot $FILENAME.$i.supergraph.dot\n    mv $FILENAME.analyzer.txt $FILENAME.$i.analyzer.txt\n    mv $FILENAME.supergraph-eg.dot $FILENAME.$i.supergraph-eg.dot\n    mv $FILENAME.eg.txt $FILENAME.$i.eg.txt\n    mv $FILENAME.eg.dot $FILENAME.$i.eg.dot\ndone\n\ngcc/analyzer/ChangeLog:\n\t* engine.cc (setjmp_record::cmp): New.\n\t(supernode_cluster::dump_dot): Avoid embedding pointer in cluster\n\tname.\n\t(supernode_cluster::cmp_ptr_ptr): New.\n\t(function_call_string_cluster::dump_dot): Avoid embedding pointer\n\tin cluster name.  Sort m_map when dumping child clusters.\n\t(function_call_string_cluster::cmp_ptr_ptr): New.\n\t(root_cluster::dump_dot): Sort m_map when dumping child clusters.\n\t* program-point.cc (function_point::cmp): New.\n\t(function_point::cmp_ptr): New.\n\t* program-point.h (function_point::cmp): New decl.\n\t(function_point::cmp_ptr): New decl.\n\t* program-state.cc (sm_state_map::print): Sort the values.  Guard\n\tthe printing of pointers with !flag_dump_noaddr.\n\t(program_state::prune_for_point): Sort the regions.\n\t(log_set_of_svalues): Sort the values.  Guard the printing of\n\tpointers with !flag_dump_noaddr.\n\t* region-model-manager.cc (log_uniq_map): Sort the values.\n\t* region-model-reachability.cc (dump_set): New function template.\n\t(reachable_regions::dump_to_pp): Use it.\n\t* region-model.h (svalue::cmp_ptr): New decl.\n\t(svalue::cmp_ptr_ptr): New decl.\n\t(setjmp_record::cmp): New decl.\n\t(placeholder_svalue::get_name): New accessor.\n\t(widening_svalue::get_point): New accessor.\n\t(compound_svalue::get_map): New accessor.\n\t(conjured_svalue::get_stmt): New accessor.\n\t(conjured_svalue::get_id_region): New accessor.\n\t(region::cmp_ptrs): Rename to...\n\t(region::cmp_ptr_ptr): ...this.\n\t* region.cc (region::cmp_ptrs): Rename to...\n\t(region::cmp_ptr_ptr): ...this.\n\t* state-purge.cc\n\t(state_purge_per_ssa_name::state_purge_per_ssa_name): Sort\n\tm_points_needing_name when dumping.\n\t* store.cc (concrete_binding::cmp_ptr_ptr): New.\n\t(symbolic_binding::cmp_ptr_ptr): New.\n\t(binding_map::cmp): New.\n\t(get_sorted_parent_regions): Update for renaming of\n\tregion::cmp_ptrs to region::cmp_ptr_ptr.\n\t(store::dump_to_pp): Likewise.\n\t(store::to_json): Likewise.\n\t(store::can_merge_p): Sort the base regions before considering\n\tthem.\n\t* store.h (concrete_binding::cmp_ptr_ptr): New decl.\n\t(symbolic_binding::cmp_ptr_ptr): New decl.\n\t(binding_map::cmp): New decl.\n\t* supergraph.cc (supergraph::supergraph): Assign UIDs to the\n\tgimple stmts.\n\t* svalue.cc (cmp_cst): New.\n\t(svalue::cmp_ptr): New.\n\t(svalue::cmp_ptr_ptr): New.", "tree": {"sha": "de1ab726b16225999a368b75676db848b5c31ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de1ab726b16225999a368b75676db848b5c31ed6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0702ac5588333e27d7ec43d21d704521f7a05c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0702ac5588333e27d7ec43d21d704521f7a05c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0702ac5588333e27d7ec43d21d704521f7a05c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0702ac5588333e27d7ec43d21d704521f7a05c6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0ae4e77a89d4a0492dcbbc13e9cbc19bcc2361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0ae4e77a89d4a0492dcbbc13e9cbc19bcc2361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea0ae4e77a89d4a0492dcbbc13e9cbc19bcc2361"}], "stats": {"total": 558, "additions": 493, "deletions": 65}, "files": [{"sha": "49cd33e94dad3f9350905a6bfd2db6b011fbf5fa", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -149,6 +149,17 @@ impl_region_model_context::on_escaped_function (tree fndecl)\n   m_eg->on_escaped_function (fndecl);\n }\n \n+/* struct setjmp_record.  */\n+\n+int\n+setjmp_record::cmp (const setjmp_record &rec1, const setjmp_record &rec2)\n+{\n+  if (int cmp_enode = rec1.m_enode->m_index - rec2.m_enode->m_index)\n+    return cmp_enode;\n+  gcc_assert (&rec1 == &rec2);\n+  return 0;\n+}\n+\n /* class setjmp_svalue : public svalue.  */\n \n /* Implementation of svalue::accept vfunc for setjmp_svalue.  */\n@@ -3506,8 +3517,7 @@ class supernode_cluster : public exploded_cluster\n \n   void dump_dot (graphviz_out *gv, const dump_args_t &args) const FINAL OVERRIDE\n   {\n-    gv->println (\"subgraph \\\"cluster_supernode_%p\\\" {\",\n-\t\t (const void *)this);\n+    gv->println (\"subgraph \\\"cluster_supernode_%i\\\" {\", m_supernode->m_index);\n     gv->indent ();\n     gv->println (\"style=\\\"dashed\\\";\");\n     gv->println (\"label=\\\"SN: %i (bb: %i; scc: %i)\\\";\",\n@@ -3529,6 +3539,17 @@ class supernode_cluster : public exploded_cluster\n     m_enodes.safe_push (en);\n   }\n \n+  /* Comparator for use by auto_vec<supernode_cluster *>::qsort.  */\n+\n+  static int cmp_ptr_ptr (const void *p1, const void *p2)\n+  {\n+    const supernode_cluster *c1\n+      = *(const supernode_cluster * const *)p1;\n+    const supernode_cluster *c2\n+      = *(const supernode_cluster * const *)p2;\n+    return c1->m_supernode->m_index - c2->m_supernode->m_index;\n+  }\n+\n private:\n   const supernode *m_supernode;\n   auto_vec <exploded_node *> m_enodes;\n@@ -3555,18 +3576,28 @@ class function_call_string_cluster : public exploded_cluster\n   {\n     const char *funcname = function_name (m_fun);\n \n-    gv->println (\"subgraph \\\"cluster_function_%p\\\" {\", (const void *)this);\n+    gv->println (\"subgraph \\\"cluster_function_%s\\\" {\",\n+\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (m_fun->decl)));\n     gv->indent ();\n     gv->write_indent ();\n     gv->print (\"label=\\\"call string: \");\n     m_cs.print (gv->get_pp ());\n     gv->print (\" function: %s \\\";\", funcname);\n     gv->print (\"\\n\");\n \n+    /* Dump m_map, sorting it to avoid churn when comparing dumps.  */\n+    auto_vec<supernode_cluster *> child_clusters (m_map.elements ());\n     for (map_t::iterator iter = m_map.begin ();\n \t iter != m_map.end ();\n \t ++iter)\n-      (*iter).second->dump_dot (gv, args);\n+      child_clusters.quick_push ((*iter).second);\n+\n+    child_clusters.qsort (supernode_cluster::cmp_ptr_ptr);\n+\n+    unsigned i;\n+    supernode_cluster *child_cluster;\n+    FOR_EACH_VEC_ELT (child_clusters, i, child_cluster)\n+      child_cluster->dump_dot (gv, args);\n \n     /* Terminate subgraph.  */\n     gv->outdent ();\n@@ -3588,6 +3619,21 @@ class function_call_string_cluster : public exploded_cluster\n       }\n   }\n \n+  /* Comparator for use by auto_vec<function_call_string_cluster *>.  */\n+\n+  static int cmp_ptr_ptr (const void *p1, const void *p2)\n+  {\n+    const function_call_string_cluster *c1\n+      = *(const function_call_string_cluster * const *)p1;\n+    const function_call_string_cluster *c2\n+      = *(const function_call_string_cluster * const *)p2;\n+    if (int cmp_names\n+\t= strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (c1->m_fun->decl)),\n+\t\t  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (c2->m_fun->decl))))\n+      return cmp_names;\n+    return call_string::cmp (c1->m_cs, c2->m_cs);\n+  }\n+\n private:\n   function *m_fun;\n   call_string m_cs;\n@@ -3680,10 +3726,18 @@ class root_cluster : public exploded_cluster\n     FOR_EACH_VEC_ELT (m_functionless_enodes, i, enode)\n       enode->dump_dot (gv, args);\n \n+    /* Dump m_map, sorting it to avoid churn when comparing dumps.  */\n+    auto_vec<function_call_string_cluster *> child_clusters (m_map.elements ());\n     for (map_t::iterator iter = m_map.begin ();\n \t iter != m_map.end ();\n \t ++iter)\n-      (*iter).second->dump_dot (gv, args);\n+      child_clusters.quick_push ((*iter).second);\n+\n+    child_clusters.qsort (function_call_string_cluster::cmp_ptr_ptr);\n+\n+    function_call_string_cluster *child_cluster;\n+    FOR_EACH_VEC_ELT (child_clusters, i, child_cluster)\n+      child_cluster->dump_dot (gv, args);\n   }\n \n   void add_node (exploded_node *en) FINAL OVERRIDE"}, {"sha": "d8fde6033747849f8ece19f2eeb68a45ebfe1e16", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -558,6 +558,33 @@ function_point::cmp_within_supernode (const function_point &point_a,\n   return result;\n }\n \n+/* Comparator for imposing an order on function_points.  */\n+\n+int\n+function_point::cmp (const function_point &point_a,\n+\t\t     const function_point &point_b)\n+{\n+  int idx_a = point_a.m_supernode ? point_a.m_supernode->m_index : -1;\n+  int idx_b = point_b.m_supernode ? point_b.m_supernode->m_index : -1;\n+  if (int cmp_idx = idx_a - idx_b)\n+    return cmp_idx;\n+  gcc_assert (point_a.m_supernode == point_b.m_supernode);\n+  if (point_a.m_supernode)\n+    return cmp_within_supernode (point_a, point_b);\n+  else\n+    return 0;\n+}\n+\n+/* Comparator for use by vec<function_point>::qsort.  */\n+\n+int\n+function_point::cmp_ptr (const void *p1, const void *p2)\n+{\n+  const function_point *fp1 = (const function_point *)p1;\n+  const function_point *fp2 = (const function_point *)p2;\n+  return cmp (*fp1, *fp2);\n+}\n+\n /* For PK_BEFORE_STMT, go to next stmt (or to PK_AFTER_SUPERNODE).  */\n \n void"}, {"sha": "2d1c3aba7cbd31e3a83d9bade223999b8a378ab8", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -138,6 +138,9 @@ class function_point\n \t\t\t\t     const function_point &point_b);\n   static int cmp_within_supernode (const function_point &point_a,\n \t\t\t\t   const function_point &point_b);\n+  static int cmp (const function_point &point_a,\n+\t\t  const function_point &point_b);\n+  static int cmp_ptr (const void *p1, const void *p2);\n \n   /* For before_stmt, go to next stmt.  */\n   void next_stmt ();"}, {"sha": "2313a662e360d084c6876298ed0bd9a4317b137d", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -170,21 +170,29 @@ sm_state_map::print (const region_model *model,\n \tpp_newline (pp);\n       first = false;\n     }\n+  auto_vec <const svalue *> keys (m_map.elements ());\n   for (map_t::iterator iter = m_map.begin ();\n        iter != m_map.end ();\n        ++iter)\n+    keys.quick_push ((*iter).first);\n+  keys.qsort (svalue::cmp_ptr_ptr);\n+  unsigned i;\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (keys, i, sval)\n     {\n       if (multiline)\n \tpp_string (pp, \"  \");\n       else if (!first)\n \tpp_string (pp, \", \");\n       first = false;\n-      const svalue *sval = (*iter).first;\n-      pp_pointer (pp, sval);\n-      pp_string (pp, \": \");\n+      if (!flag_dump_noaddr)\n+\t{\n+\t  pp_pointer (pp, sval);\n+\t  pp_string (pp, \": \");\n+\t}\n       sval->dump_to_pp (pp, simple);\n \n-      entry_t e = (*iter).second;\n+      entry_t e = *const_cast <map_t &> (m_map).get (sval);\n       pp_string (pp, \": \");\n       e.m_state->dump_to_pp (pp);\n       if (model)\n@@ -916,6 +924,7 @@ program_state::prune_for_point (exploded_graph &eg,\n       auto_vec<const decl_region *> ssa_name_regs;\n       new_state.m_region_model->get_ssa_name_regions_for_current_frame\n \t(&ssa_name_regs);\n+      ssa_name_regs.qsort (region::cmp_ptr_ptr);\n       unsigned i;\n       const decl_region *reg;\n       FOR_EACH_VEC_ELT (ssa_name_regs, i, reg)\n@@ -1032,18 +1041,26 @@ program_state::validate (const extrinsic_state &ext_state) const\n \n static void\n log_set_of_svalues (logger *logger, const char *name,\n-\t\t     const svalue_set &set)\n+\t\t    const svalue_set &set)\n {\n   logger->log (name);\n   logger->inc_indent ();\n+  auto_vec<const svalue *> sval_vecs (set.elements ());\n   for (svalue_set::iterator iter = set.begin ();\n        iter != set.end (); ++iter)\n+    sval_vecs.quick_push (*iter);\n+  sval_vecs.qsort (svalue::cmp_ptr_ptr);\n+  unsigned i;\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (sval_vecs, i, sval)\n     {\n       logger->start_log_line ();\n       pretty_printer *pp = logger->get_printer ();\n-      const svalue *sval = (*iter);\n-      pp_pointer (pp, sval);\n-      pp_string (pp, \": \");\n+      if (!flag_dump_noaddr)\n+\t{\n+\t  pp_pointer (pp, sval);\n+\t  pp_string (pp, \": \");\n+\t}\n       sval->dump_to_pp (pp, false);\n       logger->end_log_line ();\n     }"}, {"sha": "f7fa33b028c37cfa8eccb095c1a55158e86bc40a", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -1033,13 +1033,19 @@ log_uniq_map (logger *logger, bool show_objs, const char *title,\n \t      const hash_map<K, T*> &uniq_map)\n {\n   logger->log (\"  # %s: %li\", title, uniq_map.elements ());\n-  if (show_objs)\n-    for (typename hash_map<K, T*>::iterator iter = uniq_map.begin ();\n-\t iter != uniq_map.end (); ++iter)\n-      {\n-\tT *managed_obj = (*iter).second;\n-\tlog_managed_object<T> (logger, managed_obj);\n-      }\n+  if (!show_objs)\n+    return;\n+  auto_vec<const T *> vec_objs (uniq_map.elements ());\n+  for (typename hash_map<K, T*>::iterator iter = uniq_map.begin ();\n+       iter != uniq_map.end (); ++iter)\n+    vec_objs.quick_push ((*iter).second);\n+\n+  vec_objs.qsort (T::cmp_ptr_ptr);\n+\n+  unsigned i;\n+  const T *obj;\n+  FOR_EACH_VEC_ELT (vec_objs, i, obj)\n+    log_managed_object<T> (logger, obj);\n }\n \n /* Dump the number of objects that were managed by MAP to LOGGER.\n@@ -1051,13 +1057,20 @@ log_uniq_map (logger *logger, bool show_objs, const char *title,\n \t      const consolidation_map<T> &map)\n {\n   logger->log (\"  # %s: %li\", title, map.elements ());\n-  if (show_objs)\n-    for (typename consolidation_map<T>::iterator iter = map.begin ();\n-\t iter != map.end (); ++iter)\n-      {\n-\tT *managed_obj = (*iter).second;\n-\tlog_managed_object<T> (logger, managed_obj);\n-      }\n+  if (!show_objs)\n+    return;\n+\n+  auto_vec<const T *> vec_objs (map.elements ());\n+  for (typename consolidation_map<T>::iterator iter = map.begin ();\n+       iter != map.end (); ++iter)\n+    vec_objs.quick_push ((*iter).second);\n+\n+  vec_objs.qsort (T::cmp_ptr_ptr);\n+\n+  unsigned i;\n+  const T *obj;\n+  FOR_EACH_VEC_ELT (vec_objs, i, obj)\n+    log_managed_object<T> (logger, obj);\n }\n \n /* Dump the number of objects of each class that were managed by this"}, {"sha": "52525e1144be6342d48870faf7a47783cca5010b", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -227,47 +227,49 @@ reachable_regions::mark_escaped_clusters (region_model_context *ctxt)\n     }\n }\n \n+/* Dump SET to PP, sorting it to avoid churn when comparing dumps.  */\n+\n+template <typename T>\n+static void\n+dump_set (const hash_set<const T *> &set, pretty_printer *pp)\n+{\n+  auto_vec<const T *> elements (set.elements ());\n+  for (typename hash_set<const T *>::iterator iter = set.begin ();\n+       iter != set.end (); ++iter)\n+    elements.quick_push (*iter);\n+\n+  elements.qsort (T::cmp_ptr_ptr);\n+\n+  unsigned i;\n+  const T *element;\n+  FOR_EACH_VEC_ELT (elements, i, element)\n+    {\n+      pp_string (pp, \"  \");\n+      element->dump_to_pp (pp, true);\n+      pp_newline (pp);\n+    }\n+}\n+\n /* Dump a multiline representation of this object to PP.  */\n \n void\n reachable_regions::dump_to_pp (pretty_printer *pp) const\n {\n   pp_string (pp, \"reachable clusters: \");\n   pp_newline (pp);\n-  for (hash_set<const region *>::iterator iter = m_reachable_base_regs.begin ();\n-       iter != m_reachable_base_regs.end (); ++iter)\n-    {\n-      pp_string (pp, \"  \");\n-      (*iter)->dump_to_pp (pp, true);\n-      pp_newline (pp);\n-    }\n+  dump_set (m_reachable_base_regs, pp);\n+\n   pp_string (pp, \"mutable clusters: \");\n   pp_newline (pp);\n-  for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();\n-       iter != m_mutable_base_regs.end (); ++iter)\n-    {\n-      pp_string (pp, \"  \");\n-      (*iter)->dump_to_pp (pp, true);\n-      pp_newline (pp);\n-    }\n+  dump_set (m_mutable_base_regs, pp);\n+\n   pp_string (pp, \"reachable svals: \");\n   pp_newline (pp);\n-  for (svalue_set::iterator iter = m_reachable_svals.begin ();\n-       iter != m_reachable_svals.end (); ++iter)\n-    {\n-      pp_string (pp, \"  \");\n-      (*iter)->dump_to_pp (pp, true);\n-      pp_newline (pp);\n-    }\n+  dump_set (m_reachable_svals, pp);\n+\n   pp_string (pp, \"mutable svals: \");\n   pp_newline (pp);\n-  for (svalue_set::iterator iter = m_mutable_svals.begin ();\n-       iter != m_mutable_svals.end (); ++iter)\n-    {\n-      pp_string (pp, \"  \");\n-      (*iter)->dump_to_pp (pp, true);\n-      pp_newline (pp);\n-    }\n+  dump_set (m_mutable_svals, pp);\n }\n \n /* Dump a multiline representation of this object to stderr.  */"}, {"sha": "a67d6f4336f14301dfc9de4db180380f71071150", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -300,6 +300,9 @@ class svalue\n   virtual bool implicitly_live_p (const svalue_set &live_svalues,\n \t\t\t\t  const region_model *model) const;\n \n+  static int cmp_ptr (const svalue *, const svalue *);\n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n  protected:\n   svalue (complexity c, tree type)\n   : m_complexity (c), m_type (type)\n@@ -552,6 +555,8 @@ struct setjmp_record\n     hstate->add_ptr (m_setjmp_call);\n   }\n \n+  static int cmp (const setjmp_record &rec1, const setjmp_record &rec2);\n+\n   const exploded_node *m_enode;\n   const gcall *m_setjmp_call;\n };\n@@ -987,6 +992,8 @@ class placeholder_svalue : public svalue\n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n \n+  const char *get_name () const { return m_name; }\n+\n  private:\n   const char *m_name;\n };\n@@ -1078,6 +1085,7 @@ class widening_svalue : public svalue\n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n \n+  const function_point &get_point () const { return m_point; }\n   const svalue *get_base_svalue () const { return m_base_sval; }\n   const svalue *get_iter_svalue () const { return m_iter_sval; }\n \n@@ -1172,6 +1180,8 @@ class compound_svalue : public svalue\n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n \n+  const binding_map &get_map () const { return m_map; }\n+\n   iterator_t begin () const { return m_map.begin (); }\n   iterator_t end () const { return m_map.end (); }\n \n@@ -1280,6 +1290,9 @@ class conjured_svalue : public svalue\n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n \n+  const gimple *get_stmt () const { return m_stmt; }\n+  const region *get_id_region () const { return m_id_reg; }\n+\n  private:\n   const gimple *m_stmt;\n   const region *m_id_reg;\n@@ -1418,7 +1431,7 @@ class region\n \n   bool non_null_p () const;\n \n-  static int cmp_ptrs (const void *, const void *);\n+  static int cmp_ptr_ptr (const void *, const void *);\n \n   region_offset get_offset () const;\n   bool get_byte_size (byte_size_t *out) const;"}, {"sha": "3a88a5fbc67de0c0ac7ef1bf32f3e70f65788a50", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -517,10 +517,11 @@ region::region (complexity c, unsigned id, const region *parent, tree type)\n   gcc_assert (type == NULL_TREE || TYPE_P (type));\n }\n \n-/* Comparator for regions, using their IDs to order them.  */\n+/* Comparator for use by vec<const region *>::qsort,\n+   using their IDs to order them.  */\n \n int\n-region::cmp_ptrs (const void *p1, const void *p2)\n+region::cmp_ptr_ptr (const void *p1, const void *p2)\n {\n   const region * const *reg1 = (const region * const *)p1;\n   const region * const *reg2 = (const region * const *)p2;"}, {"sha": "418d80c608b188cce33276a36f707ec8b232161f", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -209,13 +209,21 @@ state_purge_per_ssa_name::state_purge_per_ssa_name (const state_purge_map &map,\n   if (map.get_logger ())\n     {\n       map.log (\"%qE in %qD is needed to process:\", name, fun->decl);\n+      /* Log m_points_needing_name, sorting it to avoid churn when comparing\n+\t dumps.  */\n+      auto_vec<function_point> points;\n       for (point_set_t::iterator iter = m_points_needing_name.begin ();\n \t   iter != m_points_needing_name.end ();\n \t   ++iter)\n+\tpoints.safe_push (*iter);\n+      points.qsort (function_point::cmp_ptr);\n+      unsigned i;\n+      function_point *point;\n+      FOR_EACH_VEC_ELT (points, i, point)\n \t{\n \t  map.start_log_line ();\n \t  map.get_logger ()->log_partial (\"  point: \");\n-\t  (*iter).print (map.get_logger ()->get_printer (), format (false));\n+\t  point->print (map.get_logger ()->get_printer (), format (false));\n \t  map.end_log_line ();\n \t}\n     }"}, {"sha": "05dd47d94a13f0b161f1602627af860ce4838357", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -208,6 +208,23 @@ concrete_binding::overlaps_p (const concrete_binding &other) const\n   return false;\n }\n \n+/* Comparator for use by vec<const concrete_binding *>::qsort.  */\n+\n+int\n+concrete_binding::cmp_ptr_ptr (const void *p1, const void *p2)\n+{\n+  const concrete_binding *b1 = *(const concrete_binding * const *)p1;\n+  const concrete_binding *b2 = *(const concrete_binding * const *)p2;\n+\n+  if (int kind_cmp = b1->get_kind () - b2->get_kind ())\n+    return kind_cmp;\n+\n+  if (int start_cmp = wi::cmps (b1->m_start_bit_offset, b2->m_start_bit_offset))\n+    return start_cmp;\n+\n+  return wi::cmpu (b1->m_size_in_bits, b2->m_size_in_bits);\n+}\n+\n /* class symbolic_binding : public binding_key.  */\n \n void\n@@ -218,6 +235,20 @@ symbolic_binding::dump_to_pp (pretty_printer *pp, bool simple) const\n   m_region->dump_to_pp (pp, simple);\n }\n \n+/* Comparator for use by vec<const symbolic_binding *>::qsort.  */\n+\n+int\n+symbolic_binding::cmp_ptr_ptr (const void *p1, const void *p2)\n+{\n+  const symbolic_binding *b1 = *(const symbolic_binding * const *)p1;\n+  const symbolic_binding *b2 = *(const symbolic_binding * const *)p2;\n+\n+  if (int kind_cmp = b1->get_kind () - b2->get_kind ())\n+    return kind_cmp;\n+\n+  return region::cmp_ids (b1->get_region (), b2->get_region ());\n+}\n+\n /* The store is oblivious to the types of the svalues bound within\n    it: any type can get bound at any location.\n    Simplify any casts before binding.\n@@ -409,6 +440,40 @@ binding_map::to_json () const\n   return map_obj;\n }\n \n+/* Comparator for imposing an order on binding_maps.  */\n+\n+int\n+binding_map::cmp (const binding_map &map1, const binding_map &map2)\n+{\n+  if (int count_cmp = map1.elements () - map2.elements ())\n+    return count_cmp;\n+\n+  auto_vec <const binding_key *> keys1 (map1.elements ());\n+  for (map_t::iterator iter = map1.begin ();\n+       iter != map1.end (); ++iter)\n+    keys1.quick_push ((*iter).first);\n+  keys1.qsort (binding_key::cmp_ptrs);\n+\n+  auto_vec <const binding_key *> keys2 (map2.elements ());\n+  for (map_t::iterator iter = map2.begin ();\n+       iter != map2.end (); ++iter)\n+    keys2.quick_push ((*iter).first);\n+  keys2.qsort (binding_key::cmp_ptrs);\n+\n+  for (size_t i = 0; i < keys1.length (); i++)\n+    {\n+      const binding_key *k1 = keys1[i];\n+      const binding_key *k2 = keys2[i];\n+      if (int key_cmp = binding_key::cmp (k1, k2))\n+\treturn key_cmp;\n+      gcc_assert (k1 == k2);\n+      if (int sval_cmp = svalue::cmp_ptr (map1.get (k1), map2.get (k2)))\n+\treturn sval_cmp;\n+    }\n+\n+  return 0;\n+}\n+\n /* Get the child region of PARENT_REG based upon INDEX within a\n    CONSTRUCTOR.   */\n \n@@ -1512,7 +1577,7 @@ get_sorted_parent_regions (auto_vec<const region *> *out,\n     out->safe_push (*iter);\n \n   /* Sort OUT.  */\n-  out->qsort (region::cmp_ptrs);\n+  out->qsort (region::cmp_ptr_ptr);\n }\n \n /* Dump a representation of this store to PP, using SIMPLE to control how\n@@ -1532,7 +1597,7 @@ store::dump_to_pp (pretty_printer *pp, bool simple, bool multiline,\n       const region *base_reg = (*iter).first;\n       base_regions.safe_push (base_reg);\n     }\n-  base_regions.qsort (region::cmp_ptrs);\n+  base_regions.qsort (region::cmp_ptr_ptr);\n \n   /* Gather clusters, organize by parent region, so that we can group\n      together locals, globals, etc.  */\n@@ -1653,7 +1718,7 @@ store::to_json () const\n       const region *base_reg = (*iter).first;\n       base_regions.safe_push (base_reg);\n     }\n-  base_regions.qsort (region::cmp_ptrs);\n+  base_regions.qsort (region::cmp_ptr_ptr);\n \n   /* Gather clusters, organize by parent region, so that we can group\n      together locals, globals, etc.  */\n@@ -1991,10 +2056,19 @@ store::can_merge_p (const store *store_a, const store *store_b,\n       base_regions.add (base_reg_b);\n     }\n \n+  /* Sort the base regions before considering them.  This ought not to\n+     affect the results, but can affect which types UNKNOWN_REGIONs are\n+     created for in a run; sorting them thus avoids minor differences\n+     in logfiles.  */\n+  auto_vec<const region *> vec_base_regions (base_regions.elements ());\n   for (hash_set<const region *>::iterator iter = base_regions.begin ();\n        iter != base_regions.end (); ++iter)\n+    vec_base_regions.quick_push (*iter);\n+  vec_base_regions.qsort (region::cmp_ptr_ptr);\n+  unsigned i;\n+  const region *base_reg;\n+  FOR_EACH_VEC_ELT (vec_base_regions, i, base_reg)\n     {\n-      const region *base_reg = *iter;\n       const binding_cluster *cluster_a = store_a->get_cluster (base_reg);\n       const binding_cluster *cluster_b = store_b->get_cluster (base_reg);\n       /* At least one of cluster_a and cluster_b must be non-NULL.  */"}, {"sha": "466c1830c0f361a89635801494f031841b3476b6", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -237,6 +237,8 @@ class concrete_binding : public binding_key\n \n   bool overlaps_p (const concrete_binding &other) const;\n \n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n private:\n   bit_offset_t m_start_bit_offset;\n   bit_size_t m_size_in_bits;\n@@ -282,6 +284,8 @@ class symbolic_binding : public binding_key\n \n   const region *get_region () const { return m_region; }\n \n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n private:\n   const region *m_region;\n };\n@@ -346,6 +350,8 @@ class binding_map\n   bool apply_ctor_to_region (const region *parent_reg, tree ctor,\n \t\t\t     region_model_manager *mgr);\n \n+  static int cmp (const binding_map &map1, const binding_map &map2);\n+\n private:\n   bool apply_ctor_val_to_range (const region *parent_reg,\n \t\t\t\tregion_model_manager *mgr,"}, {"sha": "37f143c6fca007aa4ba604837531f55619a908ec", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -90,16 +90,19 @@ supergraph_call_edge (function *fun, gimple *stmt)\n /* supergraph's ctor.  Walk the callgraph, building supernodes for each\n    CFG basic block, splitting the basic blocks at callsites.  Join\n    together the supernodes with interprocedural and intraprocedural\n-   superedges as appropriate.  */\n+   superedges as appropriate.\n+   Assign UIDs to the gimple stmts.  */\n \n supergraph::supergraph (logger *logger)\n {\n   auto_timevar tv (TV_ANALYZER_SUPERGRAPH);\n \n   LOG_FUNC (logger);\n \n-  /* First pass: make supernodes.  */\n+  /* First pass: make supernodes (and assign UIDs to the gimple stmts).  */\n   {\n+    unsigned next_uid = 0;\n+\n     /* Sort the cgraph_nodes?  */\n     cgraph_node *node;\n     FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n@@ -124,6 +127,7 @@ supergraph::supergraph (logger *logger)\n \t    {\n \t      gimple *stmt = gsi_stmt (gpi);\n \t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n+\t      stmt->uid = next_uid++;\n \t    }\n \n \t  /* Append statements from BB to the current supernode, splitting\n@@ -135,6 +139,7 @@ supergraph::supergraph (logger *logger)\n \t      gimple *stmt = gsi_stmt (gsi);\n \t      node_for_stmts->m_stmts.safe_push (stmt);\n \t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n+\t      stmt->uid = next_uid++;\n \t      if (cgraph_edge *edge = supergraph_call_edge (fun, stmt))\n \t\t{\n \t\t  m_cgraph_edge_to_caller_prev_node.put(edge, node_for_stmts);"}, {"sha": "8eece134e109c98e140711c8634c13484bd967d4", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0702ac5588333e27d7ec43d21d704521f7a05c6/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=b0702ac5588333e27d7ec43d21d704521f7a05c6", "patch": "@@ -298,6 +298,211 @@ svalue::implicitly_live_p (const svalue_set &, const region_model *) const\n   return false;\n }\n \n+/* Comparator for imposing a deterministic order on constants that are\n+   of the same type.  */\n+\n+static int\n+cmp_cst (const_tree cst1, const_tree cst2)\n+{\n+  gcc_assert (TREE_TYPE (cst1) == TREE_TYPE (cst2));\n+  gcc_assert (TREE_CODE (cst1) == TREE_CODE (cst2));\n+  switch (TREE_CODE (cst1))\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case INTEGER_CST:\n+      return tree_int_cst_compare (cst1, cst2);\n+    case STRING_CST:\n+      return strcmp (TREE_STRING_POINTER (cst1),\n+\t\t     TREE_STRING_POINTER (cst2));\n+    case REAL_CST:\n+      /* Impose an arbitrary but deterministic order.  */\n+      return memcmp (TREE_REAL_CST_PTR (cst1),\n+\t\t     TREE_REAL_CST_PTR (cst2),\n+\t\t     sizeof (real_value));\n+    case VECTOR_CST:\n+      if (int cmp_log2_npatterns\n+\t    = ((int)VECTOR_CST_LOG2_NPATTERNS (cst1)\n+\t       - (int)VECTOR_CST_LOG2_NPATTERNS (cst2)))\n+\treturn cmp_log2_npatterns;\n+      if (int cmp_nelts_per_pattern\n+\t    = ((int)VECTOR_CST_NELTS_PER_PATTERN (cst1)\n+\t       - (int)VECTOR_CST_NELTS_PER_PATTERN (cst2)))\n+\treturn cmp_nelts_per_pattern;\n+      unsigned encoded_nelts = vector_cst_encoded_nelts (cst1);\n+      for (unsigned i = 0; i < encoded_nelts; i++)\n+\tif (int el_cmp = cmp_cst (VECTOR_CST_ENCODED_ELT (cst1, i),\n+\t\t\t\t  VECTOR_CST_ENCODED_ELT (cst2, i)))\n+\t  return el_cmp;\n+      return 0;\n+    }\n+}\n+\n+/* Comparator for imposing a deterministic order on svalues.  */\n+\n+int\n+svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)\n+{\n+  if (sval1 == sval2)\n+    return 0;\n+  if (int cmp_kind = sval1->get_kind () - sval2->get_kind ())\n+    return cmp_kind;\n+  int t1 = sval1->get_type () ? TYPE_UID (sval1->get_type ()) : -1;\n+  int t2 = sval2->get_type () ? TYPE_UID (sval2->get_type ()) : -1;\n+  if (int cmp_type = t1 - t2)\n+    return cmp_type;\n+  switch (sval1->get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case SK_REGION:\n+      {\n+\tconst region_svalue *region_sval1 = (const region_svalue *)sval1;\n+\tconst region_svalue *region_sval2 = (const region_svalue *)sval2;\n+\treturn region::cmp_ids (region_sval1->get_pointee (),\n+\t\t\t\tregion_sval2->get_pointee ());\n+      }\n+      break;\n+    case SK_CONSTANT:\n+      {\n+\tconst constant_svalue *constant_sval1 = (const constant_svalue *)sval1;\n+\tconst constant_svalue *constant_sval2 = (const constant_svalue *)sval2;\n+\tconst_tree cst1 = constant_sval1->get_constant ();\n+\tconst_tree cst2 = constant_sval2->get_constant ();\n+\treturn cmp_cst (cst1, cst2);\n+      }\n+      break;\n+    case SK_UNKNOWN:\n+      {\n+\tgcc_assert (sval1 == sval2);\n+\treturn 0;\n+      }\n+      break;\n+    case SK_POISONED:\n+      {\n+\tconst poisoned_svalue *poisoned_sval1 = (const poisoned_svalue *)sval1;\n+\tconst poisoned_svalue *poisoned_sval2 = (const poisoned_svalue *)sval2;\n+\treturn (poisoned_sval1->get_poison_kind ()\n+\t\t- poisoned_sval2->get_poison_kind ());\n+      }\n+      break;\n+    case SK_SETJMP:\n+      {\n+\tconst setjmp_svalue *setjmp_sval1 = (const setjmp_svalue *)sval1;\n+\tconst setjmp_svalue *setjmp_sval2 = (const setjmp_svalue *)sval2;\n+\tconst setjmp_record &rec1 = setjmp_sval1->get_setjmp_record ();\n+\tconst setjmp_record &rec2 = setjmp_sval2->get_setjmp_record ();\n+\treturn setjmp_record::cmp (rec1, rec2);\n+      }\n+      break;\n+    case SK_INITIAL:\n+      {\n+\tconst initial_svalue *initial_sval1 = (const initial_svalue *)sval1;\n+\tconst initial_svalue *initial_sval2 = (const initial_svalue *)sval2;\n+\treturn region::cmp_ids (initial_sval1->get_region (),\n+\t\t\t\tinitial_sval2->get_region ());\n+      }\n+      break;\n+    case SK_UNARYOP:\n+      {\n+\tconst unaryop_svalue *unaryop_sval1 = (const unaryop_svalue *)sval1;\n+\tconst unaryop_svalue *unaryop_sval2 = (const unaryop_svalue *)sval2;\n+\tif (int op_cmp = unaryop_sval1->get_op () - unaryop_sval2->get_op ())\n+\t  return op_cmp;\n+\treturn svalue::cmp_ptr (unaryop_sval1->get_arg (),\n+\t\t\t\tunaryop_sval2->get_arg ());\n+      }\n+      break;\n+    case SK_BINOP:\n+      {\n+\tconst binop_svalue *binop_sval1 = (const binop_svalue *)sval1;\n+\tconst binop_svalue *binop_sval2 = (const binop_svalue *)sval2;\n+\tif (int op_cmp = binop_sval1->get_op () - binop_sval2->get_op ())\n+\t  return op_cmp;\n+\tif (int arg0_cmp = svalue::cmp_ptr (binop_sval1->get_arg0 (),\n+\t\t\t\t\t    binop_sval2->get_arg0 ()))\n+\t  return arg0_cmp;\n+\treturn svalue::cmp_ptr (binop_sval1->get_arg1 (),\n+\t\t\t\tbinop_sval2->get_arg1 ());\n+      }\n+      break;\n+    case SK_SUB:\n+      {\n+\tconst sub_svalue *sub_sval1 = (const sub_svalue *)sval1;\n+\tconst sub_svalue *sub_sval2 = (const sub_svalue *)sval2;\n+\tif (int parent_cmp = svalue::cmp_ptr (sub_sval1->get_parent (),\n+\t\t\t\t\t      sub_sval2->get_parent ()))\n+\t  return parent_cmp;\n+\treturn region::cmp_ids (sub_sval1->get_subregion (),\n+\t\t\t\tsub_sval2->get_subregion ());\n+      }\n+      break;\n+    case SK_UNMERGEABLE:\n+      {\n+\tconst unmergeable_svalue *unmergeable_sval1\n+\t  = (const unmergeable_svalue *)sval1;\n+\tconst unmergeable_svalue *unmergeable_sval2\n+\t  = (const unmergeable_svalue *)sval2;\n+\treturn svalue::cmp_ptr (unmergeable_sval1->get_arg (),\n+\t\t\t\tunmergeable_sval2->get_arg ());\n+      }\n+      break;\n+    case SK_PLACEHOLDER:\n+      {\n+\tconst placeholder_svalue *placeholder_sval1\n+\t  = (const placeholder_svalue *)sval1;\n+\tconst placeholder_svalue *placeholder_sval2\n+\t  = (const placeholder_svalue *)sval2;\n+\treturn strcmp (placeholder_sval1->get_name (),\n+\t\t       placeholder_sval2->get_name ());\n+      }\n+      break;\n+    case SK_WIDENING:\n+      {\n+\tconst widening_svalue *widening_sval1 = (const widening_svalue *)sval1;\n+\tconst widening_svalue *widening_sval2 = (const widening_svalue *)sval2;\n+\tif (int point_cmp = function_point::cmp (widening_sval1->get_point (),\n+\t\t\t\t\t\t widening_sval2->get_point ()))\n+\t  return point_cmp;\n+\tif (int base_cmp = svalue::cmp_ptr (widening_sval1->get_base_svalue (),\n+\t\t\t\t\t    widening_sval2->get_base_svalue ()))\n+\t  return base_cmp;\n+\treturn svalue::cmp_ptr (widening_sval1->get_iter_svalue (),\n+\t\t\t\twidening_sval2->get_iter_svalue ());\n+      }\n+      break;\n+    case SK_COMPOUND:\n+      {\n+\tconst compound_svalue *compound_sval1 = (const compound_svalue *)sval1;\n+\tconst compound_svalue *compound_sval2 = (const compound_svalue *)sval2;\n+\treturn binding_map::cmp (compound_sval1->get_map (),\n+\t\t\t\t compound_sval2->get_map ());\n+      }\n+      break;\n+    case SK_CONJURED:\n+      {\n+\tconst conjured_svalue *conjured_sval1 = (const conjured_svalue *)sval1;\n+\tconst conjured_svalue *conjured_sval2 = (const conjured_svalue *)sval2;\n+\tif (int stmt_cmp = (conjured_sval1->get_stmt ()->uid\n+\t\t\t    - conjured_sval2->get_stmt ()->uid))\n+\t  return stmt_cmp;\n+\treturn region::cmp_ids (conjured_sval1->get_id_region (),\n+\t\t\t\tconjured_sval2->get_id_region ());\n+      }\n+      break;\n+    }\n+}\n+\n+/* Comparator for use by vec<const svalue *>::qsort.  */\n+\n+int\n+svalue::cmp_ptr_ptr (const void *p1, const void *p2)\n+{\n+  const svalue *sval1 = *(const svalue * const *)p1;\n+  const svalue *sval2 = *(const svalue * const *)p2;\n+  return cmp_ptr (sval1, sval2);\n+}\n+\n /* class region_svalue : public svalue.  */\n \n /* Implementation of svalue::dump_to_pp vfunc for region_svalue.  */"}]}