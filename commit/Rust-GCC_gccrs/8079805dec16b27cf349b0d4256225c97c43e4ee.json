{"sha": "8079805dec16b27cf349b0d4256225c97c43e4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3OTgwNWRlYzE2YjI3Y2YzNDliMGQ0MjU2MjI1Yzk3YzQzZTRlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-06T19:39:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-06T19:39:37Z"}, "message": "(subst): Split into five functions.\n\n(simplify_{rtx,if_then_else,set,logical}): New functions.\n\nFrom-SVN: r6703", "tree": {"sha": "7c241fe85a7ca61b2e8fc1f8965407fe69dab02b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c241fe85a7ca61b2e8fc1f8965407fe69dab02b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8079805dec16b27cf349b0d4256225c97c43e4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8079805dec16b27cf349b0d4256225c97c43e4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8079805dec16b27cf349b0d4256225c97c43e4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8079805dec16b27cf349b0d4256225c97c43e4ee/comments", "author": null, "committer": null, "parents": [{"sha": "02fa12846661826bff9031fcf0e0b3fe8d58be2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fa12846661826bff9031fcf0e0b3fe8d58be2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fa12846661826bff9031fcf0e0b3fe8d58be2b"}], "stats": {"total": 1725, "additions": 817, "deletions": 908}, "files": [{"sha": "166b8b04d372ba7fa0d3939d9e2d0ade915b3543", "filename": "gcc/combine.c", "status": "modified", "additions": 817, "deletions": 908, "changes": 1725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8079805dec16b27cf349b0d4256225c97c43e4ee/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8079805dec16b27cf349b0d4256225c97c43e4ee/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8079805dec16b27cf349b0d4256225c97c43e4ee", "patch": "@@ -386,6 +386,10 @@ static rtx try_combine\t\tPROTO((rtx, rtx, rtx));\n static void undo_all\t\tPROTO((void));\n static rtx *find_split_point\tPROTO((rtx *, rtx));\n static rtx subst\t\tPROTO((rtx, rtx, rtx, int, int));\n+static rtx simplify_rtx\t\tPROTO((rtx, enum machine_mode, int, int));\n+static rtx simplify_if_then_else  PROTO((rtx));\n+static rtx simplify_set\t\tPROTO((rtx));\n+static rtx simplify_logical\tPROTO((rtx, int));\n static rtx expand_compound_operation  PROTO((rtx));\n static rtx expand_field_assignment  PROTO((rtx));\n static rtx make_extraction\tPROTO((enum machine_mode, rtx, int, rtx, int,\n@@ -2725,28 +2729,11 @@ subst (x, from, to, in_dest, unique_copy)\n      int in_dest;\n      int unique_copy;\n {\n-  register char *fmt;\n-  register int len, i;\n   register enum rtx_code code = GET_CODE (x), orig_code = code;\n-  rtx temp;\n-  enum machine_mode mode = GET_MODE (x);\n   enum machine_mode op0_mode = VOIDmode;\n-  rtx other_insn;\n-  rtx *cc_use;\n-  int n_restarts = 0;\n-\n-/* FAKE_EXTEND_SAFE_P (MODE, FROM) is 1 if (subreg:MODE FROM 0) is a safe\n-   replacement for (zero_extend:MODE FROM) or (sign_extend:MODE FROM).\n-   If it is 0, that cannot be done.  We can now do this for any MEM\n-   because (SUBREG (MEM...)) is guaranteed to cause the MEM to be reloaded.\n-   If not for that, MEM's would very rarely be safe.  */\n-\n-/* Reject MODEs bigger than a word, because we might not be able\n-   to reference a two-register group starting with an arbitrary register\n-   (and currently gen_lowpart might crash for a SUBREG).  */\n-\n-#define FAKE_EXTEND_SAFE_P(MODE, FROM) \\\n-  (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\n+  register char *fmt;\n+  register int len, i;\n+  rtx new;\n \n /* Two expressions are equal if they are identical copies of a shared\n    RTX or if they are both registers with the same register number\n@@ -2812,7 +2799,6 @@ subst (x, from, to, in_dest, unique_copy)\n \t  register int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      register rtx new;\n \t      if (COMBINE_RTX_EQUAL_P (XVECEXP (x, i, j), from))\n \t\t{\n \t\t  new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n@@ -2832,8 +2818,6 @@ subst (x, from, to, in_dest, unique_copy)\n \t}\n       else if (fmt[i] == 'e')\n \t{\n-\t  register rtx new;\n-\n \t  if (COMBINE_RTX_EQUAL_P (XEXP (x, i), from))\n \t    {\n \t      /* In general, don't install a subreg involving two modes not\n@@ -2850,7 +2834,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t  && ! MODES_TIEABLE_P (GET_MODE (to),\n \t\t\t\t\tGET_MODE (SUBREG_REG (to)))\n \t\t  && ! (code == SUBREG\n-\t\t\t&& MODES_TIEABLE_P (mode, GET_MODE (SUBREG_REG (to))))\n+\t\t\t&& MODES_TIEABLE_P (GET_MODE (x),\n+\t\t\t\t\t    GET_MODE (SUBREG_REG (to))))\n #ifdef HAVE_cc0\n \t\t  && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n #endif\n@@ -2889,25 +2874,49 @@ subst (x, from, to, in_dest, unique_copy)\n \t}\n     }\n \n-  /* We come back to here if we have replaced the expression with one of\n-     a different code and it is likely that further simplification will be\n-     possible.  */\n+  /* Try to simplify X.  If the simplification changed the code, it is likely\n+     that further simplification will help, so loop, but limit the number\n+     of repetitions that will be performed.  */\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      /* If X is sufficiently simple, don't bother trying to do anything\n+\t with it.  */\n+      if (code != CONST_INT && code != REG && code != CLOBBER)\n+\tx = simplify_rtx (x, op0_mode, i == 3, in_dest);\n \n- restart:\n+      if (GET_CODE (x) == code)\n+\tbreak;\n \n-  /* If we have restarted more than 4 times, we are probably looping, so\n-     give up.  */\n-  if (++n_restarts > 4)\n-    return x;\n+      code = GET_CODE (x);\n \n-  /* If we are restarting at all, it means that we no longer know the\n-     original mode of operand 0 (since we have probably changed the\n-     form of X).  */\n+      /* We no longer know the original mode of operand 0 since we\n+\t have changed the form of X)  */\n+      op0_mode = VOIDmode;\n+    }\n \n-  if (n_restarts > 1)\n-    op0_mode = VOIDmode;\n+  return x;\n+}\n+\f\n+/* Simplify X, a piece of RTL.  We just operate on the expression at the\n+   outer level; call `subst' to simplify recursively.  Return the new\n+   expression.\n \n-  code = GET_CODE (x);\n+   OP0_MODE is the original mode of XEXP (x, 0); LAST is nonzero if this\n+   will be the iteration even if an expression with a code different from\n+   X is returned; IN_DEST is nonzero if we are inside a SET_DEST.  */\n+\n+static rtx\n+simplify_rtx (x, op0_mode, last, in_dest)\n+     rtx x;\n+     enum machine_mode op0_mode;\n+     int last;\n+     int in_dest;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx temp;\n+  int i;\n \n   /* If this is a commutative operation, put a constant last and a complex\n      expression first.  We don't need to do this for comparisons here.  */\n@@ -3025,12 +3034,9 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t   gen_binary (reverse_condition (cond_code), \n \t\t\t\t       mode, cond, cop1));\n \t  else\n-\t    {\n-\t      x = gen_rtx (IF_THEN_ELSE, mode,\n-\t\t\t   gen_binary (cond_code, VOIDmode, cond, cop1),\n-\t\t\t   true, false);\n-\t      goto restart;\n-\t    }\n+\t    return gen_rtx (IF_THEN_ELSE, mode,\n+\t\t\t    gen_binary (cond_code, VOIDmode, cond, cop1),\n+\t\t\t    true, false);\n \n \t  code = GET_CODE (x);\n \t  op0_mode = VOIDmode;\n@@ -3117,11 +3123,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t    }\n \n \t  if (inner)\n-\t    {\n-\t      x = gen_binary (code, mode, other, inner);\n-\t      goto restart;\n-\t    \n-\t    }\n+\t    return gen_binary (code, mode, other, inner);\n \t}\n     }\n \n@@ -3261,17 +3263,12 @@ subst (x, from, to, in_dest, unique_copy)\n       /* (not (plus X -1)) can become (neg X).  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && XEXP (XEXP (x, 0), 1) == constm1_rtx)\n-\t{\n-\t  x = gen_rtx_combine (NEG, mode, XEXP (XEXP (x, 0), 0));\n-\t  goto restart;\n-\t}\n+\treturn gen_rtx_combine (NEG, mode, XEXP (XEXP (x, 0), 0));\n \n       /* Similarly, (not (neg X)) is (plus X -1).  */\n       if (GET_CODE (XEXP (x, 0)) == NEG)\n-\t{\n-\t  x = gen_rtx_combine (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n-\t  goto restart;\n-\t}\n+\treturn gen_rtx_combine (PLUS, mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\tconstm1_rtx);\n \n       /* (not (xor X C)) for C constant is (xor X D) with D = ~ C.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR\n@@ -3290,11 +3287,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t but this doesn't seem common enough to bother with.  */\n       if (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && XEXP (XEXP (x, 0), 0) == const1_rtx)\n-\t{\n-\t  x = gen_rtx (ROTATE, mode, gen_unary (NOT, mode, const1_rtx),\n-\t\t       XEXP (XEXP (x, 0), 1));\n-\t  goto restart;\n-\t}\n+\treturn gen_rtx (ROTATE, mode, gen_unary (NOT, mode, const1_rtx),\n+\t\t\tXEXP (XEXP (x, 0), 1));\n \t\t\t\t\t    \n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t  && subreg_lowpart_p (XEXP (x, 0))\n@@ -3308,8 +3302,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  x = gen_rtx (ROTATE, inner_mode,\n \t\t       gen_unary (NOT, inner_mode, const1_rtx),\n \t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n-\t  x = gen_lowpart_for_combine (mode, x);\n-\t  goto restart;\n+\t  return gen_lowpart_for_combine (mode, x);\n \t}\n \t\t\t\t\t    \n #if STORE_FLAG_VALUE == -1\n@@ -3360,47 +3353,34 @@ subst (x, from, to, in_dest, unique_copy)\n \t     in2 = in1; in1 = tem;\n \t   }\n \n-\t x = gen_rtx_combine (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n-\t\t\t      mode, in1, in2);\n-\t goto restart;\n+\t return gen_rtx_combine (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n+\t\t\t\t mode, in1, in2);\n        } \n       break;\n \n     case NEG:\n       /* (neg (plus X 1)) can become (not X).  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx)\n-\t{\n-\t  x = gen_rtx_combine (NOT, mode, XEXP (XEXP (x, 0), 0));\n-\t  goto restart;\n-\t}\n+\treturn gen_rtx_combine (NOT, mode, XEXP (XEXP (x, 0), 0));\n \n       /* Similarly, (neg (not X)) is (plus X 1).  */\n       if (GET_CODE (XEXP (x, 0)) == NOT)\n- \t{\n-\t  x = plus_constant (XEXP (XEXP (x, 0), 0), 1);\n-\t  goto restart;\n- \t}\n+\treturn plus_constant (XEXP (XEXP (x, 0), 0), 1);\n \n       /* (neg (minus X Y)) can become (minus Y X).  */\n       if (GET_CODE (XEXP (x, 0)) == MINUS\n \t  && (! FLOAT_MODE_P (mode)\n \t      /* x-y != -(y-x) with IEEE floating point. */\n \t      || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t      || flag_fast_math))\n-\t{\n-\t  x = gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n-\t\t\t  XEXP (XEXP (x, 0), 0));\n-\t  goto restart;\n-\t}\n+\treturn gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n+\t\t\t   XEXP (XEXP (x, 0), 0));\n \n       /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1. */\n       if (GET_CODE (XEXP (x, 0)) == XOR && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n-\t{\n-\t  x = gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n-\t  goto restart;\n-\t}\n+\treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n \n       /* NEG commutes with ASHIFT since it is multiplication.  Only do this\n \t if we can then eliminate the NEG (e.g.,\n@@ -3426,11 +3406,8 @@ subst (x, from, to, in_dest, unique_copy)\n       if (GET_CODE (temp) == ASHIFTRT\n \t  && GET_CODE (XEXP (temp, 1)) == CONST_INT\n \t  && INTVAL (XEXP (temp, 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\t{\n-\t  x = simplify_shift_const (temp, LSHIFTRT, mode, XEXP (temp, 0),\n-\t\t\t\t    INTVAL (XEXP (temp, 1)));\n-\t  goto restart;\n-\t}\n+\treturn simplify_shift_const (temp, LSHIFTRT, mode, XEXP (temp, 0),\n+\t\t\t\t     INTVAL (XEXP (temp, 1)));\n \n       /* If X has only a single bit that might be nonzero, say, bit I, convert\n \t (neg X) to (ashiftrt (ashift X C-I) C-I) where C is the bitsize of\n@@ -3456,10 +3433,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  if (GET_CODE (temp1) != ASHIFTRT\n \t      || GET_CODE (XEXP (temp1, 0)) != ASHIFT\n \t      || XEXP (XEXP (temp1, 0), 0) != temp)\n-\t    {\n-\t      x = temp1;\n-\t      goto restart;\n-\t    }\n+\t    return temp1;\n \t}\n       break;\n \n@@ -3535,15 +3509,12 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n \t\t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n \t\t      == i + 1))))\n-\t{\n-\t  x = simplify_shift_const\n-\t    (NULL_RTX, ASHIFTRT, mode,\n-\t     simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t\t   XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t\t   GET_MODE_BITSIZE (mode) - (i + 1)),\n-\t     GET_MODE_BITSIZE (mode) - (i + 1));\n-\t  goto restart;\n-\t}\n+\treturn simplify_shift_const\n+\t  (NULL_RTX, ASHIFTRT, mode,\n+\t   simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t\t\t\t XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t GET_MODE_BITSIZE (mode) - (i + 1)),\n+\t   GET_MODE_BITSIZE (mode) - (i + 1));\n \n       /* (plus (comparison A B) C) can become (neg (rev-comp A B)) if\n \t C is 1 and STORE_FLAG_VALUE is -1 or if C is -1 and STORE_FLAG_VALUE\n@@ -3553,12 +3524,11 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && reversible_comparison_p (XEXP (x, 0))\n \t  && ((STORE_FLAG_VALUE == -1 && XEXP (x, 1) == const1_rtx)\n \t      || (STORE_FLAG_VALUE == 1 && XEXP (x, 1) == constm1_rtx)))\n-\t{\n-\t  x = gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t  mode, XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 0), 1));\n-\t  x = gen_unary (NEG, mode, x);\n-\t  goto restart;\n-\t}\n+\treturn\n+\t  gen_unary (NEG, mode,\n+\t\t     gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n+\t\t\t\t mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t XEXP (XEXP (x, 0), 1)));\n \n       /* If only the low-order bit of X is possibly nonzero, (plus x -1)\n \t can become (ashiftrt (ashift (xor x 1) C) C) where C is\n@@ -3569,16 +3539,12 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && ! (GET_CODE (XEXP (x,0)) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG)\n \t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n-\t{\n-\t  x = simplify_shift_const\n-\t    (NULL_RTX, ASHIFTRT, mode,\n-\t     simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t\t   gen_rtx_combine (XOR, mode,\n-\t\t\t\t\t\t    XEXP (x, 0), const1_rtx),\n-\t\t\t\t   GET_MODE_BITSIZE (mode) - 1),\n-\t     GET_MODE_BITSIZE (mode) - 1);\n-\t  goto restart;\n-\t}\n+\treturn simplify_shift_const (NULL_RTX, ASHIFTRT, mode,\n+\t   simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t\t\t\t gen_rtx_combine (XOR, mode,\n+\t\t\t\t\t\t  XEXP (x, 0), const1_rtx),\n+\t\t\t\t GET_MODE_BITSIZE (mode) - 1),\n+\t   GET_MODE_BITSIZE (mode) - 1);\n \n       /* If we are adding two things that have no bits in common, convert\n \t the addition into an IOR.  This will often be further simplified,\n@@ -3588,10 +3554,7 @@ subst (x, from, to, in_dest, unique_copy)\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (x, 0), mode)\n \t      & nonzero_bits (XEXP (x, 1), mode)) == 0)\n-\t{\n-\t  x = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n-\t  goto restart;\n-\t}\n+\treturn gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n       break;\n \n     case MINUS:\n@@ -3612,22 +3575,16 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n \t  && exact_log2 (- INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n-\t{\n-\t  x = simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n-\t\t\t\t      - INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n-\t  goto restart;\n-\t}\n+\treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n+\t\t\t\t       - INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n \n       /* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for\n \t integers.  */\n       if (GET_CODE (XEXP (x, 1)) == PLUS && INTEGRAL_MODE_P (mode))\n-\t{\n-\t  x = gen_binary (MINUS, mode,\n-\t\t\t  gen_binary (MINUS, mode, XEXP (x, 0),\n-\t\t\t\t      XEXP (XEXP (x, 1), 0)),\n-\t\t\t  XEXP (XEXP (x, 1), 1));\n-\t  goto restart;\n-\t}\n+\treturn gen_binary (MINUS, mode,\n+\t\t\t   gen_binary (MINUS, mode, XEXP (x, 0),\n+\t\t\t\t       XEXP (XEXP (x, 1), 0)),\n+\t\t\t   XEXP (XEXP (x, 1), 1));\n       break;\n \n     case MULT:\n@@ -3645,7 +3602,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t\t     XEXP (XEXP (x, 0), 1), XEXP (x, 1))));\n \n \t  if (GET_CODE (x) != MULT)\n-\t    goto restart;\n+\t    return x;\n \t}\n \n       /* If this is multiplication by a power of two and its first operand is\n@@ -3658,10 +3615,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || GET_CODE (XEXP (x, 0)) == ASHIFTRT\n \t      || GET_CODE (XEXP (x, 0)) == ROTATE\n \t      || GET_CODE (XEXP (x, 0)) == ROTATERT))\n-\t{\n-\t  x = simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (x, 0), i);\n-\t  goto restart;\n-\t}\n+\treturn simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (x, 0), i);\n \n       /* Convert (mult (ashift (const_int 1) A) B) to (ashift B A).  */\n       if (GET_CODE (XEXP (x, 0)) == ASHIFT\n@@ -3680,10 +3634,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || GET_CODE (XEXP (x, 0)) == ASHIFTRT\n \t      || GET_CODE (XEXP (x, 0)) == ROTATE\n \t      || GET_CODE (XEXP (x, 0)) == ROTATERT))\n-\t{\n-\t  x = simplify_shift_const (NULL_RTX, LSHIFTRT, mode, XEXP (x, 0), i);\n-\t  goto restart;\n-\t}\n+\treturn simplify_shift_const (NULL_RTX, LSHIFTRT, mode, XEXP (x, 0), i);\n       break;\n \n     case EQ:  case NE:\n@@ -3733,19 +3684,18 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = gen_unary (NEG, mode, gen_lowpart_for_combine (mode, op0));\n-\t      goto restart;\n+\t      return gen_unary (NEG, mode,\n+\t\t\t\tgen_lowpart_for_combine (mode, op0));\n \t    }\n \n \t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = gen_binary (XOR, mode,\n-\t\t\t      gen_lowpart_for_combine (mode, op0),\n-\t\t\t      const1_rtx);\n-\t      goto restart;\n+\t      return gen_binary (XOR, mode,\n+\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t const1_rtx);\n \t    }\n \n \t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n@@ -3754,8 +3704,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = plus_constant (gen_lowpart_for_combine (mode, op0), 1);\n-\t      goto restart;\n+\t      return plus_constant (gen_lowpart_for_combine (mode, op0), 1);\n \t    }\n #endif\n \n@@ -3774,8 +3723,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = gen_unary (NEG, mode, gen_lowpart_for_combine (mode, op0));\n-\t      goto restart;\n+\t      return gen_unary (NEG, mode,\n+\t\t\t\tgen_lowpart_for_combine (mode, op0));\n \t    }\n \n \t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n@@ -3784,8 +3733,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = gen_unary (NOT, mode, gen_lowpart_for_combine (mode, op0));\n-\t      goto restart;\n+\t      return gen_unary (NOT, mode,\n+\t\t\t\tgen_lowpart_for_combine (mode, op0));\n \t    }\n \n \t  /* If X is 0/1, (eq X 0) is X-1.  */\n@@ -3794,8 +3743,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = plus_constant (gen_lowpart_for_combine (mode, op0), -1);\n-\t      goto restart;\n+\t      return plus_constant (gen_lowpart_for_combine (mode, op0), -1);\n \t    }\n #endif\n \n@@ -3833,651 +3781,714 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \t  \n     case IF_THEN_ELSE:\n-      /* Simplify storing of the truth value. */\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && XEXP (x, 1) == const_true_rtx\n-\t  && XEXP (x, 2) == const0_rtx)\n-\treturn gen_binary (GET_CODE (XEXP (x, 0)), mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t   XEXP (XEXP (x, 0), 1));\n-      \n-      /* Also when the truth value has to be reversed. */\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0))\n-\t  && XEXP (x, 1) == const0_rtx\n-\t  && XEXP (x, 2) == const_true_rtx)\n-\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t   mode, XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 0), 1));\n+      return simplify_if_then_else (x);\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      /* If we are processing SET_DEST, we are done. */\n+      if (in_dest)\n+\treturn x;\n \n-      /* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register\n-\t used in it is being compared against certain values.  Get the\n-\t true and false comparisons and see if that says anything about the\n-\t value of each arm.  */\n+      return expand_compound_operation (x);\n \n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n-\t{\n-\t  HOST_WIDE_INT nzb;\n-\t  rtx from = XEXP (XEXP (x, 0), 0);\n-\t  enum rtx_code true_code = GET_CODE (XEXP (x, 0));\n-\t  enum rtx_code false_code = reverse_condition (true_code);\n-\t  rtx true_val = XEXP (XEXP (x, 0), 1);\n-\t  rtx false_val = true_val;\n-\t  rtx true_arm = XEXP (x, 1);\n-\t  rtx false_arm = XEXP (x, 2);\n-\t  int swapped = 0;\n-\n-\t  /* If FALSE_CODE is EQ, swap the codes and arms.  */\n-\n-\t  if (false_code == EQ)\n-\t    {\n-\t      swapped = 1, true_code = EQ, false_code = NE;\n-\t      true_arm = XEXP (x, 2), false_arm = XEXP (x, 1);\n-\t    }\n+    case SET:\n+      return simplify_set (x);\n \n-\t  /* If we are comparing against zero and the expression being tested\n-\t     has only a single bit that might be nonzero, that is its value\n-\t     when it is not equal to zero.  Similarly if it is known to be\n-\t     -1 or 0.  */\n-\n-\t  if (true_code == EQ && true_val == const0_rtx\n-\t      && exact_log2 (nzb = nonzero_bits (from, GET_MODE (from))) >= 0)\n-\t    false_code = EQ, false_val = GEN_INT (nzb);\n-\t  else if (true_code == EQ && true_val == const0_rtx\n-\t\t   && (num_sign_bit_copies (from, GET_MODE (from))\n-\t\t       == GET_MODE_BITSIZE (GET_MODE (from))))\n-\t    false_code = EQ, false_val = constm1_rtx;\n-\n-\t  /* Now simplify an arm if we know the value of the register\n-\t     in the branch and it is used in the arm.  Be carefull due to\n-\t     the potential of locally-shared RTL.  */\n-\n-\t  if (reg_mentioned_p (from, true_arm))\n-\t    true_arm = subst (known_cond (copy_rtx (true_arm), true_code,\n-\t\t\t\t\t  from, true_val),\n-\t\t\t      pc_rtx, pc_rtx, 0, 0);\n-\t  if (reg_mentioned_p (from, false_arm))\n-\t    false_arm = subst (known_cond (copy_rtx (false_arm), false_code,\n-\t\t\t\t\t   from, false_val),\n-\t\t\t       pc_rtx, pc_rtx, 0, 0);\n-\n-\t  SUBST (XEXP (x, 1), swapped ? false_arm : true_arm);\n-\t  SUBST (XEXP (x, 2), swapped ? true_arm : false_arm);\n-\t}\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      return simplify_logical (x, last);\n+\n+    case ABS:\n+      /* (abs (neg <foo>)) -> (abs <foo>) */\n+      if (GET_CODE (XEXP (x, 0)) == NEG)\n+\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n+\n+      /* If operand is something known to be positive, ignore the ABS.  */\n+      if (GET_CODE (XEXP (x, 0)) == FFS || GET_CODE (XEXP (x, 0)) == ABS\n+\t  || ((GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n+\t       <= HOST_BITS_PER_WIDE_INT)\n+\t      && ((nonzero_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n+\t\t   & ((HOST_WIDE_INT) 1\n+\t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n+\t\t  == 0)))\n+\treturn XEXP (x, 0);\n+\n+\n+      /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n+      if (num_sign_bit_copies (XEXP (x, 0), mode) == GET_MODE_BITSIZE (mode))\n+\treturn gen_rtx_combine (NEG, mode, XEXP (x, 0));\n+\n+      break;\n+\n+    case FFS:\n+      /* (ffs (*_extend <X>)) = (ffs <X>) */\n+      if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t  || GET_CODE (XEXP (x, 0)) == ZERO_EXTEND)\n+\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n+      break;\n+\n+    case FLOAT:\n+      /* (float (sign_extend <X>)) = (float <X>).  */\n+      if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n+\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n+      break;\n+\n+    case LSHIFT:\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+    case ROTATE:\n+    case ROTATERT:\n+      /* If this is a shift by a constant amount, simplify it.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\treturn simplify_shift_const (x, code, mode, XEXP (x, 0), \n+\t\t\t\t     INTVAL (XEXP (x, 1)));\n+\n+#ifdef SHIFT_COUNT_TRUNCATED\n+      else if (SHIFT_COUNT_TRUNCATED && GET_CODE (XEXP (x, 1)) != REG)\n+\tSUBST (XEXP (x, 1),\n+\t       force_to_mode (XEXP (x, 1), GET_MODE (x),\n+\t\t\t      ((HOST_WIDE_INT) 1 \n+\t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n+\t\t\t      - 1,\n+\t\t\t      NULL_RTX, 0));\n+#endif\n+\n+      break;\n+    }\n+\n+  return x;\n+}\n+\f\n+/* Simplify X, an IF_THEN_ELSE expression.  Return the new expression.  */\n+\n+static rtx\n+simplify_if_then_else (x)\n+     rtx x;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx cond = XEXP (x, 0);\n+  rtx true = XEXP (x, 1);\n+  rtx false = XEXP (x, 2);\n+  enum rtx_code true_code = GET_CODE (cond);\n+  int comparison_p = GET_RTX_CLASS (true_code) == '<';\n+  rtx temp;\n+  int i;\n+\n+  /* Simplify storing of the truth value. */\n+  if (comparison_p && true == const_true_rtx && false == const0_rtx)\n+    return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n       \n-      /* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be\n-\t reversed, do so to avoid needing two sets of patterns for\n-\t subtract-and-branch insns.  Similarly if we have a constant in the\n-\t true arm, the false arm is the same as the first operand of the\n-\t comparison, or the false arm is more complicated than the true\n-\t arm.  */\n+  /* Also when the truth value has to be reversed. */\n+  if (comparison_p && reversible_comparison_p (cond)\n+      && true == const0_rtx && false == const_true_rtx)\n+    return gen_binary (reverse_condition (true_code),\n+\t\t       mode, XEXP (cond, 0), XEXP (cond, 1));\n+\n+  /* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register used\n+     in it is being compared against certain values.  Get the true and false\n+     comparisons and see if that says anything about the value of each arm.  */\n+\n+  if (comparison_p && reversible_comparison_p (cond)\n+      && GET_CODE (XEXP (cond, 0)) == REG)\n+    {\n+      HOST_WIDE_INT nzb;\n+      rtx from = XEXP (cond, 0);\n+      enum rtx_code false_code = reverse_condition (true_code);\n+      rtx true_val = XEXP (cond, 1);\n+      rtx false_val = true_val;\n+      int swapped = 0;\n \n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0))\n-\t  && (XEXP (x, 1) == pc_rtx \n-\t      || (CONSTANT_P (XEXP (x, 1))\n-\t\t  && GET_CODE (XEXP (x, 2)) != CONST_INT\n-\t\t  && XEXP (x, 2) != pc_rtx)\n-\t      || XEXP (x, 1) == const0_rtx\n-\t      || (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == 'o'\n-\t\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 2))) != 'o')\n-\t      || (GET_CODE (XEXP (x, 1)) == SUBREG\n-\t\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 1)))) == 'o'\n-\t\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 2))) != 'o')\n-\t      || reg_mentioned_p (XEXP (x, 1), XEXP (x, 2))\n-\t      || rtx_equal_p (XEXP (x, 2), XEXP (XEXP (x, 0), 0))))\n-\t{\n-\t  SUBST (XEXP (x, 0),\n-\t\t gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t     GET_MODE (XEXP (x, 0)),\n-\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 0), 1)));\n+      /* If FALSE_CODE is EQ, swap the codes and arms.  */\n \n-\t  temp = XEXP (x, 1);\n-\t  SUBST (XEXP (x, 1), XEXP (x, 2));\n-\t  SUBST (XEXP (x, 2), temp);\n+      if (false_code == EQ)\n+\t{\n+\t  swapped = 1, true_code = EQ, false_code = NE;\n+\t  temp = true, true = false, false = temp;\n \t}\n \n-      /* If the two arms are identical, we don't need the comparison.  */\n+      /* If we are comparing against zero and the expression being tested has\n+\t only a single bit that might be nonzero, that is its value when it is\n+\t not equal to zero.  Similarly if it is known to be -1 or 0.  */\n \n-      if (rtx_equal_p (XEXP (x, 1), XEXP (x, 2))\n-\t  && ! side_effects_p (XEXP (x, 0)))\n-\treturn XEXP (x, 1);\n+      if (true_code == EQ && true_val == const0_rtx\n+\t  && exact_log2 (nzb = nonzero_bits (from, GET_MODE (from))) >= 0)\n+\tfalse_code = EQ, false_val = GEN_INT (nzb);\n+      else if (true_code == EQ && true_val == const0_rtx\n+\t       && (num_sign_bit_copies (from, GET_MODE (from))\n+\t\t   == GET_MODE_BITSIZE (GET_MODE (from))))\n+\tfalse_code = EQ, false_val = constm1_rtx;\n \n-      /* Look for cases where we have (abs x) or (neg (abs X)).  */\n+      /* Now simplify an arm if we know the value of the register in the\n+\t branch and it is used in the arm.  Be careful due to the potential\n+\t of locally-shared RTL.  */\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_CODE (XEXP (x, 2)) == NEG\n-\t  && rtx_equal_p (XEXP (x, 1), XEXP (XEXP (x, 2), 0))\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && rtx_equal_p (XEXP (x, 1), XEXP (XEXP (x, 0), 0))\n-\t  && ! side_effects_p (XEXP (x, 1)))\n-\tswitch (GET_CODE (XEXP (x, 0)))\n-\t  {\n-\t  case GT:\n-\t  case GE:\n-\t    x = gen_unary (ABS, mode, XEXP (x, 1));\n-\t    goto restart;\n-\t  case LT:\n-\t  case LE:\n-\t    x = gen_unary (NEG, mode, gen_unary (ABS, mode, XEXP (x, 1)));\n-\t    goto restart;\n-\t  }\n+      if (reg_mentioned_p (from, true))\n+\ttrue = subst (known_cond (copy_rtx (true), true_code, from, true_val),\n+\t\t      pc_rtx, pc_rtx, 0, 0);\n+      if (reg_mentioned_p (from, false))\n+\tfalse = subst (known_cond (copy_rtx (false), false_code,\n+\t\t\t\t   from, false_val),\n+\t\t       pc_rtx, pc_rtx, 0, 0);\n \n-      /* Look for MIN or MAX.  */\n+      SUBST (XEXP (x, 1), swapped ? false : true);\n+      SUBST (XEXP (x, 2), swapped ? true : false);\n \n-      if (! FLOAT_MODE_P (mode)\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 2))\n-\t  && ! side_effects_p (XEXP (x, 0)))\n-\tswitch (GET_CODE (XEXP (x, 0)))\n-\t  {\n-\t  case GE:\n-\t  case GT:\n-\t    x = gen_binary (SMAX, mode, XEXP (x, 1), XEXP (x, 2));\n-\t    goto restart;\n-\t  case LE:\n-\t  case LT:\n-\t    x = gen_binary (SMIN, mode, XEXP (x, 1), XEXP (x, 2));\n-\t    goto restart;\n-\t  case GEU:\n-\t  case GTU:\n-\t    x = gen_binary (UMAX, mode, XEXP (x, 1), XEXP (x, 2));\n-\t    goto restart;\n-\t  case LEU:\n-\t  case LTU:\n-\t    x = gen_binary (UMIN, mode, XEXP (x, 1), XEXP (x, 2));\n-\t    goto restart;\n-\t  }\n+      true = XEXP (x, 1), false = XEXP (x, 2), true_code = GET_CODE (cond);\n+    }\n \n-#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n+  /* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be\n+     reversed, do so to avoid needing two sets of patterns for\n+     subtract-and-branch insns.  Similarly if we have a constant in the true\n+     arm, the false arm is the same as the first operand of the comparison, or\n+     the false arm is more complicated than the true arm.  */\n+\n+  if (comparison_p && reversible_comparison_p (cond)\n+      && (true == pc_rtx \n+\t  || (CONSTANT_P (true)\n+\t      && GET_CODE (false) != CONST_INT && false != pc_rtx)\n+\t  || true == const0_rtx\n+\t  || (GET_RTX_CLASS (GET_CODE (true)) == 'o'\n+\t      && GET_RTX_CLASS (GET_CODE (false)) != 'o')\n+\t  || (GET_CODE (true) == SUBREG\n+\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (true))) == 'o'\n+\t      && GET_RTX_CLASS (GET_CODE (false)) != 'o')\n+\t  || reg_mentioned_p (true, false)\n+\t  || rtx_equal_p (false, XEXP (cond, 0))))\n+    {\n+      true_code = reverse_condition (true_code);\n+      SUBST (XEXP (x, 0),\n+\t     gen_binary (true_code, GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t XEXP (cond, 1)));\n \n-      /* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when\n-\t its second operand is zero, this can be done as (OP Z (mult COND C2))\n-\t where C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer\n-\t ZERO_EXTEND or SIGN_EXTEND as long as Z is already extended (so\n-\t we don't destroy it).  We can do this kind of thing in some\n-\t cases when STORE_FLAG_VALUE is neither of the above, but it isn't\n-\t worth checking for.\n+      SUBST (XEXP (x, 1), false);\n+      SUBST (XEXP (x, 2), true);\n \n-\t Similarly, (if_then_else COND Z 0) can be replaced by \n-\t (mult COND (mult Z STORE_FLAG_VALUE)).  */\n+      temp = true, true = false, false = temp, cond = XEXP (x, 0);\n+    }\n \n-      if (mode != VOIDmode && ! side_effects_p (x))\n-\t{\n-\t  rtx t = make_compound_operation (XEXP (x, 1), SET);\n-\t  rtx f = make_compound_operation (XEXP (x, 2), SET);\n-\t  rtx cond_op0 = XEXP (XEXP (x, 0), 0);\n-\t  rtx cond_op1 = XEXP (XEXP (x, 0), 1);\n-\t  enum rtx_code cond_op = GET_CODE (XEXP (x, 0));\n-\t  enum rtx_code op, extend_op = NIL;\n-\t  enum machine_mode m = mode;\n-\t  rtx z = 0, c1, c2;\n-\n-\t  if (f == const0_rtx)\n-\t    return gen_binary (MULT, mode, gen_binary (cond_op, mode, cond_op0,\n-\t\t\t\t\t\t       cond_op1),\n-\t\t\t       gen_binary (MULT, mode, t, const_true_rtx));\n-\n-\t  if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n-\t       || GET_CODE (t) == IOR || GET_CODE (t) == XOR\n-\t       || GET_CODE (t) == ASHIFT\n-\t       || GET_CODE (t) == LSHIFTRT || GET_CODE (t) == ASHIFTRT)\n-\t      && rtx_equal_p (XEXP (t, 0), f))\n-\t    c1 = XEXP (t, 1), op = GET_CODE (t), z = f;\n-\n-\t  /* If an identity-zero op is commutative, check whether there\n-\t     would be a match if we swapped the operands. */\n-\t  else if ((GET_CODE (t) == PLUS || GET_CODE (t) == IOR\n-\t\t    || GET_CODE (t) == XOR)\n-\t\t   && rtx_equal_p (XEXP (t, 1), f))\n-\t    c1 = XEXP (t, 0), op = GET_CODE (t), z = f;\n-\t  else if (GET_CODE (t) == SIGN_EXTEND\n-\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n-\t\t   && (num_sign_bit_copies (f, GET_MODE (f))\n-\t\t       > (GET_MODE_BITSIZE (mode)\n-\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0),\n-\t\t\t\t\t\t\t      0))))))\n-\t    {\n-\t      c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n-\t      extend_op = SIGN_EXTEND;\n-\t      m = GET_MODE (XEXP (t, 0));\n-\t    }\n-\t  else if (GET_CODE (t) == SIGN_EXTEND\n-\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == XOR)\n-\t\t   && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n-\t\t   && (num_sign_bit_copies (f, GET_MODE (f))\n-\t\t       > (GET_MODE_BITSIZE (mode)\n-\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0),\n-\t\t\t\t\t\t\t      1))))))\n-\t    {\n-\t      c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n-\t      extend_op = SIGN_EXTEND;\n-\t      m = GET_MODE (XEXP (t, 0));\n-\t    }\n-\t  else if (GET_CODE (t) == ZERO_EXTEND\n-\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n-\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n-\t\t   && ((nonzero_bits (f, GET_MODE (f))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n-\t\t       == 0))\n-\t    {\n-\t      c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n-\t      extend_op = ZERO_EXTEND;\n-\t      m = GET_MODE (XEXP (t, 0));\n-\t    }\n-\t  else if (GET_CODE (t) == ZERO_EXTEND\n-\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (t, 0)) == XOR)\n-\t\t   && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n-\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n-\t\t   && ((nonzero_bits (f, GET_MODE (f))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n-\t\t       == 0))\n-\t    {\n-\t      c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n-\t      extend_op = ZERO_EXTEND;\n-\t      m = GET_MODE (XEXP (t, 0));\n-\t    }\n+  /* If the two arms are identical, we don't need the comparison.  */\n \n-\t  if (z)\n-\t    {\n-\t      temp = subst (gen_binary (cond_op, m, cond_op0, cond_op1),\n-\t\t\t    pc_rtx, pc_rtx, 0, 0);\n+  if (rtx_equal_p (true, false) && ! side_effects_p (cond))\n+    return true;\n \n+  /* Look for cases where we have (abs x) or (neg (abs X)).  */\n \n-\t      temp = gen_binary (MULT, m, temp,\n-\t\t\t\t gen_binary (MULT, m, c1, const_true_rtx));\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_CODE (false) == NEG\n+      && rtx_equal_p (true, XEXP (false, 0))\n+      && comparison_p\n+      && rtx_equal_p (true, XEXP (cond, 0))\n+      && ! side_effects_p (true))\n+    switch (true_code)\n+      {\n+      case GT:\n+      case GE:\n+\treturn gen_unary (ABS, mode, true);\n+      case LT:\n+      case LE:\n+\treturn gen_unary (NEG, mode, gen_unary (ABS, mode, true));\n+      }\n \n-\t      temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n+  /* Look for MIN or MAX.  */\n+\n+  if ((! FLOAT_MODE_P (mode) | flag_fast_math)\n+      && comparison_p\n+      && rtx_equal_p (XEXP (cond, 0), true)\n+      && rtx_equal_p (XEXP (cond, 1), false)\n+      && ! side_effects_p (cond))\n+    switch (true_code)\n+      {\n+      case GE:\n+      case GT:\n+\treturn gen_binary (SMAX, mode, true, false);\n+      case LE:\n+      case LT:\n+\treturn gen_binary (SMIN, mode, true, false);\n+      case GEU:\n+      case GTU:\n+\treturn gen_binary (UMAX, mode, true, false);\n+      case LEU:\n+      case LTU:\n+\treturn gen_binary (UMIN, mode, true, false);\n+      }\n+  \n+#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n \n-\t      temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n+  /* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when its\n+     second operand is zero, this can be done as (OP Z (mult COND C2)) where\n+     C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer ZERO_EXTEND or\n+     SIGN_EXTEND as long as Z is already extended (so we don't destroy it).\n+     We can do this kind of thing in some cases when STORE_FLAG_VALUE is\n+     neither of the above, but it isn't worth checking for.\n \n-\t      if (extend_op != NIL)\n-\t\ttemp = gen_unary (extend_op, mode, temp);\n+     Similarly, (if_then_else COND Z 0) can be replaced by \n+     (mult COND (mult Z STORE_FLAG_VALUE)).  */\n \n-\t      return temp;\n-\t    }\n+  if (comparison_p && mode != VOIDmode && ! side_effects_p (x))\n+    {\n+      rtx t = make_compound_operation (true, SET);\n+      rtx f = make_compound_operation (false, SET);\n+      rtx cond_op0 = XEXP (cond, 0);\n+      rtx cond_op1 = XEXP (cond, 1);\n+      enum rtx_code op, extend_op = NIL;\n+      enum machine_mode m = mode;\n+      rtx z = 0, c1, c2;\n+\n+      if (f == const0_rtx)\n+\treturn gen_binary (MULT, mode, gen_binary (true_code, mode, cond_op0,\n+\t\t\t\t\t\t   cond_op1),\n+\t\t\t   gen_binary (MULT, mode, t, const_true_rtx));\n+\n+      if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n+\t   || GET_CODE (t) == IOR || GET_CODE (t) == XOR\n+\t   || GET_CODE (t) == ASHIFT\n+\t   || GET_CODE (t) == LSHIFTRT || GET_CODE (t) == ASHIFTRT)\n+\t  && rtx_equal_p (XEXP (t, 0), f))\n+\tc1 = XEXP (t, 1), op = GET_CODE (t), z = f;\n+\n+      /* If an identity-zero op is commutative, check whether there\n+\t would be a match if we swapped the operands. */\n+      else if ((GET_CODE (t) == PLUS || GET_CODE (t) == IOR\n+\t\t|| GET_CODE (t) == XOR)\n+\t       && rtx_equal_p (XEXP (t, 1), f))\n+\tc1 = XEXP (t, 0), op = GET_CODE (t), z = f;\n+      else if (GET_CODE (t) == SIGN_EXTEND\n+\t       && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == MINUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == XOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == ASHIFT\n+\t\t   || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n+\t\t   || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n+\t       && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n+\t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n+\t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n+\t       && (num_sign_bit_copies (f, GET_MODE (f))\n+\t\t   > (GET_MODE_BITSIZE (mode)\n+\t\t      - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0), 0))))))\n+\t{\n+\t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n+\t  extend_op = SIGN_EXTEND;\n+\t  m = GET_MODE (XEXP (t, 0));\n+\t}\n+      else if (GET_CODE (t) == SIGN_EXTEND\n+\t       && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == XOR)\n+\t       && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n+\t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n+\t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n+\t       && (num_sign_bit_copies (f, GET_MODE (f))\n+\t\t   > (GET_MODE_BITSIZE (mode)\n+\t\t      - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0), 1))))))\n+\t{\n+\t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n+\t  extend_op = SIGN_EXTEND;\n+\t  m = GET_MODE (XEXP (t, 0));\n+\t}\n+      else if (GET_CODE (t) == ZERO_EXTEND\n+\t       && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == MINUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == XOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == ASHIFT\n+\t\t   || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n+\t\t   || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n+\t       && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n+\t       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n+\t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n+\t       && ((nonzero_bits (f, GET_MODE (f))\n+\t\t    & ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n+\t\t   == 0))\n+\t{\n+\t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n+\t  extend_op = ZERO_EXTEND;\n+\t  m = GET_MODE (XEXP (t, 0));\n+\t}\n+      else if (GET_CODE (t) == ZERO_EXTEND\n+\t       && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t   || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t   || GET_CODE (XEXP (t, 0)) == XOR)\n+\t       && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n+\t       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n+\t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n+\t       && ((nonzero_bits (f, GET_MODE (f))\n+\t\t    & ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n+\t\t   == 0))\n+\t{\n+\t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n+\t  extend_op = ZERO_EXTEND;\n+\t  m = GET_MODE (XEXP (t, 0));\n \t}\n+      \n+      if (z)\n+\t{\n+\t  temp = subst (gen_binary (true_code, m, cond_op0, cond_op1),\n+\t\t\tpc_rtx, pc_rtx, 0, 0);\n+\t  temp = gen_binary (MULT, m, temp,\n+\t\t\t     gen_binary (MULT, m, c1, const_true_rtx));\n+\t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n+\t  temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n+\n+\t  if (extend_op != NIL)\n+\t    temp = gen_unary (extend_op, mode, temp);\n+\n+\t  return temp;\n+\t}\n+    }\n #endif\n \n-      /* If we have (if_then_else (ne A 0) C1 0) and either A is known to \n-\t be 0 or 1 and C1 is a single bit or A is known to be 0 or -1 and\n-\t C1 is the negation of a single bit, we can convert this operation\n-\t to a shift.  We can actually do this in more general cases, but it\n-\t doesn't seem worth it.  */\n+  /* If we have (if_then_else (ne A 0) C1 0) and either A is known to be 0 or\n+     1 and C1 is a single bit or A is known to be 0 or -1 and C1 is the\n+     negation of a single bit, we can convert this operation to a shift.  We\n+     can actually do this more generally, but it doesn't seem worth it.  */\n+\n+  if (true_code == NE && XEXP (cond, 1) == const0_rtx\n+      && false == const0_rtx && GET_CODE (true) == CONST_INT\n+      && ((1 == nonzero_bits (XEXP (cond, 0), mode)\n+\t   && (i = exact_log2 (INTVAL (true))) >= 0)\n+\t  || ((num_sign_bit_copies (XEXP (cond, 0), mode)\n+\t       == GET_MODE_BITSIZE (mode))\n+\t      && (i = exact_log2 (- INTVAL (true))) >= 0)))\n+    return\n+      simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t\t\t    gen_lowpart_for_combine (mode, XEXP (cond, 0)), i);\n \n-      if (GET_CODE (XEXP (x, 0)) == NE && XEXP (XEXP (x, 0), 1) == const0_rtx\n-\t  && XEXP (x, 2) == const0_rtx && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && ((1 == nonzero_bits (XEXP (XEXP (x, 0), 0), mode)\n-\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n-\t      || ((num_sign_bit_copies (XEXP (XEXP (x, 0), 0), mode)\n-\t\t   == GET_MODE_BITSIZE (mode))\n-\t\t  && (i = exact_log2 (- INTVAL (XEXP (x, 1)))) >= 0)))\n-\treturn\n-\t  simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t\tgen_lowpart_for_combine (mode,\n-\t\t\t\t\t\t\t XEXP (XEXP (x, 0), 0)),\n-\t\t\t\ti);\n-      break;\n-\t  \n-    case ZERO_EXTRACT:\n-    case SIGN_EXTRACT:\n-    case ZERO_EXTEND:\n-    case SIGN_EXTEND:\n-      /* If we are processing SET_DEST, we are done. */\n-      if (in_dest)\n-\treturn x;\n+  return x;\n+}\n+\f\n+/* Simplify X, a SET expression.  Return the new expression.  */\n \n-      x = expand_compound_operation (x);\n-      if (GET_CODE (x) != code)\n-\tgoto restart;\n-      break;\n+static rtx\n+simplify_set (x)\n+     rtx x;\n+{\n+  rtx src = SET_SRC (x);\n+  rtx dest = SET_DEST (x);\n+  enum machine_mode mode\n+    = GET_MODE (src) != VOIDmode ? GET_MODE (src) : GET_MODE (dest);\n+  rtx other_insn;\n+  rtx *cc_use;\n \n-    case SET:\n-      /* (set (pc) (return)) gets written as (return).  */\n-      if (GET_CODE (SET_DEST (x)) == PC && GET_CODE (SET_SRC (x)) == RETURN)\n-\treturn SET_SRC (x);\n+  /* (set (pc) (return)) gets written as (return).  */\n+  if (GET_CODE (dest) == PC && GET_CODE (src) == RETURN)\n+    return src;\n \n-      /* Convert this into a field assignment operation, if possible.  */\n-      x = make_field_assignment (x);\n+  /* Convert this into a field assignment operation, if possible.  */\n+  x = make_field_assignment (x);\n \n-      /* If we are setting CC0 or if the source is a COMPARE, look for the\n-\t use of the comparison result and try to simplify it unless we already\n-\t have used undobuf.other_insn.  */\n-      if ((GET_CODE (SET_SRC (x)) == COMPARE\n+  /* If we are setting CC0 or if the source is a COMPARE, look for the use of\n+     the comparison result and try to simplify it unless we already have used\n+     undobuf.other_insn.  */\n+  if ((GET_CODE (src) == COMPARE\n #ifdef HAVE_cc0\n-\t   || SET_DEST (x) == cc0_rtx\n+       || dest == cc0_rtx\n #endif\n-\t   )\n-\t  && (cc_use = find_single_use (SET_DEST (x), subst_insn,\n-\t\t\t\t\t&other_insn)) != 0\n-\t  && (undobuf.other_insn == 0 || other_insn == undobuf.other_insn)\n-\t  && GET_RTX_CLASS (GET_CODE (*cc_use)) == '<'\n-\t  && XEXP (*cc_use, 0) == SET_DEST (x))\n-\t{\n-\t  enum rtx_code old_code = GET_CODE (*cc_use);\n-\t  enum rtx_code new_code;\n-\t  rtx op0, op1;\n-\t  int other_changed = 0;\n-\t  enum machine_mode compare_mode = GET_MODE (SET_DEST (x));\n-\n-\t  if (GET_CODE (SET_SRC (x)) == COMPARE)\n-\t    op0 = XEXP (SET_SRC (x), 0), op1 = XEXP (SET_SRC (x), 1);\n-\t  else\n-\t    op0 = SET_SRC (x), op1 = const0_rtx;\n+       )\n+      && (cc_use = find_single_use (dest, subst_insn, &other_insn)) != 0\n+      && (undobuf.other_insn == 0 || other_insn == undobuf.other_insn)\n+      && GET_RTX_CLASS (GET_CODE (*cc_use)) == '<'\n+      && XEXP (*cc_use, 0) == dest)\n+    {\n+      enum rtx_code old_code = GET_CODE (*cc_use);\n+      enum rtx_code new_code;\n+      rtx op0, op1;\n+      int other_changed = 0;\n+      enum machine_mode compare_mode = GET_MODE (dest);\n+\n+      if (GET_CODE (src) == COMPARE)\n+\top0 = XEXP (src, 0), op1 = XEXP (src, 1);\n+      else\n+\top0 = src, op1 = const0_rtx;\n \n-\t  /* Simplify our comparison, if possible.  */\n-\t  new_code = simplify_comparison (old_code, &op0, &op1);\n+      /* Simplify our comparison, if possible.  */\n+      new_code = simplify_comparison (old_code, &op0, &op1);\n \n #ifdef EXTRA_CC_MODES\n-\t  /* If this machine has CC modes other than CCmode, check to see\n-\t     if we need to use a different CC mode here.  */\n-\t  compare_mode = SELECT_CC_MODE (new_code, op0, op1);\n+      /* If this machine has CC modes other than CCmode, check to see if we\n+\t need to use a different CC mode here.  */\n+      compare_mode = SELECT_CC_MODE (new_code, op0, op1);\n #endif /* EXTRA_CC_MODES */\n \n #if !defined (HAVE_cc0) && defined (EXTRA_CC_MODES)\n-\t  /* If the mode changed, we have to change SET_DEST, the mode\n-\t     in the compare, and the mode in the place SET_DEST is used.\n-\t     If SET_DEST is a hard register, just build new versions with\n-\t     the proper mode.  If it is a pseudo, we lose unless it is only\n-\t     time we set the pseudo, in which case we can safely change\n-\t     its mode.  */\n-\t  if (compare_mode != GET_MODE (SET_DEST (x)))\n+      /* If the mode changed, we have to change SET_DEST, the mode in the\n+\t compare, and the mode in the place SET_DEST is used.  If SET_DEST is\n+\t a hard register, just build new versions with the proper mode.  If it\n+\t is a pseudo, we lose unless it is only time we set the pseudo, in\n+\t which case we can safely change its mode.  */\n+      if (compare_mode != GET_MODE (dest))\n+\t{\n+\t  int regno = REGNO (dest);\n+\t  rtx new_dest = gen_rtx (REG, compare_mode, regno);\n+\n+\t  if (regno < FIRST_PSEUDO_REGISTER\n+\t      || (reg_n_sets[regno] == 1 && ! REG_USERVAR_P (dest)))\n \t    {\n-\t      int regno = REGNO (SET_DEST (x));\n-\t      rtx new_dest = gen_rtx (REG, compare_mode, regno);\n+\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\tSUBST (regno_reg_rtx[regno], new_dest);\n \n-\t      if (regno < FIRST_PSEUDO_REGISTER\n-\t\t  || (reg_n_sets[regno] == 1\n-\t\t      && ! REG_USERVAR_P (SET_DEST (x))))\n-\t\t{\n-\t\t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\t    SUBST (regno_reg_rtx[regno], new_dest);\n+\t      SUBST (SET_DEST (x), new_dest);\n+\t      SUBST (XEXP (*cc_use, 0), new_dest);\n+\t      other_changed = 1;\n \n-\t\t  SUBST (SET_DEST (x), new_dest);\n-\t\t  SUBST (XEXP (*cc_use, 0), new_dest);\n-\t\t  other_changed = 1;\n-\t\t}\n+\t      dest = new_dest;\n \t    }\n+\t}\n #endif\n \n-\t  /* If the code changed, we have to build a new comparison\n-\t     in undobuf.other_insn.  */\n-\t  if (new_code != old_code)\n+      /* If the code changed, we have to build a new comparison in\n+\t undobuf.other_insn.  */\n+      if (new_code != old_code)\n+\t{\n+\t  unsigned HOST_WIDE_INT mask;\n+\n+\t  SUBST (*cc_use, gen_rtx_combine (new_code, GET_MODE (*cc_use),\n+\t\t\t\t\t   dest, const0_rtx));\n+\n+\t  /* If the only change we made was to change an EQ into an NE or\n+\t     vice versa, OP0 has only one bit that might be nonzero, and OP1\n+\t     is zero, check if changing the user of the condition code will\n+\t     produce a valid insn.  If it won't, we can keep the original code\n+\t     in that insn by surrounding our operation with an XOR.  */\n+\n+\t  if (((old_code == NE && new_code == EQ)\n+\t       || (old_code == EQ && new_code == NE))\n+\t      && ! other_changed && op1 == const0_rtx\n+\t      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n+\t      && exact_log2 (mask = nonzero_bits (op0, GET_MODE (op0))) >= 0)\n \t    {\n-\t      unsigned HOST_WIDE_INT mask;\n+\t      rtx pat = PATTERN (other_insn), note = 0;\n \n-\t      SUBST (*cc_use, gen_rtx_combine (new_code, GET_MODE (*cc_use),\n-\t\t\t\t\t       SET_DEST (x), const0_rtx));\n-\n-\t      /* If the only change we made was to change an EQ into an\n-\t\t NE or vice versa, OP0 has only one bit that might be nonzero,\n-\t\t and OP1 is zero, check if changing the user of the condition\n-\t\t code will produce a valid insn.  If it won't, we can keep\n-\t\t the original code in that insn by surrounding our operation\n-\t\t with an XOR.  */\n-\n-\t      if (((old_code == NE && new_code == EQ)\n-\t\t   || (old_code == EQ && new_code == NE))\n-\t\t  && ! other_changed && op1 == const0_rtx\n-\t\t  && (GET_MODE_BITSIZE (GET_MODE (op0))\n-\t\t      <= HOST_BITS_PER_WIDE_INT)\n-\t\t  && (exact_log2 (mask = nonzero_bits (op0, GET_MODE (op0)))\n-\t\t      >= 0))\n+\t      if ((recog_for_combine (&pat, other_insn, &note) < 0\n+\t\t   && ! check_asm_operands (pat)))\n \t\t{\n-\t\t  rtx pat = PATTERN (other_insn), note = 0;\n+\t\t  PUT_CODE (*cc_use, old_code);\n+\t\t  other_insn = 0;\n \n-\t\t  if ((recog_for_combine (&pat, other_insn, &note) < 0\n-\t\t       && ! check_asm_operands (pat)))\n-\t\t    {\n-\t\t      PUT_CODE (*cc_use, old_code);\n-\t\t      other_insn = 0;\n-\n-\t\t      op0 = gen_binary (XOR, GET_MODE (op0), op0,\n-\t\t\t\t\tGEN_INT (mask));\n-\t\t    }\n+\t\t  op0 = gen_binary (XOR, GET_MODE (op0), op0, GEN_INT (mask));\n \t\t}\n-\n-\t      other_changed = 1;\n \t    }\n \n-\t  if (other_changed)\n-\t    undobuf.other_insn = other_insn;\n+\t  other_changed = 1;\n+\t}\n+\n+      if (other_changed)\n+\tundobuf.other_insn = other_insn;\n \n #ifdef HAVE_cc0\n-\t  /* If we are now comparing against zero, change our source if\n-\t     needed.  If we do not use cc0, we always have a COMPARE.  */\n-\t  if (op1 == const0_rtx && SET_DEST (x) == cc0_rtx)\n-\t    SUBST (SET_SRC (x), op0);\n-\t  else\n+      /* If we are now comparing against zero, change our source if\n+\t needed.  If we do not use cc0, we always have a COMPARE.  */\n+      if (op1 == const0_rtx && dest == cc0_rtx)\n+\t{\n+\t  SUBST (SET_SRC (x), op0);\n+\t  src = op0;\n+\t}\n+      else\n #endif\n \n-\t  /* Otherwise, if we didn't previously have a COMPARE in the\n-\t     correct mode, we need one.  */\n-\t  if (GET_CODE (SET_SRC (x)) != COMPARE\n-\t      || GET_MODE (SET_SRC (x)) != compare_mode)\n-\t    SUBST (SET_SRC (x), gen_rtx_combine (COMPARE, compare_mode,\n-\t\t\t\t\t\t op0, op1));\n-\t  else\n-\t    {\n-\t      /* Otherwise, update the COMPARE if needed.  */\n-\t      SUBST (XEXP (SET_SRC (x), 0), op0);\n-\t      SUBST (XEXP (SET_SRC (x), 1), op1);\n-\t    }\n+      /* Otherwise, if we didn't previously have a COMPARE in the\n+\t correct mode, we need one.  */\n+      if (GET_CODE (src) != COMPARE || GET_MODE (src) != compare_mode)\n+\t{\n+\t  SUBST (SET_SRC (x),\n+\t\t gen_rtx_combine (COMPARE, compare_mode, op0, op1));\n+\t  src = SET_SRC (x);\n \t}\n       else\n \t{\n-\t  /* Get SET_SRC in a form where we have placed back any\n-\t     compound expressions.  Then do the checks below.  */\n-\t  temp = make_compound_operation (SET_SRC (x), SET);\n-\t  SUBST (SET_SRC (x), temp);\n+\t  /* Otherwise, update the COMPARE if needed.  */\n+\t  SUBST (XEXP (src, 0), op0);\n+\t  SUBST (XEXP (src, 1), op1);\n \t}\n+    }\n+  else\n+    {\n+      /* Get SET_SRC in a form where we have placed back any\n+\t compound expressions.  Then do the checks below.  */\n+      src = make_compound_operation (src, SET);\n+      SUBST (SET_SRC (x), src);\n+    }\n \n-      /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some\n-\t operation, and X being a REG or (subreg (reg)), we may be able to\n-\t convert this to (set (subreg:m2 x) (op)).\n+  /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some operation,\n+     and X being a REG or (subreg (reg)), we may be able to convert this to\n+     (set (subreg:m2 x) (op)). \n \n-\t We can always do this if M1 is narrower than M2 because that\n-\t means that we only care about the low bits of the result.\n+     We can always do this if M1 is narrower than M2 because that means that\n+     we only care about the low bits of the result.\n \n-\t However, on machines without WORD_REGISTER_OPERATIONS defined,\n-\t we cannot perform a narrower operation that requested since the\n-\t high-order bits will be undefined.  On machine where it is defined,\n-\t this transformation is safe as long as M1 and M2 have the same\n-\t number of words.  */\n+     However, on machines without WORD_REGISTER_OPERATIONS defined, we cannot\n+     perform a narrower operation that requested since the high-order bits will\n+     be undefined.  On machine where it is defined, this transformation is safe\n+     as long as M1 and M2 have the same number of words.  */\n  \n-      if (GET_CODE (SET_SRC (x)) == SUBREG\n-\t  && subreg_lowpart_p (SET_SRC (x))\n-\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (SET_SRC (x)))) != 'o'\n-\t  && (((GET_MODE_SIZE (GET_MODE (SET_SRC (x))) + (UNITS_PER_WORD - 1))\n-\t       / UNITS_PER_WORD)\n-\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n-\t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n+  if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n+      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (src))) != 'o'\n+      && (((GET_MODE_SIZE (GET_MODE (src)) + (UNITS_PER_WORD - 1))\n+\t   / UNITS_PER_WORD)\n+\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n+\t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n #ifndef WORD_REGISTER_OPERATIONS\n-\t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n-\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n+      && (GET_MODE_SIZE (GET_MODE (src))\n+\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n #endif\n-\t  && (GET_CODE (SET_DEST (x)) == REG\n-\t      || (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t  && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG)))\n-\t{\n-\t  SUBST (SET_DEST (x),\n-\t\t gen_lowpart_for_combine (GET_MODE (SUBREG_REG (SET_SRC (x))),\n-\t\t\t\t\t  SET_DEST (x)));\n-\t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n-\t}\n+      && (GET_CODE (dest) == REG\n+\t  || (GET_CODE (dest) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (dest)) == REG)))\n+    {\n+      SUBST (SET_DEST (x),\n+\t     gen_lowpart_for_combine (GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t      dest));\n+      SUBST (SET_SRC (x), SUBREG_REG (src));\n+\n+      src = SET_SRC (x), dest = SET_DEST (x);\n+    }\n \n #ifdef LOAD_EXTEND_OP\n-      /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with\n-\t M wider than N, this would require a paradoxical subreg.\n-\t Replace the subreg with a zero_extend to avoid the reload that\n-\t would otherwise be required. */\n-\n-      if (GET_CODE (SET_SRC (x)) == SUBREG\n-\t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (SET_SRC (x)))) != NIL\n-\t  && subreg_lowpart_p (SET_SRC (x))\n-\t  && SUBREG_WORD (SET_SRC (x)) == 0\n-\t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n-\t  && GET_CODE (SUBREG_REG (SET_SRC (x))) == MEM)\n-\tSUBST (SET_SRC (x),\n-\t       gen_rtx_combine (LOAD_EXTEND_OP (GET_MODE\n-\t\t\t\t\t\t(SUBREG_REG (SET_SRC (x)))),\n-\t\t\t\tGET_MODE (SET_SRC (x)),\n-\t\t\t\tXEXP (SET_SRC (x), 0)));\n+  /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with M wider than N, this\n+     would require a paradoxical subreg.  Replace the subreg with a\n+     zero_extend to avoid the reload that would otherwise be required. */\n+\n+  if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n+      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != NIL\n+      && SUBREG_WORD (src) == 0\n+      && (GET_MODE_SIZE (GET_MODE (src))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n+      && GET_CODE (SUBREG_REG (src)) == MEM)\n+    {\n+      SUBST (SET_SRC (x),\n+\t     gen_rtx_combine (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))),\n+\t\t\t      GET_MODE (src), XEXP (src, 0)));\n+\n+      src = SET_SRC (x);\n+    }\n #endif\n \n #ifndef HAVE_conditional_move\n \n-      /* If we don't have a conditional move, SET_SRC is an IF_THEN_ELSE,\n-\t and we are comparing an item known to be 0 or -1 against 0, use a\n-\t logical operation instead. Check for one of the arms being an IOR\n-\t of the other arm with some value.  We compute three terms to be\n-\t IOR'ed together.  In practice, at most two will be nonzero.  Then\n-\t we do the IOR's.  */\n-\n-      if (GET_CODE (SET_DEST (x)) != PC\n-\t  && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE\n-\t  && (GET_CODE (XEXP (SET_SRC (x), 0)) == EQ\n-\t      || GET_CODE (XEXP (SET_SRC (x), 0)) == NE)\n-\t  && XEXP (XEXP (SET_SRC (x), 0), 1) == const0_rtx\n-\t  && (num_sign_bit_copies (XEXP (XEXP (SET_SRC (x), 0), 0),\n-\t\t\t\t   GET_MODE (XEXP (XEXP (SET_SRC (x), 0), 0)))\n-\t      == GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (SET_SRC (x), 0), 0))))\n-\t  && ! side_effects_p (SET_SRC (x)))\n-\t{\n-\t  rtx true = (GET_CODE (XEXP (SET_SRC (x), 0)) == NE\n-\t\t      ? XEXP (SET_SRC (x), 1) : XEXP (SET_SRC (x), 2));\n-\t  rtx false = (GET_CODE (XEXP (SET_SRC (x), 0)) == NE\n-\t\t       ? XEXP (SET_SRC (x), 2) : XEXP (SET_SRC (x), 1));\n-\t  rtx term1 = const0_rtx, term2, term3;\n-\n-\t  if (GET_CODE (true) == IOR && rtx_equal_p (XEXP (true, 0), false))\n-\t    term1 = false, true = XEXP (true, 1), false = const0_rtx;\n-\t  else if (GET_CODE (true) == IOR\n-\t\t   && rtx_equal_p (XEXP (true, 1), false))\n-\t    term1 = false, true = XEXP (true, 0), false = const0_rtx;\n-\t  else if (GET_CODE (false) == IOR\n-\t\t   && rtx_equal_p (XEXP (false, 0), true))\n-\t    term1 = true, false = XEXP (false, 1), true = const0_rtx;\n-\t  else if (GET_CODE (false) == IOR\n-\t\t   && rtx_equal_p (XEXP (false, 1), true))\n-\t    term1 = true, false = XEXP (false, 0), true = const0_rtx;\n-\n-\t  term2 = gen_binary (AND, GET_MODE (SET_SRC (x)),\n-\t\t\t      XEXP (XEXP (SET_SRC (x), 0), 0), true);\n-\t  term3 = gen_binary (AND, GET_MODE (SET_SRC (x)),\n-\t\t\t      gen_unary (NOT, GET_MODE (SET_SRC (x)),\n-\t\t\t\t\t XEXP (XEXP (SET_SRC (x), 0), 0)),\n-\t\t\t      false);\n-\n-\t  SUBST (SET_SRC (x),\n-\t\t gen_binary (IOR, GET_MODE (SET_SRC (x)),\n-\t\t\t     gen_binary (IOR, GET_MODE (SET_SRC (x)),\n-\t\t\t\t\t term1, term2),\n-\t\t\t     term3));\n-\t}\n+  /* If we don't have a conditional move, SET_SRC is an IF_THEN_ELSE, and we\n+     are comparing an item known to be 0 or -1 against 0, use a logical\n+     operation instead. Check for one of the arms being an IOR of the other\n+     arm with some value.  We compute three terms to be IOR'ed together.  In\n+     practice, at most two will be nonzero.  Then we do the IOR's.  */\n+\n+  if (GET_CODE (dest) != PC\n+      && GET_CODE (src) == IF_THEN_ELSE\n+      && (GET_CODE (XEXP (src, 0)) == EQ || GET_CODE (XEXP (src, 0)) == NE)\n+      && XEXP (XEXP (src, 0), 1) == const0_rtx\n+      && (num_sign_bit_copies (XEXP (XEXP (src, 0), 0),\n+\t\t\t       GET_MODE (XEXP (XEXP (src, 0), 0)))\n+\t  == GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (src, 0), 0))))\n+      && ! side_effects_p (src))\n+    {\n+      rtx true = (GET_CODE (XEXP (src, 0)) == NE\n+\t\t      ? XEXP (src, 1) : XEXP (src, 2));\n+      rtx false = (GET_CODE (XEXP (src, 0)) == NE\n+\t\t   ? XEXP (src, 2) : XEXP (src, 1));\n+      rtx term1 = const0_rtx, term2, term3;\n+\n+      if (GET_CODE (true) == IOR && rtx_equal_p (XEXP (true, 0), false))\n+\tterm1 = false, true = XEXP (true, 1), false = const0_rtx;\n+      else if (GET_CODE (true) == IOR\n+\t       && rtx_equal_p (XEXP (true, 1), false))\n+\tterm1 = false, true = XEXP (true, 0), false = const0_rtx;\n+      else if (GET_CODE (false) == IOR\n+\t       && rtx_equal_p (XEXP (false, 0), true))\n+\tterm1 = true, false = XEXP (false, 1), true = const0_rtx;\n+      else if (GET_CODE (false) == IOR\n+\t       && rtx_equal_p (XEXP (false, 1), true))\n+\tterm1 = true, false = XEXP (false, 0), true = const0_rtx;\n+\n+      term2 = gen_binary (AND, GET_MODE (src), XEXP (XEXP (src, 0), 0), true);\n+      term3 = gen_binary (AND, GET_MODE (src),\n+\t\t\t  gen_unary (NOT, GET_MODE (src),\n+\t\t\t\t     XEXP (XEXP (src, 0), 0)),\n+\t\t\t  false);\n+\n+      SUBST (SET_SRC (x),\n+\t     gen_binary (IOR, GET_MODE (src),\n+\t\t\t gen_binary (IOR, GET_MODE (src), term1, term2),\n+\t\t\t term3));\n+\n+      src = SET_SRC (x);\n+    }\n #endif\n-      break;\n \n+  return x;\n+}\n+\f\n+/* Simplify, X, and AND, IOR, or XOR operation, and return the simplified\n+   result.  LAST is nonzero if this is the last retry.  */\n+\n+static rtx\n+simplify_logical (x, last)\n+     rtx x;\n+     int last;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx op0 = XEXP (x, 0);\n+  rtx op1 = XEXP (x, 1);\n+\n+  switch (GET_CODE (x))\n+    {\n     case AND:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      /* Convert (A ^ B) & A to A & (~ B) since the latter is often a single\n+\t insn (and may simplify more).  */\n+      if (GET_CODE (op0) == XOR\n+\t  && rtx_equal_p (XEXP (op0, 0), op1)\n+\t  && ! side_effects_p (op1))\n+\tx = gen_binary (AND, mode, gen_unary (NOT, mode, XEXP (op0, 1)), op1);\n+\n+      if (GET_CODE (op0) == XOR\n+\t  && rtx_equal_p (XEXP (op0, 1), op1)\n+\t  && ! side_effects_p (op1))\n+\tx = gen_binary (AND, mode, gen_unary (NOT, mode, XEXP (op0, 0)), op1);\n+\n+      /* Similarly for (~ (A ^ B)) & A.  */\n+      if (GET_CODE (op0) == NOT\n+\t  && GET_CODE (XEXP (op0, 0)) == XOR\n+\t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), op1)\n+\t  && ! side_effects_p (op1))\n+\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n+\n+      if (GET_CODE (op0) == NOT\n+\t  && GET_CODE (XEXP (op0, 0)) == XOR\n+\t  && rtx_equal_p (XEXP (XEXP (op0, 0), 1), op1)\n+\t  && ! side_effects_p (op1))\n+\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n+\n+      if (GET_CODE (op1) == CONST_INT)\n \t{\n-\t  x = simplify_and_const_int (x, mode, XEXP (x, 0),\n-\t\t\t\t      INTVAL (XEXP (x, 1)));\n+\t  x = simplify_and_const_int (x, mode, op0, INTVAL (op1));\n \n \t  /* If we have (ior (and (X C1) C2)) and the next restart would be\n \t     the last, simplify this by making C1 as small as possible\n \t     and then exit. */\n-\t  if (n_restarts >= 3 && GET_CODE (x) == IOR\n-\t      && GET_CODE (XEXP (x, 0)) == AND\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t    {\n-\t      temp = gen_binary (AND, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t GEN_INT (INTVAL (XEXP (XEXP (x, 0), 1))\n-\t\t\t\t\t  & ~ INTVAL (XEXP (x, 1))));\n-\t      return gen_binary (IOR, mode, temp, XEXP (x, 1));\n-\t    }\n+\t  if (last\n+\t      && GET_CODE (x) == IOR && GET_CODE (op0) == AND\n+\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && GET_CODE (op1) == CONST_INT)\n+\t    return gen_binary (IOR, mode,\n+\t\t\t       gen_binary (AND, mode, XEXP (op0, 0),\n+\t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n+\t\t\t\t\t\t    & ~ INTVAL (op1))), op1);\n \n \t  if (GET_CODE (x) != AND)\n-\t    goto restart;\n+\t    return x;\n \t}\n \n       /* Convert (A | B) & A to A.  */\n-      if (GET_CODE (XEXP (x, 0)) == IOR\n-\t  && (rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n-\t      || rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 1)))\n-\t  && ! side_effects_p (XEXP (XEXP (x, 0), 0))\n-\t  && ! side_effects_p (XEXP (XEXP (x, 0), 1)))\n-\treturn XEXP (x, 1);\n-\n-      /* Convert (A ^ B) & A to A & (~ B) since the latter is often a single\n-\t insn (and may simplify more).  */\n-      else if (GET_CODE (XEXP (x, 0)) == XOR\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n-\t  && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode,\n-\t\t\t  gen_unary (NOT, mode, XEXP (XEXP (x, 0), 1)),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n-      else if (GET_CODE (XEXP (x, 0)) == XOR\n-\t       && rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 1))\n-\t       && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode,\n-\t\t\t  gen_unary (NOT, mode, XEXP (XEXP (x, 0), 0)),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n-\n-      /* Similarly for (~ (A ^ B)) & A.  */\n-      else if (GET_CODE (XEXP (x, 0)) == NOT\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == XOR\n-\t       && rtx_equal_p (XEXP (XEXP (XEXP (x, 0), 0), 0), XEXP (x, 1))\n-\t       && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode, XEXP (XEXP (XEXP (x, 0), 0), 1),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n-      else if (GET_CODE (XEXP (x, 0)) == NOT\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == XOR\n-\t       && rtx_equal_p (XEXP (XEXP (XEXP (x, 0), 0), 1), XEXP (x, 1))\n-\t       && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode, XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n+      if (GET_CODE (op0) == IOR\n+\t  && (rtx_equal_p (XEXP (op0, 0), op1)\n+\t      || rtx_equal_p (XEXP (op0, 1), op1))\n+\t  && ! side_effects_p (XEXP (op0, 0))\n+\t  && ! side_effects_p (XEXP (op0, 1)))\n+\treturn op1;\n \n       /* In the following group of tests (and those in case IOR below),\n \t we start with some combination of logical operations and apply\n@@ -4489,129 +4500,97 @@ subst (x, from, to, in_dest, unique_copy)\n \t For example, (and (ior A B) (not B)) can occur as the result of\n \t expanding a bit field assignment.  When we apply the distributive\n \t law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n-\t which then simplifies to (and (A (not B))).  */\n+\t which then simplifies to (and (A (not B))). \n \n-      /* If we have (and (ior A B) C), apply the distributive law and then\n+\t If we have (and (ior A B) C), apply the distributive law and then\n \t the inverse distributive law to see if things simplify.  */\n \n-      if (GET_CODE (XEXP (x, 0)) == IOR || GET_CODE (XEXP (x, 0)) == XOR)\n+      if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR)\n \t{\n \t  x = apply_distributive_law\n-\t    (gen_binary (GET_CODE (XEXP (x, 0)), mode,\n-\t\t\t gen_binary (AND, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (x, 1)),\n-\t\t\t gen_binary (AND, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 1), XEXP (x, 1))));\n+\t    (gen_binary (GET_CODE (op0), mode,\n+\t\t\t gen_binary (AND, mode, XEXP (op0, 0), op1),\n+\t\t\t gen_binary (AND, mode, XEXP (op0, 1), op1)));\n \t  if (GET_CODE (x) != AND)\n-\t    goto restart;\n+\t    return x;\n \t}\n \n-      if (GET_CODE (XEXP (x, 1)) == IOR || GET_CODE (XEXP (x, 1)) == XOR)\n-\t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (GET_CODE (XEXP (x, 1)), mode,\n-\t\t\t gen_binary (AND, mode,\n-\t\t\t\t     XEXP (XEXP (x, 1), 0), XEXP (x, 0)),\n-\t\t\t gen_binary (AND, mode,\n-\t\t\t\t     XEXP (XEXP (x, 1), 1), XEXP (x, 0))));\n-\t  if (GET_CODE (x) != AND)\n-\t    goto restart;\n-\t}\n+      if (GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (GET_CODE (op1), mode,\n+\t\t       gen_binary (AND, mode, XEXP (op1, 0), op0),\n+\t\t       gen_binary (AND, mode, XEXP (op1, 1), op0)));\n \n       /* Similarly, taking advantage of the fact that\n \t (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n \n-      if (GET_CODE (XEXP (x, 0)) == NOT && GET_CODE (XEXP (x, 1)) == XOR)\n-\t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (XOR, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t     XEXP (XEXP (x, 1), 0)),\n-\t\t\t gen_binary (IOR, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t     XEXP (XEXP (x, 1), 1))));\n-\t  if (GET_CODE (x) != AND)\n-\t    goto restart;\n-\t}\n+      if (GET_CODE (op0) == NOT && GET_CODE (op1) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (XOR, mode,\n+\t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 0)),\n+\t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 1))));\n \t\t\t\t\t\t\t    \n-      else if (GET_CODE (XEXP (x, 1)) == NOT && GET_CODE (XEXP (x, 0)) == XOR)\n-\t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (XOR, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (XEXP (x, 1), 0),\n-\t\t\t\t     XEXP (XEXP (x, 0), 0)),\n-\t\t\t gen_binary (IOR, mode, XEXP (XEXP (x, 1), 0),\n-\t\t\t\t     XEXP (XEXP (x, 0), 1))));\n-\t  if (GET_CODE (x) != AND)\n-\t    goto restart;\n-\t}\n+      else if (GET_CODE (op1) == NOT && GET_CODE (op0) == XOR)\n+\treturn apply_distributive_law\n+\t  (gen_binary (XOR, mode,\n+\t\t       gen_binary (IOR, mode, XEXP (op1, 0), XEXP (op0, 0)),\n+\t\t       gen_binary (IOR, mode, XEXP (op1, 0), XEXP (op0, 1))));\n       break;\n \n     case IOR:\n       /* (ior A C) is C if all bits of A that might be nonzero are on in C.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (GET_CODE (op1) == CONST_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (XEXP (x, 0), mode) & ~ INTVAL (XEXP (x, 1))) == 0)\n-\treturn XEXP (x, 1);\n+\t  && (nonzero_bits (op0, mode) & ~ INTVAL (op1)) == 0)\n+\treturn op1;\n \n       /* Convert (A & B) | A to A.  */\n-      if (GET_CODE (XEXP (x, 0)) == AND\n-\t  && (rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n-\t      || rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 1)))\n-\t  && ! side_effects_p (XEXP (XEXP (x, 0), 0))\n-\t  && ! side_effects_p (XEXP (XEXP (x, 0), 1)))\n-\treturn XEXP (x, 1);\n+      if (GET_CODE (op0) == AND\n+\t  && (rtx_equal_p (XEXP (op0, 0), op1)\n+\t      || rtx_equal_p (XEXP (op0, 1), op1))\n+\t  && ! side_effects_p (XEXP (op0, 0))\n+\t  && ! side_effects_p (XEXP (op0, 1)))\n+\treturn op1;\n \n       /* If we have (ior (and A B) C), apply the distributive law and then\n \t the inverse distributive law to see if things simplify.  */\n \n-      if (GET_CODE (XEXP (x, 0)) == AND)\n+      if (GET_CODE (op0) == AND)\n \t{\n \t  x = apply_distributive_law\n \t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (x, 1)),\n-\t\t\t gen_binary (IOR, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 1), XEXP (x, 1))));\n+\t\t\t gen_binary (IOR, mode, XEXP (op0, 0), op1),\n+\t\t\t gen_binary (IOR, mode, XEXP (op0, 1), op1)));\n \n \t  if (GET_CODE (x) != IOR)\n-\t    goto restart;\n+\t    return x;\n \t}\n \n-      if (GET_CODE (XEXP (x, 1)) == AND)\n+      if (GET_CODE (op1) == AND)\n \t{\n \t  x = apply_distributive_law\n \t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode,\n-\t\t\t\t     XEXP (XEXP (x, 1), 0), XEXP (x, 0)),\n-\t\t\t gen_binary (IOR, mode,\n-\t\t\t\t     XEXP (XEXP (x, 1), 1), XEXP (x, 0))));\n+\t\t\t gen_binary (IOR, mode, XEXP (op1, 0), op0),\n+\t\t\t gen_binary (IOR, mode, XEXP (op1, 1), op0)));\n \n \t  if (GET_CODE (x) != IOR)\n-\t    goto restart;\n+\t    return x;\n \t}\n \n       /* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the\n \t mode size to (rotate A CX).  */\n \n-      if (((GET_CODE (XEXP (x, 0)) == ASHIFT\n-\t    && GET_CODE (XEXP (x, 1)) == LSHIFTRT)\n-\t   || (GET_CODE (XEXP (x, 1)) == ASHIFT\n-\t       && GET_CODE (XEXP (x, 0)) == LSHIFTRT))\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 1), 0))\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n-\t  && (INTVAL (XEXP (XEXP (x, 0), 1)) + INTVAL (XEXP (XEXP (x, 1), 1))\n+      if (((GET_CODE (op0) == ASHIFT && GET_CODE (op1) == LSHIFTRT)\n+\t   || (GET_CODE (op1) == ASHIFT && GET_CODE (op0) == LSHIFTRT))\n+\t  && rtx_equal_p (XEXP (op0, 0), XEXP (op1, 0))\n+\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (op0, 1)) + INTVAL (XEXP (op1, 1))\n \t      == GET_MODE_BITSIZE (mode)))\n-\t{\n-\t  rtx shift_count;\n+\treturn gen_rtx (ROTATE, mode, XEXP (op0, 0),\n+\t\t\t(GET_CODE (op0) == ASHIFT\n+\t\t\t ? XEXP (op0, 1) : XEXP (op1, 1)));\n \n-\t  if (GET_CODE (XEXP (x, 0)) == ASHIFT)\n-\t    shift_count = XEXP (XEXP (x, 0), 1);\n-\t  else\n-\t    shift_count = XEXP (XEXP (x, 1), 1);\n-\t  x = gen_rtx (ROTATE, mode, XEXP (XEXP (x, 0), 0), shift_count);\n-\t  goto restart;\n-\t}\n       break;\n \n     case XOR:\n@@ -4620,146 +4599,67 @@ subst (x, from, to, in_dest, unique_copy)\n \t (NOT y).  */\n       {\n \tint num_negated = 0;\n-\trtx in1 = XEXP (x, 0), in2 = XEXP (x, 1);\n \n-\tif (GET_CODE (in1) == NOT)\n-\t  num_negated++, in1 = XEXP (in1, 0);\n-\tif (GET_CODE (in2) == NOT)\n-\t  num_negated++, in2 = XEXP (in2, 0);\n+\tif (GET_CODE (op0) == NOT)\n+\t  num_negated++, op0 = XEXP (op0, 0);\n+\tif (GET_CODE (op1) == NOT)\n+\t  num_negated++, op1 = XEXP (op1, 0);\n \n \tif (num_negated == 2)\n \t  {\n-\t    SUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n-\t    SUBST (XEXP (x, 1), XEXP (XEXP (x, 1), 0));\n+\t    SUBST (XEXP (x, 0), op0);\n+\t    SUBST (XEXP (x, 1), op1);\n \t  }\n \telse if (num_negated == 1)\n-\t  {\n-\t    x =  gen_unary (NOT, mode,\n-\t\t\t    gen_binary (XOR, mode, in1, in2));\n-\t    goto restart;\n-\t  }\n+\t  return gen_unary (NOT, mode, gen_binary (XOR, mode, op0, op1));\n       }\n \n       /* Convert (xor (and A B) B) to (and (not A) B).  The latter may\n \t correspond to a machine insn or result in further simplifications\n \t if B is a constant.  */\n \n-      if (GET_CODE (XEXP (x, 0)) == AND\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 1))\n-\t  && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode,\n-\t\t\t  gen_unary (NOT, mode, XEXP (XEXP (x, 0), 0)),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n-      else if (GET_CODE (XEXP (x, 0)) == AND\n-\t       && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n-\t       && ! side_effects_p (XEXP (x, 1)))\n-\t{\n-\t  x = gen_binary (AND, mode,\n-\t\t\t  gen_unary (NOT, mode, XEXP (XEXP (x, 0), 1)),\n-\t\t\t  XEXP (x, 1));\n-\t  goto restart;\n-\t}\n+      if (GET_CODE (op0) == AND\n+\t  && rtx_equal_p (XEXP (op0, 1), op1)\n+\t  && ! side_effects_p (op1))\n+\treturn gen_binary (AND, mode, gen_unary (NOT, mode, XEXP (op0, 0)),\n+\t\t\t   op1);\n \n+      else if (GET_CODE (op0) == AND\n+\t       && rtx_equal_p (XEXP (op0, 0), op1)\n+\t       && ! side_effects_p (op1))\n+\treturn gen_binary (AND, mode, gen_unary (NOT, mode, XEXP (op0, 1)),\n+\t\t\t   op1);\n \n #if STORE_FLAG_VALUE == 1\n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n \t comparison.  */\n-      if (XEXP (x, 1) == const1_rtx\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0)))\n-\treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\tXEXP (XEXP (x, 0), 1));\n+      if (op1 == const1_rtx\n+\t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n+\t  && reversible_comparison_p (op0))\n+\treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n+\t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n \n       /* (lshiftrt foo C) where C is the number of bits in FOO minus 1\n \t is (lt foo (const_int 0)), so we can perform the above\n \t simplification.  */\n \n-      if (XEXP (x, 1) == const1_rtx\n-\t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\treturn gen_rtx_combine (GE, mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n+      if (op1 == const1_rtx\n+\t  && GET_CODE (op0) == LSHIFTRT\n+\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (op0, 1)) == GET_MODE_BITSIZE (mode) - 1)\n+\treturn gen_rtx_combine (GE, mode, XEXP (op0, 0), const0_rtx);\n #endif\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (STORE_FLAG_VALUE\n \t      == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n-\t  && XEXP (x, 1) == const_true_rtx\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0)))\n-\treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\tXEXP (XEXP (x, 0), 1));\n-      break;\n-\n-    case ABS:\n-      /* (abs (neg <foo>)) -> (abs <foo>) */\n-      if (GET_CODE (XEXP (x, 0)) == NEG)\n-\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n-\n-      /* If operand is something known to be positive, ignore the ABS.  */\n-      if (GET_CODE (XEXP (x, 0)) == FFS || GET_CODE (XEXP (x, 0)) == ABS\n-\t  || ((GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n-\t       <= HOST_BITS_PER_WIDE_INT)\n-\t      && ((nonzero_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t\t   & ((HOST_WIDE_INT) 1\n-\t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n-\t\t  == 0)))\n-\treturn XEXP (x, 0);\n-\n-\n-      /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n-      if (num_sign_bit_copies (XEXP (x, 0), mode) == GET_MODE_BITSIZE (mode))\n-\t{\n-\t  x = gen_rtx_combine (NEG, mode, XEXP (x, 0));\n-\t  goto restart;\n-\t}\n-      break;\n-\n-    case FFS:\n-      /* (ffs (*_extend <X>)) = (ffs <X>) */\n-      if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n-\t  || GET_CODE (XEXP (x, 0)) == ZERO_EXTEND)\n-\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n-      break;\n-\n-    case FLOAT:\n-      /* (float (sign_extend <X>)) = (float <X>).  */\n-      if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n-\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n-      break;\n-\n-    case LSHIFT:\n-    case ASHIFT:\n-    case LSHIFTRT:\n-    case ASHIFTRT:\n-    case ROTATE:\n-    case ROTATERT:\n-      /* If this is a shift by a constant amount, simplify it.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  x = simplify_shift_const (x, code, mode, XEXP (x, 0), \n-\t\t\t\t    INTVAL (XEXP (x, 1)));\n-\t  if (GET_CODE (x) != code)\n-\t    goto restart;\n-\t}\n-\n-#ifdef SHIFT_COUNT_TRUNCATED\n-      else if (SHIFT_COUNT_TRUNCATED && GET_CODE (XEXP (x, 1)) != REG)\n-\tSUBST (XEXP (x, 1),\n-\t       force_to_mode (XEXP (x, 1), GET_MODE (x),\n-\t\t\t      ((HOST_WIDE_INT) 1 \n-\t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n-\t\t\t      - 1,\n-\t\t\t      NULL_RTX, 0));\n-#endif\n-\n+\t  && op1 == const_true_rtx\n+\t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n+\t  && reversible_comparison_p (op0))\n+\treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n+\t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n       break;\n     }\n \n@@ -4804,7 +4704,16 @@ expand_compound_operation (x)\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \treturn x;\n \n-      if (! FAKE_EXTEND_SAFE_P (GET_MODE (XEXP (x, 0)), XEXP (x, 0)))\n+      /* Return if (subreg:MODE FROM 0) is not a safe replacement for\n+\t (zero_extend:MODE FROM) or (sign_extend:MODE FROM).  It is for any MEM\n+\t because (SUBREG (MEM...)) is guaranteed to cause the MEM to be\n+\t reloaded. If not for that, MEM's would very rarely be safe.\n+\n+\t Reject MODEs bigger than a word, because we might not be able\n+\t to reference a two-register group starting with an arbitrary register\n+\t (and currently gen_lowpart might crash for a SUBREG).  */\n+  \n+      if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) > UNITS_PER_WORD)\n \treturn x;\n \n       len = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)));"}]}