{"sha": "e129b3f9512d0f842df00ea9f08c06011cae7926", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEyOWIzZjk1MTJkMGY4NDJkZjAwZWE5ZjA4YzA2MDExY2FlNzkyNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-04-01T22:32:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-04-01T22:32:37Z"}, "message": "re PR fortran/9974 (Test g77.f-torture/noncompile/check0.f fails)\n\n\n\tPR fortran/9974\n\t* gcse.c (reg_killed_on_egde): New function to test whether the\n\tgiven reg is overwritten by any instruction queued on an edge.\n\t(bypass_block): Ignore substitutions killed on incoming edges.\n\tDon't bypass outgoing edges that have queued instructions.\n\n\t* gcc.c-torture/execute/20030401-1.c: New test case.\n\nFrom-SVN: r65148", "tree": {"sha": "6afdbb92ab2cb0aed6d61ceda0f1ab8ccab13025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6afdbb92ab2cb0aed6d61ceda0f1ab8ccab13025"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e129b3f9512d0f842df00ea9f08c06011cae7926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e129b3f9512d0f842df00ea9f08c06011cae7926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e129b3f9512d0f842df00ea9f08c06011cae7926", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e129b3f9512d0f842df00ea9f08c06011cae7926/comments", "author": null, "committer": null, "parents": [{"sha": "70ab763c5b138f42662a054941d19fa064ac951c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ab763c5b138f42662a054941d19fa064ac951c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ab763c5b138f42662a054941d19fa064ac951c"}], "stats": {"total": 93, "additions": 89, "deletions": 4}, "files": [{"sha": "2fa9ef5cbbd731a1b5ca831401aceba797b402c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e129b3f9512d0f842df00ea9f08c06011cae7926", "patch": "@@ -1,3 +1,11 @@\n+2003-04-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/9974\n+\t* gcse.c (reg_killed_on_egde): New function to test whether the\n+\tgiven reg is overwritten by any instruction queued on an edge.\n+\t(bypass_block): Ignore substitutions killed on incoming edges.\n+\tDon't bypass outgoing edges that have queued instructions.\n+\n 2003-04-01  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* real.h (EXP_BITS): Make room for..."}, {"sha": "e7a6845581d3cc81bb263286cae0811ab6b51098", "filename": "gcc/gcse.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e129b3f9512d0f842df00ea9f08c06011cae7926", "patch": "@@ -624,6 +624,7 @@ static void find_implicit_sets\tPARAMS ((void));\n static int one_cprop_pass\tPARAMS ((int, int, int));\n static bool constprop_register\tPARAMS ((rtx, rtx, rtx, int));\n static struct expr *find_bypass_set PARAMS ((int, int));\n+static bool reg_killed_on_edge\t    PARAMS ((rtx, edge));\n static int bypass_block\t\t    PARAMS ((basic_block, rtx, rtx));\n static int bypass_conditional_jumps PARAMS ((void));\n static void alloc_pre_mem\tPARAMS ((int, int));\n@@ -4768,19 +4769,43 @@ find_bypass_set (regno, bb)\n }\n \n \n+/* Subroutine of bypass_block that checks whether a pseudo is killed by\n+   any of the instructions inserted on an edge.  Jump bypassing places\n+   condition code setters on CFG edges using insert_insn_on_edge.  This\n+   function is required to check that our data flow analysis is still\n+   valid prior to commit_edge_insertions.  */\n+\n+static bool\n+reg_killed_on_edge (reg, e)\n+     rtx reg;\n+     edge e;\n+{\n+  rtx insn;\n+\n+  for (insn = e->insns; insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && reg_set_p (reg, insn))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Subroutine of bypass_conditional_jumps that attempts to bypass the given\n    basic block BB which has more than one predecessor.  If not NULL, SETCC\n    is the first instruction of BB, which is immediately followed by JUMP_INSN\n    JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.\n-   Returns nonzero if a change was made.  */\n+   Returns nonzero if a change was made.\n+\n+   During the jump bypassing pass, we may place copies of SETCC instuctions\n+   on CFG edges.  The following routine must be careful to pay attention to\n+   these inserted insns when performing its transformations.  */\n \n static int\n bypass_block (bb, setcc, jump)\n      basic_block bb;\n      rtx setcc, jump;\n {\n   rtx insn, note;\n-  edge e, enext;\n+  edge e, enext, edest;\n   int i, change;\n   int may_be_loop_header;\n \n@@ -4835,6 +4860,10 @@ bypass_block (bb, setcc, jump)\n \t  if (! set)\n \t    continue;\n \n+\t  /* Check the data flow is valid after edge insertions.  */\n+\t  if (e->insns && reg_killed_on_edge (reg_used->reg_rtx, e))\n+\t    continue;\n+\n \t  src = SET_SRC (pc_set (jump));\n \n \t  if (setcc != NULL)\n@@ -4845,10 +4874,27 @@ bypass_block (bb, setcc, jump)\n \t  new = simplify_replace_rtx (src, reg_used->reg_rtx,\n \t\t\t\t      SET_SRC (set->expr));\n \n+\t  /* Jump bypassing may have already placed instructions on \n+\t     edges of the CFG.  We can't bypass an outgoing edge that\n+\t     has instructions associated with it, as these insns won't\n+\t     get executed if the incoming edge is redirected.  */\n+\n \t  if (new == pc_rtx)\n-\t    dest = FALLTHRU_EDGE (bb)->dest;\n+\t    {\n+\t      edest = FALLTHRU_EDGE (bb);\n+\t      dest = edest->insns ? NULL : edest->dest;\n+\t    }\n \t  else if (GET_CODE (new) == LABEL_REF)\n-\t    dest = BLOCK_FOR_INSN (XEXP (new, 0));\n+\t    {\n+\t      dest = BLOCK_FOR_INSN (XEXP (new, 0));\n+\t      /* Don't bypass edges containing instructions.  */\n+\t      for (edest = bb->succ; edest; edest = edest->succ_next)\n+\t\tif (edest->dest == dest && edest->insns)\n+\t\t  {\n+\t\t    dest = NULL;\n+\t\t    break;\n+\t\t  }\n+\t    }\n \t  else\n \t    dest = NULL;\n "}, {"sha": "bf5d4aa458c44affae10b0df7e4c08d06cc3abd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e129b3f9512d0f842df00ea9f08c06011cae7926", "patch": "@@ -1,3 +1,7 @@\n+2003-04-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/20030401-1.c: New test case.\n+\n 2003-04-01  Ziemowit Laski <zlaski@apple.com>\n \n \t* objc.dg/defs.m: New."}, {"sha": "0cc144a8560574226944f4dd110107e971a9c72a", "filename": "gcc/testsuite/gcc.c-torture/execute/20030401-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030401-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129b3f9512d0f842df00ea9f08c06011cae7926/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030401-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030401-1.c?ref=e129b3f9512d0f842df00ea9f08c06011cae7926", "patch": "@@ -0,0 +1,27 @@\n+/* Testcase for PR fortran/9974.  This was a miscompilation of the g77\n+   front-end caused by the jump bypassing optimizations not handling\n+   instructions inserted on CFG edges.  */\n+\n+extern void abort ();\n+\n+int bar ()\n+{\n+  return 1;\n+}\n+\n+void foo (int x)\n+{\n+  unsigned char error = 0;\n+\n+  if (! (error = ((x == 0) || bar ())))\n+    bar ();\n+  if (! error)\n+    abort ();\n+}\n+\n+int main()\n+{\n+  foo (1);\n+  return 0;\n+}\n+  "}]}