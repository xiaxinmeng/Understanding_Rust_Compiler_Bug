{"sha": "f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwYTZjNTdmMGYyNmQ5YzYwZDZkNjE4MmYxZTIxODFmNzI3YzgzNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T17:19:48Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T17:19:48Z"}, "message": "Implement three-level optimize_for_size predicates\n\nthis patch implements thre two-state optimize_for_size predicates, so with -Os\nand with profile feedback for never executed code it returns OPTIMIZE_SIZE_MAX\nwhile in cases we decide to optimize for size based on branch prediction logic\nit return OPTIMIZE_SIZE_BALLANCED.\n\nThe idea is that for places where we guess that code is unlikely we do not\nwant to do extreme optimizations for size that leads to many fold slowdowns\n(using idiv rather than few shigts or using rep based inlined stringops).\n\nI will update RTL handling code to also support this with BB granuality (which\nwe don't currently).  LLVM has -Os and -Oz levels where -Oz is our -Os and\nLLVM's -Os would ocrrespond to OPTIMIZE_SIZE_BALLANCED.  I wonder if we want\nto export this to command line somehow?  For me it would be definitly useful\nto test things, I am not sure how \"weaker\" -Os is desired in practice.\n\ngcc/ChangeLog:\n\n\t* cgraph.h (cgraph_node::optimize_for_size_p): Return\n\toptimize_size_level.\n\t(cgraph_node::optimize_for_size_p): Update.\n\t* coretypes.h (enum optimize_size_level): New enum.\n\t* predict.c (unlikely_executed_edge_p): Microoptimize.\n\t(optimize_function_for_size_p): Return optimize_size_level.\n\t(optimize_bb_for_size_p): Likewise.\n\t(optimize_edge_for_size_p): Likewise.\n\t(optimize_insn_for_size_p): Likewise.\n\t(optimize_loop_nest_for_size_p): Likewise.\n\t* predict.h (optimize_function_for_size_p): Update declaration.\n\t(optimize_bb_for_size_p): Update declaration.\n\t(optimize_edge_for_size_p): Update declaration.\n\t(optimize_insn_for_size_p): Update declaration.\n\t(optimize_loop_for_size_p): Update declaration.\n\t(optimize_loop_nest_for_size_p): Update declaration.", "tree": {"sha": "27c496c30e568070afa9a437c707bd911b31db10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27c496c30e568070afa9a437c707bd911b31db10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/comments", "author": null, "committer": null, "parents": [{"sha": "63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b2149fb4b0bd16c44ab9485cfdc37149e97b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b2149fb4b0bd16c44ab9485cfdc37149e97b97"}], "stats": {"total": 101, "additions": 76, "deletions": 25}, "files": [{"sha": "fb3ad95e064590cadad4c7fc6fb5f4b1bf709c08", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "patch": "@@ -1279,7 +1279,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   bool check_calls_comdat_local_p ();\n \n   /* Return true if function should be optimized for size.  */\n-  bool optimize_for_size_p (void);\n+  enum optimize_size_level optimize_for_size_p (void);\n \n   /* Dump the callgraph to file F.  */\n   static void dump_cgraph (FILE *f);\n@@ -3315,15 +3315,17 @@ cgraph_node::mark_force_output (void)\n \n /* Return true if function should be optimized for size.  */\n \n-inline bool\n+inline enum optimize_size_level\n cgraph_node::optimize_for_size_p (void)\n {\n   if (opt_for_fn (decl, optimize_size))\n-    return true;\n+    return OPTIMIZE_SIZE_MAX;\n+  if (count == profile_count::zero ())\n+    return OPTIMIZE_SIZE_MAX;\n   if (frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-    return true;\n+    return OPTIMIZE_SIZE_BALANCED;\n   else\n-    return false;\n+    return OPTIMIZE_SIZE_NO;\n }\n \n /* Return symtab_node for NODE or create one if it is not present"}, {"sha": "da178b6a9f61621fe7a6468dac5a2a9d64285ca6", "filename": "gcc/coretypes.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "patch": "@@ -444,6 +444,18 @@ enum excess_precision_type\n   EXCESS_PRECISION_TYPE_FAST\n };\n \n+/* Level of size optimization.  */\n+\n+enum optimize_size_level\n+{\n+  /* Do not optimize for size.  */\n+  OPTIMIZE_SIZE_NO,\n+  /* Optimize for size but not at extreme performance costs.  */\n+  OPTIMIZE_SIZE_BALANCED,\n+  /* Optimize for size as much as possible.  */\n+  OPTIMIZE_SIZE_MAX\n+};\n+\n /* Support for user-provided GGC and PCH markers.  The first parameter\n    is a pointer to a pointer, the second a cookie.  */\n typedef void (*gt_pointer_operator) (void *, void *);"}, {"sha": "361c4019eec0b9526027bd348b59e0a32ca30a54", "filename": "gcc/predict.c", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "patch": "@@ -243,7 +243,7 @@ probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n static bool\n unlikely_executed_edge_p (edge e)\n {\n-  return (e->count () == profile_count::zero ()\n+  return (e->src->count == profile_count::zero ()\n \t  || e->probability == profile_probability::never ())\n \t || (e->flags & (EDGE_EH | EDGE_FAKE));\n }\n@@ -260,13 +260,15 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n \n /* Return true if function FUN should always be optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_function_for_size_p (struct function *fun)\n {\n   if (!fun || !fun->decl)\n-    return optimize_size;\n+    return optimize_size ? OPTIMIZE_SIZE_MAX : OPTIMIZE_SIZE_NO;\n   cgraph_node *n = cgraph_node::get (fun->decl);\n-  return n && n->optimize_for_size_p ();\n+  if (n)\n+    return n->optimize_for_size_p ();\n+  return OPTIMIZE_SIZE_NO;\n }\n \n /* Return true if function FUN should always be optimized for speed.  */\n@@ -289,11 +291,16 @@ function_optimization_type (struct function *fun)\n \n /* Return TRUE if basic block BB should be optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_bb_for_size_p (const_basic_block bb)\n {\n-  return (optimize_function_for_size_p (cfun)\n-\t  || (bb && !maybe_hot_bb_p (cfun, bb)));\n+  enum optimize_size_level ret = optimize_function_for_size_p (cfun);\n+\n+  if (bb && ret < OPTIMIZE_SIZE_MAX && bb->count == profile_count::zero ())\n+    ret = OPTIMIZE_SIZE_MAX;\n+  if (bb && ret < OPTIMIZE_SIZE_BALANCED && !maybe_hot_bb_p (cfun, bb))\n+    ret = OPTIMIZE_SIZE_BALANCED;\n+  return ret;\n }\n \n /* Return TRUE if basic block BB should be optimized for speed.  */\n@@ -316,10 +323,16 @@ bb_optimization_type (const_basic_block bb)\n \n /* Return TRUE if edge E should be optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_edge_for_size_p (edge e)\n {\n-  return optimize_function_for_size_p (cfun) || !maybe_hot_edge_p (e);\n+  enum optimize_size_level ret = optimize_function_for_size_p (cfun);\n+\n+  if (ret < OPTIMIZE_SIZE_MAX && unlikely_executed_edge_p (e))\n+    ret = OPTIMIZE_SIZE_MAX;\n+  if (ret < OPTIMIZE_SIZE_BALANCED && !maybe_hot_edge_p (e))\n+    ret = OPTIMIZE_SIZE_BALANCED;\n+  return ret;\n }\n \n /* Return TRUE if edge E should be optimized for speed.  */\n@@ -332,10 +345,13 @@ optimize_edge_for_speed_p (edge e)\n \n /* Return TRUE if the current function is optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_insn_for_size_p (void)\n {\n-  return optimize_function_for_size_p (cfun) || !crtl->maybe_hot_insn_p;\n+  enum optimize_size_level ret = optimize_function_for_size_p (cfun);\n+  if (ret < OPTIMIZE_SIZE_BALANCED && !crtl->maybe_hot_insn_p)\n+    ret = OPTIMIZE_SIZE_BALANCED;\n+  return ret;\n }\n \n /* Return TRUE if the current function is optimized for speed.  */\n@@ -348,7 +364,7 @@ optimize_insn_for_speed_p (void)\n \n /* Return TRUE if LOOP should be optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_loop_for_size_p (class loop *loop)\n {\n   return optimize_bb_for_size_p (loop->header);\n@@ -392,10 +408,31 @@ optimize_loop_nest_for_speed_p (class loop *loop)\n \n /* Return TRUE if nest rooted at LOOP should be optimized for size.  */\n \n-bool\n+optimize_size_level\n optimize_loop_nest_for_size_p (class loop *loop)\n {\n-  return !optimize_loop_nest_for_speed_p (loop);\n+  enum optimize_size_level ret = optimize_loop_for_size_p (loop);\n+  class loop *l = loop;\n+\n+  l = loop->inner;\n+  while (l && l != loop)\n+    {\n+      if (ret == OPTIMIZE_SIZE_NO)\n+\tbreak;\n+      ret = MIN (optimize_loop_for_size_p (l), ret);\n+      if (l->inner)\n+        l = l->inner;\n+      else if (l->next)\n+        l = l->next;\n+      else\n+        {\n+\t  while (l != loop && !l->next)\n+\t    l = loop_outer (l);\n+\t  if (l != loop)\n+\t    l = l->next;\n+\t}\n+    }\n+  return ret;\n }\n \n /* Return true if edge E is likely to be well predictable by branch"}, {"sha": "b64d2098ab02fdc794c3da137481306b5ef24a42", "filename": "gcc/predict.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20a6c57f0f26d9c60d6d6182f1e2181f727c834/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "patch": "@@ -58,20 +58,20 @@ extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n extern bool maybe_hot_edge_p (edge);\n extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n extern bool probably_never_executed_edge_p (struct function *, edge);\n-extern bool optimize_function_for_size_p (struct function *);\n+extern enum optimize_size_level optimize_function_for_size_p (struct function *);\n extern bool optimize_function_for_speed_p (struct function *);\n extern optimization_type function_optimization_type (struct function *);\n-extern bool optimize_bb_for_size_p (const_basic_block);\n+extern enum optimize_size_level optimize_bb_for_size_p (const_basic_block);\n extern bool optimize_bb_for_speed_p (const_basic_block);\n extern optimization_type bb_optimization_type (const_basic_block);\n-extern bool optimize_edge_for_size_p (edge);\n+extern enum optimize_size_level optimize_edge_for_size_p (edge);\n extern bool optimize_edge_for_speed_p (edge);\n-extern bool optimize_insn_for_size_p (void);\n+extern enum optimize_size_level optimize_insn_for_size_p (void);\n extern bool optimize_insn_for_speed_p (void);\n-extern bool optimize_loop_for_size_p (class loop *);\n+extern enum optimize_size_level optimize_loop_for_size_p (class loop *);\n extern bool optimize_loop_for_speed_p (class loop *);\n extern bool optimize_loop_nest_for_speed_p (class loop *);\n-extern bool optimize_loop_nest_for_size_p (class loop *);\n+extern enum optimize_size_level optimize_loop_nest_for_size_p (class loop *);\n extern bool predictable_edge_p (edge);\n extern void rtl_profile_for_bb (basic_block);\n extern void rtl_profile_for_edge (edge);"}]}