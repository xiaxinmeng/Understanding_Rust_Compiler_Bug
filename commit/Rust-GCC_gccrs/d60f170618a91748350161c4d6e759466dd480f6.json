{"sha": "d60f170618a91748350161c4d6e759466dd480f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwZjE3MDYxOGE5MTc0ODM1MDE2MWM0ZDZlNzU5NDY2ZGQ0ODBmNg==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-06-07T17:41:52Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-06-07T17:41:52Z"}, "message": "Moved array notation helper functions from c/ to c-family/ files.\n\n2013-06-07  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-array-notation.c (length_mismatch_in_expr_p): Moved this\n        function to c-family/array-notation-common.c.\n        (is_cilkplus_reduce_builtin): Likewise.\n        (find_rank): Likewise.\n        (extract_array_notation_exprs): Likewise.\n        (replace_array_notations): Likewise.\n        (find_inv_trees): Likewise.\n        (replace_inv_trees): Likewise.\n        (contains_array_notation_expr): Likewise.\n        (find_correct_array_notation_type): Likewise.\n        (replace_invariant_exprs): Initialized additional_tcodes to NULL.\n        (struct inv_list): Moved this to c-family/array-notation-common.c.\n        * c-tree.h (is_cilkplus_builtin_reduce): Remove prototype.\n\n2013-06-07  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * array-notation-common.c (length_mismatch_in_expr_p): Moved this\n        function from c/c-array-notation.c.\n        (is_cilkplus_reduce_builtin): Likewise.\n        (find_rank): Likewise.\n        (extract_array_notation_exprs): Likewise.\n        (replace_array_notations): Likewise.\n        (find_inv_trees): Likewise.\n        (replace_inv_trees): Likewise.\n        (contains_array_notation_expr): Likewise.\n        (find_correct_array_notation_type): Likewise.\n        * c-common.h (struct inv_list): Moved this struct from the file\n        c/c-array-notation.c and added a new field called additional tcodes.\n        (length_mismatch_in_expr_p): New prototype.\n        (is_cilkplus_reduce_builtin): Likewise.\n        (find_rank): Likewise.\n        (extract_array_notation_exprs): Likewise.\n        (replace_array_notation): Likewise.\n        (find_inv_trees): Likewise.\n        (replace_inv_trees): Likewise.\n\nFrom-SVN: r199825", "tree": {"sha": "5060dc228092332f439762b5a2364429d3fc32c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5060dc228092332f439762b5a2364429d3fc32c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60f170618a91748350161c4d6e759466dd480f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60f170618a91748350161c4d6e759466dd480f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60f170618a91748350161c4d6e759466dd480f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60f170618a91748350161c4d6e759466dd480f6/comments", "author": null, "committer": null, "parents": [{"sha": "cf28fab6bcd3a7d53f84ca16adad1da424769273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf28fab6bcd3a7d53f84ca16adad1da424769273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf28fab6bcd3a7d53f84ca16adad1da424769273"}], "stats": {"total": 1044, "additions": 549, "deletions": 495}, "files": [{"sha": "aaa1b76f19ba8ec89e59f92c645bf6aec9baff4d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -1,3 +1,26 @@\n+2013-06-07  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* array-notation-common.c (length_mismatch_in_expr_p): Moved this\n+\tfunction from c/c-array-notation.c.\n+\t(is_cilkplus_reduce_builtin): Likewise.\n+\t(find_rank): Likewise.\n+\t(extract_array_notation_exprs): Likewise.\n+\t(replace_array_notations): Likewise.\n+\t(find_inv_trees): Likewise.\n+\t(replace_inv_trees): Likewise.\n+\t(contains_array_notation_expr): Likewise.\n+\t(find_correct_array_notation_type): Likewise.\n+\t* c-common.h (struct inv_list): Moved this struct from the file\n+\tc/c-array-notation.c and added a new field called additional tcodes.\n+\t(length_mismatch_in_expr_p): New prototype.\n+\t(is_cilkplus_reduce_builtin): Likewise.\n+\t(find_rank): Likewise.\n+\t(extract_array_notation_exprs): Likewise.\n+\t(replace_array_notation): Likewise.\n+\t(find_inv_trees): Likewise.\n+\t(replace_inv_trees): Likewise.\n+\t(find_correct_array_notation_type): Likewise.\n+\t\n 2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-common.c (c_define_builtins): When cilkplus is enabled, the"}, {"sha": "489b67cafb9a09f32c4164e38c3b9e6dab608861", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 487, "deletions": 1, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -27,9 +27,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"langhooks.h\" \n #include \"tree-iterator.h\"\n+#include \"c-family/c-common.h\"\n #include \"diagnostic-core.h\"\n \n-\n /* Returns true if the function call in FNDECL is  __sec_implicit_index.  */\n \n bool\n@@ -74,3 +74,489 @@ extract_sec_implicit_index_arg (location_t location, tree fn)\n     }\n   return return_int;\n }\n+\n+/* Returns true if there is length mismatch among expressions\n+   on the same dimension and on the same side of the equal sign.  The\n+   expressions (or ARRAY_NOTATION lengths) are passed in through 2-D array\n+   **LIST where X and Y indicate first and second dimension sizes of LIST,\n+   respectively.  */\n+\n+bool\n+length_mismatch_in_expr_p (location_t loc, tree **list, size_t x, size_t y)\n+{\n+  size_t ii, jj;\n+  tree start = NULL_TREE;\n+  HOST_WIDE_INT l_start, l_node;\n+  for (jj = 0; jj < y; jj++)\n+    {\n+      start = NULL_TREE;\n+      for (ii = 0; ii < x; ii++)\n+\t{\n+\t  if (!start)\n+\t    start = list[ii][jj];\n+\t  else if (TREE_CODE (start) == INTEGER_CST)\n+\t    {\n+\t      /* If start is a INTEGER, and list[ii][jj] is an integer then\n+\t\t check if they are equal.  If they are not equal then return\n+\t\t true.  */\n+\t      if (TREE_CODE (list[ii][jj]) == INTEGER_CST)\n+\t\t{\n+\t\t  l_node = int_cst_value (list[ii][jj]);\n+\t\t  l_start = int_cst_value (start);\n+\t\t  if (absu_hwi (l_start) != absu_hwi (l_node))\n+\t\t    {\n+\t\t      error_at (loc, \"length mismatch in expression\");\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* We set the start node as the current node just in case it turns\n+\t       out to be an integer.  */\n+\t    start = list[ii][jj];\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Given an FNDECL of type FUNCTION_DECL or ADDR_EXPR, return the corresponding\n+   BUILT_IN_CILKPLUS_SEC_REDUCE_* being called.  If none, return\n+   BUILT_IN_NONE.  */\n+\n+enum built_in_function\n+is_cilkplus_reduce_builtin (tree fndecl)\n+{\n+  if (!fndecl)\n+    return BUILT_IN_NONE;\n+  if (TREE_CODE (fndecl) == ADDR_EXPR)\n+    fndecl = TREE_OPERAND (fndecl, 0);\n+\n+  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+\treturn DECL_FUNCTION_CODE (fndecl);\n+      default:\n+\tbreak;\n+      }\n+\n+  return BUILT_IN_NONE;\n+}\n+\n+/* This function will recurse into EXPR finding any\n+   ARRAY_NOTATION_EXPRs and calculate the overall rank of EXPR,\n+   storing it in *RANK. LOC is the location of the original expression.\n+\n+   ORIG_EXPR is the original expression used to display if any rank\n+   mismatch errors are found.\n+\n+   Upon entry, *RANK must be either 0, or the rank of a parent\n+   expression that must have the same rank as the one being\n+   calculated.  It is illegal to have multiple array notation with different\n+   rank in the same expression (see examples below for clarification).\n+\n+   If there were any rank mismatches while calculating the rank, an\n+   error will be issued, and FALSE will be returned.  Otherwise, TRUE\n+   is returned.  \n+\n+   If IGNORE_BUILTIN_FN is TRUE, ignore array notation specific\n+   built-in functions (__sec_reduce_*, etc).\n+\n+   Here are some examples of array notations and their rank:\n+\n+   Expression\t\t\t    RANK\n+   5\t\t\t\t    0\n+   X (a variable)\t\t    0\n+   *Y (a pointer)\t\t    0\n+   A[5]\t\t\t\t    0\n+   B[5][10]\t\t\t    0\n+   A[:]\t\t\t\t    1 \n+   B[0:10]\t\t\t    1\n+   C[0:10:2]\t\t\t    1\n+   D[5][0:10:2]\t\t\t    1 (since D[5] is considered \"scalar\")\n+   D[5][:][10]\t\t\t    1 \n+   E[:] + 5\t\t\t    1 \n+   F[:][:][:] + 5 + X\t\t    3\n+   F[:][:][:] + E[:] + 5 + X\t    RANKMISMATCH-ERROR since rank (E[:]) = 1 and\n+                                    rank (F[:][:][:]) = 3.  They must be equal \n+\t\t\t\t    or have a rank of zero.\n+   F[:][5][10] + E[:] * 5 + *Y      1\n+\n+   int func (int);\n+   func (A[:])\t\t\t    1\n+   func (B[:][:][:][:])             4 \n+   \n+   int func2 (int, int)\n+   func2 (A[:], B[:][:][:][:])\t    RANKMISMATCH-ERROR -- Since Rank (A[:]) = 1 \n+\t\t\t\t    and Rank (B[:][:][:][:]) = 4\n+\n+   A[:] + func (B[:][:][:][:])\t    RANKMISMATCH-ERROR\n+   func2 (A[:], B[:]) + func (A)    1 \n+\n+ */\n+\n+bool\n+find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n+\t   size_t *rank)\n+{\n+  tree ii_tree;\n+  size_t ii = 0, current_rank = 0;\n+\n+  if (TREE_CODE (expr) == ARRAY_NOTATION_REF)\n+    {\n+      ii_tree = expr;\n+      while (ii_tree)\n+\t{\n+\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t    {\n+\t      current_rank++;\n+\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t    }\n+\t  else if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n+\t  else if (TREE_CODE (ii_tree) == PARM_DECL\n+\t\t   || TREE_CODE (ii_tree) == VAR_DECL)\n+\t    break;\n+\t}\n+      if (*rank == 0)\n+\t/* In this case, all the expressions this function has encountered thus\n+\t   far have been scalars or expressions with zero rank.  Please see\n+\t   header comment for examples of such expression.  */\n+\t*rank = current_rank;\n+      else if (*rank != current_rank)\n+\t{\n+\t  /* In this case, find rank is being recursed through a set of \n+\t     expression of the form A <OPERATION> B, where A and B both have\n+\t     array notations in them and the rank of A is not equal to rank of\n+\t     B.  \n+\t     A simple example of such case is the following: X[:] + Y[:][:] */ \n+\t  *rank = current_rank;\n+\t  return false;\n+\t}\n+    }\n+  else if (TREE_CODE (expr) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (expr); !tsi_end_p (ii_tsi);\n+\t   tsi_next (&ii_tsi))\n+\tif (!find_rank (loc, orig_expr, *tsi_stmt_ptr (ii_tsi),\n+\t\t\tignore_builtin_fn, rank))\n+\t  return false;\n+    }\n+  else\n+    {\n+      if (TREE_CODE (expr) == CALL_EXPR)\n+\t{\n+\t  tree func_name = CALL_EXPR_FN (expr);\n+\t  tree prev_arg = NULL_TREE, arg;\n+\t  call_expr_arg_iterator iter;\n+\t  size_t prev_rank = 0;\n+\t  if (TREE_CODE (func_name) == ADDR_EXPR)\n+\t    if (!ignore_builtin_fn)\n+\t      if (is_cilkplus_reduce_builtin (func_name))\n+\t\t/* If it is a built-in function, then we know it returns a \n+\t\t   scalar.  */\n+\t\treturn true;\n+\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n+\t    {\n+\t      if (!find_rank (loc, orig_expr, arg, ignore_builtin_fn, rank))\n+\t\t{\n+\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg)\n+\t\t      && prev_rank != *rank)\n+\t\t    error_at (EXPR_LOCATION (prev_arg),\n+\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n+\t\t\t      arg);\n+\t\t  else if (prev_arg && prev_rank != *rank)\n+\t\t    /* Here the original expression is printed as a \"heads-up\"\n+\t\t       to the programmer.  This is because since there is no \n+\t\t       location information for the offending argument, the \n+\t\t       error could be in some internally generated code that is\n+\t\t       not visible for the programmer.  Thus, the correct fix\n+\t\t       may lie in the original expression.  */\n+\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n+\t\t\t      orig_expr);\n+\t\t  return false;\n+\t\t}\n+\t      prev_arg = arg;\n+\t      prev_rank = *rank;\n+\t    }\t\n+\t}\n+      else\n+\t{\n+\t  tree prev_arg = NULL_TREE;\n+\t  for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (expr)); ii++)\n+\t    {\n+\t      if (TREE_OPERAND (expr, ii)\n+\t\t  && !find_rank (loc, orig_expr, TREE_OPERAND (expr, ii),\n+\t\t\t\t ignore_builtin_fn, rank))\n+\t\t{\n+\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg))\n+\t\t    error_at (EXPR_LOCATION (prev_arg),\n+\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n+\t\t\t      TREE_OPERAND (expr, ii));\n+\t\t  return false;\n+\t\t}\n+\t      prev_arg = TREE_OPERAND (expr, ii);\n+\t    }\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Extracts all array notations in NODE and stores them in ARRAY_LIST.  If \n+   IGNORE_BUILTIN_FN is set, then array notations inside array notation\n+   specific built-in functions are ignored.  The NODE can be constants,\n+   VAR_DECL, PARM_DECLS, STATEMENT_LISTS or full expressions.   */\n+\n+void\n+extract_array_notation_exprs (tree node, bool ignore_builtin_fn,\n+\t\t\t      vec<tree, va_gc> **array_list)\n+{\n+  size_t ii = 0;  \n+  if (TREE_CODE (node) == ARRAY_NOTATION_REF)\n+    {\n+      vec_safe_push (*array_list, node);\n+      return;\n+    }\n+  else if (TREE_CODE (node) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (node); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n+\textract_array_notation_exprs (*tsi_stmt_ptr (ii_tsi),\n+\t\t\t\t      ignore_builtin_fn, array_list);\n+    }\n+  else if (TREE_CODE (node) == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (node)))\n+\t{\n+\t  if (ignore_builtin_fn)\n+\t    return;\n+\t  else\n+\t    {\n+\t      vec_safe_push (*array_list, node);\n+\t      return;\n+\t    }\n+\t}\n+      if (is_sec_implicit_index_fn (CALL_EXPR_FN (node)))\n+\t{\n+\t  vec_safe_push (*array_list, node);\n+\t  return;\n+\t}\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n+\textract_array_notation_exprs (arg, ignore_builtin_fn, array_list);\n+    } \n+  else \n+    for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (node)); ii++) \n+      if (TREE_OPERAND (node, ii))\n+\textract_array_notation_exprs (TREE_OPERAND (node, ii),\n+\t\t\t\t      ignore_builtin_fn, array_list);\n+  return;\n+}\n+\n+/* LIST contains all the array notations found in *ORIG and ARRAY_OPERAND\n+   contains the expanded ARRAY_REF.  E.g., if LIST[<some_index>] contains\n+   an array_notation expression, then ARRAY_OPERAND[<some_index>] contains its\n+   expansion.  If *ORIG matches LIST[<some_index>] then *ORIG is set to\n+   ARRAY_OPERAND[<some_index>].  This function recursively steps through\n+   all the sub-trees of *ORIG, if it is larger than a single\n+   ARRAY_NOTATION_REF.  */\n+\n+void\n+replace_array_notations (tree *orig, bool ignore_builtin_fn,\n+\t\t\t vec<tree, va_gc> *list,\n+\t\t\t vec<tree, va_gc> *array_operand)\n+{\n+  size_t ii = 0;\n+  extern tree build_c_cast (location_t, tree, tree);\n+  tree node = NULL_TREE, node_replacement = NULL_TREE;\n+  \n+  if (vec_safe_length (list) == 0)\n+    return;\n+\n+  if (TREE_CODE (*orig) == ARRAY_NOTATION_REF)\n+    {\n+      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n+\tif (*orig == node)\n+\t  {\n+\t    node_replacement = (*array_operand)[ii];\n+\t    *orig = node_replacement;\n+\t  }\n+    }\n+  else if (TREE_CODE (*orig) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (*orig); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n+\treplace_array_notations (tsi_stmt_ptr (ii_tsi), ignore_builtin_fn, list,\n+\t\t\t\t array_operand);\n+    }\n+  else if (TREE_CODE (*orig) == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (*orig)))\n+\t{\n+\t  if (!ignore_builtin_fn)\n+\t    {\n+\t      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n+\t\tif (*orig == node)\n+\t\t  {\n+\t\t    node_replacement = (*array_operand)[ii];\n+\t\t    *orig = node_replacement;\n+\t\t  }\n+\t    }\n+\t  return;\n+\t}\n+      if (is_sec_implicit_index_fn (CALL_EXPR_FN (*orig)))\n+\t{\n+\t  for (ii = 0; vec_safe_iterate (list, ii, &node); ii++)\n+\t    if (*orig == node)\n+\t      {\n+\t\tnode_replacement = (*array_operand)[ii];\n+\t\t*orig = build_c_cast (EXPR_LOCATION (*orig),\n+\t\t\t\t      TREE_TYPE (*orig), node_replacement);\n+\t      }\n+\t  return;\n+\t}\n+      ii = 0;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, *orig)\n+\t{\n+\t  replace_array_notations (&arg, ignore_builtin_fn, list,\n+\t\t\t\t   array_operand);\n+\t  CALL_EXPR_ARG (*orig, ii) = arg;\n+\t  ii++;\n+\t}     \n+    }\n+  else\n+    {\n+      for (ii = 0; ii < (size_t) TREE_CODE_LENGTH (TREE_CODE (*orig)); ii++) \n+\tif (TREE_OPERAND (*orig, ii))\n+\t  replace_array_notations (&TREE_OPERAND (*orig, ii), ignore_builtin_fn,\n+\t\t\t\t   list, array_operand);\n+    }\n+  return;\n+}\n+\n+/* Callback for walk_tree.  Find all the scalar expressions in *TP and push \n+   them in DATA struct, typecasted to (void *).  If *WALK_SUBTREES is set to 0 \n+   then do not go into the *TP's subtrees.  Since this function steps through \n+   all the subtrees, *TP and TP can be NULL_TREE and NULL, respectively.  The \n+   function returns NULL_TREE unconditionally.  */\n+\n+tree\n+find_inv_trees (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct inv_list *i_list = (struct inv_list *) data;\n+  unsigned int ii = 0;\n+\n+  if (!tp || !*tp)\n+    return NULL_TREE;\n+  if (TREE_CONSTANT (*tp))\n+    return NULL_TREE; /* No need to save constant to a variable.  */\n+  if (TREE_CODE (*tp) != COMPOUND_EXPR && !contains_array_notation_expr (*tp))\n+    {\n+      vec_safe_push (i_list->list_values, *tp);\n+      *walk_subtrees = 0;\n+    }\n+  else if (TREE_CODE (*tp) == ARRAY_NOTATION_REF\n+\t   || TREE_CODE (*tp) == ARRAY_REF\n+\t   || TREE_CODE (*tp) == CALL_EXPR)\n+    /* No need to step through the internals of array notation.  */\n+    *walk_subtrees = 0;\n+  else\n+    {\n+      *walk_subtrees = 1;\n+\n+      /* This function is used by C and C++ front-ends.  In C++, additional\n+\t tree codes such as TARGET_EXPR must be eliminated.  These codes are\n+\t passed into additional_tcodes and are walked through and checked.  */\n+      for (ii = 0; ii < vec_safe_length (i_list->additional_tcodes); ii++)\n+\tif (TREE_CODE (*tp) == (enum rid)(*(i_list->additional_tcodes))[ii])\n+\t  *walk_subtrees = 0;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Callback for walk_tree.  Replace all the scalar expressions in *TP with the \n+   appropriate replacement stored in the struct *DATA (typecasted to void*).  \n+   The subtrees are not touched if *WALK_SUBTREES is set to zero.  */\n+\n+tree\n+replace_inv_trees (tree *tp, int *walk_subtrees, void *data)\n+{\n+  size_t ii = 0;\n+  tree t, r;\n+  struct inv_list *i_list = (struct inv_list *) data;\n+\n+  if (vec_safe_length (i_list->list_values))\n+    {\n+      for (ii = 0; vec_safe_iterate (i_list->list_values, ii, &t); ii++)\n+\tif (simple_cst_equal (*tp, t) == 1)\n+\t  {\n+\t    vec_safe_iterate (i_list->replacement, ii, &r);\n+\t    gcc_assert (r != NULL_TREE);\n+\t    *tp = r;\n+\t    *walk_subtrees = 0;\n+\t  }\n+    }\n+  else\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n+/* Returns true if EXPR or any of its subtrees contain ARRAY_NOTATION_EXPR \n+   node.  */\n+\n+bool\n+contains_array_notation_expr (tree expr)\n+{\n+  vec<tree, va_gc> *array_list = NULL;\n+\n+  if (!expr)\n+    return false;\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    if (is_cilkplus_reduce_builtin (expr))\n+      return true;\n+  \n+  extract_array_notation_exprs (expr, false, &array_list);\n+  if (vec_safe_length (array_list) == 0)\n+    return false;\n+  else\n+    return true;\n+}\n+\n+/* This function will check if OP is a CALL_EXPR that is a built-in array \n+   notation function.  If so, then we will return its type to be the type of\n+   the array notation inside.  */\n+\n+tree\n+find_correct_array_notation_type (tree op)\n+{\n+  tree fn_arg, return_type = NULL_TREE;\n+\n+  if (op)\n+    {\n+      return_type = TREE_TYPE (op); /* This is the default case.  */\n+      if (TREE_CODE (op) == CALL_EXPR) \n+\tif (is_cilkplus_reduce_builtin (CALL_EXPR_FN (op))) \n+\t  { \n+\t    fn_arg = CALL_EXPR_ARG (op, 0); \n+\t    if (fn_arg) \n+\t      return_type = TREE_TYPE (fn_arg); \n+\t  }\n+    } \n+  return return_type;\n+}"}, {"sha": "8eaf54fe50271617ab10506a4de9d285d9b1526a", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -541,7 +541,6 @@ extern tree build_modify_expr (location_t, tree, tree, enum tree_code,\n extern tree build_array_notation_expr (location_t, tree, tree, enum tree_code,\n \t\t\t\t       location_t, tree, tree);\n extern tree build_array_notation_ref (location_t, tree, tree, tree, tree, tree);\n-extern bool find_rank (location_t, tree, tree, bool, size_t *);\n extern tree build_indirect_ref (location_t, tree, ref_operator);\n \n extern int field_decl_cmp (const void *, const void *);\n@@ -1150,7 +1149,19 @@ extern enum stv_conv scalar_to_vector (location_t loc, enum tree_code code,\n #define ARRAY_NOTATION_STRIDE(NODE) \\\n   TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 3)\n \n-extern int extract_sec_implicit_index_arg (location_t, tree);\n+/* This structure holds all the scalar values and its appropriate variable \n+   replacment.  It is mainly used by the function that pulls all the invariant\n+   parts that should be executed only once, which comes with array notation \n+   expressions.  */\n+struct inv_list\n+{\n+  vec<tree, va_gc> *list_values;\n+  vec<tree, va_gc> *replacement;\n+  vec<enum rid, va_gc> *additional_tcodes; \n+};\n+\n+/* In array-notation-common.c.  */\n+extern HOST_WIDE_INT extract_sec_implicit_index_arg (location_t, tree);\n extern bool is_sec_implicit_index_fn (tree);\n extern void array_notation_init_builtins (void);\n extern struct c_expr fix_array_notation_expr (location_t, enum tree_code, \n@@ -1159,4 +1170,13 @@ extern bool contains_array_notation_expr (tree);\n extern tree expand_array_notation_exprs (tree);\n extern tree fix_conditional_array_notations (tree);\n extern tree find_correct_array_notation_type (tree);\n+extern bool length_mismatch_in_expr_p (location_t, tree **, size_t, size_t);\n+extern enum built_in_function is_cilkplus_reduce_builtin (tree);\n+extern bool find_rank (location_t, tree, tree, bool, size_t *);\n+extern void extract_array_notation_exprs (tree, bool, vec<tree, va_gc> **);\n+extern void replace_array_notations (tree *, bool, vec<tree, va_gc> *,\n+\t\t\t\t     vec<tree, va_gc> *);\n+extern tree find_inv_trees (tree *, int *, void *);\n+extern tree replace_inv_trees (tree *, int *, void *);\n+extern tree find_correct_array_notation_type (tree op);\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "7f5b5a9f0ffff332a908a2cbfe6b84bb142856ce", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -1,3 +1,19 @@\n+2013-06-07  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-array-notation.c (length_mismatch_in_expr_p): Moved this\n+\tfunction to c-family/array-notation-common.c.\n+\t(is_cilkplus_reduce_builtin): Likewise.\n+\t(find_rank): Likewise.\n+\t(extract_array_notation_exprs): Likewise.\n+\t(replace_array_notations): Likewise.\n+\t(find_inv_trees): Likewise.\n+\t(replace_inv_trees): Likewise.\n+\t(contains_array_notation_expr): Likewise.\n+\t(find_correct_array_notation_type): Likewise.\n+\t(replace_invariant_exprs): Initialized additional_tcodes to NULL.\n+\t(struct inv_list): Moved this to c-family/array-notation-common.c.\n+\t* c-tree.h (is_cilkplus_builtin_reduce): Remove prototype.\n+\t\n 2013-06-05  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-typeck.c (convert_arguments): Moved checking of builtin cilkplus"}, {"sha": "7b13687342a03a4a3360ec8d7eed7f90ea9032d6", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 1, "deletions": 489, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -74,452 +74,6 @@\n #include \"opts.h\"\n #include \"c-family/c-common.h\"\n \n-static void replace_array_notations (tree *, bool, vec<tree, va_gc> *,\n-\t\t\t\t     vec<tree, va_gc> *);\n-static void extract_array_notation_exprs (tree, bool, vec<tree, va_gc> **);\n-\n-/* This structure holds all the scalar values and its appropriate variable \n-   replacment.  It is mainly used by the function that pulls all the invariant\n-   parts that should be executed only once, which comes with array notation \n-   expressions.  */\n-struct inv_list\n-{\n-  vec<tree, va_gc> *list_values;\n-  vec<tree, va_gc> *replacement;\n-};\n-\n-/* Returns true if there is length mismatch among expressions\n-   on the same dimension and on the same side of the equal sign.  The\n-   expressions (or ARRAY_NOTATION lengths) are passed in through 2-D array\n-   **LIST where X and Y indicate first and second dimension sizes of LIST,\n-   respectively.  */\n-\n-static bool\n-length_mismatch_in_expr_p (location_t loc, tree **list, size_t x, size_t y)\n-{\n-  size_t ii, jj;\n-  tree start = NULL_TREE;\n-  HOST_WIDE_INT l_start, l_node;\n-  for (jj = 0; jj < y; jj++)\n-    {\n-      start = NULL_TREE;\n-      for (ii = 0; ii < x; ii++)\n-\t{\n-\t  if (!start)\n-\t    start = list[ii][jj];\n-\t  else if (TREE_CODE (start) == INTEGER_CST)\n-\t    {\n-\t      /* If start is a INTEGER, and list[ii][jj] is an integer then\n-\t\t check if they are equal.  If they are not equal then return\n-\t\t true.  */\n-\t      if (TREE_CODE (list[ii][jj]) == INTEGER_CST)\n-\t\t{\n-\t\t  l_node = int_cst_value (list[ii][jj]);\n-\t\t  l_start = int_cst_value (start);\n-\t\t  if (absu_hwi (l_start) != absu_hwi (l_node))\n-\t\t    {\n-\t\t      error_at (loc, \"length mismatch in expression\");\n-\t\t      return true;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* We set the start node as the current node just in case it turns\n-\t       out to be an integer.  */\n-\t    start = list[ii][jj];\n-\t}\n-    }\n-  return false;\n-}\n-\n-\n-/* Given an FNDECL of type FUNCTION_DECL or ADDR_EXPR, return the corresponding\n-   BUILT_IN_CILKPLUS_SEC_REDUCE_* being called.  If none, return\n-   BUILT_IN_NONE.  */\n-\n-enum built_in_function\n-is_cilkplus_reduce_builtin (tree fndecl)\n-{\n-  if (TREE_CODE (fndecl) == ADDR_EXPR)\n-    fndecl = TREE_OPERAND (fndecl, 0);\n-\n-  if (TREE_CODE (fndecl) == FUNCTION_DECL\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (fndecl))\n-      {\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-\treturn DECL_FUNCTION_CODE (fndecl);\n-      default:\n-\tbreak;\n-      }\n-\n-  return BUILT_IN_NONE;\n-}\n-\n-/* This function will recurse into EXPR finding any\n-   ARRAY_NOTATION_EXPRs and calculate the overall rank of EXPR,\n-   storing it in *RANK. LOC is the location of the original expression.\n-\n-   ORIG_EXPR is the original expression used to display if any rank\n-   mismatch errors are found.\n-\n-   Upon entry, *RANK must be either 0, or the rank of a parent\n-   expression that must have the same rank as the one being\n-   calculated.  It is illegal to have multiple array notation with different\n-   rank in the same expression (see examples below for clarification).\n-\n-   If there were any rank mismatches while calculating the rank, an\n-   error will be issued, and FALSE will be returned.  Otherwise, TRUE\n-   is returned.  \n-\n-   If IGNORE_BUILTIN_FN is TRUE, ignore array notation specific\n-   built-in functions (__sec_reduce_*, etc).\n-\n-   Here are some examples of array notations and their rank:\n-\n-   Expression\t\t\t    RANK\n-   5\t\t\t\t    0\n-   X (a variable)\t\t    0\n-   *Y (a pointer)\t\t    0\n-   A[5]\t\t\t\t    0\n-   B[5][10]\t\t\t    0\n-   A[:]\t\t\t\t    1 \n-   B[0:10]\t\t\t    1\n-   C[0:10:2]\t\t\t    1\n-   D[5][0:10:2]\t\t\t    1 (since D[5] is considered \"scalar\")\n-   D[5][:][10]\t\t\t    1 \n-   E[:] + 5\t\t\t    1 \n-   F[:][:][:] + 5 + X\t\t    3\n-   F[:][:][:] + E[:] + 5 + X\t    RANKMISMATCH-ERROR since rank (E[:]) = 1 and\n-                                    rank (F[:][:][:]) = 3.  They must be equal \n-\t\t\t\t    or have a rank of zero.\n-   F[:][5][10] + E[:] * 5 + *Y      1\n-\n-   int func (int);\n-   func (A[:])\t\t\t    1\n-   func (B[:][:][:][:])             4 \n-   \n-   int func2 (int, int)\n-   func2 (A[:], B[:][:][:][:])\t    RANKMISMATCH-ERROR -- Since Rank (A[:]) = 1 \n-\t\t\t\t    and Rank (B[:][:][:][:]) = 4\n-\n-   A[:] + func (B[:][:][:][:])\t    RANKMISMATCH-ERROR\n-   func2 (A[:], B[:]) + func (A)    1 \n-\n- */\n-\n-bool\n-find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n-\t   size_t *rank)\n-{\n-  tree ii_tree;\n-  size_t ii = 0, current_rank = 0;\n- \n-  if (TREE_CODE (expr) == ARRAY_NOTATION_REF)\n-    {\n-      ii_tree = expr;\n-      while (ii_tree)\n-\t{\n-\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t    {\n-\t      current_rank++;\n-\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t    }\n-\t  else if (TREE_CODE (ii_tree) == ARRAY_REF)\n-\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n-\t  else if (TREE_CODE (ii_tree) == PARM_DECL\n-\t\t   || TREE_CODE (ii_tree) == VAR_DECL)\n-\t    break;\n-\t}\n-      if (*rank == 0)\n-\t/* In this case, all the expressions this function has encountered thus\n-\t   far have been scalars or expressions with zero rank.  Please see\n-\t   header comment for examples of such expression.  */\n-\t*rank = current_rank;\n-      else if (*rank != current_rank)\n-\t{\n-\t  /* In this case, find rank is being recursed through a set of \n-\t     expression of the form A <OPERATION> B, where A and B both have\n-\t     array notations in them and the rank of A is not equal to rank of\n-\t     B.  \n-\t     A simple example of such case is the following: X[:] + Y[:][:] */ \n-\t  *rank = current_rank;\n-\t  return false;\n-\t}\n-    }\n-  else if (TREE_CODE (expr) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (expr); !tsi_end_p (ii_tsi);\n-\t   tsi_next (&ii_tsi))\n-\tif (!find_rank (loc, orig_expr, *tsi_stmt_ptr (ii_tsi),\n-\t\t\tignore_builtin_fn, rank))\n-\t  return false;\n-    }\n-  else\n-    {\n-      if (TREE_CODE (expr) == CALL_EXPR)\n-\t{\n-\t  tree func_name = CALL_EXPR_FN (expr);\n-\t  tree prev_arg = NULL_TREE, arg;\n-\t  call_expr_arg_iterator iter;\n-\t  size_t prev_rank = 0;\n-\t  if (TREE_CODE (func_name) == ADDR_EXPR)\n-\t    if (!ignore_builtin_fn)\n-\t      if (is_cilkplus_reduce_builtin (func_name))\n-\t\t/* If it is a built-in function, then we know it returns a \n-\t\t   scalar.  */\n-\t\treturn true;\n-\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n-\t    {\n-\t      if (!find_rank (loc, orig_expr, arg, ignore_builtin_fn, rank))\n-\t\t{\n-\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg)\n-\t\t      && prev_rank != *rank)\n-\t\t    error_at (EXPR_LOCATION (prev_arg),\n-\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n-\t\t\t      arg);\n-\t\t  else if (prev_arg && prev_rank != *rank)\n-\t\t    /* Here the original expression is printed as a \"heads-up\"\n-\t\t       to the programmer.  This is because since there is no \n-\t\t       location information for the offending argument, the \n-\t\t       error could be in some internally generated code that is\n-\t\t       not visible for the programmer.  Thus, the correct fix\n-\t\t       may lie in the original expression.  */\n-\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n-\t\t\t      orig_expr);\n-\t\t  return false;\n-\t\t}\n-\t      prev_arg = arg;\n-\t      prev_rank = *rank;\n-\t    }\t\n-\t}\n-      else\n-\t{\n-\t  tree prev_arg = NULL_TREE;\n-\t  for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (expr)); ii++)\n-\t    {\n-\t      if (TREE_OPERAND (expr, ii)\n-\t\t  && !find_rank (loc, orig_expr, TREE_OPERAND (expr, ii),\n-\t\t\t\t ignore_builtin_fn, rank))\n-\t\t{\n-\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg))\n-\t\t    error_at (EXPR_LOCATION (prev_arg),\n-\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n-\t\t\t      TREE_OPERAND (expr, ii));\n-\t\t  else if (prev_arg)\n-\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n-\t\t\t      orig_expr);\n-\t\t  return false;\n-\t\t}\n-\t      prev_arg = TREE_OPERAND (expr, ii);\n-\t    }\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Extracts all array notations in NODE and stores them in ARRAY_LIST.  If \n-   IGNORE_BUILTIN_FN is set, then array notations inside array notation\n-   specific built-in functions are ignored.  The NODE can be constants,\n-   VAR_DECL, PARM_DECLS, STATEMENT_LISTS or full expressions.   */\n-\n-static void\n-extract_array_notation_exprs (tree node, bool ignore_builtin_fn,\n-\t\t\t      vec<tree, va_gc> **array_list)\n-{\n-  size_t ii = 0;  \n-  if (TREE_CODE (node) == ARRAY_NOTATION_REF)\n-    {\n-      vec_safe_push (*array_list, node);\n-      return;\n-    }\n-  else if (TREE_CODE (node) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (node); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n-\textract_array_notation_exprs (*tsi_stmt_ptr (ii_tsi),\n-\t\t\t\t      ignore_builtin_fn, array_list);\n-    }\n-  else if (TREE_CODE (node) == CALL_EXPR)\n-    {\n-      tree arg;\n-      call_expr_arg_iterator iter;\n-      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (node)))\n-\t{\n-\t  if (ignore_builtin_fn)\n-\t    return;\n-\t  else\n-\t    {\n-\t      vec_safe_push (*array_list, node);\n-\t      return;\n-\t    }\n-\t}\n-      if (is_sec_implicit_index_fn (CALL_EXPR_FN (node)))\n-\t{\n-\t  vec_safe_push (*array_list, node);\n-\t  return;\n-\t}\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n-\textract_array_notation_exprs (arg, ignore_builtin_fn, array_list);\n-    } \n-  else \n-    for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (node)); ii++) \n-      if (TREE_OPERAND (node, ii))\n-\textract_array_notation_exprs (TREE_OPERAND (node, ii),\n-\t\t\t\t      ignore_builtin_fn, array_list);\n-  return;\n-}\n-\n-/* LIST contains all the array notations found in *ORIG and ARRAY_OPERAND\n-   contains the expanded ARRAY_REF.  E.g., if LIST[<some_index>] contains\n-   an array_notation expression, then ARRAY_OPERAND[<some_index>] contains its\n-   expansion.  If *ORIG matches LIST[<some_index>] then *ORIG is set to\n-   ARRAY_OPERAND[<some_index>].  This function recursively steps through\n-   all the sub-trees of *ORIG, if it is larger than a single\n-   ARRAY_NOTATION_REF.  */\n-\n-static void\n-replace_array_notations (tree *orig, bool ignore_builtin_fn,\n-\t\t\t vec<tree, va_gc> *list,\n-\t\t\t vec<tree, va_gc> *array_operand)\n-{\n-  size_t ii = 0;\n-  tree node = NULL_TREE, node_replacement = NULL_TREE;\n-  \n-  if (vec_safe_length (list) == 0)\n-    return;\n-\n-  if (TREE_CODE (*orig) == ARRAY_NOTATION_REF)\n-    {\n-      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n-\tif (*orig == node)\n-\t  {\n-\t    node_replacement = (*array_operand)[ii];\n-\t    *orig = node_replacement;\n-\t  }\n-    }\n-  else if (TREE_CODE (*orig) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (*orig); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n-\treplace_array_notations (tsi_stmt_ptr (ii_tsi), ignore_builtin_fn, list,\n-\t\t\t\t array_operand);\n-    }\n-  else if (TREE_CODE (*orig) == CALL_EXPR)\n-    {\n-      tree arg;\n-      call_expr_arg_iterator iter;\n-      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (*orig)))\n-\t{\n-\t  if (!ignore_builtin_fn)\n-\t    {\n-\t      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n-\t\tif (*orig == node)\n-\t\t  {\n-\t\t    node_replacement = (*array_operand)[ii];\n-\t\t    *orig = node_replacement;\n-\t\t  }\n-\t    }\n-\t  return;\n-\t}\n-      if (is_sec_implicit_index_fn (CALL_EXPR_FN (*orig)))\n-\t{\n-\t  for (ii = 0; vec_safe_iterate (list, ii, &node); ii++)\n-\t    if (*orig == node)\n-\t      {\n-\t\tnode_replacement = (*array_operand)[ii];\n-\t\t*orig = node_replacement;\n-\t      }\n-\t  return;\n-\t}\n-      ii = 0;\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, *orig)\n-\t{\n-\t  replace_array_notations (&arg, ignore_builtin_fn, list,\n-\t\t\t\t   array_operand);\n-\t  CALL_EXPR_ARG (*orig, ii) = arg;\n-\t  ii++;\n-\t}     \n-    }\n-  else\n-    {\n-      for (ii = 0; ii < (size_t) TREE_CODE_LENGTH (TREE_CODE (*orig)); ii++) \n-\tif (TREE_OPERAND (*orig, ii))\n-\t  replace_array_notations (&TREE_OPERAND (*orig, ii), ignore_builtin_fn,\n-\t\t\t\t   list, array_operand);\n-    }\n-  return;\n-}\n-\n-/* Callback for walk_tree.  Find all the scalar expressions in *TP and push \n-   them in DATA struct, typecasted to (void *).  If *WALK_SUBTREES is set to 0 \n-   then do not go into the *TP's subtrees.  Since this function steps through \n-   all the subtrees, *TP and TP can be NULL_TREE and NULL, respectively.  The \n-   function returns NULL_TREE unconditionally.  */\n-\n-static tree\n-find_inv_trees (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct inv_list *i_list = (struct inv_list *) data;\n-\n-  if (!tp || !*tp)\n-    return NULL_TREE;\n-  if (TREE_CONSTANT (*tp))\n-    return NULL_TREE; /* No need to save constant to a variable.  */\n-  if (TREE_CODE (*tp) != COMPOUND_EXPR && !contains_array_notation_expr (*tp))\n-    {\n-      vec_safe_push (i_list->list_values, *tp);\n-      *walk_subtrees = 0;\n-    }\n-  else if (TREE_CODE (*tp) == ARRAY_NOTATION_REF\n-\t   || TREE_CODE (*tp) == ARRAY_REF\n-\t   || TREE_CODE (*tp) == CALL_EXPR)\n-    /* No need to step through the internals of array notation.  */\n-    *walk_subtrees = 0;\n-  else\n-    *walk_subtrees = 1;\n-  return NULL_TREE;\n-}\n-\n-/* Callback for walk_tree.  Replace all the scalar expressions in *TP with the \n-   appropriate replacement stored in the struct *DATA (typecasted to void*).  \n-   The subtrees are not touched if *WALK_SUBTREES is set to zero.  */\n-\n-static tree\n-replace_inv_trees (tree *tp, int *walk_subtrees, void *data)\n-{\n-  size_t ii = 0;\n-  tree t, r;\n-  struct inv_list *i_list = (struct inv_list *) data;\n-\n-  if (vec_safe_length (i_list->list_values))\n-    {\n-      for (ii = 0; vec_safe_iterate (i_list->list_values, ii, &t); ii++)\n-\tif (simple_cst_equal (*tp, t) == 1)\n-\t  {\n-\t    vec_safe_iterate (i_list->replacement, ii, &r);\n-\t    gcc_assert (r != NULL_TREE);\n-\t    *tp = r;\n-\t    *walk_subtrees = 0;\n-\t  }\n-    }\n-  else\n-    *walk_subtrees = 0;\n-  return NULL_TREE;\n-}\n-\n /* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT_LIST that\n    holds the NODE along with variables that holds the results of the invariant\n    expressions.  */\n@@ -534,6 +88,7 @@ replace_invariant_exprs (tree *node)\n \n   data.list_values = NULL;\n   data.replacement = NULL;\n+  data.additional_tcodes = NULL;\n   walk_tree (node, find_inv_trees, (void *)&data, NULL);\n \n   if (vec_safe_length (data.list_values))\n@@ -2405,27 +1960,6 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n   return arg;\n }\n \n-/* Returns true if EXPR or any of its subtrees contain ARRAY_NOTATION_EXPR \n-   node.  */\n-\n-bool\n-contains_array_notation_expr (tree expr)\n-{\n-  vec<tree, va_gc> *array_list = NULL;\n-\n-  if (!expr)\n-    return false;\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    if (is_cilkplus_reduce_builtin (expr))\n-      return true;\n-  \n-  extract_array_notation_exprs (expr, false, &array_list);\n-  if (vec_safe_length (array_list) == 0)\n-    return false;\n-  else\n-    return true;\n-}\n-\n /* Replaces array notations in a void function call arguments in ARG and returns\n    a STATEMENT_LIST.  */\n \n@@ -2867,25 +2401,3 @@ build_array_notation_ref (location_t loc, tree array, tree start_index,\n   return array_ntn_tree;\n }\n \n-/* This function will check if OP is a CALL_EXPR that is a built-in array \n-   notation function.  If so, then we will return its type to be the type of\n-   the array notation inside.  */\n-\n-tree\n-find_correct_array_notation_type (tree op)\n-{\n-  tree fn_arg, return_type = NULL_TREE;\n-\n-  if (op)\n-    {\n-      return_type = TREE_TYPE (op); /* This is the default case.  */\n-      if (TREE_CODE (op) == CALL_EXPR) \n-\tif (is_cilkplus_reduce_builtin (CALL_EXPR_FN (op))) \n-\t  { \n-\t    fn_arg = CALL_EXPR_ARG (op, 0); \n-\t    if (fn_arg) \n-\t      return_type = TREE_TYPE (fn_arg); \n-\t  }\n-    } \n-  return return_type;\n-}"}, {"sha": "d1a871daa683c3b1ebe20cf7157a4ba7965656f9", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60f170618a91748350161c4d6e759466dd480f6/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=d60f170618a91748350161c4d6e759466dd480f6", "patch": "@@ -668,7 +668,4 @@ extern void c_write_global_declarations (void);\n extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n \n-/* In c-array-notation.c */\n-enum built_in_function is_cilkplus_reduce_builtin (tree);\n-\n #endif /* ! GCC_C_TREE_H */"}]}