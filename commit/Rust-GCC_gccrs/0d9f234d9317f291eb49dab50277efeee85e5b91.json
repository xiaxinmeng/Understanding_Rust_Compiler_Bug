{"sha": "0d9f234d9317f291eb49dab50277efeee85e5b91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ5ZjIzNGQ5MzE3ZjI5MWViNDlkYWI1MDI3N2VmZWVlODVlNWI5MQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-09-18T18:43:05Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-09-18T18:43:05Z"}, "message": "cpphash.h (HASHSTEP): Take character rather than pointer to character.\n\n\t* cpphash.h (HASHSTEP): Take character rather than pointer\n\tto character.\n\t(_cpp_check_directive, _cpp_check_linemarker): Update prototypes.\n\n\t* cpphash.c (cpp_loookup): Update for new HASHSTEP.\n\n\t* cpplex.c (auto_expand_name_space, trigraph_replace,\n\tbackslash_start, handle_newline, parse_name, INIT_TOKEN_STR,\n\tIMMED_TOKEN, PREV_TOKEN_TYPE, PUSH_TOKEN, REVISE_TOKEN,\n\tBACKUP_TOKEN, BACKUP_TRIGRAPH, MIGHT_BE_DIRECTIVE,\n\tKNOWN_DIRECTIVE): Delete.\n\n\t(handle_newline, check_long_token, skip_escaped_newlines,\n\tunterminated): New functions.\n\t(ACCEPT_CHAR, SAVE_STATE, RESTORE_STATE): New macros.\n\n\t(parse_identifier): Was parse_name, new implementation.\n\t(skip_line_comment, skip_block_comment, skip_whitespace,\n\tparse_number, parse_string, trigraph_ok, save_comment,\n\tadjust_column, _cpp_get_line): New implementations.\n\n\t(lex_token): New function.  Lexes a token at a time, looking\n\tforwards.  Contains most of the guts of the old lex_line.\n\t(lex_line): New implementation, using lex_token to obtain\n\tindividual tokens.\n\t(cpp_scan_buffer): Use the token's line, not the list's line.\n\n\t* cpplib.c (_cpp_check_directive, _cpp_check_linemarker):\n\t New implementations.\n\t(do_assert): Don't bother setting the answer's list's line.\n\t(cpp_push_buffer): Initialise new pfile and read_ahead members\n\tof struct cpp_buffer.\n\n\t* cpplib.h (cppchar_t): New typedef.\n\t(struct cpp_buffer): read_ahead, pfile and col_adjust are\n\tnew members.\n\t(struct lexer_state): New structure that determines the state\n\tand behaviour of the lexer.\n\t(IN_DIRECTIVE, KNOWN_DIRECTIVE): New macros.\n\t(struct cpp_reader): New member \"state\". Rename\n\tmultiline_string_line and multiline_string_column. Delete\n\tcol_adjust, in_lex_line members.\n\t(CPP_BUF_COLUMN): Update.\n\n\t* gcc.dg/cpp/cmdlne-C.c: Remove bogus warning test.\n\nFrom-SVN: r36509", "tree": {"sha": "46f9c8a95640d0cd590d2e287982ab8e1099e35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46f9c8a95640d0cd590d2e287982ab8e1099e35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d9f234d9317f291eb49dab50277efeee85e5b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9f234d9317f291eb49dab50277efeee85e5b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9f234d9317f291eb49dab50277efeee85e5b91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9f234d9317f291eb49dab50277efeee85e5b91/comments", "author": null, "committer": null, "parents": [{"sha": "9f8e169eb7a21b2f374df31dd32beef667676a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8e169eb7a21b2f374df31dd32beef667676a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f8e169eb7a21b2f374df31dd32beef667676a13"}], "stats": {"total": 2202, "additions": 1084, "deletions": 1118}, "files": [{"sha": "b164a222cb683046d2d48715af84b6ef524ef127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -1,3 +1,49 @@\n+Mon 18-Sep-2000 19:21:35 BST  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.h (HASHSTEP): Take character rather than pointer\n+\tto character.\n+\t(_cpp_check_directive, _cpp_check_linemarker): Update prototypes.\n+\n+\t* cpphash.c (cpp_loookup): Update for new HASHSTEP.\n+\n+\t* cpplex.c (auto_expand_name_space, trigraph_replace,\n+\tbackslash_start, handle_newline, parse_name, INIT_TOKEN_STR,\n+\tIMMED_TOKEN, PREV_TOKEN_TYPE, PUSH_TOKEN, REVISE_TOKEN,\n+\tBACKUP_TOKEN, BACKUP_TRIGRAPH, MIGHT_BE_DIRECTIVE,\n+\tKNOWN_DIRECTIVE): Delete.\n+\n+\t(handle_newline, check_long_token, skip_escaped_newlines,\n+\tunterminated): New functions.\n+\t(ACCEPT_CHAR, SAVE_STATE, RESTORE_STATE): New macros.\n+\n+\t(parse_identifier): Was parse_name, new implementation.\n+\t(skip_line_comment, skip_block_comment, skip_whitespace,\n+\tparse_number, parse_string, trigraph_ok, save_comment,\n+\tadjust_column, _cpp_get_line): New implementations.\n+\n+\t(lex_token): New function.  Lexes a token at a time, looking\n+\tforwards.  Contains most of the guts of the old lex_line.\n+\t(lex_line): New implementation, using lex_token to obtain\n+\tindividual tokens.\n+\t(cpp_scan_buffer): Use the token's line, not the list's line.\n+\n+\t* cpplib.c (_cpp_check_directive, _cpp_check_linemarker):\n+\t New implementations.\n+\t(do_assert): Don't bother setting the answer's list's line.\n+\t(cpp_push_buffer): Initialise new pfile and read_ahead members\n+\tof struct cpp_buffer.\n+\n+\t* cpplib.h (cppchar_t): New typedef.\n+\t(struct cpp_buffer): read_ahead, pfile and col_adjust are\n+\tnew members.\n+\t(struct lexer_state): New structure that determines the state\n+\tand behaviour of the lexer.\n+\t(IN_DIRECTIVE, KNOWN_DIRECTIVE): New macros.\n+\t(struct cpp_reader): New member \"state\". Rename\n+\tmultiline_string_line and multiline_string_column. Delete\n+\tcol_adjust, in_lex_line members.\n+\t(CPP_BUF_COLUMN): Update.\n+\n 2000-09-18  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (simplify_comparison): Shift a NOT out of a single"}, {"sha": "dee77a98e421c271c5a770f50f09d42b7b5e631e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -104,7 +104,7 @@ cpp_lookup (pfile, name, len)\n \n   do\n     {\n-      r = HASHSTEP (r, str);\n+      r = HASHSTEP (r, *str);\n       str++;\n     }\n   while (--n);"}, {"sha": "08d3209d7bc96f73da54373d5c670fafb6926801", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -211,7 +211,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n \n /* Hash step.  The hash calculation is duplicated in cpp_lookup and\n    parse_name.  */\n-#define HASHSTEP(r, str) ((r) * 67 + (*str - 113));\n+#define HASHSTEP(r, c) ((r) * 67 + (c - 113));\n \n /* Flags for _cpp_init_toklist.  */\n #define DUMMY_TOKEN     0\n@@ -280,9 +280,9 @@ extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n \n /* In cpplib.c */\n extern const struct directive *_cpp_check_directive\n-\t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n+\t\t\tPARAMS ((cpp_reader *, const cpp_token *));\n extern const struct directive *_cpp_check_linemarker\n-\t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n+\t\t\tPARAMS ((cpp_reader *, const cpp_token *));\n extern cpp_hashnode *_cpp_parse_assertion PARAMS ((cpp_reader *,\n \t\t\t\t\t\t    struct answer **));\n extern struct answer **_cpp_find_answer\tPARAMS ((cpp_hashnode *,"}, {"sha": "4e321b6da4425e503ceda957d5587cc70030f86b", "filename": "gcc/cpplex.c", "status": "modified", "additions": 920, "deletions": 1055, "changes": 1975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -25,7 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n Cleanups to do:-\n \n o Check line numbers assigned to all errors.\n-o lex_line's use of cur_token, flags and list->token_used is a bit opaque.\n o Distinguish integers, floats, and 'other' pp-numbers.\n o Store ints and char constants as binary values.\n o New command-line assertion syntax.\n@@ -45,7 +44,8 @@ o Correct pastability test for CPP_NAME and CPP_NUMBER.\n #include \"cpphash.h\"\n #include \"symcat.h\"\n \n-static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER, 0 UNION_INIT_ZERO};\n+static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER,\n+\t\t\t\t\t    0 UNION_INIT_ZERO};\n static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n \n /* Flags for cpp_context.  */\n@@ -93,34 +93,34 @@ static int pop_context PARAMS ((cpp_reader *));\n static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n static void free_macro_args PARAMS ((macro_args *));\n-\n-#define auto_expand_name_space(list) \\\n-    _cpp_expand_name_space ((list), 1 + (list)->name_cap / 2)\n static void dump_param_spelling PARAMS ((FILE *, const cpp_toklist *,\n \t\t\t\t\t unsigned int));\n static void output_line_command PARAMS ((cpp_reader *, cpp_printer *,\n \t\t\t\t\t unsigned int));\n \n-static void process_directive\tPARAMS ((cpp_reader *, const cpp_token *));\n-static unsigned char *trigraph_replace PARAMS ((cpp_reader *, unsigned char *,\n-\t\t\t\t\t\tunsigned char *));\n-static const unsigned char *backslash_start PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t     const unsigned char *));\n+static cppchar_t handle_newline PARAMS ((cpp_buffer *, cppchar_t));\n+static cppchar_t skip_escaped_newlines PARAMS ((cpp_buffer *, cppchar_t));\n+static cppchar_t get_effective_char PARAMS ((cpp_buffer *));\n+\n static int skip_block_comment PARAMS ((cpp_reader *));\n-static int skip_line_comment PARAMS ((cpp_reader *));\n-static void adjust_column PARAMS ((cpp_reader *, const U_CHAR *));\n-static void skip_whitespace PARAMS ((cpp_reader *, int));\n-static const U_CHAR *parse_name PARAMS ((cpp_reader *, cpp_token *,\n-\t\t\t\t   const U_CHAR *, const U_CHAR *));\n-static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_string *));\n-static void parse_string PARAMS ((cpp_reader *, cpp_toklist *, cpp_token *,\n-\t\t\t\t  unsigned int));\n-static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n-static void save_comment PARAMS ((cpp_toklist *, cpp_token *,\n-\t\t\t\t  const unsigned char *,\n-\t\t\t\t  unsigned int, unsigned int));\n+static int skip_line_comment PARAMS ((cpp_buffer *));\n+static void adjust_column PARAMS ((cpp_reader *));\n+static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n+static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *, cppchar_t));\n+static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t));\n+static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n+static void unterminated PARAMS ((cpp_reader *, unsigned int, int));\n+static int trigraph_ok PARAMS ((cpp_reader *, cppchar_t));\n+static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static void lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n+static void check_long_token PARAMS ((cpp_buffer *,\n+\t\t\t\t      cpp_token *,\n+\t\t\t\t      cppchar_t,\n+\t\t\t\t      enum cpp_ttype));\n+static void lex_token PARAMS ((cpp_reader *, cpp_token *));\n static int lex_next PARAMS ((cpp_reader *, int));\n+\n+static void process_directive\tPARAMS ((cpp_reader *, const cpp_token *));\n static int is_macro_disabled PARAMS ((cpp_reader *, const cpp_toklist *,\n \t\t\t\t      const cpp_token *));\n \n@@ -149,37 +149,11 @@ static void release_temp_tokens\t\tPARAMS ((cpp_reader *));\n static U_CHAR * quote_string PARAMS ((U_CHAR *, const U_CHAR *, unsigned int));\n static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n-#define INIT_TOKEN_STR(list, token) \\\n-  do {(token)->val.str.len = 0; \\\n-      (token)->val.str.text = (list)->namebuf + (list)->name_used; \\\n-  } while (0)\n-\n #define VALID_SIGN(c, prevc) \\\n   (((c) == '+' || (c) == '-') && \\\n    ((prevc) == 'e' || (prevc) == 'E' \\\n     || (((prevc) == 'p' || (prevc) == 'P') && !CPP_OPTION (pfile, c89))))\n \n-/* Handle LF, CR, CR-LF and LF-CR style newlines.  Assumes next\n-   character, if any, is in buffer.  */\n-\n-#define handle_newline(cur, limit, c) \\\n- do { \\\n-  if ((cur) < (limit) && *(cur) == '\\r' + '\\n' - c) \\\n-    (cur)++; \\\n-  pfile->buffer->lineno++; \\\n-  pfile->buffer->line_base = (cur); \\\n-  pfile->col_adjust = 0; \\\n- } while (0)\n-\n-#define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITE))\n-#define PREV_TOKEN_TYPE (cur_token[-1].type)\n-\n-#define PUSH_TOKEN(ttype) cur_token++->type = (ttype)\n-#define REVISE_TOKEN(ttype) cur_token[-1].type = (ttype)\n-#define BACKUP_TOKEN(ttype) (--cur_token)->type = (ttype)\n-#define BACKUP_DIGRAPH(ttype) do { \\\n-  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n-\n /* An upper bound on the number of bytes needed to spell a token,\n    including preceding whitespace.  */\n static inline size_t TOKEN_LEN PARAMS ((const cpp_token *));\n@@ -366,7 +340,7 @@ cpp_scan_buffer (pfile, print)\n \n       if (token->flags & BOL)\n \t{\n-\t  output_line_command (pfile, print, pfile->token_list.line);\n+\t  output_line_command (pfile, print, token->line);\n \t  prev = 0;\n \n \t  if (token->type == CPP_HASH && pfile->token_list.directive)\n@@ -613,1229 +587,1117 @@ cpp_ideq (token, string)\n   return !ustrcmp (token->val.node->name, (const U_CHAR *)string);\n }\n \n-/* Lexing algorithm.\n-\n- The original lexer in cpplib was made up of two passes: a first pass\n- that replaced trigraphs and deleted esacped newlines, and a second\n- pass that tokenized the result of the first pass.  Tokenisation was\n- performed by peeking at the next character in the input stream.  For\n- example, if the input stream contained \"!=\", the handler for the !\n- character would peek at the next character, and if it were a '='\n- would skip over it, and return a \"!=\" token, otherwise it would\n- return just the \"!\" token.\n-\n- To implement a single-pass lexer, this peeking ahead is unworkable.\n- An arbitrary number of escaped newlines, and trigraphs (in particular\n- ??/ which translates to the escape \\), could separate the '!' and '='\n- in the input stream, yet the next token is still a \"!=\".\n-\n- Suppose instead that we lex by one logical line at a time, producing\n- a token list or stack for each logical line, and when seeing the '!'\n- push a CPP_NOT token on the list.  Then if the '!' is part of a\n- longer token (\"!=\") we know we must see the remainder of the token by\n- the time we reach the end of the logical line.  Thus we can have the\n- '=' handler look at the previous token (at the end of the list / top\n- of the stack) and see if it is a \"!\" token, and if so, instead of\n- pushing a \"=\" token revise the existing token to be a \"!=\" token.\n-\n- This works in the presence of escaped newlines, because the '\\' would\n- have been pushed on the top of the stack as a CPP_BACKSLASH.  The\n- newline ('\\n' or '\\r') handler looks at the token at the top of the\n- stack to see if it is a CPP_BACKSLASH, and if so discards both.\n- Hence the '=' handler would never see any intervening tokens.\n-\n- To make trigraphs work in this context, as in precedence trigraphs\n- are highest and converted before anything else, the '?' handler does\n- lookahead to see if it is a trigraph, and if so skips the trigraph\n- and pushes the token it represents onto the top of the stack.  This\n- also works in the particular case of a CPP_BACKSLASH trigraph.\n-\n- To the preprocessor, whitespace is only significant to the point of\n- knowing whether whitespace precedes a particular token.  For example,\n- the '=' handler needs to know whether there was whitespace between it\n- and a \"!\" token on the top of the stack, to make the token conversion\n- decision correctly.  So each token has a PREV_WHITE flag to\n- indicate this - the standard permits consecutive whitespace to be\n- regarded as a single space.  The compiler front ends are not\n- interested in whitespace at all; they just require a token stream.\n- Another place where whitespace is significant to the preprocessor is\n- a #define statment - if there is whitespace between the macro name\n- and an initial \"(\" token the macro is \"object-like\", otherwise it is\n- a function-like macro that takes arguments.\n-\n- However, all is not rosy.  Parsing of identifiers, numbers, comments\n- and strings becomes trickier because of the possibility of raw\n- trigraphs and escaped newlines in the input stream.\n-\n- The trigraphs are three consecutive characters beginning with two\n- question marks.  A question mark is not valid as part of a number or\n- identifier, so parsing of a number or identifier terminates normally\n- upon reaching it, returning to the mainloop which handles the\n- trigraph just like it would in any other position.  Similarly for the\n- backslash of a backslash-newline combination.  So we just need the\n- escaped-newline dropper in the mainloop to check if the token on the\n- top of the stack after dropping the escaped newline is a number or\n- identifier, and if so to continue the processing it as if nothing had\n- happened.\n-\n- For strings, we replace trigraphs whenever we reach a quote or\n- newline, because there might be a backslash trigraph escaping them.\n- We need to be careful that we start trigraph replacing from where we\n- left off previously, because it is possible for a first scan to leave\n- \"fake\" trigraphs that a second scan would pick up as real (e.g. the\n- sequence \"????/\\n=\" would find a fake ??= trigraph after removing the\n- escaped newline.)\n-\n- For line comments, on reaching a newline we scan the previous\n- character(s) to see if it escaped, and continue if it is.  Block\n- comments ignore everything and just focus on finding the comment\n- termination mark.  The only difficult thing, and it is surprisingly\n- tricky, is checking if an asterisk precedes the final slash since\n- they could be separated by escaped newlines.  If the preprocessor is\n- invoked with the output comments option, we don't bother removing\n- escaped newlines and replacing trigraphs for output.\n-\n- Finally, numbers can begin with a period, which is pushed initially\n- as a CPP_DOT token in its own right.  The digit handler checks if the\n- previous token was a CPP_DOT not separated by whitespace, and if so\n- pops it off the stack and pushes a period into the number's buffer\n- before calling the number parser.\n-\n-*/\n-\n static const unsigned char *digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n \t\t\t\t\t\t    U\":>\", U\"<%\", U\"%>\"};\n \n-/* Call when a trigraph is encountered.  It warns if necessary, and\n-   returns true if the trigraph should be honoured.  END is the third\n-   character of a trigraph in the input stream.  */\n+/* Call when meeting a newline.  Returns the character after the newline\n+   (or carriage-return newline combination), or EOF.  */\n+static cppchar_t\n+handle_newline (buffer, newline_char)\n+     cpp_buffer *buffer;\n+     cppchar_t newline_char;\n+{\n+  cppchar_t next = EOF;\n+\n+  buffer->col_adjust = 0;\n+  buffer->lineno++;\n+  buffer->line_base = buffer->cur;\n+\n+  /* Handle CR-LF and LF-CR combinations, get the next character.  */\n+  if (buffer->cur < buffer->rlimit)\n+    {\n+      next = *buffer->cur++;\n+      if (next + newline_char == '\\r' + '\\n')\n+\t{\n+\t  buffer->line_base = buffer->cur;\n+\t  if (buffer->cur < buffer->rlimit)\n+\t    next = *buffer->cur++;\n+\t  else\n+\t    next = EOF;\n+\t}\n+    }\n+\n+  buffer->read_ahead = next;\n+  return next;\n+}\n+\n+/* Subroutine of skip_escaped_newlines; called when a trigraph is\n+   encountered.  It warns if necessary, and returns true if the\n+   trigraph should be honoured.  FROM_CHAR is the third character of a\n+   trigraph, and presumed to be the previous character for position\n+   reporting.  */\n static int\n-trigraph_ok (pfile, end)\n+trigraph_ok (pfile, from_char)\n      cpp_reader *pfile;\n-     const unsigned char *end;\n+     cppchar_t from_char;\n {\n   int accept = CPP_OPTION (pfile, trigraphs);\n   \n   if (CPP_OPTION (pfile, warn_trigraphs))\n     {\n-      unsigned int col = end - 1 - pfile->buffer->line_base;\n+      cpp_buffer *buffer = pfile->buffer;\n       if (accept)\n-\tcpp_warning_with_line (pfile, pfile->buffer->lineno, col, \n+\tcpp_warning_with_line (pfile, buffer->lineno, CPP_BUF_COL (buffer) - 2,\n \t\t\t       \"trigraph ??%c converted to %c\",\n-\t\t\t       (int) *end, (int) _cpp_trigraph_map[*end]);\n+\t\t\t       (int) from_char,\n+\t\t\t       (int) _cpp_trigraph_map[from_char]);\n       else\n-\tcpp_warning_with_line (pfile, pfile->buffer->lineno, col,\n-\t\t\t       \"trigraph ??%c ignored\", (int) *end);\n+\tcpp_warning_with_line (pfile, buffer->lineno, CPP_BUF_COL (buffer) - 2,\n+\t\t\t       \"trigraph ??%c ignored\", (int) from_char);\n     }\n+\n   return accept;\n }\n \n-/* Scan a string for trigraphs, warning or replacing them inline as\n-   appropriate.  When parsing a string, we must call this routine\n-   before processing a newline character (if trigraphs are enabled),\n-   since the newline might be escaped by a preceding backslash\n-   trigraph sequence.  Returns a pointer to the end of the name after\n-   replacement.  */\n+/* Assumes local variables buffer and result.  */\n+#define ACCEPT_CHAR(t) \\\n+  do { result->type = t; buffer->read_ahead = EOF; } while (0)\n \n-static unsigned char *\n-trigraph_replace (pfile, src, limit)\n-     cpp_reader *pfile;\n-     unsigned char *src;\n-     unsigned char *limit;\n+/* When we move to multibyte character sets, add to these something\n+   that saves and restores the state of the multibyte conversion\n+   library.  This probably involves saving and restoring a \"cookie\".\n+   In the case of glibc it is an 8-byte structure, so is not a high\n+   overhead operation.  In any case, it's out of the fast path.  */\n+#define SAVE_STATE() do { saved_cur = buffer->cur; } while (0)\n+#define RESTORE_STATE() do { buffer->cur = saved_cur; } while (0)\n+\n+/* Skips any escaped newlines introduced by NEXT, which is either a\n+   '?' or a '\\\\'.  Returns the next character, which will also have\n+   been placed in buffer->read_ahead.  */\n+static cppchar_t\n+skip_escaped_newlines (buffer, next)\n+     cpp_buffer *buffer;\n+     cppchar_t next;\n {\n-  unsigned char *dest;\n+  cppchar_t next1;\n+  const unsigned char *saved_cur;\n+  int space;\n \n-  /* Starting with src[1], find two consecutive '?'.  The case of no\n-     trigraphs is streamlined.  */\n-  \n-  for (src++; src + 1 < limit; src += 2)\n+  do\n     {\n-      if (src[0] != '?')\n-\tcontinue;\n+      if (buffer->cur == buffer->rlimit)\n+\tbreak;\n+      \n+      SAVE_STATE ();\n+      if (next == '?')\n+\t{\n+\t  next1 = *buffer->cur++;\n+\t  if (next1 != '?' || buffer->cur == buffer->rlimit)\n+\t    {\n+\t      RESTORE_STATE ();\n+\t      break;\n+\t    }\n \n-      /* Make src point to the 1st (NOT 2nd) of two consecutive '?'s.  */\n-      if (src[-1] == '?')\n-\tsrc--;\n-      else if (src + 2 == limit || src[1] != '?')\n-\tcontinue;\n+\t  next1 = *buffer->cur++;\n+\t  if (!_cpp_trigraph_map[next1] || !trigraph_ok (buffer->pfile, next1))\n+\t    {\n+\t      RESTORE_STATE ();\n+\t      break;\n+\t    }\n \n-      /* Check if it really is a trigraph.  */\n-      if (_cpp_trigraph_map[src[2]] == 0)\n-\tcontinue;\n+\t  /* We have a full trigraph here.  */\n+\t  next = _cpp_trigraph_map[next1];\n+\t  if (next != '\\\\' || buffer->cur == buffer->rlimit)\n+\t    break;\n+\t  SAVE_STATE ();\n+\t}\n+\n+      /* We have a backslash, and room for at least one more character.  */\n+      space = 0;\n+      do\n+\t{\n+\t  next1 = *buffer->cur++;\n+\t  if (!is_nvspace (next1))\n+\t    break;\n+\t  space = 1;\n+\t}\n+      while (buffer->cur < buffer->rlimit);\n+\n+      if (!is_vspace (next1))\n+\t{\n+\t  RESTORE_STATE ();\n+\t  break;\n+\t}\n \n-      dest = src;\n-      goto trigraph_found;\n+      if (space)\n+\tcpp_warning (buffer->pfile,\n+\t\t     \"backslash and newline separated by space\");\n+\n+      next = handle_newline (buffer, next1);\n+      if (next == EOF)\n+\tcpp_pedwarn (buffer->pfile, \"backslash-newline at end of file\");\n     }\n-  return limit;\n+  while (next == '\\\\' || next == '?');\n \n-  /* Now we have a trigraph, we need to scan the remaining buffer, and\n-     copy-shifting its contents left if replacement is enabled.  */\n-  for (; src + 2 < limit; dest++, src++)\n-    if ((*dest = *src) == '?' && src[1] == '?' && _cpp_trigraph_map[src[2]])\n-      {\n-      trigraph_found:\n-\tsrc += 2;\n-\tif (trigraph_ok (pfile, pfile->buffer->cur - (limit - src)))\n-\t  *dest = _cpp_trigraph_map[*src];\n-      }\n-  \n-  /* Copy remaining (at most 2) characters.  */\n-  while (src < limit)\n-    *dest++ = *src++;\n-  return dest;\n+  buffer->read_ahead = next;\n+  return next;\n }\n \n-/* If CUR is a backslash or the end of a trigraphed backslash, return\n-   a pointer to its beginning, otherwise NULL.  We don't read beyond\n-   the buffer start, because there is the start of the comment in the\n-   buffer.  */\n-static const unsigned char *\n-backslash_start (pfile, cur)\n-     cpp_reader *pfile;\n-     const unsigned char *cur;\n+/* Obtain the next character, after trigraph conversion and skipping\n+   an arbitrary string of escaped newlines.  The common case of no\n+   trigraphs or escaped newlines falls through quickly.  */\n+static cppchar_t\n+get_effective_char (buffer)\n+     cpp_buffer *buffer;\n {\n-  if (cur[0] == '\\\\')\n-    return cur;\n-  if (cur[0] == '/' && cur[-1] == '?' && cur[-2] == '?'\n-      && trigraph_ok (pfile, cur))\n-    return cur - 2;\n-  return 0;\n+  cppchar_t next = EOF;\n+\n+  if (buffer->cur < buffer->rlimit)\n+    {\n+      next = *buffer->cur++;\n+\n+      /* '?' can introduce trigraphs (and therefore backslash); '\\\\'\n+\t can introduce escaped newlines, which we want to skip, or\n+\t UCNs, which, depending upon lexer state, we will handle in\n+\t the future.  */\n+      if (next == '?' || next == '\\\\')\n+\tnext = skip_escaped_newlines (buffer, next);\n+    }\n+\n+  buffer->read_ahead = next;\n+  return next;\n }\n \n-/* Skip a C-style block comment.  This is probably the trickiest\n-   handler.  We find the end of the comment by seeing if an asterisk\n-   is before every '/' we encounter.  The nasty complication is that a\n-   previous asterisk may be separated by one or more escaped newlines.\n-   Returns non-zero if comment terminated by EOF, zero otherwise.  */\n+/* Skip a C-style block comment.  We find the end of the comment by\n+   seeing if an asterisk is before every '/' we encounter.  Returns\n+   non-zero if comment terminated by EOF, zero otherwise.  */\n static int\n skip_block_comment (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  const unsigned char *char_after_star = 0;\n-  const unsigned char *cur = buffer->cur;\n-  \n-  for (; cur < buffer->rlimit; )\n+  cppchar_t c = EOF, prevc;\n+\n+  while (buffer->cur != buffer->rlimit)\n     {\n-      unsigned char c = *cur++;\n+      prevc = c, c = *buffer->cur++;\n \n-      /* People like decorating comments with '*', so check for\n-\t '/' instead for efficiency.  */\n+    next_char:\n+      /* FIXME: For speed, create a new character class of characters\n+\t of no interest inside block comments.  */\n+      if (c == '?' || c == '\\\\')\n+\tc = skip_escaped_newlines (buffer, c);\n+\n+      /* People like decorating comments with '*', so check for '/'\n+\t instead for efficiency.  */\n       if (c == '/')\n \t{\n-\t  /* Don't view / then * then / as finishing the comment.  */\n-\t  if ((cur[-2] == '*' && cur - 1 > buffer->cur)\n-\t      || cur - 1 == char_after_star)\n-\t    {\n-\t      buffer->cur = cur;\n-\t      return 0;\n-\t    }\n+\t  if (prevc == '*')\n+\t    break;\n \n-\t  /* Warn about potential nested comments, but not when\n-\t     the final character inside the comment is a '/'.\n+\t  /* Warn about potential nested comments, but not if the '/'\n+\t     comes immediately before the true comment delimeter.\n \t     Don't bother to get it right across escaped newlines.  */\n-\t  if (CPP_OPTION (pfile, warn_comments) && cur + 1 < buffer->rlimit\n-\t      && cur[0] == '*' && cur[1] != '/') \n+\t  if (CPP_OPTION (pfile, warn_comments)\n+\t      && buffer->cur != buffer->rlimit)\n \t    {\n-\t      buffer->cur = cur;\n-\t      cpp_warning (pfile, \"'/*' within comment\");\n+\t      prevc = c, c = *buffer->cur++;\n+\t      if (c == '*' && buffer->cur != buffer->rlimit)\n+\t\t{\n+\t\t  prevc = c, c = *buffer->cur++;\n+\t\t  if (c != '/') \n+\t\t    cpp_warning_with_line (pfile, CPP_BUF_LINE (buffer),\n+\t\t\t\t\t   CPP_BUF_COL (buffer),\n+\t\t\t\t\t   \"\\\"/*\\\" within comment\");\n+\t\t}\n+\t      goto next_char;\n \t    }\n \t}\n       else if (is_vspace (c))\n \t{\n-\t  const unsigned char* bslash = backslash_start (pfile, cur - 2);\n-\n-\t  handle_newline (cur, buffer->rlimit, c);\n-\t  /* Work correctly if there is an asterisk before an\n-\t     arbirtrarily long sequence of escaped newlines.  */\n-\t  if (bslash && (bslash[-1] == '*' || bslash == char_after_star))\n-\t    char_after_star = cur;\n-\t  else\n-\t    char_after_star = 0;\n+\t  prevc = c, c = handle_newline (buffer, c);\n+\t  goto next_char;\n \t}\n       else if (c == '\\t')\n-\tadjust_column (pfile, cur - 1);\n+\tadjust_column (pfile);\n     }\n \n-  buffer->cur = cur;\n-  return 1;\n+  buffer->read_ahead = EOF;\n+  return c != '/' || prevc != '*';\n }\n \n /* Skip a C++ line comment.  Handles escaped newlines.  Returns\n-   non-zero if a multiline comment.  */\n+   non-zero if a multiline comment.  The following new line, if any,\n+   is left in buffer->read_ahead.  */\n static int\n-skip_line_comment (pfile)\n-     cpp_reader *pfile;\n+skip_line_comment (buffer)\n+     cpp_buffer *buffer;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  register const unsigned char *cur = buffer->cur;\n-  int multiline = 0;\n+  unsigned int orig_lineno = buffer->lineno;\n+  cppchar_t c;\n \n-  for (; cur < buffer->rlimit; )\n+  do\n     {\n-      unsigned char c = *cur++;\n+      c = EOF;\n+      if (buffer->cur == buffer->rlimit)\n+\tbreak;\n \n-      if (is_vspace (c))\n-\t{\n-\t  /* Check for a (trigaph?) backslash escaping the newline.  */\n-\t  if (!backslash_start (pfile, cur - 2))\n-\t    goto out;\n-\t  multiline = 1;\n-\t  handle_newline (cur, buffer->rlimit, c);\n-\t}\n+      c = *buffer->cur++;\n+      if (c == '?' || c == '\\\\')\n+\tc = skip_escaped_newlines (buffer, c);\n     }\n-  cur++;\n+  while (!is_vspace (c));\n \n- out:\n-  buffer->cur = cur - 1;\t/* Leave newline for caller.  */\n-  return multiline;\n+  buffer->read_ahead = c;\t/* Leave any newline for caller.  */\n+  return orig_lineno != buffer->lineno;\n }\n \n-/* TAB points to a \\t character.  Update col_adjust so we track the\n-   column correctly.  */\n+/* pfile->buffer->cur is one beyond the \\t character.  Update\n+   col_adjust so we track the column correctly.  */\n static void\n-adjust_column (pfile, tab)\n+adjust_column (pfile)\n      cpp_reader *pfile;\n-     const U_CHAR *tab;\n {\n-  /* Zero-based column.  */\n-  unsigned int col = CPP_BUF_COLUMN (pfile->buffer, tab);\n+  cpp_buffer *buffer = pfile->buffer;\n+  unsigned int col = CPP_BUF_COL (buffer) - 1; /* Zero-based column.  */\n \n   /* Round it up to multiple of the tabstop, but subtract 1 since the\n      tab itself occupies a character position.  */\n-  pfile->col_adjust += (CPP_OPTION (pfile, tabstop)\n-\t\t\t- col % CPP_OPTION (pfile, tabstop)) - 1;\n+  buffer->col_adjust += (CPP_OPTION (pfile, tabstop)\n+\t\t\t - col % CPP_OPTION (pfile, tabstop)) - 1;\n }\n \n-/* Skips whitespace, stopping at next non-whitespace character.\n-   Adjusts pfile->col_adjust to account for tabs.  This enables tokens\n-   to be assigned the correct column.  */\n+/* Skips whitespace, saving the next non-whitespace character.\n+   Adjusts pfile->col_adjust to account for tabs.  Without this,\n+   tokens might be assigned an incorrect column.  */\n static void\n-skip_whitespace (pfile, in_directive)\n+skip_whitespace (pfile, c)\n      cpp_reader *pfile;\n-     int in_directive;\n+     cppchar_t c;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned short warned = 0;\n+  unsigned int warned = 0;\n \n-  /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0. */\n-  while (buffer->cur < buffer->rlimit)\n+  do\n     {\n-      unsigned char c = *buffer->cur;\n-\n-      if (!is_nvspace (c))\n-\tbreak;\n-\n-      buffer->cur++;\n       /* Horizontal space always OK.  */\n       if (c == ' ')\n-\tcontinue;\n+\t;\n       else if (c == '\\t')\n-\tadjust_column (pfile, buffer->cur - 1);\n-      /* Must be \\f \\v or \\0.  */\n+\tadjust_column (pfile);\n+      /* Just \\f \\v or \\0 left.  */\n       else if (c == '\\0')\n \t{\n \t  if (!warned)\n-\t    cpp_warning_with_line (pfile, CPP_BUF_LINE (buffer),\n-\t\t\t\t   CPP_BUF_COL (buffer),\n-\t\t\t\t   \"embedded null character ignored\");\n-\t  warned = 1;\n+\t    {\n+\t      cpp_warning (pfile, \"null character(s) ignored\");\n+\t      warned = 1;\n+\t    }\n \t}\n-      else if (in_directive && CPP_PEDANTIC (pfile))\n+      else if (IN_DIRECTIVE (pfile) && CPP_PEDANTIC (pfile))\n \tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n \t\t\t       CPP_BUF_COL (buffer),\n \t\t\t       \"%s in preprocessing directive\",\n \t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n+\n+      c = EOF;\n+      if (buffer->cur == buffer->rlimit)\n+\tbreak;\n+      c = *buffer->cur++;\n     }\n+  /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0. */\n+  while (is_nvspace (c));\n+\n+  /* Remember the next character.  */\n+  buffer->read_ahead = c;\n }\n \n-/* Parse (append) an identifier.  Calculates the hash value of the\n-   token while parsing, for performance.  The algorithm *must* match\n-   cpp_lookup().  */\n-static const U_CHAR *\n-parse_name (pfile, tok, cur, rlimit)\n+/* Parse an identifier, skipping embedded backslash-newlines.\n+   Calculate the hash value of the token while parsing, for improved\n+   performance.  The hashing algorithm *must* match cpp_lookup().  */\n+\n+static cpp_hashnode *\n+parse_identifier (pfile, c)\n      cpp_reader *pfile;\n-     cpp_token *tok;\n-     const U_CHAR *cur, *rlimit;\n+     cppchar_t c;\n {\n-  const U_CHAR *name;\n-  unsigned int len;\n-  unsigned int r;\n+  cpp_buffer *buffer = pfile->buffer;\n+  unsigned int r = 0, saw_dollar = 0;\n+  unsigned int orig_used = pfile->token_list.name_used;\n \n-  name = cur;\n-  r = 0;\n-  while (cur < rlimit)\n+  do\n     {\n-      if (! is_idchar (*cur))\n-\tbreak;\n-      /* $ is not a identifier character in the standard, but is\n-\t commonly accepted as an extension.  Don't warn about it in\n-\t skipped conditional blocks. */\n-      if (*cur == '$' && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n+      do\n \t{\n-\t  CPP_BUFFER (pfile)->cur = cur;\n-\t  cpp_pedwarn (pfile, \"'$' character in identifier\");\n-\t}\n-\n-      r = HASHSTEP (r, cur);\n-      cur++;\n-    }\n-  len = cur - name;\n+\t  if (pfile->token_list.name_used == pfile->token_list.name_cap)\n+\t    _cpp_expand_name_space (&pfile->token_list,\n+\t\t\t\t    pfile->token_list.name_used + 256);\n+\t  pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n+\t  r = HASHSTEP (r, c);\n \n-  if (tok->type == CPP_NAME && tok->val.node == 0)\n-    tok->val.node = _cpp_lookup_with_hash (pfile, name, len, r);\n-  else\n-    {\n-      unsigned int oldlen;\n-      U_CHAR *newname;\n+\t  if (c == '$')\n+\t    saw_dollar++;\n \n-      if (tok->type == CPP_NAME)\n-\toldlen = tok->val.node->length;\n-      else\n-\toldlen = 1;\n+\t  c = EOF;\n+\t  if (buffer->cur == buffer->rlimit)\n+\t    break;\n \n-      newname = alloca (oldlen + len);\n+\t  c = *buffer->cur++;\n+\t}\n+      while (is_idchar (c));\n \n-      if (tok->type == CPP_NAME)\n-\tmemcpy (newname, tok->val.node->name, oldlen);\n-      else\n-\tnewname[0] = tok->val.aux;\n-      memcpy (newname + oldlen, name, len);\n-      tok->val.node = cpp_lookup (pfile, newname, len + oldlen);\n-      tok->type = CPP_NAME;\n+      /* Potential escaped newline?  */\n+      if (c != '?' && c != '\\\\')\n+\tbreak;\n+      c = skip_escaped_newlines (buffer, c);\n     }\n+  while (is_idchar (c));\n+\n+  /* $ is not a identifier character in the standard, but is commonly\n+     accepted as an extension.  Don't warn about it in skipped\n+     conditional blocks.  */\n+  if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n+    cpp_pedwarn (pfile, \"'$' character(s) in identifier\");\n \n-  return cur;\n+  /* Remember the next character.  */\n+  buffer->read_ahead = c;\n+  return _cpp_lookup_with_hash (pfile, &pfile->token_list.namebuf[orig_used],\n+\t\t\t\tpfile->token_list.name_used - orig_used, r);\n }\n \n-/* Parse (append) a number.  */\n+/* Parse a number, skipping embedded backslash-newlines.  */\n static void\n-parse_number (pfile, list, name)\n+parse_number (pfile, number, c)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n-     cpp_string *name;\n+     cpp_string *number;\n+     cppchar_t c;\n {\n-  const unsigned char *name_limit;\n-  unsigned char *namebuf;\n+  cppchar_t prevc;\n   cpp_buffer *buffer = pfile->buffer;\n-  register const unsigned char *cur = buffer->cur;\n+  unsigned int orig_used = pfile->token_list.name_used;\n \n- expanded:\n-  name_limit = list->namebuf + list->name_cap;\n-  namebuf = list->namebuf + list->name_used;\n-\n-  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+  do\n     {\n-      unsigned char c = *namebuf = *cur; /* Copy a single char.  */\n+      do\n+\t{\n+\t  if (pfile->token_list.name_used == pfile->token_list.name_cap)\n+\t    _cpp_expand_name_space (&pfile->token_list,\n+\t\t\t\t    pfile->token_list.name_used + 256);\n+\t  pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n+\n+\t  prevc = c;\n+\t  c = EOF;\n+\t  if (buffer->cur == buffer->rlimit)\n+\t    break;\n \n-      /* Perhaps we should accept '$' here if we accept it for\n-         identifiers.  We know namebuf[-1] is safe, because for c to\n-         be a sign we must have pushed at least one character.  */\n-      if (!is_numchar (c) && c != '.' && ! VALID_SIGN (c, namebuf[-1]))\n-\tgoto out;\n+\t  c = *buffer->cur++;\n+\t}\n+      while (is_numchar (c) || c == '.' || VALID_SIGN (c, prevc));\n \n-      namebuf++;\n-      cur++;\n+      /* Potential escaped newline?  */\n+      if (c != '?' && c != '\\\\')\n+\tbreak;\n+      c = skip_escaped_newlines (buffer, c);\n     }\n+  while (is_numchar (c) || c == '.' || VALID_SIGN (c, prevc));\n+\n+  /* Remember the next character.  */\n+  buffer->read_ahead = c;\n \n-  /* Run out of name space?  */\n-  if (cur < buffer->rlimit)\n+  number->text = &pfile->token_list.namebuf[orig_used];\n+  number->len = pfile->token_list.name_used - orig_used;\n+}\n+\n+/* Subroutine of parse_string.  Emits error for unterminated strings.  */\n+static void\n+unterminated (pfile, line, term)\n+     cpp_reader *pfile;\n+     unsigned int line;\n+     int term;\n+{\n+  cpp_error (pfile, \"missing terminating %c character\", term);\n+\n+  if (term == '\\\"' && pfile->mls_line && pfile->mls_line != line)\n     {\n-      list->name_used = namebuf - list->namebuf;\n-      auto_expand_name_space (list);\n-      goto expanded;\n+      cpp_error_with_line (pfile, pfile->mls_line, pfile->mls_column,\n+\t\t\t   \"possible start of unterminated string literal\");\n+      pfile->mls_line = 0;\n     }\n-  \n- out:\n-  buffer->cur = cur;\n-  name->len = namebuf - name->text;\n-  list->name_used = namebuf - list->namebuf;\n }\n \n-/* Places a string terminated by an unescaped TERMINATOR into a\n-   cpp_string, which should be expandable and thus at the top of the\n-   list's stack.  Handles embedded trigraphs, if necessary, and\n-   escaped newlines.\n-\n-   Can be used for character constants (terminator = '\\''), string\n-   constants ('\"') and angled headers ('>').  Multi-line strings are\n-   allowed, except for within directives.  */\n+/* Parses a string, character constant, or angle-bracketed header file\n+   name.  Handles embedded trigraphs and escaped newlines.\n \n+   Multi-line strings are allowed, but they are deprecated within\n+   directives.  */\n static void\n-parse_string (pfile, list, token, terminator)\n+parse_string (pfile, token, terminator)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n      cpp_token *token;\n-     unsigned int terminator;\n+     cppchar_t terminator;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cpp_string *name = &token->val.str;\n-  register const unsigned char *cur = buffer->cur;\n-  const unsigned char *name_limit;\n-  unsigned char *namebuf;\n-  unsigned int null_count = 0;\n-  unsigned int trigraphed = list->name_used;\n-\n- expanded:\n-  name_limit = list->namebuf + list->name_cap;\n-  namebuf = list->namebuf + list->name_used;\n-\n-  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+  unsigned int orig_used = pfile->token_list.name_used;\n+  cppchar_t c;\n+  unsigned int nulls = 0;\n+\n+  for (;;)\n     {\n-      unsigned int c = *namebuf++ = *cur++; /* Copy a single char.  */\n+      if (buffer->cur == buffer->rlimit)\n+\t{\n+\t  c = EOF;\n+\t  unterminated (pfile, token->line, terminator);\n+\t  break;\n+\t}\n+      c = *buffer->cur++;\n \n-      if (c == '\\0')\n-\tnull_count++;\n-      else if (c == terminator || is_vspace (c))\n+    have_char:\n+      /* Handle trigraphs, escaped newlines etc.  */\n+      if (c == '?' || c == '\\\\')\n+\tc = skip_escaped_newlines (buffer, c);\n+\n+      if (c == terminator)\n \t{\n-\t  /* Needed for trigraph_replace and multiline string warning.  */\n-\t  buffer->cur = cur;\n+\t  unsigned int u = pfile->token_list.name_used;\n+\n+\t  /* An odd number of consecutive backslashes represents an\n+\t     escaped terminator.  */\n+\t  while (u > orig_used && pfile->token_list.namebuf[u - 1] == '\\\\')\n+\t    u--;\n \n-\t  /* Scan for trigraphs before checking if backslash-escaped.  */\n-\t  if ((CPP_OPTION (pfile, trigraphs)\n-\t       || CPP_OPTION (pfile, warn_trigraphs))\n-\t      && namebuf - (list->namebuf + trigraphed) >= 3)\n+\t  if ((pfile->token_list.name_used - u) % 2 == 0)\n \t    {\n-\t      namebuf = trigraph_replace (pfile, list->namebuf + trigraphed,\n-\t\t\t\t\t  namebuf);\n-\t      /* The test above guarantees trigraphed will be positive.  */\n-\t      trigraphed = namebuf - list->namebuf - 2;\n+\t      c = EOF;\n+\t      break;\n \t    }\n+\t}\n+      else if (is_vspace (c))\n+\t{\n+\t  /* In assembly language, silently terminate string and\n+\t     character literals at end of line.  This is a kludge\n+\t     around not knowing where comments are.  */\n+\t  if (CPP_OPTION (pfile, lang_asm) && terminator != '>')\n+\t    break;\n \n-\t  namebuf--;     /* Drop the newline / terminator from the name.  */\n-\t  if (is_vspace (c))\n+\t  /* Character constants and header names may not extend over\n+\t     multiple lines.  In Standard C, neither may strings.\n+\t     Unfortunately, we accept multiline strings as an\n+\t     extension.  (Deprecatedly even in directives - otherwise,\n+\t     glibc's longlong.h breaks.)  */\n+\t  if (terminator != '\"')\n \t    {\n-\t      /* Drop a backslash newline, and continue. */\n-\t      U_CHAR *old = namebuf;\n-\t      while (namebuf > list->namebuf && is_hspace (namebuf[-1]))\n-\t\tnamebuf--;\n-\t      if (namebuf > list->namebuf && namebuf[-1] == '\\\\')\n-\t\t{\n-\t\t  handle_newline (cur, buffer->rlimit, c);\n-\t\t  namebuf--;\n-\t\t  if (old[-1] != '\\\\')\n-\t\t    {\n-\t\t      buffer->cur = cur;\n-\t\t      cpp_warning (pfile,\n-\t\t\t\t   \"backslash and newline separated by space\");\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\tnamebuf = old;\n-\n-\t      cur--;\n-\n-\t      /* In assembly language, silently terminate strings of\n-\t\t either variety at end of line.  This is a kludge\n-\t\t around not knowing where comments are.  */\n-\t      if (CPP_OPTION (pfile, lang_asm))\n-\t\tgoto out;\n-\n-\t      /* Character constants and header names may not extend\n-\t\t over multiple lines.  In Standard C, neither may\n-\t\t strings.  We accept multiline strings as an\n-\t\t extension.  (Even in directives - otherwise, glibc's\n-\t\t longlong.h breaks.)  */\n-\t      if (terminator != '\"')\n-\t\tgoto unterminated;\n-\t\t\n-\t      cur++;  /* Move forwards again.  */\n-\n-\t      if (pfile->multiline_string_line == 0)\n-\t\t{\n-\t\t  pfile->multiline_string_line = token->line;\n-\t\t  pfile->multiline_string_column = token->col;\n-\t\t  if (CPP_PEDANTIC (pfile))\n-\t\t    cpp_pedwarn (pfile, \"multi-line string constant\");\n-\t\t}\n-\n-\t      *namebuf++ = '\\n';\n-\t      handle_newline (cur, buffer->rlimit, c);\n+\t      unterminated (pfile, token->line, terminator);\n+\t      break;\n \t    }\n-\t  else\n-\t    {\n-\t      unsigned char *temp;\n \n-\t      /* An odd number of consecutive backslashes represents\n-\t\t an escaped terminator.  */\n-\t      temp = namebuf - 1;\n-\t      while (temp >= name->text && *temp == '\\\\')\n-\t\ttemp--;\n-\n-\t      if ((namebuf - temp) & 1)\n-\t\tgoto out;\n-\t      namebuf++;\n+\t  if (pfile->mls_line == 0)\n+\t    {\n+\t      pfile->mls_line = token->line;\n+\t      pfile->mls_column = token->col;\n+\t      if (CPP_PEDANTIC (pfile))\n+\t\tcpp_pedwarn (pfile, \"multi-line string constant\");\n \t    }\n+\t      \n+\t  handle_newline (buffer, c);  /* Stores to read_ahead.  */\n+\t  c = '\\n';\n+\t}\n+      else if (c == '\\0')\n+\t{\n+\t  if (nulls++ == 0)\n+\t    cpp_warning (pfile, \"null character(s) preserved in literal\");\n \t}\n-    }\n-\n-  /* Run out of name space?  */\n-  if (cur < buffer->rlimit)\n-    {\n-      list->name_used = namebuf - list->namebuf;\n-      auto_expand_name_space (list);\n-      goto expanded;\n-    }\n-\n-  /* We may not have trigraph-replaced the input for this code path,\n-     but as the input is in error by being unterminated we don't\n-     bother.  Prevent warnings about no newlines at EOF.  */\n-  if (is_vspace (cur[-1]))\n-    cur--;\n \n- unterminated:\n-  cpp_error (pfile, \"missing terminating %c character\", (int) terminator);\n+      if (pfile->token_list.name_used == pfile->token_list.name_cap)\n+\t_cpp_expand_name_space (&pfile->token_list,\n+\t\t\t\tpfile->token_list.name_used + 256);\n \n-  if (terminator == '\\\"' && pfile->multiline_string_line != list->line\n-      && pfile->multiline_string_line != 0)\n-    {\n-      cpp_error_with_line (pfile, pfile->multiline_string_line,\n-\t\t\t   pfile->multiline_string_column,\n-\t\t\t   \"possible start of unterminated string literal\");\n-      pfile->multiline_string_line = 0;\n+      pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n+      /* If we had a new line, the next character is in read_ahead.  */\n+      if (c != '\\n')\n+\tcontinue;\n+      c = buffer->read_ahead;\n+      if (c != EOF)\n+\tgoto have_char;\n     }\n-  \n- out:\n-  buffer->cur = cur;\n-  name->len = namebuf - name->text;\n-  list->name_used = namebuf - list->namebuf;\n \n-  if (null_count > 0)\n-    cpp_warning (pfile, (null_count > 1 ? \"null characters preserved\"\n-\t\t\t : \"null character preserved\"));\n-}\n+  buffer->read_ahead = c;\n \n-/* The character TYPE helps us distinguish comment types: '*' = C\n-   style, '/' = C++ style.  For code simplicity, the stored comment\n-   includes the comment start and any terminator.  */\n+  token->val.str.text = &pfile->token_list.namebuf[orig_used];\n+  token->val.str.len = pfile->token_list.name_used - orig_used;\n+}\n \n-#define COMMENT_START_LEN 2\n+/* For output routine simplicity, the stored comment includes the\n+   comment start and any terminator.  */\n static void\n-save_comment (list, token, from, len, type)\n-     cpp_toklist *list;\n+save_comment (pfile, token, from)\n+     cpp_reader *pfile;\n      cpp_token *token;\n      const unsigned char *from;\n-     unsigned int len;\n-     unsigned int type;\n {\n   unsigned char *buffer;\n+  unsigned int len;\n+  cpp_toklist *list = &pfile->token_list;\n+  \n+#define COMMENT_START_LEN 2\n+  len = pfile->buffer->cur - from + COMMENT_START_LEN;\n+  _cpp_reserve_name_space (list, len);\n+  buffer = list->namebuf + list->name_used;\n+  list->name_used += len;\n   \n-  len += COMMENT_START_LEN;\n-\n-  if (list->name_used + len > list->name_cap)\n-    _cpp_expand_name_space (list, len);\n-\n-  INIT_TOKEN_STR (list, token);\n   token->type = CPP_COMMENT;\n   token->val.str.len = len;\n+  token->val.str.text = buffer;\n \n-  buffer = list->namebuf + list->name_used;\n-  list->name_used += len;\n+  /* from[-1] is '/' or '*' depending on the comment type.  */\n+  *buffer++ = '/';\n+  *buffer++ = from[-1];\n+  memcpy (buffer, from, len - COMMENT_START_LEN);\n+}\n \n-  /* Copy the comment.  */\n-  if (type == '*')\n-    {\n-      *buffer++ = '/';\n-      *buffer++ = '*';\n-    }\n+/* A helper routine for lex_token.  With some long tokens, we need\n+   to read ahead to see if that is the token we have, but back-track\n+   if not.  */\n+static void\n+check_long_token (buffer, result, wanted, type)\n+     cpp_buffer *buffer;\n+     cpp_token *result;\n+     cppchar_t wanted;\n+     enum cpp_ttype type;\n+{\n+  const unsigned char *saved_cur;\n+  cppchar_t c = buffer->read_ahead;\n+\n+  SAVE_STATE ();\n+  if (get_effective_char (buffer) == wanted)\n+    ACCEPT_CHAR (type);\n   else\n     {\n-      *buffer++ = type;\n-      *buffer++ = type;\n+      /* Restore state.  */\n+      RESTORE_STATE ();\n+      buffer->read_ahead = c;\n     }\n-  memcpy (buffer, from, len - COMMENT_START_LEN);\n }\n \n-/*\n- *  The tokenizer's main loop.  Returns a token list, representing a\n- *  logical line in the input file.  On EOF after some tokens have\n- *  been processed, we return immediately.  Then in next call, or if\n- *  EOF occurred at the beginning of a logical line, a single CPP_EOF\n- *  token is placed in the list.\n- *\n- *  Implementation relies almost entirely on lookback, rather than\n- *  looking forwards.  This means that tokenization requires just\n- *  a single pass of the file, even in the presence of trigraphs and\n- *  escaped newlines, providing significant performance benefits.\n- *  Trigraph overhead is negligible if they are disabled, and low\n- *  even when enabled.\n- */\n-\n-#define KNOWN_DIRECTIVE() (list->directive != 0)\n-#define MIGHT_BE_DIRECTIVE() \\\n-(cur_token == &list->tokens[first_token + 1] && cur_token[-1].type == CPP_HASH)\n-\n static void\n-lex_line (pfile, list)\n+lex_token (pfile, result)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n+     cpp_token *result;\n {\n-  cpp_token *cur_token, *token_limit, *first;\n+  cppchar_t c;\n   cpp_buffer *buffer = pfile->buffer;\n-  const unsigned char *cur = buffer->cur;\n-  unsigned char flags = 0;\n-  unsigned int first_token = list->tokens_used;\n+  const unsigned char *comment_start;\n \n-  if (!(list->flags & LIST_OFFSET))\n-    (abort) ();\n-\n- retry:\n-  list->file = buffer->nominal_fname;\n-  list->line = CPP_BUF_LINE (buffer);\n-  pfile->col_adjust = 0;\n-  pfile->in_lex_line = 1;\n-  if (cur == buffer->buf)\n-    list->flags |= BEG_OF_FILE;\n+  result->flags = 0;\n+ next_char:\n+  result->line = CPP_BUF_LINE (buffer);\n+ next_char2:\n+  result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n \n- expanded:\n-  token_limit = list->tokens + list->tokens_cap;\n-  cur_token = list->tokens + list->tokens_used;\n+  c = buffer->read_ahead;\n+  if (c == EOF && buffer->cur < buffer->rlimit)\n+    {\n+      c = *buffer->cur++;\n+      result->col++;\n+    }\n \n-  for (; cur < buffer->rlimit && cur_token < token_limit;)\n+ do_switch:\n+  buffer->read_ahead = EOF;\n+  switch (c)\n     {\n-      unsigned char c;\n+    case EOF:\n+      /* Non-empty files should end in a newline.  Testing\n+         skip_newlines ensures we only emit the warning once.  */\n+      if (buffer->cur != buffer->line_base && buffer->cur != buffer->buf\n+\t  && pfile->state.skip_newlines)\n+\tcpp_pedwarn_with_line (pfile, buffer->lineno, CPP_BUF_COL (buffer),\n+\t\t\t       \"no newline at end of file\");\n+      result->type = CPP_EOF;\n+      break;\n \n-      /* Optimize non-vertical whitespace skipping; most tokens are\n-\t probably separated by whitespace. (' ' '\\t' '\\v' '\\f' '\\0').  */\n-      c = *cur;\n-      if (is_nvspace (c))\n+    case ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n+      skip_whitespace (pfile, c);\n+      result->flags |= PREV_WHITE;\n+      goto next_char2;\n+\n+    case '\\n': case '\\r':\n+      result->type = CPP_EOF;\n+      handle_newline (buffer, c);\n+      /* Handling here will change significantly when moving to\n+\t token-at-a-time.  */\n+      if (pfile->state.skip_newlines)\n \t{\n-\t  buffer->cur = cur;\n-\t  skip_whitespace (pfile, (list->tokens[first_token].type == CPP_HASH\n-\t\t\t\t   && cur_token > &list->tokens[first_token]));\n-\t  cur = buffer->cur;\n-\n-\t  flags = PREV_WHITE;\n-\t  if (cur == buffer->rlimit)\n-\t    break;\n-\t  c = *cur;\n+\t  result->flags &= ~PREV_WHITE; /* Clear any whitespace flag.   */\n+\t  goto next_char;\n \t}\n-      cur++;\n-\n-      /* Initialize current token.  CPP_EOF will not be fixed up by\n-\t expand_name_space.  */\n-      list->tokens_used = cur_token - list->tokens + 1;\n-      cur_token->type = CPP_EOF;\n-      cur_token->col = CPP_BUF_COLUMN (buffer, cur);\n-      cur_token->line = CPP_BUF_LINE (buffer);\n-      cur_token->flags = flags;\n-      flags = 0;\n-\n-      switch (c)\n-\t{\n-\tcase '0': case '1': case '2': case '3': case '4':\n-\tcase '5': case '6': case '7': case '8': case '9':\n-\t  {\n-\t    int prev_dot;\n-\n-\t    cur--;\t\t/* Backup character.  */\n-\t    prev_dot = PREV_TOKEN_TYPE == CPP_DOT && IMMED_TOKEN ();\n-\t    if (prev_dot)\n-\t      cur_token--;\n-\t    INIT_TOKEN_STR (list, cur_token);\n-\t    /* Prepend an immediately previous CPP_DOT token.  */\n-\t    if (prev_dot)\n-\t      {\n-\t\tif (list->name_cap == list->name_used)\n-\t\t  auto_expand_name_space (list);\n+      break;\n \n-\t\tcur_token->val.str.len = 1;\n-\t\tlist->namebuf[list->name_used++] = '.';\n-\t      }\n+    case '?':\n+    case '\\\\':\n+      /* These could start an escaped newline, or '?' a trigraph.  Let\n+\t skip_escaped_newlines do all the work.  */\n+      {\n+\tunsigned int lineno = buffer->lineno;\n+\n+\tc = skip_escaped_newlines (buffer, c);\n+\tif (lineno != buffer->lineno)\n+\t  /* We had at least one escaped newline of some sort, and the\n+\t     next character is in buffer->read_ahead.  Update the\n+\t     token's line and column.  */\n+\t    goto next_char;\n+\n+\t/* We are either the original '?' or '\\\\', or a trigraph.  */\n+\tresult->type = CPP_QUERY;\n+\tbuffer->read_ahead = EOF;\n+\tif (c == '\\\\')\n+\t  result->type = CPP_BACKSLASH;\n+\telse if (c != '?')\n+\t  goto do_switch;\n+      }\n+      break;\n \n-\t  continue_number:\n-\t    cur_token->type = CPP_NUMBER; /* Before parse_number.  */\n-\t    buffer->cur = cur;\n-\t    parse_number (pfile, list, &cur_token->val.str);\n-\t    cur = buffer->cur;\n-\t  }\n-\t  /* Check for # 123 form of #line.  */\n-\t  if (MIGHT_BE_DIRECTIVE ())\n-\t    list->directive = _cpp_check_linemarker (pfile, cur_token,\n-\t\t\t\t\t\t     !(cur_token[-1].flags\n-\t\t\t\t\t\t       & PREV_WHITE));\n-\t  cur_token++;\n-\t  break;\n+    make_number:\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+      result->type = CPP_NUMBER;\n+      parse_number (pfile, &result->val.str, c);\n+      break;\n \n-\tletter:\n-\tcase '_':\n-\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n-\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n-\tcase 'y': case 'z':\n-\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n-\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-\tcase 'Y': case 'Z':\n-\t  cur--;\t\t     /* Backup character.  */\n-\n-\t  /* In Objective C, '@' may begin certain keywords.  */\n-\t  if (CPP_OPTION (pfile, objc) && cur_token[-1].type == CPP_OTHER\n-\t      && cur_token[-1].val.aux == '@' && IMMED_TOKEN ())\n-\t    cur_token--;\n-\t  else\n+    case '$':\n+      if (!CPP_OPTION (pfile, dollars_in_ident))\n+\tgoto random_char;\n+      /* Fall through... */\n+\n+    case '_':\n+    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+    case 'y': case 'z':\n+    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+    case 'Y': case 'Z':\n+      result->type = CPP_NAME;\n+      result->val.node = parse_identifier (pfile, c);\n+\n+      /* 'L' may introduce wide characters or strings.  */\n+      if (result->val.node == pfile->spec_nodes->n_L)\n+\t{\n+\t  c = buffer->read_ahead; /* For make_string.  */\n+\t  if (c == '\\'' || c == '\"')\n \t    {\n-\t      cur_token->val.node = 0;\n-\t      cur_token->type = CPP_NAME; /* Identifier, macro etc.  */\n+\t      ACCEPT_CHAR (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n+\t      goto make_string;\n \t    }\n+\t}\n+      /* Convert named operators to their proper types.  */\n+      else if (result->val.node->type == T_OPERATOR)\n+\t{\n+\t  result->flags |= NAMED_OP;\n+\t  result->type = result->val.node->value.code;\n+\t}\n+      break;\n+\n+    case '\\'':\n+    case '\"':\n+      result->type = c == '\"' ? CPP_STRING: CPP_CHAR;\n+    make_string:\n+      parse_string (pfile, result, c);\n+      break;\n \n-\tcontinue_name:\n-\t  cur = parse_name (pfile, cur_token, cur, buffer->rlimit);\n+    case '/':\n+      result->type = CPP_DIV;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_DIV_EQ);\n+      else if (c == '*')\n+\t{\n+\t  comment_start = buffer->cur;\n \n-\t  if (MIGHT_BE_DIRECTIVE ())\n-\t    list->directive = _cpp_check_directive (pfile, cur_token,\n-\t\t\t\t\t\t    !(list->tokens[0].flags\n-\t\t\t\t\t\t      & PREV_WHITE));\n-\t  /* Convert named operators to their proper types.  */\n-\t  if (cur_token->val.node->type == T_OPERATOR)\n+\t  /* Skip_block_comment updates buffer->read_ahead.  */\n+\t  if (skip_block_comment (pfile))\n+\t    cpp_error_with_line (pfile, result->line, result->col,\n+\t\t\t\t \"unterminated comment\");\n+\t  if (!pfile->state.save_comments)\n \t    {\n-\t      cur_token->flags |= NAMED_OP;\n-\t      cur_token->type = cur_token->val.node->value.code;\n+\t      result->flags |= PREV_WHITE;\n+\t      goto next_char;\n \t    }\n \n-\t  cur_token++;\n-\t  break;\n-\n-\tcase '\\'':\n-\t  cur_token->type = CPP_CHAR;\n-\t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n-\t      && cur_token[-1].val.node == pfile->spec_nodes->n_L)\n-\t    BACKUP_TOKEN (CPP_WCHAR);\n-\t  goto do_parse_string;\n-\t  \n-\tcase '\\\"':\n-\t  cur_token->type = CPP_STRING;\n-\t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n-\t      && cur_token[-1].val.node == pfile->spec_nodes->n_L)\n-\t    BACKUP_TOKEN (CPP_WSTRING);\n-\t  else if (CPP_OPTION (pfile, objc)\n-\t\t   && cur_token[-1].type == CPP_OTHER && IMMED_TOKEN ()\n-\t\t   && cur_token[-1].val.aux == '@')\n-\t    BACKUP_TOKEN (CPP_OSTRING);\n-\n-\tdo_parse_string:\n-\t  /* Here c is one of ' \" or >.  */\n-\t  INIT_TOKEN_STR (list, cur_token);\n-\t  buffer->cur = cur;\n-\t  parse_string (pfile, list, cur_token, c);\n-\t  cur = buffer->cur;\n-\t  cur_token++;\n-\t  break;\n-\n-\tcase '/':\n-\t  cur_token->type = CPP_DIV;\n-\t  if (IMMED_TOKEN ())\n+\t  /* Save the comment as a token in its own right.  */\n+\t  save_comment (pfile, result, comment_start);\n+\t}\n+      else if (c == '/')\n+\t{\n+\t  /* We silently allow C++ comments in system headers,\n+\t     irrespective of conformance mode, because lots of\n+\t     broken systems do that and trying to clean it up in\n+\t     fixincludes is a nightmare.  */\n+\t  if (CPP_IN_SYSTEM_HEADER (pfile))\n+\t    goto do_line_comment;\n+\t  if (CPP_OPTION (pfile, cplusplus_comments))\n \t    {\n-\t      if (PREV_TOKEN_TYPE == CPP_DIV)\n+\t      if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)\n+\t\t  && ! buffer->warned_cplusplus_comments)\n \t\t{\n-\t\t  /* We silently allow C++ comments in system headers,\n-\t\t     irrespective of conformance mode, because lots of\n-\t\t     broken systems do that and trying to clean it up\n-\t\t     in fixincludes is a nightmare.  */\n-\t\t  if (CPP_IN_SYSTEM_HEADER (pfile))\n-\t\t    goto do_line_comment;\n-\t\t  else if (CPP_OPTION (pfile, cplusplus_comments))\n-\t\t    {\n-\t\t      if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)\n-\t\t\t  && ! buffer->warned_cplusplus_comments)\n-\t\t\t{\n-\t\t\t  buffer->cur = cur;\n-\t\t\t  cpp_pedwarn (pfile,\n-\t\t\t     \"C++ style comments are not allowed in ISO C89\");\n-\t\t\t  cpp_pedwarn (pfile,\n-\t\t\t  \"(this will be reported only once per input file)\");\n-\t\t\t  buffer->warned_cplusplus_comments = 1;\n-\t\t\t}\n-\t\t    do_line_comment:\n-\t\t      buffer->cur = cur;\n-#if 0 /* Leave until new lexer in place.  */\n-\t\t      if (cur[-2] != c)\n-\t\t\tcpp_warning (pfile,\n-\t\t\t\t     \"comment start split across lines\");\n-#endif\n-\t\t      if (skip_line_comment (pfile))\n-\t\t\tcpp_warning (pfile, \"multi-line comment\");\n-\n-\t\t      /* Back-up to first '-' or '/'.  */\n-\t\t      cur_token--;\n-\t\t      if (!CPP_OPTION (pfile, discard_comments)\n-\t\t\t  && (!KNOWN_DIRECTIVE()\n-\t\t\t      || (list->directive->flags & COMMENTS)))\n-\t\t\tsave_comment (list, cur_token++, cur,\n-\t\t\t\t      buffer->cur - cur, c);\n-\t\t      else\n-\t\t\tflags = PREV_WHITE;\n-\n-\t\t      cur = buffer->cur;\n-\t\t      break;\n-\t\t    }\n+\t\t  cpp_pedwarn (pfile,\n+\t\t       \"C++ style comments are not allowed in ISO C89\");\n+\t\t  cpp_pedwarn (pfile,\n+\t\t       \"(this will be reported only once per input file)\");\n+\t\t  buffer->warned_cplusplus_comments = 1;\n \t\t}\n-\t    }\n-\t  cur_token++;\n-\t  break;\n-\t\t      \n-\tcase '*':\n-\t  cur_token->type = CPP_MULT;\n-\t  if (IMMED_TOKEN ())\n-\t    {\n-\t      if (PREV_TOKEN_TYPE == CPP_DIV)\n-\t\t{\n-\t\t  buffer->cur = cur;\n-#if 0 /* Leave until new lexer in place.  */\n-\t\t  if (cur[-2] != '/')\n-\t\t    cpp_warning (pfile,\n-\t\t\t\t \"comment start '/*' split across lines\");\n-#endif\n-\t\t  if (skip_block_comment (pfile))\n-\t\t    cpp_error_with_line (pfile, list->line, cur_token[-1].col,\n-\t\t\t\t\t \"unterminated comment\");\n-#if 0 /* Leave until new lexer in place.  */\n-\t\t  else if (buffer->cur[-2] != '*')\n-\t\t    cpp_warning (pfile,\n-\t\t\t\t \"comment end '*/' split across lines\");\n-#endif\n-\t\t  /* Back up to opening '/'.  */\n-\t\t  cur_token--;\n-\t\t  if (!CPP_OPTION (pfile, discard_comments)\n-\t\t      && (!KNOWN_DIRECTIVE()\n-\t\t\t  || (list->directive->flags & COMMENTS)))\n-\t\t    save_comment (list, cur_token++, cur,\n-\t\t\t\t  buffer->cur - cur, c);\n-\t\t  else\n-\t\t    flags = PREV_WHITE;\n \n-\t\t  cur = buffer->cur;\n-\t\t  break;\n-\t\t}\n-\t      else if (CPP_OPTION (pfile, cplusplus))\n+\t    do_line_comment:\n+\t      comment_start = buffer->cur;\n+\n+\t      /* Skip_line_comment updates buffer->read_ahead.  */\n+\t      if (skip_line_comment (buffer))\n+\t\tcpp_warning_with_line (pfile, result->line, result->col,\n+\t\t\t\t       \"multi-line comment\");\n+\n+\t      if (!pfile->state.save_comments)\n \t\t{\n-\t\t  /* In C++, there are .* and ->* operators.  */\n-\t\t  if (PREV_TOKEN_TYPE == CPP_DEREF)\n-\t\t    BACKUP_TOKEN (CPP_DEREF_STAR);\n-\t\t  else if (PREV_TOKEN_TYPE == CPP_DOT)\n-\t\t    BACKUP_TOKEN (CPP_DOT_STAR);\n+\t\t  result->flags |= PREV_WHITE;\n+\t\t  goto next_char;\n \t\t}\n+\n+\t      /* Save the comment as a token in its own right.  */\n+\t      save_comment (pfile, result, comment_start);\n \t    }\n-\t  cur_token++;\n-\t  break;\n+\t}\n+      break;\n+\n+    case '<':\n+      if (pfile->state.angled_headers)\n+\t{\n+\t  result->type = CPP_HEADER_NAME;\n+\t  c = '>';\t\t/* terminator.  */\n+\t  goto make_string;\n+\t}\n+\n+      result->type = CPP_LESS;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_LESS_EQ);\n+      else if (c == '<')\n+\t{\n+\t  ACCEPT_CHAR (CPP_LSHIFT);\n+\t  if (get_effective_char (buffer) == '=')\n+\t    ACCEPT_CHAR (CPP_LSHIFT_EQ);\n+\t}\n+      else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n+\t{\n+\t  ACCEPT_CHAR (CPP_MIN);\n+\t  if (get_effective_char (buffer) == '=')\n+\t    ACCEPT_CHAR (CPP_MIN_EQ);\n+\t}\n+      else if (c == ':' && CPP_OPTION (pfile, digraphs))\n+\t{\n+\t  ACCEPT_CHAR (CPP_OPEN_SQUARE);\n+\t  result->flags |= DIGRAPH;\n+\t}\n+      else if (c == '%' && CPP_OPTION (pfile, digraphs))\n+\t{\n+\t  ACCEPT_CHAR (CPP_OPEN_BRACE);\n+\t  result->flags |= DIGRAPH;\n+\t}\n+      break;\n \n-\tcase '\\n':\n-\tcase '\\r':\n-\t  handle_newline (cur, buffer->rlimit, c);\n-\t  if (PREV_TOKEN_TYPE == CPP_BACKSLASH)\n+    case '>':\n+      result->type = CPP_GREATER;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_GREATER_EQ);\n+      else if (c == '>')\n+\t{\n+\t  ACCEPT_CHAR (CPP_RSHIFT);\n+\t  if (get_effective_char (buffer) == '=')\n+\t    ACCEPT_CHAR (CPP_RSHIFT_EQ);\n+\t}\n+      else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n+\t{\n+\t  ACCEPT_CHAR (CPP_MAX);\n+\t  if (get_effective_char (buffer) == '=')\n+\t    ACCEPT_CHAR (CPP_MAX_EQ);\n+\t}\n+      break;\n+\n+    case '.':\n+      {\n+\tconst unsigned char *saved_cur;\n+\tcppchar_t c1;\n+\n+\t/* Save state to avoid needing to pass 2 chars to parse_number.  */\n+\tSAVE_STATE ();\n+\tc1 = get_effective_char (buffer);\n+\t/* All known character sets have 0...9 contiguous.  */\n+\tif (c1 >= '0' && c1 <= '9')\n+\t  {\n+\t    RESTORE_STATE ();\n+\t    goto make_number;\n+\t  }\n+\n+\tresult->type = CPP_DOT;\n+\tif (c1 == '.')\n+\t  {\n+\t    if (get_effective_char (buffer) == '.')\n+\t      ACCEPT_CHAR (CPP_ELLIPSIS);\n+\t    else\n+\t      {\n+\t\tbuffer->read_ahead = EOF;\n+\t\tRESTORE_STATE ();\n+\t      }\n+\t  }\n+\telse if (c1 == '*' && CPP_OPTION (pfile, cplusplus))\n+\t  ACCEPT_CHAR (CPP_DOT_STAR);\n+      }\n+      break;\n+\n+    case '%':\n+      result->type = CPP_MOD;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_MOD_EQ);\n+      else if (CPP_OPTION (pfile, digraphs))\n+\t{\n+\t  if (c == ':')\n \t    {\n-\t      /* backslash space newline is still treated as backslash-newline;\n-\t\t we think this is standard conforming, with some reservations\n-\t\t about actually _using_ the weasel words in C99 5.1.1.2\n-\t\t (translation phase 1 is allowed to do whatever it wants to\n-\t\t your input as long as it's documented).  */\n-\t      if (! IMMED_TOKEN ())\n-\t\t{\n-\t\t  buffer->cur = cur;\n-\t\t  cpp_warning (pfile,\n-\t\t\t       \"backslash and newline separated by space\");\n-\t\t}\n-\t      \n-\t      /* Remove the escaped newline.  Then continue to process\n-\t\t any interrupted name or number.  */\n-\t      cur_token--;\n-\t      /* Backslash-newline may not be immediately followed by\n-\t\t EOF (C99 5.1.1.2).  */\n-\t      if (cur >= buffer->rlimit)\n-\t\t{\n-\t\t  cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n-\t\t  break;\n-\t\t}\n-\t      if (IMMED_TOKEN ())\n-\t\t{\n-\t\t  cur_token--;\n-\t\t  if (cur_token->type == CPP_NAME)\n-\t\t    goto continue_name;\n-\t\t  else if (cur_token->type == CPP_NUMBER)\n-\t\t    goto continue_number;\n-\t\t  cur_token++;\n-\t\t}\n-\t      /* Remember whitespace setting.  */\n-\t      flags = cur_token->flags;\n-\t      break;\n+\t      result->flags |= DIGRAPH;\n+\t      ACCEPT_CHAR (CPP_HASH);\n+\t      if (get_effective_char (buffer) == '%')\n+\t\tcheck_long_token (buffer, result, ':', CPP_PASTE);\n \t    }\n-\t  else if (MIGHT_BE_DIRECTIVE ())\n+\t  else if (c == '>')\n \t    {\n-\t      /* \"Null directive.\" C99 6.10.7: A preprocessing\n-\t\t directive of the form # <new-line> has no effect.\n-\n-\t\t But it is still a directive, and therefore disappears\n-\t\t from the output. */\n-\t      cur_token--;\n-\t      if (cur_token->flags & PREV_WHITE\n-\t\t  && CPP_WTRADITIONAL (pfile))\n-\t\tcpp_warning (pfile, \"K+R C ignores #\\\\n with the # indented\");\n+\t      result->flags |= DIGRAPH;\n+\t      ACCEPT_CHAR (CPP_CLOSE_BRACE);\n \t    }\n+\t}\n+      break;\n \n-\t  /* Skip vertical space until we have at least one token to\n-             return.  */\n-\t  if (cur_token != &list->tokens[first_token])\n-\t    goto out;\n-\t  list->line = CPP_BUF_LINE (buffer);\n-\t  break;\n+    case '+':\n+      result->type = CPP_PLUS;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_PLUS_EQ);\n+      else if (c == '+')\n+\tACCEPT_CHAR (CPP_PLUS_PLUS);\n+      break;\n \n-\tcase '-':\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_MINUS)\n-\t    REVISE_TOKEN (CPP_MINUS_MINUS);\n-\t  else\n-\t    PUSH_TOKEN (CPP_MINUS);\n-\t  break;\n+    case '-':\n+      result->type = CPP_MINUS;\n+      c = get_effective_char (buffer);\n+      if (c == '>')\n+\t{\n+\t  ACCEPT_CHAR (CPP_DEREF);\n+\t  if (CPP_OPTION (pfile, cplusplus)\n+\t      && get_effective_char (buffer) == '*')\n+\t    ACCEPT_CHAR (CPP_DEREF_STAR);\n+\t}\n+      else if (c == '=')\n+\tACCEPT_CHAR (CPP_MINUS_EQ);\n+      else if (c == '-')\n+\tACCEPT_CHAR (CPP_MINUS_MINUS);\n+      break;\n \n-\tmake_hash:\n-\tcase '#':\n-\t  /* The digraph flag checking ensures that ## and %:%:\n-\t     are interpreted as CPP_PASTE, but #%: and %:# are not.  */\n-\t  if (PREV_TOKEN_TYPE == CPP_HASH && IMMED_TOKEN ()\n-\t      && ((cur_token->flags ^ cur_token[-1].flags) & DIGRAPH) == 0)\n-\t    REVISE_TOKEN (CPP_PASTE);\n-\t  else\n-\t    PUSH_TOKEN (CPP_HASH);\n-\t  break;\n+    case '*':\n+      result->type = CPP_MULT;\n+      if (get_effective_char (buffer) == '=')\n+\tACCEPT_CHAR (CPP_MULT_EQ);\n+      break;\n \n-\tcase ':':\n-\t  cur_token->type = CPP_COLON;\n-\t  if (IMMED_TOKEN ())\n-\t    {\n-\t      if (PREV_TOKEN_TYPE == CPP_COLON\n-\t\t  && CPP_OPTION (pfile, cplusplus))\n-\t\tBACKUP_TOKEN (CPP_SCOPE);\n-\t      else if (CPP_OPTION (pfile, digraphs))\n-\t\t{\n-\t\t  /* Digraph: \"<:\" is a '['  */\n-\t\t  if (PREV_TOKEN_TYPE == CPP_LESS)\n-\t\t    BACKUP_DIGRAPH (CPP_OPEN_SQUARE);\n-\t\t  /* Digraph: \"%:\" is a '#'  */\n-\t\t  else if (PREV_TOKEN_TYPE == CPP_MOD)\n-\t\t    {\n-\t\t      (--cur_token)->flags |= DIGRAPH;\n-\t\t      goto make_hash;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  cur_token++;\n-\t  break;\n+    case '=':\n+      result->type = CPP_EQ;\n+      if (get_effective_char (buffer) == '=')\n+\tACCEPT_CHAR (CPP_EQ_EQ);\n+      break;\n \n-\tcase '&':\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_AND)\n-\t    REVISE_TOKEN (CPP_AND_AND);\n-\t  else\n-\t    PUSH_TOKEN (CPP_AND);\n-\t  break;\n+    case '!':\n+      result->type = CPP_NOT;\n+      if (get_effective_char (buffer) == '=')\n+\tACCEPT_CHAR (CPP_NOT_EQ);\n+      break;\n \n-\tmake_or:\n-\tcase '|':\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_OR)\n-\t    REVISE_TOKEN (CPP_OR_OR);\n-\t  else\n-\t    PUSH_TOKEN (CPP_OR);\n-\t  break;\n+    case '&':\n+      result->type = CPP_AND;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_AND_EQ);\n+      else if (c == '&')\n+\tACCEPT_CHAR (CPP_AND_AND);\n+      break;\n+\t  \n+    case '#':\n+      result->type = CPP_HASH;\n+      if (get_effective_char (buffer) == '#')\n+\tACCEPT_CHAR (CPP_PASTE);\n+      break;\n \n-\tcase '+':\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_PLUS)\n-\t    REVISE_TOKEN (CPP_PLUS_PLUS);\n-\t  else\n-\t    PUSH_TOKEN (CPP_PLUS);\n-\t  break;\n+    case '|':\n+      result->type = CPP_OR;\n+      c = get_effective_char (buffer);\n+      if (c == '=')\n+\tACCEPT_CHAR (CPP_OR_EQ);\n+      else if (c == '|')\n+\tACCEPT_CHAR (CPP_OR_OR);\n+      break;\n \n-\tcase '=':\n-\t    /* This relies on equidistance of \"?=\" and \"?\" tokens.  */\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE <= CPP_LAST_EQ)\n-\t    REVISE_TOKEN (PREV_TOKEN_TYPE + (CPP_EQ_EQ - CPP_EQ));\n-\t  else\n-\t    PUSH_TOKEN (CPP_EQ);\n-\t  break;\n+    case '^':\n+      result->type = CPP_XOR;\n+      if (get_effective_char (buffer) == '=')\n+\tACCEPT_CHAR (CPP_XOR_EQ);\n+      break;\n \n-\tcase '>':\n-\t  cur_token->type = CPP_GREATER;\n-\t  if (IMMED_TOKEN ())\n-\t    {\n-\t      if (PREV_TOKEN_TYPE == CPP_GREATER)\n-\t\tBACKUP_TOKEN (CPP_RSHIFT);\n-\t      else if (PREV_TOKEN_TYPE == CPP_MINUS)\n-\t\tBACKUP_TOKEN (CPP_DEREF);\n-\t      else if (CPP_OPTION (pfile, digraphs))\n-\t\t{\n-\t\t  /* Digraph: \":>\" is a ']'  */\n-\t\t  if (PREV_TOKEN_TYPE == CPP_COLON)\n-\t\t    BACKUP_DIGRAPH (CPP_CLOSE_SQUARE);\n-\t\t  /* Digraph: \"%>\" is a '}'  */\n-\t\t  else if (PREV_TOKEN_TYPE == CPP_MOD)\n-\t\t    BACKUP_DIGRAPH (CPP_CLOSE_BRACE);\n-\t\t}\n-\t    }\n-\t  cur_token++;\n-\t  break;\n-\t  \n-\tcase '<':\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_LESS)\n-\t    {\n-\t      REVISE_TOKEN (CPP_LSHIFT);\n-\t      break;\n-\t    }\n-\t  /* Is this the beginning of a header name?  */\n-\t  if (KNOWN_DIRECTIVE () && (list->directive->flags & INCL))\n-\t    {\n-\t      c = '>';\t/* Terminator.  */\n-\t      cur_token->type = CPP_HEADER_NAME;\n-\t      goto do_parse_string;\n-\t    }\n-\t  PUSH_TOKEN (CPP_LESS);\n-\t  break;\n+    case ':':\n+      result->type = CPP_COLON;\n+      c = get_effective_char (buffer);\n+      if (c == ':' && CPP_OPTION (pfile, cplusplus))\n+\tACCEPT_CHAR (CPP_SCOPE);\n+      else if (c == '>' && CPP_OPTION (pfile, digraphs))\n+\t{\n+\t  result->flags |= DIGRAPH;\n+\t  ACCEPT_CHAR (CPP_CLOSE_SQUARE);\n+\t}\n+      break;\n \n-\tcase '%':\n-\t  /* Digraph: \"<%\" is a '{'  */\n-\t  cur_token->type = CPP_MOD;\n-\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_LESS\n-\t      && CPP_OPTION (pfile, digraphs))\n-\t    BACKUP_DIGRAPH (CPP_OPEN_BRACE);\n-\t  cur_token++;\n-\t  break;\n+    case '~': result->type = CPP_COMPL; break;\n+    case ',': result->type = CPP_COMMA; break;\n+    case '(': result->type = CPP_OPEN_PAREN; break;\n+    case ')': result->type = CPP_CLOSE_PAREN; break;\n+    case '[': result->type = CPP_OPEN_SQUARE; break;\n+    case ']': result->type = CPP_CLOSE_SQUARE; break;\n+    case '{': result->type = CPP_OPEN_BRACE; break;\n+    case '}': result->type = CPP_CLOSE_BRACE; break;\n+    case ';': result->type = CPP_SEMICOLON; break;\n+\n+    case '@':\n+      if (CPP_OPTION (pfile, objc))\n+\t{\n+\t  /* In Objective C, '@' may begin keywords or strings, like\n+\t     @keyword or @\"string\".  It would be nice to call\n+\t     get_effective_char here and test the result.  However, we\n+\t     would then need to pass 2 characters to parse_identifier,\n+\t     making it ugly and slowing down its main loop.  Instead,\n+\t     we assume we have an identifier, and recover if not.  */\n+\t  result->type = CPP_NAME;\n+\t  result->val.node = parse_identifier (pfile, c);\n+\t  if (result->val.node->length != 1)\n+\t    break;\n \n-\tcase '?':\n-\t  if (cur + 1 < buffer->rlimit && *cur == '?'\n-\t      && _cpp_trigraph_map[cur[1]] && trigraph_ok (pfile, cur + 1))\n+\t  /* OK, so it wasn't an identifier.  Maybe a string?  */\n+\t  if (buffer->read_ahead == '\"')\n \t    {\n-\t      /* Handle trigraph.  */\n-\t      cur++;\n-\t      switch (*cur++)\n-\t\t{\n-\t\tcase '(': goto make_open_square;\n-\t\tcase ')': goto make_close_square;\n-\t\tcase '<': goto make_open_brace;\n-\t\tcase '>': goto make_close_brace;\n-\t\tcase '=': goto make_hash;\n-\t\tcase '!': goto make_or;\n-\t\tcase '-': goto make_complement;\n-\t\tcase '/': goto make_backslash;\n-\t\tcase '\\'': goto make_xor;\n-\t\t}\n-\t    }\n-\t  if (IMMED_TOKEN () && CPP_OPTION (pfile, cplusplus))\n-\t    {\n-\t      /* GNU C++ defines <? and >? operators.  */\n-\t      if (PREV_TOKEN_TYPE == CPP_LESS)\n-\t\t{\n-\t\t  REVISE_TOKEN (CPP_MIN);\n-\t\t  break;\n-\t\t}\n-\t      else if (PREV_TOKEN_TYPE == CPP_GREATER)\n-\t\t{\n-\t\t  REVISE_TOKEN (CPP_MAX);\n-\t\t  break;\n-\t\t}\n+\t      c = '\"';\n+\t      ACCEPT_CHAR (CPP_OSTRING);\n+\t      goto make_string;\n \t    }\n-\t  PUSH_TOKEN (CPP_QUERY);\n-\t  break;\n+\t}\n+      goto random_char;\n+\n+    random_char:\n+    default:\n+      result->type = CPP_OTHER;\n+      result->val.aux = c;\n+      break;\n+    }\n+}\n+\n+/*\n+ *  The tokenizer's main loop.  Returns a token list, representing a\n+ *  logical line in the input file.  On EOF after some tokens have\n+ *  been processed, we return immediately.  Then in next call, or if\n+ *  EOF occurred at the beginning of a logical line, a single CPP_EOF\n+ *  token is placed in the list.\n+ */\n+\n+static void\n+lex_line (pfile, list)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+{\n+  unsigned int first_token;\n+  cpp_token *cur_token, *first;\n+  cpp_buffer *buffer = pfile->buffer;\n+\n+  if (!(list->flags & LIST_OFFSET))\n+    (abort) ();\n+\n+  pfile->state.in_lex_line = 1;\n+  if (pfile->buffer->cur == pfile->buffer->buf)\n+    list->flags |= BEG_OF_FILE;\n \n-\tcase '.':\n-\t  if (PREV_TOKEN_TYPE == CPP_DOT && cur_token[-2].type == CPP_DOT\n-\t      && IMMED_TOKEN ()\n-\t      && !(cur_token[-1].flags & PREV_WHITE))\n+ retry:\n+  pfile->state.in_directive = 0;\n+  pfile->state.angled_headers = 0;\n+  pfile->state.skip_newlines = 1;\n+  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n+  first_token = list->tokens_used;\n+  list->file = buffer->nominal_fname;\n+\n+  do\n+    {\n+      if (list->tokens_used >= list->tokens_cap)\n+\t_cpp_expand_token_space (list, 256);\n+\n+      cur_token = list->tokens + list->tokens_used;\n+      lex_token (pfile, cur_token);\n+\n+      if (pfile->state.skip_newlines)\n+\t{\n+\t  pfile->state.skip_newlines = 0;\n+\t  list->line = buffer->lineno;\n+\t  if (cur_token->type == CPP_HASH)\n \t    {\n-\t      cur_token -= 2;\n-\t      PUSH_TOKEN (CPP_ELLIPSIS);\n+\t      pfile->state.in_directive = 1;\n+\t      pfile->state.save_comments = 0;\n+\t      pfile->state.indented = cur_token->flags & PREV_WHITE;\n \t    }\n+\t  /* 6.10.3.10: Within the sequence of preprocessing tokens\n+\t     making up the invocation of a function-like macro, new\n+\t     line is considered a normal white-space character.  */\n+\t  else if (first_token != 0)\n+\t    cur_token->flags |= PREV_WHITE;\n+\t}\n+      else if (IN_DIRECTIVE (pfile) && list->tokens_used == first_token + 1)\n+\t{\n+\t  if (cur_token->type == CPP_NUMBER)\n+\t    list->directive = _cpp_check_linemarker (pfile, cur_token);\n \t  else\n-\t    PUSH_TOKEN (CPP_DOT);\n-\t  break;\n-\n-\tmake_complement:\n-\tcase '~': PUSH_TOKEN (CPP_COMPL); break;\n-\tmake_xor:\n-\tcase '^': PUSH_TOKEN (CPP_XOR); break;\n-\tmake_open_brace:\n-\tcase '{': PUSH_TOKEN (CPP_OPEN_BRACE); break;\n-\tmake_close_brace:\n-\tcase '}': PUSH_TOKEN (CPP_CLOSE_BRACE); break;\n-\tmake_open_square:\n-\tcase '[': PUSH_TOKEN (CPP_OPEN_SQUARE); break;\n-\tmake_close_square:\n-\tcase ']': PUSH_TOKEN (CPP_CLOSE_SQUARE); break;\n-\tmake_backslash:\n-\tcase '\\\\': PUSH_TOKEN (CPP_BACKSLASH); break;\n-\tcase '!': PUSH_TOKEN (CPP_NOT); break;\n-\tcase ',': PUSH_TOKEN (CPP_COMMA); break;\n-\tcase ';': PUSH_TOKEN (CPP_SEMICOLON); break;\n-\tcase '(': PUSH_TOKEN (CPP_OPEN_PAREN); break;\n-\tcase ')': PUSH_TOKEN (CPP_CLOSE_PAREN); break;\n-\n-\tcase '$':\n-\t  if (CPP_OPTION (pfile, dollars_in_ident))\n-\t    goto letter;\n-\t  /* Fall through */\n-\tdefault:\n-\t  cur_token->val.aux = c;\n-\t  PUSH_TOKEN (CPP_OTHER);\n-\t  break;\n+\t    list->directive = _cpp_check_directive (pfile, cur_token);\n \t}\n-    }\n \n-  /* Run out of token space?  */\n-  if (cur_token == token_limit)\n-    {\n-      list->tokens_used = cur_token - list->tokens;\n-      _cpp_expand_token_space (list, 256);\n-      goto expanded;\n+      /* _cpp_get_line assumes list->tokens_used refers to the current\n+\t token being lexed.  So do this after _cpp_check_directive to\n+\t get the warnings therein correct.  */\n+      list->tokens_used++;\n     }\n+  while (cur_token->type != CPP_EOF);\n \n-  cur_token->flags = flags;\n-  if (cur_token == &list->tokens[first_token] && pfile->done_initializing)\n-    {\n-      if (cur > buffer->buf && !is_vspace (cur[-1]))\n-\tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n-\t\t\t       CPP_BUF_COLUMN (buffer, cur),\n-\t\t\t       \"no newline at end of file\");\n-      cur_token++->type = CPP_EOF;\n-    }\n-\n- out:\n   /* All tokens are allocated, so the memory location is fixed.  */\n   first = &list->tokens[first_token];\n+  first->flags |= BOL;\n+  pfile->first_directive_token = first;\n+\n+  /* Drop the EOF unless really at EOF or in a directive.  */\n+  if (!(cur_token == first || pfile->state.in_directive\n+\t|| !pfile->done_initializing))\n+    list->tokens_used--;\n \n   /* Don't complain about the null directive, nor directives in\n      assembly source: we don't know where the comments are, and # may\n      introduce assembler pseudo-ops.  Don't complain about invalid\n      directives in skipped conditional groups (6.10 p4).  */\n-  if (first->type == CPP_HASH && list->directive == 0 && !pfile->skipping\n-      && cur_token > first + 1 && !CPP_OPTION (pfile, lang_asm))\n+  if (IN_DIRECTIVE (pfile) && !KNOWN_DIRECTIVE (list) && !pfile->skipping\n+      && !CPP_OPTION (pfile, lang_asm))\n     {\n-      if (first[1].type == CPP_NAME)\n-\tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n-\t\t   first[1].val.node->name);\n-      else\n-\tcpp_error (pfile, \"invalid preprocessing directive\");\n+      if (cur_token > first + 1)\n+\t{\n+\t  if (first[1].type == CPP_NAME)\n+\t    cpp_error_with_line (pfile, first->line, first->col,\n+\t\t\t\t \"invalid preprocessing directive #%s\",\n+\t\t\t\t first[1].val.node->name);\n+\t  else\n+\t    cpp_error_with_line (pfile, first->line, first->col,\n+\t\t\t\t \"invalid preprocessing directive\");\n+\t}\n \n       /* Discard this line to prevent further errors from cc1.  */\n       _cpp_clear_toklist (list);\n       goto retry;\n     }\n \n-  /* Put EOF at end of known directives.  This covers \"directives do\n-     not extend beyond the end of the line (description 6.10 part 2)\".  */\n-  if (KNOWN_DIRECTIVE () || !pfile->done_initializing)\n-    {\n-      pfile->first_directive_token = first;\n-      cur_token++->type = CPP_EOF;\n-    }\n-\n-  first->flags |= BOL;\n-  if (first_token != 0)\n-    /* 6.10.3.10: Within the sequence of preprocessing tokens making\n-       up the invocation of a function-like macro, new line is\n-       considered a normal white-space character.  */\n-    first->flags |= PREV_WHITE;\n-\n-  buffer->cur = cur;\n-  list->tokens_used = cur_token - list->tokens;\n-  pfile->in_lex_line = 0;\n+  pfile->state.in_lex_line = 0;\n }\n \n /* Write the spelling of a token TOKEN, with any appropriate\n@@ -3400,19 +3262,22 @@ _cpp_get_line (pfile, pcol)\n   unsigned int index;\n   const cpp_token *cur_token;\n \n-  if (pfile->in_lex_line)\n+  if (pfile->state.in_lex_line)\n     index = pfile->token_list.tokens_used;\n   else\n-    index = pfile->contexts[0].posn;\n-\n-  if (index == 0)\n     {\n-      if (pcol)\n-\t*pcol = 0;\n-      return 0;\n+      index = pfile->contexts[0].posn;\n+\n+      if (index == 0)\n+\t{\n+\t  if (pcol)\n+\t    *pcol = 0;\n+\t  return 0;\n+\t}\n+      index--;\n     }\n \n-  cur_token = &pfile->token_list.tokens[index - 1];\n+  cur_token = &pfile->token_list.tokens[index];\n   if (pcol)\n     *pcol = cur_token->col;\n   return cur_token->line;"}, {"sha": "31064863cac20f075ddb370aac202d91150e02d6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -133,64 +133,81 @@ DIRECTIVE_TABLE\n /* Check if a token's name matches that of a known directive.  Put in\n    this file to save exporting dtable and other unneeded information.  */\n const struct directive *\n-_cpp_check_directive (pfile, token, bol)\n+_cpp_check_directive (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n-     int bol;\n {\n   unsigned int i;\n \n+  if (token->type != CPP_NAME)\n+    {\n+      if (token->type == CPP_EOF && CPP_WTRADITIONAL (pfile)\n+\t  && pfile->state.indented)\n+\tcpp_warning (pfile, \"traditional C ignores #\\\\n with the # indented\");\n+\n+      return 0;\n+    }\n+\n   for (i = 0; i < N_DIRECTIVES; i++)\n     if (pfile->spec_nodes->dirs[i] == token->val.node)\n-      {\n-\t/* If we are rescanning preprocessed input, only directives\n-\t   tagged with IN_I are to be honored, and the warnings below\n-\t   are suppressed.  */\n-\tif (CPP_OPTION (pfile, preprocessed))\n-\t  {\n-\t    if (dtable[i].flags & IN_I)\n-\t      return &dtable[i];\n-\t    return 0;\n-\t  }\n-\n-\t/* In -traditional mode, a directive is ignored unless its #\n-\t   is in column 1.  In code intended to work with K+R compilers,\n-\t   therefore, directives added by C89 must have their # indented,\n-\t   and directives present in traditional C must not.  This is true\n-\t   even of directives in skipped conditional blocks.  */\n-\tif (CPP_WTRADITIONAL (pfile))\n-\t  {\n-\t    if (!bol && dtable[i].origin == KANDR)\n-\t      cpp_warning (pfile,\n-\t\t\t   \"traditional C ignores #%s with the # indented\",\n-\t\t\t   dtable[i].name);\n-\n-\t    if (bol && dtable[i].origin != KANDR)\n-\t      cpp_warning (pfile,\n-\t\t    \"suggest hiding #%s from traditional C with an indented #\",\n-\t\t\t   dtable[i].name);\n-\t  }\n-\n-\t/* If we are skipping a failed conditional group, all non-conditional\n-\t   directives are ignored.  */\n-\tif (pfile->skipping && !(dtable[i].flags & COND))\n-\t  return 0;\n-\n-\t/* Issue -pedantic warnings for extended directives.   */\n-\tif (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n-\t  cpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n-\n-\treturn &dtable[i];\n-      }\n+      break;\n \n-  return 0;\n+  if (i == N_DIRECTIVES)\n+    return 0;\n+\n+  /* We should lex headers correctly, regardless of whether we're\n+     skipping or not.  */\n+  pfile->state.angled_headers = dtable[i].flags & INCL;\n+\n+  /* If we are rescanning preprocessed input, only directives tagged\n+     with IN_I are honored, and the warnings below are suppressed.  */\n+  if (CPP_OPTION (pfile, preprocessed))\n+    {\n+      if (!dtable[i].flags & IN_I)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      /* Traditionally, a directive is ignored unless its # is in\n+\t column 1.  Therefore in code intended to work with K+R\n+\t compilers, directives added by C89 must have their #\n+\t indented, and directives present in traditional C must not.\n+\t This is true even of directives in skipped conditional\n+\t blocks.  */\n+      if (CPP_WTRADITIONAL (pfile))\n+\t{\n+\t  if (pfile->state.indented && dtable[i].origin == KANDR)\n+\t    cpp_warning (pfile, \n+\t\t\t \"traditional C ignores #%s with the # indented\",\n+\t\t\t dtable[i].name);\n+\n+\t  else if (!pfile->state.indented && dtable[i].origin != KANDR)\n+\t    cpp_warning (pfile,\n+\t\t \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t\t dtable[i].name);\n+\t}\n+\n+      /* If we are skipping a failed conditional group, all non-conditional\n+\t directives are ignored.  */\n+      if (pfile->skipping && !(dtable[i].flags & COND))\n+\treturn 0;\n+\n+      /* Issue -pedantic warnings for extended directives.   */\n+      if (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n+\tcpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n+    }\n+\n+  /* Only flag to save comments if we process the directive.  */\n+  pfile->state.save_comments = (! CPP_OPTION (pfile, discard_comments)\n+\t\t\t\t&& (dtable[i].flags & COMMENTS));\n+\n+  return &dtable[i];\n }\n \n const struct directive *\n-_cpp_check_linemarker (pfile, token, bol)\n+_cpp_check_linemarker (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token ATTRIBUTE_UNUSED;\n-     int bol;\n {\n   /* # followed by a number is equivalent to #line.  Do not recognize\n      this form in assembly language source files or skipped\n@@ -206,7 +223,7 @@ _cpp_check_linemarker (pfile, token, bol)\n \n   /* In -traditional mode, a directive is ignored unless its #\n      is in column 1.  */\n-  if (!bol && CPP_WTRADITIONAL (pfile))\n+  if (pfile->state.indented && CPP_WTRADITIONAL (pfile))\n     cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n \t\t dtable[T_LINE].name);\n \n@@ -1319,7 +1336,6 @@ do_assert (pfile)\n   if (node)\n     {\n       new_answer->next = 0;\n-      new_answer->list.line = pfile->token_list.line;\n       new_answer->list.file = pfile->token_list.file;\n \n       if (node->type == T_ASSERTION)\n@@ -1499,6 +1515,8 @@ cpp_push_buffer (pfile, buffer, length)\n   new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + length;\n   new->prev = buf;\n+  new->pfile = pfile;\n+  new->read_ahead = EOF;\n \n   CPP_BUFFER (pfile) = new;\n   return new;"}, {"sha": "75115375664cb8ee9a9cb1b5214f5cb092f17e6d", "filename": "gcc/cpplib.h", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -215,15 +215,22 @@ struct cpp_toklist\n   unsigned short flags;\n };\n \n+/* A standalone character.  We may want to make it unsigned for the\n+   same reason we use unsigned char - to avoid signedness issues.  */\n+typedef int cppchar_t;\n+\n struct cpp_buffer\n {\n   const unsigned char *cur;\t /* current position */\n   const unsigned char *rlimit; /* end of valid data */\n-  const unsigned char *buf;\t /* entire buffer */\n   const unsigned char *line_base; /* start of current line */\n+  cppchar_t read_ahead;\t\t/* read ahead character */\n \n+  struct cpp_reader *pfile;\t/* Owns this buffer.  */\n   struct cpp_buffer *prev;\n \n+  const unsigned char *buf;\t /* entire buffer */\n+\n   /* Filename specified with #line command.  */\n   const char *nominal_fname;\n \n@@ -238,6 +245,9 @@ struct cpp_buffer\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n   struct if_stack *if_stack;\n \n+  /* Token column position adjustment owing to tabs in whitespace.  */\n+  unsigned int col_adjust;\n+\n   /* Line number at line_base (above). */\n   unsigned int lineno;\n \n@@ -431,6 +441,31 @@ struct cpp_options\n   unsigned char show_column;\n };\n \n+struct lexer_state\n+{\n+  /* Nonzero if first token on line is CPP_HASH.  */\n+  unsigned char in_directive;\n+\n+  /* Nonzero if the directive's # was not in the first column.  Used\n+     by -Wtraditional.  */\n+  unsigned char indented;\n+\n+  /* Nonzero if in a directive that takes angle-bracketed headers.  */\n+  unsigned char angled_headers;\n+\n+  /* Nonzero to save comments.  Turned off if discard_comments, and in\n+     all directives apart from #define.  */\n+  unsigned char save_comments;\n+\n+  /* Nonzero to get force the lexer to skip newlines.  */\n+  unsigned char skip_newlines;\n+\n+  /* If we're in the subroutine lex_line.  */\n+  unsigned char in_lex_line;\n+};\n+#define IN_DIRECTIVE(pfile) (pfile->state.in_directive)\n+#define KNOWN_DIRECTIVE(list) (list->directive != 0)\n+\n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active. */\n@@ -440,12 +475,16 @@ struct cpp_reader\n   /* Top of buffer stack.  */\n   cpp_buffer *buffer;\n \n+  /* Lexer state.  */\n+  struct lexer_state state;\n+\n   /* Error counter for exit code */\n   unsigned int errors;\n \n-  /* Line and column where a newline was first seen in a string constant.  */\n-  unsigned int multiline_string_line;\n-  unsigned int multiline_string_column;\n+  /* Line and column where a newline was first seen in a string\n+     constant (multi-line strings).  */\n+  unsigned int mls_line;\n+  unsigned int mls_column;\n \n   /* Current depth in #include directives that use <...>.  */\n   unsigned int system_include_depth;\n@@ -475,9 +514,6 @@ struct cpp_reader\n      be one at a time, so it is per-reader not per-buffer.  */\n   const cpp_hashnode *potential_control_macro;\n \n-  /* Token column position adjustment owing to tabs in whitespace.  */\n-  unsigned int col_adjust;\n-\n   /* Token list used to store logical lines with new lexer.  */\n   cpp_toklist token_list;\n \n@@ -557,9 +593,6 @@ struct cpp_reader\n      or we might need to write out definitions.  */\n   unsigned char save_parameter_spellings;\n \n-  /* If we're in lex_line.  */\n-  unsigned char in_lex_line;\n-\n   /* True if output_line_command needs to output a newline.  */\n   unsigned char need_newline;\n \n@@ -586,7 +619,7 @@ struct cpp_printer\n #define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n #define CPP_BUF_LINE(BUF) ((BUF)->lineno)\n-#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + pfile->col_adjust)\n+#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n #define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n \n /* Name under which this program was invoked.  */"}, {"sha": "68eb6f2011b1d04c09c439e13838dfc59666c73b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -1,3 +1,7 @@\n+Mon 18-Sep-2000 19:23:11 BST  Neil Booth  <NeilB@earthling.net>\n+\n+\t* gcc.dg/cpp/cmdlne-C.c: Remove bogus warning test.\n+\n 2000-09-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/format-ext-1.c: Add tests for mixing %m with $ formats."}, {"sha": "c89dd8b09ce96ad2f30949262d44a46e0a7ccf4b", "filename": "gcc/testsuite/gcc.dg/cpp/cmdlne-C.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcmdlne-C.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9f234d9317f291eb49dab50277efeee85e5b91/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcmdlne-C.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fcmdlne-C.c?ref=0d9f234d9317f291eb49dab50277efeee85e5b91", "patch": "@@ -10,7 +10,7 @@\n    the beginning of a directive turns it into a non-directive.  */\n \n #define simple no comments\n-#/**/define bad_directive\t\t/* { dg-error \"invalid\" } */\n+\n #define/**/obj_like/**/(some)/**/thing/**/\n #define fun_like(/**/x/**/,/**/y/**/)/**/\n /**/#define not_a_macro"}]}