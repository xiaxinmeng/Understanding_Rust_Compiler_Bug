{"sha": "2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZhNTQ4NDE1YWEyYTQ3ZDcxYTAxMTU1ZTZjMWNkOWRhYzFmNWIzNg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-06-02T11:38:24Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-02T11:38:24Z"}, "message": "re PR fortran/15557 (Not Implemented: Substring reference in DATA statement)\n\nfortran/\nPR fortran/15557\n* data.c (assign_substring_data_value): New function.\n(gfc_assign_data_value): Call the new function if we're dealing\nwith a substring LHS.\n\ntestsuite/\nPR fortran/15557\n* gfortran.fortran-torture/execute/data_3.f90: New testcase.\n\nFrom-SVN: r82570", "tree": {"sha": "e9e2239ff6bf5808b145300135905c4d7d684f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e2239ff6bf5808b145300135905c4d7d684f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "785287145e15dab88c193434e6d07b68b4870783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785287145e15dab88c193434e6d07b68b4870783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/785287145e15dab88c193434e6d07b68b4870783"}], "stats": {"total": 129, "additions": 124, "deletions": 5}, "files": [{"sha": "aa7f1ae520e75c6929f6ed6bd065db8120d8e67f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "patch": "@@ -1,3 +1,10 @@\n+2004-06-02  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/15557\n+\t* data.c (assign_substring_data_value): New function.\n+\t(gfc_assign_data_value): Call the new function if we're dealing\n+\twith a substring LHS.\n+\n 2004-06-01  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/15477"}, {"sha": "5ffdd5bc5e00e7e4ed7737d2025cb6871240405a", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "patch": "@@ -108,8 +108,87 @@ find_con_by_component (gfc_component *com, gfc_constructor *con)\n   return NULL;\n }\n \n+/* Assign RVALUE to LVALUE where we assume that LVALUE is a substring\n+   reference. We do a little more than that: if LVALUE already has an\n+   initialization, we put RVALUE into the existing initialization as\n+   per the rules of assignment to a substring. If LVALUE has no\n+   initialization yet, we initialize it to all blanks, then filling in\n+   the RVALUE.  */\n+\n+static void\n+assign_substring_data_value (gfc_expr * lvalue, gfc_expr * rvalue)\n+{\n+  gfc_symbol *symbol;\n+  gfc_expr *expr, *init;\n+  gfc_ref *ref;\n+  int len, i;\n+  int start, end;\n+  char *c, *d;\n+\t    \n+  symbol = lvalue->symtree->n.sym;\n+  ref = lvalue->ref;\n+  init = symbol->value;\n+\n+  assert (symbol->ts.type == BT_CHARACTER);\n+  assert (symbol->ts.cl->length->expr_type == EXPR_CONSTANT);\n+  assert (symbol->ts.cl->length->ts.type == BT_INTEGER);\n+  assert (symbol->ts.kind == 1);\n+\n+  gfc_extract_int (symbol->ts.cl->length, &len);\n+\t    \n+  if (init == NULL)\n+    {\n+      /* Setup the expression to hold the constructor.  */\n+      expr = gfc_get_expr ();\n+      expr->expr_type = EXPR_CONSTANT;\n+      expr->ts.type = BT_CHARACTER;\n+      expr->ts.kind = 1;\n+\t      \n+      expr->value.character.length = len;\n+      expr->value.character.string = gfc_getmem (len);\n+      memset (expr->value.character.string, ' ', len);\n+\n+      symbol->value = expr;\n+    }\n+  else\n+    expr = init;\n+\t  \n+  /* Now that we have allocated the memory for the string,\n+     fill in the initialized places, truncating the\n+     intialization string if necessary, i.e.\n+     DATA a(1:2) /'123'/\n+     doesn't initialize a(3:3).  */\n+\n+  gfc_extract_int (ref->u.ss.start, &start);\n+  gfc_extract_int (ref->u.ss.end, &end);\n+\t    \n+  assert (start >= 1);\n+  assert (end <= len);\n+\n+  len = rvalue->value.character.length;\n+  c = rvalue->value.character.string;\n+  d = &expr->value.character.string[start - 1];\n+\n+  for (i = 0; i <= end - start && i < len; i++)\n+    d[i] = c[i];\n+\n+  /* Pad with spaces. I.e. \n+     DATA a(1:2) /'a'/\n+     intializes a(1:2) to 'a ' per the rules for assignment.  \n+     If init == NULL we don't need to do this, as we have\n+     intialized the whole string to blanks above.  */\n+\n+  if (init != NULL)\n+    for (; i <= end - start; i++)\n+      d[i] = ' ';\n+\n+  return;\n+}\n+\n+/* Assign the initial value RVALUE to  LVALUE's symbol->value. If the\n+   LVALUE already has an initialization, we extend this, otherwise we\n+   create a new one.  */\n \n-/* Assign the initial value RVALUE to  LVALUE's symbol->value.  */\n void\n gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n {\n@@ -122,12 +201,22 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n   mpz_t offset;\n \n   ref = lvalue->ref;\n+  if (ref != NULL && ref->type == REF_SUBSTRING)\n+    {\n+      /* No need to go through the for (; ref; ref->next) loop, since\n+\t a single substring lvalue will only refer to a single\n+\t substring, and therefore ref->next == NULL.  */\n+      assert (ref->next == NULL);      \n+      assign_substring_data_value (lvalue, rvalue);\n+      return;\n+    }\n+\n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n   last_con = NULL;\n   mpz_init_set_si (offset, 0);\n \n-  for (ref = lvalue->ref; ref; ref = ref->next)\n+  for (; ref; ref = ref->next)\n     {\n       /* Use the existing initializer expression if it exists.  Otherwise\n          create a new one.  */\n@@ -199,9 +288,8 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t    }\n \t  break;\n \n-\tcase REF_SUBSTRING:\n-\t  gfc_todo_error (\"Substring reference in DATA statement\");\n-\n+       /* case REF_SUBSTRING: dealt with separately above. */\n+\t\n \tdefault:\n \t  abort ();\n \t}"}, {"sha": "2a8bc4a6c94cd44a4f12a19650db7b5f5e4f429d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "patch": "@@ -1,3 +1,8 @@\n+2004-06-02  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/15557\n+\t* gfortran.fortran-torture/execute/data_3.f90: New testcase.\n+\n 2004-06-01  Richard Hederson  <rth@redhat.com>\n \n \t* g++.dg/template/dependent-expr4.C: Use __builtin_offsetof."}, {"sha": "bdeaaa871091aaa7dc0e11752a0b795904f13e57", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/data_3.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fdata_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa548415aa2a47d71a01155e6c1cd9dac1f5b36/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fdata_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fdata_3.f90?ref=2fa548415aa2a47d71a01155e6c1cd9dac1f5b36", "patch": "@@ -0,0 +1,19 @@\n+! Check initialization of character variables via the DATA statement\n+CHARACTER*4 a\n+CHARACTER*6 b\n+CHARACTER*2 c\n+CHARACTER*4 d(2)\n+CHARACTER*4 e\n+\n+DATA a(1:2) /'aa'/\n+DATA a(3:4) /'b'/\n+DATA b(2:6), c /'AAA', '12345'/\n+DATA d /2*'1234'/\n+DATA e(4:4), e(1:3) /'45', '123A'/\n+\n+IF (a.NE.'aab ') CALL abort()\n+IF (b.NE.' AAA   ') CALL abort()\n+IF (c.NE.'12') CALL abort()\n+IF (d(1).NE.d(2) .OR. d(1).NE.'1234') CALL abort()\n+IF (e.NE.'1234') CALL abort()\n+END"}]}