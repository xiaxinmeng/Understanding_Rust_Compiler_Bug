{"sha": "6ad48e84df035fd325684bf59baf86c67ae1bdb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkNDhlODRkZjAzNWZkMzI1Njg0YmY1OWJhZjg2YzY3YWUxYmRiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-15T12:28:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-15T12:28:46Z"}, "message": "predict.c (struct block_info_def): Remove nvisited.\n\n\t* predict.c (struct block_info_def): Remove nvisited.\n\t(propagate_freq): Use EDGE_DFS_BACK to detect irreducible regions.\n\t(estimate_bb_frequencies): Call mark_dfs_back_edges.\n\n\t* i386.c (ix86_agi_depdendant): Lea causes AGI only on the Pentium\n\t(ix86_adjust_cost): Teach scheduler that latency to load operand can\n\tbe masked.\n\nFrom-SVN: r44921", "tree": {"sha": "fad32e0ae9c8f2faddd9dd154447c9c2965b09a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad32e0ae9c8f2faddd9dd154447c9c2965b09a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ad48e84df035fd325684bf59baf86c67ae1bdb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad48e84df035fd325684bf59baf86c67ae1bdb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ad48e84df035fd325684bf59baf86c67ae1bdb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad48e84df035fd325684bf59baf86c67ae1bdb1/comments", "author": null, "committer": null, "parents": [{"sha": "cc10816d2df6cc6ca36359e11baf40e95fc16f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc10816d2df6cc6ca36359e11baf40e95fc16f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc10816d2df6cc6ca36359e11baf40e95fc16f04"}], "stats": {"total": 94, "additions": 79, "deletions": 15}, "files": [{"sha": "7ace5598397c914ea82445c5b2f60dab246b071f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ad48e84df035fd325684bf59baf86c67ae1bdb1", "patch": "@@ -1,3 +1,13 @@\n+Wed Aug 15 14:24:22 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (struct block_info_def): Remove nvisited.\n+\t(propagate_freq): Use EDGE_DFS_BACK to detect irreducible regions.\n+\t(estimate_bb_frequencies): Call mark_dfs_back_edges.\n+\n+\t* i386.c (ix86_agi_depdendant): Lea causes AGI only on the Pentium\n+\t(ix86_adjust_cost): Teach scheduler that latency to load operand can\n+\tbe masked.\n+\n Wed Aug 15 12:41:32 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.def: Update hitrates."}, {"sha": "ed62fab713f19abd0ad4b7e8b67d0e06eebcaeaa", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6ad48e84df035fd325684bf59baf86c67ae1bdb1", "patch": "@@ -8450,7 +8450,8 @@ ix86_agi_dependant (insn, dep_insn, insn_type)\n {\n   rtx addr;\n \n-  if (insn_type == TYPE_LEA)\n+  if (insn_type == TYPE_LEA\n+      && TARGET_PENTIUM)\n     {\n       addr = PATTERN (insn);\n       if (GET_CODE (addr) == SET)\n@@ -8485,7 +8486,7 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n      int cost;\n {\n   enum attr_type insn_type, dep_insn_type;\n-  enum attr_memory memory;\n+  enum attr_memory memory, dep_memory;\n   rtx set, set2;\n   int dep_insn_code_number;\n \n@@ -8521,12 +8522,14 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n       break;\n \n     case PROCESSOR_PENTIUMPRO:\n+      memory = get_attr_memory (insn);\n+      dep_memory = get_attr_memory (dep_insn);\n+\n       /* Since we can't represent delayed latencies of load+operation,\n \t increase the cost here for non-imov insns.  */\n       if (dep_insn_type != TYPE_IMOV\n-\t  && dep_insn_type != TYPE_FMOV\n-\t  && ((memory = get_attr_memory (dep_insn) == MEMORY_LOAD)\n-              || memory == MEMORY_BOTH))\n+          && dep_insn_type != TYPE_FMOV\n+          && (dep_memory == MEMORY_LOAD || dep_memory == MEMORY_BOTH))\n \tcost += 1;\n \n       /* INT->FP conversion is expensive.  */\n@@ -8540,9 +8543,26 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \t  && rtx_equal_p (SET_DEST (set), SET_SRC (set2))\n \t  && GET_CODE (SET_DEST (set2)) == MEM)\n \tcost += 1;\n+\n+      /* Show ability of reorder buffer to hide latency of load by executing\n+\t in parallel with previous instruction in case\n+\t previous instruction is not needed to compute the address.  */\n+      if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)\n+\t  && !ix86_agi_dependant (insn, dep_insn, insn_type))\n+ \t{\n+\t  /* Claim moves to take one cycle, as core can issue one load\n+\t     at time and the next load can start cycle later.  */\n+\t  if (dep_insn_type == TYPE_IMOV\n+\t      || dep_insn_type == TYPE_FMOV)\n+\t    cost = 1;\n+\t  else if (cost > 1)\n+\t    cost--;\n+\t}\n       break;\n \n     case PROCESSOR_K6:\n+      memory = get_attr_memory (insn);\n+      dep_memory = get_attr_memory (dep_insn);\n       /* The esp dependency is resolved before the instruction is really\n          finished.  */\n       if ((insn_type == TYPE_PUSH || insn_type == TYPE_POP)\n@@ -8551,24 +8571,58 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \n       /* Since we can't represent delayed latencies of load+operation,\n \t increase the cost here for non-imov insns.  */\n-      if ((memory = get_attr_memory (dep_insn) == MEMORY_LOAD)\n-          || memory == MEMORY_BOTH)\n+      if (dep_memory == MEMORY_LOAD || dep_memory == MEMORY_BOTH)\n \tcost += (dep_insn_type != TYPE_IMOV) ? 2 : 1;\n \n       /* INT->FP conversion is expensive.  */\n       if (get_attr_fp_int_src (dep_insn))\n \tcost += 5;\n+\n+      /* Show ability of reorder buffer to hide latency of load by executing\n+\t in parallel with previous instruction in case\n+\t previous instruction is not needed to compute the address.  */\n+      if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)\n+\t  && !ix86_agi_dependant (insn, dep_insn, insn_type))\n+ \t{\n+\t  /* Claim moves to take one cycle, as core can issue one load\n+\t     at time and the next load can start cycle later.  */\n+\t  if (dep_insn_type == TYPE_IMOV\n+\t      || dep_insn_type == TYPE_FMOV)\n+\t    cost = 1;\n+\t  else if (cost > 2)\n+\t    cost -= 2;\n+\t  else\n+\t    cost = 1;\n+\t}\n       break;\n \n     case PROCESSOR_ATHLON:\n-      if ((memory = get_attr_memory (dep_insn)) == MEMORY_LOAD\n-           || memory == MEMORY_BOTH)\n+      memory = get_attr_memory (insn);\n+      dep_memory = get_attr_memory (dep_insn);\n+\n+      if (dep_memory == MEMORY_LOAD || dep_memory == MEMORY_BOTH)\n \t{\n \t  if (dep_insn_type == TYPE_IMOV || dep_insn_type == TYPE_FMOV)\n \t    cost += 2;\n \t  else\n \t    cost += 3;\n         }\n+      /* Show ability of reorder buffer to hide latency of load by executing\n+\t in parallel with previous instruction in case\n+\t previous instruction is not needed to compute the address.  */\n+      if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)\n+\t  && !ix86_agi_dependant (insn, dep_insn, insn_type))\n+ \t{\n+\t  /* Claim moves to take one cycle, as core can issue one load\n+\t     at time and the next load can start cycle later.  */\n+\t  if (dep_insn_type == TYPE_IMOV\n+\t      || dep_insn_type == TYPE_FMOV)\n+\t    cost = 0;\n+\t  else if (cost >= 3)\n+\t    cost -= 3;\n+\t  else\n+\t    cost = 0;\n+\t}\n \n     default:\n       break;"}, {"sha": "6496ef02d87a9f07d1fdfbbcce71d93649e1ec61", "filename": "gcc/predict.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad48e84df035fd325684bf59baf86c67ae1bdb1/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=6ad48e84df035fd325684bf59baf86c67ae1bdb1", "patch": "@@ -68,11 +68,11 @@ DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", PROB_ALWAYS,\n \t       PRED_FLAG_FIRST_MATCH)\n \n /* Loopback edge is taken.  */\n-DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", HITRATE (88),\n+DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", HITRATE (89),\n \t       PRED_FLAG_FIRST_MATCH)\n \n /* Edge causing loop to terminate is probably not taken. */\n-DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (92),\n+DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (90),\n \t       PRED_FLAG_FIRST_MATCH)\n \n /* Condition emitted by preconditiong code to ensure that variable\n@@ -83,16 +83,16 @@ DEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY, 0)\n DEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY, 0)\n \n /* Copied condition for the first iteration of loop is probably true.  */\n-DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (60), 0)\n+DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (64), 0)\n \n /* Pointers are usually not NULL.  */\n-DEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (75), 0)\n+DEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (83), 0)\n \n /* NE is probable, EQ not etc...  */\n-DEF_PREDICTOR (PRED_OPCODE, \"opcode\", HITRATE (53), 0)\n+DEF_PREDICTOR (PRED_OPCODE, \"opcode\", HITRATE (55), 0)\n \n /* Branch guarding call is probably taken.  */\n-DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (66), 0)\n+DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)\n \n /* Branch causing function to terminate is probably not taken.  */\n DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", PROB_LIKELY, 0)"}]}