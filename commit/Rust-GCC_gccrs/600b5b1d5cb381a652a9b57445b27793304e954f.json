{"sha": "600b5b1d5cb381a652a9b57445b27793304e954f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwYjViMWQ1Y2IzODFhNjUyYTliNTc0NDViMjc3OTMzMDRlOTU0Zg==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-08-31T01:43:33Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-08-31T01:43:33Z"}, "message": "This patch sanitizes the partitioning to address issues such as edge weight insanities that sometimes occur due to upstream optimizations...\n\nThis patch sanitizes the partitioning to address issues such as edge\nweight insanities that sometimes occur due to upstream optimizations,\nand ensures that hot blocks are not dominated by cold blocks. This\nneeds to be resanitized after certain cfg optimizations that may\ncause hot blocks previously reached via both hot and cold paths to\nonly be reached by cold paths.\n\nThe verification code in sanitize_dominator_hotness was contributed by\nSteven Bosscher.\n\n2013-08-29  Teresa Johnson  <tejohnson@google.com>\n            Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* cfgrtl.c (fixup_new_cold_bb): New routine.\n\t(commit_edge_insertions): Invoke fixup_partitions.\n\t(find_partition_fixes): New routine.\n\t(fixup_partitions): Ditto.\n\t(verify_hot_cold_block_grouping): Update comments.\n\t(rtl_verify_edges): Invoke find_partition_fixes.\n\t(rtl_verify_bb_pointers): Update comments.\n\t(rtl_verify_bb_layout): Ditto.\n\t* basic-block.h (probably_never_executed_edge_p): Declare.\n        (fixup_partitions): Ditto.\n\t* cfgcleanup.c (try_optimize_cfg): Invoke fixup_partitions.\n\t* bb-reorder.c (sanitize_hot_paths): New function.\n        (find_rarely_executed_basic_blocks_and_crossing_edges): Invoke\n        sanitize_hot_paths.\n\t* predict.c (probably_never_executed_edge_p): New routine.\n\t* cfg.c (check_bb_profile): Add partition insanity warnings.\n\nCo-Authored-By: Steven Bosscher <steven@gcc.gnu.org>\n\nFrom-SVN: r202125", "tree": {"sha": "5309c6fb7e215165052af90d314125c561039563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5309c6fb7e215165052af90d314125c561039563"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/600b5b1d5cb381a652a9b57445b27793304e954f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600b5b1d5cb381a652a9b57445b27793304e954f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600b5b1d5cb381a652a9b57445b27793304e954f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600b5b1d5cb381a652a9b57445b27793304e954f/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b55c620f002242dfa035572deb1bd1ed9c97dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b55c620f002242dfa035572deb1bd1ed9c97dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b55c620f002242dfa035572deb1bd1ed9c97dd7"}], "stats": {"total": 360, "additions": 352, "deletions": 8}, "files": [{"sha": "5e78ba1048bd0b68364aade270770d94debba764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -1,3 +1,23 @@\n+2013-08-30  Teresa Johnson  <tejohnson@google.com>\n+\t    Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cfgrtl.c (fixup_new_cold_bb): New routine.\n+\t(commit_edge_insertions): Invoke fixup_partitions.\n+\t(find_partition_fixes): New routine.\n+\t(fixup_partitions): Ditto.\n+\t(verify_hot_cold_block_grouping): Update comments.\n+\t(rtl_verify_edges): Invoke find_partition_fixes.\n+\t(rtl_verify_bb_pointers): Update comments.\n+\t(rtl_verify_bb_layout): Ditto.\n+\t* basic-block.h (probably_never_executed_edge_p): Declare.\n+\t(fixup_partitions): Ditto.\n+\t* cfgcleanup.c (try_optimize_cfg): Invoke fixup_partitions.\n+\t* bb-reorder.c (sanitize_hot_paths): New function.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): Invoke\n+\tsanitize_hot_paths.\n+\t* predict.c (probably_never_executed_edge_p): New routine.\n+\t* cfg.c (check_bb_profile): Add partition insanity warnings.\n+\n 2013-08-30  Meador Inge  <meadori@codesourcery.com>\n \n \t* tree-vrp.c (check_array_ref): Bail out on zero-length arrays."}, {"sha": "d7b896ae8a169fb0af6c352a9487bb2ece667454", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -726,6 +726,7 @@ extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n extern bool maybe_hot_edge_p (edge);\n extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n+extern bool probably_never_executed_edge_p (struct function *, edge);\n extern bool optimize_bb_for_size_p (const_basic_block);\n extern bool optimize_bb_for_speed_p (const_basic_block);\n extern bool optimize_edge_for_size_p (edge);\n@@ -797,6 +798,7 @@ extern bool contains_no_active_insn_p (const_basic_block);\n extern bool forwarder_block_p (const_basic_block);\n extern bool can_fallthru (basic_block, basic_block);\n extern void emit_barrier_after_bb (basic_block bb);\n+extern void fixup_partitions (void);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);"}, {"sha": "6b034aba5c9ec8059d353b0faabbff412be612fb", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -1444,25 +1444,155 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n       ei_next (&ei);\n }\n \n+\n+/* Ensure that all hot bbs are included in a hot path through the\n+   procedure. This is done by calling this function twice, once\n+   with WALK_UP true (to look for paths from the entry to hot bbs) and\n+   once with WALK_UP false (to look for paths from hot bbs to the exit).\n+   Returns the updated value of COLD_BB_COUNT and adds newly-hot bbs\n+   to BBS_IN_HOT_PARTITION.  */\n+\n+static unsigned int\n+sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n+                    vec<basic_block> *bbs_in_hot_partition)\n+{\n+  /* Callers check this.  */\n+  gcc_checking_assert (cold_bb_count);\n+\n+  /* Keep examining hot bbs while we still have some left to check\n+     and there are remaining cold bbs.  */\n+  vec<basic_block> hot_bbs_to_check = bbs_in_hot_partition->copy ();\n+  while (! hot_bbs_to_check.is_empty ()\n+         && cold_bb_count)\n+    {\n+      basic_block bb = hot_bbs_to_check.pop ();\n+      vec<edge, va_gc> *edges = walk_up ? bb->preds : bb->succs;\n+      edge e;\n+      edge_iterator ei;\n+      int highest_probability = 0;\n+      int highest_freq = 0;\n+      gcov_type highest_count = 0;\n+      bool found = false;\n+\n+      /* Walk the preds/succs and check if there is at least one already\n+         marked hot. Keep track of the most frequent pred/succ so that we\n+         can mark it hot if we don't find one.  */\n+      FOR_EACH_EDGE (e, ei, edges)\n+        {\n+          basic_block reach_bb = walk_up ? e->src : e->dest;\n+\n+          if (e->flags & EDGE_DFS_BACK)\n+            continue;\n+\n+          if (BB_PARTITION (reach_bb) != BB_COLD_PARTITION)\n+          {\n+            found = true;\n+            break;\n+          }\n+          /* The following loop will look for the hottest edge via\n+             the edge count, if it is non-zero, then fallback to the edge\n+             frequency and finally the edge probability.  */\n+          if (e->count > highest_count)\n+            highest_count = e->count;\n+          int edge_freq = EDGE_FREQUENCY (e);\n+          if (edge_freq > highest_freq)\n+            highest_freq = edge_freq;\n+          if (e->probability > highest_probability)\n+            highest_probability = e->probability;\n+        }\n+\n+      /* If bb is reached by (or reaches, in the case of !WALK_UP) another hot\n+         block (or unpartitioned, e.g. the entry block) then it is ok. If not,\n+         then the most frequent pred (or succ) needs to be adjusted.  In the\n+         case where multiple preds/succs have the same frequency (e.g. a\n+         50-50 branch), then both will be adjusted.  */\n+      if (found)\n+        continue;\n+\n+      FOR_EACH_EDGE (e, ei, edges)\n+        {\n+          if (e->flags & EDGE_DFS_BACK)\n+            continue;\n+          /* Select the hottest edge using the edge count, if it is non-zero,\n+             then fallback to the edge frequency and finally the edge\n+             probability.  */\n+          if (highest_count)\n+            {\n+              if (e->count < highest_count)\n+                continue;\n+            }\n+          else if (highest_freq)\n+            {\n+              if (EDGE_FREQUENCY (e) < highest_freq)\n+                continue;\n+            }\n+          else if (e->probability < highest_probability)\n+            continue;\n+\n+          basic_block reach_bb = walk_up ? e->src : e->dest;\n+\n+          /* We have a hot bb with an immediate dominator that is cold.\n+             The dominator needs to be re-marked hot.  */\n+          BB_SET_PARTITION (reach_bb, BB_HOT_PARTITION);\n+          cold_bb_count--;\n+\n+          /* Now we need to examine newly-hot reach_bb to see if it is also\n+             dominated by a cold bb.  */\n+          bbs_in_hot_partition->safe_push (reach_bb);\n+          hot_bbs_to_check.safe_push (reach_bb);\n+        }\n+    }\n+\n+  return cold_bb_count;\n+}\n+\n+\n /* Find the basic blocks that are rarely executed and need to be moved to\n    a separate section of the .o file (to cut down on paging and improve\n    cache locality).  Return a vector of all edges that cross.  */\n \n-static vec<edge> \n+static vec<edge>\n find_rarely_executed_basic_blocks_and_crossing_edges (void)\n {\n   vec<edge> crossing_edges = vNULL;\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n+  unsigned int cold_bb_count = 0;\n+  vec<basic_block> bbs_in_hot_partition = vNULL;\n \n   /* Mark which partition (hot/cold) each basic block belongs in.  */\n   FOR_EACH_BB (bb)\n     {\n       if (probably_never_executed_bb_p (cfun, bb))\n-\tBB_SET_PARTITION (bb, BB_COLD_PARTITION);\n+        {\n+          BB_SET_PARTITION (bb, BB_COLD_PARTITION);\n+          cold_bb_count++;\n+        }\n       else\n-\tBB_SET_PARTITION (bb, BB_HOT_PARTITION);\n+        {\n+          BB_SET_PARTITION (bb, BB_HOT_PARTITION);\n+          bbs_in_hot_partition.safe_push (bb);\n+        }\n+    }\n+\n+  /* Ensure that hot bbs are included along a hot path from the entry to exit.\n+     Several different possibilities may include cold bbs along all paths\n+     to/from a hot bb. One is that there are edge weight insanities\n+     due to optimization phases that do not properly update basic block profile\n+     counts. The second is that the entry of the function may not be hot, because\n+     it is entered fewer times than the number of profile training runs, but there\n+     is a loop inside the function that causes blocks within the function to be\n+     above the threshold for hotness. This is fixed by walking up from hot bbs\n+     to the entry block, and then down from hot bbs to the exit, performing\n+     partitioning fixups as necessary.  */\n+  if (cold_bb_count)\n+    {\n+      mark_dfs_back_edges ();\n+      cold_bb_count = sanitize_hot_paths (true, cold_bb_count,\n+                                          &bbs_in_hot_partition);\n+      if (cold_bb_count)\n+        sanitize_hot_paths (false, cold_bb_count, &bbs_in_hot_partition);\n     }\n \n   /* The format of .gcc_except_table does not allow landing pads to"}, {"sha": "cfada7395dbf9c79020ed07edea53cc93ef8f19d", "filename": "gcc/cfg.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -446,6 +446,21 @@ check_bb_profile (basic_block bb, FILE * file, int indent, int flags)\n \t\t (flags & TDF_COMMENT) ? \";; \" : \"\", s_indent,\n \t\t (int) lsum, (int) bb->count);\n     }\n+  if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n+    {\n+      /* Warn about inconsistencies in the partitioning that are\n+         currently caused by profile insanities created via optimization.  */\n+      if (!probably_never_executed_bb_p (fun, bb))\n+        fprintf (file, \"%s%sBlock in cold partition with hot count\\n\",\n+                 (flags & TDF_COMMENT) ? \";; \" : \"\", s_indent);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+        {\n+          if (!probably_never_executed_edge_p (fun, e))\n+            fprintf (file,\n+                     \"%s%sBlock in cold partition with incoming hot edge\\n\",\n+                     (flags & TDF_COMMENT) ? \";; \" : \"\", s_indent);\n+        }\n+    }\n }\n \f\n void"}, {"sha": "6836a9e6e847ac513e5f5de39fcd776e50d48449", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -2807,10 +2807,21 @@ try_optimize_cfg (int mode)\n \t      df_analyze ();\n \t    }\n \n-#ifdef ENABLE_CHECKING\n \t  if (changed)\n-\t    verify_flow_info ();\n+            {\n+              /* Edge forwarding in particular can cause hot blocks previously\n+                 reached by both hot and cold blocks to become dominated only\n+                 by cold blocks. This will cause the verification below to fail,\n+                 and lead to now cold code in the hot section. This is not easy\n+                 to detect and fix during edge forwarding, and in some cases\n+                 is only visible after newly unreachable blocks are deleted,\n+                 which will be done in fixup_partitions.  */\n+              fixup_partitions ();\n+\n+#ifdef ENABLE_CHECKING\n+              verify_flow_info ();\n #endif\n+            }\n \n \t  changed_overall |= changed;\n \t  first_pass = false;"}, {"sha": "eb6b312d5c81c9805da490aeeeb253077cd1f838", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 153, "deletions": 3, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -1358,6 +1358,43 @@ fixup_partition_crossing (edge e)\n     }\n }\n \n+/* Called when block BB has been reassigned to the cold partition,\n+   because it is now dominated by another cold block,\n+   to ensure that the region crossing attributes are updated.  */\n+\n+static void\n+fixup_new_cold_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* This is called when a hot bb is found to now be dominated\n+     by a cold bb and therefore needs to become cold. Therefore,\n+     its preds will no longer be region crossing. Any non-dominating\n+     preds that were previously hot would also have become cold\n+     in the caller for the same region. Any preds that were previously\n+     region-crossing will be adjusted in fixup_partition_crossing.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      fixup_partition_crossing (e);\n+    }\n+\n+  /* Possibly need to make bb's successor edges region crossing,\n+     or remove stale region crossing.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      /* We can't have fall-through edges across partition boundaries.\n+         Note that force_nonfallthru will do any necessary partition\n+         boundary fixup by calling fixup_partition_crossing itself.  */\n+      if ((e->flags & EDGE_FALLTHRU)\n+          && BB_PARTITION (bb) != BB_PARTITION (e->dest)\n+          && e->dest != EXIT_BLOCK_PTR)\n+        force_nonfallthru (e);\n+      else\n+        fixup_partition_crossing (e);\n+    }\n+}\n+\n /* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n    expense of adding new instructions or reordering basic blocks.\n \n@@ -1996,6 +2033,14 @@ commit_edge_insertions (void)\n {\n   basic_block bb;\n \n+  /* Optimization passes that invoke this routine can cause hot blocks\n+     previously reached by both hot and cold blocks to become dominated only\n+     by cold blocks. This will cause the verification below to fail,\n+     and lead to now cold code in the hot section. In some cases this\n+     may only be visible after newly unreachable blocks are deleted,\n+     which will be done by fixup_partitions.  */\n+  fixup_partitions ();\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n@@ -2190,6 +2235,101 @@ get_last_bb_insn (basic_block bb)\n   return end;\n }\n \n+/* Sanity check partition hotness to ensure that basic blocks in\n+ \u00a0 the cold partition don't dominate basic blocks in the hot partition.\n+   If FLAG_ONLY is true, report violations as errors. Otherwise\n+   re-mark the dominated blocks as cold, since this is run after\n+   cfg optimizations that may make hot blocks previously reached\n+   by both hot and cold blocks now only reachable along cold paths.  */\n+\n+static vec<basic_block>\n+find_partition_fixes (bool flag_only)\n+{\n+  basic_block bb;\n+  vec<basic_block> bbs_in_cold_partition = vNULL;\n+  vec<basic_block> bbs_to_fix = vNULL;\n+\n+  /* Callers check this.  */\n+  gcc_checking_assert (crtl->has_bb_partition);\n+\n+  FOR_EACH_BB (bb)\n+    if ((BB_PARTITION (bb) == BB_COLD_PARTITION))\n+      bbs_in_cold_partition.safe_push (bb);\n+\n+  if (bbs_in_cold_partition.is_empty ())\n+    return vNULL;\n+\n+  bool dom_calculated_here = !dom_info_available_p (CDI_DOMINATORS);\n+\n+  if (dom_calculated_here)\n+    calculate_dominance_info (CDI_DOMINATORS);\n+\n+  while (! bbs_in_cold_partition.is_empty  ())\n+    {\n+      bb = bbs_in_cold_partition.pop ();\n+      /* Any blocks dominated by a block in the cold section\n+         must also be cold.  */\n+      basic_block son;\n+      for (son = first_dom_son (CDI_DOMINATORS, bb);\n+           son;\n+           son = next_dom_son (CDI_DOMINATORS, son))\n+        {\n+          /* If son is not yet cold, then mark it cold here and\n+             enqueue it for further processing.  */\n+          if ((BB_PARTITION (son) != BB_COLD_PARTITION))\n+            {\n+              if (flag_only)\n+                error (\"non-cold basic block %d dominated \"\n+                       \"by a block in the cold partition (%d)\", son->index, bb->index);\n+              else\n+                BB_SET_PARTITION (son, BB_COLD_PARTITION);\n+              bbs_to_fix.safe_push (son);\n+              bbs_in_cold_partition.safe_push (son);\n+            }\n+        }\n+    }\n+\n+  if (dom_calculated_here)\n+    free_dominance_info (CDI_DOMINATORS);\n+\n+  return bbs_to_fix;\n+}\n+\n+/* Perform cleanup on the hot/cold bb partitioning after optimization\n+   passes that modify the cfg.  */\n+\n+void\n+fixup_partitions (void)\n+{\n+  basic_block bb;\n+\n+  if (!crtl->has_bb_partition)\n+    return;\n+\n+  /* Delete any blocks that became unreachable and weren't\n+     already cleaned up, for example during edge forwarding\n+     and convert_jumps_to_returns. This will expose more\n+     opportunities for fixing the partition boundaries here.\n+     Also, the calculation of the dominance graph during verification\n+     will assert if there are unreachable nodes.  */\n+  delete_unreachable_blocks ();\n+\n+  /* If there are partitions, do a sanity check on them: A basic block in\n+   \u00a0 a cold partition cannot dominate a basic block in a hot partition.\n+     Fixup any that now violate this requirement, as a result of edge\n+     forwarding and unreachable block deletion. \u00a0*/\n+  vec<basic_block> bbs_to_fix = find_partition_fixes (false);\n+\n+  /* Do the partition fixup after all necessary blocks have been converted to\n+     cold, so that we only update the region crossings the minimum number of\n+     places, which can require forcing edges to be non fallthru.  */\n+  while (! bbs_to_fix.is_empty ())\n+    {\n+      bb = bbs_to_fix.pop ();\n+      fixup_new_cold_bb (bb);\n+    }\n+}\n+\n /* Verify, in the basic block chain, that there is at most one switch\n    between hot/cold partitions. This condition will not be true until\n    after reorder_basic_blocks is called.  */\n@@ -2236,7 +2376,8 @@ verify_hot_cold_block_grouping (void)\n /* Perform several checks on the edges out of each block, such as\n    the consistency of the branch probabilities, the correctness\n    of hot/cold partition crossing edges, and the number of expected\n-   successor edges.  */\n+   successor edges.  Also verify that the dominance relationship\n+   between hot/cold blocks is sane.  */\n \n static int\n rtl_verify_edges (void)\n@@ -2399,6 +2540,14 @@ rtl_verify_edges (void)\n \t}\n     }\n \n+  /* If there are partitions, do a sanity check on them: A basic block in\n+   \u00a0 a cold partition cannot dominate a basic block in a hot partition. \u00a0*/\n+  if (crtl->has_bb_partition && !err)\n+    {\n+      vec<basic_block> bbs_to_fix = find_partition_fixes (true);\n+      err = !bbs_to_fix.is_empty ();\n+    }\n+\n   /* Clean up.  */\n   return err;\n }\n@@ -2532,7 +2681,7 @@ rtl_verify_bb_pointers (void)\n      and NOTE_INSN_BASIC_BLOCK\n    - verify that no fall_thru edge crosses hot/cold partition boundaries\n    - verify that there are no pending RTL branch predictions\n-   - verify that there is a single hot/cold partition boundary after bbro\n+   - verify that hot blocks are not dominated by cold blocks\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n@@ -2778,7 +2927,8 @@ rtl_verify_bb_layout (void)\n    - check that all insns are in the basic blocks\n      (except the switch handling code, barriers and notes)\n    - check that all returns are followed by barriers\n-   - check that all fallthru edge points to the adjacent blocks.  */\n+   - check that all fallthru edge points to the adjacent blocks\n+   - verify that there is a single hot/cold partition boundary after bbro  */\n \n static int\n rtl_verify_flow_info (void)"}, {"sha": "06da1cdf22ec66582ff07f793c80e7caf30dfb6d", "filename": "gcc/predict.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600b5b1d5cb381a652a9b57445b27793304e954f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=600b5b1d5cb381a652a9b57445b27793304e954f", "patch": "@@ -241,6 +241,22 @@ probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n   return false;\n }\n \n+\n+/* Return true in case edge E is probably never executed.  */\n+\n+bool\n+probably_never_executed_edge_p (struct function *fun, edge e)\n+{\n+  gcc_checking_assert (fun);\n+  if (profile_info && flag_branch_probabilities)\n+    return ((e->count + profile_info->runs / 2) / profile_info->runs) == 0;\n+  if ((!profile_info || !flag_branch_probabilities)\n+      && (cgraph_get_node (fun->decl)->frequency\n+\t  == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n+    return true;\n+  return false;\n+}\n+\n /* Return true if NODE should be optimized for size.  */\n \n bool"}]}