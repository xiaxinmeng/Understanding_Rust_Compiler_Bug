{"sha": "95e9a7616d363105a654f2108535f8121938bf04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVlOWE3NjE2ZDM2MzEwNWE2NTRmMjEwODUzNWY4MTIxOTM4YmYwNA==", "commit": {"author": {"name": "JeanHeyd Meneide", "email": "phdofthehouse@gmail.com", "date": "2019-09-05T11:27:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-09-05T11:27:45Z"}, "message": "Implement std::span for C++20\n\n2019-09-05  JeanHeyd Meneide  <phdofthehouse@gmail.com>\n\n\t* include/Makefile.am: Add <span> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/range_access.h (__adl_begin, __adl_end, __adl_cbegin)\n\t(__adl_cend, __adl_rbegin, __adl_rend, __adl_crbegin, __adl_crend)\n\t(__adl_data, __adl_cdata, __adl_size, __adl_empty, __adl_to_address):\n\tNew functions for performing argument-dependent lookup of range\n\tcustomization points.\n\t* include/bits/stl_iterator.h (__normal_iterator): Add\n\t_GLIBCXX20_CONSTEXPR to all functions.\n\t* include/std/span: New header.\n\t* include/std/version (__cpp_lib_span): Define feature test macro.\n\t* testsuite/23_containers/span/contiguous_range_neg.cc: New test.\n\t* testsuite/23_containers/span/everything.cc: New test.\n\t* testsuite/23_containers/span/get_neg.cc: New test.\n\t* testsuite/23_containers/span/last_neg.cc: New test.\n\t* testsuite/23_containers/span/subspan_neg.cc: New test.\n\t* testsuite/23_containers/span/tuple_element_dynamic_neg.cc: New test.\n\t* testsuite/23_containers/span/tuple_element_oob_neg.cc: New test.\n\t* testsuite/23_containers/span/tuple_size_neg.cc: New test.\n\nFrom-SVN: r275403", "tree": {"sha": "14e109dae9d12194e175cb9eca9ed8c058ece0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14e109dae9d12194e175cb9eca9ed8c058ece0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95e9a7616d363105a654f2108535f8121938bf04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e9a7616d363105a654f2108535f8121938bf04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e9a7616d363105a654f2108535f8121938bf04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e9a7616d363105a654f2108535f8121938bf04/comments", "author": {"login": "ThePhD", "id": 2886436, "node_id": "MDQ6VXNlcjI4ODY0MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/2886436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThePhD", "html_url": "https://github.com/ThePhD", "followers_url": "https://api.github.com/users/ThePhD/followers", "following_url": "https://api.github.com/users/ThePhD/following{/other_user}", "gists_url": "https://api.github.com/users/ThePhD/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThePhD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThePhD/subscriptions", "organizations_url": "https://api.github.com/users/ThePhD/orgs", "repos_url": "https://api.github.com/users/ThePhD/repos", "events_url": "https://api.github.com/users/ThePhD/events{/privacy}", "received_events_url": "https://api.github.com/users/ThePhD/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "056f95ec951178a110b57e58a2ee434907de2e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056f95ec951178a110b57e58a2ee434907de2e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/056f95ec951178a110b57e58a2ee434907de2e38"}], "stats": {"total": 1055, "additions": 1052, "deletions": 3}, "files": [{"sha": "8a8ec142e574c5c06554ab6f6f9dbaa9720429e6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -1,3 +1,25 @@\n+2019-09-05  JeanHeyd Meneide  <phdofthehouse@gmail.com>\n+\n+\t* include/Makefile.am: Add <span> header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/range_access.h (__adl_begin, __adl_end, __adl_cbegin)\n+\t(__adl_cend, __adl_rbegin, __adl_rend, __adl_crbegin, __adl_crend)\n+\t(__adl_data, __adl_cdata, __adl_size, __adl_empty, __adl_to_address):\n+\tNew functions for performing argument-dependent lookup of range\n+\tcustomization points.\n+\t* include/bits/stl_iterator.h (__normal_iterator): Add\n+\t_GLIBCXX20_CONSTEXPR to all functions.\n+\t* include/std/span: New header.\n+\t* include/std/version (__cpp_lib_span): Define feature test macro.\n+\t* testsuite/23_containers/span/contiguous_range_neg.cc: New test.\n+\t* testsuite/23_containers/span/everything.cc: New test.\n+\t* testsuite/23_containers/span/get_neg.cc: New test.\n+\t* testsuite/23_containers/span/last_neg.cc: New test.\n+\t* testsuite/23_containers/span/subspan_neg.cc: New test.\n+\t* testsuite/23_containers/span/tuple_element_dynamic_neg.cc: New test.\n+\t* testsuite/23_containers/span/tuple_element_oob_neg.cc: New test.\n+\t* testsuite/23_containers/span/tuple_size_neg.cc: New test.\n+\n 2019-09-05  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/xml/manual/allocator.xml: Remove URL for bibliography entry."}, {"sha": "b8b786d9260b91b814c99358496d148be686539d", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -68,6 +68,7 @@ std_headers = \\\n \t${std_srcdir}/scoped_allocator \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/shared_mutex \\\n+\t${std_srcdir}/span \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\\n \t${std_srcdir}/stdexcept \\"}, {"sha": "cd1e9df5482a19e11fa7bcaf7960304535978c9d", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -412,6 +412,7 @@ std_headers = \\\n \t${std_srcdir}/scoped_allocator \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/shared_mutex \\\n+\t${std_srcdir}/span \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\\n \t${std_srcdir}/stdexcept \\"}, {"sha": "44b9c6c3596a475571ea4a37950e3fe5fa46b402", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -318,6 +318,78 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #endif // C++17\n \n+#if __cplusplus > 201703L\n+  // \"why are these in namespace std:: and not __gnu_cxx:: ?\"\n+  // because if we don't put them here it's impossible to\n+  // have implicit ADL with \"using std::begin/end/size/data;\".\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_begin(_Container& __cont) noexcept(noexcept(begin(__cont)))\n+    { return begin(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_end(_Container& __cont) noexcept(noexcept(end(__cont)))\n+    { return end(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_cbegin(_Container& __cont) noexcept(noexcept(cbegin(__cont)))\n+    { return cbegin(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_cend(_Container& __cont) noexcept(noexcept(cend(__cont)))\n+    { return cend(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_rbegin(_Container& __cont) noexcept(noexcept(rbegin(__cont)))\n+    { return rbegin(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_rend(_Container& __cont) noexcept(noexcept(rend(__cont)))\n+    { return rend(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_crbegin(_Container& __cont) noexcept(noexcept(crbegin(__cont)))\n+    { return crbegin(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_crend(_Container& __cont) noexcept(noexcept(crend(__cont)))\n+    { return crend(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_data(_Container& __cont) noexcept(noexcept(data(__cont)))\n+    { return data(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_cdata(_Container& __cont) noexcept(noexcept(cdata(__cont)))\n+    { return cdata(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_size(_Container& __cont) noexcept(noexcept(size(__cont)))\n+    { return size(__cont); }\n+\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_empty(_Container& __cont) noexcept(noexcept(empty(__cont)))\n+    { return empty(__cont); }\n+\n+#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n+  template <typename _Container>\n+    constexpr auto\n+    __adl_to_address(_Container& __cont) noexcept(noexcept(to_address(__cont)))\n+    { return to_address(__cont); }\n+#endif // P1394 and new contiguous_iterator requirements [iterator.concept.contiguous]\n+#endif // C++20\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "e29775a42c510fefc03c52ffb20b198e3b673d45", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -446,7 +446,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if __cplusplus >= 201103L\n   template<typename _Iterator>\n-    _GLIBCXX20_CONSTEXPR auto\n+    _GLIBCXX20_CONSTEXPR\n+    auto\n     __niter_base(reverse_iterator<_Iterator> __it)\n     -> decltype(__make_reverse_iterator(__niter_base(__it.base())))\n     { return __make_reverse_iterator(__niter_base(__it.base())); }\n@@ -457,7 +458,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   template<typename _Iterator>\n-    _GLIBCXX20_CONSTEXPR auto\n+    _GLIBCXX20_CONSTEXPR\n+    auto\n     __miter_base(reverse_iterator<_Iterator> __it)\n     -> decltype(__make_reverse_iterator(__miter_base(__it.base())))\n     { return __make_reverse_iterator(__miter_base(__it.base())); }\n@@ -802,71 +804,84 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT\n       : _M_current(_Iterator()) { }\n \n-      explicit\n+      explicit _GLIBCXX20_CONSTEXPR\n       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT\n       : _M_current(__i) { }\n \n       // Allow iterator to const_iterator conversion\n       template<typename _Iter>\n+        _GLIBCXX20_CONSTEXPR\n         __normal_iterator(const __normal_iterator<_Iter,\n \t\t\t  typename __enable_if<\n       \t       (std::__are_same<_Iter, typename _Container::pointer>::__value),\n \t\t      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT\n         : _M_current(__i.base()) { }\n \n       // Forward iterator requirements\n+      _GLIBCXX20_CONSTEXPR\n       reference\n       operator*() const _GLIBCXX_NOEXCEPT\n       { return *_M_current; }\n \n+      _GLIBCXX20_CONSTEXPR\n       pointer\n       operator->() const _GLIBCXX_NOEXCEPT\n       { return _M_current; }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator&\n       operator++() _GLIBCXX_NOEXCEPT\n       {\n \t++_M_current;\n \treturn *this;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator\n       operator++(int) _GLIBCXX_NOEXCEPT\n       { return __normal_iterator(_M_current++); }\n \n       // Bidirectional iterator requirements\n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator&\n       operator--() _GLIBCXX_NOEXCEPT\n       {\n \t--_M_current;\n \treturn *this;\n       }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator\n       operator--(int) _GLIBCXX_NOEXCEPT\n       { return __normal_iterator(_M_current--); }\n \n       // Random access iterator requirements\n+      _GLIBCXX20_CONSTEXPR\n       reference\n       operator[](difference_type __n) const _GLIBCXX_NOEXCEPT\n       { return _M_current[__n]; }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator&\n       operator+=(difference_type __n) _GLIBCXX_NOEXCEPT\n       { _M_current += __n; return *this; }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator\n       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT\n       { return __normal_iterator(_M_current + __n); }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator&\n       operator-=(difference_type __n) _GLIBCXX_NOEXCEPT\n       { _M_current -= __n; return *this; }\n \n+      _GLIBCXX20_CONSTEXPR\n       __normal_iterator\n       operator-(difference_type __n) const _GLIBCXX_NOEXCEPT\n       { return __normal_iterator(_M_current - __n); }\n \n+      _GLIBCXX20_CONSTEXPR\n       const _Iterator&\n       base() const _GLIBCXX_NOEXCEPT\n       { return _M_current; }\n@@ -882,27 +897,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Forward iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() == __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t       const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() == __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() != __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t       const __normal_iterator<_Iterator, _Container>& __rhs)\n@@ -911,55 +930,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Random access iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() < __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t      const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() < __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() > __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t      const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() > __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t       const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() >= __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline bool\n     operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t       const __normal_iterator<_Iterator, _Container>& __rhs)\n@@ -973,6 +1000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n #if __cplusplus >= 201103L\n     // DR 685.\n+    _GLIBCXX20_CONSTEXPR\n     inline auto\n     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept\n@@ -985,13 +1013,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() - __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline typename __normal_iterator<_Iterator, _Container>::difference_type\n     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\n \t      const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() - __rhs.base(); }\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     inline __normal_iterator<_Iterator, _Container>\n     operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\n \t      __n, const __normal_iterator<_Iterator, _Container>& __i)\n@@ -1006,6 +1036,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Iterator, typename _Container>\n+    _GLIBCXX20_CONSTEXPR\n     _Iterator\n     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)\n     _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)"}, {"sha": "4ce2f31a1310bcc5d059add9236fa3f59e135839", "filename": "libstdc++-v3/include/std/span", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,521 @@\n+// Components for manipulating non-owning sequences of objects -*- C++ -*-\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file span\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+//\n+// P0122 span library\n+// Contributed by ThePhD\n+//\n+\n+#ifndef _GLIBCXX_SPAN\n+#define _GLIBCXX_SPAN 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L\n+\n+#include <type_traits>\n+#include <tuple>\n+#include <utility>\n+#include <array>\n+#include <bits/stl_iterator.h>\n+#include <bits/range_access.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+// FIXME: they forgot this feature test macro\n+// get on someone's back about it in Belfast!!!\n+#define __cpp_lib_span 201911\n+\n+  inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);\n+\n+  namespace __detail\n+  {\n+    template<typename _Element, typename _ToElement>\n+      static constexpr inline bool __is_base_derived_safe_convertible_v\n+\t= is_convertible_v<_Element (*)[], _ToElement (*)[]>;\n+\n+    template<typename _Tp>\n+      inline constexpr bool __is_std_array_v = false;\n+\n+    template<typename _Tp, size_t _Num>\n+      inline constexpr bool\n+      __is_std_array_v<_GLIBCXX_STD_C::array<_Tp, _Num>> = true;\n+\n+#ifdef _GLIBCXX_DEBUG\n+    template<typename _Tp, size_t _Num>\n+      inline constexpr bool\n+      __is_std_array_v<std::__debug::array<_Tp, _Num>> = true;\n+#endif // debug/array\n+\n+    template<size_t _Extent>\n+      class __extent_storage\n+      {\n+      public:\n+\tconstexpr\n+\t__extent_storage() noexcept = default;\n+\n+\tconstexpr\n+\t__extent_storage(size_t) noexcept\n+\t{ }\n+\n+\tstatic constexpr size_t\n+\t_M_extent() noexcept\n+\t{ return _Extent; }\n+      };\n+\n+    template<>\n+      class __extent_storage<static_cast<size_t>(-1)>\n+      {\n+      public:\n+\tconstexpr\n+\t__extent_storage() noexcept : _M_extent_value(0)\n+\t{ };\n+\n+\tconstexpr\n+\t__extent_storage(size_t __extent) noexcept\n+\t: _M_extent_value(__extent)\n+\t{ }\n+\n+\tconstexpr size_t\n+\t_M_extent() const noexcept\n+\t{ return this->_M_extent_value; }\n+\n+      private:\n+\tsize_t _M_extent_value;\n+      };\n+\n+  } // namespace __detail\n+\n+  template<typename _Type, size_t _Extent = dynamic_extent>\n+    class span : private __detail::__extent_storage<_Extent>\n+    {\n+    public:\n+      // member types\n+      using value_type             = remove_cv_t<_Type>;\n+      using element_type           = _Type;\n+      using index_type             = size_t;\n+      using reference              = element_type&;\n+      using const_reference        = const element_type&;\n+      using pointer                = _Type*;\n+      using const_pointer          = const _Type*;\n+      using iterator\n+\t= __gnu_cxx::__normal_iterator<pointer, span>;\n+      using const_iterator\n+\t= __gnu_cxx::__normal_iterator<const_pointer, span>;\n+      using reverse_iterator       = std::reverse_iterator<iterator>;\n+      using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n+      using difference_type        = ptrdiff_t;\n+      // Official wording has no size_type -- why??\n+      // using size_type = size_t;\n+\n+      // member constants\n+      static inline constexpr size_t extent = _Extent;\n+\n+    private:\n+      using __base_t = __detail::__extent_storage<extent>;\n+\n+    public:\n+      // constructors\n+\n+      template <typename _Dummy = _Type,\n+\t\tenable_if_t<is_same_v<_Dummy, _Type>\n+\t\t  && (_Extent == dynamic_extent || _Extent == 0)>* = nullptr>\n+\tconstexpr\n+\tspan() noexcept : __base_t(0), _M_ptr(nullptr)\n+\t{ }\n+\n+      constexpr\n+      span(const span&) noexcept = default;\n+\n+      template<size_t _ArrayExtent,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(::std::__adl_data(\n+\t      ::std::declval<element_type (&)[_ArrayExtent]>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr span(element_type (&__arr)[_ArrayExtent])\n+\tnoexcept(noexcept(::std::__adl_data(__arr)))\n+\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\t{ }\n+\n+      template<size_t _ArrayExtent,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(::std::__adl_data(\n+\t      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr\n+\tspan(array<value_type, _ArrayExtent>& __arr)\n+\tnoexcept(noexcept(::std::__adl_data(__arr)))\n+\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\t{ }\n+\n+      template<size_t _ArrayExtent,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(::std::__adl_data(\n+\t      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr\n+\tspan(const array<value_type, _ArrayExtent>& __arr)\n+\tnoexcept(noexcept(::std::__adl_data(__arr)))\n+\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\t{ }\n+\n+      // NOTE: when the time comes, and P1394 -\n+      // range constructors for std::span - ships in\n+      // the standard, delete the #else block and remove\n+      // the conditional\n+      // if the paper fails, delete #if block\n+      // and keep the crappy #else block\n+      // and then cry that NB comments failed C++20...\n+      // but maybe for C++23?\n+#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n+      template<typename _Range,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent)\n+\t  && !is_same_v<remove_cvref_t<_Range>, span>\n+\t  && !__detail::__is_std_array_v<remove_cvref_t<_Range>>\n+\t  && !is_array_v<remove_cvref_t<_Range>>\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(\n+\t      ::std::__adl_data(::std::declval<_Range&>())\n+\t      + ::std::__adl_size(::std::declval<_Range&>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr\n+\tspan(_Range&& __range)\n+\tnoexcept(noexcept(::std::__adl_data(__range))\n+\t\t  && noexcept(::std::__adl_size(__range)))\n+\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+\t{ }\n+\n+      template<typename _ContiguousIterator, typename _Sentinel,\n+\tenable_if_t<!is_convertible_v<_Sentinel, index_type>\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_reference_t<typename\n+\t      iterator_traits<_ContiguousIterator>::reference>,\n+\t  element_type>>* = nullptr>\n+\tconstexpr\n+\tspan(_ContiguousIterator __first, _Sentinel __last)\n+\t: span(::std::move(__first), static_cast<index_type>(__last - __first))\n+\t{ }\n+\n+      template<typename _ContiguousIterator>\n+\tconstexpr\n+\tspan(_ContiguousIterator __first, index_type __count)\n+\tnoexcept(noexcept(::std::__adl_to_address(__first)))\n+\t: __base_t(__count), _M_ptr(::std::__adl_to_address(__first))\n+\t{ __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n+\n+#else\n+\n+      template<typename _Container,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent)\n+\t  && !is_same_v<remove_cvref_t<_Container>, span>\n+\t  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>\n+\t  && !is_array_v<remove_cvref_t<_Container>>\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(\n+\t      ::std::__adl_data(::std::declval<_Container&>())\n+\t      + ::std::__adl_size(::std::declval<_Container&>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr\n+\tspan(_Container& __range)\n+\tnoexcept(noexcept(::std::__adl_data(__range))\n+\t\t  && noexcept(::std::__adl_size(__range)))\n+\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+\t{ }\n+\n+      template<typename _Container,\n+\tenable_if_t<\n+\t  (_Extent == dynamic_extent)\n+\t  && !is_same_v<remove_cvref_t<_Container>, span>\n+\t  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>\n+\t  && !is_array_v<remove_cvref_t<_Container>>\n+\t  && __detail::__is_base_derived_safe_convertible_v<\n+\t    remove_pointer_t<decltype(\n+\t      ::std::__adl_data(::std::declval<_Container&>())\n+\t      + ::std::__adl_size(::std::declval<_Container&>()))>,\n+\t    element_type>>* = nullptr>\n+\tconstexpr span(const _Container& __range)\n+\tnoexcept(noexcept(::std::__adl_data(__range))\n+\t\t  && noexcept(::std::__adl_size(__range)))\n+\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+\t{ }\n+\n+      constexpr\n+      span(pointer __first, index_type __count) noexcept\n+      : __base_t(__count), _M_ptr(static_cast<pointer>(__first))\n+      { __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n+\n+      constexpr\n+      span(pointer __first, pointer __last) noexcept\n+      : span(::std::move(__first), static_cast<index_type>(__last - __first))\n+      { }\n+#endif // P1394\n+\n+      // assignment\n+\n+      constexpr span&\n+      operator=(const span&) noexcept = default;\n+\n+      // observers: element access\n+\n+      constexpr reference\n+      front() const noexcept\n+      { return *this->begin(); }\n+\n+      constexpr reference\n+      back() const noexcept\n+      {\n+\titerator __it = this->end();\n+\t--__it;\n+\treturn *__it;\n+      }\n+\n+      constexpr reference\n+      operator[](index_type __idx) const noexcept\n+      { return *(this->_M_ptr + __idx); }\n+\n+      constexpr pointer\n+      data() const noexcept\n+      { return this->_M_ptr; }\n+\n+      constexpr index_type\n+      size() const noexcept\n+      { return this->__base_t::_M_extent(); }\n+\n+      constexpr index_type\n+      size_bytes() const noexcept\n+      { return this->__base_t::_M_extent() * sizeof(element_type); }\n+\n+      constexpr bool\n+      empty() const noexcept\n+      { return size() == 0; }\n+\n+      // observers: iterator support\n+      constexpr iterator\n+      begin() const noexcept\n+      { return iterator(this->_M_ptr); }\n+\n+      constexpr const_iterator\n+      cbegin() const noexcept\n+      { return const_iterator(this->_M_ptr); }\n+\n+      constexpr iterator\n+      end() const noexcept\n+      { return iterator(this->_M_ptr + this->size()); }\n+\n+      constexpr const_iterator\n+      cend() const noexcept\n+      { return const_iterator(this->_M_ptr + this->size()); }\n+\n+      constexpr reverse_iterator\n+      rbegin() const noexcept\n+      { return reverse_iterator(this->end()); }\n+\n+      constexpr const_reverse_iterator\n+      crbegin() const noexcept\n+      { return const_reverse_iterator(this->cend()); }\n+\n+      constexpr reverse_iterator\n+      rend() const noexcept\n+      { return reverse_iterator(this->begin()); }\n+\n+      constexpr const_reverse_iterator\n+      crend() const noexcept\n+      { return const_reverse_iterator(this->cbegin()); }\n+\n+      // observers: subranges\n+      template<size_t _Count>\n+\tconstexpr span<element_type, _Count>\n+\tfirst() const\n+\t{\n+\t  __glibcxx_assert(_Count < size());\n+\t  return { this->data(), _Count };\n+\t}\n+\n+      constexpr span<element_type, dynamic_extent>\n+      first(index_type __count) const\n+      {\n+\t__glibcxx_assert(__count < size());\n+\treturn { this->data(), __count };\n+      }\n+\n+      template<size_t _Count>\n+\tconstexpr span<element_type, _Count>\n+\tlast() const\n+\t{\n+\t  static_assert(_Count == dynamic_extent ||\n+\t\t\t  _Extent == dynamic_extent || _Count <= _Extent,\n+\t    \"Count or Extent are dynamic, \"\n+\t    \"or the Count is less than the static extent\");\n+\t  __glibcxx_assert(_Count <= size());\n+\t  return { this->data() + (this->size() - _Count), _Count };\n+\t}\n+\n+      constexpr span<element_type, dynamic_extent>\n+      last(index_type __count) const\n+      {\n+\t__glibcxx_assert(__count < size());\n+\tindex_type __offset = (this->size() - __count);\n+\treturn { this->data() + __offset, __count };\n+      }\n+\n+      template<size_t _Offset, size_t _Count = dynamic_extent>\n+\tconstexpr auto\n+\tsubspan() const\n+\t{\n+\t  static_assert(_Count == dynamic_extent ||\n+\t\t\t  _Extent == dynamic_extent ||\n+\t\t\t  (_Offset + _Count) <= _Extent,\n+\t    \"Count or Extent are dynamic, \"\n+\t    \"or the Count + Offset is less than the static extent\");\n+\t  constexpr size_t __span_extent =\n+\t    (_Count != dynamic_extent\n+\t\t? _Count\n+\t\t: (_Extent != dynamic_extent ? _Extent - _Offset\n+\t\t\t\t\t\t    : dynamic_extent));\n+\t  using __span_t = span<element_type, __span_extent>;\n+\t  if constexpr(_Count != dynamic_extent)\n+\t    {\n+\t      __glibcxx_assert((_Offset + _Count) < size());\n+\t    }\n+\t  return __span_t(this->data() + _Offset,\n+\t    (_Count == dynamic_extent ? this->size() - _Offset : _Count));\n+\t}\n+\n+      constexpr span<element_type, dynamic_extent>\n+      subspan(index_type __offset, index_type __count = dynamic_extent) const\n+      {\n+\treturn {this->data() + __offset,\n+\t  __count == dynamic_extent ? this->size() - __offset : __count};\n+      }\n+\n+      // observers: range helpers\n+\n+      friend constexpr iterator\n+      begin(span __sp) noexcept\n+      { return __sp.begin(); }\n+\n+      friend constexpr iterator\n+      end(span __sp) noexcept\n+      { return __sp.end(); }\n+\n+    private:\n+      pointer _M_ptr;\n+    };\n+\n+  // deduction guides\n+  template<typename _Type, size_t _ArrayExtent>\n+    span(_Type(&)[_ArrayExtent])->span<_Type, _ArrayExtent>;\n+\n+  template<typename _Type, size_t _ArrayExtent>\n+    span(array<_Type, _ArrayExtent>&)->span<_Type, _ArrayExtent>;\n+\n+  template<typename _Type, size_t _ArrayExtent>\n+    span(const array<_Type, _ArrayExtent>&)\n+      ->span<const _Type, _ArrayExtent>;\n+\n+#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n+\n+  template<typename _ContiguousIterator, typename _Sentinel>\n+    span(_ContiguousIterator, _Sentinel)\n+      ->span<remove_reference_t<\n+\ttypename iterator_traits<_ContiguousIterator>::reference>>;\n+\n+  template<typename _Range>\n+    span(_Range &&)\n+      ->span<remove_reference_t<typename iterator_traits<decltype(\n+\t::std::__adl_begin(::std::declval<_Range&>()))>::reference>>;\n+\n+#else\n+\n+  template<typename _Container>\n+    span(_Container&)->span<typename _Container::value_type>;\n+\n+  template<typename _Container>\n+    span(const _Container&)->span<const typename _Container::value_type>;\n+\n+#endif // P1394\n+\n+  template<typename _Type, size_t _Extent>\n+    span<const byte, _Extent == dynamic_extent\n+\t? dynamic_extent : _Extent * sizeof(_Type)>\n+    inline as_bytes(span<_Type, _Extent> __sp) noexcept\n+    {\n+      return {reinterpret_cast<const byte*>(__sp.data()), __sp.size_bytes()};\n+    }\n+\n+  template<typename _Type, size_t _Extent>\n+    span<byte, _Extent == dynamic_extent\n+       ? dynamic_extent : _Extent * sizeof(_Type)>\n+    as_writable_bytes(span<_Type, _Extent> __sp) noexcept\n+    {\n+      return {reinterpret_cast<byte*>(__sp.data()), __sp.size_bytes()};\n+    }\n+\n+  // tuple helpers\n+  template<size_t _Index, typename _Type, size_t _Extent>\n+    constexpr _Type&\n+    get(span<_Type, _Extent> __sp) noexcept\n+    {\n+      static_assert(_Extent != dynamic_extent\n+\t&& (_Extent > 0) && (_Index < _Extent),\n+\t\"std::get can only be used with a span of non-dynamic (fixed) extent\");\n+      return __sp[_Index];\n+    }\n+\n+  template<typename _Type, size_t _Extent>\n+    struct tuple_size<span<_Type, _Extent>>\n+    : public integral_constant<size_t, _Extent>\n+    {\n+      static_assert(_Extent != dynamic_extent, \"tuple_size can only \"\n+\t\"be used with a span of non-dynamic (fixed) extent\");\n+    };\n+\n+  template<size_t _Index, typename _Type, size_t _Extent>\n+    struct tuple_element<_Index, span<_Type, _Extent>>\n+    {\n+      static_assert(_Extent != dynamic_extent, \"tuple_size can only \"\n+\t\"be used with a span of non-dynamic (fixed) extent\");\n+      static_assert(_Index < _Extent, \"Index is less than Extent\");\n+      using type = typename span<_Type, _Extent>::element_type;\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++20\n+#endif // _GLIBCXX_SPAN"}, {"sha": "4341c9f0c1ba35f5640d094c911bfd6941f3a81c", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -167,6 +167,9 @@\n #define __cpp_lib_list_remove_return_type 201806L\n #define __cpp_lib_math_constants 201907L\n #define __cpp_lib_to_array 201907L\n+// FIXME: they forgot this feature test macro\n+// get on someone's back about it in Belfast!!!\n+#define __cpp_lib_span 201911\n #endif // C++2a\n #endif // C++17\n #endif // C++14"}, {"sha": "475be1e900d3235a441884916cc9c025da8ae51c", "filename": "libstdc++-v3/testsuite/23_containers/span/contiguous_range_neg.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fcontiguous_range_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fcontiguous_range_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fcontiguous_range_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+#include <deque>\n+\n+int\n+main()\n+{\n+  std::deque<int> d{};\n+  std::span<int, std::dynamic_extent> myspan(d); // { dg-error \"no match\" }\n+}\n+\n+// { dg-prune-output \"data\" }\n+// { dg-prune-output \"invalid operands\" }"}, {"sha": "719015a871435f2b435ea897fcc4c0c0a95543e4", "filename": "libstdc++-v3/testsuite/23_containers/span/everything.cc", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Feverything.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Feverything.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Feverything.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,203 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <testsuite_hooks.h>\n+\n+#include <span>\n+#include <type_traits>\n+#include <cstdint>\n+#include <vector>\n+#include <algorithm>\n+#include <cassert>\n+\n+int\n+main()\n+{\n+  struct alignas(256) strawman\n+  {\n+    int x;\n+    int y;\n+    bool z;\n+    int w;\n+  };\n+\n+  struct naked_span\n+  {\n+    char* p;\n+    std::size_t n;\n+  };\n+\n+  struct strawman_span\n+  {\n+    strawman* p;\n+    std::size_t n;\n+  };\n+\n+  static_assert(sizeof(std::span<char, 0>) <= sizeof(char*));\n+  static_assert(sizeof(std::span<const char, 0>) <= sizeof(const char*));\n+  static_assert(sizeof(std::span<strawman, 0>) <= sizeof(strawman*));\n+  static_assert(sizeof(std::span<strawman, 1>) <= sizeof(strawman*));\n+  static_assert(sizeof(std::span<char>) <= sizeof(naked_span));\n+  static_assert(sizeof(std::span<strawman>) <= sizeof(strawman_span));\n+\n+  constexpr static std::array<int, 9> arr_data{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n+  constexpr auto arr_data_span = std::span(arr_data);\n+  static_assert(arr_data_span.size() == 9);\n+  static_assert(arr_data_span.size_bytes() == 9 * sizeof(int));\n+  static_assert(*arr_data_span.begin() == 0);\n+  static_assert(*arr_data_span.data() == 0);\n+  static_assert(arr_data_span.front() == 0);\n+  static_assert(arr_data_span.back() == 8);\n+  static_assert(arr_data_span[0] == 0);\n+  static_assert(arr_data_span[1] == 1);\n+  static_assert(arr_data_span[2] == 2);\n+  static_assert(arr_data_span[3] == 3);\n+  static_assert(arr_data_span[4] == 4);\n+  static_assert(arr_data_span[5] == 5);\n+  static_assert(arr_data_span[6] == 6);\n+  static_assert(arr_data_span[7] == 7);\n+  static_assert(arr_data_span[8] == 8);\n+  static_assert(!arr_data_span.empty());\n+  static_assert(decltype(arr_data_span)::extent == 9);\n+\n+  constexpr static int data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n+  constexpr auto data_span    = std::span(data);\n+  static_assert(data_span.size() == 9);\n+  static_assert(data_span.size_bytes() == 9 * sizeof(int));\n+  static_assert(*data_span.begin() == 0);\n+  static_assert(*data_span.data() == 0);\n+  static_assert(data_span.front() == 0);\n+  static_assert(data_span.back() == 8);\n+  static_assert(data_span[0] == 0);\n+  static_assert(data_span[1] == 1);\n+  static_assert(data_span[2] == 2);\n+  static_assert(data_span[3] == 3);\n+  static_assert(data_span[4] == 4);\n+  static_assert(data_span[5] == 5);\n+  static_assert(data_span[6] == 6);\n+  static_assert(data_span[7] == 7);\n+  static_assert(data_span[8] == 8);\n+  static_assert(!data_span.empty());\n+  static_assert(decltype(data_span)::extent == 9);\n+\n+  constexpr auto data_span_first = data_span.first<3>();\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_first)>, std::span<const int, 3>>);\n+  static_assert(decltype(data_span_first)::extent == 3);\n+  static_assert(data_span_first.size() == 3);\n+  static_assert(data_span_first.front() == 0);\n+  static_assert(data_span_first.back() == 2);\n+  static_assert(std::tuple_size_v<decltype(data_span_first)> == 3);\n+  static_assert(std::is_same_v<std::tuple_element_t<0, decltype(data_span_first)>, const int>);\n+\n+  constexpr auto data_span_first_dyn = data_span.first(4);\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_first_dyn)>, std::span<const int>>);\n+  static_assert(decltype(data_span_first_dyn)::extent == std::dynamic_extent);\n+  static_assert(data_span_first_dyn.size() == 4);\n+  static_assert(data_span_first_dyn.front() == 0);\n+  static_assert(data_span_first_dyn.back() == 3);\n+\n+  constexpr auto data_span_last = data_span.last<5>();\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_last)>, std::span<const int, 5>>);\n+  static_assert(decltype(data_span_last)::extent == 5);\n+  static_assert(data_span_last.size() == 5);\n+  static_assert(data_span_last.front() == 4);\n+  static_assert(data_span_last.back() == 8);\n+  static_assert(std::tuple_size_v<decltype(data_span_last)> == 5);\n+  static_assert(std::is_same_v<std::tuple_element_t<0, decltype(data_span_last)>, const int>);\n+\n+  constexpr auto data_span_last_dyn = data_span.last(6);\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_last_dyn)>, std::span<const int>>);\n+  static_assert(decltype(data_span_last_dyn)::extent == std::dynamic_extent);\n+  static_assert(data_span_last_dyn.size() == 6);\n+  static_assert(data_span_last_dyn.front() == 3);\n+  static_assert(data_span_last_dyn.back() == 8);\n+\n+  constexpr auto data_span_subspan = data_span.subspan<1, 3>();\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_subspan)>, std::span<const int, 3>>);\n+  static_assert(decltype(data_span_subspan)::extent == 3);\n+  static_assert(data_span_subspan.size() == 3);\n+  static_assert(data_span_subspan.front() == 1);\n+  static_assert(data_span_subspan.back() == 3);\n+\n+  constexpr auto data_span_subspan_offset = data_span.subspan<8>();\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_subspan_offset)>, std::span<const int, 1>>);\n+  static_assert(decltype(data_span_subspan_offset)::extent == 1);\n+  static_assert(data_span_subspan_offset.size() == 1);\n+  static_assert(data_span_subspan_offset.front() == 8);\n+  static_assert(data_span_subspan_offset.back() == 8);\n+\n+  constexpr auto data_span_subspan_empty = data_span.subspan(9, 0);\n+  static_assert(\n+    std::is_same_v<std::remove_cv_t<decltype(data_span_subspan_empty)>, std::span<const int>>);\n+  static_assert(decltype(data_span_subspan_empty)::extent == std::dynamic_extent);\n+  static_assert(data_span_subspan_empty.size() == 0);\n+\n+  constexpr auto data_span_subspan_empty_static = data_span.subspan<9>();\n+  static_assert(std::is_same_v<std::remove_cv_t<decltype(data_span_subspan_empty_static)>,\n+    std::span<const int, 0>>);\n+  static_assert(decltype(data_span_subspan_empty_static)::extent == 0);\n+  static_assert(data_span_subspan_empty.size() == 0);\n+\n+  std::span<short> shorts{};\n+  bool really_empty0 = shorts.empty();\n+  bool really_empty1 = std::empty(shorts);\n+  bool really_empty2 = shorts.data() == nullptr;\n+  bool really_empty3 = shorts.begin() == shorts.end();\n+  bool really_empty4 = shorts.cbegin() == shorts.cend();\n+  bool really_empty =\n+    really_empty0 && really_empty1 && really_empty2 && really_empty3 && really_empty4;\n+  (void)really_empty;\n+  VERIFY(really_empty);\n+\n+  std::vector<std::int_least32_t> value{ 0 };\n+  std::span<int32_t> muh_span(value);\n+  VERIFY(muh_span.size() == 1);\n+  std::byte* original_bytes                  = reinterpret_cast<std::byte*>(value.data());\n+  original_bytes[0]                          = static_cast<std::byte>(1);\n+  original_bytes[1]                          = static_cast<std::byte>(2);\n+  original_bytes[2]                          = static_cast<std::byte>(3);\n+  original_bytes[3]                          = static_cast<std::byte>(4);\n+  std::span<const std::byte> muh_byte_span   = std::as_bytes(muh_span);\n+  std::span<std::byte> muh_mutable_byte_span = std::as_writable_bytes(muh_span);\n+  std::span<std::byte> muh_original_byte_span(original_bytes, original_bytes + 4);\n+  bool definitely_reinterpret_casted0 = std::equal(muh_byte_span.cbegin(), muh_byte_span.cend(),\n+    muh_original_byte_span.cbegin(), muh_original_byte_span.cend());\n+  bool definitely_reinterpret_casted1 = std::equal(muh_mutable_byte_span.cbegin(),\n+    muh_mutable_byte_span.cend(), muh_original_byte_span.cbegin(), muh_original_byte_span.cend());\n+  bool definitely_reinterpret_casted =\n+    definitely_reinterpret_casted0 && definitely_reinterpret_casted1;\n+  (void)definitely_reinterpret_casted;\n+  VERIFY(definitely_reinterpret_casted);\n+\n+  std::span<std::byte> muh_original_byte_span_ptr_size(original_bytes, 4);\n+  bool definitely_equivalent =\n+    std::equal(muh_original_byte_span_ptr_size.cbegin(), muh_original_byte_span_ptr_size.cend(),\n+      muh_original_byte_span.cbegin(), muh_original_byte_span.cend());\n+  (void)definitely_equivalent;\n+  VERIFY(definitely_equivalent);\n+\n+  return definitely_equivalent && definitely_reinterpret_casted && really_empty ? 0 : 1;\n+}"}, {"sha": "37d188ed07375f919d0d9d28587083bfdfb530c1", "filename": "libstdc++-v3/testsuite/23_containers/span/get_neg.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fget_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fget_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fget_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+#include <tuple>\n+\n+int\n+main()\n+{\n+  std::span<int, std::dynamic_extent> myspan((int*)nullptr, 0ul);\n+  std::get<0>(myspan); // { dg-error \"here\" }\n+}\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "8f0145f7012cc7f4d08f7bc53043332930564bc6", "filename": "libstdc++-v3/testsuite/23_containers/span/last_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flast_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flast_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Flast_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,29 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+\n+int\n+main()\n+{\n+  std::span<int, 2> myspan(nullptr, 2);\n+  myspan.last<3>(); // { dg-error \"here\" }\n+}\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "5ecbff937cc0c4165a1a9bbbe4acc8b076c71223", "filename": "libstdc++-v3/testsuite/23_containers/span/subspan_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fsubspan_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fsubspan_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Fsubspan_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,29 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+\n+int\n+main()\n+{\n+  std::span<int, 2> myspan(nullptr, 2);\n+  myspan.subspan<3, 1>(); // { dg-error \"here\" }\n+}\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "cf8436099ce1e481e3b43225849be99ad8cf401e", "filename": "libstdc++-v3/testsuite/23_containers/span/tuple_element_dynamic_neg.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_dynamic_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_dynamic_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_dynamic_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,25 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+#include <tuple>\n+\n+std::tuple_element<0, std::span<int, std::dynamic_extent>> ts; // { dg-error \"here\" }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "bf97735cd554ee53bf7af4a494e137e0074946a2", "filename": "libstdc++-v3/testsuite/23_containers/span/tuple_element_oob_neg.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_oob_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_oob_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_element_oob_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,25 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+#include <tuple>\n+\n+std::tuple_element<3, std::span<int, 2>> te; // { dg-error \"here\" }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "99e95b3243a545580544457f2cad4677949d4d60", "filename": "libstdc++-v3/testsuite/23_containers/span/tuple_size_neg.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_size_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95e9a7616d363105a654f2108535f8121938bf04/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_size_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fspan%2Ftuple_size_neg.cc?ref=95e9a7616d363105a654f2108535f8121938bf04", "patch": "@@ -0,0 +1,25 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <span>\n+#include <tuple>\n+\n+std::tuple_size<std::span<int, std::dynamic_extent>> ts; // { dg-error \"here\" }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}]}