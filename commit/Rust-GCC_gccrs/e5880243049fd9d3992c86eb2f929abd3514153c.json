{"sha": "e5880243049fd9d3992c86eb2f929abd3514153c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU4ODAyNDMwNDlmZDlkMzk5MmM4NmViMmY5MjlhYmQzNTE0MTUzYw==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2010-05-05T18:53:23Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2010-05-05T18:53:23Z"}, "message": "re PR fortran/24978 (ICE in gfc_assign_data_value_range)\n\ngcc/fortran/:\n2010-05-05  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/24978\n\t* gfortran.h: Removed repeat count from constructor, removed\n\tall usages.\n\t* data.h (gfc_assign_data_value_range): Changed return value from\n\tvoid to gfc_try.\n\t* data.c (gfc_assign_data_value): Add location to constructor element.\n\t(gfc_assign_data_value_range): Call gfc_assign_data_value()\n\tfor each element in range. Return early if an error was generated.\n\t* resolve.c (check_data_variable): Stop early if range assignment\n\tgenerated an error.\n\ngcc/testsuite/:\n2010-05-05  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR fortran/24978\n\t* gfortran.dg/data_invalid.f90: New.\n\nFrom-SVN: r159076", "tree": {"sha": "24a5a6c449684bf4a2c0701c5f668e03bd7fa60f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a5a6c449684bf4a2c0701c5f668e03bd7fa60f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5880243049fd9d3992c86eb2f929abd3514153c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5880243049fd9d3992c86eb2f929abd3514153c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5880243049fd9d3992c86eb2f929abd3514153c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5880243049fd9d3992c86eb2f929abd3514153c/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b042919f71728bc26a8921738bdb0a1b3c680f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b042919f71728bc26a8921738bdb0a1b3c680f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b042919f71728bc26a8921738bdb0a1b3c680f0"}], "stats": {"total": 381, "additions": 176, "deletions": 205}, "files": [{"sha": "090a4315c0c265acae309f9935ce53054af24477", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -1,3 +1,16 @@\n+2010-05-05  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/24978\n+\t* gfortran.h: Removed repeat count from constructor, removed\n+\tall usages.\n+\t* data.h (gfc_assign_data_value_range): Changed return value from\n+\tvoid to gfc_try.\n+\t* data.c (gfc_assign_data_value): Add location to constructor element.\n+\t(gfc_assign_data_value_range): Call gfc_assign_data_value()\n+\tfor each element in range. Return early if an error was generated.\n+\t* resolve.c (check_data_variable): Stop early if range assignment\n+\tgenerated an error.\n+\n 2010-05-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/43696"}, {"sha": "3ffc39714da05b03c6fb5dd2e7a76bfbbbaf92ed", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -1266,7 +1266,6 @@ typedef struct\n \n   mpz_t *offset;\n   gfc_component *component;\n-  mpz_t *repeat;\n \n   gfc_try (*expand_work_function) (gfc_expr *);\n }\n@@ -1501,7 +1500,6 @@ expand_constructor (gfc_constructor_base base)\n \t  return FAILURE;\n \t}\n       current_expand.offset = &c->offset;\n-      current_expand.repeat = &c->repeat;\n       current_expand.component = c->n.component;\n       if (current_expand.expand_work_function (e) == FAILURE)\n \treturn FAILURE;"}, {"sha": "45228b0c47cfa53a79549dc3536406f440c8d56b", "filename": "gcc/fortran/constructor.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fconstructor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fconstructor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.c?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -36,7 +36,6 @@ node_free (splay_tree_value value)\n     gfc_free_iterator (c->iterator, 1);\n \n   mpz_clear (c->offset);\n-  mpz_clear (c->repeat);\n \n   gfc_free (c);\n }\n@@ -55,7 +54,6 @@ node_copy (splay_tree_node node, void *base)\n   c->n.component = src->n.component;\n \n   mpz_init_set (c->offset, src->offset);\n-  mpz_init_set (c->repeat, src->repeat);\n \n   return c;\n }\n@@ -80,7 +78,6 @@ gfc_constructor_get (void)\n   c->iterator = NULL;\n \n   mpz_init_set_si (c->offset, 0);\n-  mpz_init_set_si (c->repeat, 0);\n \n   return c;\n }\n@@ -172,7 +169,6 @@ gfc_constructor_insert_expr (gfc_constructor_base *base,\n gfc_constructor *\n gfc_constructor_lookup (gfc_constructor_base base, int offset)\n {\n-  gfc_constructor *c;\n   splay_tree_node node;\n \n   if (!base)\n@@ -182,22 +178,7 @@ gfc_constructor_lookup (gfc_constructor_base base, int offset)\n   if (node)\n     return (gfc_constructor*) node->value;\n \n-  /* Check if the previous node has a repeat count big enough to\n-     cover the offset looked for.  */\n-  node = splay_tree_predecessor (base, offset);\n-  if (!node)\n-    return NULL;\n-\n-  c = (gfc_constructor*) node->value;\n-  if (mpz_cmp_si (c->repeat, 1) > 0)\n-    {\n-      if (mpz_get_si (c->offset) + mpz_get_si (c->repeat) <= offset)\n-\tc = NULL;\n-    }\n-  else\n-    c = NULL;\n-\n-  return c;\n+  return NULL;\n }\n \n "}, {"sha": "c217e1cab0ec09c229bf0912743845fbb9f16af1", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 26, "deletions": 138, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -288,7 +288,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t  if (!con)\n \t    {\n \t      con = gfc_constructor_insert_expr (&expr->value.constructor,\n-\t\t\t\t\t\t NULL, NULL,\n+\t\t\t\t\t\t NULL, &rvalue->where,\n \t\t\t\t\t\t mpz_get_si (offset));\n \t    }\n \t  break;\n@@ -352,8 +352,10 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t  expr = (LOCATION_LINE (init->where.lb->location)\n \t\t  > LOCATION_LINE (rvalue->where.lb->location))\n \t       ? init : rvalue;\n-\t  gfc_notify_std (GFC_STD_GNU, \"Extension: re-initialization \"\n-\t\t\t  \"of '%s' at %L\", symbol->name, &expr->where);\n+\t  if (gfc_notify_std (GFC_STD_GNU,\"Extension: \"\n+\t\t\t      \"re-initialization of '%s' at %L\",\n+\t\t\t      symbol->name, &expr->where) == FAILURE)\n+\t    return FAILURE;\n \t}\n \n       expr = gfc_copy_expr (rvalue);\n@@ -371,149 +373,35 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \n \n /* Similarly, but initialize REPEAT consecutive values in LVALUE the same\n-   value in RVALUE.  For the nonce, LVALUE must refer to a full array, not\n-   an array section.  */\n+   value in RVALUE.  */\n \n-void\n+gfc_try\n gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n \t\t\t     mpz_t index, mpz_t repeat)\n {\n-  gfc_ref *ref;\n-  gfc_expr *init, *expr;\n-  gfc_constructor *con, *last_con;\n-  gfc_symbol *symbol;\n-  gfc_typespec *last_ts;\n-  mpz_t offset;\n-\n-  symbol = lvalue->symtree->n.sym;\n-  init = symbol->value;\n-  last_ts = &symbol->ts;\n-  last_con = NULL;\n-  mpz_init_set_si (offset, 0);\n-\n-  /* Find/create the parent expressions for subobject references.  */\n-  for (ref = lvalue->ref; ref; ref = ref->next)\n-    {\n-      /* Use the existing initializer expression if it exists.\n-\t Otherwise create a new one.  */\n-      if (init == NULL)\n-\texpr = gfc_get_expr ();\n-      else\n-\texpr = init;\n-\n-      /* Find or create this element.  */\n-      switch (ref->type)\n-\t{\n-\tcase REF_ARRAY:\n-\t  if (init == NULL)\n-\t    {\n-\t      /* The element typespec will be the same as the array\n-\t\t typespec.  */\n-\t      expr->ts = *last_ts;\n-\t      /* Setup the expression to hold the constructor.  */\n-\t      expr->expr_type = EXPR_ARRAY;\n-\t      expr->rank = ref->u.ar.as->rank;\n-\t    }\n-\t  else\n-\t    gcc_assert (expr->expr_type == EXPR_ARRAY);\n-\n-\t  if (ref->u.ar.type == AR_ELEMENT)\n-\t    {\n-\t      get_array_index (&ref->u.ar, &offset);\n-\n-\t      /* This had better not be the bottom of the reference.\n-\t\t We can still get to a full array via a component.  */\n-\t      gcc_assert (ref->next != NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      mpz_set (offset, index);\n-\n-\t      /* We're at a full array or an array section.  This means\n-\t\t that we've better have found a full array, and that we're\n-\t\t at the bottom of the reference.  */\n-\t      gcc_assert (ref->u.ar.type == AR_FULL);\n-\t      gcc_assert (ref->next == NULL);\n-\t    }\n-\n-\t  con = gfc_constructor_lookup (expr->value.constructor,\n-\t\t\t\t\tmpz_get_si (offset));\n-\t  if (con == NULL)\n-\t    {\n-\t      con = gfc_constructor_insert_expr (&expr->value.constructor,\n-\t\t\t\t\t\t NULL, NULL,\n-\t\t\t\t\t\t mpz_get_si (offset));\n-\t      if (ref->next == NULL)\n-\t\tmpz_set (con->repeat, repeat);\n-\t    }\n-\t  else\n-\t    gcc_assert (ref->next != NULL);\n-\t  break;\n-\n-\tcase REF_COMPONENT:\n-\t  if (init == NULL)\n-\t    {\n-\t      /* Setup the expression to hold the constructor.  */\n-\t      expr->expr_type = EXPR_STRUCTURE;\n-\t      expr->ts.type = BT_DERIVED;\n-\t      expr->ts.u.derived = ref->u.c.sym;\n-\t    }\n-\t  else\n-\t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n-\t  last_ts = &ref->u.c.component->ts;\n-\n-  \t  /* Find the same element in the existing constructor.  */\n-\t  con = find_con_by_component (ref->u.c.component,\n-\t\t\t\t       expr->value.constructor);\n-\n-\t  if (con == NULL)\n-\t    {\n-\t      /* Create a new constructor.  */\n-\t      con = gfc_constructor_append_expr (&expr->value.constructor,\n-\t\t\t\t\t\t NULL, NULL);\n-\t      con->n.component = ref->u.c.component;\n-\t    }\n-\n-\t  /* Since we're only intending to initialize arrays here,\n-\t     there better be an inner reference.  */\n-\t  gcc_assert (ref->next != NULL);\n-\t  break;\n-\n-\tcase REF_SUBSTRING:\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      if (init == NULL)\n-\t{\n-\t  /* Point the container at the new expression.  */\n-\t  if (last_con == NULL)\n-\t    symbol->value = expr;\n-\t  else\n-\t    last_con->expr = expr;\n-\t}\n-      init = con->expr;\n-      last_con = con;\n-    }\n+  mpz_t offset, last_offset;\n+  gfc_try t;\n+\n+  mpz_init (offset);\n+  mpz_init (last_offset);\n+  mpz_add (last_offset, index, repeat);\n+\n+  t = SUCCESS;\n+  for (mpz_set(offset, index) ; mpz_cmp(offset, last_offset) < 0;\n+\t\t   mpz_add_ui (offset, offset, 1))\n+    if (gfc_assign_data_value (lvalue, rvalue, offset) == FAILURE)\n+      {\n+\tt = FAILURE;\n+\tbreak;\n+      }\n \n-  if (last_ts->type == BT_CHARACTER)\n-    expr = create_character_intializer (init, last_ts, NULL, rvalue);\n-  else\n-    {\n-      /* We should never be overwriting an existing initializer.  */\n-      gcc_assert (!init);\n+  mpz_clear (offset);\n+  mpz_clear (last_offset);\n \n-      expr = gfc_copy_expr (rvalue);\n-      if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n-\tgfc_convert_type (expr, &lvalue->ts, 0);\n-    }\n-\n-  if (last_con == NULL)\n-    symbol->value = expr;\n-  else\n-    last_con->expr = expr;\n+  return t;\n }\n \n+\n /* Modify the index of array section and re-calculate the array offset.  */\n \n void "}, {"sha": "c54c75de9c0b089eae4e18497271e3a83bd84eec", "filename": "gcc/fortran/data.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.h?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -20,5 +20,5 @@ along with GCC; see the file COPYING3.  If not see\n void gfc_formalize_init_value (gfc_symbol *);\n void gfc_get_section_index (gfc_array_ref *, mpz_t *, mpz_t *);\n gfc_try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t);\n-void gfc_assign_data_value_range (gfc_expr *, gfc_expr *, mpz_t, mpz_t);\n+gfc_try gfc_assign_data_value_range (gfc_expr *, gfc_expr *, mpz_t, mpz_t);\n void gfc_advance_section (mpz_t *, gfc_array_ref *, mpz_t *);"}, {"sha": "827a13f4dc29d4c2aa3754d2f42ed3b0f47ce03f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -2187,8 +2187,6 @@ typedef struct gfc_constructor\n      gfc_component *component; /* Record the component being initialized.  */\n   }\n   n;\n-  mpz_t repeat; /* Record the repeat number of initial values in data\n-                  statement like \"data a/5*10/\".  */\n }\n gfc_constructor;\n "}, {"sha": "2c79863a718b12569c7da6fa6c26354cc685eb69", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -11781,11 +11781,14 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \t      mpz_set_ui (size, 0);\n \t    }\n \n-\t  gfc_assign_data_value_range (var->expr, values.vnode->expr,\n-\t\t\t\t       offset, range);\n+\t  t = gfc_assign_data_value_range (var->expr, values.vnode->expr,\n+\t\t\t\t\t   offset, range);\n \n \t  mpz_add (offset, offset, range);\n \t  mpz_clear (range);\n+\n+\t  if (t == FAILURE)\n+\t    break;\n \t}\n \n       /* Assign initial value to symbol.  */"}, {"sha": "8ece64327af342ba9e5e6ea17bf0880c55120fc9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -4133,11 +4133,10 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n {\n   gfc_constructor *c;\n   tree tmp;\n-  mpz_t maxval;\n   gfc_se se;\n   HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT lo;\n-  tree index, range;\n+  tree index;\n   VEC(constructor_elt,gc) *v = NULL;\n \n   switch (expr->expr_type)\n@@ -4190,42 +4189,13 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n             index = gfc_conv_mpz_to_tree (c->offset, gfc_index_integer_kind);\n           else\n             index = NULL_TREE;\n-\t  mpz_init (maxval);\n-          if (mpz_cmp_si (c->repeat, 0) != 0)\n-            {\n-              tree tmp1, tmp2;\n-\n-              mpz_set (maxval, c->repeat);\n-              mpz_add (maxval, c->offset, maxval);\n-              mpz_sub_ui (maxval, maxval, 1);\n-              tmp2 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n-              if (mpz_cmp_si (c->offset, 0) != 0)\n-                {\n-                  mpz_add_ui (maxval, c->offset, 1);\n-                  tmp1 = gfc_conv_mpz_to_tree (maxval, gfc_index_integer_kind);\n-                }\n-              else\n-                tmp1 = gfc_conv_mpz_to_tree (c->offset, gfc_index_integer_kind);\n-\n-              range = fold_build2 (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n-            }\n-          else\n-            range = NULL;\n-\t  mpz_clear (maxval);\n \n           gfc_init_se (&se, NULL);\n \t  switch (c->expr->expr_type)\n \t    {\n \t    case EXPR_CONSTANT:\n \t      gfc_conv_constant (&se, c->expr);\n-              if (range == NULL_TREE)\n-\t\tCONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n-              else\n-                {\n-                  if (index != NULL_TREE)\n-\t\t    CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n-\t\t  CONSTRUCTOR_APPEND_ELT (v, range, se.expr);\n-                }\n+\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \n \t    case EXPR_STRUCTURE:\n@@ -4239,14 +4209,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \t\t for one reason or another, assuming that if they are\n \t\t standard defying the frontend will catch them.  */\n \t      gfc_conv_expr (&se, c->expr);\n-\t      if (range == NULL_TREE)\n-\t\tCONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n-\t      else\n-\t\t{\n-\t\t  if (index != NULL_TREE)\n-\t\t  CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n-\t\t  CONSTRUCTOR_APPEND_ELT (v, range, se.expr);\n-\t\t}\n+\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \t    }\n         }"}, {"sha": "3ff322094b3107d773b4723b232b2ba002a75180", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -1,3 +1,8 @@\n+2010-05-05  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/24978\n+\t* gfortran.dg/data_invalid.f90: New.\n+\n 2010-05-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/lto2.adb: New test."}, {"sha": "10ea7e57c0819505c376a2e693d039946e88422c", "filename": "gcc/testsuite/gfortran.dg/data_invalid.f90", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_invalid.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5880243049fd9d3992c86eb2f929abd3514153c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_invalid.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_invalid.f90?ref=e5880243049fd9d3992c86eb2f929abd3514153c", "patch": "@@ -0,0 +1,122 @@\n+! { dg-do \"compile\" }\n+! { dg-options \"-std=f95 -fmax-errors=0\" }\n+!\n+! Testcases from PR fortran/24978\n+!\n+\n+SUBROUTINE data_init_scalar_invalid()\n+  integer :: a\n+  data       a / 1 /\n+  data       a / 1 /                             ! { dg-error \"re-initialization\" }\n+\n+  integer :: b = 0\n+  data       b / 1 /                             ! { dg-error \"re-initialization\" }\n+END SUBROUTINE\n+\n+SUBROUTINE data_init_array_invalid()\n+  ! initialize (at least) one element, re-initialize full array\n+  integer :: a(3)\n+  data       a(2) / 2 /\n+  data       a    / 3*1 /                        ! { dg-error \"re-initialization\" }\n+\n+  ! initialize (at least) one element, re-initialize subsection including the element\n+  integer :: b(3)\n+  data       b(2)   / 2 /\n+  data       b(1:2) / 2*1 /                      ! { dg-error \"re-initialization\" }\n+\n+  ! initialize subsection, re-initialize (intersecting) subsection\n+  integer :: c(3)\n+  data       c(1:2) / 2*1 /\n+  data       c(2:3) / 1,1 /                      ! { dg-error \"re-initialization\" }\n+\n+  ! initialize subsection, re-initialize full array\n+  integer :: d(3)\n+  data       d(2:3) / 2*1 /\n+  data       d      / 2*2, 3 /                   ! { dg-error \"re-initialization\" }\n+\n+  ! full array initializer, re-initialize (at least) one element\n+  integer :: e(3)\n+  data       e    / 3*1 /\n+  data       e(2) / 2 /                          ! { dg-error \"re-initialization\" }\n+\n+  integer :: f(3) = 0                            ! { dg-error \"already is initialized\" }\n+  data       f(2) / 1 /\n+\n+  ! full array initializer, re-initialize subsection\n+  integer :: g(3)\n+  data       g      / 3*1 /\n+  data       g(1:2) / 2*2 /                      ! { dg-error \"re-initialization\" }\n+\n+  integer :: h(3) = 1                            ! { dg-error \"already is initialized\" }\n+  data       h(2:3) / 2*2 /\n+\n+  ! full array initializer, re-initialize full array\n+  integer :: i(3)\n+  data       i   / 3*1 /\n+  data       i   / 2,2,2 /                       ! { dg-error \"re-initialization\" }\n+\n+  integer :: j(3) = 1                            ! { dg-error \"already is initialized\" }\n+  data       j   / 3*2 /\n+END SUBROUTINE\n+\n+SUBROUTINE data_init_matrix_invalid()\n+  ! initialize (at least) one element, re-initialize full matrix\n+  integer :: a(3,3)\n+  data       a(2,2) / 1 /\n+  data       a      / 9*2 /                      ! { dg-error \"re-initialization\" }\n+\n+  ! initialize (at least) one element, re-initialize subsection\n+  integer :: b(3,3)\n+  data       b(2,2) / 1 /\n+  data       b(2,:) / 3*2 /                      ! { dg-error \"re-initialization\" }\n+\n+  ! initialize subsection, re-initialize (intersecting) subsection\n+  integer :: c(3,3)\n+  data       c(3,:) / 3*1 /, c(:,3) / 3*2 /      ! { dg-error \"re-initialization\" }\n+\n+  ! initialize subsection, re-initialize full array\n+  integer :: d(3,3)\n+  data       d(2,:) / 1,2,3 /\n+  data       d      / 9*4 /                      ! { dg-error \"re-initialization\" }\n+\n+  ! full array initializer, re-initialize (at least) one element\n+  integer :: e(3,3)\n+  data       e      / 9*1 /\n+  data       e(2,3) / 2 /                        ! { dg-error \"re-initialization\" }\n+\n+  integer :: f(3,3) = 1                          ! { dg-error \"already is initialized\" }\n+  data       f(3,2) / 2 /\n+\n+  ! full array initializer, re-initialize subsection\n+  integer :: g(3,3)\n+  data       g          / 9 * 1 /\n+  data       g(2:3,2:3) / 2, 2*3, 4 /            ! { dg-error \"re-initialization\" }\n+\n+  integer :: h(3,3) = 1                          ! { dg-error \"already is initialized\" }\n+  data       h(2:3,2:3) / 2, 2*3, 4 /\n+\n+  ! full array initializer, re-initialize full array\n+  integer :: i(3,3)\n+  data       i   / 3*1, 3*2, 3*3 /\n+  data       i   / 9 * 1 /                       ! { dg-error \"re-initialization\" }\n+\n+  integer :: j(3,3) = 0                          ! { dg-error \"already is initialized\" }\n+  data       j   / 9 * 1 /\n+END SUBROUTINE\n+\n+SUBROUTINE data_init_misc_invalid()\n+  ! wrong number of dimensions\n+  integer :: a(3)\n+  data       a(1,1) / 1 /                        ! { dg-error \"Rank mismatch\" }\n+\n+  ! index out-of-bounds, direct access\n+  integer :: b(3)\n+  data       b(-2) / 1 /                         ! { dg-error \"below array lower bound\" }\n+\n+  ! index out-of-bounds, implied do-loop (PR32315)\n+  integer :: i\n+  character(len=20), dimension(4) :: string\n+  data (string(i), i = 1, 5) / 'A', 'B', 'C', 'D', 'E' /   ! { dg-error \"above array upper bound\" }\n+END SUBROUTINE\n+\n+! { dg-excess-errors \"\" }"}]}