{"sha": "27dada7d06926cc7ef6293fbbf0629f523b49e48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdkYWRhN2QwNjkyNmNjN2VmNjI5M2ZiYmYwNjI5ZjUyM2I0OWU0OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-09-09T11:12:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-09-09T11:12:38Z"}, "message": "Improve constraints for std::span constructors\n\nThis patch simplifies the constraints on the constructors from arrays by\nremoving the redundant checks that element_type and value_type are\nconvertible to element_type. The incorrect uses of __adl_data in those\nconstructors are removed as well (they should use std::data not\nstd::ranges::data, and the former doesn't use ADL).\n\nThe range/container constructors are now constrained to exclude all\nspecializations of std::span, not just the current instantiation. The\nrange constructor now also checks s subset of the contiguous_range\nrequirements.\n\nAll relevant constructor constraints now use the _Require helper in\norder to short circuit and avoid unnecessary instantiations after the\nfirst failed constraint.\n\nA new constructor supports initialization from different specializations\nof std::span<OtherType, OtherExtent>, as specified in the C++20 draft.\n\n\t* include/bits/range_access.h (__adl_to_address): Remove.\n\t* include/std/span (__is_base_derived_safe_convertible_v): Replace\n\twith span::__is_compatible.\n\t(__is_std_array_v): Replace with __is_std_array class template and\n\tpartial specializations.\n\t(__is_std_array, __is_std_span): New class templates and partial\n\tspecializations.\n\t(span::__is_compatible): New alias template for SFINAE constraints.\n\t(span::span(element_type (&)[N])): Remove redundant constraints. Do\n\tnot use __adl_data to obtain a pointer.\n\t(span::span(array<value_type, N>&)): Likewise.\n\t(span::span(const array<value_type, N>&)): Likewise.\n\t[_GLIBCXX_P1394] (span::iter_reference_t, span::iterator_t)\n\t(span::iter_value_t, span::derived_from): New alias templates for\n\tSFINAE constraints, until the equivalents are supported in <concepts>\n\tand <iterator>.\n\t[_GLIBCXX_P1394] (span::__is_compatible_iterator): New alias template\n\tfor SFINAE constraints.\n\t[_GLIBCXX_P1394] (span::is_compatible_range): New class template for\n\tSFINAE constraints.\n\t[_GLIBCXX_P1394] (span::span(Range&&)): Improve constraints.\n\t[_GLIBCXX_P1394] (span::span(ContiguousIterator, Sentinel)): Likewise.\n\tUse std::to_address instead of __adl_to_address.\n\t[_GLIBCXX_P1394] (span::span(ContiguousIterator, size_type)): Likewise.\n\t[!_GLIBCXX_P1394] (span::__is_compatible_container): New alias\n\ttemplate for SFINAE constraints.\n\t[!_GLIBCXX_P1394] (span::span(Container&))\n\t(span::span(const Container&)): Improve constraints.\n\t[!_GLIBCXX_P1394] (span::span(pointer, size_type))\n\t(span::span(pointer, pointer)): Remove redundant cast of pointer.\n\t(span(const span<OType, OExtent>&)): New constructor.\n\nFrom-SVN: r275513", "tree": {"sha": "e3d6a047ad28871046ab9b7279b472cfedd58a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3d6a047ad28871046ab9b7279b472cfedd58a7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27dada7d06926cc7ef6293fbbf0629f523b49e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27dada7d06926cc7ef6293fbbf0629f523b49e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27dada7d06926cc7ef6293fbbf0629f523b49e48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27dada7d06926cc7ef6293fbbf0629f523b49e48/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca47c3987c09df50cd9504652e4a8f6f8656bf94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca47c3987c09df50cd9504652e4a8f6f8656bf94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca47c3987c09df50cd9504652e4a8f6f8656bf94"}], "stats": {"total": 255, "additions": 155, "deletions": 100}, "files": [{"sha": "0aff148effb20820a981c008367e64c0d8c055f7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=27dada7d06926cc7ef6293fbbf0629f523b49e48", "patch": "@@ -1,3 +1,37 @@\n+2019-09-09  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/range_access.h (__adl_to_address): Remove.\n+\t* include/std/span (__is_base_derived_safe_convertible_v): Replace\n+\twith span::__is_compatible.\n+\t(__is_std_array_v): Replace with __is_std_array class template and\n+\tpartial specializations.\n+\t(__is_std_array, __is_std_span): New class templates and partial\n+\tspecializations.\n+\t(span::__is_compatible): New alias template for SFINAE constraints.\n+\t(span::span(element_type (&)[N])): Remove redundant constraints. Do\n+\tnot use __adl_data to obtain a pointer.\n+\t(span::span(array<value_type, N>&)): Likewise.\n+\t(span::span(const array<value_type, N>&)): Likewise.\n+\t[_GLIBCXX_P1394] (span::iter_reference_t, span::iterator_t)\n+\t(span::iter_value_t, span::derived_from): New alias templates for\n+\tSFINAE constraints, until the equivalents are supported in <concepts>\n+\tand <iterator>.\n+\t[_GLIBCXX_P1394] (span::__is_compatible_iterator): New alias template\n+\tfor SFINAE constraints.\n+\t[_GLIBCXX_P1394] (span::is_compatible_range): New class template for\n+\tSFINAE constraints.\n+\t[_GLIBCXX_P1394] (span::span(Range&&)): Improve constraints.\n+\t[_GLIBCXX_P1394] (span::span(ContiguousIterator, Sentinel)): Likewise.\n+\tUse std::to_address instead of __adl_to_address.\n+\t[_GLIBCXX_P1394] (span::span(ContiguousIterator, size_type)): Likewise.\n+\t[!_GLIBCXX_P1394] (span::__is_compatible_container): New alias\n+\ttemplate for SFINAE constraints.\n+\t[!_GLIBCXX_P1394] (span::span(Container&))\n+\t(span::span(const Container&)): Improve constraints.\n+\t[!_GLIBCXX_P1394] (span::span(pointer, size_type))\n+\t(span::span(pointer, pointer)): Remove redundant cast of pointer.\n+\t(span(const span<OType, OExtent>&)): New constructor.\n+\n 2019-09-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/range_access.h (ssize): Define for C++20."}, {"sha": "bc137d7396eea57ea2d907f9695ed41c67979fc5", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=27dada7d06926cc7ef6293fbbf0629f523b49e48", "patch": "@@ -396,13 +396,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr auto\n     __adl_empty(_Container& __cont) noexcept(noexcept(empty(__cont)))\n     { return empty(__cont); }\n-\n-#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n-  template <typename _Container>\n-    constexpr auto\n-    __adl_to_address(_Container& __cont) noexcept(noexcept(to_address(__cont)))\n-    { return to_address(__cont); }\n-#endif // P1394 and new contiguous_iterator requirements [iterator.concept.contiguous]\n #endif // C++20\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "1a0d61c194772e3e9ced0137efe0605afca10ff4", "filename": "libstdc++-v3/include/std/span", "status": "modified", "additions": 121, "deletions": 93, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dada7d06926cc7ef6293fbbf0629f523b49e48/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan?ref=27dada7d06926cc7ef6293fbbf0629f523b49e48", "patch": "@@ -53,24 +53,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);\n \n+  template<typename _Type, size_t _Extent>\n+    class span;\n+\n   namespace __detail\n   {\n-    template<typename _Element, typename _ToElement>\n-      static constexpr inline bool __is_base_derived_safe_convertible_v\n-\t= is_convertible_v<_Element (*)[], _ToElement (*)[]>;\n+    template<typename _Tp>\n+      struct __is_std_span : false_type { };\n+\n+    template<typename _Tp, size_t _Num>\n+      struct __is_std_span<span<_Tp, _Num>> : true_type { };\n \n     template<typename _Tp>\n-      inline constexpr bool __is_std_array_v = false;\n+      struct __is_std_array : false_type { };\n \n     template<typename _Tp, size_t _Num>\n-      inline constexpr bool\n-      __is_std_array_v<_GLIBCXX_STD_C::array<_Tp, _Num>> = true;\n+      struct __is_std_array<_GLIBCXX_STD_C::array<_Tp, _Num>> : true_type { };\n \n #ifdef _GLIBCXX_DEBUG\n     template<typename _Tp, size_t _Num>\n-      inline constexpr bool\n-      __is_std_array_v<std::__debug::array<_Tp, _Num>> = true;\n-#endif // debug/array\n+      struct __is_std_array<__debug::array<_Tp, _Num>> : true_type { };\n+#endif\n \n     template<size_t _Extent>\n       class __extent_storage\n@@ -119,6 +122,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return dynamic_extent;\n \t}\n \n+      template<typename _Tp>\n+\tusing __is_compatible = is_convertible<_Tp(*)[], _Type(*)[]>;\n+\n     public:\n       // member types\n       using value_type             = remove_cv_t<_Type>;\n@@ -154,41 +160,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       span(const span&) noexcept = default;\n \n       template<size_t _ArrayExtent,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(::std::__adl_data(\n-\t      ::std::declval<element_type (&)[_ArrayExtent]>()))>,\n-\t    element_type>>* = nullptr>\n-\tconstexpr span(element_type (&__arr)[_ArrayExtent])\n-\tnoexcept(noexcept(::std::__adl_data(__arr)))\n-\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\tenable_if_t<_Extent == dynamic_extent || _ArrayExtent == _Extent>*\n+\t  = nullptr>\n+\tconstexpr\n+\tspan(element_type (&__arr)[_ArrayExtent]) noexcept\n+\t: span(static_cast<pointer>(__arr), _ArrayExtent)\n \t{ }\n \n       template<size_t _ArrayExtent,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(::std::__adl_data(\n-\t      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,\n-\t    element_type>>* = nullptr>\n+\tenable_if_t<_Extent == dynamic_extent || _ArrayExtent == _Extent>*\n+\t  = nullptr>\n \tconstexpr\n-\tspan(array<value_type, _ArrayExtent>& __arr)\n-\tnoexcept(noexcept(::std::__adl_data(__arr)))\n-\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\tspan(array<value_type, _ArrayExtent>& __arr) noexcept\n+\t: span(__arr.data(), _ArrayExtent)\n \t{ }\n \n       template<size_t _ArrayExtent,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent || _ArrayExtent == _Extent)\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(::std::__adl_data(\n-\t      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,\n-\t    element_type>>* = nullptr>\n+\tenable_if_t<_Extent == dynamic_extent || _ArrayExtent == _Extent>*\n+\t  = nullptr>\n \tconstexpr\n-\tspan(const array<value_type, _ArrayExtent>& __arr)\n-\tnoexcept(noexcept(::std::__adl_data(__arr)))\n-\t: span(::std::__adl_data(__arr), _ArrayExtent)\n+\tspan(const array<value_type, _ArrayExtent>& __arr) noexcept\n+\t: span(__arr.data(), _ArrayExtent)\n \t{ }\n \n       // NOTE: when the time comes, and P1394 -\n@@ -199,91 +191,127 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // and keep the crappy #else block\n       // and then cry that NB comments failed C++20...\n       // but maybe for C++23?\n-#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n-      template<typename _Range,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent)\n-\t  && !is_same_v<remove_cvref_t<_Range>, span>\n-\t  && !__detail::__is_std_array_v<remove_cvref_t<_Range>>\n-\t  && !is_array_v<remove_cvref_t<_Range>>\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(\n-\t      ::std::__adl_data(::std::declval<_Range&>())\n-\t      + ::std::__adl_size(::std::declval<_Range&>()))>,\n-\t    element_type>>* = nullptr>\n+#ifdef _GLIBCXX_P1394\n+    private:\n+      // FIXME: use std::iter_reference_t\n+      template<typename _Iterator>\n+\tusing iter_reference_t = decltype(*std::declval<_Iterator&>());\n+      // FIXME: use std::ranges::iterator_t\n+      // N.B. constraint is needed to prevent a cycle when __adl_begin finds\n+      // begin(span) which does overload resolution on span(Range&&).\n+      template<typename _Rng,\n+\t       typename _Rng2 = remove_cvref_t<_Rng>,\n+\t       typename = enable_if_t<!__detail::__is_std_span<_Rng2>::value>>\n+\tusing iterator_t = decltype(std::__adl_begin(std::declval<_Rng&>()));\n+      // FIXME: use std::iter_value_t\n+      template<typename _Iter>\n+\tusing iter_value_t = typename iterator_traits<_Iter>::value_type;\n+      // FIXME: use std::derived_from concept\n+      template<typename _Derived, typename _Base>\n+\tusing derived_from\n+\t  = __and_<is_base_of<_Base, _Derived>,\n+\t      is_convertible<const volatile _Derived*, const volatile _Base*>>;\n+      // FIXME: require contiguous_iterator<_Iterator>\n+      template<typename _Iter,\n+\t       typename _Ref = iter_reference_t<_Iter>,\n+\t       typename _Traits = iterator_traits<_Iter>,\n+\t       typename _Tag = typename _Traits::iterator_category>\n+\tusing __is_compatible_iterator\n+\t  = __and_<derived_from<_Tag, random_access_iterator_tag>,\n+\t\t   is_lvalue_reference<_Ref>,\n+\t\t   is_same<iter_value_t<_Iter>, remove_cvref_t<_Ref>>,\n+\t\t   __is_compatible<remove_reference_t<_Ref>>>;\n+\n+      template<typename _Range>\n+\tusing __is_compatible_range\n+\t  = __is_compatible_iterator<iterator_t<_Range>>;\n+\n+    public:\n+      template<typename _Range, typename = _Require<\n+\t  bool_constant<_Extent == dynamic_extent>,\n+\t  __not_<__detail::__is_std_span<remove_cvref_t<_Range>>>,\n+\t  __not_<__detail::__is_std_array<remove_cvref_t<_Range>>>,\n+\t  __not_<is_array<remove_reference_t<_Range>>>,\n+\t  __is_compatible_range<_Range>>,\n+\t  typename = decltype(std::__adl_data(std::declval<_Range&>()))>\n \tconstexpr\n \tspan(_Range&& __range)\n \tnoexcept(noexcept(::std::__adl_data(__range))\n \t\t  && noexcept(::std::__adl_size(__range)))\n \t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n \t{ }\n \n-      template<typename _ContiguousIterator, typename _Sentinel,\n-\tenable_if_t<!is_convertible_v<_Sentinel, index_type>\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_reference_t<typename\n-\t      iterator_traits<_ContiguousIterator>::reference>,\n-\t  element_type>>* = nullptr>\n+      template<typename _ContiguousIterator, typename _Sentinel, typename\n+\t\t= _Require<__not_<is_convertible<_Sentinel, index_type>>,\n+\t\t\t   __is_compatible_iterator<_ContiguousIterator>>>\n \tconstexpr\n \tspan(_ContiguousIterator __first, _Sentinel __last)\n-\t: span(::std::move(__first), static_cast<index_type>(__last - __first))\n-\t{ }\n+\t: _M_extent(static_cast<index_type>(__last - __first)),\n+\t  _M_ptr(std::to_address(__first))\n+\t{\n+\t  if (_Extent != dynamic_extent)\n+\t    __glibcxx_assert((__last - __first) == _Extent);\n+\t}\n \n-      template<typename _ContiguousIterator>\n+      template<typename _ContiguousIterator, typename\n+\t\t= _Require<__is_compatible_iterator<_ContiguousIterator>>>\n \tconstexpr\n \tspan(_ContiguousIterator __first, index_type __count)\n-\tnoexcept(noexcept(::std::__adl_to_address(__first)))\n-\t: _M_extent(__count), _M_ptr(::std::__adl_to_address(__first))\n+\tnoexcept(noexcept(std::to_address(__first)))\n+\t: _M_extent(__count), _M_ptr(std::to_address(__first))\n \t{ __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n-\n #else\n-\n+    private:\n       template<typename _Container,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent)\n-\t  && !is_same_v<remove_cvref_t<_Container>, span>\n-\t  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>\n-\t  && !is_array_v<remove_cvref_t<_Container>>\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(\n-\t      ::std::__adl_data(::std::declval<_Container&>())\n-\t      + ::std::__adl_size(::std::declval<_Container&>()))>,\n-\t    element_type>>* = nullptr>\n+\t  typename _DataT = decltype(std::data(std::declval<_Container&>())),\n+\t  typename _SizeT = decltype(std::size(std::declval<_Container&>()))>\n+\tusing __is_compatible_container\n+\t  = __is_compatible<remove_pointer_t<_DataT>>;\n+\n+    public:\n+      template<typename _Container, typename = _Require<\n+\t\tbool_constant<_Extent == dynamic_extent>,\n+\t\t__not_<__detail::__is_std_span<_Container>>,\n+\t\t__not_<__detail::__is_std_array<_Container>>,\n+\t\t__not_<is_array<_Container>>,\n+\t\t__is_compatible_container<_Container>>>\n \tconstexpr\n-\tspan(_Container& __range)\n-\tnoexcept(noexcept(::std::__adl_data(__range))\n-\t\t  && noexcept(::std::__adl_size(__range)))\n-\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+\tspan(_Container& __cont)\n+\tnoexcept(noexcept(std::data(__cont)) && noexcept(std::size(__cont)))\n+\t: _M_extent(std::size(__cont)), _M_ptr(std::data(__cont))\n \t{ }\n \n-      template<typename _Container,\n-\tenable_if_t<\n-\t  (_Extent == dynamic_extent)\n-\t  && !is_same_v<remove_cvref_t<_Container>, span>\n-\t  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>\n-\t  && !is_array_v<remove_cvref_t<_Container>>\n-\t  && __detail::__is_base_derived_safe_convertible_v<\n-\t    remove_pointer_t<decltype(\n-\t      ::std::__adl_data(::std::declval<_Container&>())\n-\t      + ::std::__adl_size(::std::declval<_Container&>()))>,\n-\t    element_type>>* = nullptr>\n-\tconstexpr span(const _Container& __range)\n-\tnoexcept(noexcept(::std::__adl_data(__range))\n-\t\t  && noexcept(::std::__adl_size(__range)))\n-\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+      template<typename _Container, typename = _Require<\n+\t\tbool_constant<_Extent == dynamic_extent>,\n+\t\t__not_<__detail::__is_std_span<_Container>>,\n+\t\t__not_<__detail::__is_std_array<_Container>>,\n+\t\t__not_<is_array<_Container>>,\n+\t\t__is_compatible_container<const _Container>>>\n+\tconstexpr\n+\tspan(const _Container& __cont)\n+\tnoexcept(noexcept(std::data(__cont)) && noexcept(std::size(__cont)))\n+\t: _M_extent(std::size(__cont)), _M_ptr(std::data(__cont))\n \t{ }\n \n       constexpr\n       span(pointer __first, index_type __count) noexcept\n-      : _M_extent(__count), _M_ptr(static_cast<pointer>(__first))\n+      : _M_extent(__count), _M_ptr(__first)\n       { __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n \n       constexpr\n       span(pointer __first, pointer __last) noexcept\n-      : span(::std::move(__first), static_cast<index_type>(__last - __first))\n+      : span(__first, static_cast<index_type>(__last - __first))\n       { }\n #endif // P1394\n \n+      template<typename _OType, size_t _OExtent, typename = _Require<\n+\t  __bool_constant<_Extent == dynamic_extent || _Extent == _OExtent>,\n+\t  is_convertible<_OType(*)[], _Type(*)[]>>>\n+\tconstexpr\n+\tspan(const span<_OType, _OExtent>& __s) noexcept\n+\t: _M_extent(__s.size()), _M_ptr(__s.data())\n+\t{ }\n+\n       // assignment\n \n       constexpr span&\n@@ -474,7 +502,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     span(const array<_Type, _ArrayExtent>&)\n       -> span<const _Type, _ArrayExtent>;\n \n-#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394\n+#ifdef _GLIBCXX_P1394\n \n   template<typename _ContiguousIterator, typename _Sentinel>\n     span(_ContiguousIterator, _Sentinel)"}]}