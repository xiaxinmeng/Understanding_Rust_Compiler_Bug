{"sha": "829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5ZmQ3ZTBmNTAzM2IzMmUwMGFkOTlhOTVjNzk3Y2M3MmI0YTZlYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-05-19T00:48:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-05-19T00:48:10Z"}, "message": "call.c (find_scoped_type, [...]): Lose.\n\n\t* call.c (find_scoped_type, resolve_scope_to_name): Lose.\n\t* class.c (finish_struct_1): Use CLASS_TYPE_P.\n\t* ptree.c (print_lang_type): Likewise.\n\t* typeck.c (build_modify_expr, c_expand_asm_operands): Use\n\tIS_AGGR_TYPE_CODE.\n\t* typeck2.c (digest_init): Likewise.\n\nFrom-SVN: r27001", "tree": {"sha": "c5504a2824f51329807cdc105f88ee9ca8fb9e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5504a2824f51329807cdc105f88ee9ca8fb9e8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/comments", "author": null, "committer": null, "parents": [{"sha": "965f45361ecb69fcd1fe43ae97b63609b0a1dc53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965f45361ecb69fcd1fe43ae97b63609b0a1dc53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965f45361ecb69fcd1fe43ae97b63609b0a1dc53"}], "stats": {"total": 151, "additions": 14, "deletions": 137}, "files": [{"sha": "b2277da733ecfb8deb464b77140a88363246d5a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -1,3 +1,12 @@\n+1999-05-19  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (find_scoped_type, resolve_scope_to_name): Lose.\n+\t* class.c (finish_struct_1): Use CLASS_TYPE_P.\n+\t* ptree.c (print_lang_type): Likewise.\n+\t* typeck.c (build_modify_expr, c_expand_asm_operands): Use\n+\tIS_AGGR_TYPE_CODE.\n+\t* typeck2.c (digest_init): Likewise.\n+\n 1999-05-18  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (joust): Compare the types of the conv ops, not the"}, {"sha": "e4b1a0008e0ad2a23e64e3020394facae39548e8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -42,7 +42,6 @@ extern tree ctor_label, dtor_label;\n static tree build_new_method_call PROTO((tree, tree, tree, tree, int));\n \n static tree build_field_call PROTO((tree, tree, tree, tree));\n-static tree find_scoped_type PROTO((tree, tree, tree));\n static struct z_candidate * tourney PROTO((struct z_candidate *));\n static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n static int compare_ics PROTO((tree, tree));\n@@ -164,130 +163,6 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n   return NULL_TREE;\n }\n \n-static tree\n-find_scoped_type (type, inner_name, inner_types)\n-     tree type, inner_name, inner_types;\n-{\n-  tree tags = CLASSTYPE_TAGS (type);\n-\n-  while (tags)\n-    {\n-      /* The TREE_PURPOSE of an enum tag (which becomes a member of the\n-\t enclosing class) is set to the name for the enum type.  So, if\n-\t inner_name is `bar', and we strike `baz' for `enum bar { baz }',\n-\t then this test will be true.  */\n-      if (TREE_PURPOSE (tags) == inner_name)\n-\t{\n-\t  if (inner_types == NULL_TREE)\n-\t    return TYPE_MAIN_DECL (TREE_VALUE (tags));\n-\t  return resolve_scope_to_name (TREE_VALUE (tags), inner_types);\n-\t}\n-      tags = TREE_CHAIN (tags);\n-    }\n-\n-  /* Look for a TYPE_DECL.  */\n-  for (tags = TYPE_FIELDS (type); tags; tags = TREE_CHAIN (tags))\n-    if (TREE_CODE (tags) == TYPE_DECL && DECL_NAME (tags) == inner_name)\n-      {\n-\t/* Code by raeburn.  */\n-\tif (inner_types == NULL_TREE)\n-\t  return tags;\n-\treturn resolve_scope_to_name (TREE_TYPE (tags), inner_types);\n-      }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Resolve an expression NAME1::NAME2::...::NAMEn to\n-   the name that names the above nested type.  INNER_TYPES\n-   is a chain of nested type names (held together by SCOPE_REFs);\n-   OUTER_TYPE is the type we know to enclose INNER_TYPES.\n-   Returns NULL_TREE if there is an error.  */\n-\n-tree\n-resolve_scope_to_name (outer_type, inner_stuff)\n-     tree outer_type, inner_stuff;\n-{\n-  register tree tmp;\n-  tree inner_name, inner_type;\n-\n-  if (outer_type == NULL_TREE && current_class_type != NULL_TREE)\n-    {\n-      /* We first try to look for a nesting in our current class context,\n-         then try any enclosing classes.  */\n-      tree type = current_class_type;\n-      \n-      while (type && (TREE_CODE (type) == RECORD_TYPE\n-\t\t      || TREE_CODE (type) == UNION_TYPE))\n-        {\n-          tree rval = resolve_scope_to_name (type, inner_stuff);\n-\n-\t  if (rval != NULL_TREE)\n-\t    return rval;\n-\t  type = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n-\t}\n-    }\n-\n-  if (TREE_CODE (inner_stuff) == SCOPE_REF)\n-    {\n-      inner_name = TREE_OPERAND (inner_stuff, 0);\n-      inner_type = TREE_OPERAND (inner_stuff, 1);\n-    }\n-  else\n-    {\n-      inner_name = inner_stuff;\n-      inner_type = NULL_TREE;\n-    }\n-\n-  if (outer_type == NULL_TREE)\n-    {\n-      tree x;\n-      /* If we have something that's already a type by itself,\n-\t use that.  */\n-      if (IDENTIFIER_HAS_TYPE_VALUE (inner_name))\n-\t{\n-\t  if (inner_type)\n-\t    return resolve_scope_to_name (IDENTIFIER_TYPE_VALUE (inner_name),\n-\t\t\t\t\t  inner_type);\n-\t  return inner_name;\n-\t}\n-      \n-      x = lookup_name (inner_name, 0);\n-\n-      if (x && TREE_CODE (x) == NAMESPACE_DECL)\n-\t{\n-\t  x = lookup_namespace_name (x, inner_type);\n-\t  return x;\n-\t}\n-      return NULL_TREE;\n-    }\n-\n-  if (! IS_AGGR_TYPE (outer_type))\n-    return NULL_TREE;\n-\n-  /* Look for member classes or enums.  */\n-  tmp = find_scoped_type (outer_type, inner_name, inner_type);\n-\n-  /* If it's not a type in this class, then go down into the\n-     base classes and search there.  */\n-  if (! tmp && TYPE_BINFO (outer_type))\n-    {\n-      tree binfos = TYPE_BINFO_BASETYPES (outer_type);\n-      int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-      for (i = 0; i < n_baselinks; i++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  tmp = resolve_scope_to_name (BINFO_TYPE (base_binfo), inner_stuff);\n-\t  if (tmp)\n-\t    return tmp;\n-\t}\n-      tmp = NULL_TREE;\n-    }\n-\n-  return tmp;\n-}\n-\n /* Returns nonzero iff the destructor name specified in NAME\n    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many\n    forms...  */"}, {"sha": "00f9d323f13b535a29a865557061f9cf7477dd59", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -3526,8 +3526,7 @@ finish_struct_1 (t, warn_anon)\n \t  while (TREE_CODE (type) == ARRAY_TYPE)\n \t    type = TREE_TYPE (type);\n \n-\t  if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x)\n-\t      && ! TYPE_PTRMEMFUNC_P (type))\n+\t  if (CLASS_TYPE_P (type))\n \t    {\n \t      /* Never let anything with uninheritable virtuals\n \t\t make it through without complaint.  */"}, {"sha": "502c1f0cc752cf440062ce0ebaff62b612bfc319", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -79,11 +79,7 @@ print_lang_type (file, node, indent)\n       return;\n     }\n \n-  if (! (TREE_CODE (node) == RECORD_TYPE\n-\t || TREE_CODE (node) == UNION_TYPE))\n-    return;\n-\n-  if (!TYPE_LANG_SPECIFIC (node))\n+  if (! CLASS_TYPE_P (node))\n     return;\n \n   indent_to (file, indent + 3);"}, {"sha": "a6d08be5ff286590981636e8683fda2e20b52796", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -6116,8 +6116,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  /* Functions are not modifiable, even though they are\n \t     lvalues.  */\n \t  || TREE_CODE (TREE_TYPE (lhs)) == FUNCTION_TYPE\n-\t  || ((TREE_CODE (lhstype) == RECORD_TYPE\n-\t       || TREE_CODE (lhstype) == UNION_TYPE)\n+\t  || (IS_AGGR_TYPE_CODE (TREE_CODE (lhstype))\n \t      && C_TYPE_FIELDS_READONLY (lhstype))\n \t  || (TREE_CODE (lhstype) == REFERENCE_TYPE\n \t      && CP_TYPE_CONST_P (TREE_TYPE (lhstype)))))\n@@ -7268,8 +7267,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t{\n \t  tree type = TREE_TYPE (o[i]);\n \t  if (CP_TYPE_CONST_P (type)\n-\t      || ((TREE_CODE (type) == RECORD_TYPE\n-\t\t   || TREE_CODE (type) == UNION_TYPE)\n+\t      || (IS_AGGR_TYPE_CODE (TREE_CODE (type))\n \t\t  && C_TYPE_FIELDS_READONLY (type)))\n \t    readonly_error (o[i], \"modification by `asm'\", 1);\n \t}"}, {"sha": "971b388a34167fee248fc55459ae2960ada564be", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829fd7e0f5033b32e00ad99a95c797cc72b4a6ea/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=829fd7e0f5033b32e00ad99a95c797cc72b4a6ea", "patch": "@@ -835,7 +835,7 @@ digest_init (type, init, tail)\n       return error_mark_node;\n     }\n \n-  if (code == ARRAY_TYPE || code == RECORD_TYPE || code == UNION_TYPE)\n+  if (code == ARRAY_TYPE || IS_AGGR_TYPE_CODE (code))\n     {\n       if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type))\n \t{"}]}