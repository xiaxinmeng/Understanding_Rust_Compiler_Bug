{"sha": "4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5NWE3Njc5NmYyYTg4YmJiY2IwOTQ3YjNmYzhjZmI1OTBiY2YyOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2007-07-22T16:25:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2007-07-22T16:25:54Z"}, "message": "re PR c++/30818 (templates and typedefs cause function prototype not to match)\n\ncp/\n\tPR c++/30818\n\t* typeck.c (structural_comptypes): No need to check\n\tresolve_typename_type return value here.\n\t* cp-tree.h (TYPENAME_IS_RESOLVING_P): New.\n\t* pt.c (resolve_typename_type): Follow typename typedefs.  Return\n\toriginal type rather than error_mark_node in case of failure.\n\t* parser.c (cp_parser_nested_name_specifier_opt): Adjust\n\tresolve_typename_type result check.\n\t(cp_parser_direct_declarator, cp_parser_head,\n\tcp_parser_constructor_declarator_p): Likewise.\n\ntestsuite/\n\tPR c++/30818\n\t* g++.dg/template/crash47.C: Adjust errors.\n\t* g++.dg/template/crash48.C: Adjust errors.\n\t* g++.dg/template/typename12.C: New.\n\t* g++.dg/template/typename13.C: New.\n\t* g++.dg/template/typename14.C: New.\n\t* g++.dg/template/typedef6.C: Adjust errors.\n\nFrom-SVN: r126825", "tree": {"sha": "dfb789ad9be1e19231b508e1334e98d3418748a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfb789ad9be1e19231b508e1334e98d3418748a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/comments", "author": null, "committer": null, "parents": [{"sha": "7e24f16cf7d70e74c60985f7591cbf2e129a23da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e24f16cf7d70e74c60985f7591cbf2e129a23da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e24f16cf7d70e74c60985f7591cbf2e129a23da"}], "stats": {"total": 194, "additions": 155, "deletions": 39}, "files": [{"sha": "6faa01f80a112957ac5a84e338471817855dd410", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -1,3 +1,16 @@\n+2007-07-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/30818\n+\t* typeck.c (structural_comptypes): No need to check\n+\tresolve_typename_type return value here.\n+\t* cp-tree.h (TYPENAME_IS_RESOLVING_P): New.\n+\t* pt.c (resolve_typename_type): Follow typename typedefs.  Return\n+\toriginal type rather than error_mark_node in case of failure.\n+\t* parser.c (cp_parser_nested_name_specifier_opt): Adjust\n+\tresolve_typename_type result check.\n+\t(cp_parser_direct_declarator, cp_parser_head,\n+\tcp_parser_constructor_declarator_p): Likewise.\n+\n 2007-07-12  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* pt.c (template_parms_variadic_p): Remove."}, {"sha": "e4401712fb5e6780783d2439521c24d5e41fcd88", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -71,6 +71,7 @@ struct diagnostic_context;\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n+      TYPENAME_IS_RESOLVING_P (in TYPE_NAME_TYPE)\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -2589,6 +2590,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPENAME_IS_CLASS_P(NODE) \\\n   (TREE_LANG_FLAG_1 (TYPENAME_TYPE_CHECK (NODE)))\n \n+/* True if a TYPENAME_TYPE is in the process of being resolved.  */\n+#define TYPENAME_IS_RESOLVING_P(NODE) \\\n+  (TREE_LANG_FLAG_2 (TYPENAME_TYPE_CHECK (NODE)))\n+\n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) TREE_LANG_FLAG_0 (INTEGER_CST_CHECK (NODE))"}, {"sha": "458d300c33138678690f2aab2745a554f9148f05", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -3922,7 +3922,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t    {\n \t      new_scope = resolve_typename_type (parser->scope,\n \t\t\t\t\t\t /*only_current_p=*/false);\n-\t      if (new_scope != error_mark_node)\n+\t      if (TREE_CODE (new_scope) != TYPENAME_TYPE)\n \t\tparser->scope = new_scope;\n \t    }\n \t  success = true;\n@@ -12464,7 +12464,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      type = resolve_typename_type (qualifying_scope,\n \t\t\t\t\t    /*only_current_p=*/false);\n \t      /* If that failed, the declarator is invalid.  */\n-\t      if (type == error_mark_node)\n+\t      if (TREE_CODE (type) == TYPENAME_TYPE)\n \t\terror (\"%<%T::%E%> is not a type\",\n \t\t       TYPE_CONTEXT (qualifying_scope),\n \t\t       TYPE_IDENTIFIER (qualifying_scope));\n@@ -14282,7 +14282,7 @@ cp_parser_class_head (cp_parser* parser,\n \t{\n \t  class_type = resolve_typename_type (TREE_TYPE (type),\n \t\t\t\t\t      /*only_current_p=*/false);\n-\t  if (class_type != error_mark_node)\n+\t  if (TREE_CODE (class_type) != TYPENAME_TYPE)\n \t    type = TYPE_NAME (class_type);\n \t  else\n \t    {\n@@ -16291,7 +16291,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t{\n \t\t  type = resolve_typename_type (type,\n \t\t\t\t\t\t/*only_current_p=*/false);\n-\t\t  if (type == error_mark_node)\n+\t\t  if (TREE_CODE (type) == TYPENAME_TYPE)\n \t\t    {\n \t\t      cp_parser_abort_tentative_parse (parser);\n \t\t      return false;"}, {"sha": "86b8eee6a1089c7cce4656b92630938aea6004d1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -15457,11 +15457,12 @@ dependent_template_id_p (tree tmpl, tree args)\n }\n \n /* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the\n-   TYPENAME_TYPE corresponds.  Returns ERROR_MARK_NODE if no such TYPE\n-   can be found.  Note that this function peers inside uninstantiated\n-   templates and therefore should be used only in extremely limited\n-   situations.  ONLY_CURRENT_P restricts this peering to the currently\n-   open classes hierarchy (which is required when comparing types).  */\n+   TYPENAME_TYPE corresponds.  Returns the original TYPENAME_TYPE if\n+   no such TYPE can be found.  Note that this function peers inside\n+   uninstantiated templates and therefore should be used only in\n+   extremely limited situations.  ONLY_CURRENT_P restricts this\n+   peering to the currently open classes hierarchy (which is required\n+   when comparing types).  */\n \n tree\n resolve_typename_type (tree type, bool only_current_p)\n@@ -15471,6 +15472,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   tree decl;\n   int quals;\n   tree pushed_scope;\n+  tree result;\n \n   gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n@@ -15483,16 +15485,16 @@ resolve_typename_type (tree type, bool only_current_p)\n     scope = resolve_typename_type (scope, only_current_p);\n   /* If we don't know what SCOPE refers to, then we cannot resolve the\n      TYPENAME_TYPE.  */\n-  if (scope == error_mark_node || TREE_CODE (scope) == TYPENAME_TYPE)\n-    return error_mark_node;\n+  if (TREE_CODE (scope) == TYPENAME_TYPE)\n+    return type;\n   /* If the SCOPE is a template type parameter, we have no way of\n      resolving the name.  */\n   if (TREE_CODE (scope) == TEMPLATE_TYPE_PARM)\n     return type;\n   /* If the SCOPE is not the current instantiation, there's no reason\n      to look inside it.  */\n   if (only_current_p && !currently_open_class (scope))\n-    return error_mark_node;\n+    return type;\n   /* If SCOPE is a partial instantiation, it will not have a valid\n      TYPE_FIELDS list, so use the original template.  */\n   scope = CLASSTYPE_PRIMARY_TEMPLATE_TYPE (scope);\n@@ -15502,15 +15504,20 @@ resolve_typename_type (tree type, bool only_current_p)\n   pushed_scope = push_scope (scope);\n   /* Look up the declaration.  */\n   decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/true);\n-  /* Obtain the set of qualifiers applied to the TYPE.  */\n-  quals = cp_type_quals (type);\n+\n+  result = NULL_TREE;\n+  \n   /* For a TYPENAME_TYPE like \"typename X::template Y<T>\", we want to\n      find a TEMPLATE_DECL.  Otherwise, we want to find a TYPE_DECL.  */\n   if (!decl)\n-    type = error_mark_node;\n+    /*nop*/;\n   else if (TREE_CODE (TYPENAME_TYPE_FULLNAME (type)) == IDENTIFIER_NODE\n \t   && TREE_CODE (decl) == TYPE_DECL)\n-    type = TREE_TYPE (decl);\n+    {\n+      result = TREE_TYPE (decl);\n+      if (result == error_mark_node)\n+\tresult = NULL_TREE;\n+    }\n   else if (TREE_CODE (TYPENAME_TYPE_FULLNAME (type)) == TEMPLATE_ID_EXPR\n \t   && DECL_CLASS_TEMPLATE_P (decl))\n     {\n@@ -15520,19 +15527,37 @@ resolve_typename_type (tree type, bool only_current_p)\n       tmpl = TREE_OPERAND (TYPENAME_TYPE_FULLNAME (type), 0);\n       args = TREE_OPERAND (TYPENAME_TYPE_FULLNAME (type), 1);\n       /* Instantiate the template.  */\n-      type = lookup_template_class (tmpl, args, NULL_TREE, NULL_TREE,\n-\t\t\t\t    /*entering_scope=*/0, tf_error | tf_user);\n+      result = lookup_template_class (tmpl, args, NULL_TREE, NULL_TREE,\n+\t\t\t\t      /*entering_scope=*/0,\n+\t\t\t\t      tf_error | tf_user);\n+      if (result == error_mark_node)\n+\tresult = NULL_TREE;\n     }\n-  else\n-    type = error_mark_node;\n-  /* Qualify the resulting type.  */\n-  if (type != error_mark_node && quals)\n-    type = cp_build_qualified_type (type, quals);\n+  \n   /* Leave the SCOPE.  */\n   if (pushed_scope)\n     pop_scope (pushed_scope);\n \n-  return type;\n+  /* If we failed to resolve it, return the original typename.  */\n+  if (!result)\n+    return type;\n+  \n+  /* If lookup found a typename type, resolve that too.  */\n+  if (TREE_CODE (result) == TYPENAME_TYPE && !TYPENAME_IS_RESOLVING_P (result))\n+    {\n+      /* Ill-formed programs can cause infinite recursion here, so we\n+\t must catch that.  */\n+      TYPENAME_IS_RESOLVING_P (type) = 1;\n+      result = resolve_typename_type (result, only_current_p);\n+      TYPENAME_IS_RESOLVING_P (type) = 0;\n+    }\n+  \n+  /* Qualify the resulting type.  */\n+  quals = cp_type_quals (type);\n+  if (quals)\n+    result = cp_build_qualified_type (result, cp_type_quals (result) | quals);\n+\n+  return result;\n }\n \n /* EXPR is an expression which is not type-dependent.  Return a proxy"}, {"sha": "7e59ec36b0584e93e76a51ff16bf08aa9574d19f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -943,20 +943,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n   /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n      current instantiation.  */\n   if (TREE_CODE (t1) == TYPENAME_TYPE)\n-    {\n-      tree resolved = resolve_typename_type (t1, /*only_current_p=*/true);\n-\n-      if (resolved != error_mark_node)\n-\tt1 = resolved;\n-    }\n+    t1 = resolve_typename_type (t1, /*only_current_p=*/true);\n \n   if (TREE_CODE (t2) == TYPENAME_TYPE)\n-    {\n-      tree resolved = resolve_typename_type (t2, /*only_current_p=*/true);\n-\n-      if (resolved != error_mark_node)\n-\tt2 = resolved;\n-    }\n+    t2 = resolve_typename_type (t2, /*only_current_p=*/true);\n \n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);"}, {"sha": "1b5a4101bc9ec93677532e7d284672b46ebe12dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -1,3 +1,13 @@\n+2007-07-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/30818\n+\t* g++.dg/template/crash47.C: Adjust errors.\n+\t* g++.dg/template/crash48.C: Adjust errors.\n+\t* g++.dg/template/typename12.C: New.\n+\t* g++.dg/template/typename13.C: New.\n+\t* g++.dg/template/typename14.C: New.\n+\t* g++.dg/template/typedef6.C: Adjust errors.\n+\n 2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n \n \tPR fortran/32627"}, {"sha": "9c2163209339e022989e90f64fd0df1434a86a76", "filename": "gcc/testsuite/g++.dg/template/crash47.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash47.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -1,3 +1,3 @@\n // PR c++/27102\n \n-template<typename T> void T::X::foo() {} // { dg-error \"invalid\" }\n+template<typename T> void T::X::foo() {} // { dg-error \"invalid|not a type\" }"}, {"sha": "deb944685bdcdcad447e8f9f590d164e8b8ceedf", "filename": "gcc/testsuite/g++.dg/template/crash48.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash48.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -7,4 +7,4 @@ template<typename T> struct A\n   typedef typename T::X X;\n };\n \n-template<typename T> A<T>::X::X() {} // { dg-error \"no type|invalid use\" }\n+template<typename T> A<T>::X::X() {} // { dg-error \"no type|invalid use|not a type\" }"}, {"sha": "c95945966fad5de1c84282d6713773612f7d1001", "filename": "gcc/testsuite/g++.dg/template/typedef6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef6.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -5,4 +5,4 @@ template<typename T> struct A\n   typedef struct typename T::X X;       // { dg-error \"expected identifier|two or more\" }\n };\n \n-template<typename T> A<T>::X::X() {}    // { dg-error \"not a type|forbids declaration\" }\n+template<typename T> A<T>::X::X() {}    // { dg-error \"not a type|forbids declaration|invalid use of\" }"}, {"sha": "0bb78c7c85728593e0901f8f8a0733007afb58a0", "filename": "gcc/testsuite/g++.dg/template/typename12.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename12.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2007 <nathan@codesourcery.com>\n+\n+// Origin: sschunck@pdf.de\n+// PR 30818, failure to resolve typename typedef\n+\n+template < typename T > \n+class A \n+{\n+  typedef int type;\n+  class B;\n+};\n+\n+template < typename T >\n+class A<T>::B\n+{\n+  typedef typename A<T>::type type;\n+  type f();\n+};\n+\n+template < typename T >\n+typename A<T>::B::type \n+A<T>::B::f() { return 0; }"}, {"sha": "527b0d15316561a09865f384107d5e11ab71ef0b", "filename": "gcc/testsuite/g++.dg/template/typename13.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename13.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2007 <nathan@codesourcery.com>\n+\n+template <typename T> struct A\n+{\n+  struct B;\n+  typedef typename B::type type;\n+};\n+\n+template <typename T> struct A<T>::B\n+{\n+  typedef typename A<T>::type type;\n+\n+  type Foo ();\n+};\n+\n+template <typename T>\n+typename A<T>::B::type\n+A<T>::B::Foo () \n+{\n+  return 0;\n+}"}, {"sha": "7e73cb0f3ad525177925ce13d1c1de790aa578d8", "filename": "gcc/testsuite/g++.dg/template/typename14.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4195a76796f2a88bbbcb0947b3fc8cfb590bcf28/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename14.C?ref=4195a76796f2a88bbbcb0947b3fc8cfb590bcf28", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2007 <nathan@codesourcery.com>\n+\n+template <typename T> struct A  \n+{\n+  typedef const T X;\n+  \n+  struct B;\n+};\n+\n+template <typename T> struct A<T>::B\n+{\n+  typedef volatile typename A<T>::X Y;\n+\n+  T const volatile *Foo ();\n+};\n+\n+template<typename T>\n+typename A<T>::B::Y *A<T>::B::Foo ()\n+{\n+  return 0;\n+}"}]}