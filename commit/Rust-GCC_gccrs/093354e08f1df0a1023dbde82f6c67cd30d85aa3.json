{"sha": "093354e08f1df0a1023dbde82f6c67cd30d85aa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzMzU0ZTA4ZjFkZjBhMTAyM2RiZGU4MmY2YzY3Y2QzMGQ4NWFhMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-01T23:26:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-01T23:26:43Z"}, "message": "alpha.c: Fix comment typos.\n\n\t* config/alpha/alpha.c: Fix comment typos.\n\t* config/alpha/elf.h: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/arm/arm.h: Likewise.\n\t* config/arm/arm.md: Likewise.\n\t* config/arm/t-arm-coff: Likewise.\n\t* config/arm/t-strongarm-pe: Likewise.\n\t* config/arm/xscale-elf.h: Likewise.\n\t* config/avr/avr.h: Likewise.\n\nFrom-SVN: r68800", "tree": {"sha": "fc7172a6af53d704bc2f22f1af3ca915f2652214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc7172a6af53d704bc2f22f1af3ca915f2652214"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/093354e08f1df0a1023dbde82f6c67cd30d85aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093354e08f1df0a1023dbde82f6c67cd30d85aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093354e08f1df0a1023dbde82f6c67cd30d85aa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093354e08f1df0a1023dbde82f6c67cd30d85aa3/comments", "author": null, "committer": null, "parents": [{"sha": "2a2ecc33a8538c043fd424034f467d667cf237f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2ecc33a8538c043fd424034f467d667cf237f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2ecc33a8538c043fd424034f467d667cf237f3"}], "stats": {"total": 52, "additions": 32, "deletions": 20}, "files": [{"sha": "8719b5ffff675f8109a5af0538d0fa07ae3c3794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -1,3 +1,15 @@\n+2003-07-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/alpha/alpha.c: Fix comment typos.\n+\t* config/alpha/elf.h: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/arm/arm.h: Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\t* config/arm/t-arm-coff: Likewise.\n+\t* config/arm/t-strongarm-pe: Likewise.\n+\t* config/arm/xscale-elf.h: Likewise.\n+\t* config/avr/avr.h: Likewise.\n+\n 2003-07-01  Jeff Law  <law@redhat.com>\n \n \t* stmt.c (any_pending_cleanups): Remove another redundant test."}, {"sha": "927073f1c4a75dc0de8308c8ad0df052f1b940c5", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -974,7 +974,7 @@ call_operand (rtx op, enum machine_mode mode)\n     {\n       if (TARGET_ABI_OSF)\n \t{\n-\t  /* Disallow virtual registers to cope with pathalogical test cases\n+\t  /* Disallow virtual registers to cope with pathological test cases\n \t     such as compile/930117-1.c in which the virtual reg decomposes\n \t     to the frame pointer.  Which is a hard reg that is not $27.  */\n \t  return (REGNO (op) == 27 || REGNO (op) > LAST_VIRTUAL_REGISTER);\n@@ -2006,7 +2006,7 @@ split_small_symbolic_operand (rtx x)\n    that we've marked with gpdisp relocs, since those have to stay in\n    1-1 correspondence with one another.\n \n-   Techinically we could copy them if we could set up a mapping from one\n+   Technically we could copy them if we could set up a mapping from one\n    sequence number to another, across the set of insns to be duplicated.\n    This seems overly complicated and error-prone since interblock motion\n    from sched-ebb could move one of the pair of insns to a different block.  */\n@@ -7253,7 +7253,7 @@ alpha_expand_prologue (void)\n \t       => alpha_procedure_type != PT_NULL,\n \n \t     so when we are not setting the bit here, we are guaranteed to\n-\t     have emited an FRP frame pointer update just before.  */\n+\t     have emitted an FRP frame pointer update just before.  */\n \t  RTX_FRAME_RELATED_P (seq) = ! frame_pointer_needed;\n \t}\n     }\n@@ -8267,7 +8267,7 @@ alpha_handle_trap_shadows (void)\n }\n \f\n /* Alpha can only issue instruction groups simultaneously if they are\n-   suitibly aligned.  This is very processor-specific.  */\n+   suitably aligned.  This is very processor-specific.  */\n \n enum alphaev4_pipe {\n   EV4_STOP = 0,\n@@ -8857,7 +8857,7 @@ alpha_elf_select_rtx_section (enum machine_mode mode, rtx x,\n \t\t\t      unsigned HOST_WIDE_INT align)\n {\n   if (TARGET_SMALL_DATA && GET_MODE_SIZE (mode) <= g_switch_value)\n-    /* ??? Consider using mergable sdata sections.  */\n+    /* ??? Consider using mergeable sdata sections.  */\n     sdata_section ();\n   else\n     default_elf_select_rtx_section (mode, x, align);"}, {"sha": "118ba8947a578a34a892891fc5d2ff85fe289e8d", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -149,7 +149,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    not defined, the default value is `BIGGEST_ALIGNMENT'. \n \n    This value is really 2^63.  Since gcc figures the alignment in bits,\n-   we could only potentially get to 2^60 on suitible hosts.  Due to other\n+   we could only potentially get to 2^60 on suitable hosts.  Due to other\n    considerations in varasm, we must restrict this to what fits in an int.  */\n \n #undef  MAX_OFILE_ALIGNMENT"}, {"sha": "6b6a718557de11ae3bfaf50d9e008eb46f1e4aec", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -2085,7 +2085,7 @@ arm_va_arg (tree valist, tree type)\n       tree t;\n \n       /* Maintain 64-bit alignment of the valist pointer by\n-\t contructing:   valist = ((valist + (8 - 1)) & -8).  */\n+\t constructing:   valist = ((valist + (8 - 1)) & -8).  */\n       minus_eight = build_int_2 (- (IWMMXT_ALIGNMENT / BITS_PER_UNIT), -1);\n       t = build_int_2 ((IWMMXT_ALIGNMENT / BITS_PER_UNIT) - 1, 0);\n       t = build (PLUS_EXPR,    TREE_TYPE (valist), valist, t);\n@@ -6124,7 +6124,7 @@ get_jump_table_size (rtx insn)\n \n /* Move a minipool fix MP from its current location to before MAX_MP.\n    If MAX_MP is NULL, then MP doesn't need moving, but the addressing\n-   contrains may need updating.  */\n+   constraints may need updating.  */\n static Mnode *\n move_minipool_fix_forward_ref (Mnode *mp, Mnode *max_mp,\n \t\t\t       HOST_WIDE_INT max_address)\n@@ -6747,7 +6747,7 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n \n #ifdef AOF_ASSEMBLER\n-  /* PIC symbol refereneces need to be converted into offsets into the\n+  /* PIC symbol references need to be converted into offsets into the\n      based area.  */\n   /* XXX This shouldn't be done here.  */\n   if (flag_pic && GET_CODE (value) == SYMBOL_REF)\n@@ -9490,13 +9490,13 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t \n \t In a pair of registers containing a DI or DF value the 'Q'\n \t operand returns the register number of the register containing\n-\t the least signficant part of the value.  The 'R' operand returns\n+\t the least significant part of the value.  The 'R' operand returns\n \t the register number of the register containing the most\n \t significant part of the value.\n \t \n \t The 'H' operand returns the higher of the two register numbers.\n \t On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the\n-\t same as the 'Q' operand, since the most signficant part of the\n+\t same as the 'Q' operand, since the most significant part of the\n \t value is held in the lower number register.  The reverse is true\n \t on systems where WORDS_BIG_ENDIAN is false.\n \t \n@@ -11702,7 +11702,7 @@ thumb_unexpanded_epilogue (void)\n       high_regs_pushed++;\n \n   /* The prolog may have pushed some high registers to use as\n-     work registers.  eg the testuite file:\n+     work registers.  eg the testsuite file:\n      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c\n      compiles to produce:\n \tpush\t{r4, r5, r6, r7, lr}"}, {"sha": "dc649ccfd1dec28e0c54f9633de988cb67b2f073", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -1024,7 +1024,7 @@ extern const char * structure_size_string;\n /* The number of (integer) argument register available.  */\n #define NUM_ARG_REGS\t\t4\n \n-/* Return the regiser number of the N'th (integer) argument.  */\n+/* Return the register number of the N'th (integer) argument.  */\n #define ARG_REGISTER(N) \t(N - 1)\n \n #if 0 /* FIXME: The ARM backend has special code to handle structure"}, {"sha": "94e2c65edd6b46554f617170d0f77dc18b5f42ee", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -1726,7 +1726,7 @@\n \t/* A Trick, since we are setting the bottom bits in the word,\n \t   we can shift operand[3] up, operand[0] down, OR them together\n \t   and rotate the result back again.  This takes 3 insns, and\n-\t   the third might be mergable into another op.  */\n+\t   the third might be mergeable into another op.  */\n \t/* The shift up copes with the possibility that operand[3] is\n            wider than the bitfield.  */\n \trtx op0 = gen_reg_rtx (SImode);"}, {"sha": "8eef976aaee3654ee0739762e7f10740dd3bc788", "filename": "gcc/config/arm/t-arm-coff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Ft-arm-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Ft-arm-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-coff?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -28,7 +28,7 @@ EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n \n-# Currently there is a bug somwehere in GCC's alias analysis\n+# Currently there is a bug somewhere in GCC's alias analysis\n # or scheduling code that is breaking _fpmul_parts in fp-bit.c.\n # Disabling function inlining is a workaround for this problem.\n TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "e401666654a6cc70eccea1a29c530a0ab174d859", "filename": "gcc/config/arm/t-strongarm-pe", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Ft-strongarm-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Ft-strongarm-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-strongarm-pe?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -32,7 +32,7 @@ EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n \n-# Currently there is a bug somwehere in GCC's alias analysis\n+# Currently there is a bug somewhere in GCC's alias analysis\n # or scheduling code that is breaking _fpmul_parts in fp-bit.c.\n # Disabling function inlining is a workaround for this problem.\n TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "aea8360dba8baa4671f8afec26eb347d66fa28fe", "filename": "gcc/config/arm/xscale-elf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Fxscale-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Farm%2Fxscale-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxscale-elf.h?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -32,7 +32,7 @@\n    the assembler:\n    \n      -mfpu=softvfp   This is the default.  It indicates thats doubles are\n-                     stored in a format compatable with the VFP\n+                     stored in a format compatible with the VFP\n \t\t     specification.  This is the newer double format, whereby\n \t\t     the endian-ness of the doubles matches the endian-ness\n \t\t     of the memory architecture.\n@@ -43,8 +43,8 @@\n \t\t     is what happens].\n \t\t     \n      -mfpu=softfpa   This is when -msoft-float is specified.\n-                     This is the normal beahviour of other arm configurations,\n-\t\t     which for backwards compatability purposes default to\n+                     This is the normal behavior of other arm configurations,\n+\t\t     which for backwards compatibility purposes default to\n \t\t     supporting the old FPA format which was always big\n \t\t     endian, regardless of the endian-ness of the memory\n \t\t     system.  */"}, {"sha": "83c91ee62405244e65703d6c793d06d83ee25c54", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093354e08f1df0a1023dbde82f6c67cd30d85aa3/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=093354e08f1df0a1023dbde82f6c67cd30d85aa3", "patch": "@@ -364,7 +364,7 @@ extern int avr_asm_only_p;\n \n    One use of this macro is on machines where the highest numbered\n    registers must always be saved and the save-multiple-registers\n-   instruction supports only sequences of consetionve registers.  On\n+   instruction supports only sequences of consecutive registers.  On\n    such machines, define `REG_ALLOC_ORDER' to be an initializer that\n    lists the highest numbered allocatable register first. */\n "}]}