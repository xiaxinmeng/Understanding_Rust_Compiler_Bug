{"sha": "ae673f140351f3cb46dd7856c493a3ae52a7f15c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU2NzNmMTQwMzUxZjNjYjQ2ZGQ3ODU2YzQ5M2EzYWU1MmE3ZjE1Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-11-16T01:37:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-11-16T01:37:39Z"}, "message": "class.c (finish_struct): If we're a local class in a template function, add a TAG_DEFN.\n\n        * class.c (finish_struct): If we're a local class in a template\n        function, add a TAG_DEFN.\n        * pt.c (lookup_template_class): If this is a local class in a\n        template function, call pushtag.\n        (tsubst_expr, case TAG_DEFN): Handle classes, too.\n\n        Emit debug info with the vtable.\n        * search.c (maybe_suppress_debug_info): New function...\n        * class.c (finish_struct_1): ...split out from here.\n        * cp-tree.h: Declare it.\n        * decl2.c (finish_vtable_vardecl): Override TYPE_DECL_SUPPRESS_DEBUG\n        if we're writing out the vtable.\n        * decl.c, search.c (dfs_debug_mark, dfs_debug_unmarked_p,\n        note_debug_info_needed): #if 0 out.\n\nFrom-SVN: r30541", "tree": {"sha": "67da42d593d4dbfeed5167b23b222f87b07b537b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67da42d593d4dbfeed5167b23b222f87b07b537b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae673f140351f3cb46dd7856c493a3ae52a7f15c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae673f140351f3cb46dd7856c493a3ae52a7f15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae673f140351f3cb46dd7856c493a3ae52a7f15c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae673f140351f3cb46dd7856c493a3ae52a7f15c/comments", "author": null, "committer": null, "parents": [{"sha": "348bb3c7ed94f7224110bab364e70d962a7c31c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348bb3c7ed94f7224110bab364e70d962a7c31c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348bb3c7ed94f7224110bab364e70d962a7c31c0"}], "stats": {"total": 197, "additions": 111, "deletions": 86}, "files": [{"sha": "cc45c1e0bda823931464e875531c7ac95458ae0c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -1,3 +1,20 @@\n+1999-11-15  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* class.c (finish_struct): If we're a local class in a template\n+\tfunction, add a TAG_DEFN.\n+\t* pt.c (lookup_template_class): If this is a local class in a\n+\ttemplate function, call pushtag.\n+\t(tsubst_expr, case TAG_DEFN): Handle classes, too.\n+\n+\tEmit debug info with the vtable.\n+\t* search.c (maybe_suppress_debug_info): New function...\n+\t* class.c (finish_struct_1): ...split out from here.\n+\t* cp-tree.h: Declare it.\n+\t* decl2.c (finish_vtable_vardecl): Override TYPE_DECL_SUPPRESS_DEBUG\n+\tif we're writing out the vtable.\n+\t* decl.c, search.c (dfs_debug_mark, dfs_debug_unmarked_p, \n+\tnote_debug_info_needed): #if 0 out.\n+\n 1999-11-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (DECL_LOCAL_FUCNTION_P): New macro."}, {"sha": "19bd69cf089a0666e85eb48b5a44100467a3d0a1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 40, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -4180,46 +4180,7 @@ finish_struct_1 (t)\n   if (warn_overloaded_virtual)\n     warn_hidden (t);\n \n-#if 0\n-  /* This has to be done after we have sorted out what to do with\n-     the enclosing type.  */\n-  if (write_symbols != DWARF_DEBUG)\n-    {\n-      /* Be smarter about nested classes here.  If a type is nested,\n-\t only output it if we would output the enclosing type.  */\n-      if (DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (t)))\n-\tDECL_IGNORED_P (TYPE_MAIN_DECL (t)) = TREE_ASM_WRITTEN (TYPE_MAIN_DECL (t));\n-    }\n-#endif\n-\n-  if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n-    {\n-      /* If the type has methods, we want to think about cutting down\n-\t the amount of symbol table stuff we output.  The value stored in\n-\t the TYPE_DECL's DECL_IGNORED_P slot is a first approximation.\n-\t For example, if a member function is seen and we decide to\n-\t write out that member function, then we can change the value\n-\t of the DECL_IGNORED_P slot, and the type will be output when\n-\t that member function's debug info is written out.\n-\n-\t We can't do this with DWARF, which does not support name\n-\t references between translation units.  */\n-      if (CLASSTYPE_METHOD_VEC (t))\n-\t{\n-\t  /* Don't output full info about any type\n-\t     which does not have its implementation defined here.  */\n-\t  if (CLASSTYPE_INTERFACE_ONLY (t))\n-\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n-#if 0\n-\t  /* XXX do something about this.  */\n-\t  else if (CLASSTYPE_INTERFACE_UNKNOWN (t))\n-\t    /* Only a first approximation!  */\n-\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n-#endif\n-\t}\n-      else if (CLASSTYPE_INTERFACE_ONLY (t))\n-\tTYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n-    }\n+  maybe_suppress_debug_info (t);\n \n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel_bindings_p ());\n@@ -4287,6 +4248,13 @@ finish_struct (t, attributes)\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n \n+  if (processing_template_decl)\n+    {\n+      tree scope = current_scope ();\n+      if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+\tadd_tree (build_min (TAG_DEFN, t));\n+    }\n+\n   return t;\n }\n \f"}, {"sha": "24f71c31abe9b0bf923890d57b89af2e0ce8a0a0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -3830,6 +3830,7 @@ extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern tree get_vbase_types\t\t\tPROTO((tree));\n+extern void maybe_suppress_debug_info\t\tPROTO((tree));\n extern void note_debug_info_needed\t\tPROTO((tree));\n extern void push_class_decls\t\t\tPROTO((tree));\n extern void pop_class_decls\t\t\tPROTO((void));"}, {"sha": "a0dbffee46cb098bb8c930920c34d7e8b0cb9be3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -7063,12 +7063,17 @@ layout_var_decl (decl)\n       cp_error (\"storage size of `%D' isn't known\", decl);\n       TREE_TYPE (decl) = error_mark_node;\n     }\n+#if 0\n+  /* Keep this code around in case we later want to control debug info\n+     based on whether a type is \"used\".  (jason 1999-11-11) */\n+\n   else if (!DECL_EXTERNAL (decl) && IS_AGGR_TYPE (ttype))\n     /* Let debugger know it should output info for this type.  */\n     note_debug_info_needed (ttype);\n \n   if (TREE_STATIC (decl) && DECL_CLASS_SCOPE_P (decl))\n     note_debug_info_needed (DECL_CONTEXT (decl));\n+#endif\n \n   if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n       && DECL_SIZE (decl) != NULL_TREE\n@@ -13443,6 +13448,10 @@ finish_function (lineno, flags)\n \t  tree ttype = target_type (fntype);\n \t  tree parmdecl;\n \n+#if 0\n+\t  /* Keep this code around in case we later want to control debug info\n+\t     based on whether a type is \"used\".  (jason 1999-11-11) */\n+\n \t  if (IS_AGGR_TYPE (ttype))\n \t    /* Let debugger know it should output info for this type.  */\n \t    note_debug_info_needed (ttype);\n@@ -13454,6 +13463,7 @@ finish_function (lineno, flags)\n \t\t/* Let debugger know it should output info for this type.  */\n \t\tnote_debug_info_needed (ttype);\n \t    }\n+#endif\n \t}\n \n       /* Clean house because we will need to reorder insns here.  */\n@@ -13643,8 +13653,13 @@ finish_function (lineno, flags)\n \t  mark_inline_for_output (fndecl);\n \t}\n \n+#if 0\n+      /* Keep this code around in case we later want to control debug info\n+\t based on whether a type is \"used\".  (jason 1999-11-11) */\n+\n       if (ctype && TREE_ASM_WRITTEN (fndecl))\n \tnote_debug_info_needed (ctype);\n+#endif\n \n       returns_null |= can_reach_end;\n "}, {"sha": "8c623fc1daa104fcc57fe2be9b4cbf5ac6c5037a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -2598,6 +2598,14 @@ finish_vtable_vardecl (t, data)\n       if (flag_syntax_only)\n \tTREE_ASM_WRITTEN (vars) = 1;\n \n+      /* Since we're writing out the vtable here, also write the debug \n+\t info.  */\n+      if (TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (ctype)))\n+\t{\n+\t  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (ctype)) = 0;\n+\t  rest_of_type_compilation (ctype, toplevel_bindings_p ());\n+\t}\n+\n       return 1;\n     }\n   else if (!DECL_NEEDED_P (vars))"}, {"sha": "91a4407be7f079a15c9b8c69b8d340c8582f5a01", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -369,7 +369,7 @@ build_eh_type_type_ref (type)\n }\n \n /* This routine is called to mark all the symbols representing runtime\n-   type functions in the exception table as haveing been referenced.\n+   type functions in the exception table as having been referenced.\n    This will make sure code is emitted for them. Called from finish_file. */\n void \n mark_all_runtime_matches () "}, {"sha": "c94fffed6297158214909aa6ae6191bb8c06059c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -3909,10 +3909,14 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \t  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n \t  TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (template_type);\n+\n+\t  /* A local class.  Make sure the decl gets registered properly.  */\n+\t  if (context == current_function_decl)\n+\t    pushtag (DECL_NAME (template), t, 0);\n \t}\n \n-      /* If we called start_enum above, this information will already\n-\t be set up.  */\n+      /* If we called start_enum or pushtag above, this information\n+\t will already be set up.  */\n       if (!TYPE_NAME (t))\n \t{\n \t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n@@ -7317,8 +7321,7 @@ tsubst_expr (t, args, complain, in_decl)\n     case TAG_DEFN:\n       prep_stmt (t);\n       t = TREE_TYPE (t);\n-      if (TREE_CODE (t) == ENUMERAL_TYPE)\n-\ttsubst (t, args, complain, NULL_TREE);\n+      tsubst (t, args, complain, NULL_TREE);\n       break;\n \n     default:"}, {"sha": "6ca817164c8df20a28dd08b6a0eb7811970a8f25", "filename": "gcc/cp/search.c", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae673f140351f3cb46dd7856c493a3ae52a7f15c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ae673f140351f3cb46dd7856c493a3ae52a7f15c", "patch": "@@ -103,8 +103,10 @@ static tree marked_new_vtablep PROTO((tree, void *));\n static tree unmarked_new_vtablep PROTO((tree, void *));\n static tree marked_pushdecls_p PROTO((tree, void *));\n static tree unmarked_pushdecls_p PROTO((tree, void *));\n+#if 0\n static tree dfs_debug_unmarkedp PROTO((tree, void *));\n static tree dfs_debug_mark PROTO((tree, void *));\n+#endif\n static tree dfs_find_vbases PROTO((tree, void *));\n static tree dfs_clear_vbase_slots PROTO((tree, void *));\n static tree dfs_init_vbase_pointers PROTO((tree, void *));\n@@ -2301,7 +2303,6 @@ unmarked_pushdecls_p (binfo, data)\n #if 0\n static int dfs_search_slot_nonempty_p (binfo) tree binfo;\n { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }\n-#endif\n \n static tree \n dfs_debug_unmarkedp (binfo, data) \n@@ -2311,6 +2312,7 @@ dfs_debug_unmarkedp (binfo, data)\n   return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n \t  ? binfo : NULL_TREE);\n }\n+#endif\n \n /* The worker functions for `dfs_walk'.  These do not need to\n    test anything (vis a vis marking) if they are paired with\n@@ -2351,63 +2353,37 @@ dfs_unmark_new_vtable (binfo) tree binfo;\n static void\n dfs_clear_search_slot (binfo) tree binfo;\n { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }\n-#endif\n \n+/* Keep this code around in case we later want to control debug info\n+   based on whether a type is \"used\".  Currently, we only suppress debug\n+   info if we can emit it with the vtable.  jason 1999-11-11) */\n static tree\n dfs_debug_mark (binfo, data)\n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n {\n   tree t = BINFO_TYPE (binfo);\n \n-  /* Use heuristic that if there are virtual functions,\n-     ignore until we see a non-inline virtual function.  */\n-  tree methods = CLASSTYPE_METHOD_VEC (t);\n-\n   CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n \n-  if (methods == 0)\n-    return NULL_TREE;\n-\n   /* If interface info is known, either we've already emitted the debug\n      info or we don't need to.  */\n   if (CLASSTYPE_INTERFACE_KNOWN (t))\n     return NULL_TREE;\n \n-  /* If debug info is requested from this context for this type, supply it.\n-     If debug info is requested from another context for this type,\n-     see if some third context can supply it.  */\n-  if (current_function_decl == NULL_TREE\n-      || DECL_CLASS_CONTEXT (current_function_decl) != t)\n-    {\n-      if (TREE_VEC_ELT (methods, 1))\n-\tmethods = TREE_VEC_ELT (methods, 1);\n-      else if (TREE_VEC_ELT (methods, 0))\n-\tmethods = TREE_VEC_ELT (methods, 0);\n-      else\n-\tmethods = TREE_VEC_ELT (methods, 2);\n-      methods = OVL_CURRENT (methods);\n-      while (methods)\n-\t{\n-\t  if (DECL_VINDEX (methods)\n-\t      && DECL_THIS_INLINE (methods) == 0\n-\t      && DECL_ABSTRACT_VIRTUAL_P (methods) == 0)\n-\t    {\n-\t      /* Somebody, somewhere is going to have to define this\n-\t\t virtual function.  When they do, they will provide\n-\t\t the debugging info.  */\n-\t      return NULL_TREE;\n-\t    }\n-\t  methods = TREE_CHAIN (methods);\n-\t}\n-    }\n+  /* If the class has virtual functions, we'll emit the debug info\n+     with the vtable.  */\n+  if (TYPE_VIRTUAL_P (t))\n+    return NULL_TREE;\n+\n   /* We cannot rely on some alien method to solve our problems,\n      so we must write out the debug info ourselves.  */\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n   rest_of_type_compilation (t, toplevel_bindings_p ());\n \n   return NULL_TREE;\n }\n+#endif\n \f\n struct vbase_info \n {\n@@ -2933,6 +2909,41 @@ get_vbase_types (type)\n   return vbase_types;\n }\n \f\n+/* Debug info for C++ classes can get very large; try to avoid\n+   emitting it everywhere.\n+\n+   As it happens, this optimization wins even when the target supports\n+   BINCL (though only slightly), so we always do it. */\n+\n+void\n+maybe_suppress_debug_info (t)\n+     tree t;\n+{\n+  /* We don't bother with this for dwarf1, which shouldn't be used for C++\n+     anyway.  */\n+  if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG\n+      || write_symbols == NO_DEBUG)\n+    return;\n+\n+  /* If we already know how we're handling this class, handle debug info\n+     the same way.  */\n+  if (CLASSTYPE_INTERFACE_ONLY (t))\n+    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n+  else if (CLASSTYPE_INTERFACE_KNOWN (t))\n+    /* Don't set it.  */;\n+  /* If the class has virtual functions, write out the debug info\n+     along with the vtable.  */\n+  else if (TYPE_VIRTUAL_P (t))\n+    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n+\n+  /* Otherwise, just emit the debug info normally.  */\n+}\n+\n+#if 0\n+/* Keep this code around in case we later want to control debug info\n+   based on whether a type is \"used\".  Currently, we only suppress debug\n+   info if we can emit it with the vtable.  jason 1999-11-11) */\n+\n /* If we want debug info for a type TYPE, make sure all its base types\n    are also marked as being potentially interesting.  This avoids\n    the problem of not writing any debug info for intermediate basetypes\n@@ -2952,10 +2963,9 @@ note_debug_info_needed (type)\n     return;\n \n   /* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n-     does not support name references between translation units.  Well, we\n-     could, but that would mean putting global labels in the debug output\n-     before each exported type and each of its functions and static data\n-     members.  */\n+     does not support name references between translation units.  It supports\n+     symbolic references between translation units, but only within a single\n+     executable or shared library.  */\n   if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG\n       || write_symbols == NO_DEBUG)\n     return;\n@@ -2970,6 +2980,7 @@ note_debug_info_needed (type)\n \tnote_debug_info_needed (ttype);\n     }\n }\n+#endif\n \f\n /* Subroutines of push_class_decls ().  */\n \n@@ -3333,7 +3344,9 @@ types_overlap_p (empty_type, next_type)\n   return oi.found_overlap;\n }\n \n-/* Given a vtable VAR, determine which binfo it comes from.  */\n+/* Given a vtable VAR, determine which binfo it comes from.\n+\n+   FIXME What about secondary vtables?  */\n \n tree\n binfo_for_vtable (var)"}]}