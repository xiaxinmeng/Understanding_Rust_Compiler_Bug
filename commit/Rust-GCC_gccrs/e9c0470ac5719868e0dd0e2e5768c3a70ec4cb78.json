{"sha": "e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljMDQ3MGFjNTcxOTg2OGUwZGQwZTJlNTc2OGMzYTcwZWM0Y2I3OA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-03-30T14:09:09Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-03-30T14:09:09Z"}, "message": "rx.md: Add peepholes and patterns to combine extending loads and simple arithmetic...\n\n\t* config/rx/rx.md: Add peepholes and patterns to combine\n\textending loads and simple arithmetic instructions.\n\t* config/rx/rx.h (ADJUST_INSN_LENGTH): Define.\n        * config/rx/rx-protos.h (rx_adjust_insn_length): Prototype.\n        * config/rx/rx.c (rx_is_legitimate_address): Allow QI and HI\n\tmodes to use pre-decrement and post-increment addressing.\n        (rx_is_restricted_memory_address): Add range checking of REG+INT\n\taddresses.\n        (rx_print_operand): Add support for %Q.\n        Fix handling of %Q.\n        (rx_memory_move_cost): Adjust cost of stores.\n        (rx_adjust_insn_length): New function.\n\nFrom-SVN: r171724", "tree": {"sha": "8f32c8dd7a17241af74ee0dfc5739af97d792ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f32c8dd7a17241af74ee0dfc5739af97d792ac3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a87e7abcb28cc53fb1be10b453d030a039de15e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a87e7abcb28cc53fb1be10b453d030a039de15e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a87e7abcb28cc53fb1be10b453d030a039de15e"}], "stats": {"total": 328, "additions": 299, "deletions": 29}, "files": [{"sha": "fb3cc9e708b69fd910ab160521ddeb4c1c684b45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "patch": "@@ -1,3 +1,18 @@\n+2011-03-30  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rx/rx.md: Add peepholes and patterns to combine\n+\textending loads and simple arithmetic instructions.\n+\t* config/rx/rx.h (ADJUST_INSN_LENGTH): Define.\n+        * config/rx/rx-protos.h (rx_adjust_insn_length): Prototype.\n+        * config/rx/rx.c (rx_is_legitimate_address): Allow QI and HI\n+\tmodes to use pre-decrement and post-increment addressing.\n+        (rx_is_restricted_memory_address): Add range checking of REG+INT\n+\taddresses.\n+        (rx_print_operand): Add support for %Q.\n+        Fix handling of %Q.\n+        (rx_memory_move_cost): Adjust cost of stores.\n+        (rx_adjust_insn_length): New function.\n+\n 2011-03-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/48305"}, {"sha": "17f60833e710d38d405029a3b783aae451b98b93", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "patch": "@@ -31,16 +31,17 @@ extern void\t\trx_expand_prologue (void);\n extern int\t\trx_initial_elimination_offset (int, int);\n \n #ifdef RTX_CODE\n+extern int\t\trx_adjust_insn_length (rtx, int);\n extern void             rx_emit_stack_popm (rtx *, bool);\n extern void             rx_emit_stack_pushm (rtx *);\n extern void\t\trx_expand_epilogue (bool);\n extern char *\t\trx_gen_move_template (rtx *, bool);\n extern bool\t\trx_is_legitimate_constant (rtx);\n extern bool\t\trx_is_restricted_memory_address (rtx, Mmode);\n+extern bool\t\trx_match_ccmode (rtx, Mmode);\n extern void\t\trx_notice_update_cc (rtx body, rtx insn);\n extern void\t\trx_split_cbranch (Mmode, Rcode, rtx, rtx, rtx);\n extern Mmode\t\trx_select_cc_mode (Rcode, rtx, rtx);\n-extern bool\t\trx_match_ccmode (rtx, Mmode);\n #endif\n \n #endif /* GCC_RX_PROTOS_H */"}, {"sha": "0ed4ee634d2be5b10c339a9b1ab2b1fe3cd9a2a7", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 142, "deletions": 20, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "patch": "@@ -86,7 +86,7 @@ rx_is_legitimate_address (Mmode mode, rtx x, bool strict ATTRIBUTE_UNUSED)\n     /* Register Indirect.  */\n     return true;\n \n-  if (GET_MODE_SIZE (mode) == 4\n+  if (GET_MODE_SIZE (mode) <= 4\n       && (GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC))\n     /* Pre-decrement Register Indirect or\n        Post-increment Register Indirect.  */\n@@ -117,7 +117,7 @@ rx_is_legitimate_address (Mmode mode, rtx x, bool strict ATTRIBUTE_UNUSED)\n \n \t    if (val < 0)\n \t      return false;\n-\t    \n+\n \t    switch (GET_MODE_SIZE (mode))\n \t      {\n \t      default: \n@@ -126,7 +126,7 @@ rx_is_legitimate_address (Mmode mode, rtx x, bool strict ATTRIBUTE_UNUSED)\n \t      case 1: factor = 1; break;\n \t      }\n \n-\t    if (val > (65535 * factor))\n+\t    if (val >= (0x10000 * factor))\n \t      return false;\n \t    return (val % factor) == 0;\n \t  }\n@@ -167,8 +167,6 @@ rx_is_legitimate_address (Mmode mode, rtx x, bool strict ATTRIBUTE_UNUSED)\n bool\n rx_is_restricted_memory_address (rtx mem, enum machine_mode mode)\n {\n-  rtx base, index;\n-\n   if (! rx_is_legitimate_address\n       (mode, mem, reload_in_progress || reload_completed))\n     return false;\n@@ -184,11 +182,18 @@ rx_is_restricted_memory_address (rtx mem, enum machine_mode mode)\n       return false;\n \n     case PLUS:\n-      /* Only allow REG+INT addressing.  */\n-      base = XEXP (mem, 0);\n-      index = XEXP (mem, 1);\n+      {\n+\trtx base, index;\n+\t\n+\t/* Only allow REG+INT addressing.  */\n+\tbase = XEXP (mem, 0);\n+\tindex = XEXP (mem, 1);\n \n-      return RX_REG_P (base) && CONST_INT_P (index);\n+\tif (! RX_REG_P (base) || ! CONST_INT_P (index))\n+\t  return false;\n+\n+\treturn IN_RANGE (INTVAL (index), 0, (0x10000 * GET_MODE_SIZE (mode)) - 1);\n+      }\n \n     case SYMBOL_REF:\n       /* Can happen when small data is being supported.\n@@ -387,11 +392,14 @@ rx_assemble_integer (rtx x, unsigned int size, int is_aligned)\n      %L  Print low part of a DImode register, integer or address.\n      %N  Print the negation of the immediate value.\n      %Q  If the operand is a MEM, then correctly generate\n-         register indirect or register relative addressing.  */\n+         register indirect or register relative addressing.\n+     %R  Like %Q but for zero-extending loads.  */\n \n static void\n rx_print_operand (FILE * file, rtx op, int letter)\n {\n+  bool unsigned_load = false;\n+\n   switch (letter)\n     {\n     case 'A':\n@@ -451,6 +459,7 @@ rx_print_operand (FILE * file, rtx op, int letter)\n \telse\n \t  {\n \t    unsigned int flags = flags_from_mode (mode);\n+\n \t    switch (code)\n \t      {\n \t      case LT:\n@@ -589,10 +598,15 @@ rx_print_operand (FILE * file, rtx op, int letter)\n       rx_print_integer (file, - INTVAL (op));\n       break;\n \n+    case 'R':\n+      gcc_assert (GET_MODE_SIZE (GET_MODE (op)) < 4);\n+      unsigned_load = true;\n+      /* Fall through.  */\n     case 'Q':\n       if (MEM_P (op))\n \t{\n \t  HOST_WIDE_INT offset;\n+\t  rtx mem = op;\n \n \t  op = XEXP (op, 0);\n \n@@ -627,22 +641,24 @@ rx_print_operand (FILE * file, rtx op, int letter)\n \t  rx_print_operand (file, op, 0);\n \t  fprintf (file, \"].\");\n \n-\t  switch (GET_MODE_SIZE (GET_MODE (op)))\n+\t  switch (GET_MODE_SIZE (GET_MODE (mem)))\n \t    {\n \t    case 1:\n-\t      gcc_assert (offset < 65535 * 1);\n-\t      fprintf (file, \"B\");\n+\t      gcc_assert (offset <= 65535 * 1);\n+\t      fprintf (file, unsigned_load ? \"UB\" : \"B\");\n \t      break;\n \t    case 2:\n \t      gcc_assert (offset % 2 == 0);\n-\t      gcc_assert (offset < 65535 * 2);\n-\t      fprintf (file, \"W\");\n+\t      gcc_assert (offset <= 65535 * 2);\n+\t      fprintf (file, unsigned_load ? \"UW\" : \"W\");\n \t      break;\n-\t    default:\n+\t    case 4:\n \t      gcc_assert (offset % 4 == 0);\n-\t      gcc_assert (offset < 65535 * 4);\n+\t      gcc_assert (offset <= 65535 * 4);\n \t      fprintf (file, \"L\");\n \t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n \t  break;\n \t}\n@@ -2449,8 +2465,7 @@ rx_is_legitimate_constant (rtx x)\n \n \tdefault:\n \t  /* FIXME: Can this ever happen ?  */\n-\t  abort ();\n-\t  return false;\n+\t  gcc_unreachable ();\n \t}\n       break;\n       \n@@ -2593,7 +2608,7 @@ rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n static int\n rx_memory_move_cost (enum machine_mode mode, reg_class_t regclass, bool in)\n {\n-  return 2 + memory_move_secondary_cost (mode, regclass, in);\n+  return (in ? 2 : 0) + memory_move_secondary_cost (mode, regclass, in);\n }\n \n /* Convert a CC_MODE to the set of flags that it represents.  */\n@@ -2778,6 +2793,113 @@ rx_max_skip_for_label (rtx lab)\n     return opsize - 1;\n   return 0;\n }\n+\n+/* Compute the real length of the extending load-and-op instructions.  */\n+\n+int\n+rx_adjust_insn_length (rtx insn, int current_length)\n+{\n+  rtx extend, mem, offset;\n+  bool zero;\n+  int factor;\n+\n+  switch (INSN_CODE (insn))\n+    {\n+    default:\n+      return current_length;\n+\n+    case CODE_FOR_plussi3_zero_extendhi:\n+    case CODE_FOR_andsi3_zero_extendhi:\n+    case CODE_FOR_iorsi3_zero_extendhi:\n+    case CODE_FOR_xorsi3_zero_extendhi:\n+    case CODE_FOR_divsi3_zero_extendhi:\n+    case CODE_FOR_udivsi3_zero_extendhi:\n+    case CODE_FOR_minussi3_zero_extendhi:\n+    case CODE_FOR_smaxsi3_zero_extendhi:\n+    case CODE_FOR_sminsi3_zero_extendhi:\n+    case CODE_FOR_multsi3_zero_extendhi:\n+    case CODE_FOR_comparesi3_zero_extendqi:\n+      zero = true;\n+      factor = 2;\n+      break;\n+\n+    case CODE_FOR_plussi3_sign_extendhi:\n+    case CODE_FOR_andsi3_sign_extendhi:\n+    case CODE_FOR_iorsi3_sign_extendhi:\n+    case CODE_FOR_xorsi3_sign_extendhi:\n+    case CODE_FOR_divsi3_sign_extendhi:\n+    case CODE_FOR_udivsi3_sign_extendhi:\n+    case CODE_FOR_minussi3_sign_extendhi:\n+    case CODE_FOR_smaxsi3_sign_extendhi:\n+    case CODE_FOR_sminsi3_sign_extendhi:\n+    case CODE_FOR_multsi3_sign_extendhi:\n+    case CODE_FOR_comparesi3_zero_extendhi:\n+      zero = false;\n+      factor = 2;\n+      break;\n+      \n+    case CODE_FOR_plussi3_zero_extendqi:\n+    case CODE_FOR_andsi3_zero_extendqi:\n+    case CODE_FOR_iorsi3_zero_extendqi:\n+    case CODE_FOR_xorsi3_zero_extendqi:\n+    case CODE_FOR_divsi3_zero_extendqi:\n+    case CODE_FOR_udivsi3_zero_extendqi:\n+    case CODE_FOR_minussi3_zero_extendqi:\n+    case CODE_FOR_smaxsi3_zero_extendqi:\n+    case CODE_FOR_sminsi3_zero_extendqi:\n+    case CODE_FOR_multsi3_zero_extendqi:\n+    case CODE_FOR_comparesi3_sign_extendqi:\n+      zero = true;\n+      factor = 1;\n+      break;\n+      \n+    case CODE_FOR_plussi3_sign_extendqi:\n+    case CODE_FOR_andsi3_sign_extendqi:\n+    case CODE_FOR_iorsi3_sign_extendqi:\n+    case CODE_FOR_xorsi3_sign_extendqi:\n+    case CODE_FOR_divsi3_sign_extendqi:\n+    case CODE_FOR_udivsi3_sign_extendqi:\n+    case CODE_FOR_minussi3_sign_extendqi:\n+    case CODE_FOR_smaxsi3_sign_extendqi:\n+    case CODE_FOR_sminsi3_sign_extendqi:\n+    case CODE_FOR_multsi3_sign_extendqi:\n+    case CODE_FOR_comparesi3_sign_extendhi:\n+      zero = false;\n+      factor = 1;\n+      break;\n+    }      \n+\n+  /* We are expecting: (SET (REG) (<OP> (REG) (<EXTEND> (MEM)))).  */\n+  extend = single_set (insn);\n+  gcc_assert (extend != NULL_RTX);\n+\n+  extend = SET_SRC (extend);\n+  if (GET_CODE (XEXP (extend, 0)) == ZERO_EXTEND\n+      || GET_CODE (XEXP (extend, 0)) == SIGN_EXTEND)\n+    extend = XEXP (extend, 0);\n+  else\n+    extend = XEXP (extend, 1);\n+\n+  gcc_assert ((zero && (GET_CODE (extend) == ZERO_EXTEND))\n+\t      || (! zero && (GET_CODE (extend) == SIGN_EXTEND)));\n+    \n+  mem = XEXP (extend, 0);\n+  gcc_checking_assert (MEM_P (mem));\n+  if (REG_P (XEXP (mem, 0)))\n+    return (zero && factor == 1) ? 2 : 3;\n+\n+  /* We are expecting: (MEM (PLUS (REG) (CONST_INT))).  */\n+  gcc_checking_assert (GET_CODE (XEXP (mem, 0)) == PLUS);\n+  gcc_checking_assert (REG_P (XEXP (XEXP (mem, 0), 0)));\n+\n+  offset = XEXP (XEXP (mem, 0), 1);\n+  gcc_checking_assert (GET_CODE (offset) == CONST_INT);\n+\n+  if (IN_RANGE (INTVAL (offset), 0, 255 * factor))\n+    return (zero && factor == 1) ? 3 : 4;\n+\n+  return (zero && factor == 1) ? 4 : 5;\n+}\n \f\n #undef  TARGET_ASM_JUMP_ALIGN_MAX_SKIP\n #define TARGET_ASM_JUMP_ALIGN_MAX_SKIP\t\t\trx_max_skip_for_label"}, {"sha": "14b13d955598220675e0f9598a19e03ee1c3450b", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "patch": "@@ -630,3 +630,10 @@ typedef unsigned int CUMULATIVE_ARGS;\n #define REGISTER_MOVE_COST(MODE,FROM,TO) 2\n \n #define SELECT_CC_MODE(OP,X,Y)  rx_select_cc_mode(OP, X, Y)\n+\n+#define ADJUST_INSN_LENGTH(INSN,LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      (LENGTH) = rx_adjust_insn_length ((INSN), (LENGTH));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "6ff3a1e7e2ab6dc5fb89c6dd14706113823b508a", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 133, "deletions": 8, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=e9c0470ac5719868e0dd0e2e5768c3a70ec4cb78", "patch": "@@ -1545,6 +1545,139 @@\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n \f\n+;; A set of peepholes to catch extending loads followed by arithmetic operations.\n+;; We use iterators where possible to reduce the amount of typing and hence the\n+;; possibilities for typos.\n+\n+(define_code_iterator extend_types [(zero_extend \"\") (sign_extend \"\")])\n+(define_code_attr     letter       [(zero_extend \"R\") (sign_extend \"Q\")])\n+\n+(define_code_iterator memex_commutative [(plus \"\") (and \"\") (ior \"\") (xor \"\")])\n+(define_code_iterator memex_noncomm     [(div \"\") (udiv \"\") (minus \"\")])\n+(define_code_iterator memex_nocc        [(smax \"\") (smin \"\") (mult \"\")])\n+\n+(define_code_attr     op                [(plus \"add\") (and \"and\") (div \"div\") (udiv \"divu\") (smax \"max\") (smin \"min\") (mult \"mul\") (ior \"or\") (minus \"sub\") (xor \"xor\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (parallel [(set (match_operand:SI                    2 \"register_operand\")\n+\t\t   (memex_commutative:SI (match_dup 0)\n+\t\t\t\t\t (match_dup 2)))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(parallel [(set:SI (match_dup 2)\n+\t\t      (memex_commutative:SI (match_dup 2)\n+\t\t\t\t\t    (extend_types:SI (match_dup 1))))\n+\t      (clobber (reg:CC CC_REG))])]\n+)\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (parallel [(set (match_operand:SI                    2 \"register_operand\")\n+\t\t   (memex_commutative:SI (match_dup 2)\n+\t\t\t\t\t (match_dup 0)))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(parallel [(set:SI (match_dup 2)\n+\t\t      (memex_commutative:SI (match_dup 2)\n+\t\t\t\t\t    (extend_types:SI (match_dup 1))))\n+\t      (clobber (reg:CC CC_REG))])]\n+)\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (parallel [(set (match_operand:SI                    2 \"register_operand\")\n+\t\t   (memex_noncomm:SI (match_dup 2)\n+\t\t\t\t     (match_dup 0)))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(parallel [(set:SI (match_dup 2)\n+\t\t      (memex_noncomm:SI (match_dup 2)\n+\t\t\t\t\t(extend_types:SI (match_dup 1))))\n+\t      (clobber (reg:CC CC_REG))])]\n+)\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (set (match_operand:SI                               2 \"register_operand\")\n+\t(memex_nocc:SI (match_dup 0)\n+\t\t       (match_dup 2)))]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(set:SI (match_dup 2)\n+\t   (memex_nocc:SI (match_dup 2)\n+\t\t\t  (extend_types:SI (match_dup 1))))]\n+)\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (set (match_operand:SI                               2 \"register_operand\")\n+\t(memex_nocc:SI (match_dup 2)\n+\t\t       (match_dup 0)))]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(set:SI (match_dup 2)\n+\t   (memex_nocc:SI (match_dup 2)\n+\t\t\t  (extend_types:SI (match_dup 1))))]\n+)\n+\n+(define_insn \"<memex_commutative:code>si3_<extend_types:code><small_int_modes:mode>\"\n+  [(set (match_operand:SI                                                     0 \"register_operand\" \"=r\")\n+\t(memex_commutative:SI (match_operand:SI                               1 \"register_operand\" \"%0\")\n+ \t\t              (extend_types:SI (match_operand:small_int_modes 2 \"rx_restricted_mem_operand\" \"Q\"))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"<memex_commutative:op>\\t%<extend_types:letter>2, %0\"\n+  [(set_attr \"timings\" \"33\")\n+   (set_attr \"length\"  \"5\")] ;; This length is corrected in rx_adjust_insn_length\n+)\n+\n+(define_insn \"<memex_noncomm:code>si3_<extend_types:code><small_int_modes:mode>\"\n+  [(set (match_operand:SI                                                 0 \"register_operand\" \"=r\")\n+\t(memex_noncomm:SI (match_operand:SI                               1 \"register_operand\" \"0\")\n+                          (extend_types:SI (match_operand:small_int_modes 2 \"rx_restricted_mem_operand\" \"Q\"))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"<memex_noncomm:op>\\t%<extend_types:letter>2, %0\"\n+  [(set_attr \"timings\" \"33\")\n+   (set_attr \"length\"  \"5\")] ;; This length is corrected in rx_adjust_insn_length\n+)\n+\n+(define_insn \"<memex_nocc:code>si3_<extend_types:code><small_int_modes:mode>\"\n+  [(set (match_operand:SI                                              0 \"register_operand\" \"=r\")\n+\t(memex_nocc:SI (match_operand:SI                               1 \"register_operand\" \"%0\")\n+\t\t       (extend_types:SI (match_operand:small_int_modes 2 \"rx_restricted_mem_operand\" \"Q\"))))]\n+  \"\"\n+  \"<memex_nocc:op>\\t%<extend_types:letter>2, %0\"\n+  [(set_attr \"timings\" \"33\")\n+   (set_attr \"length\"  \"5\")] ;; This length is corrected in rx_adjust_insn_length\n+)\n+\n+(define_peephole2\n+  [(set (match_operand:SI                               0 \"register_operand\")\n+\t(extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\")))\n+   (set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI                   2 \"register_operand\")\n+\t\t    (match_dup 0)))]\n+  \"peep2_regno_dead_p (2, REGNO (operands[0]))\"\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_dup 2)\n+\t\t    (extend_types:SI (match_dup 1))))]\n+)\n+\n+(define_insn \"comparesi3_<extend_types:code><small_int_modes:mode>\"\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI                               0 \"register_operand\" \"=r\")\n+\t\t    (extend_types:SI (match_operand:small_int_modes 1 \"rx_restricted_mem_operand\" \"Q\"))))]\n+  \"\"\n+  \"cmp\\t%<extend_types:letter>1, %0\"\n+  [(set_attr \"timings\" \"33\")\n+   (set_attr \"length\"  \"5\")] ;; This length is corrected in rx_adjust_insn_length\n+)\n+\f\n ;; Floating Point Instructions\n \n (define_insn \"addsf3\"\n@@ -1897,14 +2030,6 @@\n     rtx addr2 = gen_rtx_REG (SImode, 2);\n     rtx len   = gen_rtx_REG (SImode, 3);\n \n-    /* Do not use when the source or destination are volatile - the SMOVF\n-       instruction will read and write in word sized blocks, which may be\n-       outside of the valid address range.  */\n-    if (MEM_P (operands[0]) && MEM_VOLATILE_P (operands[0]))\n-      FAIL;\n-    if (MEM_P (operands[1]) && MEM_VOLATILE_P (operands[1]))\n-      FAIL;\n-\n     if (REG_P (operands[0]) && (REGNO (operands[0]) == 2\n \t\t\t\t      || REGNO (operands[0]) == 3))\n       FAIL;"}]}