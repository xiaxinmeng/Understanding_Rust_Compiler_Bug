{"sha": "dfe1da2381373d3b905053166d49fbaf8b0082e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZlMWRhMjM4MTM3M2QzYjkwNTA1MzE2NmQ0OWZiYWY4YjAwODJlNg==", "commit": {"author": {"name": "Jackson Woodruff", "email": "jackson.woodruff@arm.com", "date": "2018-05-22T15:35:06Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-05-22T15:35:06Z"}, "message": "[AArch64] Merge stores of D-register values with different modes\n\nThis patch merges loads and stores from D-registers that are of different modes.\n\nCode like this:\n\n    typedef int __attribute__((vector_size(8))) vec;\n    struct pair\n    {\n      vec v;\n      double d;\n    }\n\nNow generates a store pair instruction:\n\n    void\n    assign (struct pair *p, vec v)\n    {\n      p->v = v;\n      p->d = 1.0;\n    }\n\nWhereas previously it generated two `str` instructions.\n\nThis patch also merges storing of double zero values with\nlong integer values:\n\n    struct pair\n    {\n      long long l;\n      double d;\n    }\n\n    void\n    foo (struct pair *p)\n    {\n      p->l = 10;\n      p->d = 0.0;\n    }\n\nNow generates a single store pair instruction rather than two `str` instructions.\n\nThe patch basically generalises the mode iterators on the patterns in aarch64.md\nand the peepholes in aarch64-ldpstp.md to take all combinations of pairs of modes\nso, while it may be a large-ish patch, it does fairly mechanical stuff.\n\n2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/aarch64/aarch64.md: New patterns to generate stp\n\tand ldp.\n\t(store_pair_sw, store_pair_dw): New patterns to generate stp for\n\tsingle words and double words.\n\t(load_pair_sw, load_pair_dw): Likewise.\n\t(store_pair_sf, store_pair_df, store_pair_si, store_pair_di):\n\tDelete.\n\t(load_pair_sf, load_pair_df, load_pair_si, load_pair_di):\n\tDelete.\n\t* config/aarch64/aarch64-ldpstp.md: Modify peephole\n\tfor different mode ldpstp and add peephole for merged zero stores.\n\tLikewise for loads.\n\t* config/aarch64/aarch64.c (aarch64_operands_ok_for_ldpstp):\n\tAdd size check.\n\t(aarch64_gen_store_pair): Rename calls to match new patterns.\n\t(aarch64_gen_load_pair): Rename calls to match new patterns.\n\t* config/aarch64/aarch64-simd.md (load_pair<mode>): Rename to...\n\t(load_pair<DREG:mode><DREG2:mode>): ... This.\n\t(store_pair<mode>): Rename to...\n\t(vec_store_pair<DREG:mode><DREG2:mode>): ... This.\n\t* config/aarch64/iterators.md (DREG, DREG2, DX2, SX, SX2, DSX):\n\tNew mode iterators.\n\t(V_INT_EQUIV): Handle SImode.\n\t* config/aarch64/predicates.md (aarch64_reg_zero_or_fp_zero):\n\tNew predicate.\n\n\t* gcc.target/aarch64/ldp_stp_6.c: New.\n\t* gcc.target/aarch64/ldp_stp_7.c: New.\n\t* gcc.target/aarch64/ldp_stp_8.c: New.\n\nCo-Authored-By: Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n\nFrom-SVN: r260538", "tree": {"sha": "1be999111a574c3f56ae048a2312ed208220c725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1be999111a574c3f56ae048a2312ed208220c725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfe1da2381373d3b905053166d49fbaf8b0082e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe1da2381373d3b905053166d49fbaf8b0082e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe1da2381373d3b905053166d49fbaf8b0082e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe1da2381373d3b905053166d49fbaf8b0082e6/comments", "author": null, "committer": null, "parents": [{"sha": "9f855c10d6be14e4ac73fc55625d4799ca939cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f855c10d6be14e4ac73fc55625d4799ca939cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f855c10d6be14e4ac73fc55625d4799ca939cf8"}], "stats": {"total": 389, "additions": 256, "deletions": 133}, "files": [{"sha": "5fca480bcb06d067cdd19e8c27fb85854db8413c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -1,3 +1,32 @@\n+2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n+            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.md: New patterns to generate stp\n+\tand ldp.\n+\t(store_pair_sw, store_pair_dw): New patterns to generate stp for\n+\tsingle words and double words.\n+\t(load_pair_sw, load_pair_dw): Likewise.\n+\t(store_pair_sf, store_pair_df, store_pair_si, store_pair_di):\n+\tDelete.\n+\t(load_pair_sf, load_pair_df, load_pair_si, load_pair_di):\n+\tDelete.\n+\t* config/aarch64/aarch64-ldpstp.md: Modify peephole\n+\tfor different mode ldpstp and add peephole for merged zero stores.\n+\tLikewise for loads.\n+\t* config/aarch64/aarch64.c (aarch64_operands_ok_for_ldpstp):\n+\tAdd size check.\n+\t(aarch64_gen_store_pair): Rename calls to match new patterns.\n+\t(aarch64_gen_load_pair): Rename calls to match new patterns.\n+\t* config/aarch64/aarch64-simd.md (load_pair<mode>): Rename to...\n+\t(load_pair<DREG:mode><DREG2:mode>): ... This.\n+\t(store_pair<mode>): Rename to...\n+\t(vec_store_pair<DREG:mode><DREG2:mode>): ... This.\n+\t* config/aarch64/iterators.md (DREG, DREG2, DX2, SX, SX2, DSX):\n+\tNew mode iterators.\n+\t(V_INT_EQUIV): Handle SImode.\n+\t* config/aarch64/predicates.md (aarch64_reg_zero_or_fp_zero):\n+\tNew predicate.\n+\n 2018-05-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85826"}, {"sha": "f6fe8a6a93b5466723e3ed6b892e0ec1e67ee89d", "filename": "gcc/config/aarch64/aarch64-ldpstp.md", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -99,11 +99,11 @@\n })\n \n (define_peephole2\n-  [(set (match_operand:VD 0 \"register_operand\" \"\")\n-\t(match_operand:VD 1 \"aarch64_mem_pair_operand\" \"\"))\n-   (set (match_operand:VD 2 \"register_operand\" \"\")\n-\t(match_operand:VD 3 \"memory_operand\" \"\"))]\n-  \"aarch64_operands_ok_for_ldpstp (operands, true, <MODE>mode)\"\n+  [(set (match_operand:DREG 0 \"register_operand\" \"\")\n+\t(match_operand:DREG 1 \"aarch64_mem_pair_operand\" \"\"))\n+   (set (match_operand:DREG2 2 \"register_operand\" \"\")\n+\t(match_operand:DREG2 3 \"memory_operand\" \"\"))]\n+  \"aarch64_operands_ok_for_ldpstp (operands, true, <DREG:MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n@@ -119,11 +119,12 @@\n })\n \n (define_peephole2\n-  [(set (match_operand:VD 0 \"aarch64_mem_pair_operand\" \"\")\n-\t(match_operand:VD 1 \"register_operand\" \"\"))\n-   (set (match_operand:VD 2 \"memory_operand\" \"\")\n-\t(match_operand:VD 3 \"register_operand\" \"\"))]\n-  \"TARGET_SIMD && aarch64_operands_ok_for_ldpstp (operands, false, <MODE>mode)\"\n+  [(set (match_operand:DREG 0 \"aarch64_mem_pair_operand\" \"\")\n+\t(match_operand:DREG 1 \"register_operand\" \"\"))\n+   (set (match_operand:DREG2 2 \"memory_operand\" \"\")\n+\t(match_operand:DREG2 3 \"register_operand\" \"\"))]\n+  \"TARGET_SIMD\n+   && aarch64_operands_ok_for_ldpstp (operands, false, <DREG:MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n@@ -138,7 +139,6 @@\n     }\n })\n \n-\n ;; Handle sign/zero extended consecutive load/store.\n \n (define_peephole2\n@@ -181,6 +181,36 @@\n     }\n })\n \n+;; Handle storing of a floating point zero with integer data.\n+;; This handles cases like:\n+;;   struct pair { int a; float b; }\n+;;\n+;;   p->a = 1;\n+;;   p->b = 0.0;\n+;;\n+;; We can match modes that won't work for a stp instruction\n+;; as aarch64_operands_ok_for_ldpstp checks that the modes are\n+;; compatible.\n+(define_peephole2\n+  [(set (match_operand:DSX 0 \"aarch64_mem_pair_operand\" \"\")\n+\t(match_operand:DSX 1 \"aarch64_reg_zero_or_fp_zero\" \"\"))\n+   (set (match_operand:<FCVT_TARGET> 2 \"memory_operand\" \"\")\n+\t(match_operand:<FCVT_TARGET> 3 \"aarch64_reg_zero_or_fp_zero\" \"\"))]\n+  \"aarch64_operands_ok_for_ldpstp (operands, false, <V_INT_EQUIV>mode)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (set (match_dup 2) (match_dup 3))])]\n+{\n+  rtx base, offset_1, offset_2;\n+\n+  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n+  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n+  if (INTVAL (offset_1) > INTVAL (offset_2))\n+    {\n+      std::swap (operands[0], operands[2]);\n+      std::swap (operands[1], operands[3]);\n+    }\n+})\n+\n ;; Handle consecutive load/store whose offset is out of the range\n ;; supported by ldp/ldpsw/stp.  We firstly adjust offset in a scratch\n ;; register, then merge them into ldp/ldpsw/stp by using the adjusted"}, {"sha": "daaefdab8d0663d7610681de9ebdfd1e69cd4c8f", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -177,30 +177,30 @@\n   [(set_attr \"type\" \"neon_store1_1reg<q>\")]\n )\n \n-(define_insn \"load_pair<mode>\"\n-  [(set (match_operand:VD 0 \"register_operand\" \"=w\")\n-\t(match_operand:VD 1 \"aarch64_mem_pair_operand\" \"Ump\"))\n-   (set (match_operand:VD 2 \"register_operand\" \"=w\")\n-\t(match_operand:VD 3 \"memory_operand\" \"m\"))]\n+(define_insn \"load_pair<DREG:mode><DREG2:mode>\"\n+  [(set (match_operand:DREG 0 \"register_operand\" \"=w\")\n+\t(match_operand:DREG 1 \"aarch64_mem_pair_operand\" \"Ump\"))\n+   (set (match_operand:DREG2 2 \"register_operand\" \"=w\")\n+\t(match_operand:DREG2 3 \"memory_operand\" \"m\"))]\n   \"TARGET_SIMD\n    && rtx_equal_p (XEXP (operands[3], 0),\n \t\t   plus_constant (Pmode,\n \t\t\t\t  XEXP (operands[1], 0),\n-\t\t\t\t  GET_MODE_SIZE (<MODE>mode)))\"\n+\t\t\t\t  GET_MODE_SIZE (<DREG:MODE>mode)))\"\n   \"ldp\\\\t%d0, %d2, %1\"\n   [(set_attr \"type\" \"neon_ldp\")]\n )\n \n-(define_insn \"store_pair<mode>\"\n-  [(set (match_operand:VD 0 \"aarch64_mem_pair_operand\" \"=Ump\")\n-\t(match_operand:VD 1 \"register_operand\" \"w\"))\n-   (set (match_operand:VD 2 \"memory_operand\" \"=m\")\n-\t(match_operand:VD 3 \"register_operand\" \"w\"))]\n+(define_insn \"vec_store_pair<DREG:mode><DREG2:mode>\"\n+  [(set (match_operand:DREG 0 \"aarch64_mem_pair_operand\" \"=Ump\")\n+\t(match_operand:DREG 1 \"register_operand\" \"w\"))\n+   (set (match_operand:DREG2 2 \"memory_operand\" \"=m\")\n+\t(match_operand:DREG2 3 \"register_operand\" \"w\"))]\n   \"TARGET_SIMD\n    && rtx_equal_p (XEXP (operands[2], 0),\n \t\t   plus_constant (Pmode,\n \t\t\t\t  XEXP (operands[0], 0),\n-\t\t\t\t  GET_MODE_SIZE (<MODE>mode)))\"\n+\t\t\t\t  GET_MODE_SIZE (<DREG:MODE>mode)))\"\n   \"stp\\\\t%d1, %d3, %0\"\n   [(set_attr \"type\" \"neon_stp\")]\n )"}, {"sha": "b75a588eb9aa49b1796161d34494d452a6742e4d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -4279,10 +4279,10 @@ aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n   switch (mode)\n     {\n     case E_DImode:\n-      return gen_store_pairdi (mem1, reg1, mem2, reg2);\n+      return gen_store_pair_dw_didi (mem1, reg1, mem2, reg2);\n \n     case E_DFmode:\n-      return gen_store_pairdf (mem1, reg1, mem2, reg2);\n+      return gen_store_pair_dw_dfdf (mem1, reg1, mem2, reg2);\n \n     default:\n       gcc_unreachable ();\n@@ -4299,10 +4299,10 @@ aarch64_gen_load_pair (machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n   switch (mode)\n     {\n     case E_DImode:\n-      return gen_load_pairdi (reg1, mem1, reg2, mem2);\n+      return gen_load_pair_dw_didi (reg1, mem1, reg2, mem2);\n \n     case E_DFmode:\n-      return gen_load_pairdf (reg1, mem1, reg2, mem2);\n+      return gen_load_pair_dw_dfdf (reg1, mem1, reg2, mem2);\n \n     default:\n       gcc_unreachable ();\n@@ -16853,6 +16853,10 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n   if (!rtx_equal_p (base_1, base_2))\n     return false;\n \n+  /* The operands must be of the same size.  */\n+  gcc_assert (known_eq (GET_MODE_SIZE (GET_MODE (mem_1)),\n+\t\t\t GET_MODE_SIZE (GET_MODE (mem_2))));\n+\n   offval_1 = INTVAL (offset_1);\n   offval_2 = INTVAL (offset_2);\n   /* We should only be trying this for fixed-sized modes.  There is no"}, {"sha": "8a894f8ac00f0fc76cc9f1fc9f0c17b429482db8", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 38, "deletions": 105, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -1307,141 +1307,74 @@\n \n ;; Operands 1 and 3 are tied together by the final condition; so we allow\n ;; fairly lax checking on the second memory operation.\n-(define_insn \"load_pairsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,w\")\n-\t(match_operand:SI 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r,w\")\n-\t(match_operand:SI 3 \"memory_operand\" \"m,m\"))]\n-  \"rtx_equal_p (XEXP (operands[3], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[1], 0),\n-\t\t\t       GET_MODE_SIZE (SImode)))\"\n+(define_insn \"load_pair_sw_<SX:mode><SX2:mode>\"\n+  [(set (match_operand:SX 0 \"register_operand\" \"=r,w\")\n+\t(match_operand:SX 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n+   (set (match_operand:SX2 2 \"register_operand\" \"=r,w\")\n+\t(match_operand:SX2 3 \"memory_operand\" \"m,m\"))]\n+   \"rtx_equal_p (XEXP (operands[3], 0),\n+\t\t plus_constant (Pmode,\n+\t\t\t\tXEXP (operands[1], 0),\n+\t\t\t\tGET_MODE_SIZE (<SX:MODE>mode)))\"\n   \"@\n    ldp\\\\t%w0, %w2, %1\n    ldp\\\\t%s0, %s2, %1\"\n   [(set_attr \"type\" \"load_8,neon_load1_2reg\")\n    (set_attr \"fp\" \"*,yes\")]\n )\n \n-(define_insn \"load_pairdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,w\")\n-\t(match_operand:DI 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"=r,w\")\n-\t(match_operand:DI 3 \"memory_operand\" \"m,m\"))]\n-  \"rtx_equal_p (XEXP (operands[3], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[1], 0),\n-\t\t\t       GET_MODE_SIZE (DImode)))\"\n+;; Storing different modes that can still be merged\n+(define_insn \"load_pair_dw_<DX:mode><DX2:mode>\"\n+  [(set (match_operand:DX 0 \"register_operand\" \"=r,w\")\n+\t(match_operand:DX 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n+   (set (match_operand:DX2 2 \"register_operand\" \"=r,w\")\n+\t(match_operand:DX2 3 \"memory_operand\" \"m,m\"))]\n+   \"rtx_equal_p (XEXP (operands[3], 0),\n+\t\t plus_constant (Pmode,\n+\t\t\t\tXEXP (operands[1], 0),\n+\t\t\t\tGET_MODE_SIZE (<DX:MODE>mode)))\"\n   \"@\n    ldp\\\\t%x0, %x2, %1\n    ldp\\\\t%d0, %d2, %1\"\n   [(set_attr \"type\" \"load_16,neon_load1_2reg\")\n    (set_attr \"fp\" \"*,yes\")]\n )\n \n-\n ;; Operands 0 and 2 are tied together by the final condition; so we allow\n ;; fairly lax checking on the second memory operation.\n-(define_insn \"store_pairsi\"\n-  [(set (match_operand:SI 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n-\t(match_operand:SI 1 \"aarch64_reg_or_zero\" \"rZ,w\"))\n-   (set (match_operand:SI 2 \"memory_operand\" \"=m,m\")\n-\t(match_operand:SI 3 \"aarch64_reg_or_zero\" \"rZ,w\"))]\n-  \"rtx_equal_p (XEXP (operands[2], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[0], 0),\n-\t\t\t       GET_MODE_SIZE (SImode)))\"\n+(define_insn \"store_pair_sw_<SX:mode><SX2:mode>\"\n+  [(set (match_operand:SX 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n+\t(match_operand:SX 1 \"aarch64_reg_zero_or_fp_zero\" \"rYZ,w\"))\n+   (set (match_operand:SX2 2 \"memory_operand\" \"=m,m\")\n+\t(match_operand:SX2 3 \"aarch64_reg_zero_or_fp_zero\" \"rYZ,w\"))]\n+   \"rtx_equal_p (XEXP (operands[2], 0),\n+\t\t plus_constant (Pmode,\n+\t\t\t\tXEXP (operands[0], 0),\n+\t\t\t\tGET_MODE_SIZE (<SX:MODE>mode)))\"\n   \"@\n    stp\\\\t%w1, %w3, %0\n    stp\\\\t%s1, %s3, %0\"\n   [(set_attr \"type\" \"store_8,neon_store1_2reg\")\n    (set_attr \"fp\" \"*,yes\")]\n )\n \n-(define_insn \"store_pairdi\"\n-  [(set (match_operand:DI 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n-\t(match_operand:DI 1 \"aarch64_reg_or_zero\" \"rZ,w\"))\n-   (set (match_operand:DI 2 \"memory_operand\" \"=m,m\")\n-\t(match_operand:DI 3 \"aarch64_reg_or_zero\" \"rZ,w\"))]\n-  \"rtx_equal_p (XEXP (operands[2], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[0], 0),\n-\t\t\t       GET_MODE_SIZE (DImode)))\"\n+;; Storing different modes that can still be merged\n+(define_insn \"store_pair_dw_<DX:mode><DX2:mode>\"\n+  [(set (match_operand:DX 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n+\t(match_operand:DX 1 \"aarch64_reg_zero_or_fp_zero\" \"rYZ,w\"))\n+   (set (match_operand:DX2 2 \"memory_operand\" \"=m,m\")\n+\t(match_operand:DX2 3 \"aarch64_reg_zero_or_fp_zero\" \"rYZ,w\"))]\n+   \"rtx_equal_p (XEXP (operands[2], 0),\n+\t\t plus_constant (Pmode,\n+\t\t\t\tXEXP (operands[0], 0),\n+\t\t\t\tGET_MODE_SIZE (<DX:MODE>mode)))\"\n   \"@\n    stp\\\\t%x1, %x3, %0\n    stp\\\\t%d1, %d3, %0\"\n   [(set_attr \"type\" \"store_16,neon_store1_2reg\")\n    (set_attr \"fp\" \"*,yes\")]\n )\n \n-;; Operands 1 and 3 are tied together by the final condition; so we allow\n-;; fairly lax checking on the second memory operation.\n-(define_insn \"load_pairsf\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=w,r\")\n-\t(match_operand:SF 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n-   (set (match_operand:SF 2 \"register_operand\" \"=w,r\")\n-\t(match_operand:SF 3 \"memory_operand\" \"m,m\"))]\n-  \"rtx_equal_p (XEXP (operands[3], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[1], 0),\n-\t\t\t       GET_MODE_SIZE (SFmode)))\"\n-  \"@\n-   ldp\\\\t%s0, %s2, %1\n-   ldp\\\\t%w0, %w2, %1\"\n-  [(set_attr \"type\" \"neon_load1_2reg,load_8\")\n-   (set_attr \"fp\" \"yes,*\")]\n-)\n-\n-(define_insn \"load_pairdf\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=w,r\")\n-\t(match_operand:DF 1 \"aarch64_mem_pair_operand\" \"Ump,Ump\"))\n-   (set (match_operand:DF 2 \"register_operand\" \"=w,r\")\n-\t(match_operand:DF 3 \"memory_operand\" \"m,m\"))]\n-  \"rtx_equal_p (XEXP (operands[3], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[1], 0),\n-\t\t\t       GET_MODE_SIZE (DFmode)))\"\n-  \"@\n-   ldp\\\\t%d0, %d2, %1\n-   ldp\\\\t%x0, %x2, %1\"\n-  [(set_attr \"type\" \"neon_load1_2reg,load_16\")\n-   (set_attr \"fp\" \"yes,*\")]\n-)\n-\n-;; Operands 0 and 2 are tied together by the final condition; so we allow\n-;; fairly lax checking on the second memory operation.\n-(define_insn \"store_pairsf\"\n-  [(set (match_operand:SF 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n-\t(match_operand:SF 1 \"aarch64_reg_or_fp_zero\" \"w,rY\"))\n-   (set (match_operand:SF 2 \"memory_operand\" \"=m,m\")\n-\t(match_operand:SF 3 \"aarch64_reg_or_fp_zero\" \"w,rY\"))]\n-  \"rtx_equal_p (XEXP (operands[2], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[0], 0),\n-\t\t\t       GET_MODE_SIZE (SFmode)))\"\n-  \"@\n-   stp\\\\t%s1, %s3, %0\n-   stp\\\\t%w1, %w3, %0\"\n-  [(set_attr \"type\" \"neon_store1_2reg,store_8\")\n-   (set_attr \"fp\" \"yes,*\")]\n-)\n-\n-(define_insn \"store_pairdf\"\n-  [(set (match_operand:DF 0 \"aarch64_mem_pair_operand\" \"=Ump,Ump\")\n-\t(match_operand:DF 1 \"aarch64_reg_or_fp_zero\" \"w,rY\"))\n-   (set (match_operand:DF 2 \"memory_operand\" \"=m,m\")\n-\t(match_operand:DF 3 \"aarch64_reg_or_fp_zero\" \"w,rY\"))]\n-  \"rtx_equal_p (XEXP (operands[2], 0),\n-\t\tplus_constant (Pmode,\n-\t\t\t       XEXP (operands[0], 0),\n-\t\t\t       GET_MODE_SIZE (DFmode)))\"\n-  \"@\n-   stp\\\\t%d1, %d3, %0\n-   stp\\\\t%x1, %x3, %0\"\n-  [(set_attr \"type\" \"neon_store1_2reg,store_16\")\n-   (set_attr \"fp\" \"yes,*\")]\n-)\n-\n ;; Load pair with post-index writeback.  This is primarily used in function\n ;; epilogues.\n (define_insn \"loadwb_pair<GPI:mode>_<P:mode>\""}, {"sha": "03a0c96e5721582fc14bc24e165944745ed8cfa1", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -69,6 +69,12 @@\n ;; Double vector modes.\n (define_mode_iterator VD [V8QI V4HI V4HF V2SI V2SF])\n \n+;; All modes stored in registers d0-d31.\n+(define_mode_iterator DREG [V8QI V4HI V4HF V2SI V2SF DF])\n+\n+;; Copy of the above.\n+(define_mode_iterator DREG2 [V8QI V4HI V4HF V2SI V2SF DF])\n+\n ;; Advanced SIMD, 64-bit container, all integer modes.\n (define_mode_iterator VD_BHSI [V8QI V4HI V2SI])\n \n@@ -239,6 +245,19 @@\n ;; Double scalar modes\n (define_mode_iterator DX [DI DF])\n \n+;; Duplicate of the above\n+(define_mode_iterator DX2 [DI DF])\n+\n+;; Single scalar modes\n+(define_mode_iterator SX [SI SF])\n+\n+;; Duplicate of the above\n+(define_mode_iterator SX2 [SI SF])\n+\n+;; Single and double integer and float modes\n+(define_mode_iterator DSX [DF DI SF SI])\n+\n+\n ;; Modes available for Advanced SIMD <f>mul lane operations.\n (define_mode_iterator VMUL [V4HI V8HI V2SI V4SI\n \t\t\t    (V4HF \"TARGET_SIMD_F16INST\")\n@@ -858,7 +877,8 @@\n \t\t\t       (V4HF \"V4HI\") (V8HF  \"V8HI\")\n \t\t\t       (V2SF \"V2SI\") (V4SF  \"V4SI\")\n \t\t\t       (DF   \"DI\")   (V2DF  \"V2DI\")\n-\t\t\t       (SF   \"SI\")   (HF    \"HI\")\n+\t\t\t       (SF   \"SI\")   (SI    \"SI\")\n+\t\t\t       (HF    \"HI\")\n \t\t\t       (VNx16QI \"VNx16QI\")\n \t\t\t       (VNx8HI  \"VNx8HI\") (VNx8HF \"VNx8HI\")\n \t\t\t       (VNx4SI  \"VNx4SI\") (VNx4SF \"VNx4SI\")"}, {"sha": "7aec76d681f5eca87b7b5e1d63d12dc0205ad113", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -62,6 +62,10 @@\n \t(and (match_code \"const_double\")\n \t     (match_test \"aarch64_float_const_zero_rtx_p (op)\"))))\n \n+(define_predicate \"aarch64_reg_zero_or_fp_zero\"\n+  (ior (match_operand 0 \"aarch64_reg_or_fp_zero\")\n+       (match_operand 0 \"aarch64_reg_or_zero\")))\n+\n (define_predicate \"aarch64_reg_zero_or_m1_or_1\"\n   (and (match_code \"reg,subreg,const_int\")\n        (ior (match_operand 0 \"register_operand\")"}, {"sha": "06ca4806b0767cdb54ea88ea225c5be8a64ab44a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -1,3 +1,9 @@\n+2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\t* gcc.target/aarch64/ldp_stp_6.c: New.\n+\t* gcc.target/aarch64/ldp_stp_7.c: New.\n+\t* gcc.target/aarch64/ldp_stp_8.c: New.\n+\n 2018-05-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85826"}, {"sha": "2d982f3389b668f2042d48ba3db04e619fd999f3", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_6.c?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2\" } */\n+\n+typedef float __attribute__ ((vector_size (8))) vec;\n+\n+struct pair\n+{\n+  vec e1;\n+  double e2;\n+};\n+\n+vec tmp;\n+\n+void\n+stp (struct pair *p)\n+{\n+  p->e1 = tmp;\n+  p->e2 = 1.0;\n+\n+  /* { dg-final { scan-assembler \"stp\\td\\[0-9\\]+, d\\[0-9\\]+, \\\\\\[x\\[0-9\\]+\\\\\\]\" } } */\n+}"}, {"sha": "be24c8a97009a77b510e2b1caee754a75bb9c3d3", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_7.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_7.c?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-options \"-O2\" } */\n+\n+struct pair\n+{\n+  double a;\n+  long long int b;\n+};\n+\n+void\n+stp (struct pair *p)\n+{\n+  p->a = 0.0;\n+  p->b = 1;\n+}\n+\n+/* { dg-final { scan-assembler \"stp\\txzr, x\\[0-9\\]+, \\\\\\[x\\[0-9\\]+\\\\\\]\" } } */\n+\n+void\n+stp2 (struct pair *p)\n+{\n+  p->a = 0.0;\n+  p->b = 0;\n+}\n+\n+struct reverse_pair\n+{\n+  long long int a;\n+  double b;\n+};\n+\n+void\n+stp_reverse (struct reverse_pair *p)\n+{\n+  p->a = 1;\n+  p->b = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler \"stp\\tx\\[0-9\\]+, xzr, \\\\\\[x\\[0-9\\]+\\\\\\]\" } } */\n+\n+void\n+stp_reverse2 (struct reverse_pair *p)\n+{\n+  p->a = 0;\n+  p->b = 0.0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\txzr, xzr, \\\\\\[x\\[0-9\\]+\\\\\\]\" 2 } } */"}, {"sha": "2d9cb6b19d563a7e1bb11c174f6d642291260f29", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_8.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe1da2381373d3b905053166d49fbaf8b0082e6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_8.c?ref=dfe1da2381373d3b905053166d49fbaf8b0082e6", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2\" } */\n+\n+typedef float __attribute__ ((vector_size (8))) fvec;\n+typedef int __attribute__ ((vector_size (8))) ivec;\n+\n+struct pair\n+{\n+  double a;\n+  fvec b;\n+};\n+\n+void ldp (double *a, fvec *b, struct pair *p)\n+{\n+  *a = p->a + 1;\n+  *b = p->b;\n+}\n+\n+struct vec_pair\n+{\n+  fvec a;\n+  ivec b;\n+};\n+\n+void ldp2 (fvec *a, ivec *b, struct vec_pair *p)\n+{\n+  *a = p->a;\n+  *b = p->b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldp\\td\\[0-9\\], d\\[0-9\\]+, \\\\\\[x\\[0-9\\]+\\\\\\]\" 2 } } */"}]}