{"sha": "3ab933594942029c75a9f966ba949c8a0ead1de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FiOTMzNTk0OTQyMDI5Yzc1YTlmOTY2YmE5NDljOGEwZWFkMWRlOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-03-22T22:47:06Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-03-22T22:47:06Z"}, "message": "IPA ICF: include hash values of references.\n\n\t* ipa-icf.c (sem_item::update_hash_by_addr_refs): New function.\n\t(sem_item::update_hash_by_local_refs): Likewise.\n\t(sem_variable::get_hash): Empty line is fixed.\n\t(sem_item_optimizer::execute): Include adding of hash references.\n\t(sem_item_optimizer::update_hash_by_addr_refs): New function.\n\t(sem_item_optimizer::build_hash_based_classes): Use local hash.\n\t* ipa-icf.h (sem_item::update_hash_by_addr_refs): New function.\n\t(sem_item::update_hash_by_local_refs): Likewise.\n\nFrom-SVN: r221576", "tree": {"sha": "b7bc6aaab7da123adf51a0177421b3b65768c4ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7bc6aaab7da123adf51a0177421b3b65768c4ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ab933594942029c75a9f966ba949c8a0ead1de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab933594942029c75a9f966ba949c8a0ead1de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ab933594942029c75a9f966ba949c8a0ead1de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab933594942029c75a9f966ba949c8a0ead1de8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34d417be31db4900811d9294f4f42371d576d340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d417be31db4900811d9294f4f42371d576d340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d417be31db4900811d9294f4f42371d576d340"}], "stats": {"total": 124, "additions": 119, "deletions": 5}, "files": [{"sha": "36c88ee3499a5238fd37d75ddef8ed0f3ec399b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ab933594942029c75a9f966ba949c8a0ead1de8", "patch": "@@ -1,3 +1,14 @@\n+2015-03-22  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf.c (sem_item::update_hash_by_addr_refs): New function.\n+\t(sem_item::update_hash_by_local_refs): Likewise.\n+\t(sem_variable::get_hash): Empty line is fixed.\n+\t(sem_item_optimizer::execute): Include adding of hash references.\n+\t(sem_item_optimizer::update_hash_by_addr_refs): New function.\n+\t(sem_item_optimizer::build_hash_based_classes): Use local hash.\n+\t* ipa-icf.h (sem_item::update_hash_by_addr_refs): New function.\n+\t(sem_item::update_hash_by_local_refs): Likewise.\n+\n 2015-03-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65502"}, {"sha": "bdfbd3ba362b89aefc05b75c5b60d025dc53e947", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=3ab933594942029c75a9f966ba949c8a0ead1de8", "patch": "@@ -557,6 +557,72 @@ sem_function::equals_wpa (sem_item *item,\n   return true;\n }\n \n+/* Update hash by address sensitive references. We iterate over all\n+   sensitive references (address_matters_p) and we hash ultime alias\n+   target of these nodes, which can improve a semantic item hash.\n+   TODO: stronger SCC based hashing would be desirable here.  */\n+\n+void\n+sem_item::update_hash_by_addr_refs (hash_map <symtab_node *,\n+\t\t\t\t    sem_item *> &m_symtab_node_map)\n+{\n+  if (is_a <varpool_node *> (node) && DECL_VIRTUAL_P (node->decl))\n+    return;\n+\n+  ipa_ref* ref;\n+  inchash::hash hstate (hash);\n+  for (unsigned i = 0; i < node->num_references (); i++)\n+    {\n+      ref = node->iterate_reference (i, ref);\n+      if (ref->address_matters_p () || !m_symtab_node_map.get (ref->referred))\n+\thstate.add_ptr (ref->referred->ultimate_alias_target ());\n+    }\n+\n+  if (is_a <cgraph_node *> (node))\n+    {\n+      for (cgraph_edge *e = dyn_cast <cgraph_node *> (node)->callers; e;\n+\t   e = e->next_caller)\n+\t{\n+\t  sem_item **result = m_symtab_node_map.get (e->callee);\n+\t  if (!result)\n+\t    hstate.add_ptr (e->callee->ultimate_alias_target ());\n+\t}\n+    }\n+\n+  hash = hstate.end ();\n+}\n+\n+/* Update hash by computed local hash values taken from different\n+   semantic items.  */\n+\n+void\n+sem_item::update_hash_by_local_refs (hash_map <symtab_node *,\n+\t\t\t\t     sem_item *> &m_symtab_node_map)\n+{\n+  inchash::hash state (hash);\n+  for (unsigned j = 0; j < node->num_references (); j++)\n+    {\n+      ipa_ref *ref;\n+      ref = node->iterate_reference (j, ref);\n+      sem_item **result = m_symtab_node_map.get (ref->referring);\n+      if (result)\n+\tstate.merge_hash ((*result)->hash);\n+    }\n+\n+  if (type == FUNC)\n+    {\n+      for (cgraph_edge *e = dyn_cast <cgraph_node *> (node)->callees; e;\n+\t   e = e->next_callee)\n+\t{\n+\t  sem_item **result = m_symtab_node_map.get (e->caller);\n+\t  if (result)\n+\t    state.merge_hash ((*result)->hash);\n+\t}\n+    }\n+\n+  global_hash = state.end ();\n+}\n+\n /* Returns true if the item equals to ITEM given as argument.  */\n \n bool\n@@ -1749,8 +1815,8 @@ hashval_t\n sem_variable::get_hash (void)\n {\n   if (hash)\n-\n     return hash;\n+\n   /* All WPA streamed in symbols should have their hashes computed at compile\n      time.  At this point, the constructor may not be in memory at all.\n      DECL_INITIAL (decl) would be error_mark_node in that case.  */\n@@ -2216,6 +2282,8 @@ sem_item_optimizer::execute (void)\n   filter_removed_items ();\n   unregister_hooks ();\n \n+  build_graph ();\n+  update_hash_by_addr_refs ();\n   build_hash_based_classes ();\n \n   if (dump_file)\n@@ -2225,8 +2293,6 @@ sem_item_optimizer::execute (void)\n   for (unsigned int i = 0; i < m_items.length(); i++)\n     m_items[i]->init_wpa ();\n \n-  build_graph ();\n-\n   subdivide_classes_by_equality (true);\n \n   if (dump_file)\n@@ -2315,6 +2381,27 @@ sem_item_optimizer::add_item_to_class (congruence_class *cls, sem_item *item)\n   item->cls = cls;\n }\n \n+/* For each semantic item, append hash values of references.  */\n+\n+void\n+sem_item_optimizer::update_hash_by_addr_refs ()\n+{\n+  /* First, append to hash sensitive references.  */\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    m_items[i]->update_hash_by_addr_refs (m_symtab_node_map);\n+\n+  /* Once all symbols have enhanced hash value, we can append\n+     hash values of symbols that are seen by IPA ICF and are\n+     references by a semantic item. Newly computed values\n+     are saved to global_hash member variable.  */\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    m_items[i]->update_hash_by_local_refs (m_symtab_node_map);\n+\n+  /* Global hash value replace current hash values.  */\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    m_items[i]->hash = m_items[i]->global_hash;\n+}\n+\n /* Congruence classes are built by hash value.  */\n \n void\n@@ -2324,7 +2411,7 @@ sem_item_optimizer::build_hash_based_classes (void)\n     {\n       sem_item *item = m_items[i];\n \n-      congruence_class_group *group = get_group_by_hash (item->get_hash (),\n+      congruence_class_group *group = get_group_by_hash (item->hash,\n \t\t\t\t      item->type);\n \n       if (!group->classes.length ())"}, {"sha": "cd21cacc94b62db7fce1ffbf3e88aa6246b90308", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ab933594942029c75a9f966ba949c8a0ead1de8/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=3ab933594942029c75a9f966ba949c8a0ead1de8", "patch": "@@ -189,6 +189,15 @@ class sem_item\n   /* Dump symbol to FILE.  */\n   virtual void dump_to_file (FILE *file) = 0;\n \n+  /* Update hash by address sensitive references.  */\n+  void update_hash_by_addr_refs (hash_map <symtab_node *,\n+\t\t\t\t sem_item *> &m_symtab_node_map);\n+\n+  /* Update hash by computed local hash values taken from different\n+     semantic items.  */\n+  void update_hash_by_local_refs (hash_map <symtab_node *,\n+\t\t\t\t  sem_item *> &m_symtab_node_map);\n+\n   /* Return base tree that can be used for compatible_types_p and\n      contains_polymorphic_type_p comparison.  */\n   static bool get_base_types (tree *t1, tree *t2);\n@@ -226,9 +235,13 @@ class sem_item\n   /* A set with symbol table references.  */\n   hash_set <symtab_node *> refs_set;\n \n+  /* Hash of item.  */\n+  hashval_t hash;\n+\n+  /* Temporary hash used where hash values of references are added.  */\n+  hashval_t global_hash;\n protected:\n   /* Cached, once calculated hash for the item.  */\n-  hashval_t hash;\n \n   /* Accumulate to HSTATE a hash of constructor expression EXP.  */\n   static void add_expr (const_tree exp, inchash::hash &hstate);\n@@ -494,6 +507,9 @@ class sem_item_optimizer\n \n private:\n \n+  /* For each semantic item, append hash values of references.  */\n+  void update_hash_by_addr_refs ();\n+\n   /* Congruence classes are built by hash value.  */\n   void build_hash_based_classes (void);\n "}]}