{"sha": "0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFmZDMyYmUzY2NkNzkxZjBhZGE1YTRhYWM5M2U5YTk1N2RjZDcyNQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-01T22:04:20Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-01T22:04:20Z"}, "message": "use sese_l throughout scop-detection\n\nUse sese_l throughout SCoP detection and create vec<scop_p> at the very end when\nall SCoPs have been identified. 'struct sese_l' is very lightweight (two\npointers) compared to 'struct scop'.\n\nNo functional change intended. Passes regtest and bootstrap.\n\ngcc/ChangeLog:\n\n2015-10-01  Aditya Kumar  <hiraditya@msn.com>\n\n        * graphite-scop-detection.c (struct sese_l): New conversion constructor\n          so that this type can be pushed into a vec.\n        (class scop_builder): use sese_l to collect scops.\n        (get_scops): New getter function.\n        (remove_intersecting_scops): Use sese_l instead of scops_p.\n        (intersects): Same.\n        (add_scop): Same.\n        (subsumes): Same.\n        (remove_subscops): Same.\n        (build_scops): Add scops to vec<scops_p> once all the scops have been\n        detected.\n\nFrom-SVN: r228359", "tree": {"sha": "b906b6c08891f54fc7f2d5cb301a4a64957b38c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b906b6c08891f54fc7f2d5cb301a4a64957b38c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0afd32be3ccd791f0ada5a4aac93e9a957dcd725/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ef70d69574433ef8a0e26e31b8af7c0bbb65de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef70d69574433ef8a0e26e31b8af7c0bbb65de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ef70d69574433ef8a0e26e31b8af7c0bbb65de"}], "stats": {"total": 133, "additions": 84, "deletions": 49}, "files": [{"sha": "03671ceaae70e750f332e34ec0b72644009f51eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0afd32be3ccd791f0ada5a4aac93e9a957dcd725/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0afd32be3ccd791f0ada5a4aac93e9a957dcd725/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "patch": "@@ -1,3 +1,17 @@\n+2015-10-01  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+\t* graphite-scop-detection.c (struct sese_l): New conversion constructor\n+\tso that this type can be pushed into a vec.\n+\t(class scop_builder): use sese_l to collect scops.\n+\t(get_scops): New getter function.\n+\t(remove_intersecting_scops): Use sese_l instead of scops_p.\n+\t(intersects): Same.\n+\t(add_scop): Same.\n+\t(subsumes): Same.\n+\t(remove_subscops): Same.\n+\t(build_scops): Add scops to vec<scops_p> once all the scops have been\n+\tdetected.\n+\n 2015-10-01  Aditya Kumar  <aditya.k7@samsung.com>\n \n \t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple):"}, {"sha": "acc963af516603e2e23eb2bff564adaef9ae97d7", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 70, "deletions": 49, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0afd32be3ccd791f0ada5a4aac93e9a957dcd725/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0afd32be3ccd791f0ada5a4aac93e9a957dcd725/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=0afd32be3ccd791f0ada5a4aac93e9a957dcd725", "patch": "@@ -62,11 +62,26 @@ struct sese_l\n   : entry (e), exit (x)\n   { }\n \n+  /* This is to push objects of sese_l in a vec.  */\n+  sese_l (int i)\n+  : entry (NULL), exit (NULL)\n+  {\n+    gcc_assert (i == 0);\n+  }\n+\n   operator bool () const\n   {\n     return entry && exit;\n   }\n \n+  const sese_l&\n+  operator= (const sese_l &s)\n+  {\n+    entry = s.entry;\n+    exit = s.exit;\n+    return *this;\n+  }\n+\n   edge entry;\n   edge exit;\n };\n@@ -823,13 +838,20 @@ loop_body_is_valid_scop (loop_p loop, sese_l scop)\n class scop_builder\n {\n  public:\n-  scop_builder (vec<scop_p> *s)\n-    : scops (s)\n+  scop_builder ()\n+    : scops (vNULL)\n   { }\n \n   static sese_l invalid_sese;\n \n-  sese_l get_sese (loop_p loop)\n+  vec<sese_l>\n+    get_scops ()\n+  {\n+    return scops;\n+  }\n+\n+  sese_l\n+    get_sese (loop_p loop)\n   {\n     if (!loop)\n       return invalid_sese;\n@@ -908,10 +930,7 @@ class scop_builder\n   }\n \n   /* Merge scops at same loop depth and returns the new sese.\n-     TODO: Free the already allocated sese's first and second, or reuse.\n-     Returns SECOND when first is NULL.  SECOND cannot be NULL.\n-     Frees up SECOND and returns a new SESE when merge was successful.\n-  */\n+     Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n \n   static sese_l\n     merge_sese (sese_l first, sese_l second)\n@@ -962,7 +981,7 @@ class scop_builder\n \n     /* For now we just want to bail out when exit does not post-dominate entry.\n        TODO: We might just add a basic_block at the exit to make exit\n-       post-dominate entry (the entrire region).  */\n+       post-dominate entry (the entire region).  */\n     if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (entry),\n                          get_exit_bb (exit))\n \t|| !dominated_by_p (CDI_DOMINATORS, get_exit_bb (exit),\n@@ -1137,8 +1156,6 @@ class scop_builder\n     add_scop (sese_l s)\n   {\n     gcc_assert (s);\n-    edge scop_begin = s.entry;\n-    edge scop_end = s.exit;\n \n     /* Do not add scops with only one loop.  */\n     if (region_has_one_loop (s))\n@@ -1148,24 +1165,21 @@ class scop_builder\n \treturn;\n       }\n \n-    if (get_exit_bb (scop_end) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    if (get_exit_bb (s.exit) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n       {\n \tDEBUG_PRINT (dp << \"\\n[scop-detection-fail] \"\n \t\t        << \"Discarding SCoP exiting to return\";\n \t\t     print_sese (dump_file, s));\n \treturn;\n       }\n \n-    sese sese_reg = new_sese (scop_begin, scop_end);\n-    scop_p newscop = new_scop (sese_reg);\n-\n     /* Remove all the scops which are subsumed by s.  */\n-    remove_subscops (newscop);\n+    remove_subscops (s);\n \n     /* Replace this with split-intersecting scops.  */\n-    remove_intersecting_scops (newscop);\n+    remove_intersecting_scops (s);\n \n-    scops->safe_push (newscop);\n+    scops.safe_push (s);\n     DEBUG_PRINT (dp << \"\\nAdding SCoP \"; print_sese (dump_file, s));\n   }\n \n@@ -1210,31 +1224,29 @@ class scop_builder\n \n   /* Returns true if S1 subsumes/surrounds S2.  */\n   static bool\n-    subsumes (scop_p s1, scop_p s2)\n+    subsumes (sese_l s1, sese_l s2)\n   {\n-    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n-\t\t\tget_entry_bb (s1->region->entry))\n-\t&& dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2->region->exit),\n-\t\t\t   get_entry_bb (s1->region->exit)))\n+    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t\tget_entry_bb (s1.entry))\n+\t&& dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2.exit),\n+\t\t\t   get_entry_bb (s1.exit)))\n       return true;\n     return false;\n   }\n \n-  /* TODO: Maybe vec<scops_p> can be made as vec<sese_l> so that it consumes\n-   less memory and later push only the relevant scops to vec <scops_p>.  */\n+  /* Remove a SCoP which is subsumed by S1.  */\n   void\n-    remove_subscops (scop_p s1)\n+    remove_subscops (sese_l s1)\n   {\n     int j;\n-    scop_p s2;\n-    FOR_EACH_VEC_ELT_REVERSE (*scops, j, s2)\n+    sese_l s2 (0);\n+    FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n       {\n \tif (subsumes (s1, s2))\n \t  {\n \t    DEBUG_PRINT (dp << \"\\nRemoving sub-SCoP\";\n-\t\t print_sese (dump_file,\n-\t\t\t     sese_l (s2->region->entry, s2->region->exit)));\n-\t    scops->unordered_remove (j);\n+\t\t print_sese (dump_file, s2));\n+\t    scops.unordered_remove (j);\n \t  }\n       }\n   }\n@@ -1243,15 +1255,15 @@ class scop_builder\n      not subsume S2 or vice-versa, we only check for entry bbs.  */\n \n   static bool\n-    intersects (scop_p s1, scop_p s2)\n+    intersects (sese_l s1, sese_l s2)\n   {\n-    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n-\t\t\tget_entry_bb (s1->region->entry))\n-\t&& !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n-\t\t\t    get_exit_bb (s1->region->exit)))\n+    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t\tget_entry_bb (s1.entry))\n+\t&& !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t\t    get_exit_bb (s1.exit)))\n       return true;\n-    if ((s1->region->exit == s2->region->entry)\n-\t|| (s2->region->exit == s1->region->entry))\n+    if ((s1.exit == s2.entry)\n+\t|| (s2.exit == s1.entry))\n       return true;\n \n     return false;\n@@ -1260,30 +1272,28 @@ class scop_builder\n   /* Remove one of the scops when it intersects with any other.  */\n \n   void\n-    remove_intersecting_scops (scop_p s1)\n+    remove_intersecting_scops (sese_l s1)\n   {\n     int j;\n-    scop_p s2;\n-    FOR_EACH_VEC_ELT_REVERSE (*scops, j, s2)\n+    sese_l s2 (0);\n+    FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n       {\n \tif (intersects (s1, s2))\n \t  {\n \t    DEBUG_PRINT (dp << \"\\nRemoving intersecting SCoP\";\n-\t\tprint_sese (dump_file, sese_l (s2->region->entry,\n-\t\t\t\t\t       s2->region->exit));\n+\t\tprint_sese (dump_file, s2);\n \t\tdp << \"Intersects with:\";\n-\t\tprint_sese (dump_file, sese_l (s1->region->entry,\n-\t\t\t\t\t       s1->region->exit)));\n-\t    scops->unordered_remove (j);\n+\t\tprint_sese (dump_file, s1));\n+\t    scops.unordered_remove (j);\n \t  }\n       }\n   }\n \n  private:\n-  vec<scop_p> *scops;\n+  vec<sese_l> scops;\n };\n \n-sese_l scop_builder::invalid_sese (NULL, NULL);\n+sese_l scop_builder::invalid_sese (0);\n \n /* Find Static Control Parts (SCoP) in the current function and pushes\n    them to SCOPS.  */\n@@ -1296,8 +1306,19 @@ build_scops (vec<scop_p> *scops)\n \n   canonicalize_loop_closed_ssa_form ();\n \n-  scop_builder s (scops);\n-  s.build_scop_depth (scop_builder::invalid_sese, current_loops->tree_root);\n+  scop_builder sb;\n+  sb.build_scop_depth (scop_builder::invalid_sese, current_loops->tree_root);\n+\n+  /* Now create scops from the lightweight SESEs.  */\n+  vec<sese_l> scops_l = sb.get_scops ();\n+  int i;\n+  sese_l s (0);\n+  FOR_EACH_VEC_ELT (scops_l, i, s)\n+  {\n+    sese sese_reg = new_sese (s.entry, s.exit);\n+    scops->safe_push (new_scop (sese_reg));\n+  }\n+\n   DEBUG_PRINT (dp << \"number of SCoPs: \" << (scops ? scops->length () : 0););\n }\n "}]}