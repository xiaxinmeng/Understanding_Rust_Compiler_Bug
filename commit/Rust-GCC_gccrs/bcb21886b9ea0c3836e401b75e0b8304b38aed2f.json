{"sha": "bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNiMjE4ODZiOWVhMGMzODM2ZTQwMWI3NWUwYjgzMDRiMzhhZWQyZg==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-10-13T17:26:49Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-10-13T17:26:49Z"}, "message": "re PR target/8340 (ICE on x86 inline asm w/ -fPIC)\n\n\ngcc/\n\tPR target/8340\n\tPR middle-end/47602\n\tPR rtl-optimization/55458\n\t* config/i386/i386.c (ix86_use_pseudo_pic_reg): New.\n\t(ix86_init_pic_reg): New.\n\t(ix86_select_alt_pic_regnum): Add check on pseudo register.\n\t(ix86_save_reg): Likewise.\n\t(ix86_expand_prologue): Remove PIC register initialization\n\tnow performed in ix86_init_pic_reg.\n\t(ix86_output_function_epilogue): Add check on pseudo register.\n\t(set_pic_reg_ever_alive): New.\n\t(legitimize_pic_address): Replace df_set_regs_ever_live with new\n\tset_pic_reg_ever_alive.\n\t(legitimize_tls_address): Likewise.\n\t(ix86_pic_register_p): New check.\n\t(ix86_delegitimize_address): Add check on pseudo register.\n\t(ix86_expand_call): Insert move from pseudo PIC register to ABI\n\tdefined REAL_PIC_OFFSET_TABLE_REGNUM.\n\t(TARGET_INIT_PIC_REG): New.\n\t(TARGET_USE_PSEUDO_PIC_REG): New.\n\t* config/i386/i386.h (PIC_OFFSET_TABLE_REGNUM): Return INVALID_REGNUM\n\tif pic_offset_table_rtx exists.\n\t* doc/tm.texi.in (TARGET_USE_PSEUDO_PIC_REG, TARGET_INIT_PIC_REG):\n\tDocument.\n\t* doc/tm.texi: Regenerate.\n\t* function.c (assign_parms): Generate pseudo register for PIC.\n\t* init-regs.c (initialize_uninitialized_regs): Ignor pseudo PIC\n\tregister.\n\t* ira-color.c (color_pass): Add check on pseudo register.\n\t* ira-emit.c (change_loop): Don't create copies for PIC pseudo\n\tregister.\n\t* ira.c (split_live_ranges_for_shrink_wrap): Add check on pseudo\n\tregister.\n\t(ira): Add target specific PIC register initialization.\n\t(do_reload): Keep PIC pseudo register.\n\t* lra-assigns.c (spill_for): Add checks on pseudo register.\n\t* lra-constraints.c (contains_symbol_ref_p): New.\n\t(lra_constraints): Enable lra risky transformations when PIC is pseudo\n\tregister.\n\t* shrink-wrap.c (try_shrink_wrapping): Add check on pseudo register.\n\t* target.def (use_pseudo_pic_reg): New.\n\t(init_pic_reg): New.\n\ngcc/testsuite/\n\tPR target/8340\n\tPR middle-end/47602\n\tPR rtl-optimization/55458\n\t* gcc.target/i386/pic-1.c: Remove dg-error as test should pass now.\n\t* gcc.target/i386/pr55458.c: Likewise.\n\t* gcc.target/i386/pr47602.c: New.\n\t* gcc.target/i386/pr23098.c: Move to XFAIL.\n\nFrom-SVN: r216154", "tree": {"sha": "6c2ee30ea96f8dde643e082a6ab50870b1a8de9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2ee30ea96f8dde643e082a6ab50870b1a8de9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/comments", "author": null, "committer": null, "parents": [{"sha": "8d99ad36b391d760f08f9f3bba6a99649e0cce35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d99ad36b391d760f08f9f3bba6a99649e0cce35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d99ad36b391d760f08f9f3bba6a99649e0cce35"}], "stats": {"total": 381, "additions": 289, "deletions": 92}, "files": [{"sha": "66fecb931196e0731d4fa11f623b96d3f41c4b88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -1,3 +1,49 @@\n+2014-10-13  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t    Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/8340\n+\tPR middle-end/47602\n+\tPR rtl-optimization/55458\n+\t* config/i386/i386.c (ix86_use_pseudo_pic_reg): New.\n+\t(ix86_init_pic_reg): New.\n+\t(ix86_select_alt_pic_regnum): Add check on pseudo register.\n+\t(ix86_save_reg): Likewise.\n+\t(ix86_expand_prologue): Remove PIC register initialization\n+\tnow performed in ix86_init_pic_reg.\n+\t(ix86_output_function_epilogue): Add check on pseudo register.\n+\t(set_pic_reg_ever_alive): New.\n+\t(legitimize_pic_address): Replace df_set_regs_ever_live with new\n+\tset_pic_reg_ever_alive.\n+\t(legitimize_tls_address): Likewise.\n+\t(ix86_pic_register_p): New check.\n+\t(ix86_delegitimize_address): Add check on pseudo register.\n+\t(ix86_expand_call): Insert move from pseudo PIC register to ABI\n+\tdefined REAL_PIC_OFFSET_TABLE_REGNUM.\n+\t(TARGET_INIT_PIC_REG): New.\n+\t(TARGET_USE_PSEUDO_PIC_REG): New.\n+\t* config/i386/i386.h (PIC_OFFSET_TABLE_REGNUM): Return INVALID_REGNUM\n+\tif pic_offset_table_rtx exists.\n+\t* doc/tm.texi.in (TARGET_USE_PSEUDO_PIC_REG, TARGET_INIT_PIC_REG):\n+\tDocument.\n+\t* doc/tm.texi: Regenerate.\n+\t* function.c (assign_parms): Generate pseudo register for PIC.\n+\t* init-regs.c (initialize_uninitialized_regs): Ignor pseudo PIC\n+\tregister.\n+\t* ira-color.c (color_pass): Add check on pseudo register.\n+\t* ira-emit.c (change_loop): Don't create copies for PIC pseudo\n+\tregister.\n+\t* ira.c (split_live_ranges_for_shrink_wrap): Add check on pseudo\n+\tregister.\n+\t(ira): Add target specific PIC register initialization.\n+\t(do_reload): Keep PIC pseudo register.\n+\t* lra-assigns.c (spill_for): Add checks on pseudo register.\n+\t* lra-constraints.c (contains_symbol_ref_p): New.\n+\t(lra_constraints): Enable lra risky transformations when PIC is pseudo\n+\tregister.\n+\t* shrink-wrap.c (try_shrink_wrapping): Add check on pseudo register.\n+\t* target.def (use_pseudo_pic_reg): New.\n+\t(init_pic_reg): New.\n+\n 2014-10-13  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \t* config/i386/x86-tune.def (X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY):"}, {"sha": "2a64d2d3611ce88901fcf1e2067d2cef426d21f3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 100, "deletions": 69, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -6141,6 +6141,68 @@ ix86_maybe_switch_abi (void)\n     reinit_regs ();\n }\n \n+/* Return 1 if pseudo register should be created and used to hold\n+   GOT address for PIC code.  */\n+static bool\n+ix86_use_pseudo_pic_reg (void)\n+{\n+  if ((TARGET_64BIT\n+       && (ix86_cmodel == CM_SMALL_PIC\n+\t   || TARGET_PECOFF))\n+      || !flag_pic)\n+    return false;\n+  return true;\n+}\n+\n+/* Create and initialize PIC register if required.  */\n+static void\n+ix86_init_pic_reg (void)\n+{\n+  edge entry_edge;\n+  rtx_insn *seq;\n+\n+  if (!ix86_use_pseudo_pic_reg ())\n+    return;\n+\n+  start_sequence ();\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (ix86_cmodel == CM_LARGE_PIC)\n+\t{\n+\t  rtx_code_label *label;\n+\t  rtx tmp_reg;\n+\n+\t  gcc_assert (Pmode == DImode);\n+\t  label = gen_label_rtx ();\n+\t  emit_label (label);\n+\t  LABEL_PRESERVE_P (label) = 1;\n+\t  tmp_reg = gen_rtx_REG (Pmode, R11_REG);\n+\t  gcc_assert (REGNO (pic_offset_table_rtx) != REGNO (tmp_reg));\n+\t  emit_insn (gen_set_rip_rex64 (pic_offset_table_rtx,\n+\t\t\t\t\tlabel));\n+\t  emit_insn (gen_set_got_offset_rex64 (tmp_reg, label));\n+\t  emit_insn (ix86_gen_add3 (pic_offset_table_rtx,\n+\t\t\t\t    pic_offset_table_rtx, tmp_reg));\n+\t}\n+      else\n+\temit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n+    }\n+  else\n+    {\n+      rtx insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);\n+    }\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  insert_insn_on_edge (seq, entry_edge);\n+  commit_one_edge_insertion (entry_edge);\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n@@ -9383,6 +9445,9 @@ gen_pop (rtx arg)\n static unsigned int\n ix86_select_alt_pic_regnum (void)\n {\n+  if (ix86_use_pseudo_pic_reg ())\n+    return INVALID_REGNUM;\n+\n   if (crtl->is_leaf\n       && !crtl->profile\n       && !ix86_current_function_calls_tls_descriptor)\n@@ -9407,6 +9472,7 @@ static bool\n ix86_save_reg (unsigned int regno, bool maybe_eh_return)\n {\n   if (pic_offset_table_rtx\n+      && !ix86_use_pseudo_pic_reg ()\n       && regno == REAL_PIC_OFFSET_TABLE_REGNUM\n       && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n \t  || crtl->profile\n@@ -10759,7 +10825,6 @@ ix86_expand_prologue (void)\n {\n   struct machine_function *m = cfun->machine;\n   rtx insn, t;\n-  bool pic_reg_used;\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n   bool int_registers_saved;\n@@ -11206,60 +11271,6 @@ ix86_expand_prologue (void)\n   if (!sse_registers_saved)\n     ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n \n-  pic_reg_used = false;\n-  /* We don't use pic-register for pe-coff target.  */\n-  if (pic_offset_table_rtx\n-      && !TARGET_PECOFF\n-      && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n-\t  || crtl->profile))\n-    {\n-      unsigned int alt_pic_reg_used = ix86_select_alt_pic_regnum ();\n-\n-      if (alt_pic_reg_used != INVALID_REGNUM)\n-\tSET_REGNO (pic_offset_table_rtx, alt_pic_reg_used);\n-\n-      pic_reg_used = true;\n-    }\n-\n-  if (pic_reg_used)\n-    {\n-      if (TARGET_64BIT)\n-\t{\n-\t  if (ix86_cmodel == CM_LARGE_PIC)\n-\t    {\n-\t      rtx_code_label *label;\n-\t      rtx tmp_reg;\n-\n-\t      gcc_assert (Pmode == DImode);\n-\t      label = gen_label_rtx ();\n-\t      emit_label (label);\n-\t      LABEL_PRESERVE_P (label) = 1;\n-\t      tmp_reg = gen_rtx_REG (Pmode, R11_REG);\n-\t      gcc_assert (REGNO (pic_offset_table_rtx) != REGNO (tmp_reg));\n-\t      insn = emit_insn (gen_set_rip_rex64 (pic_offset_table_rtx,\n-\t\t\t\t\t\t   label));\n-\t      insn = emit_insn (gen_set_got_offset_rex64 (tmp_reg, label));\n-\t      insn = emit_insn (ix86_gen_add3 (pic_offset_table_rtx,\n-\t\t\t\t\t       pic_offset_table_rtx, tmp_reg));\n-\t    }\n-\t  else\n-            insn = emit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n-\t}\n-      else\n-\t{\n-          insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);\n-\t}\n-    }\n-\n-  /* In the pic_reg_used case, make sure that the got load isn't deleted\n-     when mcount needs it.  Blockage to avoid call movement across mcount\n-     call is emitted in generic code after the NOTE_INSN_PROLOGUE_END\n-     note.  */\n-  if (crtl->profile && !flag_fentry && pic_reg_used)\n-    emit_insn (gen_prologue_use (pic_offset_table_rtx));\n-\n   if (crtl->drap_reg && !crtl->stack_realign_needed)\n     {\n       /* vDRAP is setup but after reload it turns out stack realign\n@@ -11800,7 +11811,8 @@ ix86_expand_epilogue (int style)\n static void\n ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED, HOST_WIDE_INT)\n {\n-  if (pic_offset_table_rtx)\n+  if (pic_offset_table_rtx\n+      && !ix86_use_pseudo_pic_reg ())\n     SET_REGNO (pic_offset_table_rtx, REAL_PIC_OFFSET_TABLE_REGNUM);\n #if TARGET_MACHO\n   /* Mach-O doesn't support labels at the end of objects, so if\n@@ -13120,6 +13132,15 @@ ix86_GOT_alias_set (void)\n   return set;\n }\n \n+/* Set regs_ever_live for PIC base address register\n+   to true if required.  */\n+static void\n+set_pic_reg_ever_live ()\n+{\n+  if (reload_in_progress)\n+    df_set_regs_ever_live (REGNO (pic_offset_table_rtx), true);\n+}\n+\n /* Return a legitimate reference for ORIG (an address) using the\n    register REG.  If REG is 0, a new pseudo is generated.\n \n@@ -13170,8 +13191,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n       /* This symbol may be referenced via a displacement from the PIC\n \t base address (@GOTOFF).  */\n \n-      if (reload_in_progress)\n-\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+      set_pic_reg_ever_live ();\n       if (GET_CODE (addr) == CONST)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n@@ -13203,8 +13223,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n       /* This symbol may be referenced via a displacement from the PIC\n \t base address (@GOTOFF).  */\n \n-      if (reload_in_progress)\n-\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+      set_pic_reg_ever_live ();\n       if (GET_CODE (addr) == CONST)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n@@ -13265,8 +13284,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  /* This symbol must be referenced via a load from the\n \t     Global Offset Table (@GOT).  */\n \n-\t  if (reload_in_progress)\n-\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\t  set_pic_reg_ever_live ();\n \t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n \t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \t  if (TARGET_64BIT)\n@@ -13318,8 +13336,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t    {\n \t      if (!TARGET_64BIT)\n \t\t{\n-\t\t  if (reload_in_progress)\n-\t\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\t\t  set_pic_reg_ever_live ();\n \t\t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n \t\t\t\t\t    UNSPEC_GOTOFF);\n \t\t  new_rtx = gen_rtx_PLUS (Pmode, new_rtx, op1);\n@@ -13615,8 +13632,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \t}\n       else if (flag_pic)\n \t{\n-\t  if (reload_in_progress)\n-\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\t  set_pic_reg_ever_live ();\n \t  pic = pic_offset_table_rtx;\n \t  type = TARGET_ANY_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n \t}\n@@ -14247,6 +14263,8 @@ ix86_pic_register_p (rtx x)\n   if (GET_CODE (x) == VALUE && CSELIB_VAL_PTR (x))\n     return (pic_offset_table_rtx\n \t    && rtx_equal_for_cselib_p (x, pic_offset_table_rtx));\n+  else if (pic_offset_table_rtx)\n+    return REG_P (x) && REGNO (x) == REGNO (pic_offset_table_rtx);\n   else\n     return REG_P (x) && REGNO (x) == PIC_OFFSET_TABLE_REGNUM;\n }\n@@ -14421,8 +14439,12 @@ ix86_delegitimize_address (rtx x)\n \t leal (%ebx, %ecx, 4), %ecx\n \t ...\n \t movl foo@GOTOFF(%ecx), %edx\n-\t in which case we return (%ecx - %ebx) + foo.  */\n-      if (pic_offset_table_rtx)\n+\t in which case we return (%ecx - %ebx) + foo.\n+\n+\t Note that when pseudo_pic_reg is used we can generate it only\n+\t before reload_completed.  */\n+      if (pic_offset_table_rtx\n+\t  && (!reload_completed || !ix86_use_pseudo_pic_reg ()))\n         result = gen_rtx_PLUS (Pmode, gen_rtx_MINUS (Pmode, copy_rtx (addend),\n \t\t\t\t\t\t     pic_offset_table_rtx),\n \t\t\t       result);\n@@ -24899,7 +24921,12 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t  && DEFAULT_ABI != MS_ABI))\n \t  && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n \t  && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n-\tuse_reg (&use, pic_offset_table_rtx);\n+\t{\n+\t  use_reg (&use, gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM));\n+\t  if (ix86_use_pseudo_pic_reg ())\n+\t    emit_move_insn (gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t    pic_offset_table_rtx);\n+\t}\n     }\n \n   if (TARGET_64BIT && INTVAL (callarg2) >= 0)\n@@ -47413,6 +47440,10 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #define TARGET_FUNCTION_ARG_ADVANCE ix86_function_arg_advance\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG ix86_function_arg\n+#undef TARGET_INIT_PIC_REG\n+#define TARGET_INIT_PIC_REG ix86_init_pic_reg\n+#undef TARGET_USE_PSEUDO_PIC_REG\n+#define TARGET_USE_PSEUDO_PIC_REG ix86_use_pseudo_pic_reg\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY ix86_function_arg_boundary\n #undef TARGET_PASS_BY_REFERENCE"}, {"sha": "61beb6676c52557fbd8ab750768d238c51f806a0", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -1233,12 +1233,14 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define REAL_PIC_OFFSET_TABLE_REGNUM  BX_REG\n \n-#define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\\\n-  ((TARGET_64BIT && (ix86_cmodel == CM_SMALL_PIC\t\\\n-                     || TARGET_PECOFF))\t\t\\\n-   || !flag_pic ? INVALID_REGNUM\t\t\t\\\n-   : reload_completed ? REGNO (pic_offset_table_rtx)\t\\\n-   : REAL_PIC_OFFSET_TABLE_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\t\t\\\n+  ((TARGET_64BIT && (ix86_cmodel == CM_SMALL_PIC\t\t\t\\\n+                     || TARGET_PECOFF))\t\t\t\t\t\\\n+   || !flag_pic\t\t\t\t\t\t\t\t\\\n+   ? INVALID_REGNUM\t\t\t\t\t\t\t\\\n+   : pic_offset_table_rtx\t\t\t\t\t\t\\\n+     ? INVALID_REGNUM\t\t\t\t\t\t\t\\\n+     : REAL_PIC_OFFSET_TABLE_REGNUM)\n \n #define GOT_SYMBOL_NAME \"_GLOBAL_OFFSET_TABLE_\"\n "}, {"sha": "5036d4fe60d648badebb2230380da19f956d6ede", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -3902,6 +3902,16 @@ If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n @code{TARGET_FUNCTION_ARG} serves both purposes.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_USE_PSEUDO_PIC_REG (void)\n+This hook should return 1 in case pseudo register should be created\n+for pic_offset_table_rtx during function expand.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_INIT_PIC_REG (void)\n+Perform a target dependent initialization of pic_offset_table_rtx.\n+This hook is called at the start of register allocation.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t @var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n This target hook returns the number of bytes at the beginning of an\n argument that must be put in registers.  The value must be zero for"}, {"sha": "5674e6c6b9e84163ad5825b2ec5709107f6018e7", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -3348,6 +3348,10 @@ the stack.\n \n @hook TARGET_FUNCTION_INCOMING_ARG\n \n+@hook TARGET_USE_PSEUDO_PIC_REG\n+\n+@hook TARGET_INIT_PIC_REG\n+\n @hook TARGET_ARG_PARTIAL_BYTES\n \n @hook TARGET_PASS_BY_REFERENCE"}, {"sha": "2becdfb591e49e0f8d1e9533460425eac0a3c402", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -3453,6 +3453,11 @@ assign_parms (tree fndecl)\n \n   fnargs.release ();\n \n+  /* Initialize pic_offset_table_rtx with a pseudo register\n+     if required.  */\n+  if (targetm.use_pseudo_pic_reg ())\n+    pic_offset_table_rtx = gen_reg_rtx (Pmode);\n+\n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */\n   emit_insn (all.first_conversion_insn);"}, {"sha": "bf83e51aa929544b0f2f43c04a01dfecec965099", "filename": "gcc/init-regs.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -80,6 +80,11 @@ initialize_uninitialized_regs (void)\n \t      if (regno < FIRST_PSEUDO_REGISTER)\n \t\tcontinue;\n \n+\t      /* Ignore pseudo PIC register.  */\n+\t      if (pic_offset_table_rtx\n+\t\t  && regno == REGNO (pic_offset_table_rtx))\n+\t\tcontinue;\n+\n \t      /* Do not generate multiple moves for the same regno.\n \t\t This is common for sequences of subreg operations.\n \t\t They would be deleted during combine but there is no"}, {"sha": "dffe40a15502b3633206bc0c3906333046c8f22e", "filename": "gcc/ira-color.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -3245,9 +3245,11 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  ira_assert (ALLOCNO_CLASS (subloop_allocno) == rclass);\n \t  ira_assert (bitmap_bit_p (subloop_node->all_allocnos,\n \t\t\t\t    ALLOCNO_NUM (subloop_allocno)));\n-\t  if ((flag_ira_region == IRA_REGION_MIXED)\n-\t      && (loop_tree_node->reg_pressure[pclass]\n-\t\t  <= ira_class_hard_regs_num[pclass]))\n+\t  if ((flag_ira_region == IRA_REGION_MIXED\n+\t       && (loop_tree_node->reg_pressure[pclass]\n+\t\t   <= ira_class_hard_regs_num[pclass]))\n+\t      || (pic_offset_table_rtx != NULL\n+\t\t  && regno == (int) REGNO (pic_offset_table_rtx)))\n \t    {\n \t      if (! ALLOCNO_ASSIGNED_P (subloop_allocno))\n \t\t{"}, {"sha": "676ee1acc97f20d542597f9977cc2a99c56143fe", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -620,7 +620,10 @@ change_loop (ira_loop_tree_node_t node)\n \t\t  /* don't create copies because reload can spill an\n \t\t     allocno set by copy although the allocno will not\n \t\t     get memory slot.  */\n-\t\t  || ira_equiv_no_lvalue_p (regno)))\n+\t\t  || ira_equiv_no_lvalue_p (regno)\n+\t\t  || (pic_offset_table_rtx != NULL\n+\t\t      && (ALLOCNO_REGNO (allocno)\n+\t\t\t  == (int) REGNO (pic_offset_table_rtx)))))\n \t    continue;\n \t  original_reg = allocno_emit_reg (allocno);\n \t  if (parent_allocno == NULL"}, {"sha": "6194d3480a4c2b2cb8e6d7934e0e8deca843228e", "filename": "gcc/ira.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -4896,7 +4896,7 @@ split_live_ranges_for_shrink_wrap (void)\n   FOR_BB_INSNS (first, insn)\n     {\n       rtx dest = interesting_dest_for_shprep (insn, call_dom);\n-      if (!dest)\n+      if (!dest || dest == pic_offset_table_rtx)\n \tcontinue;\n \n       rtx newreg = NULL_RTX;\n@@ -5048,6 +5048,9 @@ ira (FILE *f)\n   bool saved_flag_caller_saves = flag_caller_saves;\n   enum ira_region saved_flag_ira_region = flag_ira_region;\n \n+  /* Perform target specific PIC register initialization.  */\n+  targetm.init_pic_reg ();\n+\n   ira_conflicts_p = optimize > 0;\n \n   ira_use_lra_p = targetm.lra_p ();\n@@ -5299,10 +5302,18 @@ do_reload (void)\n {\n   basic_block bb;\n   bool need_dce;\n+  unsigned pic_offset_table_regno = INVALID_REGNUM;\n \n   if (flag_ira_verbose < 10)\n     ira_dump_file = dump_file;\n \n+  /* If pic_offset_table_rtx is a pseudo register, then keep it so\n+     after reload to avoid possible wrong usages of hard reg assigned\n+     to it.  */\n+  if (pic_offset_table_rtx\n+      && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n+    pic_offset_table_regno = REGNO (pic_offset_table_rtx);\n+\n   timevar_push (TV_RELOAD);\n   if (ira_use_lra_p)\n     {\n@@ -5407,6 +5418,9 @@ do_reload (void)\n       inform (DECL_SOURCE_LOCATION (decl), \"for %qD\", decl);\n     }\n \n+  if (pic_offset_table_regno != INVALID_REGNUM)\n+    pic_offset_table_rtx = gen_rtx_REG (Pmode, pic_offset_table_regno);\n+\n   timevar_pop (TV_IRA);\n }\n \f"}, {"sha": "7b862a488e6f387a576c3507f07eb7ac207376f4", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -879,11 +879,13 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t}\n       /* Spill pseudos.\t */\n       EXECUTE_IF_SET_IN_BITMAP (&spill_pseudos_bitmap, 0, spill_regno, bi)\n-\tif ((int) spill_regno >= lra_constraint_new_regno_start\n-\t    && ! bitmap_bit_p (&lra_inheritance_pseudos, spill_regno)\n-\t    && ! bitmap_bit_p (&lra_split_regs, spill_regno)\n-\t    && ! bitmap_bit_p (&lra_subreg_reload_pseudos, spill_regno)\n-\t    && ! bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno))\n+\tif ((pic_offset_table_rtx != NULL\n+\t     && spill_regno == REGNO (pic_offset_table_rtx))\n+\t    || ((int) spill_regno >= lra_constraint_new_regno_start\n+\t\t&& ! bitmap_bit_p (&lra_inheritance_pseudos, spill_regno)\n+\t\t&& ! bitmap_bit_p (&lra_split_regs, spill_regno)\n+\t\t&& ! bitmap_bit_p (&lra_subreg_reload_pseudos, spill_regno)\n+\t\t&& ! bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno)))\n \t  goto fail;\n       insn_pseudos_num = 0;\n       if (lra_dump_file != NULL)\n@@ -1053,9 +1055,15 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n       return;\n     }\n   for (n = 0, i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] >= 0 && lra_reg_info[i].nrefs > 0)\n+    if ((pic_offset_table_rtx == NULL_RTX\n+\t || i != (int) REGNO (pic_offset_table_rtx))\n+\t&& reg_renumber[i] >= 0 && lra_reg_info[i].nrefs > 0)\n       sorted_pseudos[n++] = i;\n   qsort (sorted_pseudos, n, sizeof (int), pseudo_compare_func);\n+  if (pic_offset_table_rtx != NULL_RTX\n+      && (regno = REGNO (pic_offset_table_rtx)) >= FIRST_PSEUDO_REGISTER\n+      && reg_renumber[regno] >= 0 && lra_reg_info[regno].nrefs > 0)\n+    sorted_pseudos[n++] = regno;\n   for (i = n - 1; i >= 0; i--)\n     {\n       regno = sorted_pseudos[i];"}, {"sha": "f90d13be0a38539acd763e0047779f93b36ab7ed", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -3798,6 +3798,35 @@ contains_reg_p (rtx x, bool hard_reg_p, bool spilled_p)\n   return false;\n }\n \n+/* Return true if X contains a symbol reg.  */\n+static bool\n+contains_symbol_ref_p (rtx x)\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code;\n+\n+  code = GET_CODE (x);\n+  if (code == SYMBOL_REF)\n+    return true;\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (contains_symbol_ref_p (XEXP (x, i)))\n+\t    return true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (contains_symbol_ref_p (XVECEXP (x, i, j)))\n+\t      return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Process all regs in location *LOC and change them on equivalent\n    substitution.  Return true if any change was done.  */\n static bool\n@@ -4020,7 +4049,11 @@ lra_constraints (bool first_p)\n       (\"Maximum number of LRA constraint passes is achieved (%d)\\n\",\n        LRA_MAX_CONSTRAINT_ITERATION_NUMBER);\n   changed_p = false;\n-  lra_risky_transformations_p = false;\n+  if (pic_offset_table_rtx\n+      && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n+    lra_risky_transformations_p = true;\n+  else\n+    lra_risky_transformations_p = false;\n   new_insn_uid_start = get_max_uid ();\n   new_regno_start = first_p ? lra_constraint_new_regno_start : max_reg_num ();\n   /* Mark used hard regs for target stack size calulations.  */\n@@ -4088,7 +4121,12 @@ lra_constraints (bool first_p)\n \t\t   paradoxical subregs.  */\n \t\t|| (MEM_P (x)\n \t\t    && (GET_MODE_SIZE (lra_reg_info[i].biggest_mode)\n-\t\t\t> GET_MODE_SIZE (GET_MODE (x)))))\n+\t\t\t> GET_MODE_SIZE (GET_MODE (x))))\n+\t\t|| (pic_offset_table_rtx\n+\t\t    && ((CONST_POOL_OK_P (PSEUDO_REGNO_MODE (i), x)\n+\t\t\t && (targetm.preferred_reload_class\n+\t\t\t     (x, lra_get_allocno_class (i)) == NO_REGS))\n+\t\t\t|| contains_symbol_ref_p (x))))\n \t      ira_reg_equiv[i].defined_p = false;\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;"}, {"sha": "5f6f27cc7b004ccf59a61a83d19e2abbb24fb8e3", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -579,7 +579,8 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n       if (frame_pointer_needed)\n \tadd_to_hard_reg_set (&set_up_by_prologue.set, Pmode,\n \t\t\t     HARD_FRAME_POINTER_REGNUM);\n-      if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n+      if (pic_offset_table_rtx \n+\t  && (unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n \tadd_to_hard_reg_set (&set_up_by_prologue.set, Pmode,\n \t\t\t     PIC_OFFSET_TABLE_REGNUM);\n       if (crtl->drap_reg)"}, {"sha": "4d90fc23dcf07d325cbc85c1596ae15de1199f38", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -4274,6 +4274,20 @@ DEFHOOK\n \n HOOK_VECTOR_END (calls)\n \n+DEFHOOK\n+(use_pseudo_pic_reg,\n+ \"This hook should return 1 in case pseudo register should be created\\n\\\n+for pic_offset_table_rtx during function expand.\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+DEFHOOK\n+(init_pic_reg,\n+ \"Perform a target dependent initialization of pic_offset_table_rtx.\\n\\\n+This hook is called at the start of register allocation.\",\n+ void, (void),\n+ hook_void_void)\n+\n /* Return the diagnostic message string if conversion from FROMTYPE\n    to TOTYPE is not allowed, NULL otherwise.  */\n DEFHOOK"}, {"sha": "139ea44dfcbf14012c74d496ea28abe4e94a7ec8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -1,3 +1,13 @@\n+2014-10-13  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\tPR target/8340\n+\tPR middle-end/47602\n+\tPR rtl-optimization/55458\n+\t* gcc.target/i386/pic-1.c: Remove dg-error as test should pass now.\n+\t* gcc.target/i386/pr55458.c: Likewise.\n+\t* gcc.target/i386/pr47602.c: New.\n+\t* gcc.target/i386/pr23098.c: Move to XFAIL.\n+\n 2014-10-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR tree-optimization/62127"}, {"sha": "9b7da4d2e16515a7193df90dc8af6cba946afd88", "filename": "gcc/testsuite/gcc.target/i386/pic-1.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpic-1.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -5,11 +5,13 @@\n /* { dg-skip-if \"No Windows PIC\" { *-*-mingw* *-*-cygwin } { \"*\" } { \"\" } } */\n /* { dg-options \"-fPIC\" } */\n \n+/* Test verifies that %ebx is no longer fixed when generating PIC code on i686.  */\n+\n int foo ()\n {\n   static int a;\n \n-  __asm__ __volatile__ (  /* { dg-error \"PIC register\" } */\n+  __asm__ __volatile__ (\n     \"xorl %%ebx, %%ebx\\n\"\n     \"movl %%ebx, %0\\n\"\n     : \"=m\" (a)"}, {"sha": "7f118dcfbf6ad8dd31422dce65c63c55f715fdf8", "filename": "gcc/testsuite/gcc.target/i386/pr23098.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr23098.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr23098.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr23098.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -1,7 +1,7 @@\n /* PR rtl-optimization/23098 */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fPIC\" } */\n-/* { dg-final { scan-assembler-not \"\\.LC\\[0-9\\]\" { xfail *-*-vxworks* } } } */\n+/* { dg-final { scan-assembler-not \"\\.LC\\[0-9\\]\" { xfail *-*-* } } } */\n /* { dg-require-effective-target ia32 } */\n /* { dg-require-effective-target fpic } */\n "}, {"sha": "7164ca905db279e2f2fd6dbc12f794cef2005825", "filename": "gcc/testsuite/gcc.target/i386/pr55458.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55458.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb21886b9ea0c3836e401b75e0b8304b38aed2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55458.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55458.c?ref=bcb21886b9ea0c3836e401b75e0b8304b38aed2f", "patch": "@@ -2,10 +2,12 @@\n /* { dg-require-effective-target ia32 } */\n /* { dg-options \"-fPIC\" } */\n \n+/* Test verifies that %ebx is no longer fixed when generating PIC code on i686.  */\n+\n int a, b, c;\n \n void\n foo (void)\n {\n-  asm volatile (\"\":\"+m\" (a), \"+m\" (b), \"+m\" (c)); /* { dg-error \"operand has impossible constraints\" } */\n+  asm volatile (\"\":\"+m\" (a), \"+m\" (b), \"+m\" (c));\n }"}]}