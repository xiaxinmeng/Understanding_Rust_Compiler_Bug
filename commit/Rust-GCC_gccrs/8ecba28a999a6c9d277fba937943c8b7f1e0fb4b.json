{"sha": "8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjYmEyOGE5OTlhNmM5ZDI3N2ZiYTkzNzk0M2M4YjdmMWUwZmI0Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-17T17:10:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-17T17:10:34Z"}, "message": "Makefile.in (cfgcleanup.o): Add cselib.h dependancy.\n\n\t* Makefile.in (cfgcleanup.o): Add cselib.h dependancy.\n\t* basic-block.h (CLEANUP_THREADING): New constant.\n\t* cfgcleanup.c: Include cselib.h\n\t(thread_jump, mark_effect): New functions.\n\t(try_forward_edges): Do jump threading when asked for.\n\t* jump.c (mark_modified_reg, save_regs, num_same_regs, modified_regs,\n\tmodified_mem, thread_jumps, rtx_equal_for-thread_p): Kill.\n\t* rtl.h (thread_jumps, rtx_equal_for_thread_p): Kill.\n\t* toplev.c (rest_of_compilation): Do now call thread_jumps; use\n\tCLEANUP_THREAD instead.\n\nFrom-SVN: r48108", "tree": {"sha": "b310f6d4e86aabafa94250a0bfa8d932084402f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b310f6d4e86aabafa94250a0bfa8d932084402f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/comments", "author": null, "committer": null, "parents": [{"sha": "e9c46bb75e87f0c3568372c6db9b77334556e440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c46bb75e87f0c3568372c6db9b77334556e440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c46bb75e87f0c3568372c6db9b77334556e440"}], "stats": {"total": 753, "additions": 226, "deletions": 527}, "files": [{"sha": "ff1b4045af2d8ba5cb58693f18d1ce03785feacc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -1478,7 +1478,7 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\\n    function.h except.h $(GGC_H) \n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TIMEVAR_H)\\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h $(RECOG_H) toplev.h \\\n-   $(GGC_H) insn-config.h\n+   $(GGC_H) insn-config.h cselib.h\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\"}, {"sha": "264b9d8730f758743f7bf3f80bdb8a52ead29198", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -577,6 +577,7 @@ enum update_life_extent\n #define CLEANUP_PRE_LOOP\t16\t/* Take care to preserve syntactic loop\n \t\t\t\t\t   notes.  */\n #define CLEANUP_UPDATE_LIFE\t32\t/* Keep life information up to date.  */\n+#define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n /* Flags for loop discovery.  */\n \n #define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */"}, {"sha": "d13e3a053498125c16f3e0c79b57888428d401ba", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 215, "deletions": 35, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"cselib.h\"\n \n #include \"obstack.h\"\n \n@@ -82,6 +83,8 @@ static bool merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n static bool try_optimize_cfg\t\tPARAMS ((int));\n static bool try_simplify_condjump\tPARAMS ((basic_block));\n static bool try_forward_edges\t\tPARAMS ((int, basic_block));\n+static edge thread_jump\t\t\tPARAMS ((int, edge, basic_block));\n+static bool mark_effect\t\t\tPARAMS ((rtx, bitmap));\n static void notice_new_block\t\tPARAMS ((basic_block));\n static void update_forwarder_flag\tPARAMS ((basic_block));\n \f\n@@ -178,6 +181,154 @@ try_simplify_condjump (cbranch_block)\n   return true;\n }\n \f\n+/* Attempt to prove that operation is NOOP using CSElib or mark the effect\n+   on register.  Used by jump threading.  */\n+static bool\n+mark_effect (exp, nonequal)\n+  rtx exp;\n+  regset nonequal;\n+{\n+  switch (GET_CODE (exp))\n+    {\n+      /* In case we do clobber the register, mark it as equal, as we know the\n+         value is dead so it don't have to match.  */\n+      case CLOBBER:\n+\tif (REG_P (XEXP (exp, 0)))\n+\t  CLEAR_REGNO_REG_SET (nonequal, REGNO (XEXP (exp, 0)));\n+\treturn false;\n+      case SET:\n+\tif (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))\n+\t  return false;\n+\tif (GET_CODE (SET_SRC (exp)) != REG)\n+\t  return true;\n+\tSET_REGNO_REG_SET (nonequal, REGNO (SET_SRC (exp)));\n+\treturn false;\n+      default:\n+\treturn false;\n+    }\n+}\n+/* Attempt to prove that the basic block B will have no side effects and\n+   allways continues in the same edge if reached via E.  Return the edge\n+   if exist, NULL otherwise.  */\n+\n+static edge\n+thread_jump (mode, e, b)\n+     int mode;\n+     edge e;\n+     basic_block b;\n+{\n+  rtx set1, set2, cond1, cond2, insn;\n+  enum rtx_code code1, code2, reversed_code2;\n+  bool reverse1 = false;\n+  int i;\n+  regset nonequal;\n+  bool failed = false;\n+\n+  /* At the moment, we do handle only conditional jumps, but later we may\n+     want to extend this code to tablejumps and others.  */\n+  if (!e->src->succ->succ_next || e->src->succ->succ_next->succ_next)\n+    return NULL;\n+  if (!b->succ || !b->succ->succ_next || b->succ->succ_next->succ_next)\n+    return NULL;\n+\n+  /* Second branch must end with onlyjump, as we will eliminate the jump.  */\n+  if (!any_condjump_p (e->src->end) || !any_condjump_p (b->end)\n+      || !onlyjump_p (b->end))\n+    return NULL;\n+\n+  set1 = pc_set (e->src->end);\n+  set2 = pc_set (b->end);\n+  if (((e->flags & EDGE_FALLTHRU) != 0)\n+      != (XEXP (SET_SRC (set1), 0) == pc_rtx))\n+    reverse1 = true;\n+\n+  cond1 = XEXP (SET_SRC (set1), 0);\n+  cond2 = XEXP (SET_SRC (set2), 0);\n+  if (reverse1)\n+    code1 = reversed_comparison_code (cond1, b->end);\n+  else\n+    code1 = GET_CODE (cond1);\n+\n+  code2 = GET_CODE (cond2);\n+  reversed_code2 = reversed_comparison_code (cond2, b->end);\n+\n+  if (!comparison_dominates_p (code1, code2)\n+      && !comparison_dominates_p (code1, reversed_code2))\n+    return NULL;\n+\n+  /* Ensure that the comparison operators are equivalent.\n+     ??? This is far too pesimistic.  We should allow swapped operands,\n+     different CCmodes, or for example comparisons for interval, that\n+     dominate even when operands are not equivalent.  */\n+  if (!rtx_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n+      || !rtx_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n+    return NULL;\n+\n+  /* Short circuit cases where block B contains some side effects, as we can't\n+     safely bypass it.  */\n+  for (insn = NEXT_INSN (b->head); insn != NEXT_INSN (b->end);\n+       insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && side_effects_p (PATTERN (insn)))\n+      return NULL;\n+\n+  cselib_init ();\n+\n+  /* First process all values computed in the source basic block.  */\n+  for (insn = NEXT_INSN (e->src->head); insn != NEXT_INSN (e->src->end);\n+       insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      cselib_process_insn (insn);\n+\n+  nonequal = BITMAP_XMALLOC();\n+  CLEAR_REG_SET (nonequal);\n+  /* Now assume that we've continued by the edge E to B and continue\n+     processing as if it were same basic block.\n+   \n+     Our goal is to prove that whole block is an NOOP.  */\n+  for (insn = NEXT_INSN (b->head); insn != b->end && !failed;\n+       insn = NEXT_INSN (insn))\n+  {\n+    if (INSN_P (insn))\n+      {\n+        rtx pat = PATTERN (insn);\n+\n+        if (GET_CODE (pat) == PARALLEL)\n+\t  {\n+\t    for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t      failed |= mark_effect (XVECEXP (pat, 0, i), nonequal);\n+\t  }\n+\telse\n+\t  failed |= mark_effect (pat, nonequal);\n+      }\n+    cselib_process_insn (insn);\n+  }\n+\n+  /* Later we should clear nonequal of dead registers.  So far we don't\n+     have life information in cfg_cleanup.  */\n+  if (failed)\n+    goto failed_exit;\n+\n+  /* In case liveness information is available, we need to prove equivalence\n+     only of the live values.  */\n+  if (mode & CLEANUP_UPDATE_LIFE)\n+    AND_REG_SET (nonequal, b->global_live_at_end);\n+\n+  EXECUTE_IF_SET_IN_REG_SET (nonequal, 0, i, goto failed_exit;);\n+\n+  BITMAP_XFREE (nonequal);\n+  cselib_finish ();\n+  if ((comparison_dominates_p (code1, code2) != 0)\n+      != (XEXP (SET_SRC (set2), 0) == pc_rtx))\n+    return BRANCH_EDGE (b);\n+  else\n+    return FALLTHRU_EDGE (b);\n+\n+failed_exit:\n+  BITMAP_XFREE (nonequal);\n+  cselib_finish ();\n+  return NULL;\n+}\n+\f\n /* Attempt to forward edges leaving basic block B.\n    Return true if successful.  */\n \n@@ -187,12 +338,13 @@ try_forward_edges (mode, b)\n      int mode;\n {\n   bool changed = false;\n-  edge e, next;\n+  edge e, next, threaded_edge;\n \n   for (e = b->succ; e ; e = next)\n     {\n       basic_block target, first;\n       int counter;\n+      bool threaded = false;\n \n       next = e->succ_next;\n \n@@ -207,16 +359,32 @@ try_forward_edges (mode, b)\n       target = first = e->dest;\n       counter = 0;\n \n-      /* Look for the real destination of the jump.\n-         Avoid infinite loop in the infinite empty loop by counting\n-         up to n_basic_blocks.  */\n-      while (FORWARDER_BLOCK_P (target)\n-\t     && target->succ->dest != EXIT_BLOCK_PTR\n-\t     && counter < n_basic_blocks)\n+      while (counter < n_basic_blocks)\n \t{\n-\t  /* Bypass trivial infinite loops.  */\n-\t  if (target == target->succ->dest)\n-\t    counter = n_basic_blocks;\n+\t  basic_block new_target = NULL;\n+\t  bool new_target_threaded = false;\n+\n+\t  if (FORWARDER_BLOCK_P (target)\n+\t      && target->succ->dest != EXIT_BLOCK_PTR)\n+\t    {\n+\t      /* Bypass trivial infinite loops.  */\n+\t      if (target == target->succ->dest)\n+\t\tcounter = n_basic_blocks;\n+\t      new_target = target->succ->dest;\n+\t    }\n+\t  /* Allow to thread only over one edge at time to simplify updating\n+\t     of probabilities.  */\n+\t  else if ((mode & CLEANUP_THREADING) && !threaded)\n+\t    {\n+\t      threaded_edge = thread_jump (mode, e, target);\n+\t      if (threaded_edge)\n+\t\t{\n+\t\t  new_target = threaded_edge->dest;\n+\t\t  new_target_threaded = true;\n+\t\t}\n+\t    }\n+\t  if (!new_target)\n+\t    break;\n \n \t  /* Avoid killing of loop pre-headers, as it is the place loop\n \t     optimizer wants to hoist code to.\n@@ -241,8 +409,10 @@ try_forward_edges (mode, b)\n \t      if (GET_CODE (insn) == NOTE)\n \t\tbreak;\n \t    }\n-\t  target = target->succ->dest, counter++;\n-\t}\n+\t  counter++;\n+\t  target = new_target;\n+\t  threaded |= new_target_threaded;\n+  \t}\n \n       if (counter >= n_basic_blocks)\n \t{\n@@ -257,37 +427,47 @@ try_forward_edges (mode, b)\n \t  /* Save the values now, as the edge may get removed.  */\n \t  gcov_type edge_count = e->count;\n \t  int edge_probability = e->probability;\n+\t  int edge_frequency;\n \n-\t  if (redirect_edge_and_branch (e, target))\n+\t  if (threaded)\n \t    {\n-\t      /* We successfully forwarded the edge.  Now update profile\n-\t\t data: for each edge we traversed in the chain, remove\n-\t\t the original edge's execution count.  */\n-\t      int edge_frequency = ((edge_probability * b->frequency\n-\t\t\t\t     + REG_BR_PROB_BASE / 2)\n-\t\t\t\t    / REG_BR_PROB_BASE);\n-\n-\t      if (!FORWARDER_BLOCK_P (b) && forwarder_block_p (b))\n-\t\tBB_SET_FLAG (b, BB_FORWARDER_BLOCK);\n-\t      BB_SET_FLAG (b, BB_UPDATE_LIFE);\n-\n-\t      do\n-\t\t{\n-\t\t  first->count -= edge_count;\n-\t\t  first->succ->count -= edge_count;\n-\t\t  first->frequency -= edge_frequency;\n-\t\t  first = first->succ->dest;\n-\t\t}\n-\t      while (first != target);\n-\n-\t      changed = true;\n+\t      notice_new_block (redirect_edge_and_branch_force (e, target));\n+\t      if (rtl_dump_file)\n+\t        fprintf (rtl_dump_file, \"Conditionals threaded.\\n\");\n \t    }\n-\t  else\n+\t  else if (!redirect_edge_and_branch (e, target))\n \t    {\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Forwarding edge %i->%i to %i failed.\\n\",\n \t\t\t b->index, e->dest->index, target->index);\n+\t      continue;\n \t    }\n+\t  /* We successfully forwarded the edge.  Now update profile\n+\t     data: for each edge we traversed in the chain, remove\n+\t     the original edge's execution count.  */\n+\t  edge_frequency = ((edge_probability * b->frequency\n+\t\t\t     + REG_BR_PROB_BASE / 2)\n+\t\t\t    / REG_BR_PROB_BASE);\n+\n+\t  if (!FORWARDER_BLOCK_P (b) && forwarder_block_p (b))\n+\t    BB_SET_FLAG (b, BB_FORWARDER_BLOCK);\n+\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n+\n+\t  do\n+\t    {\n+\t      edge t;\n+\t      first->count -= edge_count;\n+\t      first->succ->count -= edge_count;\n+\t      first->frequency -= edge_frequency;\n+\t      if (first->succ->succ_next)\n+\t\tt = threaded_edge;\n+\t      else\n+\t\tt = first->succ;\n+\t      first = t->dest;\n+\t    }\n+\t  while (first != target);\n+\n+\t  changed = true;\n \t}\n     }\n "}, {"sha": "fcb3c61800bbfc8433ab9eba25f020048902d32f", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 467, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -69,7 +69,6 @@ static void invert_exp_1\t\tPARAMS ((rtx));\n static int invert_exp\t\t\tPARAMS ((rtx));\n static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n static void delete_prior_computation    PARAMS ((rtx, rtx));\n-static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n \f\n /* Alternate entry into the jump optimizer.  This entry point only rebuilds\n    the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping\n@@ -2427,469 +2426,3 @@ true_regnum (x)\n     }\n   return -1;\n }\n-\f\n-/* Optimize code of the form:\n-\n-\tfor (x = a[i]; x; ...)\n-\t  ...\n-\tfor (x = a[i]; x; ...)\n-\t  ...\n-      foo:\n-\n-   Loop optimize will change the above code into\n-\n-\tif (x = a[i])\n-\t  for (;;)\n-\t     { ...; if (! (x = ...)) break; }\n-\tif (x = a[i])\n-\t  for (;;)\n-\t     { ...; if (! (x = ...)) break; }\n-      foo:\n-\n-   In general, if the first test fails, the program can branch\n-   directly to `foo' and skip the second try which is doomed to fail.\n-   We run this after loop optimization and before flow analysis.  */\n-\n-/* When comparing the insn patterns, we track the fact that different\n-   pseudo-register numbers may have been used in each computation.\n-   The following array stores an equivalence -- same_regs[I] == J means\n-   that pseudo register I was used in the first set of tests in a context\n-   where J was used in the second set.  We also count the number of such\n-   pending equivalences.  If nonzero, the expressions really aren't the\n-   same.  */\n-\n-static int *same_regs;\n-\n-static int num_same_regs;\n-\n-/* Track any registers modified between the target of the first jump and\n-   the second jump.  They never compare equal.  */\n-\n-static char *modified_regs;\n-\n-/* Record if memory was modified.  */\n-\n-static int modified_mem;\n-\n-/* Called via note_stores on each insn between the target of the first\n-   branch and the second branch.  It marks any changed registers.  */\n-\n-static void\n-mark_modified_reg (dest, x, data)\n-     rtx dest;\n-     rtx x;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  int regno;\n-  unsigned int i;\n-\n-  if (GET_CODE (dest) == SUBREG)\n-    dest = SUBREG_REG (dest);\n-\n-  if (GET_CODE (dest) == MEM)\n-    modified_mem = 1;\n-\n-  if (GET_CODE (dest) != REG)\n-    return;\n-\n-  regno = REGNO (dest);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    modified_regs[regno] = 1;\n-  /* Don't consider a hard condition code register as modified,\n-     if it is only being set.  thread_jumps will check if it is set\n-     to the same value.  */\n-  else if (GET_MODE_CLASS (GET_MODE (dest)) != MODE_CC\n-\t   || GET_CODE (x) != SET\n-\t   || ! rtx_equal_p (dest, SET_DEST (x))\n-\t   || HARD_REGNO_NREGS (regno, GET_MODE (dest)) != 1)\n-    for (i = 0; i < HARD_REGNO_NREGS (regno, GET_MODE (dest)); i++)\n-      modified_regs[regno + i] = 1;\n-}\n-\n-/* F is the first insn in the chain of insns.  */\n-\n-void\n-thread_jumps (f, max_reg, flag_before_loop)\n-     rtx f;\n-     int max_reg;\n-     int flag_before_loop;\n-{\n-  /* Basic algorithm is to find a conditional branch,\n-     the label it may branch to, and the branch after\n-     that label.  If the two branches test the same condition,\n-     walk back from both branch paths until the insn patterns\n-     differ, or code labels are hit.  If we make it back to\n-     the target of the first branch, then we know that the first branch\n-     will either always succeed or always fail depending on the relative\n-     senses of the two branches.  So adjust the first branch accordingly\n-     in this case.  */\n-\n-  rtx label, b1, b2, t1, t2;\n-  enum rtx_code code1, code2;\n-  rtx b1op0, b1op1, b2op0, b2op1;\n-  int changed = 1;\n-  int i;\n-  int *all_reset;\n-  enum rtx_code reversed_code1, reversed_code2;\n-\n-  /* Allocate register tables and quick-reset table.  */\n-  modified_regs = (char *) xmalloc (max_reg * sizeof (char));\n-  same_regs = (int *) xmalloc (max_reg * sizeof (int));\n-  all_reset = (int *) xmalloc (max_reg * sizeof (int));\n-  for (i = 0; i < max_reg; i++)\n-    all_reset[i] = -1;\n-\n-  while (changed)\n-    {\n-      changed = 0;\n-\n-      for (b1 = f; b1; b1 = NEXT_INSN (b1))\n-\t{\n-\t  rtx set;\n-\t  rtx set2;\n-\n-\t  /* Get to a candidate branch insn.  */\n-\t  if (GET_CODE (b1) != JUMP_INSN\n-\t      || ! any_condjump_p (b1) || JUMP_LABEL (b1) == 0)\n-\t    continue;\n-\n-\t  memset (modified_regs, 0, max_reg * sizeof (char));\n-\t  modified_mem = 0;\n-\n-\t  memcpy (same_regs, all_reset, max_reg * sizeof (int));\n-\t  num_same_regs = 0;\n-\n-\t  label = JUMP_LABEL (b1);\n-\n-\t  /* Look for a branch after the target.  Record any registers and\n-\t     memory modified between the target and the branch.  Stop when we\n-\t     get to a label since we can't know what was changed there.  */\n-\t  for (b2 = NEXT_INSN (label); b2; b2 = NEXT_INSN (b2))\n-\t    {\n-\t      if (GET_CODE (b2) == CODE_LABEL)\n-\t\tbreak;\n-\n-\t      else if (GET_CODE (b2) == JUMP_INSN)\n-\t\t{\n-\t\t  /* If this is an unconditional jump and is the only use of\n-\t\t     its target label, we can follow it.  */\n-\t\t  if (any_uncondjump_p (b2)\n-\t\t      && onlyjump_p (b2)\n-\t\t      && JUMP_LABEL (b2) != 0\n-\t\t      && LABEL_NUSES (JUMP_LABEL (b2)) == 1)\n-\t\t    {\n-\t\t      b2 = JUMP_LABEL (b2);\n-\t\t      continue;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\n-\t      if (GET_CODE (b2) != CALL_INSN && GET_CODE (b2) != INSN)\n-\t\tcontinue;\n-\n-\t      if (GET_CODE (b2) == CALL_INSN)\n-\t\t{\n-\t\t  modified_mem = 1;\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (call_used_regs[i] && ! fixed_regs[i]\n-\t\t\t&& i != STACK_POINTER_REGNUM\n-\t\t\t&& i != FRAME_POINTER_REGNUM\n-\t\t\t&& i != HARD_FRAME_POINTER_REGNUM\n-\t\t\t&& i != ARG_POINTER_REGNUM)\n-\t\t      modified_regs[i] = 1;\n-\t\t}\n-\n-\t      note_stores (PATTERN (b2), mark_modified_reg, NULL);\n-\t    }\n-\n-\t  /* Check the next candidate branch insn from the label\n-\t     of the first.  */\n-\t  if (b2 == 0\n-\t      || GET_CODE (b2) != JUMP_INSN\n-\t      || b2 == b1\n-\t      || !any_condjump_p (b2)\n-\t      || !onlyjump_p (b2))\n-\t    continue;\n-\t  set = pc_set (b1);\n-\t  set2 = pc_set (b2);\n-\n-\t  /* Get the comparison codes and operands, reversing the\n-\t     codes if appropriate.  If we don't have comparison codes,\n-\t     we can't do anything.  */\n-\t  b1op0 = XEXP (XEXP (SET_SRC (set), 0), 0);\n-\t  b1op1 = XEXP (XEXP (SET_SRC (set), 0), 1);\n-\t  code1 = GET_CODE (XEXP (SET_SRC (set), 0));\n-\t  reversed_code1 = code1;\n-\t  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n-\t    code1 = reversed_comparison_code (XEXP (SET_SRC (set), 0), b1);\n-\t  else\n-\t    reversed_code1 = reversed_comparison_code (XEXP (SET_SRC (set), 0), b1);\n-\n-\t  b2op0 = XEXP (XEXP (SET_SRC (set2), 0), 0);\n-\t  b2op1 = XEXP (XEXP (SET_SRC (set2), 0), 1);\n-\t  code2 = GET_CODE (XEXP (SET_SRC (set2), 0));\n-\t  reversed_code2 = code2;\n-\t  if (XEXP (SET_SRC (set2), 1) == pc_rtx)\n-\t    code2 = reversed_comparison_code (XEXP (SET_SRC (set2), 0), b2);\n-\t  else\n-\t    reversed_code2 = reversed_comparison_code (XEXP (SET_SRC (set2), 0), b2);\n-\n-\t  /* If they test the same things and knowing that B1 branches\n-\t     tells us whether or not B2 branches, check if we\n-\t     can thread the branch.  */\n-\t  if (rtx_equal_for_thread_p (b1op0, b2op0, b2)\n-\t      && rtx_equal_for_thread_p (b1op1, b2op1, b2)\n-\t      && (comparison_dominates_p (code1, code2)\n-\t\t  || comparison_dominates_p (code1, reversed_code2)))\n-\n-\t    {\n-\t      t1 = prev_nonnote_insn (b1);\n-\t      t2 = prev_nonnote_insn (b2);\n-\n-\t      while (t1 != 0 && t2 != 0)\n-\t\t{\n-\t\t  if (t2 == label)\n-\t\t    {\n-\t\t      /* We have reached the target of the first branch.\n-\t\t         If there are no pending register equivalents,\n-\t\t\t we know that this branch will either always\n-\t\t\t succeed (if the senses of the two branches are\n-\t\t\t the same) or always fail (if not).  */\n-\t\t      rtx new_label;\n-\n-\t\t      if (num_same_regs != 0)\n-\t\t\tbreak;\n-\n-\t\t      if (comparison_dominates_p (code1, code2))\n-\t\t\tnew_label = JUMP_LABEL (b2);\n-\t\t      else\n-\t\t\tnew_label = get_label_after (b2);\n-\n-\t\t      if (JUMP_LABEL (b1) != new_label)\n-\t\t\t{\n-\t\t\t  rtx prev = PREV_INSN (new_label);\n-\n-\t\t\t  if (flag_before_loop\n-\t\t\t      && GET_CODE (prev) == NOTE\n-\t\t\t      && NOTE_LINE_NUMBER (prev) == NOTE_INSN_LOOP_BEG)\n-\t\t\t    {\n-\t\t\t      /* Don't thread to the loop label.  If a loop\n-\t\t\t\t label is reused, loop optimization will\n-\t\t\t\t be disabled for that loop.  */\n-\t\t\t      new_label = gen_label_rtx ();\n-\t\t\t      emit_label_after (new_label, PREV_INSN (prev));\n-\t\t\t    }\n-\t\t\t  changed |= redirect_jump (b1, new_label, 1);\n-\t\t\t}\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If either of these is not a normal insn (it might be\n-\t\t     a JUMP_INSN, CALL_INSN, or CODE_LABEL) we fail.  (NOTEs\n-\t\t     have already been skipped above.)  Similarly, fail\n-\t\t     if the insns are different.  */\n-\t\t  if (GET_CODE (t1) != INSN || GET_CODE (t2) != INSN\n-\t\t      || recog_memoized (t1) != recog_memoized (t2)\n-\t\t      || ! rtx_equal_for_thread_p (PATTERN (t1),\n-\t\t\t\t\t\t   PATTERN (t2), t2))\n-\t\t    break;\n-\n-\t\t  t1 = prev_nonnote_insn (t1);\n-\t\t  t2 = prev_nonnote_insn (t2);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Clean up.  */\n-  free (modified_regs);\n-  free (same_regs);\n-  free (all_reset);\n-}\n-\f\n-/* This is like RTX_EQUAL_P except that it knows about our handling of\n-   possibly equivalent registers and knows to consider volatile and\n-   modified objects as not equal.\n-\n-   YINSN is the insn containing Y.  */\n-\n-int\n-rtx_equal_for_thread_p (x, y, yinsn)\n-     rtx x, y;\n-     rtx yinsn;\n-{\n-  int i;\n-  int j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  code = GET_CODE (x);\n-  /* Rtx's of different codes cannot be equal.  */\n-  if (code != GET_CODE (y))\n-    return 0;\n-\n-  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n-     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n-\n-  if (GET_MODE (x) != GET_MODE (y))\n-    return 0;\n-\n-  /* For floating-point, consider everything unequal.  This is a bit\n-     pessimistic, but this pass would only rarely do anything for FP\n-     anyway.  */\n-  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      && FLOAT_MODE_P (GET_MODE (x)) && ! flag_unsafe_math_optimizations)\n-    return 0;\n-\n-  /* For commutative operations, the RTX match if the operand match in any\n-     order.  Also handle the simple binary and unary cases without a loop.  */\n-  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n-    return ((rtx_equal_for_thread_p (XEXP (x, 0), XEXP (y, 0), yinsn)\n-\t     && rtx_equal_for_thread_p (XEXP (x, 1), XEXP (y, 1), yinsn))\n-\t    || (rtx_equal_for_thread_p (XEXP (x, 0), XEXP (y, 1), yinsn)\n-\t\t&& rtx_equal_for_thread_p (XEXP (x, 1), XEXP (y, 0), yinsn)));\n-  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n-    return (rtx_equal_for_thread_p (XEXP (x, 0), XEXP (y, 0), yinsn)\n-\t    && rtx_equal_for_thread_p (XEXP (x, 1), XEXP (y, 1), yinsn));\n-  else if (GET_RTX_CLASS (code) == '1')\n-    return rtx_equal_for_thread_p (XEXP (x, 0), XEXP (y, 0), yinsn);\n-\n-  /* Handle special-cases first.  */\n-  switch (code)\n-    {\n-    case REG:\n-      if (REGNO (x) == REGNO (y) && ! modified_regs[REGNO (x)])\n-        return 1;\n-\n-      /* If neither is user variable or hard register, check for possible\n-\t equivalence.  */\n-      if (REG_USERVAR_P (x) || REG_USERVAR_P (y)\n-\t  || REGNO (x) < FIRST_PSEUDO_REGISTER\n-\t  || REGNO (y) < FIRST_PSEUDO_REGISTER)\n-\treturn 0;\n-\n-      if (same_regs[REGNO (x)] == -1)\n-\t{\n-\t  same_regs[REGNO (x)] = REGNO (y);\n-\t  num_same_regs++;\n-\n-\t  /* If this is the first time we are seeing a register on the `Y'\n-\t     side, see if it is the last use.  If not, we can't thread the\n-\t     jump, so mark it as not equivalent.  */\n-\t  if (REGNO_LAST_UID (REGNO (y)) != INSN_UID (yinsn))\n-\t    return 0;\n-\n-\t  return 1;\n-\t}\n-      else\n-\treturn (same_regs[REGNO (x)] == (int) REGNO (y));\n-\n-      break;\n-\n-    case MEM:\n-      /* If memory modified or either volatile, not equivalent.\n-\t Else, check address.  */\n-      if (modified_mem || MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n-\treturn 0;\n-\n-      return rtx_equal_for_thread_p (XEXP (x, 0), XEXP (y, 0), yinsn);\n-\n-    case ASM_INPUT:\n-      if (MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n-\treturn 0;\n-\n-      break;\n-\n-    case SET:\n-      /* Cancel a pending `same_regs' if setting equivalenced registers.\n-\t Then process source.  */\n-      if (GET_CODE (SET_DEST (x)) == REG\n-          && GET_CODE (SET_DEST (y)) == REG)\n-\t{\n-\t  if (same_regs[REGNO (SET_DEST (x))] == (int) REGNO (SET_DEST (y)))\n-\t    {\n-\t      same_regs[REGNO (SET_DEST (x))] = -1;\n-\t      num_same_regs--;\n-\t    }\n-\t  else if (REGNO (SET_DEST (x)) != REGNO (SET_DEST (y)))\n-\t    return 0;\n-\t}\n-      else\n-\t{\n-\t  if (rtx_equal_for_thread_p (SET_DEST (x), SET_DEST (y), yinsn) == 0)\n-\t    return 0;\n-\t}\n-\n-      return rtx_equal_for_thread_p (SET_SRC (x), SET_SRC (y), yinsn);\n-\n-    case LABEL_REF:\n-      return XEXP (x, 0) == XEXP (y, 0);\n-\n-    case SYMBOL_REF:\n-      return XSTR (x, 0) == XSTR (y, 0);\n-\n-    default:\n-      break;\n-    }\n-\n-  if (x == y)\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  if (XINT (x, i) != XINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return 0;\n-\n-\t  /* And the corresponding elements must match.  */\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (rtx_equal_for_thread_p (XVECEXP (x, i, j),\n-\t\t\t\t\tXVECEXP (y, i, j), yinsn) == 0)\n-\t      return 0;\n-\t  break;\n-\n-\tcase 'e':\n-\t  if (rtx_equal_for_thread_p (XEXP (x, i), XEXP (y, i), yinsn) == 0)\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'S':\n-\tcase 's':\n-\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\n-\tcase '0':\n-\tcase 't':\n-\t  break;\n-\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's,\n-\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  return 1;\n-}"}, {"sha": "0be72c1365439c35fe076f19421c889dcc238649", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -1788,8 +1788,6 @@ extern int true_regnum\t\t\tPARAMS ((rtx));\n extern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\n extern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\n extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n-extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n-extern int rtx_equal_for_thread_p\tPARAMS ((rtx, rtx, rtx));\n extern enum rtx_code reversed_comparison_code PARAMS ((rtx, rtx));\n extern enum rtx_code reversed_comparison_code_parts PARAMS ((enum rtx_code,\n \t\t\t\t\t\t\t     rtx, rtx, rtx));"}, {"sha": "bab08c8edac6ee3324c2a215740ff5f53293cb8a", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecba28a999a6c9d277fba937943c8b7f1e0fb4b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8ecba28a999a6c9d277fba937943c8b7f1e0fb4b", "patch": "@@ -2680,7 +2680,8 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     {\n       find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP\n+ \t\t   | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n       /* ??? Run if-conversion before delete_null_pointer_checks,\n          since the later does not preserve the CFG.  This should\n@@ -2721,13 +2722,6 @@ rest_of_compilation (decl)\n \n       reg_scan (insns, max_reg_num (), 1);\n \n-      if (flag_thread_jumps)\n-\t{\n-\t  timevar_push (TV_JUMP);\n-\t  thread_jumps (insns, max_reg_num (), 1);\n-\t  timevar_pop (TV_JUMP);\n-\t}\n-\n       tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n \n       /* If we are not running more CSE passes, then we are no longer\n@@ -2750,14 +2744,16 @@ rest_of_compilation (decl)\n       delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \n       /* Try to identify useless null pointer tests and delete them.  */\n-      if (flag_delete_null_pointer_checks)\n+      if (flag_delete_null_pointer_checks || flag_thread_jumps)\n \t{\n \t  timevar_push (TV_JUMP);\n \t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP\n+\t\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n-\t  delete_null_pointer_checks (insns);\n+\t  if (flag_delete_null_pointer_checks)\n+\t    delete_null_pointer_checks (insns);\n \t  /* CFG is no longer maintained up-to-date.  */\n \t  free_bb_for_insn ();\n \t  timevar_pop (TV_JUMP);\n@@ -2928,16 +2924,6 @@ rest_of_compilation (decl)\n \t    }\n \t}\n \n-      if (flag_thread_jumps)\n-\t{\n-\t  /* This pass of jump threading straightens out code\n-\t     that was kinked by loop optimization.  */\n-\t  timevar_push (TV_JUMP);\n-\t  reg_scan (insns, max_reg_num (), 0);\n-\t  thread_jumps (insns, max_reg_num (), 0);\n-\t  timevar_pop (TV_JUMP);\n-\t}\n-\n       close_dump_file (DFI_cse2, print_rtl, insns);\n       timevar_pop (TV_CSE2);\n \n@@ -2955,7 +2941,8 @@ rest_of_compilation (decl)\n   open_dump_file (DFI_cfg, decl);\n \n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n+  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n   check_function_return_warnings ();\n \n   /* It may make more sense to mark constant functions after dead code is"}]}