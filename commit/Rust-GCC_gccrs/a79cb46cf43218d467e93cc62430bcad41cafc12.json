{"sha": "a79cb46cf43218d467e93cc62430bcad41cafc12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5Y2I0NmNmNDMyMThkNDY3ZTkzY2M2MjQzMGJjYWQ0MWNhZmMxMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-01-09T06:42:19Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-01-09T06:42:19Z"}, "message": "StringBuilder.java (appendCodePoint): New method.\n\n\t* java/lang/StringBuilder.java (appendCodePoint): New method.\n\t(insert): New overloads.\n\t* java/lang/StringBuffer.java (StringBuffer): New constructor.\n\t(charAt): Remerged javadoc.\n\t(codePointAt, codePointBefore): New methods.\n\t(appendCodePoint): New method.\n\t(append): New overloads.\n\t(insert): Likewise.\n\t(trimToSize, codePointCount, offsetByCodePoints): New methods.\n\t* java/lang/Float.java (SIZE): New field.\n\t(valueOf): New method.\n\t* java/lang/natDouble.cc (initIDs): Removed.\n\t* java/lang/Double.java (static initializer): Removed.\n\t(SIZE): New field.\n\t(valueOf): New method.\n\t(initIDs): Removed.\n\nFrom-SVN: r109497", "tree": {"sha": "8d8125b902675158f355742846d7cbefd59dcdae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d8125b902675158f355742846d7cbefd59dcdae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a79cb46cf43218d467e93cc62430bcad41cafc12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79cb46cf43218d467e93cc62430bcad41cafc12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79cb46cf43218d467e93cc62430bcad41cafc12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79cb46cf43218d467e93cc62430bcad41cafc12/comments", "author": null, "committer": null, "parents": [{"sha": "5109f57e371ed55701b035a86bada3b5c8ef6418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5109f57e371ed55701b035a86bada3b5c8ef6418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5109f57e371ed55701b035a86bada3b5c8ef6418"}], "stats": {"total": 422, "additions": 391, "deletions": 31}, "files": [{"sha": "3770c6716076dda653b29a1c51bce736c75dc672", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,3 +1,22 @@\n+2006-01-08  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/StringBuilder.java (appendCodePoint): New method.\n+\t(insert): New overloads.\n+\t* java/lang/StringBuffer.java (StringBuffer): New constructor.\n+\t(charAt): Remerged javadoc.\n+\t(codePointAt, codePointBefore): New methods.\n+\t(appendCodePoint): New method.\n+\t(append): New overloads.\n+\t(insert): Likewise.\n+\t(trimToSize, codePointCount, offsetByCodePoints): New methods.\n+\t* java/lang/Float.java (SIZE): New field.\n+\t(valueOf): New method.\n+\t* java/lang/natDouble.cc (initIDs): Removed.\n+\t* java/lang/Double.java (static initializer): Removed.\n+\t(SIZE): New field.\n+\t(valueOf): New method.\n+\t(initIDs): Removed.\n+\n 2006-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libgcj/24940"}, {"sha": "92f8a230822657eda4c8b1ecb322bc88262a2593", "filename": "libjava/java/lang/Double.java", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FDouble.java?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,5 +1,5 @@\n /* Double.java -- object wrapper for double\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -38,7 +38,6 @@\n \n package java.lang;\n \n-import gnu.classpath.Configuration;\n \n /**\n  * Instances of class <code>Double</code> represent primitive\n@@ -88,6 +87,12 @@ public final class Double extends Number implements Comparable\n    */\n   public static final double NaN = 0.0 / 0.0;\n \n+  /**\n+   * The number of bits needed to represent a <code>double</code>.\n+   * @since 1.5\n+   */\n+  public static final int SIZE = 64;\n+\n   /**\n    * The primitive type <code>double</code> is represented by this\n    * <code>Class</code> object.\n@@ -102,18 +107,6 @@ public final class Double extends Number implements Comparable\n    */\n   private final double value;\n \n-  /**\n-   * Load native routines necessary for this class.\n-   */\n-  static\n-  {\n-    if (Configuration.INIT_LOAD_LIBRARY)\n-      {\n-\tSystem.loadLibrary(\"javalang\");\n-\tinitIDs();\n-      }\n-  }\n-\n   /**\n    * Create a <code>Double</code> from the primitive <code>double</code>\n    * specified.\n@@ -179,6 +172,22 @@ public static String toString(double d)\n     return toString(d, false);\n   }\n \n+  /**\n+   * Returns a <code>Double</code> object wrapping the value.\n+   * In contrast to the <code>Double</code> constructor, this method\n+   * may cache some values.  It is used by boxing conversion.\n+   *\n+   * @param val the value to wrap\n+   * @return the <code>Double</code>\n+   * \n+   * @since 1.5\n+   */\n+  public static Double valueOf(double val)\n+  {\n+    // We don't actually cache, but we could.\n+    return new Double(val);\n+  }\n+\n   /**\n    * Create a new <code>Double</code> object using the <code>String</code>.\n    *\n@@ -534,10 +543,4 @@ public static int compare(double x, double y)\n    */\n   // Package visible for use by Float.\n   static native String toString(double d, boolean isFloat);\n-\n-  /**\n-   * Initialize JNI cache.  This method is called only by the\n-   * static initializer when using JNI.\n-   */\n-  private static native void initIDs();\n }"}, {"sha": "7677ca4132ee57799354da74f600712434c4aba7", "filename": "libjava/java/lang/Float.java", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFloat.java?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,5 +1,5 @@\n /* Float.java -- object wrapper for float\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -93,6 +93,12 @@ public final class Float extends Number implements Comparable\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass('F');\n \n+  /**\n+   * The number of bits needed to represent a <code>float</code>.\n+   * @since 1.5\n+   */\n+  public static final int SIZE = 32;\n+\n   /**\n    * The immutable value of this Float.\n    *\n@@ -191,6 +197,22 @@ public static Float valueOf(String s)\n     return new Float(parseFloat(s));\n   }\n \n+  /**\n+   * Returns a <code>Float</code> object wrapping the value.\n+   * In contrast to the <code>Float</code> constructor, this method\n+   * may cache some values.  It is used by boxing conversion.\n+   *\n+   * @param val the value to wrap\n+   * @return the <code>Float</code>\n+   * \n+   * @since 1.5\n+   */\n+  public static Float valueOf(float val)\n+  {\n+    // We don't actually cache, but we could.\n+    return new Float(val);\n+  }\n+\n   /**\n    * Parse the specified <code>String</code> as a <code>float</code>. The\n    * extended BNF grammar is as follows:<br>"}, {"sha": "c3f112967c415dec847d5e523e747bedb1e77b45", "filename": "libjava/java/lang/StringBuffer.java", "status": "modified", "additions": 259, "deletions": 2, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,5 +1,5 @@\n /* StringBuffer.java -- Growable strings\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -147,6 +147,24 @@ public StringBuffer(String str)\n     str.getChars(0, count, value, 0);\n   }\n \n+  /**\n+   * Create a new <code>StringBuffer</code> with the characters from the\n+   * specified <code>CharSequence</code>. Initial capacity will be the\n+   * size of the CharSequence plus 16.\n+   *\n+   * @param sequence the <code>String</code> to convert\n+   * @throws NullPointerException if str is null\n+   *\n+   * @since 1.5\n+   */\n+  public StringBuffer(CharSequence sequence)\n+  {\n+    count = Math.max(0, sequence.length());\n+    value = new char[count + DEFAULT_CAPACITY];\n+    for (int i = 0; i < count; ++i)\n+      value[i] = sequence.charAt(i);\n+  }\n+\n   /**\n    * Get the length of the <code>String</code> this <code>StringBuffer</code>\n    * would create. Not to be confused with the <em>capacity</em> of the\n@@ -234,7 +252,6 @@ public synchronized void setLength(int newLength)\n    * @param index the index of the character to get, starting at 0\n    * @return the character at the specified index\n    * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n-   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    */\n   public synchronized char charAt(int index)\n   {\n@@ -243,6 +260,39 @@ public synchronized char charAt(int index)\n     return value[index];\n   }\n \n+  /**\n+   * Get the code point at the specified index.  This is like #charAt(int),\n+   * but if the character is the start of a surrogate pair, and the\n+   * following character completes the pair, then the corresponding\n+   * supplementary code point is returned.\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public synchronized int codePointAt(int index)\n+  {\n+    return Character.codePointAt(value, index, count);\n+  }\n+\n+  /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(int), but checks the characters at <code>index-1</code> and\n+   * <code>index-2</code> to see if they form a supplementary code point.\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public synchronized int codePointBefore(int index)\n+  {\n+    // Character.codePointBefore() doesn't perform this check.  We\n+    // could use the CharSequence overload, but this is just as easy.\n+    if (index >= count)\n+      throw new IndexOutOfBoundsException();\n+    return Character.codePointBefore(value, index, 1);\n+  }\n+\n   /**\n    * Get the specified array of characters. <code>srcOffset - srcEnd</code>\n    * characters will be copied into the array you pass in.\n@@ -340,6 +390,46 @@ public synchronized StringBuffer append(StringBuffer stringBuffer)\n     return this;\n   }\n \n+  /**\n+   * Append the <code>CharSequence</code> value of the argument to this\n+   * <code>StringBuffer</code>.\n+   *\n+   * @param sequence the <code>CharSequence</code> to append\n+   * @return this <code>StringBuffer</code>\n+   * @see #append(Object)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer append(CharSequence sequence)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    return append(sequence, 0, sequence.length());\n+  }\n+\n+  /**\n+   * Append the specified subsequence of the <code>CharSequence</code>\n+   * argument to this <code>StringBuffer</code>.\n+   *\n+   * @param sequence the <code>CharSequence</code> to append\n+   * @param start the starting index\n+   * @param end one past the ending index\n+   * @return this <code>StringBuffer</code>\n+   * @see #append(Object)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer append(CharSequence sequence,\n+\t\t\t\t\t  int start, int end)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    if (start < 0 || end < 0 || start > end || end > sequence.length())\n+      throw new IndexOutOfBoundsException();\n+    ensureCapacity_unsynchronized(this.count + end - start);\n+    for (int i = start; i < end; ++i)\n+      value[count++] = sequence.charAt(i);\n+    return this;\n+  }\n+\n   /**\n    * Append the <code>char</code> array to this <code>StringBuffer</code>.\n    * This is similar (but more efficient) than\n@@ -406,6 +496,25 @@ public synchronized StringBuffer append(char ch)\n     return this;\n   }\n \n+  /**\n+   * Append the code point to this <code>StringBuffer</code>.\n+   * This is like #append(char), but will append two characters\n+   * if a supplementary code point is given.\n+   *\n+   * @param code the code point to append\n+   * @return this <code>StringBuffer</code>\n+   * @see Character#toChars(int, char[], int)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer appendCodePoint(int code)\n+  {\n+    int len = Character.charCount(code);\n+    ensureCapacity_unsynchronized(count + len);\n+    Character.toChars(code, value, count);\n+    count += len;\n+    return this;\n+  }\n+\n   /**\n    * Append the <code>String</code> value of the argument to this\n    * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n@@ -656,6 +765,54 @@ public synchronized StringBuffer insert(int offset, String str)\n     return this;\n   }\n \n+  /**\n+   * Insert the <code>CharSequence</code> argument into this\n+   * <code>StringBuffer</code>.  If the sequence is null, the String\n+   * \"null\" is used instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param sequence the <code>CharSequence</code> to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws IndexOutOfBoundsException if offset is out of bounds\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer insert(int offset, CharSequence sequence)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    return insert(offset, sequence, 0, sequence.length());\n+  }\n+\n+  /**\n+   * Insert a subsequence of the <code>CharSequence</code> argument into this\n+   * <code>StringBuffer</code>.  If the sequence is null, the String\n+   * \"null\" is used instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param sequence the <code>CharSequence</code> to insert\n+   * @param start the starting index of the subsequence\n+   * @param end one past the ending index of the subsequence\n+   * @return this <code>StringBuffer</code>\n+   * @throws IndexOutOfBoundsException if offset, start,\n+   * or end are out of bounds\n+   * @since 1.5\n+   */\n+  public synchronized StringBuffer insert(int offset, CharSequence sequence,\n+\t\t\t\t\t  int start, int end)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    if (start < 0 || end < 0 || start > end || end > sequence.length())\n+      throw new IndexOutOfBoundsException();\n+    int len = end - start;\n+    ensureCapacity_unsynchronized(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    for (int i = start; i < end; ++i)\n+      value[offset++] = sequence.charAt(i);\n+    count += len;\n+    return this;\n+  }\n+\n   /**\n    * Insert the <code>char[]</code> argument into this\n    * <code>StringBuffer</code>.\n@@ -876,6 +1033,106 @@ public String toString()\n     return new String(this);\n   }\n \n+  /**\n+   * This may reduce the amount of memory used by the StringBuffer,\n+   * by resizing the internal array to remove unused space.  However,\n+   * this method is not required to resize, so this behavior cannot\n+   * be relied upon.\n+   * @since 1.5\n+   */\n+  public synchronized void trimToSize()\n+  {\n+    int wouldSave = value.length - count;\n+    // Some random heuristics: if we save less than 20 characters, who\n+    // cares.\n+    if (wouldSave < 20)\n+      return;\n+    // If we save more than 200 characters, shrink.\n+    // If we save more than 1/4 of the buffer, shrink.\n+    if (wouldSave > 200 || wouldSave * 4 > value.length)\n+      {\n+\tchar[] newValue = new char[count];\n+\tSystem.arraycopy(value, 0, newValue, 0, count);\n+\tvalue = newValue;\n+      }\n+  }\n+\n+  /**\n+   * Return the number of code points between two indices in the\n+   * <code>StringBuffer</code>.  An unpaired surrogate counts as a\n+   * code point for this purpose.  Characters outside the indicated\n+   * range are not examined, even if the range ends in the middle of a\n+   * surrogate pair.\n+   *\n+   * @param start the starting index\n+   * @param end one past the ending index\n+   * @return the number of code points\n+   * @since 1.5\n+   */\n+  public synchronized int codePointCount(int start, int end)\n+  {\n+    if (start < 0 || end >= count || start > end)\n+      throw new StringIndexOutOfBoundsException();\n+\n+    int count = 0;\n+    while (start < end)\n+      {\n+\tchar base = value[start];\n+\tif (base < Character.MIN_HIGH_SURROGATE\n+\t    || base > Character.MAX_HIGH_SURROGATE\n+\t    || start == end\n+\t    || start == count\n+\t    || value[start + 1] < Character.MIN_LOW_SURROGATE\n+\t    || value[start + 1] > Character.MAX_LOW_SURROGATE)\n+\t  {\n+\t    // Nothing.\n+\t  }\n+\telse\n+\t  {\n+\t    // Surrogate pair.\n+\t    ++start;\n+\t  }\n+\t++start;\n+\t++count;\n+      }\n+    return count;\n+  }\n+\n+  /**\n+   * Starting at the given index, this counts forward by the indicated\n+   * number of code points, and then returns the resulting index.  An\n+   * unpaired surrogate counts as a single code point for this\n+   * purpose.\n+   *\n+   * @param start the starting index\n+   * @param codePoints the number of code points\n+   * @return the resulting index\n+   * @since 1.5\n+   */\n+  public synchronized int offsetByCodePoints(int start, int codePoints)\n+  {\n+    while (codePoints > 0)\n+      {\n+\tchar base = value[start];\n+\tif (base < Character.MIN_HIGH_SURROGATE\n+\t    || base > Character.MAX_HIGH_SURROGATE\n+\t    || start == count\n+\t    || value[start + 1] < Character.MIN_LOW_SURROGATE\n+\t    || value[start + 1] > Character.MAX_LOW_SURROGATE)\n+\t  {\n+\t    // Nothing.\n+\t  }\n+\telse\n+\t  {\n+\t    // Surrogate pair.\n+\t    ++start;\n+\t  }\n+\t++start;\n+\t--codePoints;\n+      }\n+    return start;\n+  }\n+\n   /**\n    * An unsynchronized version of ensureCapacity, used internally to avoid\n    * the cost of a second lock on the same object. This also has the side"}, {"sha": "5990a6d8dd5e6c6cdda2b86c3e9ec1035d72a1e6", "filename": "libjava/java/lang/StringBuilder.java", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FStringBuilder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FStringBuilder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuilder.java?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,5 +1,5 @@\n /* StringBuilder.java -- Unsynchronized growable strings\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -463,6 +463,25 @@ public StringBuilder append(CharSequence seq, int start,\n     return this;\n   }\n \n+  /**\n+   * Append the code point to this <code>StringBuilder</code>.\n+   * This is like #append(char), but will append two characters\n+   * if a supplementary code point is given.\n+   *\n+   * @param code the code point to append\n+   * @return this <code>StringBuilder</code>\n+   * @see Character#toChars(int, char[], int)\n+   * @since 1.5\n+   */\n+  public synchronized StringBuilder appendCodePoint(int code)\n+  {\n+    int len = Character.charCount(code);\n+    ensureCapacity(count + len);\n+    Character.toChars(code, value, count);\n+    count += len;\n+    return this;\n+  }\n+\n   /**\n    * Append the <code>String</code> value of the argument to this\n    * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n@@ -704,6 +723,52 @@ public StringBuilder insert(int offset, String str)\n     return this;\n   }\n \n+  /**\n+   * Insert the <code>CharSequence</code> argument into this\n+   * <code>StringBuilder</code>.  If the sequence is null, the String\n+   * \"null\" is used instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param sequence the <code>CharSequence</code> to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws IndexOutOfBoundsException if offset is out of bounds\n+   */\n+  public synchronized StringBuilder insert(int offset, CharSequence sequence)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    return insert(offset, sequence, 0, sequence.length());\n+  }\n+\n+  /**\n+   * Insert a subsequence of the <code>CharSequence</code> argument into this\n+   * <code>StringBuilder</code>.  If the sequence is null, the String\n+   * \"null\" is used instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param sequence the <code>CharSequence</code> to insert\n+   * @param start the starting index of the subsequence\n+   * @param end one past the ending index of the subsequence\n+   * @return this <code>StringBuilder</code>\n+   * @throws IndexOutOfBoundsException if offset, start,\n+   * or end are out of bounds\n+   */\n+  public synchronized StringBuilder insert(int offset, CharSequence sequence,\n+                      int start, int end)\n+  {\n+    if (sequence == null)\n+      sequence = \"null\";\n+    if (start < 0 || end < 0 || start > end || end > sequence.length())\n+      throw new IndexOutOfBoundsException();\n+    int len = end - start;\n+    ensureCapacity(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    for (int i = start; i < end; ++i)\n+      value[offset++] = sequence.charAt(i);\n+    count += len;\n+    return this;\n+  }\n+\n   /**\n    * Insert the <code>char[]</code> argument into this\n    * <code>StringBuilder</code>."}, {"sha": "24dad8a6318b3a5ce98ded727240491bdeb37099", "filename": "libjava/java/lang/natDouble.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FnatDouble.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79cb46cf43218d467e93cc62430bcad41cafc12/libjava%2Fjava%2Flang%2FnatDouble.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatDouble.cc?ref=a79cb46cf43218d467e93cc62430bcad41cafc12", "patch": "@@ -1,6 +1,6 @@\n // natDouble.cc - Implementation of java.lang.Double native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2003, 2005  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003, 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -211,9 +211,3 @@ java::lang::Double::parseDouble(jstring str)\n     }\n   throw new NumberFormatException(str);\n }\n-\n-void\n-java::lang::Double::initIDs()\n-{\n-  // Not used in libgcj\n-}"}]}