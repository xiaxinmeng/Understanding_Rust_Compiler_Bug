{"sha": "14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRkM2RjMzQ4ZWEzZjBhZDExODBhNDFkMjJjNzkwMmRjMjY5NWFmYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-20T23:34:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-20T23:34:10Z"}, "message": "reload.c (find_reloads_address): Reload the sum of a LO_SUM and a CONST_INT.\n\n\t* reload.c (find_reloads_address): Reload the sum of a LO_SUM and\n\ta CONST_INT.\n\nFrom-SVN: r86342", "tree": {"sha": "9fbd6951ec335b2e9c4bc5c74e765668d5ee5d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fbd6951ec335b2e9c4bc5c74e765668d5ee5d8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d3dc348ea3f0ad1180a41d22c7902dc2695afa/comments", "author": null, "committer": null, "parents": [{"sha": "0893e22fddd37e89ad9a0bd2bb7494ff180605b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0893e22fddd37e89ad9a0bd2bb7494ff180605b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0893e22fddd37e89ad9a0bd2bb7494ff180605b5"}], "stats": {"total": 107, "additions": 58, "deletions": 49}, "files": [{"sha": "205e4d705e3b0312a169a128d76457372e565707", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d3dc348ea3f0ad1180a41d22c7902dc2695afa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d3dc348ea3f0ad1180a41d22c7902dc2695afa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "patch": "@@ -1,3 +1,8 @@\n+2004-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* reload.c (find_reloads_address): Reload the sum of a LO_SUM and\n+\ta CONST_INT.\n+\n 2004-08-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/17099"}, {"sha": "715e58fa127b0af945c83e961493d427543cadac", "filename": "gcc/reload.c", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d3dc348ea3f0ad1180a41d22c7902dc2695afa/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d3dc348ea3f0ad1180a41d22c7902dc2695afa/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=14d3dc348ea3f0ad1180a41d22c7902dc2695afa", "patch": "@@ -4647,6 +4647,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n {\n   int regno;\n   int removed_and = 0;\n+  int op_index;\n   rtx tem;\n \n   /* If the address is a register, see if it is a legitimate address and\n@@ -4892,70 +4893,73 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n      Handle all base registers here, not just fp/ap/sp, because on some\n      targets (namely SPARC) we can also get invalid addresses from preventive\n-     subreg big-endian corrections made by find_reloads_toplev.\n+     subreg big-endian corrections made by find_reloads_toplev.  We\n+     can also get expressions involving LO_SUM (rather than PLUS) from\n+     find_reloads_subreg_address.\n \n      If we decide to do something, it must be that `double_reg_address_ok'\n      is true.  We generate a reload of the base register + constant and\n      rework the sum so that the reload register will be added to the index.\n      This is safe because we know the address isn't shared.\n \n      We check for the base register as both the first and second operand of\n-     the innermost PLUS.  */\n-\n-  else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n-\t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && REG_P (XEXP (XEXP (ad, 0), 0))\n-\t   && REGNO (XEXP (XEXP (ad, 0), 0)) < FIRST_PSEUDO_REGISTER\n-\t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 0), mode)\n-\t       || XEXP (XEXP (ad, 0), 0) == frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 0) == hard_frame_pointer_rtx\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 0) == arg_pointer_rtx\n-#endif\n-\t       || XEXP (XEXP (ad, 0), 0) == stack_pointer_rtx)\n-\t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 1)))\n+     the innermost PLUS and/or LO_SUM.  */\n+\n+  for (op_index = 0; op_index < 2; ++op_index)\n     {\n-      *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n-\t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 0),\n-\t\t\t\t\t       INTVAL (XEXP (ad, 1))),\n-\t\t\t\tXEXP (XEXP (ad, 0), 1));\n-      find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0),\n-\t\t\t\t MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n-      find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n-\t\t\t      type, 0, insn);\n+      rtx operand;\n \n-      return 0;\n-    }\n+      if (!(GET_CODE (ad) == PLUS \n+\t    && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+\t    && (GET_CODE (XEXP (ad, 0)) == PLUS\n+\t\t|| GET_CODE (XEXP (ad, 0)) == LO_SUM)))\n+\tcontinue;\n \n-  else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n-\t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && REG_P (XEXP (XEXP (ad, 0), 1))\n-\t   && REGNO (XEXP (XEXP (ad, 0), 1)) < FIRST_PSEUDO_REGISTER\n-\t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 1), mode)\n-\t       || XEXP (XEXP (ad, 0), 1) == frame_pointer_rtx\n+      operand = XEXP (XEXP (ad, 0), op_index);\n+      if (!(REG_P (operand) \n+\t    || REGNO (operand) < FIRST_PSEUDO_REGISTER))\n+\tcontinue;\n+\n+      if ((REG_MODE_OK_FOR_BASE_P (operand, mode)\n+\t   || operand == frame_pointer_rtx\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 1) == hard_frame_pointer_rtx\n+\t   || operand == hard_frame_pointer_rtx\n #endif\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 1) == arg_pointer_rtx\n+\t   || operand == arg_pointer_rtx\n #endif\n-\t       || XEXP (XEXP (ad, 0), 1) == stack_pointer_rtx)\n-\t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 0)))\n-    {\n-      *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n-\t\t\t\tXEXP (XEXP (ad, 0), 0),\n-\t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 1),\n-\t\t\t\t\t       INTVAL (XEXP (ad, 1))));\n-      find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),\n-\t\t\t\t MODE_BASE_REG_CLASS (mode),\n-\t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n-      find_reloads_address_1 (mode, XEXP (ad, 0), 1, &XEXP (ad, 0), opnum,\n-\t\t\t      type, 0, insn);\n+\t   || operand == stack_pointer_rtx)\n+\t  && ! maybe_memory_address_p (mode, ad, \n+\t\t\t\t       &XEXP (XEXP (ad, 0), op_index)))\n+\t{\n+\t  rtx offset_reg;\n+\t  rtx addend;\n+\n+\t  offset_reg = plus_constant (operand, INTVAL (XEXP (ad, 1)));\n+\t  addend = XEXP (XEXP (ad, 0), 1 - op_index);\n+\t  \n+\t  /* Form the adjusted address.  */\n+\t  if (GET_CODE (XEXP (ad, 0)) == PLUS)\n+\t    ad = gen_rtx_PLUS (GET_MODE (ad), \n+\t\t\t       op_index == 0 ? offset_reg : addend, \n+\t\t\t       op_index == 0 ? addend : offset_reg);\n+\t  else\n+\t    ad = gen_rtx_LO_SUM (GET_MODE (ad), \n+\t\t\t\t op_index == 0 ? offset_reg : addend, \n+\t\t\t\t op_index == 0 ? addend : offset_reg);\n+\t  *loc = ad;\n+\n+\t  find_reloads_address_part (XEXP (ad, op_index), \n+\t\t\t\t     &XEXP (ad, op_index),\n+\t\t\t\t     MODE_BASE_REG_CLASS (mode),\n+\t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n+\t  find_reloads_address_1 (mode, \n+\t\t\t\t  XEXP (ad, 1 - op_index), 1, \n+\t\t\t\t  &XEXP (ad, 1 - op_index), opnum,\n+\t\t\t\t  type, 0, insn);\n \n-      return 0;\n+\t  return 0;\n+\t}\n     }\n \n   /* See if address becomes valid when an eliminable register"}]}