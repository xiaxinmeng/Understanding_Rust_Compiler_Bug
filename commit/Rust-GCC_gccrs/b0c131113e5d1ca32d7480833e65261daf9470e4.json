{"sha": "b0c131113e5d1ca32d7480833e65261daf9470e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjMTMxMTEzZTVkMWNhMzJkNzQ4MDgzM2U2NTI2MWRhZjk0NzBlNA==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2010-08-07T09:20:41Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2010-08-07T09:20:41Z"}, "message": "Cortex A9 VFP Pipeline description.\n\n2010-08-07  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n        * config/arm/cortex-a9.md: Rewrite VFP Pipeline description.\n        * config/arm/arm.c (arm_xscale_tune): Initialize sched_adjust_cost.\n         (arm_fastmul_tune,arm_slowmul_tune, arm_9e_tune): Likewise.\n         (arm_adjust_cost): Split into xscale_sched_adjust_cost and a\n         generic part.\n         (cortex_a9_sched_adjust_cost): New function.\n         (xscale_sched_adjust_cost): New function.\n        * config/arm/arm-protos.h (struct tune_params): New field\n        sched_adjust_cost.\n        * config/arm/arm-cores.def: Adjust costs for cortex-a9.\n\nFrom-SVN: r162976", "tree": {"sha": "1e4aa81758063ded8d6614c4560cce1ae006477f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e4aa81758063ded8d6614c4560cce1ae006477f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c131113e5d1ca32d7480833e65261daf9470e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c131113e5d1ca32d7480833e65261daf9470e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c131113e5d1ca32d7480833e65261daf9470e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c131113e5d1ca32d7480833e65261daf9470e4/comments", "author": null, "committer": null, "parents": [{"sha": "e35546016b03c2c21584c03fd3901fd9fafc3dc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35546016b03c2c21584c03fd3901fd9fafc3dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35546016b03c2c21584c03fd3901fd9fafc3dc1"}], "stats": {"total": 290, "additions": 217, "deletions": 73}, "files": [{"sha": "96970ba1dd6b6932c848d2b7d128089cf400dce2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0c131113e5d1ca32d7480833e65261daf9470e4", "patch": "@@ -1,3 +1,16 @@\n+2010-08-07  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+        * config/arm/cortex-a9.md: Rewrite VFP Pipeline description.\n+        * config/arm/arm.c (arm_xscale_tune): Initialize sched_adjust_cost.\n+         (arm_fastmul_tune,arm_slowmul_tune, arm_9e_tune): Likewise.\n+         (arm_adjust_cost): Split into xscale_sched_adjust_cost and a\n+         generic part.\n+         (cortex_a9_sched_adjust_cost): New function.\n+         (xscale_sched_adjust_cost): New function.\n+        * config/arm/arm-protos.h (struct tune_params): New field\n+        sched_adjust_cost.\n+        * config/arm/arm-cores.def: Adjust costs for cortex-a9.\n+\n 2010-08-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/44942"}, {"sha": "1a02ba0522f86355f6c2a6f84351ee9514a2d645", "filename": "gcc/config/arm/arm-cores.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=b0c131113e5d1ca32d7480833e65261daf9470e4", "patch": "@@ -120,7 +120,7 @@ ARM_CORE(\"arm1156t2-s\",\t  arm1156t2s,\t6T2,\t\t\t\t FL_LDSCHED, 9e)\n ARM_CORE(\"arm1156t2f-s\",  arm1156t2fs,  6T2,\t\t\t\t FL_LDSCHED | FL_VFPV2, 9e)\n ARM_CORE(\"cortex-a5\",\t  cortexa5,\t7A,\t\t\t\t FL_LDSCHED, 9e)\n ARM_CORE(\"cortex-a8\",\t  cortexa8,\t7A,\t\t\t\t FL_LDSCHED, 9e)\n-ARM_CORE(\"cortex-a9\",\t  cortexa9,\t7A,\t\t\t\t FL_LDSCHED, 9e)\n+ARM_CORE(\"cortex-a9\",\t  cortexa9,\t7A,\t\t\t\t FL_LDSCHED, cortex_a9)\n ARM_CORE(\"cortex-r4\",\t  cortexr4,\t7R,\t\t\t\t FL_LDSCHED, 9e)\n ARM_CORE(\"cortex-r4f\",\t  cortexr4f,\t7R,\t\t\t\t FL_LDSCHED, 9e)\n ARM_CORE(\"cortex-m4\",\t  cortexm4,\t7EM,\t\t\t\t FL_LDSCHED, 9e)"}, {"sha": "61701a80d35d30b5ce60d42ff695efc522dff52a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=b0c131113e5d1ca32d7480833e65261daf9470e4", "patch": "@@ -216,6 +216,7 @@ extern void arm_order_regs_for_local_alloc (void);\n struct tune_params\n {\n   bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);\n+  bool (*sched_adjust_cost) (rtx, rtx, rtx, int *);\n   int constant_limit;\n };\n "}, {"sha": "a406c296eba7f3f1136714c581499db2d7ae2781", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 128, "deletions": 23, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b0c131113e5d1ca32d7480833e65261daf9470e4", "patch": "@@ -228,6 +228,8 @@ static void arm_asm_trampoline_template (FILE *);\n static void arm_trampoline_init (rtx, tree, rtx);\n static rtx arm_trampoline_adjust_address (rtx);\n static rtx arm_pic_static_addr (rtx orig, rtx reg);\n+static bool cortex_a9_sched_adjust_cost (rtx, rtx, rtx, int *);\n+static bool xscale_sched_adjust_cost (rtx, rtx, rtx, int *);\n \n \f\n /* Table of machine attributes.  */\n@@ -766,27 +768,39 @@ struct processors\n const struct tune_params arm_slowmul_tune =\n {\n   arm_slowmul_rtx_costs,\n+  NULL,\n   3\n };\n \n const struct tune_params arm_fastmul_tune =\n {\n   arm_fastmul_rtx_costs,\n+  NULL,\n   1\n };\n \n const struct tune_params arm_xscale_tune =\n {\n   arm_xscale_rtx_costs,\n+  xscale_sched_adjust_cost,\n   2\n };\n \n const struct tune_params arm_9e_tune =\n {\n   arm_9e_rtx_costs,\n+  NULL,\n   1\n };\n \n+const struct tune_params arm_cortex_a9_tune =\n+{\n+  arm_9e_rtx_costs,\n+  cortex_a9_sched_adjust_cost,\n+  1\n+};\n+\n+\n /* Not all of these give usefully different compilation alternatives,\n    but there is no simple way of generalizing them.  */\n static const struct processors all_cores[] =\n@@ -7691,30 +7705,14 @@ arm_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   return TARGET_32BIT ? arm_arm_address_cost (x) : arm_thumb_address_cost (x);\n }\n-/* This function implements the target macro TARGET_SCHED_ADJUST_COST.\n-   It corrects the value of COST based on the relationship between\n-   INSN and DEP through the dependence LINK.  It returns the new\n-   value.  */\n-  \n-static int\n-arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n-{\n-  rtx i_pat, d_pat;\n-\n-  /* When generating Thumb-1 code, we want to place flag-setting operations\n-     close to a conditional branch which depends on them, so that we can\n-     omit the comparison.  */\n-  if (TARGET_THUMB1\n-      && REG_NOTE_KIND (link) == 0\n-      && recog_memoized (insn) == CODE_FOR_cbranchsi4_insn\n-      && recog_memoized (dep) >= 0\n-      && get_attr_conds (dep) == CONDS_SET)\n-    return 0;\n \n+/* Adjust cost hook for XScale.  */\n+static bool\n+xscale_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+{\n   /* Some true dependencies can have a higher cost depending\n      on precisely how certain input operands are used.  */\n-  if (arm_tune_xscale\n-      && REG_NOTE_KIND (link) == 0\n+  if (REG_NOTE_KIND(link) == 0\n       && recog_memoized (insn) >= 0\n       && recog_memoized (dep) >= 0)\n     {\n@@ -7748,10 +7746,116 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \n \t      if (reg_overlap_mentioned_p (recog_data.operand[opno],\n \t\t\t\t\t   shifted_operand))\n-\t\treturn 2;\n+\t\t{\n+\t\t  *cost = 2;\n+\t\t  return false;\n+\t\t}\n \t    }\n \t}\n     }\n+  return true;\n+}\n+\n+/* Adjust cost hook for Cortex A9.  */\n+static bool\n+cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+{\n+  switch (REG_NOTE_KIND (link))\n+    {\n+    case REG_DEP_ANTI:\n+      *cost = 0;\n+      return false;\n+\n+    case REG_DEP_TRUE:\n+    case REG_DEP_OUTPUT:\n+\tif (recog_memoized (insn) >= 0\n+\t    && recog_memoized (dep) >= 0)\n+\t  {\n+\t    if (GET_CODE (PATTERN (insn)) == SET)\n+\t      {\n+\t\tif (GET_MODE_CLASS \n+\t\t    (GET_MODE (SET_DEST (PATTERN (insn)))) == MODE_FLOAT\n+\t\t  || GET_MODE_CLASS \n+\t\t    (GET_MODE (SET_SRC (PATTERN (insn)))) == MODE_FLOAT)\n+\t\t  {\n+\t\t    enum attr_type attr_type_insn = get_attr_type (insn);\n+\t\t    enum attr_type attr_type_dep = get_attr_type (dep);\n+\n+\t\t    /* By default all dependencies of the form\n+\t\t       s0 = s0 <op> s1\n+\t\t       s0 = s0 <op> s2\n+\t\t       have an extra latency of 1 cycle because\n+\t\t       of the input and output dependency in this\n+\t\t       case. However this gets modeled as an true\n+\t\t       dependency and hence all these checks.  */\n+\t\t    if (REG_P (SET_DEST (PATTERN (insn)))\n+\t\t\t&& REG_P (SET_DEST (PATTERN (dep)))\n+\t\t\t&& reg_overlap_mentioned_p (SET_DEST (PATTERN (insn)),\n+\t\t\t\t\t\t    SET_DEST (PATTERN (dep))))\n+\t\t      {\n+\t\t\t/* FMACS is a special case where the dependant\n+\t\t\t   instruction can be issued 3 cycles before\n+\t\t\t   the normal latency in case of an output \n+\t\t\t   dependency.  */\n+\t\t\tif ((attr_type_insn == TYPE_FMACS\n+\t\t\t     || attr_type_insn == TYPE_FMACD)\n+\t\t\t    && (attr_type_dep == TYPE_FMACS\n+\t\t\t\t|| attr_type_dep == TYPE_FMACD))\n+\t\t\t  {\n+\t\t\t    if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+\t\t\t      *cost = insn_default_latency (dep) - 3;\n+\t\t\t    else\n+\t\t\t      *cost = insn_default_latency (dep);\n+\t\t\t    return false;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+\t\t\t      *cost = insn_default_latency (dep) + 1;\n+\t\t\t    else\n+\t\t\t      *cost = insn_default_latency (dep);\n+\t\t\t  }\n+\t\t\treturn false;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\tbreak;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return true;\n+}\n+\n+/* This function implements the target macro TARGET_SCHED_ADJUST_COST.\n+   It corrects the value of COST based on the relationship between\n+   INSN and DEP through the dependence LINK.  It returns the new\n+   value. There is a per-core adjust_cost hook to adjust scheduler costs\n+   and the per-core hook can choose to completely override the generic \n+   adjust_cost function. Only put bits of code into arm_adjust_cost that \n+   are common across all cores.  */\n+static int\n+arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n+{\n+  rtx i_pat, d_pat;\n+\n+ /* When generating Thumb-1 code, we want to place flag-setting operations\n+    close to a conditional branch which depends on them, so that we can\n+    omit the comparison. */\n+  if (TARGET_THUMB1\n+      && REG_NOTE_KIND (link) == 0\n+      && recog_memoized (insn) == CODE_FOR_cbranchsi4_insn\n+      && recog_memoized (dep) >= 0\n+      && get_attr_conds (dep) == CONDS_SET)\n+    return 0;\n+\n+  if (current_tune->sched_adjust_cost != NULL)\n+    {\n+      if (!current_tune->sched_adjust_cost (insn, link, dep, &cost))\n+\treturn cost;\n+    }\n \n   /* XXX This is not strictly true for the FPA.  */\n   if (REG_NOTE_KIND (link) == REG_DEP_ANTI\n@@ -7774,7 +7878,8 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \t constant pool are cached, and that others will miss.  This is a\n \t hack.  */\n \n-      if ((GET_CODE (src_mem) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (src_mem))\n+      if ((GET_CODE (src_mem) == SYMBOL_REF \n+\t   && CONSTANT_POOL_ADDRESS_P (src_mem))\n \t  || reg_mentioned_p (stack_pointer_rtx, src_mem)\n \t  || reg_mentioned_p (frame_pointer_rtx, src_mem)\n \t  || reg_mentioned_p (hard_frame_pointer_rtx, src_mem))"}, {"sha": "27ad70569e413399086e218eb06414140a00e21c", "filename": "gcc/config/arm/cortex-a9.md", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Fcortex-a9.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c131113e5d1ca32d7480833e65261daf9470e4/gcc%2Fconfig%2Farm%2Fcortex-a9.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a9.md?ref=b0c131113e5d1ca32d7480833e65261daf9470e4", "patch": "@@ -2,8 +2,10 @@\n ;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n ;; Originally written by CodeSourcery for VFP.\n ;;\n-;; Integer core pipeline description contributed by ARM Ltd.\n-;;\n+;; Rewritten by Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>\n+;; Integer Pipeline description contributed by ARM Ltd.\n+;; VFP Pipeline description rewritten and contributed by ARM Ltd.\n+\n ;; This file is part of GCC.\n ;;\n ;; GCC is free software; you can redistribute it and/or modify it\n@@ -22,28 +24,27 @@\n \n (define_automaton \"cortex_a9\")\n \n-;; The Cortex-A9 integer core is modelled as a dual issue pipeline that has\n+;; The Cortex-A9 core is modelled as a dual issue pipeline that has\n ;; the following components.\n ;; 1. 1 Load Store Pipeline.\n ;; 2. P0 / main pipeline for data processing instructions.\n ;; 3. P1 / Dual pipeline for Data processing instructions.\n ;; 4. MAC pipeline for multiply as well as multiply\n ;;    and accumulate instructions.\n-;; 5. 1 VFP / Neon pipeline.\n-;; The Load/Store and VFP/Neon pipeline are multiplexed.\n+;; 5. 1 VFP and an optional Neon unit.\n+;; The Load/Store, VFP and Neon issue pipeline are multiplexed.\n ;; The P0 / main pipeline and M1 stage of the MAC pipeline are\n ;;   multiplexed.\n ;; The P1 / dual pipeline and M2 stage of the MAC pipeline are\n ;;   multiplexed.\n-;; There are only 4 register read ports and hence at any point of\n+;; There are only 4 integer register read ports and hence at any point of\n ;; time we can't have issue down the E1 and the E2 ports unless\n ;; of course there are bypass paths that get exercised.\n ;; Both P0 and P1 have 2 stages E1 and E2.\n ;; Data processing instructions issue to E1 or E2 depending on\n ;; whether they have an early shift or not.\n \n-\n-(define_cpu_unit \"cortex_a9_vfp, cortex_a9_ls\" \"cortex_a9\")\n+(define_cpu_unit \"ca9_issue_vfp_neon, cortex_a9_ls\" \"cortex_a9\")\n (define_cpu_unit \"cortex_a9_p0_e1, cortex_a9_p0_e2\" \"cortex_a9\")\n (define_cpu_unit \"cortex_a9_p1_e1, cortex_a9_p1_e2\" \"cortex_a9\")\n (define_cpu_unit \"cortex_a9_p0_wb, cortex_a9_p1_wb\" \"cortex_a9\")\n@@ -71,11 +72,7 @@ cortex_a9_p1_e2 + cortex_a9_p0_e1 + cortex_a9_p1_e1\")\n \n ;; Issue at the same time along the load store pipeline and\n ;; the VFP / Neon pipeline is not possible.\n-;; FIXME:: At some point we need to model the issue\n-;; of the load store and the vfp being shared rather than anything else.\n-\n-(exclusion_set \"cortex_a9_ls\" \"cortex_a9_vfp\")\n-\n+(exclusion_set \"cortex_a9_ls\" \"ca9_issue_vfp_neon\")\n \n ;; Default data processing instruction without any shift\n ;; The only exception to this is the mov instruction\n@@ -101,31 +98,27 @@ cortex_a9_p1_e2 + cortex_a9_p0_e1 + cortex_a9_p1_e1\")\n \n (define_insn_reservation \"cortex_a9_load1_2\" 4\n   (and (eq_attr \"tune\" \"cortexa9\")\n-       (eq_attr \"type\" \"load1, load2, load_byte\"))\n+       (eq_attr \"type\" \"load1, load2, load_byte, f_loads, f_loadd\"))\n   \"cortex_a9_ls\")\n \n ;; Loads multiples and store multiples can't be issued for 2 cycles in a\n ;; row. The description below assumes that addresses are 64 bit aligned.\n ;; If not, there is an extra cycle latency which is not modelled.\n \n-;; FIXME:: This bit might need to be reworked when we get to\n-;; tuning for the VFP because strictly speaking the ldm\n-;; is sent to the LSU unit as is and there is only an\n-;; issue restriction between the LSU and the VFP/ Neon unit.\n-\n (define_insn_reservation \"cortex_a9_load3_4\" 5\n   (and (eq_attr \"tune\" \"cortexa9\")\n        (eq_attr \"type\" \"load3, load4\"))\n   \"cortex_a9_ls, cortex_a9_ls\")\n \n (define_insn_reservation \"cortex_a9_store1_2\" 0\n   (and (eq_attr \"tune\" \"cortexa9\")\n-       (eq_attr \"type\" \"store1, store2\"))\n+       (eq_attr \"type\" \"store1, store2, f_stores, f_stored\"))\n   \"cortex_a9_ls\")\n \n ;; Almost all our store multiples use an auto-increment\n ;; form. Don't issue back to back load and store multiples\n ;; because the load store unit will stall.\n+\n (define_insn_reservation \"cortex_a9_store3_4\" 0\n   (and (eq_attr \"tune\" \"cortexa9\")\n        (eq_attr \"type\" \"store3, store4\"))\n@@ -193,47 +186,79 @@ cortex_a9_store3_4, cortex_a9_store1_2,  cortex_a9_load3_4\")\n (define_insn_reservation \"cortex_a9_call\"  0\n   (and (eq_attr \"tune\" \"cortexa9\")\n        (eq_attr \"type\" \"call\"))\n-  \"cortex_a9_issue_branch + cortex_a9_multcycle1 + cortex_a9_ls + cortex_a9_vfp\")\n+  \"cortex_a9_issue_branch + cortex_a9_multcycle1 + cortex_a9_ls + ca9_issue_vfp_neon\")\n \n \n ;; Pipelining for VFP instructions.\n-\n-(define_insn_reservation \"cortex_a9_ffarith\" 1\n+;; Issue happens either along load store unit or the VFP / Neon unit.\n+;; Pipeline   Instruction Classification.\n+;; FPS - fcpys, ffariths, ffarithd,r_2_f,f_2_r\n+;; FP_ADD   - fadds, faddd, fcmps (1)\n+;; FPMUL   - fmul{s,d}, fmac{s,d}\n+;; FPDIV - fdiv{s,d}\n+(define_cpu_unit \"ca9fps\" \"cortex_a9\")\n+(define_cpu_unit \"ca9fp_add1, ca9fp_add2, ca9fp_add3, ca9fp_add4\" \"cortex_a9\")\n+(define_cpu_unit \"ca9fp_mul1, ca9fp_mul2 , ca9fp_mul3, ca9fp_mul4\" \"cortex_a9\")\n+(define_cpu_unit \"ca9fp_ds1\" \"cortex_a9\")\n+\n+\n+;; fmrs, fmrrd, fmstat and fmrx - The data is available after 1 cycle.\n+(define_insn_reservation \"cortex_a9_fps\" 2\n  (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fcpys,ffariths,ffarithd,fcmps,fcmpd,fconsts,fconstd\"))\n- \"cortex_a9_vfp\")\n+      (eq_attr \"type\" \"fcpys, fconsts, fconstd, ffariths, ffarithd, r_2_f, f_2_r, f_flag\"))\n+ \"ca9_issue_vfp_neon + ca9fps\")\n+\n+(define_bypass 1\n+  \"cortex_a9_fps\"\n+  \"cortex_a9_fadd, cortex_a9_fps, cortex_a9_fcmp, cortex_a9_dp, cortex_a9_dp_shift, cortex_a9_multiply\")\n+\n+;; Scheduling on the FP_ADD pipeline.\n+(define_reservation \"ca9fp_add\" \"ca9_issue_vfp_neon + ca9fp_add1, ca9fp_add2, ca9fp_add3, ca9fp_add4\")\n \n (define_insn_reservation \"cortex_a9_fadd\" 4\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fadds,faddd,f_cvt\"))\n- \"cortex_a9_vfp\")\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fadds, faddd, f_cvt\"))\n+  \"ca9fp_add\")\n \n-(define_insn_reservation \"cortex_a9_fmuls\" 5\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fmuls\"))\n- \"cortex_a9_vfp\")\n+(define_insn_reservation \"cortex_a9_fcmp\" 1\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+      (eq_attr \"type\" \"fcmps, fcmpd\"))\n+ \"ca9_issue_vfp_neon + ca9fp_add1\")\n \n-(define_insn_reservation \"cortex_a9_fmuld\" 6\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fmuld\"))\n- \"cortex_a9_vfp*2\")\n+;; Scheduling for the Multiply and MAC instructions.\n+(define_reservation \"ca9fmuls\"\n+  \"ca9fp_mul1 + ca9_issue_vfp_neon, ca9fp_mul2, ca9fp_mul3, ca9fp_mul4\")\n+\n+(define_reservation \"ca9fmuld\"\n+  \"ca9fp_mul1 + ca9_issue_vfp_neon, (ca9fp_mul1 + ca9fp_mul2), ca9fp_mul2, ca9fp_mul3, ca9fp_mul4\")\n+\n+(define_insn_reservation \"cortex_a9_fmuls\" 4\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fmuls\"))\n+  \"ca9fmuls\")\n+\n+(define_insn_reservation \"cortex_a9_fmuld\" 5\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fmuld\"))\n+  \"ca9fmuld\")\n \n (define_insn_reservation \"cortex_a9_fmacs\" 8\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fmacs\"))\n- \"cortex_a9_vfp\")\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fmacs\"))\n+  \"ca9fmuls, ca9fp_add\")\n \n-(define_insn_reservation \"cortex_a9_fmacd\" 8\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fmacd\"))\n- \"cortex_a9_vfp*2\")\n+(define_insn_reservation \"cortex_a9_fmacd\" 9\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fmacd\"))\n+  \"ca9fmuld, ca9fp_add\")\n \n+;; Division pipeline description.\n (define_insn_reservation \"cortex_a9_fdivs\" 15\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fdivs\"))\n- \"cortex_a9_vfp*10\")\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fdivs\"))\n+  \"ca9fp_ds1 + ca9_issue_vfp_neon, nothing*14\")\n \n (define_insn_reservation \"cortex_a9_fdivd\" 25\n- (and (eq_attr \"tune\" \"cortexa9\")\n-      (eq_attr \"type\" \"fdivd\"))\n- \"cortex_a9_vfp*20\")\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"fdivd\"))\n+  \"ca9fp_ds1 + ca9_issue_vfp_neon, nothing*24\")"}]}