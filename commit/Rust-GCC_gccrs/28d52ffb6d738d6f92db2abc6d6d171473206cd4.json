{"sha": "28d52ffb6d738d6f92db2abc6d6d171473206cd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhkNTJmZmI2ZDczOGQ2ZjkyZGIyYWJjNmQ2ZDE3MTQ3MzIwNmNkNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-13T22:22:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-13T22:22:48Z"}, "message": "i386.c (call_insn_operand): Reject const_int.\n\n        * i386.c (call_insn_operand): Reject const_int.\n        (expander_call_insn_operand): Use call_insn_operand.\n\nFrom-SVN: r29385", "tree": {"sha": "bd5e50ca077aa2a17cd0c36f8a538b6d4dc19c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd5e50ca077aa2a17cd0c36f8a538b6d4dc19c5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28d52ffb6d738d6f92db2abc6d6d171473206cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d52ffb6d738d6f92db2abc6d6d171473206cd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28d52ffb6d738d6f92db2abc6d6d171473206cd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d52ffb6d738d6f92db2abc6d6d171473206cd4/comments", "author": null, "committer": null, "parents": [{"sha": "06b8b73051f29a32542ddc23dcc92dc94a4a7339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b8b73051f29a32542ddc23dcc92dc94a4a7339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b8b73051f29a32542ddc23dcc92dc94a4a7339"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "38f571820627df6918bdec828dd5e4e94736e22c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28d52ffb6d738d6f92db2abc6d6d171473206cd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28d52ffb6d738d6f92db2abc6d6d171473206cd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28d52ffb6d738d6f92db2abc6d6d171473206cd4", "patch": "@@ -1,3 +1,8 @@\n+Mon Sep 13 15:21:46 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.c (call_insn_operand): Reject const_int.\n+\t(expander_call_insn_operand): Use call_insn_operand.\n+\n Mon Sep 13 17:44:28 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c (getrusage): Wrap prototype arguments in PROTO()."}, {"sha": "3042df60bedf7efe7adb666e345a9cfa5d425f74", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28d52ffb6d738d6f92db2abc6d6d171473206cd4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28d52ffb6d738d6f92db2abc6d6d171473206cd4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=28d52ffb6d738d6f92db2abc6d6d171473206cd4", "patch": "@@ -931,10 +931,9 @@ pic_symbolic_operand (op, mode)\n   return 0;\n }\n \n-/* Test for a valid operand for a call instruction.\n-   Don't allow the arg pointer register or virtual regs\n-   since they may change into reg + const, which the patterns\n-   can't handle yet.  */\n+/* Test for a valid operand for a call instruction.  Don't allow the\n+   arg pointer register or virtual regs since they may decay into\n+   reg + const, which the patterns can't handle.  */\n \n int\n call_insn_operand (op, mode)\n@@ -953,36 +952,27 @@ call_insn_operand (op, mode)\n \t      && REGNO (op) <= LAST_VIRTUAL_REGISTER)))\n     return 0;\n \n+  /* Disallow `call 1234'.  Due to varying assembler lameness this\n+     gets either rejected or translated to `call .+1234'.  */\n+  if (GET_CODE (op) == CONST_INT)\n+    return 0;\n+\n   /* Otherwise we can allow any general_operand in the address.  */\n   return general_operand (op, Pmode);\n }\n \n-/* Like call_insn_operand but allow (mem (symbol_ref ...))\n-   even if pic.  */\n+/* Like call_insn_operand but allow (mem (symbol_ref ...)) even if pic.  */\n \n int\n expander_call_insn_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n {\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-\n-  /* Direct symbol references.  */\n-  if (CONSTANT_ADDRESS_P (op))\n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == SYMBOL_REF)\n     return 1;\n \n-  /* Disallow indirect through a virtual register.  This leads to\n-     compiler aborts when trying to eliminate them.  */\n-  if (GET_CODE (op) == REG\n-      && (op == arg_pointer_rtx\n-\t  || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      && REGNO (op) <= LAST_VIRTUAL_REGISTER)))\n-    return 0;\n-\n-  /* Otherwise we can allow any general_operand in the address.  */\n-  return general_operand (op, mode);\n+  return call_insn_operand (op, mode);\n }\n \n int"}]}