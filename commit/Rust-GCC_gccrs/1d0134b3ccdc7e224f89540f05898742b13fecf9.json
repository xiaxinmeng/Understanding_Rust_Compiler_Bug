{"sha": "1d0134b3ccdc7e224f89540f05898742b13fecf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQwMTM0YjNjY2RjN2UyMjRmODk1NDBmMDU4OTg3NDJiMTNmZWNmOQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-21T14:50:57Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-21T14:50:57Z"}, "message": "re PR fortran/45271 ([OOP] Polymorphic code breaks when changing order of USE statements)\n\n2010-08-21  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45271\n\tPR fortran/45290\n\t* class.c (add_proc_comp): Add static initializer for PPCs.\n\t(add_procs_to_declared_vtab): Modified comment.\n\t* module.c (mio_component): Add argument 'vtype'. Don't read/write the\n\tinitializer if the component is part of a vtype.\n\t(mio_component_list): Add argument 'vtype', pass it on to\n\t'mio_component'.\n\t(mio_symbol): Modified call to 'mio_component_list'.\n\t* trans.h (gfc_conv_initializer): Modified prototype.\n\t(gfc_trans_assign_vtab_procs): Removed.\n\t* trans-common.c (create_common): Modified call to\n\t'gfc_conv_initializer'.\n\t* trans-decl.c (gfc_get_symbol_decl,get_proc_pointer_decl,\n\tgfc_emit_parameter_debug_info): Modified call to\n\t'gfc_conv_initializer'.\n\t(build_function_decl): Remove assertion.\n\t* trans-expr.c (gfc_conv_derived_to_class,gfc_trans_class_assign):\n\tRemoved call to 'gfc_trans_assign_vtab_procs'.\n\t(gfc_conv_initializer): Add argument 'procptr'.\n\t(gfc_conv_structure): Modified call to 'gfc_conv_initializer'.\n\t(gfc_trans_assign_vtab_procs): Removed.\n\t* trans-stmt.c (gfc_trans_allocate): Removed call to\n\t'gfc_trans_assign_vtab_procs'.\n\n\n2010-08-21  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/44863\n\tPR fortran/45271\n\tPR fortran/45290\n\t* gfortran.dg/dynamic_dispatch_10.f03: New (PR 44863 comment #1).\n\t* gfortran.dg/pointer_init_5.f90: New (PR 45290 comment #6).\n\t* gfortran.dg/typebound_call_18.f03: New (PR 45271 comment #3).\n\nFrom-SVN: r163445", "tree": {"sha": "73b55a92cbe026c1c26f39ee2a1feac959a278bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73b55a92cbe026c1c26f39ee2a1feac959a278bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d0134b3ccdc7e224f89540f05898742b13fecf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0134b3ccdc7e224f89540f05898742b13fecf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0134b3ccdc7e224f89540f05898742b13fecf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0134b3ccdc7e224f89540f05898742b13fecf9/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02be26e48b35198e854bdfe4e608d8060fe7dfd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02be26e48b35198e854bdfe4e608d8060fe7dfd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02be26e48b35198e854bdfe4e608d8060fe7dfd6"}], "stats": {"total": 474, "additions": 374, "deletions": 100}, "files": [{"sha": "e793b421cbf525b8b8760e56efec8246306f789c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -1,3 +1,30 @@\n+2010-08-21  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45271\n+\tPR fortran/45290\n+\t* class.c (add_proc_comp): Add static initializer for PPCs.\n+\t(add_procs_to_declared_vtab): Modified comment.\n+\t* module.c (mio_component): Add argument 'vtype'. Don't read/write the\n+\tinitializer if the component is part of a vtype.\n+\t(mio_component_list): Add argument 'vtype', pass it on to\n+\t'mio_component'.\n+\t(mio_symbol): Modified call to 'mio_component_list'.\n+\t* trans.h (gfc_conv_initializer): Modified prototype.\n+\t(gfc_trans_assign_vtab_procs): Removed.\n+\t* trans-common.c (create_common): Modified call to\n+\t'gfc_conv_initializer'.\n+\t* trans-decl.c (gfc_get_symbol_decl,get_proc_pointer_decl,\n+\tgfc_emit_parameter_debug_info): Modified call to\n+\t'gfc_conv_initializer'.\n+\t(build_function_decl): Remove assertion.\n+\t* trans-expr.c (gfc_conv_derived_to_class,gfc_trans_class_assign):\n+\tRemoved call to 'gfc_trans_assign_vtab_procs'.\n+\t(gfc_conv_initializer): Add argument 'procptr'.\n+\t(gfc_conv_structure): Modified call to 'gfc_conv_initializer'.\n+\t(gfc_trans_assign_vtab_procs): Removed.\n+\t* trans-stmt.c (gfc_trans_allocate): Removed call to\n+\t'gfc_trans_assign_vtab_procs'.\n+\n 2010-08-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36158"}, {"sha": "df3a314c980cfa0b0e655cdfe9485a11cd116522", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -214,8 +214,6 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n       /* Add procedure component.  */\n       if (gfc_add_component (vtype, name, &c) == FAILURE)\n \treturn;\n-      if (tb->u.specific)\n-\tc->ts.interface = tb->u.specific->n.sym;\n \n       if (!c->tb)\n \tc->tb = XCNEW (gfc_typebound_proc);\n@@ -228,17 +226,18 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n       c->attr.external = 1;\n       c->attr.untyped = 1;\n       c->attr.if_source = IFSRC_IFBODY;\n-\n-      /* A static initializer cannot be used here because the specific\n-\tfunction is not a constant; internal compiler error: in\n-\toutput_constant, at varasm.c:4623  */\n-      c->initializer = NULL;\n     }\n   else if (c->attr.proc_pointer && c->tb)\n     {\n       *c->tb = *tb;\n       c->tb->ppc = 1;\n-      c->ts.interface = tb->u.specific->n.sym;\t  \n+    }\n+\n+  if (tb->u.specific)\n+    {\n+      c->ts.interface = tb->u.specific->n.sym;\n+      if (!tb->deferred)\n+\tc->initializer = gfc_get_variable_expr (tb->u.specific);\n     }\n }\n \n@@ -296,7 +295,7 @@ add_procs_to_declared_vtab (gfc_symbol *derived, gfc_symbol *vtype)\n     {\n       /* Make sure that the PPCs appear in the same order as in the parent.  */\n       copy_vtab_proc_comps (super_type, vtype);\n-      /* Only needed to get the PPC interfaces right.  */\n+      /* Only needed to get the PPC initializers right.  */\n       add_procs_to_declared_vtab (super_type, vtype);\n     }\n "}, {"sha": "e9a8625212dc9db2f1866d6616bcb8f685db36f5", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -2343,7 +2343,7 @@ static void mio_formal_arglist (gfc_formal_arglist **formal);\n static void mio_typebound_proc (gfc_typebound_proc** proc);\n \n static void\n-mio_component (gfc_component *c)\n+mio_component (gfc_component *c, int vtype)\n {\n   pointer_info *p;\n   int n;\n@@ -2373,7 +2373,8 @@ mio_component (gfc_component *c)\n   mio_symbol_attribute (&c->attr);\n   c->attr.access = MIO_NAME (gfc_access) (c->attr.access, access_types); \n \n-  mio_expr (&c->initializer);\n+  if (!vtype)\n+    mio_expr (&c->initializer);\n \n   if (c->attr.proc_pointer)\n     {\n@@ -2408,7 +2409,7 @@ mio_component (gfc_component *c)\n \n \n static void\n-mio_component_list (gfc_component **cp)\n+mio_component_list (gfc_component **cp, int vtype)\n {\n   gfc_component *c, *tail;\n \n@@ -2417,7 +2418,7 @@ mio_component_list (gfc_component **cp)\n   if (iomode == IO_OUTPUT)\n     {\n       for (c = *cp; c; c = c->next)\n-\tmio_component (c);\n+\tmio_component (c, vtype);\n     }\n   else\n     {\n@@ -2430,7 +2431,7 @@ mio_component_list (gfc_component **cp)\n \t    break;\n \n \t  c = gfc_get_component ();\n-\t  mio_component (c);\n+\t  mio_component (c, vtype);\n \n \t  if (tail == NULL)\n \t    *cp = c;\n@@ -3597,7 +3598,7 @@ mio_symbol (gfc_symbol *sym)\n   /* Note that components are always saved, even if they are supposed\n      to be private.  Component access is checked during searching.  */\n \n-  mio_component_list (&sym->components);\n+  mio_component_list (&sym->components, sym->attr.vtype);\n \n   if (sym->components != NULL)\n     sym->component_access"}, {"sha": "ed659ac67e9529fb3cc6fc01ea013fe76a3531be", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -649,8 +649,10 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \t      {\n \t\t/* Add the initializer for this field.  */\n \t\ttmp = gfc_conv_initializer (s->sym->value, &s->sym->ts,\n-\t\t    TREE_TYPE (s->field), s->sym->attr.dimension,\n-\t\t    s->sym->attr.pointer || s->sym->attr.allocatable);\n+\t\t\t\t\t    TREE_TYPE (s->field),\n+\t\t\t\t\t    s->sym->attr.dimension,\n+\t\t\t\t\t    s->sym->attr.pointer\n+\t\t\t\t\t    || s->sym->attr.allocatable, false);\n \n \t\tCONSTRUCTOR_APPEND_ELT (v, s->field, tmp);\n \t      }"}, {"sha": "3904b0d7ddb2367a766569b77bc14b9dc3ba941e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -1034,6 +1034,9 @@ add_attributes_to_decl (symbol_attribute sym_attr, tree list)\n }\n \n \n+static void build_function_decl (gfc_symbol * sym, bool global);\n+\n+\n /* Return the decl for a gfc_symbol, create it if it doesn't already\n    exist.  */\n \n@@ -1160,12 +1163,21 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t}\n     }\n \n-  /* Catch function declarations.  Only used for actual parameters and\n-     procedure pointers.  */\n   if (sym->attr.flavor == FL_PROCEDURE)\n     {\n-      decl = gfc_get_extern_function_decl (sym);\n-      gfc_set_decl_location (decl, &sym->declared_at);\n+      /* Catch function declarations. Only used for actual parameters,\n+\t procedure pointers and procptr initialization targets.  */\n+      if (sym->attr.external || sym->attr.use_assoc || sym->attr.intrinsic)\n+\t{\n+\t  decl = gfc_get_extern_function_decl (sym);\n+\t  gfc_set_decl_location (decl, &sym->declared_at);\n+\t}\n+      else\n+\t{\n+\t  if (!sym->backend_decl)\n+\t    build_function_decl (sym, false);\n+\t  decl = sym->backend_decl;\n+\t}\n       return decl;\n     }\n \n@@ -1281,8 +1293,11 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t every time the procedure is entered. The TREE_STATIC is\n \t in this case due to -fmax-stack-var-size=.  */\n       DECL_INITIAL (decl) = gfc_conv_initializer (sym->value, &sym->ts,\n-\t  TREE_TYPE (decl), sym->attr.dimension,\n-\t  sym->attr.pointer || sym->attr.allocatable);\n+\t\t\t\t\t\t  TREE_TYPE (decl),\n+\t\t\t\t\t\t  sym->attr.dimension,\n+\t\t\t\t\t\t  sym->attr.pointer\n+\t\t\t\t\t\t  || sym->attr.allocatable,\n+\t\t\t\t\t\t  sym->attr.proc_pointer);\n     }\n \n   if (!TREE_STATIC (decl)\n@@ -1369,9 +1384,9 @@ get_proc_pointer_decl (gfc_symbol *sym)\n     {\n       /* Add static initializer.  */\n       DECL_INITIAL (decl) = gfc_conv_initializer (sym->value, &sym->ts,\n-\t  TREE_TYPE (decl),\n-\t  sym->attr.proc_pointer ? false : sym->attr.dimension,\n-\t  sym->attr.proc_pointer);\n+\t\t\t\t\t\t  TREE_TYPE (decl),\n+\t\t\t\t\t\t  sym->attr.dimension,\n+\t\t\t\t\t\t  false, true);\n     }\n \n   attributes = add_attributes_to_decl (sym->attr, NULL_TREE);\n@@ -1608,9 +1623,11 @@ build_function_decl (gfc_symbol * sym, bool global)\n   tree result_decl;\n   gfc_formal_arglist *f;\n \n-  gcc_assert (!sym->backend_decl);\n   gcc_assert (!sym->attr.external);\n \n+  if (sym->backend_decl)\n+    return;\n+\n   /* Set the line and filename.  sym->declared_at seems to point to the\n      last statement for subroutines, but it'll do for now.  */\n   gfc_set_backend_locus (&sym->declared_at);\n@@ -3806,9 +3823,10 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n   TREE_USED (decl) = 1;\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n     TREE_PUBLIC (decl) = 1;\n-  DECL_INITIAL (decl)\n-    = gfc_conv_initializer (sym->value, &sym->ts, TREE_TYPE (decl),\n-\t\t\t    sym->attr.dimension, 0);\n+  DECL_INITIAL (decl) = gfc_conv_initializer (sym->value, &sym->ts,\n+\t\t\t\t\t      TREE_TYPE (decl),\n+\t\t\t\t\t      sym->attr.dimension,\n+\t\t\t\t\t      false, false);\n   debug_hooks->global_decl (decl);\n }\n "}, {"sha": "103bc2461f0e8850c89d28cc50b3347f06827fb3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 65, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -2574,7 +2574,6 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n      not to the class declared type.  */\n   vtab = gfc_find_derived_vtab (e->ts.u.derived);\n   gcc_assert (vtab);\n-  gfc_trans_assign_vtab_procs (&parmse->pre, e->ts.u.derived, vtab);\n   tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n   gfc_add_modify (&parmse->pre, ctree,\n \t\t  fold_convert (TREE_TYPE (ctree), tmp));\n@@ -3946,11 +3945,11 @@ gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n \n tree\n gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n-\t\t      bool array, bool pointer)\n+\t\t      bool array, bool pointer, bool procptr)\n {\n   gfc_se se;\n \n-  if (!(expr || pointer))\n+  if (!(expr || pointer || procptr))\n     return NULL_TREE;\n \n   /* Check if we have ISOCBINDING_NULL_PTR or ISOCBINDING_NULL_FUNPTR\n@@ -3972,7 +3971,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n       return se.expr;\n     }\n   \n-  if (array)\n+  if (array && !procptr)\n     {\n       /* Arrays need special handling.  */\n       if (pointer)\n@@ -3983,7 +3982,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n       else\n \treturn gfc_conv_array_initializer (type, expr);\n     }\n-  else if (pointer)\n+  else if (pointer || procptr)\n     {\n       if (!expr || expr->expr_type == EXPR_NULL)\n \treturn fold_convert (type, null_pointer_node);\n@@ -4462,8 +4461,9 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       else\n \t{\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,\n-\t      TREE_TYPE (cm->backend_decl), cm->attr.dimension,\n-\t      cm->attr.pointer || cm->attr.proc_pointer);\n+\t\t\t\t      TREE_TYPE (cm->backend_decl),\n+\t\t\t\t      cm->attr.dimension, cm->attr.pointer,\n+\t\t\t\t      cm->attr.proc_pointer);\n \n \t  /* Append it to the constructor list.  */\n \t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n@@ -5779,63 +5779,6 @@ gfc_trans_assign (gfc_code * code)\n }\n \n \n-/* Generate code to assign typebound procedures to a derived vtab.  */\n-void gfc_trans_assign_vtab_procs (stmtblock_t *block, gfc_symbol *dt,\n-\t\t\t\t  gfc_symbol *vtab)\n-{\n-  gfc_component *cmp;\n-  tree vtb, ctree, proc, cond = NULL_TREE;\n-  stmtblock_t body;\n-\n-  /* Point to the first procedure pointer.  */\n-  cmp = gfc_find_component (vtab->ts.u.derived, \"$extends\", true, true);\n-  cmp = cmp->next;\n-  if (!cmp)\n-    return;\n-  \n-  vtb = gfc_get_symbol_decl (vtab);\n-\n-  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl), vtb,\n-\t\t       cmp->backend_decl, NULL_TREE);\n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, ctree,\n-\t\t      build_int_cst (TREE_TYPE (ctree), 0));\n-\n-  gfc_init_block (&body);\n-  for (; cmp; cmp = cmp->next)\n-    {\n-      gfc_symbol *target = NULL;\n-\n-      /* This is required when typebound generic procedures are called\n-\t with derived type targets.  The specific procedures do not get\n-\t added to the vtype, which remains \"empty\".  */\n-      if (cmp->tb && cmp->tb->u.specific && cmp->tb->u.specific->n.sym)\n-\ttarget = cmp->tb->u.specific->n.sym;\n-      else\n-\t{\n-\t  gfc_symtree *st;\n-\t  st = gfc_find_typebound_proc (dt, NULL, cmp->name, false, NULL);\n-\t  if (st->n.tb && st->n.tb->u.specific)\n-\t    target = st->n.tb->u.specific->n.sym;\n-\t}\n-\n-      if (!target)\n-\tcontinue;\n-\n-      ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n-\t\t\t   vtb, cmp->backend_decl, NULL_TREE);\n-      proc = gfc_get_symbol_decl (target);\n-      proc = gfc_build_addr_expr (TREE_TYPE (ctree), proc);\n-      gfc_add_modify (&body, ctree, proc);\n-    }\n-\n-  proc = gfc_finish_block (&body);\n-\n-  proc = build3_v (COND_EXPR, cond, proc, build_empty_stmt (input_location));\n-\n-  gfc_add_expr_to_block (block, proc);\n-}\n-\n-\n /* Special case for initializing a CLASS variable on allocation.\n    A MEMCPY is needed to copy the full data of the dynamic type,\n    which may be different from the declared type.  */\n@@ -5887,7 +5830,6 @@ gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n \t  gfc_symtree *st;\n \t  vtab = gfc_find_derived_vtab (expr2->ts.u.derived);\n \t  gcc_assert (vtab);\n-\t  gfc_trans_assign_vtab_procs (&block, expr2->ts.u.derived, vtab);\n \t  rhs = gfc_get_expr ();\n \t  rhs->expr_type = EXPR_VARIABLE;\n \t  gfc_find_sym_tree (vtab->name, NULL, 1, &st);"}, {"sha": "44195870bcce1bc6b8f6bcb99490f3e2292c2056", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -4441,7 +4441,6 @@ gfc_trans_allocate (gfc_code * code)\n \t\t{\n \t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n \t\t  gcc_assert (vtab);\n-\t\t  gfc_trans_assign_vtab_procs (&block, ts->u.derived, vtab);\n \t\t  gfc_init_se (&lse, NULL);\n \t\t  lse.want_pointer = 1;\n \t\t  gfc_conv_expr (&lse, lhs);"}, {"sha": "04934e50e6d18ff1a827239ab3cb7566701546dd", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -433,7 +433,7 @@ void gfc_set_decl_location (tree, locus *);\n tree gfc_get_symbol_decl (gfc_symbol *);\n \n /* Build a static initializer.  */\n-tree gfc_conv_initializer (gfc_expr *, gfc_typespec *, tree, bool, bool);\n+tree gfc_conv_initializer (gfc_expr *, gfc_typespec *, tree, bool, bool, bool);\n \n /* Assign a default initializer to a derived type.  */\n void gfc_init_default_dt (gfc_symbol *, stmtblock_t *, bool);\n@@ -527,9 +527,6 @@ tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool);\n /* Generate code for a pointer assignment.  */\n tree gfc_trans_pointer_assignment (gfc_expr *, gfc_expr *);\n \n-/* Generate code to assign typebound procedures to a derived vtab.  */\n-void gfc_trans_assign_vtab_procs (stmtblock_t*, gfc_symbol*, gfc_symbol*);\n-\n /* Initialize function decls for library functions.  */\n void gfc_build_intrinsic_lib_fndecls (void);\n /* Create function decls for IO library functions.  */"}, {"sha": "cd60ce4e8c55a623807605d91220cde9e9e17ca6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -1,3 +1,12 @@\n+2010-08-21  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/44863\n+\tPR fortran/45271\n+\tPR fortran/45290\n+\t* gfortran.dg/dynamic_dispatch_10.f03: New (PR 44863 comment #1).\n+\t* gfortran.dg/pointer_init_5.f90: New (PR 45290 comment #6).\n+\t* gfortran.dg/typebound_call_18.f03: New (PR 45271 comment #3).\n+\n 2010-08-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36158"}, {"sha": "2b8e0fbc503e1a7cf15574357c4225c28a5eddab", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_10.f03", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_10.f03?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -0,0 +1,171 @@\n+! { dg-do run }\n+!\n+! [OOP] Fortran runtime error: internal error: bad hash value in dynamic dispatch\n+!\n+! Contributed by David Car <david.car7@gmail.com>\n+\n+module BaseStrategy\n+\n+  type, public, abstract :: Strategy\n+   contains\n+     procedure(strategy_update), pass( this ), deferred :: update\n+     procedure(strategy_pre_update), pass( this ), deferred :: preUpdate\n+     procedure(strategy_post_update), pass( this ), deferred :: postUpdate\n+  end type Strategy\n+\n+  abstract interface\n+     subroutine strategy_update( this )\n+       import Strategy\n+       class (Strategy), target, intent(in) :: this\n+     end subroutine strategy_update\n+  end interface\n+\n+  abstract interface\n+     subroutine strategy_pre_update( this )\n+       import Strategy\n+       class (Strategy), target, intent(in) :: this\n+     end subroutine strategy_pre_update\n+  end interface\n+\n+  abstract interface\n+     subroutine strategy_post_update( this )\n+       import Strategy\n+       class (Strategy), target, intent(in) :: this\n+     end subroutine strategy_post_update\n+  end interface\n+     \n+end module BaseStrategy\n+\n+!==============================================================================\n+\n+module LaxWendroffStrategy\n+\n+  use BaseStrategy\n+\n+  private :: update, preUpdate, postUpdate\n+\n+  type, public, extends( Strategy ) :: LaxWendroff\n+     class (Strategy), pointer :: child => null()\n+     contains\n+       procedure, pass( this ) :: update\n+       procedure, pass( this ) :: preUpdate\n+       procedure, pass( this ) :: postUpdate\n+  end type LaxWendroff\n+\n+contains\n+\n+  subroutine update( this )\n+    class (LaxWendroff), target, intent(in) :: this\n+\n+    print *, 'Calling LaxWendroff update'\n+  end subroutine update\n+\n+  subroutine preUpdate( this )\n+    class (LaxWendroff), target, intent(in) :: this\n+    \n+    print *, 'Calling LaxWendroff preUpdate'\n+  end subroutine preUpdate\n+\n+  subroutine postUpdate( this )\n+    class (LaxWendroff), target, intent(in) :: this\n+    \n+    print *, 'Calling LaxWendroff postUpdate'\n+  end subroutine postUpdate\n+  \n+end module LaxWendroffStrategy\n+\n+!==============================================================================\n+\n+module KEStrategy\n+\n+  use BaseStrategy\n+  ! Uncomment the line below and it runs fine\n+  ! use LaxWendroffStrategy\n+\n+  private :: update, preUpdate, postUpdate\n+\n+  type, public, extends( Strategy ) :: KE\n+     class (Strategy), pointer :: child => null()\n+     contains\n+       procedure, pass( this ) :: update\n+       procedure, pass( this ) :: preUpdate\n+       procedure, pass( this ) :: postUpdate\n+  end type KE\n+  \n+contains\n+\n+  subroutine init( this, other )\n+    class (KE), intent(inout) :: this\n+    class (Strategy), target, intent(in) :: other\n+\n+    this % child => other\n+  end subroutine init\n+\n+  subroutine update( this )\n+    class (KE), target, intent(in) :: this\n+\n+    if ( associated( this % child ) ) then\n+       call this % child % update()\n+    end if\n+\n+    print *, 'Calling KE update'\n+  end subroutine update\n+\n+ subroutine preUpdate( this )\n+    class (KE), target, intent(in) :: this\n+    \n+    if ( associated( this % child ) ) then\n+       call this % child % preUpdate()\n+    end if\n+\n+    print *, 'Calling KE preUpdate'\n+  end subroutine preUpdate\n+\n+  subroutine postUpdate( this )\n+    class (KE), target, intent(in) :: this\n+\n+    if ( associated( this % child ) ) then\n+       call this % child % postUpdate()\n+    end if\n+    \n+    print *, 'Calling KE postUpdate'\n+  end subroutine postUpdate\n+  \n+end module KEStrategy\n+\n+!==============================================================================\n+\n+program main\n+\n+  use LaxWendroffStrategy\n+  use KEStrategy\n+\n+  type :: StratSeq\n+     class (Strategy), pointer :: strat => null()\n+  end type StratSeq\n+\n+  type (LaxWendroff), target :: lw_strat\n+  type (KE), target :: ke_strat\n+\n+  type (StratSeq), allocatable, dimension( : ) :: seq\n+  \n+  allocate( seq(10) )\n+\n+  call init( ke_strat, lw_strat )\n+  call ke_strat % preUpdate()\n+  call ke_strat % update()\n+  call ke_strat % postUpdate()\n+  ! call lw_strat % update()\n+\n+  seq( 1 ) % strat => ke_strat\n+  seq( 2 ) % strat => lw_strat\n+\n+  call seq( 1 ) % strat % update()\n+\n+  do i = 1, 2\n+     call seq( i ) % strat % update()\n+  end do\n+\n+end\n+\n+! { dg-final { cleanup-modules \"BaseStrategy LaxWendroffStrategy KEStrategy\" } }"}, {"sha": "beedad27d1ee4c26bdf4baf5457f6bd82c8cc346", "filename": "gcc/testsuite/gfortran.dg/pointer_init_5.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_5.f90?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! PR 45290: [F08] pointer initialization\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+\n+implicit none\n+\n+procedure(f1), pointer :: pp => f1\n+\n+type :: t\n+  procedure(f2), pointer, nopass :: ppc => f2\n+end type\n+\n+contains\n+\n+  integer function f1()\n+    f1 = 42\n+  end function\n+\n+  integer function f2()\n+    f2 = 43\n+  end function\n+\n+end module\n+\n+\n+program test_ptr_init\n+\n+use m\n+implicit none\n+\n+type (t) :: u\n+\n+if (pp()/=42) call abort()\n+if (u%ppc()/=43) call abort()\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "bb94717ad3fffd312f9de66e00393489c84151ea", "filename": "gcc/testsuite/gfortran.dg/typebound_call_18.f03", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_18.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0134b3ccdc7e224f89540f05898742b13fecf9/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_18.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_18.f03?ref=1d0134b3ccdc7e224f89540f05898742b13fecf9", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do run }\n+!\n+! PR 45271: [OOP] Polymorphic code breaks when changing order of USE statements\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+\n+module abstract_vector\n+  implicit none\n+  type, abstract :: vector_class\n+  contains\n+    procedure(op_assign_v_v), deferred :: assign\n+  end type vector_class\n+  abstract interface\n+    subroutine op_assign_v_v(this,v)\n+      import vector_class\n+      class(vector_class), intent(inout) :: this\n+      class(vector_class), intent(in)    :: v\n+    end subroutine\n+  end interface\n+end module abstract_vector\n+\n+module concrete_vector\n+  use abstract_vector\n+  implicit none\n+  type, extends(vector_class) :: trivial_vector_type\n+  contains\n+    procedure :: assign => my_assign\n+  end type\n+contains\n+  subroutine my_assign (this,v)\n+    class(trivial_vector_type), intent(inout) :: this\n+    class(vector_class),        intent(in)    :: v\n+    write (*,*) 'Oops in concrete_vector::my_assign'\n+    call abort ()\n+  end subroutine\n+end module concrete_vector\n+\n+module concrete_gradient\n+  use abstract_vector\n+  implicit none\n+  type, extends(vector_class) :: trivial_gradient_type\n+  contains\n+    procedure :: assign => my_assign\n+  end type\n+contains\n+  subroutine my_assign (this,v)\n+    class(trivial_gradient_type), intent(inout) :: this\n+    class(vector_class),          intent(in)    :: v\n+    write (*,*) 'concrete_gradient::my_assign'\n+  end subroutine\n+end module concrete_gradient\n+\n+program main\n+  !--- exchange these two lines to make the code work:\n+  use concrete_vector    ! (1)\n+  use concrete_gradient  ! (2)\n+  !---\n+  implicit none\n+  type(trivial_gradient_type)      :: g_initial\n+  class(vector_class),  allocatable :: g\n+  print *, \"cg: before g%assign\"\n+  allocate(trivial_gradient_type :: g)\n+  call g%assign (g_initial)\n+  print *, \"cg: after  g%assign\"\n+end program main\n+\n+! { dg-final { cleanup-modules \"abstract_vector concrete_vector concrete_gradient\" } }"}]}