{"sha": "1f5a932436112de4e93366915c8dbc77a8f821ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY1YTkzMjQzNjExMmRlNGU5MzM2NjkxNWM4ZGJjNzdhOGY4MjFmZg==", "commit": {"author": {"name": "Laurent Pautet", "email": "pautet@adacore.com", "date": "2005-09-05T07:54:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:54:36Z"}, "message": "g-pehage.ads, [...] (Select_Char_Position): When no character position set is provided...\n\n2005-09-01  Laurent Pautet  <pautet@adacore.com>\n\n\t* g-pehage.ads, g-pehage.adb (Select_Char_Position): When no character\n\tposition set is provided, we compute one in order to reduce the maximum\n\tlength of the keys.  This computation first selects a character\n\tposition between 1 and the minimum length of the keys in order to\n\tavoid reducing one of the keys to an empty string.\n\t(Initialize, Compute): When the ratio V to K is too low, the algorithm\n\tdoes not converge. The initialization procedure now comes with a\n\tmaximum number of iterations such that when exceeded, an exception is\n\traised in Compute. The user can initialize this ratio to another value\n\tand try again\n\tReformating and updated headers.\n\nFrom-SVN: r103867", "tree": {"sha": "f3eddae0a34f03ac34645de2578dee1479b775a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3eddae0a34f03ac34645de2578dee1479b775a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f5a932436112de4e93366915c8dbc77a8f821ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f5a932436112de4e93366915c8dbc77a8f821ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f5a932436112de4e93366915c8dbc77a8f821ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f5a932436112de4e93366915c8dbc77a8f821ff/comments", "author": null, "committer": null, "parents": [{"sha": "dd52e06aa0e9341c1123de64c7ff2b46b60b7ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd52e06aa0e9341c1123de64c7ff2b46b60b7ba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd52e06aa0e9341c1123de64c7ff2b46b60b7ba3"}], "stats": {"total": 1574, "additions": 819, "deletions": 755}, "files": [{"sha": "a78264846150fc7d392eb878fec00f6251eaeac4", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 719, "deletions": 665, "changes": 1384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f5a932436112de4e93366915c8dbc77a8f821ff/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f5a932436112de4e93366915c8dbc77a8f821ff/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=1f5a932436112de4e93366915c8dbc77a8f821ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2002-2004 Ada Core Technologies, Inc.           --\n+--            Copyright (C) 2002-2005 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,61 +40,58 @@ with GNAT.Table;\n \n package body GNAT.Perfect_Hash_Generators is\n \n-   --  We are using the algorithm of J. Czech as described in Zbigniew\n-   --  J. Czech, George Havas, and Bohdan S. Majewski ``An Optimal\n-   --  Algorithm for Generating Minimal Perfect Hash Functions'',\n-   --  Information Processing Letters, 43(1992) pp.257-264, Oct.1992\n+   --  We are using the algorithm of J. Czech as described in Zbigniew J.\n+   --  Czech, George Havas, and Bohdan S. Majewski ``An Optimal Algorithm for\n+   --  Generating Minimal Perfect Hash Functions'', Information Processing\n+   --  Letters, 43(1992) pp.257-264, Oct.1992\n \n-   --  This minimal perfect hash function generator is based on random\n-   --  graphs and produces a hash function of the form:\n+   --  This minimal perfect hash function generator is based on random graphs\n+   --  and produces a hash function of the form:\n \n    --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n \n-   --  where f1 and f2 are functions that map strings into integers,\n-   --  and g is a function that maps integers into [0, m-1]. h can be\n-   --  order preserving. For instance, let W = {w_0, ..., w_i, ...,\n+   --  where f1 and f2 are functions that map strings into integers, and g is a\n+   --  function that maps integers into [0, m-1]. h can be order preserving.\n+   --  For instance, let W = {w_0, ..., w_i, ...,\n    --  w_m-1}, h can be defined such that h (w_i) = i.\n \n-   --  This algorithm defines two possible constructions of f1 and\n-   --  f2. Method b) stores the hash function in less memory space at\n-   --  the expense of greater CPU time.\n+   --  This algorithm defines two possible constructions of f1 and f2. Method\n+   --  b) stores the hash function in less memory space at the expense of\n+   --  greater CPU time.\n \n    --  a) fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n \n    --     size (Tk) = max (for w in W) (length (w)) * size (used char set)\n \n    --  b) fk (w) = sum (for i in 1 .. length (w)) (Tk (i) * w (i)) mod n\n \n-   --     size (Tk) = max (for w in W) (length (w)) but the table\n-   --     lookups are replaced by multiplications.\n-\n-   --  where Tk values are randomly generated. n is defined later on\n-   --  but the algorithm recommends to use a value a little bit\n-   --  greater than 2m. Note that for large values of m, the main\n-   --  memory space requirements comes from the memory space for\n-   --  storing function g (>= 2m entries).\n-\n-   --  Random graphs are frequently used to solve difficult problems\n-   --  that do not have polynomial solutions. This algorithm is based\n-   --  on a weighted undirected graph. It comprises two steps: mapping\n-   --  and assigment.\n-\n-   --  In the mapping step, a graph G = (V, E) is constructed, where V\n-   --  = {0, 1, ..., n-1} and E = {(for w in W) (f1 (w), f2 (w))}. In\n-   --  order for the assignment step to be successful, G has to be\n-   --  acyclic. To have a high probability of generating an acyclic\n-   --  graph, n >= 2m. If it is not acyclic, Tk have to be regenerated.\n-\n-   --  In the assignment step, the algorithm builds function g. As G\n-   --  is acyclic, there is a vertex v1 with only one neighbor v2. Let\n-   --  w_i be the word such that v1 = f1 (w_i) and v2 = f2 (w_i). Let\n-   --  g (v1) = 0 by construction and g (v2) = (i - g (v1)) mod n (or\n-   --  to be general, (h (i) - g (v1) mod n). If word w_j is such that\n-   --  v2 = f1 (w_j) and v3 = f2 (w_j), g (v3) = (j - g (v2)) mod n\n-   --  (or to be general, (h (j) - g (v2)) mod n). If w_i has no\n-   --  neighbor, then another vertex is selected. The algorithm\n-   --  traverses G to assign values to all the vertices. It cannot\n-   --  assign a value to an already assigned vertex as G is acyclic.\n+   --     size (Tk) = max (for w in W) (length (w)) but the table lookups are\n+   --     replaced by multiplications.\n+\n+   --  where Tk values are randomly generated. n is defined later on but the\n+   --  algorithm recommends to use a value a little bit greater than 2m. Note\n+   --  that for large values of m, the main memory space requirements comes\n+   --  from the memory space for storing function g (>= 2m entries).\n+\n+   --  Random graphs are frequently used to solve difficult problems that do\n+   --  not have polynomial solutions. This algorithm is based on a weighted\n+   --  undirected graph. It comprises two steps: mapping and assigment.\n+\n+   --  In the mapping step, a graph G = (V, E) is constructed, where = {0, 1,\n+   --  ..., n-1} and E = {(for w in W) (f1 (w), f2 (w))}. In order for the\n+   --  assignment step to be successful, G has to be acyclic. To have a high\n+   --  probability of generating an acyclic graph, n >= 2m. If it is not\n+   --  acyclic, Tk have to be regenerated.\n+\n+   --  In the assignment step, the algorithm builds function g. As is acyclic,\n+   --  there is a vertex v1 with only one neighbor v2. Let w_i be the word such\n+   --  that v1 = f1 (w_i) and v2 = f2 (w_i). Let g (v1) = 0 by construction and\n+   --  g (v2) = (i - g (v1)) mod n (or to be general, (h (i) - g (v1) mod n).\n+   --  If word w_j is such that v2 = f1 (w_j) and v3 = f2 (w_j), g (v3) = (j -\n+   --  g (v2)) mod (or to be general, (h (j) - g (v2)) mod n). If w_i has no\n+   --  neighbor, then another vertex is selected. The algorithm traverses G to\n+   --  assign values to all the vertices. It cannot assign a value to an\n+   --  already assigned vertex as G is acyclic.\n \n    subtype Word_Id   is Integer;\n    subtype Key_Id    is Integer;\n@@ -109,42 +106,44 @@ package body GNAT.Perfect_Hash_Generators is\n    Max_Word_Length : constant := 32;\n    subtype Word_Type is String (1 .. Max_Word_Length);\n    Null_Word : constant Word_Type := (others => ASCII.NUL);\n-   --  Store keyword in a word. Note that the length of word is\n-   --  limited to 32 characters.\n+   --  Store keyword in a word. Note that the length of word is limited to 32\n+   --  characters.\n \n    type Key_Type is record\n       Edge : Edge_Id;\n    end record;\n-   --  A key corresponds to an edge in the algorithm graph.\n+   --  A key corresponds to an edge in the algorithm graph\n \n    type Vertex_Type is record\n       First : Edge_Id;\n       Last  : Edge_Id;\n    end record;\n-   --  A vertex can be involved in several edges. First and Last are\n-   --  the bounds of an array of edges stored in a global edge table.\n+   --  A vertex can be involved in several edges. First and Last are the bounds\n+   --  of an array of edges stored in a global edge table.\n \n    type Edge_Type is record\n       X   : Vertex_Id;\n       Y   : Vertex_Id;\n       Key : Key_Id;\n    end record;\n-   --  An edge is a peer of vertices. In the algorithm, a key\n-   --  is associated to an edge.\n+   --  An edge is a peer of vertices. In the algorithm, a key is associated to\n+   --  an edge.\n \n    package WT is new GNAT.Table (Word_Type, Word_Id, 0, 32, 32);\n    package IT is new GNAT.Table (Integer, Integer, 0, 32, 32);\n-   --  The two main tables. IT is used to store several tables of\n-   --  components containing only integers.\n+   --  The two main tables. IT is used to store several tables of components\n+   --  containing only integers.\n \n    function Image (Int : Integer; W : Natural := 0) return String;\n    function Image (Str : String;  W : Natural := 0) return String;\n-   --  Return a string which includes string Str or integer Int\n-   --  preceded by leading spaces if required by width W.\n+   --  Return a string which includes string Str or integer Int preceded by\n+   --  leading spaces if required by width W.\n \n    Output : File_Descriptor renames GNAT.OS_Lib.Standout;\n    --  Shortcuts\n \n+   EOL : constant Character := ASCII.LF;\n+\n    Max  : constant := 78;\n    Last : Natural  := 0;\n    Line : String (1 .. Max);\n@@ -163,24 +162,23 @@ package body GNAT.Perfect_Hash_Generators is\n       F2 : Natural;\n       L2 : Natural;\n       C2 : Natural);\n-   --  Write string S into file F as a element of an array of one or\n-   --  two dimensions. Fk (resp. Lk and Ck) indicates the first (resp\n-   --  last and current) index in the k-th dimension. If F1 = L1 the\n-   --  array is considered as a one dimension array. This dimension is\n-   --  described by F2 and L2. This routine takes care of all the\n-   --  parenthesis, spaces and commas needed to format correctly the\n-   --  array. Moreover, the array is well indented and is wrapped to\n-   --  fit in a 80 col line. When the line is full, the routine writes\n-   --  it into file F. When the array is completed, the routine adds a\n+   --  Write string S into file F as a element of an array of one or two\n+   --  dimensions. Fk (resp. Lk and Ck) indicates the first (resp last and\n+   --  current) index in the k-th dimension. If F1 = L1 the array is considered\n+   --  as a one dimension array. This dimension is described by F2 and L2. This\n+   --  routine takes care of all the parenthesis, spaces and commas needed to\n+   --  format correctly the array. Moreover, the array is well indented and is\n+   --  wrapped to fit in a 80 col line. When the line is full, the routine\n+   --  writes it into file F. When the array is completed, the routine adds\n    --  semi-colon and writes the line into file F.\n \n    procedure New_Line\n-     (F : File_Descriptor);\n+     (File : File_Descriptor);\n    --  Simulate Ada.Text_IO.New_Line with GNAT.OS_Lib\n \n    procedure Put\n-     (F : File_Descriptor;\n-      S : String);\n+     (File : File_Descriptor;\n+      Str  : String);\n    --  Simulate Ada.Text_IO.Put with GNAT.OS_Lib\n \n    procedure Put_Used_Char_Set\n@@ -191,16 +189,18 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Put_Int_Vector\n      (File   : File_Descriptor;\n       Title  : String;\n-      Root   : Integer;\n+      Vector : Integer;\n       Length : Natural);\n    --  Output a title and a vector\n \n    procedure Put_Int_Matrix\n      (File  : File_Descriptor;\n       Title : String;\n-      Table : Table_Id);\n-   --  Output a title and a matrix. When the matrix has only one\n-   --  non-empty dimension, it is output as a vector.\n+      Table : Table_Id;\n+      Len_1 : Natural;\n+      Len_2 : Natural);\n+   --  Output a title and a matrix. When the matrix has only one non-empty\n+   --  dimension (Len_2 = 0), output a vector.\n \n    procedure Put_Edges\n      (File  : File_Descriptor;\n@@ -226,82 +226,79 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Character Position Selection --\n    ----------------------------------\n \n-   --  We reduce the maximum key size by selecting representative\n-   --  positions in these keys. We build a matrix with one word per\n-   --  line. We fill the remaining space of a line with ASCII.NUL. The\n-   --  heuristic selects the position that induces the minimum number\n-   --  of collisions. If there are collisions, select another position\n-   --  on the reduced key set responsible of the collisions. Apply the\n-   --  heuristic until there is no more collision.\n+   --  We reduce the maximum key size by selecting representative positions\n+   --  in these keys. We build a matrix with one word per line. We fill the\n+   --  remaining space of a line with ASCII.NUL. The heuristic selects the\n+   --  position that induces the minimum number of collisions. If there are\n+   --  collisions, select another position on the reduced key set responsible\n+   --  of the collisions. Apply the heuristic until there is no more collision.\n \n    procedure Apply_Position_Selection;\n    --  Apply Position selection and build the reduced key table\n \n    procedure Parse_Position_Selection (Argument : String);\n-   --  Parse Argument and compute the position set. Argument is a\n-   --  list of substrings separated by commas. Each substring\n-   --  represents a position or a range of positions (like x-y).\n+   --  Parse Argument and compute the position set. Argument is list of\n+   --  substrings separated by commas. Each substring represents a position\n+   --  or a range of positions (like x-y).\n \n    procedure Select_Character_Set;\n-   --  Define an optimized used character set like Character'Pos in\n-   --  order not to allocate tables of 256 entries.\n+   --  Define an optimized used character set like Character'Pos in order not\n+   --  to allocate tables of 256 entries.\n \n    procedure Select_Char_Position;\n-   --  Find a min char position set in order to reduce the max key\n-   --  length. The heuristic selects the position that induces the\n-   --  minimum number of collisions. If there are collisions, select\n-   --  another position on the reduced key set responsible of the\n-   --  collisions. Apply the heuristic until there is no collision.\n+   --  Find a min char position set in order to reduce the max key length. The\n+   --  heuristic selects the position that induces the minimum number of\n+   --  collisions. If there are collisions, select another position on the\n+   --  reduced key set responsible of the collisions. Apply the heuristic until\n+   --  there is no collision.\n \n    -----------------------------\n    -- Random Graph Generation --\n    -----------------------------\n \n    procedure Random (Seed : in out Natural);\n-   --  Simulate Ada.Discrete_Numerics.Random.\n+   --  Simulate Ada.Discrete_Numerics.Random\n \n    procedure Generate_Mapping_Table\n-     (T  : Table_Id;\n-      L1 : Natural;\n-      L2 : Natural;\n-      S  : in out Natural);\n-   --  Random generation of the tables below. T is already allocated.\n+     (Tab  : Table_Id;\n+      L1   : Natural;\n+      L2   : Natural;\n+      Seed : in out Natural);\n+   --  Random generation of the tables below. T is already allocated\n \n    procedure Generate_Mapping_Tables\n-     (Opt : Optimization;\n-      S   : in out Natural);\n-   --  Generate the mapping tables T1 and T2. They are used to define :\n-   --  fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n.\n-   --  Keys, NK and Chars are used to compute the matrix size.\n+     (Opt  : Optimization;\n+      Seed : in out Natural);\n+   --  Generate the mapping tables T1 and T2. They are used to define fk (w) =\n+   --  sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n. Keys, NK and Chars\n+   --  are used to compute the matrix size.\n \n    ---------------------------\n    -- Algorithm Computation --\n    ---------------------------\n \n    procedure Compute_Edges_And_Vertices (Opt : Optimization);\n-   --  Compute the edge and vertex tables. These are empty when a self\n-   --  loop is detected (f1 (w) = f2 (w)). The edge table is sorted by\n-   --  X value and then Y value. Keys is the key table and NK the\n-   --  number of keys. Chars is the set of characters really used in\n-   --  Keys. NV is the number of vertices recommended by the\n-   --  algorithm. T1 and T2 are the mapping tables needed to compute\n-   --  f1 (w) and f2 (w).\n+   --  Compute the edge and vertex tables. These are empty when a self loop is\n+   --  detected (f1 (w) = f2 (w)). The edge table is sorted by X value and then\n+   --  Y value. Keys is the key table and NK the number of keys. Chars is the\n+   --  set of characters really used in Keys. NV is the number of vertices\n+   --  recommended by the algorithm. T1 and T2 are the mapping tables needed to\n+   --  compute f1 (w) and f2 (w).\n \n    function Acyclic return Boolean;\n-   --  Return True when the graph is acyclic. Vertices is the current\n-   --  vertex table and Edges the current edge table.\n+   --  Return True when the graph is acyclic. Vertices is the current vertex\n+   --  table and Edges the current edge table.\n \n    procedure Assign_Values_To_Vertices;\n-   --  Execute the assignment step of the algorithm. Keys is the\n-   --  current key table. Vertices and Edges represent the random\n-   --  graph. G is the result of the assignment step such that:\n+   --  Execute the assignment step of the algorithm. Keys is the current key\n+   --  table. Vertices and Edges represent the random graph. G is the result of\n+   --  the assignment step such that:\n    --    h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n \n    function Sum\n      (Word  : Word_Type;\n       Table : Table_Id;\n-      Opt   : Optimization)\n-      return  Natural;\n+      Opt   : Optimization) return Natural;\n    --  For an optimization of CPU_Time return\n    --    fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n    --  For an optimization of Memory_Space return\n@@ -312,16 +309,18 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Internal Table Management --\n    -------------------------------\n \n-   function  Allocate (N : Natural; S : Natural) return Table_Id;\n-   --  procedure Deallocate (N : Natural; S : Natural);\n+   function  Allocate (N : Natural; S : Natural := 1) return Table_Id;\n+   --  Allocate N * S ints from IT table\n+\n+   procedure Free_Tmp_Tables;\n+   --  Deallocate the tables used by the algorithm (but not the keys table)\n \n    ----------\n    -- Keys --\n    ----------\n \n-   Key_Size : constant := 1;\n-   Keys     : Table_Id := No_Table;\n-   NK       : Natural;\n+   Keys : Table_Id := No_Table;\n+   NK   : Natural  := 0;\n    --  NK : Number of Keys\n \n    function Initial (K : Key_Id) return Word_Id;\n@@ -330,64 +329,63 @@ package body GNAT.Perfect_Hash_Generators is\n    function Reduced (K : Key_Id) return Word_Id;\n    pragma Inline (Reduced);\n \n-   function  Get_Key (F : Key_Id) return Key_Type;\n-   procedure Set_Key (F : Key_Id; Item : Key_Type);\n-   --  Comments needed here ???\n+   function  Get_Key (N : Key_Id) return Key_Type;\n+   procedure Set_Key (N : Key_Id; Item : Key_Type);\n+   --  Get or Set Nth element of Keys table\n \n    ------------------\n    -- Char_Pos_Set --\n    ------------------\n \n-   Char_Pos_Size    : constant := 1;\n    Char_Pos_Set     : Table_Id := No_Table;\n    Char_Pos_Set_Len : Natural;\n    --  Character Selected Position Set\n \n    function  Get_Char_Pos (P : Natural) return Natural;\n    procedure Set_Char_Pos (P : Natural; Item : Natural);\n-   --  Comments needed here ???\n+   --  Get or Set the string position of the Pth selected character\n \n    -------------------\n    -- Used_Char_Set --\n    -------------------\n \n-   Used_Char_Size    : constant := 1;\n    Used_Char_Set     : Table_Id := No_Table;\n    Used_Char_Set_Len : Natural;\n-   --  Used Character Set : Define a new character mapping. When all\n-   --  the characters are not present in the keys, in order to reduce\n-   --  the size of some tables, we redefine the character mapping.\n+   --  Used Character Set : Define a new character mapping. When all the\n+   --  characters are not present in the keys, in order to reduce the size\n+   --  of some tables, we redefine the character mapping.\n \n    function  Get_Used_Char (C : Character) return Natural;\n    procedure Set_Used_Char (C : Character; Item : Natural);\n \n-   -------------------\n-   -- Random Tables --\n-   -------------------\n+   ------------\n+   -- Tables --\n+   ------------\n \n-   Rand_Tab_Item_Size : constant := 1;\n-   T1                 : Table_Id := No_Table;\n-   T2                 : Table_Id := No_Table;\n-   Rand_Tab_Len_1     : Natural;\n-   Rand_Tab_Len_2     : Natural;\n+   T1     : Table_Id := No_Table;\n+   T2     : Table_Id := No_Table;\n+   T1_Len : Natural;\n+   T2_Len : Natural;\n    --  T1  : Values table to compute F1\n    --  T2  : Values table to compute F2\n \n-   function  Get_Rand_Tab (T : Integer; X, Y : Natural) return Natural;\n-   procedure Set_Rand_Tab (T : Integer; X, Y : Natural; Item : Natural);\n+   function  Get_Table (T : Integer; X, Y : Natural) return Natural;\n+   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural);\n \n-   ------------------\n-   -- Random Graph --\n-   ------------------\n+   -----------\n+   -- Graph --\n+   -----------\n \n-   Graph_Item_Size : constant := 1;\n-   G               : Table_Id := No_Table;\n-   Graph_Len       : Natural;\n-   --  G   : Values table to compute G\n+   G     : Table_Id := No_Table;\n+   G_Len : Natural;\n+   --  Values table to compute G\n \n-   function  Get_Graph (F : Natural) return Integer;\n-   procedure Set_Graph (F : Natural; Item : Integer);\n-   --  Comments needed ???\n+   NT : Natural := Default_Tries;\n+   --  Number of tries running the algorithm before raising an error\n+\n+   function  Get_Graph (N : Natural) return Integer;\n+   procedure Set_Graph (N : Natural; Item : Integer);\n+   --  Get or Set Nth element of graph\n \n    -----------\n    -- Edges --\n@@ -423,8 +421,9 @@ package body GNAT.Perfect_Hash_Generators is\n    Opt : Optimization;\n    --  Optimization mode (memory vs CPU)\n \n-   MKL : Natural;\n-   --  Maximum of all the word length\n+   Max_Key_Len : Natural := 0;\n+   Min_Key_Len : Natural := Max_Word_Length;\n+   --  Maximum and minimum of all the word length\n \n    S : Natural;\n    --  Seed\n@@ -436,26 +435,23 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Acyclic --\n    -------------\n \n-   function Acyclic return Boolean\n-   is\n+   function Acyclic return Boolean is\n       Marks : array (0 .. NV - 1) of Vertex_Id := (others => No_Vertex);\n \n       function Traverse\n-        (Edge  : Edge_Id;\n-         Mark  : Vertex_Id)\n-         return  Boolean;\n-      --  Propagate Mark from X to Y. X is already marked. Mark Y and\n-      --  propagate it to the edges of Y except the one representing\n-      --  the same key. Return False when Y is marked with Mark.\n+        (Edge : Edge_Id;\n+         Mark : Vertex_Id) return Boolean;\n+      --  Propagate Mark from X to Y. X is already marked. Mark Y and propagate\n+      --  it to the edges of Y except the one representing the same key. Return\n+      --  False when Y is marked with Mark.\n \n       --------------\n       -- Traverse --\n       --------------\n \n       function Traverse\n-        (Edge  : Edge_Id;\n-         Mark  : Vertex_Id)\n-         return  Boolean\n+        (Edge : Edge_Id;\n+         Mark : Vertex_Id) return Boolean\n       is\n          E : constant Edge_Type := Get_Edges (Edge);\n          K : constant Key_Id    := E.Key;\n@@ -473,7 +469,7 @@ package body GNAT.Perfect_Hash_Generators is\n \n             for J in V.First .. V.Last loop\n \n-               --  Do not propagate to the edge representing the same key.\n+               --  Do not propagate to the edge representing the same key\n \n                if Get_Edges (J).Key /= K\n                  and then not Traverse (J, Mark)\n@@ -531,7 +527,6 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Add (S : String) is\n       Len : constant Natural := S'Length;\n-\n    begin\n       Line (Last + 1 .. Last + Len) := S;\n       Last := Last + Len;\n@@ -541,9 +536,8 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Allocate --\n    --------------\n \n-   function  Allocate (N : Natural; S : Natural) return Table_Id is\n+   function  Allocate (N : Natural; S : Natural := 1) return Table_Id is\n       L : constant Integer := IT.Last;\n-\n    begin\n       IT.Set_Last (L + N * S);\n       return L + 1;\n@@ -555,16 +549,16 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Apply_Position_Selection is\n    begin\n-      WT.Set_Last (2 * NK - 1);\n+      WT.Set_Last (2 * NK);\n       for J in 0 .. NK - 1 loop\n          declare\n             I_Word : constant Word_Type := WT.Table (Initial (J));\n             R_Word : Word_Type := Null_Word;\n             Index  : Natural   := I_Word'First - 1;\n \n          begin\n-            --  Select the characters of Word included in the\n-            --  position selection.\n+            --  Select the characters of Word included in the position\n+            --  selection.\n \n             for C in 0 .. Char_Pos_Set_Len - 1 loop\n                exit when I_Word (Get_Char_Pos (C)) = ASCII.NUL;\n@@ -580,56 +574,6 @@ package body GNAT.Perfect_Hash_Generators is\n       end loop;\n    end Apply_Position_Selection;\n \n-   -------------\n-   -- Compute --\n-   -------------\n-\n-   procedure Compute (Position : String := Default_Position) is\n-   begin\n-      Keys := Allocate (NK, Key_Size);\n-\n-      if Verbose then\n-         Put_Initial_Keys (Output, \"Initial Key Table\");\n-      end if;\n-\n-      if Position'Length /= 0 then\n-         Parse_Position_Selection (Position);\n-      else\n-         Select_Char_Position;\n-      end if;\n-\n-      if Verbose then\n-         Put_Int_Vector\n-           (Output, \"Char Position Set\", Char_Pos_Set, Char_Pos_Set_Len);\n-      end if;\n-\n-      Apply_Position_Selection;\n-\n-      if Verbose then\n-         Put_Reduced_Keys (Output, \"Reduced Keys Table\");\n-      end if;\n-\n-      Select_Character_Set;\n-\n-      if Verbose then\n-         Put_Used_Char_Set (Output, \"Character Position Table\");\n-      end if;\n-\n-      --  Perform Czech's algorithm\n-\n-      loop\n-         Generate_Mapping_Tables (Opt, S);\n-         Compute_Edges_And_Vertices (Opt);\n-\n-         --  When graph is not empty (no self-loop from previous\n-         --  operation) and not acyclic.\n-\n-         exit when 0 < Edges_Len and then Acyclic;\n-      end loop;\n-\n-      Assign_Values_To_Vertices;\n-   end Compute;\n-\n    -------------------------------\n    -- Assign_Values_To_Vertices --\n    -------------------------------\n@@ -638,8 +582,8 @@ package body GNAT.Perfect_Hash_Generators is\n       X  : Vertex_Id;\n \n       procedure Assign (X : Vertex_Id);\n-      --  Execute assignment on X's neighbors except the vertex that\n-      --  we are coming from which is already assigned.\n+      --  Execute assignment on X's neighbors except the vertex that we are\n+      --  coming from which is already assigned.\n \n       ------------\n       -- Assign --\n@@ -649,7 +593,6 @@ package body GNAT.Perfect_Hash_Generators is\n       is\n          E : Edge_Type;\n          V : constant Vertex_Type := Get_Vertices (X);\n-\n       begin\n          for J in V.First .. V.Last loop\n             E := Get_Edges (J);\n@@ -667,11 +610,11 @@ package body GNAT.Perfect_Hash_Generators is\n       --  be in the range 0 .. NK.\n \n       if G = No_Table then\n-         Graph_Len := NV;\n-         G := Allocate (Graph_Len, Graph_Item_Size);\n+         G_Len := NV;\n+         G := Allocate (G_Len, 1);\n       end if;\n \n-      for J in 0 .. Graph_Len - 1 loop\n+      for J in 0 .. G_Len - 1 loop\n          Set_Graph (J, -1);\n       end loop;\n \n@@ -684,17 +627,80 @@ package body GNAT.Perfect_Hash_Generators is\n          end if;\n       end loop;\n \n-      for J in 0 .. Graph_Len - 1 loop\n+      for J in 0 .. G_Len - 1 loop\n          if Get_Graph (J) = -1 then\n             Set_Graph (J, 0);\n          end if;\n       end loop;\n \n       if Verbose then\n-         Put_Int_Vector (Output, \"Assign Values To Vertices\", G, Graph_Len);\n+         Put_Int_Vector (Output, \"Assign Values To Vertices\", G, G_Len);\n       end if;\n    end Assign_Values_To_Vertices;\n \n+   -------------\n+   -- Compute --\n+   -------------\n+\n+   procedure Compute\n+     (Position : String := Default_Position)\n+   is\n+      Success : Boolean := False;\n+\n+   begin\n+      NV := Natural (K2V * Float (NK));\n+\n+      Keys := Allocate (NK);\n+\n+      if Verbose then\n+         Put_Initial_Keys (Output, \"Initial Key Table\");\n+      end if;\n+\n+      if Position'Length /= 0 then\n+         Parse_Position_Selection (Position);\n+      else\n+         Select_Char_Position;\n+      end if;\n+\n+      if Verbose then\n+         Put_Int_Vector\n+           (Output, \"Char Position Set\", Char_Pos_Set, Char_Pos_Set_Len);\n+      end if;\n+\n+      Apply_Position_Selection;\n+\n+      if Verbose then\n+         Put_Reduced_Keys (Output, \"Reduced Keys Table\");\n+      end if;\n+\n+      Select_Character_Set;\n+\n+      if Verbose then\n+         Put_Used_Char_Set (Output, \"Character Position Table\");\n+      end if;\n+\n+      --  Perform Czech's algorithm\n+\n+      for J in 1 .. NT loop\n+         Generate_Mapping_Tables (Opt, S);\n+         Compute_Edges_And_Vertices (Opt);\n+\n+         --  When graph is not empty (no self-loop from previous operation) and\n+         --  not acyclic.\n+\n+         if 0 < Edges_Len and then Acyclic then\n+            Success := True;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if not Success then\n+         raise Too_Many_Tries;\n+      end if;\n+\n+      Assign_Values_To_Vertices;\n+   end Compute;\n+\n    --------------------------------\n    -- Compute_Edges_And_Vertices --\n    --------------------------------\n@@ -711,32 +717,31 @@ package body GNAT.Perfect_Hash_Generators is\n       function Lt (L, R : Natural) return Boolean;\n       --  Subprograms needed for GNAT.Heap_Sort_A\n \n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Set_Edges (To, Get_Edges (From));\n-      end Move;\n-\n       --------\n       -- Lt --\n       --------\n \n       function Lt (L, R : Natural) return Boolean is\n          EL : constant Edge_Type := Get_Edges (L);\n          ER : constant Edge_Type := Get_Edges (R);\n-\n       begin\n          return EL.X < ER.X or else (EL.X = ER.X and then EL.Y < ER.Y);\n       end Lt;\n \n+      ----------\n+      -- Move --\n+      ----------\n+\n+      procedure Move (From : Natural; To : Natural) is\n+      begin\n+         Set_Edges (To, Get_Edges (From));\n+      end Move;\n+\n    --  Start of processing for Compute_Edges_And_Vertices\n \n    begin\n-      --  We store edges from 1 to 2 * NK and leave\n-      --  zero alone in order to use GNAT.Heap_Sort_A.\n+      --  We store edges from 1 to 2 * NK and leave zero alone in order to use\n+      --  GNAT.Heap_Sort_A.\n \n       Edges_Len := 2 * NK + 1;\n \n@@ -783,14 +788,16 @@ package body GNAT.Perfect_Hash_Generators is\n       else\n          if Verbose then\n             Put_Edges      (Output, \"Unsorted Edge Table\");\n-            Put_Int_Matrix (Output, \"Function Table 1\", T1);\n-            Put_Int_Matrix (Output, \"Function Table 2\", T2);\n+            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                            T1_Len, T2_Len);\n+            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                            T1_Len, T2_Len);\n          end if;\n \n-         --  Enforce consistency between edges and keys. Construct\n-         --  Vertices and compute the list of neighbors of a vertex\n-         --  First .. Last as Edges is sorted by X and then Y. To\n-         --  compute the neighbor list, sort the edges.\n+         --  Enforce consistency between edges and keys. Construct Vertices and\n+         --  compute the list of neighbors of a vertex First .. Last as Edges\n+         --  is sorted by X and then Y. To compute the neighbor list, sort the\n+         --  edges.\n \n          Sort\n            (Edges_Len - 1,\n@@ -799,8 +806,10 @@ package body GNAT.Perfect_Hash_Generators is\n \n          if Verbose then\n             Put_Edges      (Output, \"Sorted Edge Table\");\n-            Put_Int_Matrix (Output, \"Function Table 1\", T1);\n-            Put_Int_Matrix (Output, \"Function Table 2\", T2);\n+            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                            T1_Len, T2_Len);\n+            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                            T1_Len, T2_Len);\n          end if;\n \n          --  Edges valid range is 1 .. 2 * NK\n@@ -857,8 +866,8 @@ package body GNAT.Perfect_Hash_Generators is\n          when Function_Table_1\n            |  Function_Table_2 =>\n             Item_Size := Type_Size (NV);\n-            Length_1  := Rand_Tab_Len_1;\n-            Length_2  := Rand_Tab_Len_2;\n+            Length_1  := T1_Len;\n+            Length_2  := T2_Len;\n \n          when Graph_Table =>\n             Item_Size := Type_Size (NK);\n@@ -873,11 +882,25 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Finalize is\n    begin\n+      Free_Tmp_Tables;\n+\n       WT.Release;\n       IT.Release;\n \n+      NK := 0;\n+      Max_Key_Len := 0;\n+      Min_Key_Len := Max_Word_Length;\n+   end Finalize;\n+\n+   ---------------------\n+   -- Free_Tmp_Tables --\n+   ---------------------\n+\n+   procedure Free_Tmp_Tables is\n+   begin\n+      IT.Init;\n+\n       Keys := No_Table;\n-      NK   := 0;\n \n       Char_Pos_Set     := No_Table;\n       Char_Pos_Set_Len := 0;\n@@ -888,34 +911,34 @@ package body GNAT.Perfect_Hash_Generators is\n       T1 := No_Table;\n       T2 := No_Table;\n \n-      Rand_Tab_Len_1 := 0;\n-      Rand_Tab_Len_2 := 0;\n+      T1_Len := 0;\n+      T2_Len := 0;\n \n-      G         := No_Table;\n-      Graph_Len := 0;\n+      G     := No_Table;\n+      G_Len := 0;\n \n       Edges     := No_Table;\n       Edges_Len := 0;\n \n-      Vertices     := No_Table;\n-      NV           := 0;\n-   end Finalize;\n+      Vertices := No_Table;\n+      NV       := 0;\n+   end Free_Tmp_Tables;\n \n    ----------------------------\n    -- Generate_Mapping_Table --\n    ----------------------------\n \n    procedure Generate_Mapping_Table\n-     (T  : Integer;\n-      L1 : Natural;\n-      L2 : Natural;\n-      S  : in out Natural)\n+     (Tab  : Integer;\n+      L1   : Natural;\n+      L2   : Natural;\n+      Seed : in out Natural)\n    is\n    begin\n       for J in 0 .. L1 - 1 loop\n          for K in 0 .. L2 - 1 loop\n-            Random (S);\n-            Set_Rand_Tab (T, J, K, S mod NV);\n+            Random (Seed);\n+            Set_Table (Tab, J, K, Seed mod NV);\n          end loop;\n       end loop;\n    end Generate_Mapping_Table;\n@@ -925,12 +948,12 @@ package body GNAT.Perfect_Hash_Generators is\n    -----------------------------\n \n    procedure Generate_Mapping_Tables\n-     (Opt : Optimization;\n-      S   : in out Natural)\n+     (Opt  : Optimization;\n+      Seed : in out Natural)\n    is\n    begin\n-      --  If T1 and T2 are already allocated no need to do it\n-      --  twice. Reuse them as their size has not changes.\n+      --  If T1 and T2 are already allocated no need to do it twice. Reuse them\n+      --  as their size has not changed.\n \n       if T1 = No_Table and then T2 = No_Table then\n          declare\n@@ -948,22 +971,22 @@ package body GNAT.Perfect_Hash_Generators is\n                end loop;\n             end if;\n \n-            Rand_Tab_Len_1 := Char_Pos_Set_Len;\n-            Rand_Tab_Len_2 := Used_Char_Last + 1;\n-            T1 := Allocate (Rand_Tab_Len_1 * Rand_Tab_Len_2,\n-                            Rand_Tab_Item_Size);\n-            T2 := Allocate (Rand_Tab_Len_1 * Rand_Tab_Len_2,\n-                            Rand_Tab_Item_Size);\n+            T1_Len := Char_Pos_Set_Len;\n+            T2_Len := Used_Char_Last + 1;\n+            T1 := Allocate (T1_Len * T2_Len);\n+            T2 := Allocate (T1_Len * T2_Len);\n          end;\n       end if;\n \n-      Generate_Mapping_Table (T1, Rand_Tab_Len_1, Rand_Tab_Len_2, S);\n-      Generate_Mapping_Table (T2, Rand_Tab_Len_1, Rand_Tab_Len_2, S);\n+      Generate_Mapping_Table (T1, T1_Len, T2_Len, Seed);\n+      Generate_Mapping_Table (T2, T1_Len, T2_Len, Seed);\n \n       if Verbose then\n          Put_Used_Char_Set (Output, \"Used Character Set\");\n-         Put_Int_Matrix (Output, \"Function Table 1\", T1);\n-         Put_Int_Matrix (Output, \"Function Table 2\", T2);\n+         Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                        T1_Len, T2_Len);\n+         Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                        T1_Len, T2_Len);\n       end if;\n    end Generate_Mapping_Tables;\n \n@@ -973,7 +996,6 @@ package body GNAT.Perfect_Hash_Generators is\n \n    function Get_Char_Pos (P : Natural) return Natural is\n       N : constant Natural := Char_Pos_Set + P;\n-\n    begin\n       return IT.Table (N);\n    end Get_Char_Pos;\n@@ -985,7 +1007,6 @@ package body GNAT.Perfect_Hash_Generators is\n    function Get_Edges (F : Natural) return Edge_Type is\n       N : constant Natural := Edges + (F * Edge_Size);\n       E : Edge_Type;\n-\n    begin\n       E.X   := IT.Table (N);\n       E.Y   := IT.Table (N + 1);\n@@ -997,46 +1018,38 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Get_Graph --\n    ---------------\n \n-   function Get_Graph (F : Natural) return Integer is\n-      N : constant Natural := G + F * Graph_Item_Size;\n-\n+   function Get_Graph (N : Natural) return Integer is\n    begin\n-      return IT.Table (N);\n+      return IT.Table (G + N);\n    end Get_Graph;\n \n    -------------\n    -- Get_Key --\n    -------------\n \n-   function Get_Key (F : Key_Id) return Key_Type is\n-      N : constant Natural := Keys + F * Key_Size;\n+   function Get_Key (N : Key_Id) return Key_Type is\n       K : Key_Type;\n-\n    begin\n-      K.Edge := IT.Table (N);\n+      K.Edge := IT.Table (Keys + N);\n       return K;\n    end Get_Key;\n \n-   ------------------\n-   -- Get_Rand_Tab --\n-   ------------------\n-\n-   function Get_Rand_Tab (T : Integer; X, Y : Natural) return Natural is\n-      N : constant Natural :=\n-            T + ((Y * Rand_Tab_Len_1) + X) * Rand_Tab_Item_Size;\n+   ---------------\n+   -- Get_Table --\n+   ---------------\n \n+   function Get_Table (T : Integer; X, Y : Natural) return Natural is\n+      N : constant Natural := T + (Y * T1_Len) + X;\n    begin\n       return IT.Table (N);\n-   end Get_Rand_Tab;\n+   end Get_Table;\n \n    -------------------\n    -- Get_Used_Char --\n    -------------------\n \n    function Get_Used_Char (C : Character) return Natural is\n-      N : constant Natural :=\n-            Used_Char_Set + Character'Pos (C) * Used_Char_Size;\n-\n+      N : constant Natural := Used_Char_Set + Character'Pos (C);\n    begin\n       return IT.Table (N);\n    end Get_Used_Char;\n@@ -1048,7 +1061,6 @@ package body GNAT.Perfect_Hash_Generators is\n    function Get_Vertices (F : Natural) return Vertex_Type is\n       N : constant Natural := Vertices + (F * Vertex_Size);\n       V : Vertex_Type;\n-\n    begin\n       V.First := IT.Table (N);\n       V.Last  := IT.Table (N + 1);\n@@ -1135,22 +1147,24 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Initialize\n      (Seed   : Natural;\n       K_To_V : Float        := Default_K_To_V;\n-      Optim  : Optimization := CPU_Time)\n+      Optim  : Optimization := CPU_Time;\n+      Tries  : Positive     := Default_Tries)\n    is\n    begin\n-      WT.Init;\n-      IT.Init;\n-      S   := Seed;\n+      --  Free previous tables (the settings may have changed between two runs)\n \n-      Keys := No_Table;\n-      NK   := 0;\n+      Free_Tmp_Tables;\n \n-      Char_Pos_Set     := No_Table;\n-      Char_Pos_Set_Len := 0;\n+      if K_To_V <= 2.0 then\n+         Put (Output, \"K to V ratio cannot be lower than 2.0\");\n+         New_Line (Output);\n+         raise Program_Error;\n+      end if;\n \n-      K2V := K_To_V;\n-      Opt := Optim;\n-      MKL := 0;\n+      S    := Seed;\n+      K2V  := K_To_V;\n+      Opt  := Optim;\n+      NT   := Tries;\n    end Initialize;\n \n    ------------\n@@ -1170,20 +1184,29 @@ package body GNAT.Perfect_Hash_Generators is\n       NK := NK + 1;\n       NV := Natural (Float (NK) * K2V);\n \n-      if MKL < Len then\n-         MKL := Len;\n+      --  Do not accept a value of K2V too close to 2.0 such that once rounded\n+      --  up, NV = 2 * NK because the algorithm would not converge.\n+\n+      if NV <= 2 * NK then\n+         NV := 2 * NK + 1;\n+      end if;\n+\n+      if Max_Key_Len < Len then\n+         Max_Key_Len := Len;\n+      end if;\n+\n+      if Len < Min_Key_Len then\n+         Min_Key_Len := Len;\n       end if;\n    end Insert;\n \n    --------------\n    -- New_Line --\n    --------------\n \n-   procedure New_Line (F : File_Descriptor) is\n-      EOL : constant Character := ASCII.LF;\n-\n+   procedure New_Line (File : File_Descriptor) is\n    begin\n-      if Write (F, EOL'Address, 1) /= 1 then\n+      if Write (File, EOL'Address, 1) /= 1 then\n          raise Program_Error;\n       end if;\n    end New_Line;\n@@ -1195,7 +1218,7 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Parse_Position_Selection (Argument : String) is\n       N : Natural          := Argument'First;\n       L : constant Natural := Argument'Last;\n-      M : constant Natural := MKL;\n+      M : constant Natural := Max_Key_Len;\n \n       T : array (1 .. M) of Boolean := (others => False);\n \n@@ -1206,8 +1229,7 @@ package body GNAT.Perfect_Hash_Generators is\n       -- Parse_Index --\n       -----------------\n \n-      function Parse_Index return Natural\n-      is\n+      function Parse_Index return Natural is\n          C : Character := Argument (N);\n          V : Natural   := 0;\n \n@@ -1235,13 +1257,12 @@ package body GNAT.Perfect_Hash_Generators is\n    --  Start of processing for Parse_Position_Selection\n \n    begin\n-      Char_Pos_Set_Len := 2 * NK;\n \n       --  Empty specification means all the positions\n \n       if L < N then\n          Char_Pos_Set_Len := M;\n-         Char_Pos_Set := Allocate (Char_Pos_Set_Len, Char_Pos_Size);\n+         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n \n          for C in 0 .. Char_Pos_Set_Len - 1 loop\n             Set_Char_Pos (C, C + 1);\n@@ -1292,7 +1313,7 @@ package body GNAT.Perfect_Hash_Generators is\n          --  Fill position selection\n \n          Char_Pos_Set_Len := N;\n-         Char_Pos_Set := Allocate (Char_Pos_Set_Len, Char_Pos_Size);\n+         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n \n          N := 0;\n          for J in T'Range loop\n@@ -1312,34 +1333,42 @@ package body GNAT.Perfect_Hash_Generators is\n       File     : File_Descriptor;\n \n       Status : Boolean;\n-      --  For call to Close;\n+      --  For call to Close\n \n-      function Type_Img (L : Natural) return String;\n-      --  Return the larger unsigned type T such that T'Last < L\n+      function Array_Img (N, T, R1 : String; R2 : String := \"\") return String;\n+      --  Return string \"N : constant array (R1[, R2]) of T;\"\n \n       function Range_Img (F, L : Natural; T : String := \"\") return String;\n       --  Return string \"[T range ]F .. L\"\n \n-      function Array_Img (N, T, R1 : String; R2 : String := \"\") return String;\n-      --  Return string \"N : constant array (R1[, R2]) of T;\"\n-\n-      --------------\n-      -- Type_Img --\n-      --------------\n+      function Type_Img (L : Natural) return String;\n+      --  Return the larger unsigned type T such that T'Last < L\n \n-      function Type_Img (L : Natural) return String is\n-         S : constant String := Image (Type_Size (L));\n-         U : String  := \"Unsigned_  \";\n-         N : Natural := 9;\n+      ---------------\n+      -- Array_Img --\n+      ---------------\n \n+      function Array_Img\n+        (N, T, R1 : String;\n+         R2       : String := \"\") return String\n+      is\n       begin\n-         for J in S'Range loop\n-            N := N + 1;\n-            U (N) := S (J);\n-         end loop;\n+         Last := 0;\n+         Add (\"   \");\n+         Add (N);\n+         Add (\" : constant array (\");\n+         Add (R1);\n \n-         return U (1 .. N);\n-      end Type_Img;\n+         if R2 /= \"\" then\n+            Add (\", \");\n+            Add (R2);\n+         end if;\n+\n+         Add (\") of \");\n+         Add (T);\n+         Add (\" :=\");\n+         return Line (1 .. Last);\n+      end Array_Img;\n \n       ---------------\n       -- Range_Img --\n@@ -1371,32 +1400,23 @@ package body GNAT.Perfect_Hash_Generators is\n          return RI (1 .. Len);\n       end Range_Img;\n \n-      ---------------\n-      -- Array_Img --\n-      ---------------\n+      --------------\n+      -- Type_Img --\n+      --------------\n \n-      function Array_Img\n-        (N, T, R1 : String;\n-         R2       : String := \"\")\n-         return     String\n-      is\n-      begin\n-         Last := 0;\n-         Add (\"   \");\n-         Add (N);\n-         Add (\" : constant array (\");\n-         Add (R1);\n+      function Type_Img (L : Natural) return String is\n+         S : constant String := Image (Type_Size (L));\n+         U : String  := \"Unsigned_  \";\n+         N : Natural := 9;\n \n-         if R2 /= \"\" then\n-            Add (\", \");\n-            Add (R2);\n-         end if;\n+      begin\n+         for J in S'Range loop\n+            N := N + 1;\n+            U (N) := S (J);\n+         end loop;\n \n-         Add (\") of \");\n-         Add (T);\n-         Add (\" :=\");\n-         return Line (1 .. Last);\n-      end Array_Img;\n+         return U (1 .. N);\n+      end Type_Img;\n \n       F : Natural;\n       L : Natural;\n@@ -1460,7 +1480,7 @@ package body GNAT.Perfect_Hash_Generators is\n \n          for J in Character'Range loop\n             P := Get_Used_Char (J);\n-            Put (File, Image (P), 0, 0, 0, F, L, Character'Pos (J));\n+            Put (File, Image (P), 1, 0, 1, F, L, Character'Pos (J));\n          end loop;\n \n          New_Line (File);\n@@ -1473,7 +1493,7 @@ package body GNAT.Perfect_Hash_Generators is\n       New_Line (File);\n \n       for J in F .. L loop\n-         Put (File, Image (Get_Char_Pos (J)), 0, 0, 0, F, L, J);\n+         Put (File, Image (Get_Char_Pos (J)), 1, 0, 1, F, L, J);\n       end loop;\n \n       New_Line (File);\n@@ -1482,17 +1502,16 @@ package body GNAT.Perfect_Hash_Generators is\n          Put_Int_Matrix\n            (File,\n             Array_Img (\"T1\", Type_Img (NV),\n-                       Range_Img (0, Rand_Tab_Len_1 - 1),\n-                       Range_Img (0, Rand_Tab_Len_2 - 1,\n-                                  Type_Img (256))),\n-            T1);\n+                       Range_Img (0, T1_Len - 1),\n+                       Range_Img (0, T2_Len - 1, Type_Img (256))),\n+            T1, T1_Len, T2_Len);\n \n       else\n          Put_Int_Matrix\n            (File,\n             Array_Img (\"T1\", Type_Img (NV),\n-                       Range_Img (0, Rand_Tab_Len_1 - 1)),\n-            T1);\n+                       Range_Img (0, T1_Len - 1)),\n+            T1, T1_Len, 0);\n       end if;\n \n       New_Line (File);\n@@ -1501,26 +1520,25 @@ package body GNAT.Perfect_Hash_Generators is\n          Put_Int_Matrix\n            (File,\n             Array_Img (\"T2\", Type_Img (NV),\n-                       Range_Img (0, Rand_Tab_Len_1 - 1),\n-                       Range_Img (0, Rand_Tab_Len_2 - 1,\n-                                  Type_Img (256))),\n-            T2);\n+                       Range_Img (0, T1_Len - 1),\n+                       Range_Img (0, T2_Len - 1, Type_Img (256))),\n+            T2, T1_Len, T2_Len);\n \n       else\n          Put_Int_Matrix\n            (File,\n             Array_Img (\"T2\", Type_Img (NV),\n-                       Range_Img (0, Rand_Tab_Len_1 - 1)),\n-            T2);\n+                       Range_Img (0, T1_Len - 1)),\n+            T2, T1_Len, 0);\n       end if;\n \n       New_Line (File);\n \n       Put_Int_Vector\n         (File,\n          Array_Img (\"G\", Type_Img (NK),\n-                    Range_Img (0, Graph_Len - 1)),\n-         G, Graph_Len);\n+                    Range_Img (0, G_Len - 1)),\n+         G, G_Len);\n       New_Line (File);\n \n       Put      (File, \"   function Hash (S : String) return Natural is\");\n@@ -1621,11 +1639,11 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Put --\n    ---------\n \n-   procedure Put (F : File_Descriptor; S : String) is\n-      Len : constant Natural := S'Length;\n+   procedure Put (File : File_Descriptor; Str : String) is\n+      Len : constant Natural := Str'Length;\n \n    begin\n-      if Write (F, S'Address, Len) /= Len then\n+      if Write (File, Str'Address, Len) /= Len then\n          raise Program_Error;\n       end if;\n    end Put;\n@@ -1647,6 +1665,7 @@ package body GNAT.Perfect_Hash_Generators is\n       Len : constant Natural := S'Length;\n \n       procedure Flush;\n+      --  Write current line, followed by LF\n \n       -----------\n       -- Flush --\n@@ -1674,9 +1693,12 @@ package body GNAT.Perfect_Hash_Generators is\n          Line (Last + 1 .. Last + 5) := \"     \";\n          Last := Last + 5;\n \n-         if F1 /= L1 then\n+         if F1 <= L1 then\n             if C1 = F1 and then C2 = F2 then\n                Add ('(');\n+               if F1 = L1 then\n+                  Add (\"0 .. 0 => \");\n+               end if;\n             else\n                Add (' ');\n             end if;\n@@ -1685,6 +1707,9 @@ package body GNAT.Perfect_Hash_Generators is\n \n       if C2 = F2 then\n          Add ('(');\n+         if F2 = L2 then\n+            Add (\"0 .. 0 => \");\n+         end if;\n       else\n          Add (' ');\n       end if;\n@@ -1695,7 +1720,7 @@ package body GNAT.Perfect_Hash_Generators is\n       if C2 = L2 then\n          Add (')');\n \n-         if F1 = L1 then\n+         if F1 > L1 then\n             Add (';');\n             Flush;\n          elsif C1 /= L1 then\n@@ -1712,56 +1737,91 @@ package body GNAT.Perfect_Hash_Generators is\n       end if;\n    end Put;\n \n-   -----------------------\n-   -- Put_Used_Char_Set --\n-   -----------------------\n+   ---------------\n+   -- Put_Edges --\n+   ---------------\n \n-   procedure Put_Used_Char_Set\n+   procedure Put_Edges\n      (File  : File_Descriptor;\n       Title : String)\n    is\n-      F : constant Natural := Character'Pos (Character'First);\n-      L : constant Natural := Character'Pos (Character'Last);\n+      E  : Edge_Type;\n+      F1 : constant Natural := 1;\n+      L1 : constant Natural := Edges_Len - 1;\n+      M  : constant Natural := Max / 5;\n \n    begin\n       Put (File, Title);\n       New_Line (File);\n \n-      for J in Character'Range loop\n-         Put\n-           (File, Image (Get_Used_Char (J)), 0, 0, 0, F, L, Character'Pos (J));\n+      --  Edges valid range is 1 .. Edge_Len - 1\n+\n+      for J in F1 .. L1 loop\n+         E := Get_Edges (J);\n+         Put (File, Image (J, M),     F1, L1, J, 1, 4, 1);\n+         Put (File, Image (E.X, M),   F1, L1, J, 1, 4, 2);\n+         Put (File, Image (E.Y, M),   F1, L1, J, 1, 4, 3);\n+         Put (File, Image (E.Key, M), F1, L1, J, 1, 4, 4);\n       end loop;\n-   end Put_Used_Char_Set;\n+   end Put_Edges;\n \n-   ----------\n-   -- Put --\n-   ----------\n+   ----------------------\n+   -- Put_Initial_Keys --\n+   ----------------------\n+\n+   procedure Put_Initial_Keys\n+     (File  : File_Descriptor;\n+      Title : String)\n+   is\n+      F1 : constant Natural := 0;\n+      L1 : constant Natural := NK - 1;\n+      M  : constant Natural := Max / 5;\n+      K  : Key_Type;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in F1 .. L1 loop\n+         K := Get_Key (J);\n+         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n+         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n+         Put (File, WT.Table (Initial (J)), F1, L1, J, 1, 3, 3);\n+      end loop;\n+   end Put_Initial_Keys;\n+\n+   --------------------\n+   -- Put_Int_Matrix --\n+   --------------------\n \n    procedure Put_Int_Matrix\n      (File   : File_Descriptor;\n       Title  : String;\n-      Table  : Integer)\n+      Table  : Integer;\n+      Len_1  : Natural;\n+      Len_2  : Natural)\n    is\n-      F1 : constant Natural := 0;\n-      L1 : constant Natural := Rand_Tab_Len_1 - 1;\n-      F2 : constant Natural := 0;\n-      L2 : constant Natural := Rand_Tab_Len_2 - 1;\n+      F1 : constant Integer := 0;\n+      L1 : constant Integer := Len_1 - 1;\n+      F2 : constant Integer := 0;\n+      L2 : constant Integer := Len_2 - 1;\n+      I  : Natural;\n \n    begin\n       Put (File, Title);\n       New_Line (File);\n \n-      if L2 = F2 then\n+      if Len_2 = 0 then\n          for J in F1 .. L1 loop\n-            Put (File,\n-                 Image (Get_Rand_Tab (Table, J, F2)), 0, 0, 0, F1, L1, J);\n+            I := IT.Table (Table + J);\n+            Put (File, Image (I), 1, 0, 1, F1, L1, J);\n          end loop;\n \n       else\n          for J in F1 .. L1 loop\n             for K in F2 .. L2 loop\n-               Put (File,\n-                    Image (Get_Rand_Tab (Table, J, K)), F1, L1, J, F2, L2, K);\n+               I := IT.Table (Table + J + K * Len_1);\n+               Put (File, Image (I), F1, L1, J, F2, L2, K);\n             end loop;\n          end loop;\n       end if;\n@@ -1774,7 +1834,7 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Put_Int_Vector\n      (File   : File_Descriptor;\n       Title  : String;\n-      Root   : Integer;\n+      Vector : Integer;\n       Length : Natural)\n    is\n       F2 : constant Natural := 0;\n@@ -1785,43 +1845,15 @@ package body GNAT.Perfect_Hash_Generators is\n       New_Line (File);\n \n       for J in F2 .. L2 loop\n-         Put (File, Image (IT.Table (Root + J)), 0, 0, 0, F2, L2, J);\n+         Put (File, Image (IT.Table (Vector + J)), 1, 0, 1, F2, L2, J);\n       end loop;\n    end Put_Int_Vector;\n \n-   ---------------\n-   -- Put_Edges --\n-   ---------------\n-\n-   procedure Put_Edges\n-     (File  : File_Descriptor;\n-      Title : String)\n-   is\n-      E  : Edge_Type;\n-      F1 : constant Natural := 1;\n-      L1 : constant Natural := Edges_Len - 1;\n-      M  : constant Natural := Max / 5;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      --  Edges valid range is 1 .. Edge_Len - 1\n-\n-      for J in F1 .. L1 loop\n-         E := Get_Edges (J);\n-         Put (File, Image (J, M),     F1, L1, J, 1, 4, 1);\n-         Put (File, Image (E.X, M),   F1, L1, J, 1, 4, 2);\n-         Put (File, Image (E.Y, M),   F1, L1, J, 1, 4, 3);\n-         Put (File, Image (E.Key, M), F1, L1, J, 1, 4, 4);\n-      end loop;\n-   end Put_Edges;\n-\n-   ---------------------------\n-   -- Put_Initial_Keys --\n-   ---------------------------\n+   ----------------------\n+   -- Put_Reduced_Keys --\n+   ----------------------\n \n-   procedure Put_Initial_Keys\n+   procedure Put_Reduced_Keys\n      (File  : File_Descriptor;\n       Title : String)\n    is\n@@ -1838,34 +1870,30 @@ package body GNAT.Perfect_Hash_Generators is\n          K := Get_Key (J);\n          Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n          Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Initial (J)), F1, L1, J, 1, 3, 3);\n+         Put (File, WT.Table (Reduced (J)), F1, L1, J, 1, 3, 3);\n       end loop;\n-   end Put_Initial_Keys;\n+   end Put_Reduced_Keys;\n \n-   ---------------------------\n-   -- Put_Reduced_Keys --\n-   ---------------------------\n+   -----------------------\n+   -- Put_Used_Char_Set --\n+   -----------------------\n \n-   procedure Put_Reduced_Keys\n+   procedure Put_Used_Char_Set\n      (File  : File_Descriptor;\n       Title : String)\n    is\n-      F1 : constant Natural := 0;\n-      L1 : constant Natural := NK - 1;\n-      M  : constant Natural := Max / 5;\n-      K  : Key_Type;\n+      F : constant Natural := Character'Pos (Character'First);\n+      L : constant Natural := Character'Pos (Character'Last);\n \n    begin\n       Put (File, Title);\n       New_Line (File);\n \n-      for J in F1 .. L1 loop\n-         K := Get_Key (J);\n-         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n-         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Reduced (J)), F1, L1, J, 1, 3, 3);\n+      for J in Character'Range loop\n+         Put\n+           (File, Image (Get_Used_Char (J)), 1, 0, 1, F, L, Character'Pos (J));\n       end loop;\n-   end Put_Reduced_Keys;\n+   end Put_Used_Char_Set;\n \n    ----------------------\n    -- Put_Vertex_Table --\n@@ -1898,8 +1926,8 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Random (Seed : in out Natural)\n    is\n-      --  Park & Miller Standard Minimal using Schrage's algorithm to\n-      --  avoid overflow: Xn+1 = 16807 * Xn mod (2 ** 31 - 1)\n+      --  Park & Miller Standard Minimal using Schrage's algorithm to avoid\n+      --  overflow: Xn+1 = 16807 * Xn mod (2 ** 31 - 1)\n \n       R : Natural;\n       Q : Natural;\n@@ -1923,39 +1951,9 @@ package body GNAT.Perfect_Hash_Generators is\n \n    function Reduced (K : Key_Id) return Word_Id is\n    begin\n-      return K + NK;\n+      return K + NK + 1;\n    end Reduced;\n \n-   --------------------------\n-   -- Select_Character_Set --\n-   --------------------------\n-\n-   procedure Select_Character_Set\n-   is\n-      Last : Natural := 0;\n-      Used : array (Character) of Boolean := (others => False);\n-\n-   begin\n-      for J in 0 .. NK - 1 loop\n-         for K in 1 .. Max_Word_Length loop\n-            exit when WT.Table (Initial (J))(K) = ASCII.NUL;\n-            Used (WT.Table (Initial (J))(K)) := True;\n-         end loop;\n-      end loop;\n-\n-      Used_Char_Set_Len := 256;\n-      Used_Char_Set := Allocate (Used_Char_Set_Len, Used_Char_Size);\n-\n-      for J in Used'Range loop\n-         if Used (J) then\n-            Set_Used_Char (J, Last);\n-            Last := Last + 1;\n-         else\n-            Set_Used_Char (J, 0);\n-         end if;\n-      end loop;\n-   end Select_Character_Set;\n-\n    --------------------------\n    -- Select_Char_Position --\n    --------------------------\n@@ -1968,21 +1966,21 @@ package body GNAT.Perfect_Hash_Generators is\n         (Table : in out Vertex_Table_Type;\n          Last  : in out Natural;\n          Pos   : in Natural);\n-      --  Build a list of keys subsets that are identical with the\n-      --  current position selection plus Pos. Once this routine is\n-      --  called, reduced words are sorted by subsets and each item\n-      --  (First, Last) in Sets defines the range of identical keys.\n-\n-      function Count_Identical_Keys\n-        (Table  : Vertex_Table_Type;\n-         Last   : Natural;\n-         Pos    : Natural)\n-         return   Natural;\n-      --  For each subset in Sets, count the number of identical keys\n-      --  if we add Pos to the current position selection.\n-\n-      Sel_Position : IT.Table_Type (1 .. MKL);\n+      --  Build a list of keys subsets that are identical with the current\n+      --  position selection plus Pos. Once this routine is called, reduced\n+      --  words are sorted by subsets and each item (First, Last) in Sets\n+      --  defines the range of identical keys.\n+\n+      function Count_Different_Keys\n+        (Table : Vertex_Table_Type;\n+         Last  : Natural;\n+         Pos   : Natural) return Natural;\n+      --  For each subset in Sets, count the number of different keys if we add\n+      --  Pos to the current position selection.\n+\n+      Sel_Position : IT.Table_Type (1 .. Max_Key_Len);\n       Last_Sel_Pos : Natural := 0;\n+      Max_Sel_Pos  : Natural := 0;\n \n       -------------------------------\n       -- Build_Identical_Keys_Sets --\n@@ -2001,133 +1999,132 @@ package body GNAT.Perfect_Hash_Generators is\n          L : Integer;\n          --  First and last words of a subset\n \n-      begin\n-         Last := 0;\n+         Offset : Natural;\n+         --  GNAT.Heap_Sort assumes that the first array index is 1. Offset\n+         --  defines the translation to operate.\n \n-         --  For each subset in S, extract the new subsets we have by\n-         --  adding C in the position selection.\n+         function Lt (L, R : Natural) return Boolean;\n+         procedure Move (From : Natural; To : Natural);\n+         --  Subprograms needed by GNAT.Heap_Sort_A\n \n-         for J in S'Range loop\n-            declare\n-               Offset : Natural;\n-               --  GNAT.Heap_Sort assumes that the first array index\n-               --  is 1. Offset defines the translation to operate.\n-\n-               procedure Move (From : Natural; To : Natural);\n-               function Lt (L, R : Natural) return Boolean;\n-               --  Subprograms needed by GNAT.Heap_Sort_A\n-\n-               ----------\n-               -- Move --\n-               ----------\n-\n-               procedure Move (From : Natural; To : Natural) is\n-                  Target, Source : Natural;\n-\n-               begin\n-                  if From = 0 then\n-                     Source := 0;\n-                     Target := Offset + To;\n-                  elsif To = 0 then\n-                     Source := Offset + From;\n-                     Target := 0;\n-                  else\n-                     Source := Offset + From;\n-                     Target := Offset + To;\n-                  end if;\n+         --------\n+         -- Lt --\n+         --------\n \n-                  WT.Table (Reduced (Target)) := WT.Table (Reduced (Source));\n-               end Move;\n-\n-               --------\n-               -- Lt --\n-               --------\n-\n-               function Lt (L, R : Natural) return Boolean is\n-                  C     : constant Natural := Pos;\n-                  Left  : Natural;\n-                  Right : Natural;\n-\n-               begin\n-                  if L = 0 then\n-                     Left  := 0;\n-                     Right := Offset + R;\n-                  elsif R = 0 then\n-                     Left  := Offset + L;\n-                     Right := 0;\n-                  else\n-                     Left  := Offset + L;\n-                     Right := Offset + R;\n-                  end if;\n+         function Lt (L, R : Natural) return Boolean is\n+            C     : constant Natural := Pos;\n+            Left  : Natural;\n+            Right : Natural;\n \n-                  return WT.Table (Reduced (Left))(C)\n-                       < WT.Table (Reduced (Right))(C);\n-               end Lt;\n+         begin\n+            if L = 0 then\n+               Left  := Reduced (0) - 1;\n+               Right := Offset + R;\n+            elsif R = 0 then\n+               Left  := Offset + L;\n+               Right := Reduced (0) - 1;\n+            else\n+               Left  := Offset + L;\n+               Right := Offset + R;\n+            end if;\n \n-            --  Start of processing for Build_Identical_Key_Sets\n+            return WT.Table (Left)(C) < WT.Table (Right)(C);\n+         end Lt;\n \n-            begin\n-               Offset := S (J).First - 1;\n+         ----------\n+         -- Move --\n+         ----------\n+\n+         procedure Move (From : Natural; To : Natural) is\n+            Target, Source : Natural;\n+\n+         begin\n+            if From = 0 then\n+               Source := Reduced (0) - 1;\n+               Target := Offset + To;\n+            elsif To = 0 then\n+               Source := Offset + From;\n+               Target := Reduced (0) - 1;\n+            else\n+               Source := Offset + From;\n+               Target := Offset + To;\n+            end if;\n+\n+            WT.Table (Target) := WT.Table (Source);\n+         end Move;\n+\n+         --  Start of processing for Build_Identical_Key_Sets\n+\n+      begin\n+         Last := 0;\n+\n+         --  For each subset in S, extract the new subsets we have by adding C\n+         --  in the position selection.\n+\n+         for J in S'Range loop\n+            if S (J).First = S (J).Last then\n+               F := S (J).First;\n+               L := S (J).Last;\n+               Last := Last + 1;\n+               Table (Last) := (F, L);\n+\n+            else\n+               Offset := Reduced (S (J).First) - 1;\n                Sort\n                  (S (J).Last - S (J).First + 1,\n                   Move'Unrestricted_Access,\n                   Lt'Unrestricted_Access);\n \n-               F := -1;\n-               L := -1;\n-               for N in S (J).First .. S (J).Last - 1 loop\n+               F := S (J).First;\n+               L := F;\n+               for N in S (J).First .. S (J).Last loop\n \n-                  --  Two contiguous words are identical\n+                  --  For the last item, close the last subset\n \n-                  if WT.Table (Reduced (N))(C) =\n-                     WT.Table (Reduced (N + 1))(C)\n-                  then\n-                     --  This is the first word of the subset\n+                  if N = S (J).Last then\n+                     Last := Last + 1;\n+                     Table (Last) := (F, N);\n \n-                     if F = -1 then\n-                        F := N;\n-                     end if;\n+                  --  Two contiguous words are identical when they have the\n+                  --  same Cth character.\n \n+                  elsif WT.Table (Reduced (N))(C) =\n+                        WT.Table (Reduced (N + 1))(C)\n+                  then\n                      L := N + 1;\n \n-                     --  This is the last word of the subset\n+                  --  Find a new subset of identical keys. Store the current\n+                  --  one and create a new subset.\n \n-                  elsif F /= -1 then\n+                  else\n                      Last := Last + 1;\n                      Table (Last) := (F, L);\n-                     F := -1;\n+                     F := N + 1;\n+                     L := F;\n                   end if;\n                end loop;\n-\n-               --  This is the last word of the subset and of the set\n-\n-               if F /= -1 then\n-                  Last := Last + 1;\n-                  Table (Last) := (F, L);\n-               end if;\n-            end;\n+            end if;\n          end loop;\n       end Build_Identical_Keys_Sets;\n \n       --------------------------\n-      -- Count_Identical_Keys --\n+      -- Count_Different_Keys --\n       --------------------------\n \n-      function Count_Identical_Keys\n-        (Table  : Vertex_Table_Type;\n-         Last   : Natural;\n-         Pos    : Natural)\n-         return   Natural\n+      function Count_Different_Keys\n+        (Table : Vertex_Table_Type;\n+         Last  : Natural;\n+         Pos   : Natural) return Natural\n       is\n          N : array (Character) of Natural;\n          C : Character;\n          T : Natural := 0;\n \n       begin\n          --  For each subset, count the number of words that are still\n-         --  identical when we include Sel_Position (Last_Sel_Pos) in\n-         --  the position selection. Only focus on this position as the\n-         --  other positions already produce identical keys.\n+         --  different when we include Pos in the position selection. Only\n+         --  focus on this position as the other positions already produce\n+         --  identical keys.\n \n          for S in 1 .. Last loop\n \n@@ -2139,112 +2136,181 @@ package body GNAT.Perfect_Hash_Generators is\n                N (C) := N (C) + 1;\n             end loop;\n \n-            --  Add to the total when there are two identical keys\n+            --  Update the number of different keys. Each character used\n+            --  denotes a different key.\n \n             for J in N'Range loop\n-               if N (J) > 1 then\n-                  T := T + N (J);\n+               if N (J) > 0 then\n+                  T := T + 1;\n                end if;\n             end loop;\n          end loop;\n \n          return T;\n-      end Count_Identical_Keys;\n+      end Count_Different_Keys;\n \n    --  Start of processing for Select_Char_Position\n \n    begin\n-      for C in Sel_Position'Range loop\n-         Sel_Position (C) := C;\n-      end loop;\n-\n-      --  Initialization of Words\n-\n-      WT.Set_Last (2 * NK - 1);\n+      --  Initialize the reduced words set\n \n+      WT.Set_Last (2 * NK);\n       for K in 0 .. NK - 1 loop\n-         WT.Table (Reduced (K) + 1) := WT.Table (Initial (K));\n+         WT.Table (Reduced (K)) := WT.Table (Initial (K));\n       end loop;\n \n       declare\n-         Collisions           : Natural;\n-         Min_Collisions       : Natural := NK;\n-         Old_Collisions       : Natural;\n-         Min_Coll_Sel_Pos     : Natural := 0; -- init to kill warning\n-         Min_Coll_Sel_Pos_Idx : Natural := 0; -- init to kill warning\n+         Differences          : Natural;\n+         Max_Differences      : Natural := 0;\n+         Old_Differences      : Natural;\n+         Max_Diff_Sel_Pos     : Natural := 0; -- init to kill warning\n+         Max_Diff_Sel_Pos_Idx : Natural := 0; -- init to kill warning\n          Same_Keys_Sets_Table : Vertex_Table_Type (1 .. NK);\n          Same_Keys_Sets_Last  : Natural := 1;\n \n       begin\n-         Same_Keys_Sets_Table (1) := (1, NK);\n+         for C in Sel_Position'Range loop\n+            Sel_Position (C) := C;\n+         end loop;\n+\n+         Same_Keys_Sets_Table (1) := (0, NK - 1);\n \n          loop\n-            --  Preserve minimum identical keys and check later on\n-            --  that this value is strictly decrementing. Otherwise,\n-            --  it means that two keys are stricly identical.\n+            --  Preserve maximum number of different keys and check later on\n+            --  that this value is strictly incrementing. Otherwise, it means\n+            --  that two keys are stricly identical.\n+\n+            Old_Differences := Max_Differences;\n \n-            Old_Collisions := Min_Collisions;\n+            --  The first position should not exceed the minimum key length.\n+            --  Otherwise, we may end up with an empty word once reduced.\n \n-            --  Find which position reduces the most of collisions\n+            if Last_Sel_Pos = 0 then\n+               Max_Sel_Pos := Min_Key_Len;\n+            else\n+               Max_Sel_Pos := Max_Key_Len;\n+            end if;\n \n-            for J in Last_Sel_Pos + 1 .. Sel_Position'Last loop\n-               Collisions := Count_Identical_Keys\n+            --  Find which position increases more the number of differences\n+\n+            for J in Last_Sel_Pos + 1 .. Max_Sel_Pos loop\n+               Differences := Count_Different_Keys\n                  (Same_Keys_Sets_Table,\n                   Same_Keys_Sets_Last,\n                   Sel_Position (J));\n \n-               if Collisions < Min_Collisions then\n-                  Min_Collisions       := Collisions;\n-                  Min_Coll_Sel_Pos     := Sel_Position (J);\n-                  Min_Coll_Sel_Pos_Idx := J;\n+               if Verbose then\n+                  Put (Output,\n+                       \"Selecting position\" & Sel_Position (J)'Img &\n+                         \" results in\" & Differences'Img &\n+                         \" differences\");\n+                  New_Line (Output);\n+               end if;\n+\n+               if Differences > Max_Differences then\n+                  Max_Differences      := Differences;\n+                  Max_Diff_Sel_Pos     := Sel_Position (J);\n+                  Max_Diff_Sel_Pos_Idx := J;\n                end if;\n             end loop;\n \n-            if Old_Collisions = Min_Collisions then\n+            if Old_Differences = Max_Differences then\n                Raise_Exception\n                  (Program_Error'Identity, \"some keys are identical\");\n             end if;\n \n             --  Insert selected position and sort Sel_Position table\n \n             Last_Sel_Pos := Last_Sel_Pos + 1;\n-            Sel_Position (Last_Sel_Pos + 1 .. Min_Coll_Sel_Pos_Idx) :=\n-              Sel_Position (Last_Sel_Pos .. Min_Coll_Sel_Pos_Idx - 1);\n-            Sel_Position (Last_Sel_Pos) := Min_Coll_Sel_Pos;\n+            Sel_Position (Last_Sel_Pos + 1 .. Max_Diff_Sel_Pos_Idx) :=\n+              Sel_Position (Last_Sel_Pos .. Max_Diff_Sel_Pos_Idx - 1);\n+            Sel_Position (Last_Sel_Pos) := Max_Diff_Sel_Pos;\n \n             for P in 1 .. Last_Sel_Pos - 1 loop\n-               if Min_Coll_Sel_Pos < Sel_Position (P) then\n+               if Max_Diff_Sel_Pos < Sel_Position (P) then\n                   Sel_Position (P + 1 .. Last_Sel_Pos) :=\n                     Sel_Position (P .. Last_Sel_Pos - 1);\n-                  Sel_Position (P) := Min_Coll_Sel_Pos;\n+                  Sel_Position (P) := Max_Diff_Sel_Pos;\n                   exit;\n                end if;\n             end loop;\n \n-            exit when Min_Collisions = 0;\n+            exit when Max_Differences = NK;\n \n             Build_Identical_Keys_Sets\n               (Same_Keys_Sets_Table,\n                Same_Keys_Sets_Last,\n-               Min_Coll_Sel_Pos);\n+               Max_Diff_Sel_Pos);\n+\n+            if Verbose then\n+               Put (Output,\n+                    \"Selecting position\" & Max_Diff_Sel_Pos'Img &\n+                      \" results in\" & Max_Differences'Img &\n+                      \" differences\");\n+               New_Line (Output);\n+               Put (Output, \"--\");\n+               New_Line (Output);\n+               for J in 1 .. Same_Keys_Sets_Last loop\n+                  for K in\n+                    Same_Keys_Sets_Table (J).First ..\n+                    Same_Keys_Sets_Table (J).Last\n+                  loop\n+                     Put (Output, WT.Table (Reduced (K)));\n+                     New_Line (Output);\n+                  end loop;\n+                  Put (Output, \"--\");\n+                  New_Line (Output);\n+               end loop;\n+            end if;\n          end loop;\n       end;\n \n       Char_Pos_Set_Len := Last_Sel_Pos;\n-      Char_Pos_Set := Allocate (Char_Pos_Set_Len, Char_Pos_Size);\n+      Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n \n       for C in 1 .. Last_Sel_Pos loop\n          Set_Char_Pos (C - 1, Sel_Position (C));\n       end loop;\n    end Select_Char_Position;\n \n+   --------------------------\n+   -- Select_Character_Set --\n+   --------------------------\n+\n+   procedure Select_Character_Set\n+   is\n+      Last : Natural := 0;\n+      Used : array (Character) of Boolean := (others => False);\n+      Char : Character;\n+\n+   begin\n+      for J in 0 .. NK - 1 loop\n+         for K in 0 .. Char_Pos_Set_Len - 1 loop\n+            Char := WT.Table (Initial (J))(Get_Char_Pos (K));\n+            exit when Char = ASCII.NUL;\n+            Used (Char) := True;\n+         end loop;\n+      end loop;\n+\n+      Used_Char_Set_Len := 256;\n+      Used_Char_Set := Allocate (Used_Char_Set_Len);\n+\n+      for J in Used'Range loop\n+         if Used (J) then\n+            Set_Used_Char (J, Last);\n+            Last := Last + 1;\n+         else\n+            Set_Used_Char (J, 0);\n+         end if;\n+      end loop;\n+   end Select_Character_Set;\n+\n    ------------------\n    -- Set_Char_Pos --\n    ------------------\n \n    procedure Set_Char_Pos (P : Natural; Item : Natural) is\n       N : constant Natural := Char_Pos_Set + P;\n-\n    begin\n       IT.Table (N) := Item;\n    end Set_Char_Pos;\n@@ -2255,7 +2321,6 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Set_Edges (F : Natural; Item : Edge_Type) is\n       N : constant Natural := Edges + (F * Edge_Size);\n-\n    begin\n       IT.Table (N)     := Item.X;\n       IT.Table (N + 1) := Item.Y;\n@@ -2266,44 +2331,36 @@ package body GNAT.Perfect_Hash_Generators is\n    -- Set_Graph --\n    ---------------\n \n-   procedure Set_Graph (F : Natural; Item : Integer) is\n-      N : constant Natural := G + (F * Graph_Item_Size);\n-\n+   procedure Set_Graph (N : Natural; Item : Integer) is\n    begin\n-      IT.Table (N) := Item;\n+      IT.Table (G + N) := Item;\n    end Set_Graph;\n \n    -------------\n    -- Set_Key --\n    -------------\n \n-   procedure Set_Key (F : Key_Id; Item : Key_Type) is\n-      N : constant Natural := Keys + F * Key_Size;\n-\n+   procedure Set_Key (N : Key_Id; Item : Key_Type) is\n    begin\n-      IT.Table (N) := Item.Edge;\n+      IT.Table (Keys + N) := Item.Edge;\n    end Set_Key;\n \n-   ------------------\n-   -- Set_Rand_Tab --\n-   ------------------\n-\n-   procedure Set_Rand_Tab (T : Integer; X, Y : Natural; Item : Natural) is\n-      N : constant Natural :=\n-            T + ((Y * Rand_Tab_Len_1) + X) * Rand_Tab_Item_Size;\n+   ---------------\n+   -- Set_Table --\n+   ---------------\n \n+   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural) is\n+      N : constant Natural := T + ((Y * T1_Len) + X);\n    begin\n       IT.Table (N) := Item;\n-   end Set_Rand_Tab;\n+   end Set_Table;\n \n    -------------------\n    -- Set_Used_Char --\n    -------------------\n \n    procedure Set_Used_Char (C : Character; Item : Natural) is\n-      N : constant Natural :=\n-            Used_Char_Set + Character'Pos (C) * Used_Char_Size;\n-\n+      N : constant Natural := Used_Char_Set + Character'Pos (C);\n    begin\n       IT.Table (N) := Item;\n    end Set_Used_Char;\n@@ -2314,7 +2371,6 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Set_Vertices (F : Natural; Item : Vertex_Type) is\n       N : constant Natural := Vertices + (F * Vertex_Size);\n-\n    begin\n       IT.Table (N)     := Item.First;\n       IT.Table (N + 1) := Item.Last;\n@@ -2327,24 +2383,23 @@ package body GNAT.Perfect_Hash_Generators is\n    function Sum\n      (Word  : Word_Type;\n       Table : Table_Id;\n-      Opt   : Optimization)\n-      return  Natural\n+      Opt   : Optimization) return Natural\n    is\n       S : Natural := 0;\n       R : Natural;\n \n    begin\n       if Opt = CPU_Time then\n-         for J in 0 .. Rand_Tab_Len_1 - 1 loop\n+         for J in 0 .. T1_Len - 1 loop\n             exit when Word (J + 1) = ASCII.NUL;\n-            R := Get_Rand_Tab (Table, J, Get_Used_Char (Word (J + 1)));\n+            R := Get_Table (Table, J, Get_Used_Char (Word (J + 1)));\n             S := (S + R) mod NV;\n          end loop;\n \n       else\n-         for J in 0 .. Rand_Tab_Len_1 - 1 loop\n+         for J in 0 .. T1_Len - 1 loop\n             exit when Word (J + 1) = ASCII.NUL;\n-            R := Get_Rand_Tab (Table, J, 0);\n+            R := Get_Table (Table, J, 0);\n             S := (S + R * Character'Pos (Word (J + 1))) mod NV;\n          end loop;\n       end if;\n@@ -2373,9 +2428,8 @@ package body GNAT.Perfect_Hash_Generators is\n \n    function Value\n      (Name : Table_Name;\n-      J   : Natural;\n-      K    : Natural := 0)\n-      return Natural\n+      J    : Natural;\n+      K    : Natural := 0) return Natural\n    is\n    begin\n       case Name is\n@@ -2386,10 +2440,10 @@ package body GNAT.Perfect_Hash_Generators is\n             return Get_Used_Char (Character'Val (J));\n \n          when Function_Table_1 =>\n-            return Get_Rand_Tab (T1, J, K);\n+            return Get_Table (T1, J, K);\n \n          when  Function_Table_2 =>\n-            return Get_Rand_Tab (T2, J, K);\n+            return Get_Table (T2, J, K);\n \n          when Graph_Table =>\n             return Get_Graph (J);"}, {"sha": "5cff8c53dccc6f954f945556622fabc16842bf08", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f5a932436112de4e93366915c8dbc77a8f821ff/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f5a932436112de4e93366915c8dbc77a8f821ff/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=1f5a932436112de4e93366915c8dbc77a8f821ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2002-2004 Ada Core Technologies, Inc.           --\n+--            Copyright (C) 2002-2005 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,122 +31,133 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides a generator of static minimal perfect hash\n---  functions. To understand what a perfect hash function is, we\n---  define several notions. These definitions are inspired from the\n---  following paper:\n-\n---    Zbigniew J. Czech, George Havas, and Bohdan S. Majewski ``An\n---    Optimal Algorithm for Generating Minimal Perfect Hash Functions'',\n---    Information Processing Letters, 43(1992) pp.257-264, Oct.1992\n-\n---  Let W be a set of m words. A hash function h is a function that\n---  maps the set of words W into some given interval of integers\n---  [0, k-1], where k is an integer, usually k >= m. h (w) where w\n---  is a word computes an address or an integer from I for the\n---  storage or the retrieval of that item. The storage area used to\n---  store items is known as a hash table. Words for which the same\n---  address is computed are called synonyms. Due to the existence\n---  of synonyms a situation called collision may arise in which two\n---  items w1 and w2 have the same address. Several schemes for\n---  resolving known. A perfect hash function is an injection from\n---  the word set W to the integer interval I with k >= m. If k = m,\n---  then h is a minimal perfect hash function. A hash function is\n---  order preserving if it puts entries into the hash table in a\n---  prespecified order.\n+--  This package provides a generator of static minimal perfect hash functions.\n+--  To understand what a perfect hash function is, we define several notions.\n+--  These definitions are inspired from the following paper:\n+\n+--    Zbigniew J. Czech, George Havas, and Bohdan S. Majewski ``An Optimal\n+--    Algorithm for Generating Minimal Perfect Hash Functions'', Information\n+--    Processing Letters, 43(1992) pp.257-264, Oct.1992\n+\n+--  Let W be a set of m words. A hash function h is a function that maps the\n+--  set of words W into some given interval of integers [0, k-1], where k is an\n+--  integer, usually k >= m. h (w) where is a word computes an address or an\n+--  integer from I for the storage or the retrieval of that item. The storage\n+--  area used to store items is known as a hash table. Words for which the same\n+--  address is computed are called synonyms. Due to the existence of synonyms a\n+--  situation called collision may arise in which two items w1 and w2 have the\n+--  same address. Several schemes for resolving known. A perfect hash function\n+--  is an injection from the word set W to the integer interval I with k >= m.\n+--  If k = m, then h is a minimal perfect hash function. A hash function is\n+--  order preserving if it puts entries into the hash table in prespecified\n+--  order.\n \n --  A minimal perfect hash function is defined by two properties:\n \n---    Since no collisions occur each item can be retrieved from the\n---    table in *one* probe. This represents the \"perfect\" property.\n+--    Since no collisions occur each item can be retrieved from the table in\n+--    *one* probe. This represents the \"perfect\" property.\n \n---    The hash table size corresponds to the exact size of W and\n---    *no larger*. This represents the \"minimal\" property.\n+--    The hash table size corresponds to the exact size of W and *no larger*.\n+--    This represents the \"minimal\" property.\n \n---  The functions generated by this package require the key set to\n---  be known in advance (they are \"static\" hash functions).\n---  The hash functions are also order preservering. If w2 is inserted\n---  after w1 in the generator, then f (w1) < f (w2). These hashing\n---  functions are convenient for use with realtime applications.\n+--  The functions generated by this package require the key set to be known in\n+--  advance (they are \"static\" hash functions). The hash functions are also\n+--  order preservering. If w2 is inserted after w1 in the generator, then (w1)\n+--  < f (w2). These hashing functions are convenient for use with realtime\n+--  applications.\n \n package GNAT.Perfect_Hash_Generators is\n \n    Default_K_To_V : constant Float  := 2.05;\n-   --  Default ratio for the algorithm. When K is the number of keys,\n-   --  V = (K_To_V) * K is the size of the main table of the hash function.\n+   --  Default ratio for the algorithm. When K is the number of keys, V =\n+   --  (K_To_V) * K is the size of the main table of the hash function. To\n+   --  converge, the algorithm requires K_To_V to be stricly greater than 2.0.\n \n    Default_Pkg_Name : constant String := \"Perfect_Hash\";\n-   --  Default package name in which the hash function is defined.\n+   --  Default package name in which the hash function is defined\n \n    Default_Position : constant String := \"\";\n-   --  The generator allows selection of the character positions used\n-   --  in the hash function. By default, all positions are selected.\n+   --  The generator allows selection of the character positions used in the\n+   --  hash function. By default, all positions are selected.\n+\n+   Default_Tries : constant Positive := 20;\n+   --  This algorithm may not succeed to find a possible mapping on the first\n+   --  try and may have to iterate a number of times. This constant bounds the\n+   --  number of tries.\n \n    type Optimization is (Memory_Space, CPU_Time);\n    Default_Optimization : constant Optimization := CPU_Time;\n-   --  Optimize either the memory space or the execution time.\n+   --  Optimize either the memory space or the execution time\n \n    Verbose : Boolean := False;\n-   --  Comment required ???\n+   --  Output the status of the algorithm. For instance, the tables, the random\n+   --  graph (edges, vertices) and selected char positions are output between\n+   --  two iterations.\n \n    procedure Initialize\n      (Seed   : Natural;\n       K_To_V : Float        := Default_K_To_V;\n-      Optim  : Optimization := CPU_Time);\n-   --  Initialize the generator and its internal structures. Set the\n-   --  ratio of vertices over keys in the random graphs. This value\n-   --  has to be greater than 2.0 in order for the algorithm to succeed.\n+      Optim  : Optimization := CPU_Time;\n+      Tries  : Positive     := Default_Tries);\n+   --  Initialize the generator and its internal structures. Set the ratio of\n+   --  vertices over keys in the random graphs. This value has to be greater\n+   --  than 2.0 in order for the algorithm to succeed. The key set is not\n+   --  modified (in particular when it is already set). For instance, it is\n+   --  possible to run several times the generator with different settings on\n+   --  the same key set.\n \n    procedure Finalize;\n-   --  Deallocate the internal structures.\n+   --  Deallocate the internal structures and the key table\n \n    procedure Insert (Value : String);\n-   --  Insert a new key in the table.\n+   --  Insert a new key in the table\n+\n+   Too_Many_Tries : exception;\n+   --  Raised after Tries unsuccessfull runs\n \n    procedure Compute (Position : String := Default_Position);\n-   --  Compute the hash function. Position allows to define a\n-   --  selection of character positions used in the keywords hash\n-   --  function. Positions can be separated by commas and range like\n-   --  x-y may be used. Character '$' represents the final character\n-   --  of a key. With an empty position, the generator automatically\n-   --  produces positions to reduce the memory usage.\n+   --  Compute the hash function. Position allows to define selection of\n+   --  character positions used in the keywords hash function. Positions can be\n+   --  separated by commas and range like x-y may be used. Character '$'\n+   --  represents the final character of a key. With an empty position, the\n+   --  generator automatically produces positions to reduce the memory usage.\n+   --  Raise Too_Many_Tries in case that the algorithm does not succeed in less\n+   --  than Tries attempts (see Initialize).\n \n    procedure Produce (Pkg_Name  : String := Default_Pkg_Name);\n-   --  Generate the hash function package Pkg_Name. This package\n-   --  includes the minimal perfect Hash function.\n+   --  Generate the hash function package Pkg_Name. This package includes the\n+   --  minimal perfect Hash function.\n \n-   --  The routines and structures defined below allow producing the\n-   --  hash function using a different way from the procedure above.\n-   --  The procedure Define returns the lengths of an internal table\n-   --  and its item type size. The function Value returns the value of\n-   --  each item in the table.\n+   --  The routines and structures defined below allow producing the hash\n+   --  function using a different way from the procedure above. The procedure\n+   --  Define returns the lengths of an internal table and its item type size.\n+   --  The function Value returns the value of each item in the table.\n \n    --  The hash function has the following form:\n \n    --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n \n-   --  G is a function based on a graph table [0,n-1] -> [0,m-1]. m is\n-   --  the number of keys. n is an internally computed value and it\n-   --  can be obtained as the length of vector G.\n+   --  G is a function based on a graph table [0,n-1] -> [0,m-1]. m is the\n+   --  number of keys. n is an internally computed value and it can be obtained\n+   --  as the length of vector G.\n \n-   --  F1 and F2 are two functions based on two function tables T1 and\n-   --  T2. Their definition depends on the chosen optimization mode.\n+   --  F1 and F2 are two functions based on two function tables T1 and T2.\n+   --  Their definition depends on the chosen optimization mode.\n \n-   --  Only some character positions are used in the keys because they\n-   --  are significant. They are listed in a character position table\n-   --  (P in the pseudo-code below). For instance, in {\"jan\", \"feb\",\n-   --  \"mar\", \"apr\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"},\n-   --  only positions 2 and 3 are significant (the first character can\n-   --  be ignored). In this example, P = {2, 3}\n+   --  Only some character positions are used in the keys because they are\n+   --  significant. They are listed in a character position table (P in the\n+   --  pseudo-code below). For instance, in {\"jan\", \"feb\", \"mar\", \"apr\", \"jun\",\n+   --  \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"}, only positions 2 and 3 are\n+   --  significant (the first character can be ignored). In this example, P =\n+   --  {2, 3}\n \n    --  When Optimization is CPU_Time, the first dimension of T1 and T2\n-   --  corresponds to the character position in the key and the second\n-   --  to the character set. As all the character set is not used, we\n-   --  define a used character table which associates a distinct index\n-   --  to each used character (unused characters are mapped to\n-   --  zero). In this case, the second dimension of T1 and T2 is\n-   --  reduced to the used character set (C in the pseudo-code\n-   --  below). Therefore, the hash function has the following:\n+   --  corresponds to the character position in the key and the second to the\n+   --  character set. As all the character set is not used, we define a used\n+   --  character table which associates a distinct index to each used character\n+   --  (unused characters are mapped to zero). In this case, the second\n+   --  dimension of T1 and T2 is reduced to the used character set (C in the\n+   --  pseudo-code below). Therefore, the hash function has the following:\n \n    --    function Hash (S : String) return Natural is\n    --       F      : constant Natural := S'First - 1;\n@@ -165,11 +176,11 @@ package GNAT.Perfect_Hash_Generators is\n    --       return (Natural (G (F1)) + Natural (G (F2))) mod <m>;\n    --    end Hash;\n \n-   --  When Optimization is Memory_Space, the first dimension of T1\n-   --  and T2 corresponds to the character position in the key and the\n-   --  second dimension is ignored. T1 and T2 are no longer matrices\n-   --  but vectors. Therefore, the used character table is not\n-   --  available. The hash function has the following form:\n+   --  When Optimization is Memory_Space, the first dimension of T1 and T2\n+   --  corresponds to the character position in the key and the second\n+   --  dimension is ignored. T1 and T2 are no longer matrices but vectors.\n+   --  Therefore, the used character table is not available. The hash function\n+   --  has the following form:\n \n    --     function Hash (S : String) return Natural is\n    --        F      : constant Natural := S'First - 1;\n@@ -200,17 +211,16 @@ package GNAT.Perfect_Hash_Generators is\n       Item_Size : out Natural;\n       Length_1  : out Natural;\n       Length_2  : out Natural);\n-   --  Return the definition of the table Name. This includes the\n-   --  length of dimensions 1 and 2 and the size of an unsigned\n-   --  integer item. When Length_2 is zero, the table has only one\n-   --  dimension. All the ranges start from zero.\n+   --  Return the definition of the table Name. This includes the length of\n+   --  dimensions 1 and 2 and the size of an unsigned integer item. When\n+   --  Length_2 is zero, the table has only one dimension. All the ranges start\n+   --  from zero.\n \n    function Value\n      (Name : Table_Name;\n       J    : Natural;\n-      K    : Natural := 0)\n-      return Natural;\n-   --  Return the value of the component (I, J) of the table\n-   --  Name. When the table has only one dimension, J is ignored.\n+      K    : Natural := 0) return Natural;\n+   --  Return the value of the component (I, J) of the table Name. When the\n+   --  table has only one dimension, J is ignored.\n \n end GNAT.Perfect_Hash_Generators;"}]}