{"sha": "947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3MTMxYmE0ZTM1MWUyNjRmM2FhM2E3Y2NkNmIwYzgyYmNjN2ViZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-04T22:13:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-04T22:13:09Z"}, "message": "optabs.h (optab_handler, [...]): Turn into inline functions that return an insn code.\n\ngcc/\n\t* optabs.h (optab_handler, convert_optab_handler): Turn into\n\tinline functions that return an insn code.\n\t(set_optab_handler, set_convert_optab_handler): New functions.\n\t* builtins.c: Replace optab_handler(X)->insn_code with\n\toptab_handler or set_optab_handler thoughout.  Likewise\n\tconvert_optab_handler(X)->insn_code with convert_optab_handler\n\tand set_convert_optab_handler.\n\t* expmed.c, expr.c, genopinit.c, ifcvt.c, optabs.c, reload.c,\n\treload1.c, stmt.c, targhooks.c, tree-ssa-loop-prefetch.c,\n\ttree-ssa-math-opts.c, tree-vect-data-refs.c, tree-vect-generic.c,\n\ttree-vect-loop.c, tree-vect-patterns.c, tree-vect-slp.c,\n\ttree-vect-stmts.c, config/m32c/m32c.c, config/rs6000/rs6000.c,\n\tconfig/spu/spu.c: Likewise.\n\nFrom-SVN: r161808", "tree": {"sha": "c58b0fad8bf6ca1d17ba2102d04c971975a84d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58b0fad8bf6ca1d17ba2102d04c971975a84d81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47e5ff44ccdcf7c7936ad91d07b78cbf64d430d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e5ff44ccdcf7c7936ad91d07b78cbf64d430d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e5ff44ccdcf7c7936ad91d07b78cbf64d430d1"}], "stats": {"total": 892, "additions": 459, "deletions": 433}, "files": [{"sha": "3ada08b38ea4546eea6af58f300f47ce73864de9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1,3 +1,19 @@\n+2010-07-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* optabs.h (optab_handler, convert_optab_handler): Turn into\n+\tinline functions that return an insn code.\n+\t(set_optab_handler, set_convert_optab_handler): New functions.\n+\t* builtins.c: Replace optab_handler(X)->insn_code with\n+\toptab_handler or set_optab_handler thoughout.  Likewise\n+\tconvert_optab_handler(X)->insn_code with convert_optab_handler\n+\tand set_convert_optab_handler.\n+\t* expmed.c, expr.c, genopinit.c, ifcvt.c, optabs.c, reload.c,\n+\treload1.c, stmt.c, targhooks.c, tree-ssa-loop-prefetch.c,\n+\ttree-ssa-math-opts.c, tree-vect-data-refs.c, tree-vect-generic.c,\n+\ttree-vect-loop.c, tree-vect-patterns.c, tree-vect-slp.c,\n+\ttree-vect-stmts.c, config/m32c/m32c.c, config/rs6000/rs6000.c,\n+\tconfig/spu/spu.c: Likewise.\n+\n 2010-07-04  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/44531"}, {"sha": "46cc03d8069e11063aaacd1ecb0f5876147e57b7", "filename": "gcc/builtins.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1994,7 +1994,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n     errno_set = false;\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (optab_handler (builtin_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode) != CODE_FOR_nothing)\n     {\n       target = gen_reg_rtx (mode);\n \n@@ -2096,7 +2096,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   mode = TYPE_MODE (TREE_TYPE (exp));\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (optab_handler (builtin_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n     return NULL_RTX;\n \n   target = gen_reg_rtx (mode);\n@@ -2173,7 +2173,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \n   /* Check if sincos insn is available, otherwise fallback\n      to sin or cos insn.  */\n-  if (optab_handler (builtin_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n       CASE_FLT_FN (BUILT_IN_SIN):\n@@ -2185,7 +2185,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n       }\n \n   /* Before working hard, check whether the instruction is available.  */\n-  if (optab_handler (builtin_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (builtin_optab, mode) != CODE_FOR_nothing)\n     {\n       target = gen_reg_rtx (mode);\n \n@@ -2282,7 +2282,7 @@ interclass_mathfn_icode (tree arg, tree fndecl)\n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n   if (builtin_optab)\n-    return optab_handler (builtin_optab, mode)->insn_code;\n+    return optab_handler (builtin_optab, mode);\n   return CODE_FOR_nothing;\n }\n \n@@ -2370,7 +2370,7 @@ expand_builtin_sincos (tree exp)\n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n   /* Check if sincos insn is available, otherwise emit the call.  */\n-  if (optab_handler (sincos_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (sincos_optab, mode) == CODE_FOR_nothing)\n     return NULL_RTX;\n \n   target1 = gen_reg_rtx (mode);\n@@ -2417,7 +2417,7 @@ expand_builtin_cexpi (tree exp, rtx target, rtx subtarget)\n   /* Try expanding via a sincos optab, fall back to emitting a libcall\n      to sincos or cexp.  We are sure we have sincos or cexp because cexpi\n      is only generated from sincos, cexp or if we have either of them.  */\n-  if (optab_handler (sincos_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (sincos_optab, mode) != CODE_FOR_nothing)\n     {\n       op1 = gen_reg_rtx (mode);\n       op2 = gen_reg_rtx (mode);\n@@ -3080,8 +3080,7 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t         smaller than pow (x, 1.5) if sqrt will not be expanded\n \t\t as a call.  */\n \t      || (n == 3\n-\t\t  && (optab_handler (sqrt_optab, mode)->insn_code\n-\t\t      != CODE_FOR_nothing))))\n+\t\t  && optab_handler (sqrt_optab, mode) != CODE_FOR_nothing)))\n \t{\n \t  tree call_expr = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 1,\n \t\t\t\t\t\t  narg0);\n@@ -3272,7 +3271,7 @@ expand_builtin_strlen (tree exp, rtx target,\n       /* Bail out if we can't compute strlen in the right mode.  */\n       while (insn_mode != VOIDmode)\n \t{\n-\t  icode = optab_handler (strlen_optab, insn_mode)->insn_code;\n+\t  icode = optab_handler (strlen_optab, insn_mode);\n \t  if (icode != CODE_FOR_nothing)\n \t    break;\n \n@@ -5308,7 +5307,7 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   /* Check if the back end provides an insn that handles signbit for the\n      argument's mode. */\n-  icode = signbit_optab->handlers [(int) fmode].insn_code;\n+  icode = optab_handler (signbit_optab, fmode);\n   if (icode != CODE_FOR_nothing)\n     {\n       rtx last = get_last_insn ();"}, {"sha": "d7a047a8b571367886a562b9a779b029b06880b1", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1789,9 +1789,9 @@ m32c_init_libfuncs (void)\n      the right modes are found. */\n   if (TARGET_A24)\n     {\n-      optab_handler (cstore_optab, QImode)->insn_code = CODE_FOR_cstoreqi4_24;\n-      optab_handler (cstore_optab, HImode)->insn_code = CODE_FOR_cstorehi4_24;\n-      optab_handler (cstore_optab, PSImode)->insn_code = CODE_FOR_cstorepsi4_24;\n+      set_optab_handler (cstore_optab, QImode, CODE_FOR_cstoreqi4_24);\n+      set_optab_handler (cstore_optab, HImode, CODE_FOR_cstorehi4_24);\n+      set_optab_handler (cstore_optab, PSImode, CODE_FOR_cstorepsi4_24);\n     }\n }\n "}, {"sha": "88544685e9ca3002d147784dd75d2c627b0c7153", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -3332,8 +3332,7 @@ rs6000_builtin_support_vector_misalignment (enum machine_mode mode,\n   if (TARGET_VSX)\n     {\n       /* Return if movmisalign pattern is not supported for this mode.  */\n-      if (optab_handler (movmisalign_optab, mode)->insn_code ==\n-          CODE_FOR_nothing)\n+      if (optab_handler (movmisalign_optab, mode) == CODE_FOR_nothing)\n         return false;\n \n       if (misalignment == -1)\n@@ -16355,7 +16354,7 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \tif (rev_code == UNKNOWN)\n \t  return NULL_RTX;\n \n-\tnor_code = optab_handler (one_cmpl_optab, (int)dmode)->insn_code;\n+\tnor_code = optab_handler (one_cmpl_optab, dmode);\n \tif (nor_code == CODE_FOR_nothing)\n \t  return NULL_RTX;\n \n@@ -16400,7 +16399,7 @@ rs6000_emit_vector_compare (enum rtx_code rcode,\n \t    gcc_unreachable ();\n \t  }\n \n-\tior_code = optab_handler (ior_optab, (int)dmode)->insn_code;\n+\tior_code = optab_handler (ior_optab, dmode);\n \tif (ior_code == CODE_FOR_nothing)\n \t  return NULL_RTX;\n \n@@ -25753,8 +25752,8 @@ rs6000_emit_madd (rtx dst, rtx m1, rtx m2, rtx a)\n     {\n       /* For the simple ops, use the generator function, rather than assuming\n \t that the RTL is standard.  */\n-      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n-      enum insn_code acode = optab_handler (add_optab, mode)->insn_code;\n+      enum insn_code mcode = optab_handler (smul_optab, mode);\n+      enum insn_code acode = optab_handler (add_optab, mode);\n       gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n       gen_2arg_fn_t gen_add = (gen_2arg_fn_t) GEN_FCN (acode);\n       rtx mreg = gen_reg_rtx (mode);\n@@ -25786,8 +25785,8 @@ rs6000_emit_msub (rtx dst, rtx m1, rtx m2, rtx a)\n     {\n       /* For the simple ops, use the generator function, rather than assuming\n \t that the RTL is standard.  */\n-      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n-      enum insn_code scode = optab_handler (add_optab, mode)->insn_code;\n+      enum insn_code mcode = optab_handler (smul_optab, mode);\n+      enum insn_code scode = optab_handler (add_optab, mode);\n       gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n       gen_2arg_fn_t gen_sub = (gen_2arg_fn_t) GEN_FCN (scode);\n       rtx mreg = gen_reg_rtx (mode);\n@@ -25822,8 +25821,8 @@ rs6000_emit_nmsub (rtx dst, rtx m1, rtx m2, rtx a)\n     {\n       /* For the simple ops, use the generator function, rather than assuming\n \t that the RTL is standard.  */\n-      enum insn_code mcode = optab_handler (smul_optab, mode)->insn_code;\n-      enum insn_code scode = optab_handler (sub_optab, mode)->insn_code;\n+      enum insn_code mcode = optab_handler (smul_optab, mode);\n+      enum insn_code scode = optab_handler (sub_optab, mode);\n       gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (mcode);\n       gen_2arg_fn_t gen_sub = (gen_2arg_fn_t) GEN_FCN (scode);\n       rtx mreg = gen_reg_rtx (mode);\n@@ -25857,7 +25856,7 @@ rs6000_emit_swdiv_high_precision (rtx dst, rtx n, rtx d)\n {\n   enum machine_mode mode = GET_MODE (dst);\n   rtx x0, e0, e1, y1, u0, v0;\n-  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  enum insn_code code = optab_handler (smul_optab, mode);\n   gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n   rtx one = rs6000_load_constant_and_splat (mode, dconst1);\n \n@@ -25895,7 +25894,7 @@ rs6000_emit_swdiv_low_precision (rtx dst, rtx n, rtx d)\n {\n   enum machine_mode mode = GET_MODE (dst);\n   rtx x0, e0, e1, e2, y1, y2, y3, u0, v0, one;\n-  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  enum insn_code code = optab_handler (smul_optab, mode);\n   gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n \n   gcc_assert (code != CODE_FOR_nothing);\n@@ -25966,7 +25965,7 @@ rs6000_emit_swrsqrt (rtx dst, rtx src)\n   REAL_VALUE_TYPE dconst3_2;\n   int i;\n   rtx halfthree;\n-  enum insn_code code = optab_handler (smul_optab, mode)->insn_code;\n+  enum insn_code code = optab_handler (smul_optab, mode);\n   gen_2arg_fn_t gen_mul = (gen_2arg_fn_t) GEN_FCN (code);\n \n   gcc_assert (code != CODE_FOR_nothing);"}, {"sha": "87e9c420a2db76ba2e3cc4889a8dcc833d2306d2", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1139,7 +1139,7 @@ spu_emit_branch_or_set (int is_set, rtx cmp, rtx operands[])\n           if (eq_rtx == 0)\n \t    abort ();\n           emit_insn (eq_rtx);\n-          ior_code = ior_optab->handlers[(int)comp_mode].insn_code;\n+          ior_code = optab_handler (ior_optab, comp_mode);\n           gcc_assert (ior_code != CODE_FOR_nothing);\n           emit_insn (GEN_FCN (ior_code)\n \t\t     (compare_result, compare_result, eq_result));\n@@ -4588,7 +4588,8 @@ spu_expand_mov (rtx * ops, enum machine_mode mode)\n \n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (imode))\n \t{\n-\t  enum insn_code icode = convert_optab_handler (trunc_optab, mode, imode)->insn_code;\n+\t  enum insn_code icode = convert_optab_handler (trunc_optab,\n+\t\t\t\t\t\t\tmode, imode);\n \t  emit_insn (GEN_FCN (icode) (ops[0], from));\n \t}\n       else\n@@ -6251,7 +6252,7 @@ spu_emit_vector_compare (enum rtx_code rcode,\n           {\n             enum insn_code nor_code;\n             rtx eq_rtx = spu_emit_vector_compare (EQ, op0, op1, dest_mode);\n-            nor_code = optab_handler (one_cmpl_optab, (int)dest_mode)->insn_code;\n+            nor_code = optab_handler (one_cmpl_optab, dest_mode);\n             gcc_assert (nor_code != CODE_FOR_nothing);\n             emit_insn (GEN_FCN (nor_code) (mask, eq_rtx));\n             if (dmode != dest_mode)\n@@ -6286,7 +6287,7 @@ spu_emit_vector_compare (enum rtx_code rcode,\n             c_rtx = spu_emit_vector_compare (new_code, op0, op1, dest_mode);\n             eq_rtx = spu_emit_vector_compare (EQ, op0, op1, dest_mode);\n \n-            ior_code = optab_handler (ior_optab, (int)dest_mode)->insn_code;\n+            ior_code = optab_handler (ior_optab, dest_mode);\n             gcc_assert (ior_code != CODE_FOR_nothing);\n             emit_insn (GEN_FCN (ior_code) (mask, c_rtx, eq_rtx));\n             if (dmode != dest_mode)"}, {"sha": "4bf86dd23d9ce78dbc20e5ca7f7069891af440ec", "filename": "gcc/expmed.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -419,15 +419,14 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n-      && (optab_handler (vec_set_optab, GET_MODE (op0))->insn_code\n-\t  != CODE_FOR_nothing)\n+      && optab_handler (vec_set_optab, GET_MODE (op0)) != CODE_FOR_nothing\n       && fieldmode == GET_MODE_INNER (GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n       && !(bitnum % GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) optab_handler (vec_set_optab, outermode)->insn_code;\n+      int icode = (int) optab_handler (vec_set_optab, outermode);\n       int pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = value;\n@@ -533,10 +532,9 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!MEM_P (op0)\n       && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (optab_handler (movstrict_optab, fieldmode)->insn_code\n-\t  != CODE_FOR_nothing))\n+      && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n-      int icode = optab_handler (movstrict_optab, fieldmode)->insn_code;\n+      int icode = optab_handler (movstrict_optab, fieldmode);\n       rtx insn;\n       rtx start = get_last_insn ();\n       rtx arg0 = op0;\n@@ -1253,14 +1251,13 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n-      && (optab_handler (vec_extract_optab, GET_MODE (op0))->insn_code\n-\t  != CODE_FOR_nothing)\n+      && optab_handler (vec_extract_optab, GET_MODE (op0)) != CODE_FOR_nothing\n       && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n \t  == bitnum / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) optab_handler (vec_extract_optab, outermode)->insn_code;\n+      int icode = (int) optab_handler (vec_extract_optab, outermode);\n       unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = op0;\n@@ -3567,7 +3564,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n-  if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n+  if (optab_handler (moptab, wider_mode) != CODE_FOR_nothing\n       && mul_widen_cost[speed][wider_mode] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n@@ -3577,7 +3574,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n     }\n \n   /* Try widening the mode and perform a non-widening multiplication.  */\n-  if (optab_handler (smul_optab, wider_mode)->insn_code != CODE_FOR_nothing\n+  if (optab_handler (smul_optab, wider_mode) != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n       && mul_cost[speed][wider_mode] + shift_cost[speed][mode][size-1] < max_cost)\n     {\n@@ -3604,7 +3601,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n-  if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n+  if (optab_handler (moptab, wider_mode) != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n       && (mul_widen_cost[speed][wider_mode] + 2 * shift_cost[speed][mode][size-1]\n \t  + 4 * add_cost[speed][mode] < max_cost))\n@@ -3726,7 +3723,7 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t     use a LSHIFTRT, 1 ADD, 1 SUB and an AND.  */\n \n \t  temp = gen_rtx_LSHIFTRT (mode, result, shift);\n-\t  if (optab_handler (lshr_optab, mode)->insn_code == CODE_FOR_nothing\n+\t  if (optab_handler (lshr_optab, mode) == CODE_FOR_nothing\n \t      || rtx_cost (temp, SET, optimize_insn_for_speed_p ()) > COSTS_N_INSNS (2))\n \t    {\n \t      temp = expand_binop (mode, xor_optab, op0, signmask,\n@@ -4030,8 +4027,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n        compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-    if (optab_handler (optab1, compute_mode)->insn_code != CODE_FOR_nothing\n-\t|| optab_handler (optab2, compute_mode)->insn_code != CODE_FOR_nothing)\n+    if (optab_handler (optab1, compute_mode) != CODE_FOR_nothing\n+\t|| optab_handler (optab2, compute_mode) != CODE_FOR_nothing)\n       break;\n \n   if (compute_mode == VOIDmode)\n@@ -4286,11 +4283,11 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    optab has an expander for this mode.  */\n \t\t\t && ((optab_handler ((rem_flag ? smod_optab\n \t\t\t\t\t      : sdiv_optab),\n-\t\t\t\t\t      compute_mode)->insn_code\n+\t\t\t\t\t     compute_mode)\n \t\t\t      != CODE_FOR_nothing)\n-\t\t\t     || (optab_handler(sdivmod_optab,\n-\t\t\t\t\t       compute_mode)\n-\t\t\t\t ->insn_code != CODE_FOR_nothing)))\n+\t\t\t     || (optab_handler (sdivmod_optab,\n+\t\t\t\t\t\tcompute_mode)\n+\t\t\t\t != CODE_FOR_nothing)))\n \t\t  ;\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n \t\t  {\n@@ -4302,9 +4299,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      }\n \n \t\t    if (sdiv_pow2_cheap[speed][compute_mode]\n-\t\t\t&& ((optab_handler (sdiv_optab, compute_mode)->insn_code\n+\t\t\t&& ((optab_handler (sdiv_optab, compute_mode)\n \t\t\t     != CODE_FOR_nothing)\n-\t\t\t    || (optab_handler (sdivmod_optab, compute_mode)->insn_code\n+\t\t\t    || (optab_handler (sdivmod_optab, compute_mode)\n \t\t\t\t!= CODE_FOR_nothing)))\n \t\t      quotient = expand_divmod (0, TRUNC_DIV_EXPR,\n \t\t\t\t\t\tcompute_mode, op0,\n@@ -4952,7 +4949,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n \t\t\t\t op0, op1, target,\n \t\t\t\t unsignedp,\n-\t\t\t\t ((optab_handler (optab2, compute_mode)->insn_code\n+\t\t\t\t ((optab_handler (optab2, compute_mode)\n \t\t\t\t   != CODE_FOR_nothing)\n \t\t\t\t  ? OPTAB_DIRECT : OPTAB_WIDEN));\n \t  if (remainder == 0)\n@@ -4980,7 +4977,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t= sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n \t\t\t     op0, op1, rem_flag ? NULL_RTX : target,\n \t\t\t     unsignedp,\n-\t\t\t     ((optab_handler (optab2, compute_mode)->insn_code\n+\t\t\t     ((optab_handler (optab2, compute_mode)\n \t\t\t       != CODE_FOR_nothing)\n \t\t\t      ? OPTAB_DIRECT : OPTAB_WIDEN));\n \n@@ -5479,7 +5476,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n        compare_mode = GET_MODE_WIDER_MODE (compare_mode))\n     {\n      enum machine_mode optab_mode = mclass == MODE_CC ? CCmode : compare_mode;\n-     icode = optab_handler (cstore_optab, optab_mode)->insn_code;\n+     icode = optab_handler (cstore_optab, optab_mode);\n      if (icode != CODE_FOR_nothing)\n \t{\n \t  do_pending_stack_adjust ();\n@@ -5674,7 +5671,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      as \"-(int)X >> 31\" is still cheaper than inverting \"(int)X == 0\".  */\n   rcode = reverse_condition (code);\n   if (can_compare_p (rcode, mode, ccp_store_flag)\n-      && ! (optab_handler (cstore_optab, mode)->insn_code == CODE_FOR_nothing\n+      && ! (optab_handler (cstore_optab, mode) == CODE_FOR_nothing\n \t    && code == NE\n \t    && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n \t    && op1 == const0_rtx))\n@@ -5773,9 +5770,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t that is compensated by the subsequent overflow when subtracting\n \t one / negating.  */\n \n-      if (optab_handler (abs_optab, mode)->insn_code != CODE_FOR_nothing)\n+      if (optab_handler (abs_optab, mode) != CODE_FOR_nothing)\n \ttem = expand_unop (mode, abs_optab, op0, subtarget, 1);\n-      else if (optab_handler (ffs_optab, mode)->insn_code != CODE_FOR_nothing)\n+      else if (optab_handler (ffs_optab, mode) != CODE_FOR_nothing)\n \ttem = expand_unop (mode, ffs_optab, op0, subtarget, 1);\n       else if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{"}, {"sha": "a21735d26701ebb456fd67b87a75dae615aae88b", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -434,7 +434,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n       /* Try converting directly if the insn is supported.  */\n \n-      code = convert_optab_handler (tab, to_mode, from_mode)->insn_code;\n+      code = convert_optab_handler (tab, to_mode, from_mode);\n       if (code != CODE_FOR_nothing)\n \t{\n \t  emit_unop_insn (code, to, from,\n@@ -468,12 +468,12 @@ convert_move (rtx to, rtx from, int unsignedp)\n       enum machine_mode full_mode\n \t= smallest_mode_for_size (GET_MODE_BITSIZE (to_mode), MODE_INT);\n \n-      gcc_assert (convert_optab_handler (trunc_optab, to_mode, full_mode)->insn_code\n+      gcc_assert (convert_optab_handler (trunc_optab, to_mode, full_mode)\n \t\t  != CODE_FOR_nothing);\n \n       if (full_mode != from_mode)\n \tfrom = convert_to_mode (full_mode, from, unsignedp);\n-      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, full_mode)->insn_code,\n+      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, full_mode),\n \t\t      to, from, UNKNOWN);\n       return;\n     }\n@@ -483,18 +483,19 @@ convert_move (rtx to, rtx from, int unsignedp)\n       enum machine_mode full_mode\n \t= smallest_mode_for_size (GET_MODE_BITSIZE (from_mode), MODE_INT);\n \n-      gcc_assert (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code\n+      gcc_assert (convert_optab_handler (sext_optab, full_mode, from_mode)\n \t\t  != CODE_FOR_nothing);\n \n       if (to_mode == full_mode)\n \t{\n-\t  emit_unop_insn (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code,\n+\t  emit_unop_insn (convert_optab_handler (sext_optab, full_mode,\n+\t\t\t\t\t\t from_mode),\n \t\t\t  to, from, UNKNOWN);\n \t  return;\n \t}\n \n       new_from = gen_reg_rtx (full_mode);\n-      emit_unop_insn (convert_optab_handler (sext_optab, full_mode, from_mode)->insn_code,\n+      emit_unop_insn (convert_optab_handler (sext_optab, full_mode, from_mode),\n \t\t      new_from, from, UNKNOWN);\n \n       /* else proceed to integer conversions below.  */\n@@ -695,9 +696,10 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n \n   /* Support special truncate insns for certain modes.  */\n-  if (convert_optab_handler (trunc_optab, to_mode, from_mode)->insn_code != CODE_FOR_nothing)\n+  if (convert_optab_handler (trunc_optab, to_mode,\n+\t\t\t     from_mode) != CODE_FOR_nothing)\n     {\n-      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, from_mode)->insn_code,\n+      emit_unop_insn (convert_optab_handler (trunc_optab, to_mode, from_mode),\n \t\t      to, from, UNKNOWN);\n       return;\n     }\n@@ -990,7 +992,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = optab_handler (mov_optab, mode)->insn_code;\n+      icode = optab_handler (mov_optab, mode);\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tmove_by_pieces_1 (GEN_FCN (icode), mode, &data);\n \n@@ -1071,7 +1073,7 @@ move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = optab_handler (mov_optab, mode)->insn_code;\n+      icode = optab_handler (mov_optab, mode);\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tn_insns += l / GET_MODE_SIZE (mode), l %= GET_MODE_SIZE (mode);\n \n@@ -2352,7 +2354,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t  if (mode == VOIDmode)\n \t    break;\n \n-\t  icode = optab_handler (mov_optab, mode)->insn_code;\n+\t  icode = optab_handler (mov_optab, mode);\n \t  if (icode != CODE_FOR_nothing\n \t      && align >= GET_MODE_ALIGNMENT (mode))\n \t    {\n@@ -2565,7 +2567,7 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n       if (mode == VOIDmode)\n \tbreak;\n \n-      icode = optab_handler (mov_optab, mode)->insn_code;\n+      icode = optab_handler (mov_optab, mode);\n       if (icode != CODE_FOR_nothing && align >= GET_MODE_ALIGNMENT (mode))\n \tstore_by_pieces_2 (GEN_FCN (icode), mode, data);\n \n@@ -3034,7 +3036,7 @@ emit_move_via_integer (enum machine_mode mode, rtx x, rtx y, bool force)\n     return NULL_RTX;\n \n   /* The target must support moves in this mode.  */\n-  code = optab_handler (mov_optab, imode)->insn_code;\n+  code = optab_handler (mov_optab, imode);\n   if (code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n@@ -3184,7 +3186,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \n   /* Move floating point as parts.  */\n   if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-      && optab_handler (mov_optab, GET_MODE_INNER (mode))->insn_code != CODE_FOR_nothing)\n+      && optab_handler (mov_optab, GET_MODE_INNER (mode)) != CODE_FOR_nothing)\n     try_int = false;\n   /* Not possible if the values are inherently not adjacent.  */\n   else if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n@@ -3235,7 +3237,7 @@ emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n   /* Assume all MODE_CC modes are equivalent; if we have movcc, use it.  */\n   if (mode != CCmode)\n     {\n-      enum insn_code code = optab_handler (mov_optab, CCmode)->insn_code;\n+      enum insn_code code = optab_handler (mov_optab, CCmode);\n       if (code != CODE_FOR_nothing)\n \t{\n \t  x = emit_move_change_mode (CCmode, mode, x, true);\n@@ -3375,7 +3377,7 @@ emit_move_insn_1 (rtx x, rtx y)\n \n   gcc_assert ((unsigned int) mode < (unsigned int) MAX_MACHINE_MODE);\n \n-  code = optab_handler (mov_optab, mode)->insn_code;\n+  code = optab_handler (mov_optab, mode);\n   if (code != CODE_FOR_nothing)\n     return emit_insn (GEN_FCN (code) (x, y));\n \n@@ -3627,7 +3629,7 @@ emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n   stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n   /* If there is push pattern, use it.  Otherwise try old way of throwing\n      MEM representing push operation to move expander.  */\n-  icode = optab_handler (push_optab, mode)->insn_code;\n+  icode = optab_handler (push_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       if (((pred = insn_data[(int) icode].operand[0].predicate)\n@@ -4363,7 +4365,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n        set_mem_attributes (mem, to, 0);\n        set_mem_addr_space (mem, as);\n \n-       icode = movmisalign_optab->handlers[mode].insn_code;\n+       icode = optab_handler (movmisalign_optab, mode);\n        gcc_assert (icode != CODE_FOR_nothing);\n \n        op_mode1 = insn_data[icode].operand[1].mode;\n@@ -4496,7 +4498,7 @@ bool\n emit_storent_insn (rtx to, rtx from)\n {\n   enum machine_mode mode = GET_MODE (to), imode;\n-  enum insn_code code = optab_handler (storent_optab, mode)->insn_code;\n+  enum insn_code code = optab_handler (storent_optab, mode);\n   rtx pattern;\n \n   if (code == CODE_FOR_nothing)\n@@ -5703,7 +5705,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  {\n \t    enum machine_mode mode = GET_MODE (target);\n \n-\t    icode = (int) optab_handler (vec_init_optab, mode)->insn_code;\n+\t    icode = (int) optab_handler (vec_init_optab, mode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n \t\tunsigned int i;\n@@ -7704,7 +7706,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  this_optab = usmul_widen_optab;\n \t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n-\t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t      if (optab_handler (this_optab, mode) != CODE_FOR_nothing)\n \t\t{\n \t\t  if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n \t\t    expand_operands (treeop0, treeop1, subtarget, &op0, &op1,\n@@ -7730,15 +7732,15 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n \t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n-\t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t      if (optab_handler (this_optab, mode) != CODE_FOR_nothing)\n \t\t{\n \t\t  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n \t\t\t\t   EXPAND_NORMAL);\n \t\t  temp = expand_widening_mult (mode, op0, op1, target,\n \t\t\t\t\t       unsignedp, this_optab);\n \t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n-\t      if (optab_handler (other_optab, mode)->insn_code != CODE_FOR_nothing\n+\t      if (optab_handler (other_optab, mode) != CODE_FOR_nothing\n \t\t  && innermode == word_mode)\n \t\t{\n \t\t  rtx htem, hipart;\n@@ -8727,7 +8729,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t|| modifier == EXPAND_STACK_PARM);\n \n \t    /* The vectorizer should have already checked the mode.  */\n-\t    icode = optab_handler (movmisalign_optab, mode)->insn_code;\n+\t    icode = optab_handler (movmisalign_optab, mode);\n \t    gcc_assert (icode != CODE_FOR_nothing);\n \n \t    /* We've already validated the memory, and we're creating a"}, {"sha": "1e422acf5113656e9dcb4a215c517321d9d44695", "filename": "gcc/genopinit.c", "status": "modified", "additions": 185, "deletions": 184, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -60,152 +60,152 @@ along with GCC; see the file COPYING3.  If not see\n    upper-case forms of the comparison, respectively.  */\n \n static const char * const optabs[] =\n-{ \"convert_optab_handler (sext_optab, $B, $A)->insn_code = CODE_FOR_$(extend$a$b2$)\",\n-  \"convert_optab_handler (zext_optab, $B, $A)->insn_code = CODE_FOR_$(zero_extend$a$b2$)\",\n-  \"convert_optab_handler (sfix_optab, $B, $A)->insn_code = CODE_FOR_$(fix$F$a$I$b2$)\",\n-  \"convert_optab_handler (ufix_optab, $B, $A)->insn_code = CODE_FOR_$(fixuns$F$a$b2$)\",\n-  \"convert_optab_handler (sfixtrunc_optab, $B, $A)->insn_code = CODE_FOR_$(fix_trunc$F$a$I$b2$)\",\n-  \"convert_optab_handler (ufixtrunc_optab, $B, $A)->insn_code = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n-  \"convert_optab_handler (sfloat_optab, $B, $A)->insn_code = CODE_FOR_$(float$I$a$F$b2$)\",\n-  \"convert_optab_handler (ufloat_optab, $B, $A)->insn_code = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n-  \"convert_optab_handler (trunc_optab, $B, $A)->insn_code = CODE_FOR_$(trunc$a$b2$)\",\n-  \"convert_optab_handler (fract_optab, $B, $A)->insn_code = CODE_FOR_$(fract$a$b2$)\",\n-  \"convert_optab_handler (fractuns_optab, $B, $A)->insn_code = CODE_FOR_$(fractuns$I$a$Q$b2$)\",\n-  \"convert_optab_handler (fractuns_optab, $B, $A)->insn_code = CODE_FOR_$(fractuns$Q$a$I$b2$)\",\n-  \"convert_optab_handler (satfract_optab, $B, $A)->insn_code = CODE_FOR_$(satfract$a$Q$b2$)\",\n-  \"convert_optab_handler (satfractuns_optab, $B, $A)->insn_code = CODE_FOR_$(satfractuns$I$a$Q$b2$)\",\n-  \"optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$P$a3$)\",\n-  \"optab_handler (addv_optab, $A)->insn_code =\\n\\\n-    optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$F$a3$)\",\n-  \"optab_handler (addv_optab, $A)->insn_code = CODE_FOR_$(addv$I$a3$)\",\n-  \"optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$Q$a3$)\",\n-  \"optab_handler (ssadd_optab, $A)->insn_code = CODE_FOR_$(ssadd$Q$a3$)\",\n-  \"optab_handler (usadd_optab, $A)->insn_code = CODE_FOR_$(usadd$Q$a3$)\",\n-  \"optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$P$a3$)\",\n-  \"optab_handler (subv_optab, $A)->insn_code =\\n\\\n-    optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$F$a3$)\",\n-  \"optab_handler (subv_optab, $A)->insn_code = CODE_FOR_$(subv$I$a3$)\",\n-  \"optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$Q$a3$)\",\n-  \"optab_handler (sssub_optab, $A)->insn_code = CODE_FOR_$(sssub$Q$a3$)\",\n-  \"optab_handler (ussub_optab, $A)->insn_code = CODE_FOR_$(ussub$Q$a3$)\",\n-  \"optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$Q$a3$)\",\n-  \"optab_handler (ssmul_optab, $A)->insn_code = CODE_FOR_$(ssmul$Q$a3$)\",\n-  \"optab_handler (usmul_optab, $A)->insn_code = CODE_FOR_$(usmul$Q$a3$)\",\n-  \"optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$P$a3$)\",\n-  \"optab_handler (smulv_optab, $A)->insn_code =\\n\\\n-    optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$F$a3$)\",\n-  \"optab_handler (smulv_optab, $A)->insn_code = CODE_FOR_$(mulv$I$a3$)\",\n-  \"optab_handler (umul_highpart_optab, $A)->insn_code = CODE_FOR_$(umul$a3_highpart$)\",\n-  \"optab_handler (smul_highpart_optab, $A)->insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n-  \"optab_handler (smul_widen_optab, $B)->insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n-  \"optab_handler (umul_widen_optab, $B)->insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n-  \"optab_handler (usmul_widen_optab, $B)->insn_code = CODE_FOR_$(usmul$a$b3$)$N\",\n-  \"optab_handler (smadd_widen_optab, $B)->insn_code = CODE_FOR_$(madd$a$b4$)$N\",\n-  \"optab_handler (umadd_widen_optab, $B)->insn_code = CODE_FOR_$(umadd$a$b4$)$N\",\n-  \"optab_handler (ssmadd_widen_optab, $B)->insn_code = CODE_FOR_$(ssmadd$a$b4$)$N\",\n-  \"optab_handler (usmadd_widen_optab, $B)->insn_code = CODE_FOR_$(usmadd$a$b4$)$N\",\n-  \"optab_handler (smsub_widen_optab, $B)->insn_code = CODE_FOR_$(msub$a$b4$)$N\",\n-  \"optab_handler (umsub_widen_optab, $B)->insn_code = CODE_FOR_$(umsub$a$b4$)$N\",\n-  \"optab_handler (ssmsub_widen_optab, $B)->insn_code = CODE_FOR_$(ssmsub$a$b4$)$N\",\n-  \"optab_handler (usmsub_widen_optab, $B)->insn_code = CODE_FOR_$(usmsub$a$b4$)$N\",\n-  \"optab_handler (sdiv_optab, $A)->insn_code = CODE_FOR_$(div$a3$)\",\n-  \"optab_handler (ssdiv_optab, $A)->insn_code = CODE_FOR_$(ssdiv$Q$a3$)\",\n-  \"optab_handler (sdivv_optab, $A)->insn_code = CODE_FOR_$(div$V$I$a3$)\",\n-  \"optab_handler (udiv_optab, $A)->insn_code = CODE_FOR_$(udiv$I$a3$)\",\n-  \"optab_handler (udiv_optab, $A)->insn_code = CODE_FOR_$(udiv$Q$a3$)\",\n-  \"optab_handler (usdiv_optab, $A)->insn_code = CODE_FOR_$(usdiv$Q$a3$)\",\n-  \"optab_handler (sdivmod_optab, $A)->insn_code = CODE_FOR_$(divmod$a4$)\",\n-  \"optab_handler (udivmod_optab, $A)->insn_code = CODE_FOR_$(udivmod$a4$)\",\n-  \"optab_handler (smod_optab, $A)->insn_code = CODE_FOR_$(mod$a3$)\",\n-  \"optab_handler (umod_optab, $A)->insn_code = CODE_FOR_$(umod$a3$)\",\n-  \"optab_handler (fmod_optab, $A)->insn_code = CODE_FOR_$(fmod$a3$)\",\n-  \"optab_handler (remainder_optab, $A)->insn_code = CODE_FOR_$(remainder$a3$)\",\n-  \"optab_handler (ftrunc_optab, $A)->insn_code = CODE_FOR_$(ftrunc$F$a2$)\",\n-  \"optab_handler (and_optab, $A)->insn_code = CODE_FOR_$(and$a3$)\",\n-  \"optab_handler (ior_optab, $A)->insn_code = CODE_FOR_$(ior$a3$)\",\n-  \"optab_handler (xor_optab, $A)->insn_code = CODE_FOR_$(xor$a3$)\",\n-  \"optab_handler (ashl_optab, $A)->insn_code = CODE_FOR_$(ashl$a3$)\",\n-  \"optab_handler (ssashl_optab, $A)->insn_code = CODE_FOR_$(ssashl$Q$a3$)\",\n-  \"optab_handler (usashl_optab, $A)->insn_code = CODE_FOR_$(usashl$Q$a3$)\",\n-  \"optab_handler (ashr_optab, $A)->insn_code = CODE_FOR_$(ashr$a3$)\",\n-  \"optab_handler (lshr_optab, $A)->insn_code = CODE_FOR_$(lshr$a3$)\",\n-  \"optab_handler (rotl_optab, $A)->insn_code = CODE_FOR_$(rotl$a3$)\",\n-  \"optab_handler (rotr_optab, $A)->insn_code = CODE_FOR_$(rotr$a3$)\",\n-  \"optab_handler (vashr_optab, $A)->insn_code = CODE_FOR_$(vashr$a3$)\",\n-  \"optab_handler (vlshr_optab, $A)->insn_code = CODE_FOR_$(vlshr$a3$)\",\n-  \"optab_handler (vashl_optab, $A)->insn_code = CODE_FOR_$(vashl$a3$)\",\n-  \"optab_handler (vrotl_optab, $A)->insn_code = CODE_FOR_$(vrotl$a3$)\",\n-  \"optab_handler (vrotr_optab, $A)->insn_code = CODE_FOR_$(vrotr$a3$)\",\n-  \"optab_handler (smin_optab, $A)->insn_code = CODE_FOR_$(smin$a3$)\",\n-  \"optab_handler (smax_optab, $A)->insn_code = CODE_FOR_$(smax$a3$)\",\n-  \"optab_handler (umin_optab, $A)->insn_code = CODE_FOR_$(umin$I$a3$)\",\n-  \"optab_handler (umax_optab, $A)->insn_code = CODE_FOR_$(umax$I$a3$)\",\n-  \"optab_handler (pow_optab, $A)->insn_code = CODE_FOR_$(pow$a3$)\",\n-  \"optab_handler (atan2_optab, $A)->insn_code = CODE_FOR_$(atan2$a3$)\",\n-  \"optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$P$a2$)\",\n-  \"optab_handler (negv_optab, $A)->insn_code =\\n\\\n-    optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$F$a2$)\",\n-  \"optab_handler (negv_optab, $A)->insn_code = CODE_FOR_$(negv$I$a2$)\",\n-  \"optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$Q$a2$)\",\n-  \"optab_handler (ssneg_optab, $A)->insn_code = CODE_FOR_$(ssneg$Q$a2$)\",\n-  \"optab_handler (usneg_optab, $A)->insn_code = CODE_FOR_$(usneg$Q$a2$)\",\n-  \"optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$P$a2$)\",\n-  \"optab_handler (absv_optab, $A)->insn_code =\\n\\\n-    optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$F$a2$)\",\n-  \"optab_handler (absv_optab, $A)->insn_code = CODE_FOR_$(absv$I$a2$)\",\n-  \"optab_handler (copysign_optab, $A)->insn_code = CODE_FOR_$(copysign$F$a3$)\",\n-  \"optab_handler (signbit_optab, $A)->insn_code = CODE_FOR_$(signbit$F$a2$)\",\n-  \"optab_handler (isinf_optab, $A)->insn_code = CODE_FOR_$(isinf$a2$)\",\n-  \"optab_handler (sqrt_optab, $A)->insn_code = CODE_FOR_$(sqrt$a2$)\",\n-  \"optab_handler (floor_optab, $A)->insn_code = CODE_FOR_$(floor$a2$)\",\n-  \"convert_optab_handler (lfloor_optab, $B, $A)->insn_code = CODE_FOR_$(lfloor$F$a$I$b2$)\",\n-  \"optab_handler (ceil_optab, $A)->insn_code = CODE_FOR_$(ceil$a2$)\",\n-  \"convert_optab_handler (lceil_optab, $B, $A)->insn_code = CODE_FOR_$(lceil$F$a$I$b2$)\",\n-  \"optab_handler (round_optab, $A)->insn_code = CODE_FOR_$(round$a2$)\",\n-  \"optab_handler (btrunc_optab, $A)->insn_code = CODE_FOR_$(btrunc$a2$)\",\n-  \"optab_handler (nearbyint_optab, $A)->insn_code = CODE_FOR_$(nearbyint$a2$)\",\n-  \"optab_handler (rint_optab, $A)->insn_code = CODE_FOR_$(rint$a2$)\",\n-  \"convert_optab_handler (lrint_optab, $B, $A)->insn_code = CODE_FOR_$(lrint$F$a$I$b2$)\",\n-  \"convert_optab_handler (lround_optab, $B, $A)->insn_code = CODE_FOR_$(lround$F$a$I$b2$)\",\n-  \"optab_handler (sincos_optab, $A)->insn_code = CODE_FOR_$(sincos$a3$)\",\n-  \"optab_handler (sin_optab, $A)->insn_code = CODE_FOR_$(sin$a2$)\",\n-  \"optab_handler (asin_optab, $A)->insn_code = CODE_FOR_$(asin$a2$)\",\n-  \"optab_handler (cos_optab, $A)->insn_code = CODE_FOR_$(cos$a2$)\",\n-  \"optab_handler (acos_optab, $A)->insn_code = CODE_FOR_$(acos$a2$)\",\n-  \"optab_handler (exp_optab, $A)->insn_code = CODE_FOR_$(exp$a2$)\",\n-  \"optab_handler (exp10_optab, $A)->insn_code = CODE_FOR_$(exp10$a2$)\",\n-  \"optab_handler (exp2_optab, $A)->insn_code = CODE_FOR_$(exp2$a2$)\",\n-  \"optab_handler (expm1_optab, $A)->insn_code = CODE_FOR_$(expm1$a2$)\",\n-  \"optab_handler (ldexp_optab, $A)->insn_code = CODE_FOR_$(ldexp$a3$)\",\n-  \"optab_handler (scalb_optab, $A)->insn_code = CODE_FOR_$(scalb$a3$)\",\n-  \"optab_handler (significand_optab, $A)->insn_code = CODE_FOR_$(significand$a2$)\",\n-  \"optab_handler (logb_optab, $A)->insn_code = CODE_FOR_$(logb$a2$)\",\n-  \"optab_handler (ilogb_optab, $A)->insn_code = CODE_FOR_$(ilogb$a2$)\",\n-  \"optab_handler (log_optab, $A)->insn_code = CODE_FOR_$(log$a2$)\",\n-  \"optab_handler (log10_optab, $A)->insn_code = CODE_FOR_$(log10$a2$)\",\n-  \"optab_handler (log2_optab, $A)->insn_code = CODE_FOR_$(log2$a2$)\",\n-  \"optab_handler (log1p_optab, $A)->insn_code = CODE_FOR_$(log1p$a2$)\",\n-  \"optab_handler (tan_optab, $A)->insn_code = CODE_FOR_$(tan$a2$)\",\n-  \"optab_handler (atan_optab, $A)->insn_code = CODE_FOR_$(atan$a2$)\",\n-  \"optab_handler (strlen_optab, $A)->insn_code = CODE_FOR_$(strlen$a$)\",\n-  \"optab_handler (one_cmpl_optab, $A)->insn_code = CODE_FOR_$(one_cmpl$a2$)\",\n-  \"optab_handler (bswap_optab, $A)->insn_code = CODE_FOR_$(bswap$a2$)\",\n-  \"optab_handler (ffs_optab, $A)->insn_code = CODE_FOR_$(ffs$a2$)\",\n-  \"optab_handler (clz_optab, $A)->insn_code = CODE_FOR_$(clz$a2$)\",\n-  \"optab_handler (ctz_optab, $A)->insn_code = CODE_FOR_$(ctz$a2$)\",\n-  \"optab_handler (popcount_optab, $A)->insn_code = CODE_FOR_$(popcount$a2$)\",\n-  \"optab_handler (parity_optab, $A)->insn_code = CODE_FOR_$(parity$a2$)\",\n-  \"optab_handler (mov_optab, $A)->insn_code = CODE_FOR_$(mov$a$)\",\n-  \"optab_handler (movstrict_optab, $A)->insn_code = CODE_FOR_$(movstrict$a$)\",\n-  \"optab_handler (movmisalign_optab, $A)->insn_code = CODE_FOR_$(movmisalign$a$)\",\n-  \"optab_handler (storent_optab, $A)->insn_code = CODE_FOR_$(storent$a$)\",\n-  \"optab_handler (addcc_optab, $A)->insn_code = CODE_FOR_$(add$acc$)\",\n+{ \"set_convert_optab_handler (sext_optab, $B, $A, CODE_FOR_$(extend$a$b2$))\",\n+  \"set_convert_optab_handler (zext_optab, $B, $A, CODE_FOR_$(zero_extend$a$b2$))\",\n+  \"set_convert_optab_handler (sfix_optab, $B, $A, CODE_FOR_$(fix$F$a$I$b2$))\",\n+  \"set_convert_optab_handler (ufix_optab, $B, $A, CODE_FOR_$(fixuns$F$a$b2$))\",\n+  \"set_convert_optab_handler (sfixtrunc_optab, $B, $A, CODE_FOR_$(fix_trunc$F$a$I$b2$))\",\n+  \"set_convert_optab_handler (ufixtrunc_optab, $B, $A, CODE_FOR_$(fixuns_trunc$F$a$I$b2$))\",\n+  \"set_convert_optab_handler (sfloat_optab, $B, $A, CODE_FOR_$(float$I$a$F$b2$))\",\n+  \"set_convert_optab_handler (ufloat_optab, $B, $A, CODE_FOR_$(floatuns$I$a$F$b2$))\",\n+  \"set_convert_optab_handler (trunc_optab, $B, $A, CODE_FOR_$(trunc$a$b2$))\",\n+  \"set_convert_optab_handler (fract_optab, $B, $A, CODE_FOR_$(fract$a$b2$))\",\n+  \"set_convert_optab_handler (fractuns_optab, $B, $A, CODE_FOR_$(fractuns$I$a$Q$b2$))\",\n+  \"set_convert_optab_handler (fractuns_optab, $B, $A, CODE_FOR_$(fractuns$Q$a$I$b2$))\",\n+  \"set_convert_optab_handler (satfract_optab, $B, $A, CODE_FOR_$(satfract$a$Q$b2$))\",\n+  \"set_convert_optab_handler (satfractuns_optab, $B, $A, CODE_FOR_$(satfractuns$I$a$Q$b2$))\",\n+  \"set_optab_handler (add_optab, $A, CODE_FOR_$(add$P$a3$))\",\n+  \"set_optab_handler (addv_optab, $A, CODE_FOR_$(add$F$a3$)),\\n\\\n+    set_optab_handler (add_optab, $A, CODE_FOR_$(add$F$a3$))\",\n+  \"set_optab_handler (addv_optab, $A, CODE_FOR_$(addv$I$a3$))\",\n+  \"set_optab_handler (add_optab, $A, CODE_FOR_$(add$Q$a3$))\",\n+  \"set_optab_handler (ssadd_optab, $A, CODE_FOR_$(ssadd$Q$a3$))\",\n+  \"set_optab_handler (usadd_optab, $A, CODE_FOR_$(usadd$Q$a3$))\",\n+  \"set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$P$a3$))\",\n+  \"set_optab_handler (subv_optab, $A, CODE_FOR_$(sub$F$a3$)),\\n\\\n+    set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$F$a3$))\",\n+  \"set_optab_handler (subv_optab, $A, CODE_FOR_$(subv$I$a3$))\",\n+  \"set_optab_handler (sub_optab, $A, CODE_FOR_$(sub$Q$a3$))\",\n+  \"set_optab_handler (sssub_optab, $A, CODE_FOR_$(sssub$Q$a3$))\",\n+  \"set_optab_handler (ussub_optab, $A, CODE_FOR_$(ussub$Q$a3$))\",\n+  \"set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$Q$a3$))\",\n+  \"set_optab_handler (ssmul_optab, $A, CODE_FOR_$(ssmul$Q$a3$))\",\n+  \"set_optab_handler (usmul_optab, $A, CODE_FOR_$(usmul$Q$a3$))\",\n+  \"set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$P$a3$))\",\n+  \"set_optab_handler (smulv_optab, $A, CODE_FOR_$(mul$F$a3$)),\\n\\\n+    set_optab_handler (smul_optab, $A, CODE_FOR_$(mul$F$a3$))\",\n+  \"set_optab_handler (smulv_optab, $A, CODE_FOR_$(mulv$I$a3$))\",\n+  \"set_optab_handler (umul_highpart_optab, $A, CODE_FOR_$(umul$a3_highpart$))\",\n+  \"set_optab_handler (smul_highpart_optab, $A, CODE_FOR_$(smul$a3_highpart$))\",\n+  \"set_optab_handler (smul_widen_optab, $B, CODE_FOR_$(mul$a$b3$)$N)\",\n+  \"set_optab_handler (umul_widen_optab, $B, CODE_FOR_$(umul$a$b3$)$N)\",\n+  \"set_optab_handler (usmul_widen_optab, $B, CODE_FOR_$(usmul$a$b3$)$N)\",\n+  \"set_optab_handler (smadd_widen_optab, $B, CODE_FOR_$(madd$a$b4$)$N)\",\n+  \"set_optab_handler (umadd_widen_optab, $B, CODE_FOR_$(umadd$a$b4$)$N)\",\n+  \"set_optab_handler (ssmadd_widen_optab, $B, CODE_FOR_$(ssmadd$a$b4$)$N)\",\n+  \"set_optab_handler (usmadd_widen_optab, $B, CODE_FOR_$(usmadd$a$b4$)$N)\",\n+  \"set_optab_handler (smsub_widen_optab, $B, CODE_FOR_$(msub$a$b4$)$N)\",\n+  \"set_optab_handler (umsub_widen_optab, $B, CODE_FOR_$(umsub$a$b4$)$N)\",\n+  \"set_optab_handler (ssmsub_widen_optab, $B, CODE_FOR_$(ssmsub$a$b4$)$N)\",\n+  \"set_optab_handler (usmsub_widen_optab, $B, CODE_FOR_$(usmsub$a$b4$)$N)\",\n+  \"set_optab_handler (sdiv_optab, $A, CODE_FOR_$(div$a3$))\",\n+  \"set_optab_handler (ssdiv_optab, $A, CODE_FOR_$(ssdiv$Q$a3$))\",\n+  \"set_optab_handler (sdivv_optab, $A, CODE_FOR_$(div$V$I$a3$))\",\n+  \"set_optab_handler (udiv_optab, $A, CODE_FOR_$(udiv$I$a3$))\",\n+  \"set_optab_handler (udiv_optab, $A, CODE_FOR_$(udiv$Q$a3$))\",\n+  \"set_optab_handler (usdiv_optab, $A, CODE_FOR_$(usdiv$Q$a3$))\",\n+  \"set_optab_handler (sdivmod_optab, $A, CODE_FOR_$(divmod$a4$))\",\n+  \"set_optab_handler (udivmod_optab, $A, CODE_FOR_$(udivmod$a4$))\",\n+  \"set_optab_handler (smod_optab, $A, CODE_FOR_$(mod$a3$))\",\n+  \"set_optab_handler (umod_optab, $A, CODE_FOR_$(umod$a3$))\",\n+  \"set_optab_handler (fmod_optab, $A, CODE_FOR_$(fmod$a3$))\",\n+  \"set_optab_handler (remainder_optab, $A, CODE_FOR_$(remainder$a3$))\",\n+  \"set_optab_handler (ftrunc_optab, $A, CODE_FOR_$(ftrunc$F$a2$))\",\n+  \"set_optab_handler (and_optab, $A, CODE_FOR_$(and$a3$))\",\n+  \"set_optab_handler (ior_optab, $A, CODE_FOR_$(ior$a3$))\",\n+  \"set_optab_handler (xor_optab, $A, CODE_FOR_$(xor$a3$))\",\n+  \"set_optab_handler (ashl_optab, $A, CODE_FOR_$(ashl$a3$))\",\n+  \"set_optab_handler (ssashl_optab, $A, CODE_FOR_$(ssashl$Q$a3$))\",\n+  \"set_optab_handler (usashl_optab, $A, CODE_FOR_$(usashl$Q$a3$))\",\n+  \"set_optab_handler (ashr_optab, $A, CODE_FOR_$(ashr$a3$))\",\n+  \"set_optab_handler (lshr_optab, $A, CODE_FOR_$(lshr$a3$))\",\n+  \"set_optab_handler (rotl_optab, $A, CODE_FOR_$(rotl$a3$))\",\n+  \"set_optab_handler (rotr_optab, $A, CODE_FOR_$(rotr$a3$))\",\n+  \"set_optab_handler (vashr_optab, $A, CODE_FOR_$(vashr$a3$))\",\n+  \"set_optab_handler (vlshr_optab, $A, CODE_FOR_$(vlshr$a3$))\",\n+  \"set_optab_handler (vashl_optab, $A, CODE_FOR_$(vashl$a3$))\",\n+  \"set_optab_handler (vrotl_optab, $A, CODE_FOR_$(vrotl$a3$))\",\n+  \"set_optab_handler (vrotr_optab, $A, CODE_FOR_$(vrotr$a3$))\",\n+  \"set_optab_handler (smin_optab, $A, CODE_FOR_$(smin$a3$))\",\n+  \"set_optab_handler (smax_optab, $A, CODE_FOR_$(smax$a3$))\",\n+  \"set_optab_handler (umin_optab, $A, CODE_FOR_$(umin$I$a3$))\",\n+  \"set_optab_handler (umax_optab, $A, CODE_FOR_$(umax$I$a3$))\",\n+  \"set_optab_handler (pow_optab, $A, CODE_FOR_$(pow$a3$))\",\n+  \"set_optab_handler (atan2_optab, $A, CODE_FOR_$(atan2$a3$))\",\n+  \"set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$P$a2$))\",\n+  \"set_optab_handler (negv_optab, $A, CODE_FOR_$(neg$F$a2$)),\\n\\\n+    set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$F$a2$))\",\n+  \"set_optab_handler (negv_optab, $A, CODE_FOR_$(negv$I$a2$))\",\n+  \"set_optab_handler (neg_optab, $A, CODE_FOR_$(neg$Q$a2$))\",\n+  \"set_optab_handler (ssneg_optab, $A, CODE_FOR_$(ssneg$Q$a2$))\",\n+  \"set_optab_handler (usneg_optab, $A, CODE_FOR_$(usneg$Q$a2$))\",\n+  \"set_optab_handler (abs_optab, $A, CODE_FOR_$(abs$P$a2$))\",\n+  \"set_optab_handler (absv_optab, $A, CODE_FOR_$(abs$F$a2$)),\\n\\\n+    set_optab_handler (abs_optab, $A, CODE_FOR_$(abs$F$a2$))\",\n+  \"set_optab_handler (absv_optab, $A, CODE_FOR_$(absv$I$a2$))\",\n+  \"set_optab_handler (copysign_optab, $A, CODE_FOR_$(copysign$F$a3$))\",\n+  \"set_optab_handler (signbit_optab, $A, CODE_FOR_$(signbit$F$a2$))\",\n+  \"set_optab_handler (isinf_optab, $A, CODE_FOR_$(isinf$a2$))\",\n+  \"set_optab_handler (sqrt_optab, $A, CODE_FOR_$(sqrt$a2$))\",\n+  \"set_optab_handler (floor_optab, $A, CODE_FOR_$(floor$a2$))\",\n+  \"set_convert_optab_handler (lfloor_optab, $B, $A, CODE_FOR_$(lfloor$F$a$I$b2$))\",\n+  \"set_optab_handler (ceil_optab, $A, CODE_FOR_$(ceil$a2$))\",\n+  \"set_convert_optab_handler (lceil_optab, $B, $A, CODE_FOR_$(lceil$F$a$I$b2$))\",\n+  \"set_optab_handler (round_optab, $A, CODE_FOR_$(round$a2$))\",\n+  \"set_optab_handler (btrunc_optab, $A, CODE_FOR_$(btrunc$a2$))\",\n+  \"set_optab_handler (nearbyint_optab, $A, CODE_FOR_$(nearbyint$a2$))\",\n+  \"set_optab_handler (rint_optab, $A, CODE_FOR_$(rint$a2$))\",\n+  \"set_convert_optab_handler (lrint_optab, $B, $A, CODE_FOR_$(lrint$F$a$I$b2$))\",\n+  \"set_convert_optab_handler (lround_optab, $B, $A, CODE_FOR_$(lround$F$a$I$b2$))\",\n+  \"set_optab_handler (sincos_optab, $A, CODE_FOR_$(sincos$a3$))\",\n+  \"set_optab_handler (sin_optab, $A, CODE_FOR_$(sin$a2$))\",\n+  \"set_optab_handler (asin_optab, $A, CODE_FOR_$(asin$a2$))\",\n+  \"set_optab_handler (cos_optab, $A, CODE_FOR_$(cos$a2$))\",\n+  \"set_optab_handler (acos_optab, $A, CODE_FOR_$(acos$a2$))\",\n+  \"set_optab_handler (exp_optab, $A, CODE_FOR_$(exp$a2$))\",\n+  \"set_optab_handler (exp10_optab, $A, CODE_FOR_$(exp10$a2$))\",\n+  \"set_optab_handler (exp2_optab, $A, CODE_FOR_$(exp2$a2$))\",\n+  \"set_optab_handler (expm1_optab, $A, CODE_FOR_$(expm1$a2$))\",\n+  \"set_optab_handler (ldexp_optab, $A, CODE_FOR_$(ldexp$a3$))\",\n+  \"set_optab_handler (scalb_optab, $A, CODE_FOR_$(scalb$a3$))\",\n+  \"set_optab_handler (significand_optab, $A, CODE_FOR_$(significand$a2$))\",\n+  \"set_optab_handler (logb_optab, $A, CODE_FOR_$(logb$a2$))\",\n+  \"set_optab_handler (ilogb_optab, $A, CODE_FOR_$(ilogb$a2$))\",\n+  \"set_optab_handler (log_optab, $A, CODE_FOR_$(log$a2$))\",\n+  \"set_optab_handler (log10_optab, $A, CODE_FOR_$(log10$a2$))\",\n+  \"set_optab_handler (log2_optab, $A, CODE_FOR_$(log2$a2$))\",\n+  \"set_optab_handler (log1p_optab, $A, CODE_FOR_$(log1p$a2$))\",\n+  \"set_optab_handler (tan_optab, $A, CODE_FOR_$(tan$a2$))\",\n+  \"set_optab_handler (atan_optab, $A, CODE_FOR_$(atan$a2$))\",\n+  \"set_optab_handler (strlen_optab, $A, CODE_FOR_$(strlen$a$))\",\n+  \"set_optab_handler (one_cmpl_optab, $A, CODE_FOR_$(one_cmpl$a2$))\",\n+  \"set_optab_handler (bswap_optab, $A, CODE_FOR_$(bswap$a2$))\",\n+  \"set_optab_handler (ffs_optab, $A, CODE_FOR_$(ffs$a2$))\",\n+  \"set_optab_handler (clz_optab, $A, CODE_FOR_$(clz$a2$))\",\n+  \"set_optab_handler (ctz_optab, $A, CODE_FOR_$(ctz$a2$))\",\n+  \"set_optab_handler (popcount_optab, $A, CODE_FOR_$(popcount$a2$))\",\n+  \"set_optab_handler (parity_optab, $A, CODE_FOR_$(parity$a2$))\",\n+  \"set_optab_handler (mov_optab, $A, CODE_FOR_$(mov$a$))\",\n+  \"set_optab_handler (movstrict_optab, $A, CODE_FOR_$(movstrict$a$))\",\n+  \"set_optab_handler (movmisalign_optab, $A, CODE_FOR_$(movmisalign$a$))\",\n+  \"set_optab_handler (storent_optab, $A, CODE_FOR_$(storent$a$))\",\n+  \"set_optab_handler (addcc_optab, $A, CODE_FOR_$(add$acc$))\",\n   \"movcc_gen_code[$A] = CODE_FOR_$(mov$acc$)\",\n-  \"optab_handler (cbranch_optab, $A)->insn_code = CODE_FOR_$(cbranch$a4$)\",\n-  \"optab_handler (cmov_optab, $A)->insn_code = CODE_FOR_$(cmov$a6$)\",\n-  \"optab_handler (cstore_optab, $A)->insn_code = CODE_FOR_$(cstore$a4$)\",\n-  \"optab_handler (ctrap_optab, $A)->insn_code = CODE_FOR_$(ctrap$a4$)\",\n-  \"optab_handler (push_optab, $A)->insn_code = CODE_FOR_$(push$a1$)\",\n+  \"set_optab_handler (cbranch_optab, $A, CODE_FOR_$(cbranch$a4$))\",\n+  \"set_optab_handler (cmov_optab, $A, CODE_FOR_$(cmov$a6$))\",\n+  \"set_optab_handler (cstore_optab, $A, CODE_FOR_$(cstore$a4$))\",\n+  \"set_optab_handler (ctrap_optab, $A, CODE_FOR_$(ctrap$a4$))\",\n+  \"set_optab_handler (push_optab, $A, CODE_FOR_$(push$a1$))\",\n   \"reload_in_optab[$A] = CODE_FOR_$(reload_in$a$)\",\n   \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n   \"movmem_optab[$A] = CODE_FOR_$(movmem$a$)\",\n@@ -234,45 +234,45 @@ static const char * const optabs[] =\n   \"sync_compare_and_swap[$A] = CODE_FOR_$(sync_compare_and_swap$I$a$)\",\n   \"sync_lock_test_and_set[$A] = CODE_FOR_$(sync_lock_test_and_set$I$a$)\",\n   \"sync_lock_release[$A] = CODE_FOR_$(sync_lock_release$I$a$)\",\n-  \"optab_handler (vec_set_optab, $A)->insn_code = CODE_FOR_$(vec_set$a$)\",\n-  \"optab_handler (vec_extract_optab, $A)->insn_code = CODE_FOR_$(vec_extract$a$)\",\n-  \"optab_handler (vec_extract_even_optab, $A)->insn_code = CODE_FOR_$(vec_extract_even$a$)\",\n-  \"optab_handler (vec_extract_odd_optab, $A)->insn_code = CODE_FOR_$(vec_extract_odd$a$)\",\n-  \"optab_handler (vec_interleave_high_optab, $A)->insn_code = CODE_FOR_$(vec_interleave_high$a$)\",\n-  \"optab_handler (vec_interleave_low_optab, $A)->insn_code = CODE_FOR_$(vec_interleave_low$a$)\",\n-  \"optab_handler (vec_init_optab, $A)->insn_code = CODE_FOR_$(vec_init$a$)\",\n-  \"optab_handler (vec_shl_optab, $A)->insn_code = CODE_FOR_$(vec_shl_$a$)\",\n-  \"optab_handler (vec_shr_optab, $A)->insn_code = CODE_FOR_$(vec_shr_$a$)\",\n-  \"optab_handler (vec_realign_load_optab, $A)->insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n+  \"set_optab_handler (vec_set_optab, $A, CODE_FOR_$(vec_set$a$))\",\n+  \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n+  \"set_optab_handler (vec_extract_even_optab, $A, CODE_FOR_$(vec_extract_even$a$))\",\n+  \"set_optab_handler (vec_extract_odd_optab, $A, CODE_FOR_$(vec_extract_odd$a$))\",\n+  \"set_optab_handler (vec_interleave_high_optab, $A, CODE_FOR_$(vec_interleave_high$a$))\",\n+  \"set_optab_handler (vec_interleave_low_optab, $A, CODE_FOR_$(vec_interleave_low$a$))\",\n+  \"set_optab_handler (vec_init_optab, $A, CODE_FOR_$(vec_init$a$))\",\n+  \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n+  \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\",\n+  \"set_optab_handler (vec_realign_load_optab, $A, CODE_FOR_$(vec_realign_load_$a$))\",\n   \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n   \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n-  \"optab_handler (ssum_widen_optab, $A)->insn_code = CODE_FOR_$(widen_ssum$I$a3$)\",\n-  \"optab_handler (usum_widen_optab, $A)->insn_code = CODE_FOR_$(widen_usum$I$a3$)\",\n-  \"optab_handler (udot_prod_optab, $A)->insn_code = CODE_FOR_$(udot_prod$I$a$)\",\n-  \"optab_handler (sdot_prod_optab, $A)->insn_code = CODE_FOR_$(sdot_prod$I$a$)\",\n-  \"optab_handler (reduc_smax_optab, $A)->insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n-  \"optab_handler (reduc_umax_optab, $A)->insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n-  \"optab_handler (reduc_smin_optab, $A)->insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n-  \"optab_handler (reduc_umin_optab, $A)->insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n-  \"optab_handler (reduc_splus_optab, $A)->insn_code = CODE_FOR_$(reduc_splus_$a$)\" ,\n-  \"optab_handler (reduc_uplus_optab, $A)->insn_code = CODE_FOR_$(reduc_uplus_$a$)\",\n-  \"optab_handler (vec_widen_umult_hi_optab, $A)->insn_code = CODE_FOR_$(vec_widen_umult_hi_$a$)\",\n-  \"optab_handler (vec_widen_umult_lo_optab, $A)->insn_code = CODE_FOR_$(vec_widen_umult_lo_$a$)\",\n-  \"optab_handler (vec_widen_smult_hi_optab, $A)->insn_code = CODE_FOR_$(vec_widen_smult_hi_$a$)\",\n-  \"optab_handler (vec_widen_smult_lo_optab, $A)->insn_code = CODE_FOR_$(vec_widen_smult_lo_$a$)\",\n-  \"optab_handler (vec_unpacks_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_hi_$a$)\",\n-  \"optab_handler (vec_unpacks_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n-  \"optab_handler (vec_unpacku_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n-  \"optab_handler (vec_unpacku_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n-  \"optab_handler (vec_unpacks_float_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_float_hi_$a$)\",\n-  \"optab_handler (vec_unpacks_float_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacks_float_lo_$a$)\",\n-  \"optab_handler (vec_unpacku_float_hi_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_float_hi_$a$)\",\n-  \"optab_handler (vec_unpacku_float_lo_optab, $A)->insn_code = CODE_FOR_$(vec_unpacku_float_lo_$a$)\",\n-  \"optab_handler (vec_pack_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_trunc_$a$)\",\n-  \"optab_handler (vec_pack_ssat_optab, $A)->insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",\n-  \"optab_handler (vec_pack_usat_optab, $A)->insn_code = CODE_FOR_$(vec_pack_usat_$a$)\",\n-  \"optab_handler (vec_pack_sfix_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_sfix_trunc_$a$)\",\n-  \"optab_handler (vec_pack_ufix_trunc_optab, $A)->insn_code = CODE_FOR_$(vec_pack_ufix_trunc_$a$)\"\n+  \"set_optab_handler (ssum_widen_optab, $A, CODE_FOR_$(widen_ssum$I$a3$))\",\n+  \"set_optab_handler (usum_widen_optab, $A, CODE_FOR_$(widen_usum$I$a3$))\",\n+  \"set_optab_handler (udot_prod_optab, $A, CODE_FOR_$(udot_prod$I$a$))\",\n+  \"set_optab_handler (sdot_prod_optab, $A, CODE_FOR_$(sdot_prod$I$a$))\",\n+  \"set_optab_handler (reduc_smax_optab, $A, CODE_FOR_$(reduc_smax_$a$))\",\n+  \"set_optab_handler (reduc_umax_optab, $A, CODE_FOR_$(reduc_umax_$a$))\",\n+  \"set_optab_handler (reduc_smin_optab, $A, CODE_FOR_$(reduc_smin_$a$))\",\n+  \"set_optab_handler (reduc_umin_optab, $A, CODE_FOR_$(reduc_umin_$a$))\",\n+  \"set_optab_handler (reduc_splus_optab, $A, CODE_FOR_$(reduc_splus_$a$))\" ,\n+  \"set_optab_handler (reduc_uplus_optab, $A, CODE_FOR_$(reduc_uplus_$a$))\",\n+  \"set_optab_handler (vec_widen_umult_hi_optab, $A, CODE_FOR_$(vec_widen_umult_hi_$a$))\",\n+  \"set_optab_handler (vec_widen_umult_lo_optab, $A, CODE_FOR_$(vec_widen_umult_lo_$a$))\",\n+  \"set_optab_handler (vec_widen_smult_hi_optab, $A, CODE_FOR_$(vec_widen_smult_hi_$a$))\",\n+  \"set_optab_handler (vec_widen_smult_lo_optab, $A, CODE_FOR_$(vec_widen_smult_lo_$a$))\",\n+  \"set_optab_handler (vec_unpacks_hi_optab, $A, CODE_FOR_$(vec_unpacks_hi_$a$))\",\n+  \"set_optab_handler (vec_unpacks_lo_optab, $A, CODE_FOR_$(vec_unpacks_lo_$a$))\",\n+  \"set_optab_handler (vec_unpacku_hi_optab, $A, CODE_FOR_$(vec_unpacku_hi_$a$))\",\n+  \"set_optab_handler (vec_unpacku_lo_optab, $A, CODE_FOR_$(vec_unpacku_lo_$a$))\",\n+  \"set_optab_handler (vec_unpacks_float_hi_optab, $A, CODE_FOR_$(vec_unpacks_float_hi_$a$))\",\n+  \"set_optab_handler (vec_unpacks_float_lo_optab, $A, CODE_FOR_$(vec_unpacks_float_lo_$a$))\",\n+  \"set_optab_handler (vec_unpacku_float_hi_optab, $A, CODE_FOR_$(vec_unpacku_float_hi_$a$))\",\n+  \"set_optab_handler (vec_unpacku_float_lo_optab, $A, CODE_FOR_$(vec_unpacku_float_lo_$a$))\",\n+  \"set_optab_handler (vec_pack_trunc_optab, $A, CODE_FOR_$(vec_pack_trunc_$a$))\",\n+  \"set_optab_handler (vec_pack_ssat_optab, $A, CODE_FOR_$(vec_pack_ssat_$a$))\",\n+  \"set_optab_handler (vec_pack_usat_optab, $A, CODE_FOR_$(vec_pack_usat_$a$))\",\n+  \"set_optab_handler (vec_pack_sfix_trunc_optab, $A, CODE_FOR_$(vec_pack_sfix_trunc_$a$))\",\n+  \"set_optab_handler (vec_pack_ufix_trunc_optab, $A, CODE_FOR_$(vec_pack_ufix_trunc_$a$))\"\n };\n \n static void gen_insn (rtx);\n@@ -519,8 +519,9 @@ from the machine description file `md'.  */\\n\\n\");\n      also convert validly to an unsigned one.  */\\n\\\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\\n\\\n     for (j = 0; j < NUM_MACHINE_MODES; j++)\\n\\\n-      convert_optab_handler (ufixtrunc_optab, i, j)->insn_code\\n\\\n-      = convert_optab_handler (sfixtrunc_optab, i, j)->insn_code;\\n\\\n+      set_convert_optab_handler\\n\\\n+ \t(ufixtrunc_optab, i, j,\\n\\\n+\t convert_optab_handler (sfixtrunc_optab, i, j));\\n\\\n #endif\\n\\\n }\");\n "}, {"sha": "33c9a147a66c7c441306e4c6ca6b021e76e8ee5c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -3156,7 +3156,7 @@ find_if_header (basic_block test_bb, int pass)\n     goto success;\n \n   if (HAVE_trap\n-      && optab_handler (ctrap_optab, word_mode)->insn_code != CODE_FOR_nothing\n+      && optab_handler (ctrap_optab, word_mode) != CODE_FOR_nothing\n       && find_cond_trap (test_bb, then_edge, else_edge))\n     goto success;\n "}, {"sha": "23bb549cf9b475aad9a5a35b49b8d29ea6d05825", "filename": "gcc/optabs.c", "status": "modified", "additions": 82, "deletions": 91, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -563,9 +563,9 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n   if (ops->code == WIDEN_MULT_PLUS_EXPR\n       || ops->code == WIDEN_MULT_MINUS_EXPR)\n     icode = (int) optab_handler (widen_pattern_optab,\n-\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)))->insn_code;\n+\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)));\n   else\n-    icode = (int) optab_handler (widen_pattern_optab, tmode0)->insn_code;\n+    icode = (int) optab_handler (widen_pattern_optab, tmode0);\n   gcc_assert (icode != CODE_FOR_nothing);\n   xmode0 = insn_data[icode].operand[1].mode;\n \n@@ -690,16 +690,15 @@ rtx\n expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n \t\t   rtx op1, rtx op2, rtx target, int unsignedp)\n {\n-  int icode = (int) optab_handler (ternary_optab, mode)->insn_code;\n+  int icode = (int) optab_handler (ternary_optab, mode);\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n   enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n   rtx temp;\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1, xop2 = op2;\n \n-  gcc_assert (optab_handler (ternary_optab, mode)->insn_code\n-\t      != CODE_FOR_nothing);\n+  gcc_assert (optab_handler (ternary_optab, mode) != CODE_FOR_nothing);\n \n   if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n     temp = gen_reg_rtx (mode);\n@@ -819,7 +818,7 @@ expand_vec_shift_expr (sepops ops, rtx target)\n \tgcc_unreachable ();\n     }\n \n-  icode = optab_handler (shift_optab, mode)->insn_code;\n+  icode = optab_handler (shift_optab, mode);\n   gcc_assert (icode != CODE_FOR_nothing);\n \n   mode1 = insn_data[icode].operand[1].mode;\n@@ -1436,7 +1435,7 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n \t\t       rtx last)\n {\n-  int icode = (int) optab_handler (binoptab, mode)->insn_code;\n+  int icode = (int) optab_handler (binoptab, mode);\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n   enum machine_mode tmp_mode;\n@@ -1593,7 +1592,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n-      && optab_handler (binoptab, mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, mode) != CODE_FOR_nothing)\n     {\n       temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n \t\t\t\t    unsignedp, methods, last);\n@@ -1604,9 +1603,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we were trying to rotate, and that didn't work, try rotating\n      the other direction before falling back to shifts and bitwise-or.  */\n   if (((binoptab == rotl_optab\n-\t&& optab_handler (rotr_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t&& optab_handler (rotr_optab, mode) != CODE_FOR_nothing)\n        || (binoptab == rotr_optab\n-\t   && optab_handler (rotl_optab, mode)->insn_code != CODE_FOR_nothing))\n+\t   && optab_handler (rotl_optab, mode) != CODE_FOR_nothing))\n       && mclass == MODE_INT)\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n@@ -1633,8 +1632,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (binoptab == smul_optab\n       && GET_MODE_WIDER_MODE (mode) != VOIDmode\n-      && ((optab_handler ((unsignedp ? umul_widen_optab : smul_widen_optab),\n-\t\t\t  GET_MODE_WIDER_MODE (mode))->insn_code)\n+      && (optab_handler ((unsignedp ? umul_widen_optab : smul_widen_optab),\n+\t\t\t GET_MODE_WIDER_MODE (mode))\n \t  != CODE_FOR_nothing))\n     {\n       temp = expand_binop (GET_MODE_WIDER_MODE (mode),\n@@ -1662,12 +1661,12 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n-\tif (optab_handler (binoptab, wider_mode)->insn_code != CODE_FOR_nothing\n+\tif (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n \t\t&& GET_MODE_WIDER_MODE (wider_mode) != VOIDmode\n-\t\t&& ((optab_handler ((unsignedp ? umul_widen_optab\n-\t\t\t\t     : smul_widen_optab),\n-\t\t\t\t     GET_MODE_WIDER_MODE (wider_mode))->insn_code)\n+\t\t&& (optab_handler ((unsignedp ? umul_widen_optab\n+\t\t\t\t    : smul_widen_optab),\n+\t\t\t\t   GET_MODE_WIDER_MODE (wider_mode))\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -1734,7 +1733,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n       && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -1778,9 +1777,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && mclass == MODE_INT\n       && (CONST_INT_P (op1) || optimize_insn_for_speed_p ())\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing\n-      && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n-      && optab_handler (lshr_optab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode) != CODE_FOR_nothing\n+      && optab_handler (ashl_optab, word_mode) != CODE_FOR_nothing\n+      && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n       unsigned HOST_WIDE_INT shift_mask, double_shift_mask;\n       enum machine_mode op1_mode;\n@@ -1848,8 +1847,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && mclass == MODE_INT\n       && CONST_INT_P (op1)\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n-      && optab_handler (lshr_optab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (ashl_optab, word_mode) != CODE_FOR_nothing\n+      && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n       rtx insns;\n       rtx into_target, outof_target;\n@@ -1960,7 +1959,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == add_optab || binoptab == sub_optab)\n       && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n-      && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (binoptab, word_mode) != CODE_FOR_nothing)\n     {\n       unsigned int i;\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n@@ -2057,7 +2056,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (i == GET_MODE_BITSIZE (mode) / (unsigned) BITS_PER_WORD)\n \t{\n-\t  if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing\n+\t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing\n \t      || ! rtx_equal_p (target, xtarget))\n \t    {\n \t      rtx temp = emit_move_insn (target, xtarget);\n@@ -2086,13 +2085,12 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if (binoptab == smul_optab\n       && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && optab_handler (smul_optab, word_mode)->insn_code != CODE_FOR_nothing\n-      && optab_handler (add_optab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (smul_optab, word_mode) != CODE_FOR_nothing\n+      && optab_handler (add_optab, word_mode) != CODE_FOR_nothing)\n     {\n       rtx product = NULL_RTX;\n \n-      if (optab_handler (umul_widen_optab, mode)->insn_code\n-\t  != CODE_FOR_nothing)\n+      if (optab_handler (umul_widen_optab, mode) != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n \t\t\t\t\t    true, methods);\n@@ -2101,8 +2099,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n \n       if (product == NULL_RTX\n-\t  && optab_handler (smul_widen_optab, mode)->insn_code\n-\t     != CODE_FOR_nothing)\n+\t  && optab_handler (smul_widen_optab, mode) != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n \t\t\t\t\t    false, methods);\n@@ -2112,7 +2109,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (product != NULL_RTX)\n \t{\n-\t  if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing)\n \t    {\n \t      temp = emit_move_insn (target ? target : product, product);\n \t      set_unique_reg_note (temp,\n@@ -2193,8 +2190,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if ((optab_handler (binoptab, wider_mode)->insn_code\n-\t       != CODE_FOR_nothing)\n+\t  if (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t      || (methods == OPTAB_LIB\n \t\t  && optab_libfunc (binoptab, wider_mode)))\n \t    {\n@@ -2270,7 +2266,7 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n   /* Try widening to a signed int.  Make a fake signed optab that\n      hides any signed insn for direct use.  */\n   wide_soptab = *soptab;\n-  optab_handler (&wide_soptab, mode)->insn_code = CODE_FOR_nothing;\n+  set_optab_handler (&wide_soptab, mode, CODE_FOR_nothing);\n   /* We don't want to generate new hash table entries from this fake\n      optab.  */\n   wide_soptab.libcall_gen = NULL;\n@@ -2332,9 +2328,9 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n   /* Record where to go back to if we fail.  */\n   last = get_last_insn ();\n \n-  if (optab_handler (unoptab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (unoptab, mode)->insn_code;\n+      int icode = (int) optab_handler (unoptab, mode);\n       enum machine_mode mode0 = insn_data[icode].operand[2].mode;\n       rtx pat;\n       rtx xop0 = op0;\n@@ -2370,8 +2366,7 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (optab_handler (unoptab, wider_mode)->insn_code\n-\t      != CODE_FOR_nothing)\n+\t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n \t      rtx t0 = gen_reg_rtx (wider_mode);\n \t      rtx t1 = gen_reg_rtx (wider_mode);\n@@ -2425,9 +2420,9 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n   /* Record where to go back to if we fail.  */\n   last = get_last_insn ();\n \n-  if (optab_handler (binoptab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (binoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (binoptab, mode)->insn_code;\n+      int icode = (int) optab_handler (binoptab, mode);\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n       rtx pat;\n@@ -2487,8 +2482,7 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (optab_handler (binoptab, wider_mode)->insn_code\n-\t      != CODE_FOR_nothing)\n+\t  if (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing)\n \t    {\n \t      rtx t0 = gen_reg_rtx (wider_mode);\n \t      rtx t1 = gen_reg_rtx (wider_mode);\n@@ -2589,8 +2583,7 @@ widen_clz (enum machine_mode mode, rtx op0, rtx target)\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (optab_handler (clz_optab, wider_mode)->insn_code\n-\t      != CODE_FOR_nothing)\n+\t  if (optab_handler (clz_optab, wider_mode) != CODE_FOR_nothing)\n \t    {\n \t      rtx xop0, temp, last;\n \n@@ -2702,7 +2695,7 @@ widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n   for (wider_mode = GET_MODE_WIDER_MODE (mode);\n        wider_mode != VOIDmode;\n        wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-    if (optab_handler (bswap_optab, wider_mode)->insn_code != CODE_FOR_nothing)\n+    if (optab_handler (bswap_optab, wider_mode) != CODE_FOR_nothing)\n       goto found;\n   return NULL_RTX;\n \n@@ -2764,8 +2757,7 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n       for (wider_mode = mode; wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (optab_handler (popcount_optab, wider_mode)->insn_code\n-\t      != CODE_FOR_nothing)\n+\t  if (optab_handler (popcount_optab, wider_mode) != CODE_FOR_nothing)\n \t    {\n \t      rtx xop0, temp, last;\n \n@@ -2806,7 +2798,7 @@ expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n {\n   rtx seq, temp;\n \n-  if (optab_handler (clz_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (clz_optab, mode) == CODE_FOR_nothing)\n     return 0;\n \n   start_sequence ();\n@@ -2849,7 +2841,7 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n   bool defined_at_zero = false;\n   rtx temp, seq;\n \n-  if (optab_handler (ctz_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing)\n     {\n       start_sequence ();\n \n@@ -2859,7 +2851,7 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n \n       defined_at_zero = (CTZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2);\n     }\n-  else if (optab_handler (clz_optab, mode)->insn_code != CODE_FOR_nothing)\n+  else if (optab_handler (clz_optab, mode) != CODE_FOR_nothing)\n     {\n       start_sequence ();\n       temp = expand_ctz (mode, op0, 0);\n@@ -3037,9 +3029,9 @@ static rtx\n expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t     int unsignedp)\n {\n-  if (optab_handler (unoptab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (unoptab, mode)->insn_code;\n+      int icode = (int) optab_handler (unoptab, mode);\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n@@ -3116,7 +3108,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \treturn temp;\n \n       if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t  && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n \t{\n \t  temp = expand_doubleword_clz (mode, op0, target);\n \t  if (temp)\n@@ -3134,7 +3126,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \treturn temp;\n \n       if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t  && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n \t{\n \t  temp = expand_doubleword_bswap (mode, op0, target);\n \t  if (temp)\n@@ -3149,7 +3141,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n-\tif (optab_handler (unoptab, wider_mode)->insn_code != CODE_FOR_nothing)\n+\tif (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t  {\n \t    rtx xop0 = op0;\n \t    rtx last = get_last_insn ();\n@@ -3189,7 +3181,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n   if (unoptab == one_cmpl_optab\n       && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -3311,8 +3303,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if ((optab_handler (unoptab, wider_mode)->insn_code\n-\t       != CODE_FOR_nothing)\n+\t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing\n \t      || optab_libfunc (unoptab, wider_mode))\n \t    {\n \t      rtx xop0 = op0;\n@@ -3405,7 +3396,7 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n     }\n \n   /* If we have a MAX insn, we can do this as MAX (x, -x).  */\n-  if (optab_handler (smax_optab, mode)->insn_code != CODE_FOR_nothing\n+  if (optab_handler (smax_optab, mode) != CODE_FOR_nothing\n       && !HONOR_SIGNED_ZEROS (mode))\n     {\n       rtx last = get_last_insn ();\n@@ -3508,7 +3499,7 @@ expand_one_cmpl_abs_nojump (enum machine_mode mode, rtx op0, rtx target)\n     return NULL_RTX;\n \n   /* If we have a MAX insn, we can do this as MAX (x, ~x).  */\n-  if (optab_handler (smax_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (smax_optab, mode) != CODE_FOR_nothing)\n     {\n       rtx last = get_last_insn ();\n \n@@ -3562,7 +3553,7 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n   /* Check if the back end provides an insn that handles signbit for the\n      argument's mode. */\n-  icode = (int) signbit_optab->handlers [(int) mode].insn_code;\n+  icode = (int) optab_handler (signbit_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       imode = insn_data[icode].operand[0].mode;\n@@ -3762,8 +3753,8 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n \n   if (fmt->signbit_ro >= 0\n       && (GET_CODE (op0) == CONST_DOUBLE\n-\t  || (optab_handler (neg_optab, mode)->insn_code != CODE_FOR_nothing\n-\t      && optab_handler (abs_optab, mode)->insn_code != CODE_FOR_nothing)))\n+\t  || (optab_handler (neg_optab, mode) != CODE_FOR_nothing\n+\t      && optab_handler (abs_optab, mode) != CODE_FOR_nothing)))\n     {\n       temp = expand_copysign_absneg (mode, op0, op1, target,\n \t\t\t\t     fmt->signbit_ro, op0_is_abs);\n@@ -3975,8 +3966,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n     }\n \n   last = emit_move_insn (target, result);\n-  if (optab_handler (mov_optab, GET_MODE (target))->insn_code\n-      != CODE_FOR_nothing)\n+  if (optab_handler (mov_optab, GET_MODE (target)) != CODE_FOR_nothing)\n     set_unique_reg_note (last, REG_EQUAL, copy_rtx (equiv));\n \n   if (final_dest != target)\n@@ -4002,15 +3992,15 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n       int icode;\n \n       if (purpose == ccp_jump\n-          && (icode = optab_handler (cbranch_optab, mode)->insn_code) != CODE_FOR_nothing\n+          && (icode = optab_handler (cbranch_optab, mode)) != CODE_FOR_nothing\n           && insn_data[icode].operand[0].predicate (test, mode))\n         return 1;\n       if (purpose == ccp_store_flag\n-          && (icode = optab_handler (cstore_optab, mode)->insn_code) != CODE_FOR_nothing\n+          && (icode = optab_handler (cstore_optab, mode)) != CODE_FOR_nothing\n           && insn_data[icode].operand[1].predicate (test, mode))\n         return 1;\n       if (purpose == ccp_cmov\n-\t  && optab_handler (cmov_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (cmov_optab, mode) != CODE_FOR_nothing)\n \treturn 1;\n \n       mode = GET_MODE_WIDER_MODE (mode);\n@@ -4166,7 +4156,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n   do\n    {\n       enum insn_code icode;\n-      icode = optab_handler (cbranch_optab, cmp_mode)->insn_code;\n+      icode = optab_handler (cbranch_optab, cmp_mode);\n       if (icode != CODE_FOR_nothing\n \t  && insn_data[icode].operand[0].predicate (test, VOIDmode))\n \t{\n@@ -4285,7 +4275,7 @@ emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label)\n \n   mclass = GET_MODE_CLASS (mode);\n   optab_mode = (mclass == MODE_CC) ? CCmode : mode;\n-  icode = optab_handler (cbranch_optab, optab_mode)->insn_code;\n+  icode = optab_handler (cbranch_optab, optab_mode);\n \n   gcc_assert (icode != CODE_FOR_nothing);\n   gcc_assert (insn_data[icode].operand[0].predicate (test, VOIDmode));\n@@ -4684,7 +4674,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (mode == VOIDmode)\n     mode = GET_MODE (op2);\n \n-  icode = optab_handler (addcc_optab, mode)->insn_code;\n+  icode = optab_handler (addcc_optab, mode);\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4755,7 +4745,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n rtx\n gen_add2_insn (rtx x, rtx y)\n {\n-  int icode = (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n+  int icode = (int) optab_handler (add_optab, GET_MODE (x));\n \n   gcc_assert (insn_data[icode].operand[0].predicate\n \t      (x, insn_data[icode].operand[0].mode));\n@@ -4773,7 +4763,7 @@ gen_add2_insn (rtx x, rtx y)\n rtx\n gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) optab_handler (add_optab, GET_MODE (r0))->insn_code;\n+  int icode = (int) optab_handler (add_optab, GET_MODE (r0));\n \n   if (icode == CODE_FOR_nothing\n       || !(insn_data[icode].operand[0].predicate\n@@ -4794,7 +4784,7 @@ have_add2_insn (rtx x, rtx y)\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n+  icode = (int) optab_handler (add_optab, GET_MODE (x));\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4815,7 +4805,7 @@ have_add2_insn (rtx x, rtx y)\n rtx\n gen_sub2_insn (rtx x, rtx y)\n {\n-  int icode = (int) optab_handler (sub_optab, GET_MODE (x))->insn_code;\n+  int icode = (int) optab_handler (sub_optab, GET_MODE (x));\n \n   gcc_assert (insn_data[icode].operand[0].predicate\n \t      (x, insn_data[icode].operand[0].mode));\n@@ -4833,7 +4823,7 @@ gen_sub2_insn (rtx x, rtx y)\n rtx\n gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) optab_handler (sub_optab, GET_MODE (r0))->insn_code;\n+  int icode = (int) optab_handler (sub_optab, GET_MODE (r0));\n \n   if (icode == CODE_FOR_nothing\n       || !(insn_data[icode].operand[0].predicate\n@@ -4854,7 +4844,7 @@ have_sub2_insn (rtx x, rtx y)\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) optab_handler (sub_optab, GET_MODE (x))->insn_code;\n+  icode = (int) optab_handler (sub_optab, GET_MODE (x));\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n@@ -4900,7 +4890,7 @@ can_extend_p (enum machine_mode to_mode, enum machine_mode from_mode,\n #endif\n \n   tab = unsignedp ? zext_optab : sext_optab;\n-  return convert_optab_handler (tab, to_mode, from_mode)->insn_code;\n+  return convert_optab_handler (tab, to_mode, from_mode);\n }\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n@@ -4931,7 +4921,7 @@ can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n   enum insn_code icode;\n \n   tab = unsignedp ? ufixtrunc_optab : sfixtrunc_optab;\n-  icode = convert_optab_handler (tab, fixmode, fltmode)->insn_code;\n+  icode = convert_optab_handler (tab, fixmode, fltmode);\n   if (icode != CODE_FOR_nothing)\n     {\n       *truncp_ptr = 0;\n@@ -4942,9 +4932,9 @@ can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n      for this to work. We need to rework the fix* and ftrunc* patterns\n      and documentation.  */\n   tab = unsignedp ? ufix_optab : sfix_optab;\n-  icode = convert_optab_handler (tab, fixmode, fltmode)->insn_code;\n+  icode = convert_optab_handler (tab, fixmode, fltmode);\n   if (icode != CODE_FOR_nothing\n-      && optab_handler (ftrunc_optab, fltmode)->insn_code != CODE_FOR_nothing)\n+      && optab_handler (ftrunc_optab, fltmode) != CODE_FOR_nothing)\n     {\n       *truncp_ptr = 1;\n       return icode;\n@@ -4961,7 +4951,7 @@ can_float_p (enum machine_mode fltmode, enum machine_mode fixmode,\n   convert_optab tab;\n \n   tab = unsignedp ? ufloat_optab : sfloat_optab;\n-  return convert_optab_handler (tab, fltmode, fixmode)->insn_code;\n+  return convert_optab_handler (tab, fltmode, fixmode);\n }\n \f\n /* Generate code to convert FROM to floating point\n@@ -5295,8 +5285,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n \t  emit_label (lab2);\n \n-\t  if (optab_handler (mov_optab, GET_MODE (to))->insn_code\n-\t      != CODE_FOR_nothing)\n+\t  if (optab_handler (mov_optab, GET_MODE (to)) != CODE_FOR_nothing)\n \t    {\n \t      /* Make a place for a REG_NOTE and add it.  */\n \t      insn = emit_move_insn (to, to);\n@@ -5383,7 +5372,7 @@ expand_fixed_convert (rtx to, rtx from, int uintp, int satp)\n       tab = satp ? satfract_optab : fract_optab;\n       this_code = satp ? SAT_FRACT : FRACT_CONVERT;\n     }\n-  code = tab->handlers[to_mode][from_mode].insn_code;\n+  code = convert_optab_handler (tab, to_mode, from_mode);\n   if (code != CODE_FOR_nothing)\n     {\n       emit_unop_insn (code, to, from, this_code);\n@@ -5424,7 +5413,7 @@ expand_sfix_optab (rtx to, rtx from, convert_optab tab)\n     for (imode = GET_MODE (to); imode != VOIDmode;\n \t imode = GET_MODE_WIDER_MODE (imode))\n       {\n-\ticode = convert_optab_handler (tab, imode, fmode)->insn_code;\n+\ticode = convert_optab_handler (tab, imode, fmode);\n \tif (icode != CODE_FOR_nothing)\n \t  {\n \t    rtx last = get_last_insn ();\n@@ -5454,7 +5443,7 @@ int\n have_insn_for (enum rtx_code code, enum machine_mode mode)\n {\n   return (code_to_optab[(int) code] != 0\n-\t  && (optab_handler (code_to_optab[(int) code], mode)->insn_code\n+\t  && (optab_handler (code_to_optab[(int) code], mode)\n \t      != CODE_FOR_nothing));\n }\n \n@@ -5472,7 +5461,7 @@ init_insn_codes (void)\n \n       op = &optab_table[i];\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n-\toptab_handler (op, j)->insn_code = CODE_FOR_nothing;\n+\tset_optab_handler (op, (enum machine_mode) j, CODE_FOR_nothing);\n     }\n   for (i = 0; i < (unsigned int) COI_MAX; i++)\n     {\n@@ -5482,7 +5471,8 @@ init_insn_codes (void)\n       op = &convert_optab_table[i];\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n \tfor (k = 0; k < NUM_MACHINE_MODES; k++)\n-\t  convert_optab_handler (op, j, k)->insn_code = CODE_FOR_nothing;\n+\t  set_convert_optab_handler (op, (enum machine_mode) j,\n+\t\t\t\t     (enum machine_mode) k, CODE_FOR_nothing);\n     }\n }\n \n@@ -6211,7 +6201,8 @@ init_optabs (void)\n     }\n \n #if GCC_VERSION >= 4000 && HAVE_DESIGNATED_INITIALIZERS\n-  /* We statically initialize the insn_codes with CODE_FOR_nothing.  */\n+  /* We statically initialize the insn_codes with the equivalent of\n+     CODE_FOR_nothing.  */\n   if (reinit)\n     init_insn_codes ();\n #else\n@@ -6763,7 +6754,7 @@ gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n   if (mode == VOIDmode)\n     return 0;\n \n-  icode = optab_handler (ctrap_optab, mode)->insn_code;\n+  icode = optab_handler (ctrap_optab, mode);\n   if (icode == CODE_FOR_nothing)\n     return 0;\n "}, {"sha": "03feb5a5abb05e9f64aa7f421a6248646757c7cc", "filename": "gcc/optabs.h", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -782,9 +782,43 @@ extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n /* Generate code for VEC_LSHIFT_EXPR and VEC_RSHIFT_EXPR.  */\n extern rtx expand_vec_shift_expr (sepops, rtx);\n \n-#define optab_handler(optab,mode) (&(optab)->handlers[(int) (mode)])\n-#define convert_optab_handler(optab,mode,mode2) \\\n-\t(&(optab)->handlers[(int) (mode)][(int) (mode2)])\n+/* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n+   if the target does not have such an insn.  */\n+\n+static inline enum insn_code\n+optab_handler (optab op, enum machine_mode mode)\n+{\n+  return op->handlers[(int) mode].insn_code;\n+}\n+\n+/* Record that insn CODE should be used to implement mode MODE of OP.  */\n+\n+static inline void\n+set_optab_handler (optab op, enum machine_mode mode, enum insn_code code)\n+{\n+  op->handlers[(int) mode].insn_code = code;\n+}\n+\n+/* Return the insn used to perform conversion OP from mode FROM_MODE\n+   to mode TO_MODE; return CODE_FOR_nothing if the target does not have\n+   such an insn.  */\n+\n+static inline enum insn_code\n+convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n+\t\t       enum machine_mode from_mode)\n+{\n+  return op->handlers[(int) to_mode][(int) from_mode].insn_code;\n+}\n+\n+/* Record that insn CODE should be used to perform conversion OP\n+   from mode FROM_MODE to mode TO_MODE.  */\n+\n+static inline void\n+set_convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n+\t\t\t   enum machine_mode from_mode, enum insn_code code)\n+{\n+  op->handlers[(int) to_mode][(int) from_mode].insn_code = code;\n+}\n \n extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,"}, {"sha": "8a3d29525e73743dfa4137c0a10dc6f73fb609f2", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -5834,8 +5834,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t      rtx equiv = (MEM_P (XEXP (x, 0))\n \t\t\t   ? XEXP (x, 0)\n \t\t\t   : reg_equiv_mem[regno]);\n-\t      int icode\n-\t\t= (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n+\t      int icode = (int) optab_handler (add_optab, GET_MODE (x));\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0"}, {"sha": "f056b4055ae1ce68e2aa8ba8218fbaa0ebd5eefc", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -8680,7 +8680,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t DEFINE_PEEPHOLE should be specified that recognizes the sequence\n \t we emit below.  */\n \n-      code = (int) optab_handler (add_optab, GET_MODE (out))->insn_code;\n+      code = (int) optab_handler (add_optab, GET_MODE (out));\n \n       if (CONSTANT_P (op1) || MEM_P (op1) || GET_CODE (op1) == SUBREG\n \t  || (REG_P (op1)"}, {"sha": "65f3a815ff3cd674009ccf31eb2e2a488ded089c", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -2071,7 +2071,7 @@ add_case_node (struct case_node *head, tree type, tree low, tree high,\n \n /* By default, enable case bit tests on targets with ashlsi3.  */\n #ifndef CASE_USE_BIT_TESTS\n-#define CASE_USE_BIT_TESTS  (optab_handler (ashl_optab, word_mode)->insn_code \\\n+#define CASE_USE_BIT_TESTS  (optab_handler (ashl_optab, word_mode) \\\n \t\t\t     != CODE_FOR_nothing)\n #endif\n "}, {"sha": "e302b86352c1e0b3818804cafbd3deb7a0869113", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -974,7 +974,7 @@ default_builtin_support_vector_misalignment (enum machine_mode mode,\n \t\t\t\t\t     bool is_packed\n \t\t\t\t\t     ATTRIBUTE_UNUSED)\n {\n-  if (optab_handler (movmisalign_optab, mode)->insn_code != CODE_FOR_nothing)\n+  if (optab_handler (movmisalign_optab, mode) != CODE_FOR_nothing)\n     return true;\n   return false;\n }"}, {"sha": "96a8e920acc5601ccb172c32743d9dd6e9dffa0a", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1136,7 +1136,7 @@ nontemporal_store_p (struct mem_ref *ref)\n   if (mode == BLKmode)\n     return false;\n \n-  code = optab_handler (storent_optab, mode)->insn_code;\n+  code = optab_handler (storent_optab, mode);\n   return code != CODE_FOR_nothing;\n }\n "}, {"sha": "9a8b13f2c4e380cf19966d4d64c694a850b4c69b", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -1113,11 +1113,9 @@ execute_optimize_bswap (void)\n     return 0;\n \n   bswap32_p = (built_in_decls[BUILT_IN_BSWAP32]\n-\t       && optab_handler (bswap_optab, SImode)->insn_code !=\n-\t       CODE_FOR_nothing);\n+\t       && optab_handler (bswap_optab, SImode) != CODE_FOR_nothing);\n   bswap64_p = (built_in_decls[BUILT_IN_BSWAP64]\n-\t       && (optab_handler (bswap_optab, DImode)->insn_code !=\n-\t\t   CODE_FOR_nothing\n+\t       && (optab_handler (bswap_optab, DImode) != CODE_FOR_nothing\n \t\t   || (bswap32_p && word_mode == SImode)));\n \n   if (!bswap32_p && !bswap64_p)\n@@ -1324,17 +1322,17 @@ convert_mult_to_widen (gimple stmt)\n   if ((rhs1_stmt == NULL || TYPE_UNSIGNED (type1))\n       && (rhs2_stmt == NULL || TYPE_UNSIGNED (type2))\n       && (optab_handler (umul_widen_optab, TYPE_MODE (type))\n-\t  ->insn_code == CODE_FOR_nothing))\n+\t  == CODE_FOR_nothing))\n     return false;\n   else if ((rhs1_stmt == NULL || !TYPE_UNSIGNED (type1))\n \t   && (rhs2_stmt == NULL || !TYPE_UNSIGNED (type2))\n \t   && (optab_handler (smul_widen_optab, TYPE_MODE (type))\n-\t       ->insn_code == CODE_FOR_nothing))\n+\t       == CODE_FOR_nothing))\n     return false;\n   else if (rhs1_stmt != NULL && rhs2_stmt != NULL\n \t   && (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n \t   && (optab_handler (usmul_widen_optab, TYPE_MODE (type))\n-\t       ->insn_code == CODE_FOR_nothing))\n+\t       == CODE_FOR_nothing))\n     return false;\n \n   if ((rhs1_stmt == NULL && !int_fits_type_p (rhs1, type2))\n@@ -1385,8 +1383,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n      accumulate in this mode/signedness combination, otherwise\n      this transformation is likely to pessimize code.  */\n   this_optab = optab_for_tree_code (wmult_code, type, optab_default);\n-  if (optab_handler (this_optab, TYPE_MODE (type))->insn_code\n-      == CODE_FOR_nothing)\n+  if (optab_handler (this_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n     return false;\n \n   rhs1 = gimple_assign_rhs1 (stmt);"}, {"sha": "801f37c5a0d29a72ed9919af1a2ebde1fffd5eec", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -3243,9 +3243,9 @@ bool\n vect_strided_store_supported (tree vectype)\n {\n   optab interleave_high_optab, interleave_low_optab;\n-  int mode;\n+  enum machine_mode mode;\n \n-  mode = (int) TYPE_MODE (vectype);\n+  mode = TYPE_MODE (vectype);\n \n   /* Check that the operation is supported.  */\n   interleave_high_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR,\n@@ -3259,10 +3259,8 @@ vect_strided_store_supported (tree vectype)\n       return false;\n     }\n \n-  if (optab_handler (interleave_high_optab, mode)->insn_code\n-      == CODE_FOR_nothing\n-      || optab_handler (interleave_low_optab, mode)->insn_code\n-      == CODE_FOR_nothing)\n+  if (optab_handler (interleave_high_optab, mode) == CODE_FOR_nothing\n+      || optab_handler (interleave_low_optab, mode) == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"interleave op not supported by target.\");\n@@ -3655,9 +3653,9 @@ bool\n vect_strided_load_supported (tree vectype)\n {\n   optab perm_even_optab, perm_odd_optab;\n-  int mode;\n+  enum machine_mode mode;\n \n-  mode = (int) TYPE_MODE (vectype);\n+  mode = TYPE_MODE (vectype);\n \n   perm_even_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR, vectype,\n \t\t\t\t\t optab_default);\n@@ -3668,7 +3666,7 @@ vect_strided_load_supported (tree vectype)\n       return false;\n     }\n \n-  if (optab_handler (perm_even_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (perm_even_optab, mode) == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"perm_even op not supported by target.\");\n@@ -3684,7 +3682,7 @@ vect_strided_load_supported (tree vectype)\n       return false;\n     }\n \n-  if (optab_handler (perm_odd_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (perm_odd_optab, mode) == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"perm_odd op not supported by target.\");\n@@ -4044,8 +4042,7 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n       bool is_packed = false;\n       tree type = (TREE_TYPE (DR_REF (dr)));\n \n-      if (optab_handler (vec_realign_load_optab, mode)->insn_code !=\n-\t\t\t\t\t\t   \t     CODE_FOR_nothing\n+      if (optab_handler (vec_realign_load_optab, mode) != CODE_FOR_nothing\n \t  && (!targetm.vectorize.builtin_mask_for_load\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n \t{"}, {"sha": "1fd29629e6649e70284a5bbe164f74a14ae45bd8", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -368,7 +368,7 @@ type_for_widest_vector_mode (enum machine_mode inner_mode, optab op, int satp)\n   for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_INNER (mode) == inner_mode\n         && GET_MODE_NUNITS (mode) > best_nunits\n-\t&& optab_handler (op, mode)->insn_code != CODE_FOR_nothing)\n+\t&& optab_handler (op, mode) != CODE_FOR_nothing)\n       best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n \n   if (best_mode == VOIDmode)\n@@ -443,8 +443,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \t     have a vector/vector shift */\n \t  op = optab_for_tree_code (code, type, optab_scalar);\n \t  if (!op\n-\t      || (op->handlers[(int) TYPE_MODE (type)].insn_code\n-\t\t  == CODE_FOR_nothing))\n+\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n \t    op = optab_for_tree_code (code, type, optab_vector);\n \t}\n     }\n@@ -498,7 +497,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_ACCUM\n \t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UACCUM)\n           && op != NULL\n-\t  && optab_handler (op, compute_mode)->insn_code != CODE_FOR_nothing)\n+\t  && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n \treturn;\n       else\n \t/* There is no operation in hardware, so fall back to scalars.  */"}, {"sha": "1285528fd55b844a3496fe687aa256414150ebb1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -132,7 +132,7 @@ along with GCC; see the file COPYING3.  If not see\n         Since we only vectorize operations which vector form can be\n    expressed using existing tree codes, to verify that an operation is\n    supported, the vectorizer checks the relevant optab at the relevant\n-   machine_mode (e.g, optab_handler (add_optab, V8HImode)->insn_code). If\n+   machine_mode (e.g, optab_handler (add_optab, V8HImode)). If\n    the value found is CODE_FOR_nothing, then there's no target support, and\n    we can't vectorize the stmt.\n \n@@ -2490,8 +2490,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n \t  /* We have a whole vector shift available.  */\n \t  if (VECTOR_MODE_P (mode)\n-\t      && optab_handler (optab, mode)->insn_code != CODE_FOR_nothing\n-\t      && optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t      && optab_handler (optab, mode) != CODE_FOR_nothing\n+\t      && optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n \t    /* Final reduction via vector shifts and the reduction operator. Also\n \t       requires scalar extract.  */\n \t    outer_cost += ((exact_log2(nelements) * 2) \n@@ -3333,7 +3333,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n       int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n       tree vec_temp;\n \n-      if (optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n+      if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n         shift_code = VEC_RSHIFT_EXPR;\n       else\n         have_whole_vector_shift = false;\n@@ -3349,7 +3349,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n       else\n         {\n           optab optab = optab_for_tree_code (code, vectype, optab_default);\n-          if (optab_handler (optab, mode)->insn_code == CODE_FOR_nothing)\n+          if (optab_handler (optab, mode) == CODE_FOR_nothing)\n             have_whole_vector_shift = false;\n         }\n \n@@ -4008,7 +4008,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           return false;\n         }\n \n-      if (optab_handler (optab, vec_mode)->insn_code == CODE_FOR_nothing)\n+      if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"op not supported by target.\");\n@@ -4056,11 +4056,12 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           2. The type (mode) we use to check available target support\n              for the vector operation to be created in the *epilog*, is\n              determined by the type of the reduction variable (in the example\n-             above we'd check this: plus_optab[vect_int_mode]).\n+             above we'd check this: optab_handler (plus_optab, vect_int_mode])).\n              However the type (mode) we use to check available target support\n              for the vector operation to be created *inside the loop*, is\n              determined by the type of the other arguments to STMT (in the\n-             example we'd check this: widen_sum_optab[vect_short_mode]).\n+             example we'd check this: optab_handler (widen_sum_optab,\n+\t     vect_short_mode)).\n \n           This is contrary to \"regular\" reductions, in which the types of all\n           the arguments are the same as the type of the reduction variable.\n@@ -4113,8 +4114,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         }\n \n       if (reduc_optab\n-          && optab_handler (reduc_optab, vec_mode)->insn_code\n-              == CODE_FOR_nothing)\n+          && optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"reduc op not supported by target.\");"}, {"sha": "f48e377c3a2c4852b0d7b2aa163b5a7ae42a1341", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -714,8 +714,7 @@ vect_pattern_recog_1 (\n       optab = optab_for_tree_code (code, type_in, optab_default);\n       vec_mode = TYPE_MODE (type_in);\n       if (!optab\n-          || (icode = optab_handler (optab, vec_mode)->insn_code) ==\n-              CODE_FOR_nothing\n+          || (icode = optab_handler (optab, vec_mode)) == CODE_FOR_nothing\n           || (insn_data[icode].operand[0].mode != TYPE_MODE (type_out)))\n \treturn;\n     }"}, {"sha": "6b377a8842a3541aea4565b5bc8f116c90044c49", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -421,8 +421,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t   optab_vector);\n \n \t      if (!optab\n-\t\t  || (optab->handlers[(int) vec_mode].insn_code\n-\t\t      == CODE_FOR_nothing))\n+\t\t  || optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n \t\t{\n \t\t  /* No vector/vector shift, try for a vector/scalar shift.  */\n \t\t  optab = optab_for_tree_code (rhs_code, vectype,\n@@ -434,7 +433,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\tfprintf (vect_dump, \"Build SLP failed: no optab.\");\n \t\t      return false;\n \t\t    }\n-\t\t  icode = (int) optab->handlers[(int) vec_mode].insn_code;\n+\t\t  icode = (int) optab_handler (optab, vec_mode);\n \t\t  if (icode == CODE_FOR_nothing)\n \t\t    {\n \t\t      if (vect_print_dump_info (REPORT_SLP))"}, {"sha": "b9da57e402b67d68515156603b6eca854c10da1f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=947131ba4e351e264f3aa3a7ccd6b0c82bcc7ebd", "patch": "@@ -2181,8 +2181,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  optab = optab_for_tree_code (code, vectype, optab_scalar);\n \t  if (optab\n-\t      && (optab_handler (optab, TYPE_MODE (vectype))->insn_code\n-\t\t  != CODE_FOR_nothing))\n+\t      && optab_handler (optab, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n \t    {\n \t      scalar_shift_arg = true;\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2192,7 +2191,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t    {\n \t      optab = optab_for_tree_code (code, vectype, optab_vector);\n \t      if (optab\n-\t\t  && (optab_handler (optab, TYPE_MODE (vectype))->insn_code\n+\t\t  && (optab_handler (optab, TYPE_MODE (vectype))\n \t\t      != CODE_FOR_nothing))\n \t\t{\n \t\t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2226,7 +2225,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n-  icode = (int) optab_handler (optab, vec_mode)->insn_code;\n+  icode = (int) optab_handler (optab, vec_mode);\n   if (icode == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3128,7 +3127,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   vec_mode = TYPE_MODE (vectype);\n   /* FORNOW. In some cases can vectorize even if data-type not supported\n      (e.g. - array initialization with 0).  */\n-  if (optab_handler (mov_optab, (int)vec_mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (mov_optab, vec_mode) == CODE_FOR_nothing)\n     return false;\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -3426,7 +3425,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n-  int mode;\n+  enum machine_mode mode;\n   gimple new_stmt = NULL;\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n@@ -3507,11 +3506,11 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     return false;\n \n   scalar_type = TREE_TYPE (DR_REF (dr));\n-  mode = (int) TYPE_MODE (vectype);\n+  mode = TYPE_MODE (vectype);\n \n   /* FORNOW. In some cases can vectorize even if data-type not supported\n     (e.g. - data copies).  */\n-  if (optab_handler (mov_optab, mode)->insn_code == CODE_FOR_nothing)\n+  if (optab_handler (mov_optab, mode) == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"Aligned load, but unsupported type.\");\n@@ -4963,9 +4962,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n     return false;\n \n   vec_mode = TYPE_MODE (vectype);\n-  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n-       || (icode2 = optab_handler (optab2, vec_mode)->insn_code)\n-                                                       == CODE_FOR_nothing)\n+  if ((icode1 = optab_handler (optab1, vec_mode)) == CODE_FOR_nothing\n+       || (icode2 = optab_handler (optab2, vec_mode)) == CODE_FOR_nothing)\n     return false;\n \n   /* Check if it's a multi-step conversion that can be done using intermediate\n@@ -4997,16 +4995,16 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n           optab4 = optab_for_tree_code (c2, intermediate_type, optab_default);\n \n           if (!optab3 || !optab4\n-              || (icode1 = optab1->handlers[(int) prev_mode].insn_code)\n-                                                        == CODE_FOR_nothing\n+              || ((icode1 = optab_handler (optab1, prev_mode))\n+\t\t  == CODE_FOR_nothing)\n               || insn_data[icode1].operand[0].mode != intermediate_mode\n-              || (icode2 = optab2->handlers[(int) prev_mode].insn_code)\n-                                                        == CODE_FOR_nothing\n+              || ((icode2 = optab_handler (optab2, prev_mode))\n+\t\t  == CODE_FOR_nothing)\n               || insn_data[icode2].operand[0].mode != intermediate_mode\n-              || (icode1 = optab3->handlers[(int) intermediate_mode].insn_code)\n-                                                        == CODE_FOR_nothing\n-              || (icode2 = optab4->handlers[(int) intermediate_mode].insn_code)\n-                                                        == CODE_FOR_nothing)\n+              || ((icode1 = optab_handler (optab3, intermediate_mode))\n+\t\t  == CODE_FOR_nothing)\n+              || ((icode2 = optab_handler (optab4, intermediate_mode))\n+\t\t  == CODE_FOR_nothing))\n             return false;\n \n           VEC_quick_push (tree, *interm_types, intermediate_type);\n@@ -5093,8 +5091,7 @@ supportable_narrowing_operation (enum tree_code code,\n     return false;\n \n   vec_mode = TYPE_MODE (vectype);\n-  if ((icode1 = optab_handler (optab1, vec_mode)->insn_code)\n-       == CODE_FOR_nothing)\n+  if ((icode1 = optab_handler (optab1, vec_mode)) == CODE_FOR_nothing)\n     return false;\n \n   /* Check if it's a multi-step conversion that can be done using intermediate\n@@ -5117,12 +5114,11 @@ supportable_narrowing_operation (enum tree_code code,\n           interm_optab = optab_for_tree_code (c1, intermediate_type,\n                                               optab_default);\n           if (!interm_optab\n-              || (icode1 = optab1->handlers[(int) prev_mode].insn_code)\n-                                                        == CODE_FOR_nothing\n+              || ((icode1 = optab_handler (optab1, prev_mode))\n+\t\t  == CODE_FOR_nothing)\n               || insn_data[icode1].operand[0].mode != intermediate_mode\n-              || (icode1\n-                  = interm_optab->handlers[(int) intermediate_mode].insn_code)\n-                 == CODE_FOR_nothing)\n+              || ((icode1 = optab_handler (interm_optab, intermediate_mode))\n+\t\t  == CODE_FOR_nothing))\n             return false;\n \n           VEC_quick_push (tree, *interm_types, intermediate_type);"}]}