{"sha": "123b3e03c911a43054c1f88f5d3110e1d084dd4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzYjNlMDNjOTExYTQzMDU0YzFmODhmNWQzMTEwZTFkMDg0ZGQ0ZQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T17:07:43Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T17:07:43Z"}, "message": "c++: Don't substitute into constraints on lambdas [PR99874]\n\nWe currently substitute through a lambda's constraints whenever we\nregenerate it via tsubst_lambda_expr.  This is the wrong approach\nbecause it can lead to hard errors due to constraints being evaluated\nout of order (as in the testcase concepts-lambda17.C below), and because\nit doesn't mesh well with the recently added REQUIRES_EXPR_EXTRA_ARGS\nmechanism for delaying substitution into requires-expressions, which is\nthe cause of this PR.\n\nBut in order to avoid substituting through a lambda's constraints during\nregeneration, we need to be able to get at all in-scope template\nparameters and corresponding template arguments during constraint\nchecking of a lambda's op().  And this information is not easily\navailable when we need it, it seems.\n\nTo that end, the approach that this patch takes is to add two new fields\nto LAMBDA_EXPR (and remove one): LAMBDA_EXPR_REGENERATED_FROM\n(replacing LAMBDA_EXPR_INSTANTIATED), and LAMBDA_EXPR_REGENERATING_TARGS.\nThe former allows us to obtain the complete set of template parameters\nthat are in-scope for a lambda's op(), and the latter gives us all outer\ntemplate arguments that were used to regenerate the lambda (analogous to\nthe TI_TEMPLATE and TI_ARGS of a TEMPLATE_INFO, respectively).\n\nLAMBDA_EXPR_REGENERATING_TARGS is not strictly necessary -- in an\nearlier prototype, I walked LAMBDA_EXPR_EXTRA_SCOPE to build up this set\nof outer template arguments on demand, but it seems cleaner to do it this\nway.  (We'd need to walk LAMBDA_EXPR_EXTRA_SCOPE and not DECL/TYPE_CONTEXT\nbecause the latter skips over variable template scopes.)\n\nThis patch also renames the predicate instantiated_lambda_fn_p to\nregenerated_lambda_fn_p, for sake of consistency with the rest of the\npatch which uses \"regenerated\" instead of \"instantiated\".\n\ngcc/cp/ChangeLog:\n\n\tPR c++/99874\n\t* constraint.cc (get_normalized_constraints_from_decl): Handle\n\tregenerated lambdas.\n\t(satisfy_declaration_constraints): Likewise.  Check for\n\tdependent args later.\n\t* cp-tree.h (LAMBDA_EXPR_INSTANTIATED): Replace with ...\n\t(LAMBDA_EXPR_REGENERATED_FROM): ... this.\n\t(LAMBDA_EXPR_REGENERATING_TARGS): New.\n\t(tree_lambda_expr::regenerated_from): New data member.\n\t(tree_lambda_expr::regenerating_targs): New data member.\n\t(add_to_template_args): Declare.\n\t(regenerated_lambda_fn_p): Likewise.\n\t(most_general_lambda): Likewise.\n\t* lambda.c (build_lambda_expr): Set LAMBDA_EXPR_REGENERATED_FROM\n\tand LAMBDA_EXPR_REGENERATING_TARGS.\n\t* pt.c (add_to_template_args): No longer static.\n\t(tsubst_function_decl): Unconditionally propagate constraints on\n\tthe substituted function decl.\n\t(instantiated_lambda_fn_p): Rename to ...\n\t(regenerated_lambda_fn_p): ... this.  Check\n\tLAMBDA_EXPR_REGENERATED_FROM instead of\n\tLAMBDA_EXPR_INSTANTIATED.\n\t(most_general_lambda): Define.\n\t(enclosing_instantiation_of): Adjust after renaming\n\tinstantiated_lambda_fn_p.\n\t(tsubst_lambda_expr): Don't set LAMBDA_EXPR_INSTANTIATED.  Set\n\tLAMBDA_EXPR_REGENERATED_FROM and LAMBDA_EXPR_REGENERATING_TARGS.\n\tDon't substitute or set constraints on the regenerated lambda.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/99874\n\t* g++.dg/cpp2a/concepts-lambda16.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda17.C: New test.", "tree": {"sha": "060c0876ab31fd31f0a892da209e32acdabd178a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/060c0876ab31fd31f0a892da209e32acdabd178a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/123b3e03c911a43054c1f88f5d3110e1d084dd4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123b3e03c911a43054c1f88f5d3110e1d084dd4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/123b3e03c911a43054c1f88f5d3110e1d084dd4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123b3e03c911a43054c1f88f5d3110e1d084dd4e/comments", "author": null, "committer": null, "parents": [{"sha": "05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8"}], "stats": {"total": 182, "additions": 150, "deletions": 32}, "files": [{"sha": "0a9d1bfea0fb8a03e8e77d2de162da120972f072", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -886,6 +886,16 @@ get_normalized_constraints_from_decl (tree d, bool diag = false)\n      it has the correct template information attached. */\n   d = strip_inheriting_ctors (d);\n \n+  if (regenerated_lambda_fn_p (d))\n+    {\n+      /* If this lambda was regenerated, DECL_TEMPLATE_PARMS doesn't contain\n+\t all in-scope template parameters, but the lambda from which it was\n+\t ultimately regenerated does, so use that instead.  */\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (d));\n+      lambda = most_general_lambda (lambda);\n+      d = lambda_function (lambda);\n+    }\n+\n   if (TREE_CODE (d) == TEMPLATE_DECL)\n     {\n       tmpl = d;\n@@ -3174,13 +3184,27 @@ satisfy_declaration_constraints (tree t, sat_info info)\n       args = TI_ARGS (ti);\n       if (inh_ctor_targs)\n \targs = add_outermost_template_args (args, inh_ctor_targs);\n+    }\n \n-      /* If any arguments depend on template parameters, we can't\n-\t check constraints. Pretend they're satisfied for now.  */\n-      if (uses_template_parms (args))\n-\treturn boolean_true_node;\n+  if (regenerated_lambda_fn_p (t))\n+    {\n+      /* The TI_ARGS of a regenerated lambda contains only the innermost\n+\t set of template arguments.  Augment this with the outer template\n+\t arguments that were used to regenerate the lambda.  */\n+      gcc_assert (!args || TMPL_ARGS_DEPTH (args) == 1);\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (t));\n+      tree outer_args = LAMBDA_EXPR_REGENERATING_TARGS (lambda);\n+      if (args)\n+\targs = add_to_template_args (outer_args, args);\n+      else\n+\targs = outer_args;\n     }\n \n+  /* If any arguments depend on template parameters, we can't\n+     check constraints. Pretend they're satisfied for now.  */\n+  if (uses_template_parms (args))\n+    return boolean_true_node;\n+\n   /* Get the normalized constraints.  */\n   tree norm = get_normalized_constraints_from_decl (t, info.noisy ());\n \n@@ -3227,7 +3251,16 @@ satisfy_declaration_constraints (tree t, tree args, sat_info info)\n \n   gcc_assert (TREE_CODE (t) == TEMPLATE_DECL);\n \n-  args = add_outermost_template_args (t, args);\n+  if (regenerated_lambda_fn_p (t))\n+    {\n+      /* As in the two-parameter version of this function.  */\n+      gcc_assert (TMPL_ARGS_DEPTH (args) == 1);\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (t));\n+      tree outer_args = LAMBDA_EXPR_REGENERATING_TARGS (lambda);\n+      args = add_to_template_args (outer_args, args);\n+    }\n+  else\n+    args = add_outermost_template_args (t, args);\n \n   /* If any arguments depend on template parameters, we can't\n      check constraints. Pretend they're satisfied for now.  */"}, {"sha": "bf9d5add0cf07a13e2ec70b89b3d6c533af14741", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -490,7 +490,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECLTYPE_FOR_REF_CAPTURE (in DECLTYPE_TYPE)\n       CONSTRUCTOR_C99_COMPOUND_LITERAL (in CONSTRUCTOR)\n       OVL_NESTED_P (in OVERLOAD)\n-      LAMBDA_EXPR_INSTANTIATED (in LAMBDA_EXPR)\n       DECL_MODULE_EXPORT_P (in _DECL)\n    4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n@@ -1434,10 +1433,6 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_CAPTURE_OPTIMIZED(NODE) \\\n   TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n \n-/* True iff this LAMBDA_EXPR was generated in tsubst_lambda_expr.  */\n-#define LAMBDA_EXPR_INSTANTIATED(NODE) \\\n-  TREE_LANG_FLAG_3 (LAMBDA_EXPR_CHECK (NODE))\n-\n /* True if this TREE_LIST in LAMBDA_EXPR_CAPTURE_LIST is for an explicit\n    capture.  */\n #define LAMBDA_CAPTURE_EXPLICIT_P(NODE) \\\n@@ -1461,6 +1456,16 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_PENDING_PROXIES(NODE) \\\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->pending_proxies)\n \n+/* The immediate LAMBDA_EXPR from which NODE was regenerated, or NULL_TREE\n+   (if NODE was not regenerated via tsubst_lambda_expr).  */\n+#define LAMBDA_EXPR_REGENERATED_FROM(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->regenerated_from)\n+\n+/* The full set of template arguments used to regenerate NODE, or NULL_TREE\n+   (if NODE was not regenerated via tsubst_lambda_expr).  */\n+#define LAMBDA_EXPR_REGENERATING_TARGS(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->regenerating_targs)\n+\n /* The closure type of the lambda, which is also the type of the\n    LAMBDA_EXPR.  */\n #define LAMBDA_EXPR_CLOSURE(NODE) \\\n@@ -1472,6 +1477,8 @@ struct GTY (()) tree_lambda_expr\n   tree capture_list;\n   tree this_capture;\n   tree extra_scope;\n+  tree regenerated_from;\n+  tree regenerating_targs;\n   vec<tree, va_gc> *pending_proxies;\n   location_t locus;\n   enum cp_lambda_default_capture_mode_type default_capture_mode : 8;\n@@ -7247,6 +7254,7 @@ extern unsigned get_mergeable_specialization_flags (tree tmpl, tree spec);\n extern void add_mergeable_specialization        (bool is_decl, bool is_alias,\n \t\t\t\t\t\t spec_entry *,\n \t\t\t\t\t\t tree outer, unsigned);\n+extern tree add_to_template_args\t\t(tree, tree);\n extern tree add_outermost_template_args\t\t(tree, tree);\n extern tree add_extra_args\t\t\t(tree, tree);\n extern tree build_extra_args\t\t\t(tree, tree, tsubst_flags_t);\n@@ -7557,6 +7565,8 @@ extern void record_null_lambda_scope\t\t(tree);\n extern void finish_lambda_scope\t\t\t(void);\n extern tree start_lambda_function\t\t(tree fn, tree lambda_expr);\n extern void finish_lambda_function\t\t(tree body);\n+extern bool regenerated_lambda_fn_p\t\t(tree);\n+extern tree most_general_lambda\t\t\t(tree);\n \n /* in tree.c */\n extern int cp_tree_operand_length\t\t(const_tree);"}, {"sha": "c0a5ffb427e70fed3f31249a81670bf9ddbe1086", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -41,6 +41,8 @@ build_lambda_expr (void)\n   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) = CPLD_NONE;\n   LAMBDA_EXPR_CAPTURE_LIST         (lambda) = NULL_TREE;\n   LAMBDA_EXPR_THIS_CAPTURE         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_REGENERATED_FROM     (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_REGENERATING_TARGS   (lambda) = NULL_TREE;\n   LAMBDA_EXPR_PENDING_PROXIES      (lambda) = NULL;\n   LAMBDA_EXPR_MUTABLE_P            (lambda) = false;\n   return lambda;"}, {"sha": "daf1b5aeb32aaee08498eb2b67d7cdf431897568", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -151,7 +151,6 @@ static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,\n static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t\t      bool, bool);\n static void tsubst_enum\t(tree, tree, tree);\n-static tree add_to_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int check_non_deducible_conversion (tree, tree, int, int,\n \t\t\t\t\t   struct conversion **, bool);\n@@ -553,7 +552,7 @@ maybe_end_member_template_processing (void)\n /* Return a new template argument vector which contains all of ARGS,\n    but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n-static tree\n+tree\n add_to_template_args (tree args, tree extra_args)\n {\n   tree new_args;\n@@ -14065,10 +14064,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n      don't substitute through the constraints; that's only done when\n      they are checked.  */\n   if (tree ci = get_constraints (t))\n-    /* Unless we're regenerating a lambda, in which case we'll set the\n-       lambda's constraints in tsubst_lambda_expr.  */\n-    if (!lambda_fntype)\n-      set_constraints (r, ci);\n+    set_constraints (r, ci);\n \n   if (DECL_FRIEND_CONTEXT (t))\n     SET_DECL_FRIEND_CONTEXT (r,\n@@ -14354,13 +14350,24 @@ lambda_fn_in_template_p (tree fn)\n    which the above is true.  */\n \n bool\n-instantiated_lambda_fn_p (tree fn)\n+regenerated_lambda_fn_p (tree fn)\n {\n   if (!fn || !LAMBDA_FUNCTION_P (fn))\n     return false;\n   tree closure = DECL_CONTEXT (fn);\n   tree lam = CLASSTYPE_LAMBDA_EXPR (closure);\n-  return LAMBDA_EXPR_INSTANTIATED (lam);\n+  return LAMBDA_EXPR_REGENERATED_FROM (lam) != NULL_TREE;\n+}\n+\n+/* Return the LAMBDA_EXPR from which T was ultimately regenerated.\n+   If T is not a regenerated LAMBDA_EXPR, return T.  */\n+\n+tree\n+most_general_lambda (tree t)\n+{\n+  while (LAMBDA_EXPR_REGENERATED_FROM (t))\n+    t = LAMBDA_EXPR_REGENERATED_FROM (t);\n+  return t;\n }\n \n /* We're instantiating a variable from template function TCTX.  Return the\n@@ -14376,7 +14383,7 @@ enclosing_instantiation_of (tree otctx)\n   int lambda_count = 0;\n \n   for (; tctx && (lambda_fn_in_template_p (tctx)\n-\t\t  || instantiated_lambda_fn_p (tctx));\n+\t\t  || regenerated_lambda_fn_p (tctx));\n        tctx = decl_function_context (tctx))\n     ++lambda_count;\n \n@@ -14396,7 +14403,7 @@ enclosing_instantiation_of (tree otctx)\n     {\n       tree ofn = fn;\n       int flambda_count = 0;\n-      for (; fn && instantiated_lambda_fn_p (fn);\n+      for (; fn && regenerated_lambda_fn_p (fn);\n \t   fn = decl_function_context (fn))\n \t++flambda_count;\n       if ((fn && DECL_TEMPLATE_INFO (fn))\n@@ -19271,7 +19278,9 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)\n     = LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (t);\n   LAMBDA_EXPR_MUTABLE_P (r) = LAMBDA_EXPR_MUTABLE_P (t);\n-  LAMBDA_EXPR_INSTANTIATED (r) = true;\n+  LAMBDA_EXPR_REGENERATED_FROM (r) = t;\n+  LAMBDA_EXPR_REGENERATING_TARGS (r)\n+    = add_to_template_args (LAMBDA_EXPR_REGENERATING_TARGS (t), args);\n \n   gcc_assert (LAMBDA_EXPR_THIS_CAPTURE (t) == NULL_TREE\n \t      && LAMBDA_EXPR_PENDING_PROXIES (t) == NULL);\n@@ -19413,17 +19422,6 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  finish_member_declaration (fn);\n \t}\n \n-      if (tree ci = get_constraints (oldfn))\n-\t{\n-\t  /* Substitute into the lambda's constraints.  */\n-\t  if (oldtmpl)\n-\t    ++processing_template_decl;\n-\t  ci = tsubst_constraint_info (ci, args, complain, in_decl);\n-\t  if (oldtmpl)\n-\t    --processing_template_decl;\n-\t  set_constraints (fn, ci);\n-\t}\n-\n       /* Let finish_function set this.  */\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;\n "}, {"sha": "01fda6efb386b56031a0486fd85ca354db6c9c95", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda16.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda16.C?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -0,0 +1,61 @@\n+// PR c++/99874\n+// { dg-do compile { target c++20 } }\n+\n+template <class T>\n+struct A {\n+  static inline auto a = [] <class U> (U) {\n+    return [] <class V> (V) requires requires (T t, U u, V v) { t + u + v; } { };\n+  };\n+\n+  template <class W>\n+  static inline auto b = [] <class U> (U) {\n+    return [] <class V> (V) requires requires (T t, U u, V v, W w) { t + u + v + w; } { };\n+  };\n+\n+  static auto f() {\n+    return [] <class U> (U) {\n+      return [] <class V> (V) requires requires (T t, U u, V v) { t + u + v; } { };\n+    };\n+  }\n+\n+  template <class W>\n+  static auto g() {\n+    return [] <class U> (U) {\n+      return [] <class V> (V) requires requires (T t, U u, V v, W w) { t + u + v + w; } { };\n+    };\n+  }\n+};\n+\n+template <class T>\n+auto a = [] <class U> (U) {\n+  return [] <class V> (V) requires requires (T t, U u, V v) { t + u + v; } { };\n+};\n+\n+template <class T>\n+auto b = [] <class U> (U) {\n+  return [] <class V> (V) {\n+    return [] {\n+      return [] () requires requires (T t, U u, V v) { t + u + v; } { };\n+    };\n+  };\n+};\n+\n+int main() {\n+  A<int>::a(0)(0);\n+  A<int>::a(0)(nullptr); // { dg-error \"no match\" }\n+\n+  A<int>::b<int>(0)(0);\n+  A<int>::b<int>(0)(nullptr); // { dg-error \"no match\" }\n+\n+  A<int>::f()(0)(0);\n+  A<int>::f()(0)(nullptr); // { dg-error \"no match\" }\n+\n+  A<int>::g<int>()(0)(0);\n+  A<int>::g<int>()(0)(nullptr); // { dg-error \"no match\" }\n+\n+  a<int>(0)(0);\n+  a<int>(0)(nullptr); // { dg-error \"no match\" }\n+\n+  b<int>(0)(0)();\n+  b<int>(0)(nullptr)()(); // { dg-error \"no match\" }\n+}"}, {"sha": "32ae1e121748bb3073cf804be8fc1018ef549cdc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda17.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123b3e03c911a43054c1f88f5d3110e1d084dd4e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda17.C?ref=123b3e03c911a43054c1f88f5d3110e1d084dd4e", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++20 } }\n+\n+template<class T>\n+struct A { static const bool value = T::value; };\n+\n+template<class T>\n+void f() {\n+  // Verify we don't substitute into a lambda's constraints when\n+  // regenerating it, which would lead to a hard error here.\n+  [] () requires (T::value && A<T>::value) || true { }();\n+  [] <class U> (U) requires (U::value && A<T>::value) || true { }(0);\n+}\n+\n+template void f<int>();"}]}