{"sha": "43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMzMjA1NjhiMjY1ZDZmMDQ0OGU2ZjhhZTdlNmE4YWNlM2ExM2JlMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-02-12T14:04:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-02-12T14:04:44Z"}, "message": "re PR lto/56295 (Missed optimization with LTO)\n\n2013-02-12  Richard Biener  <rguenther@suse.de>\n\n\tPR lto/56295\n\t* gimple-streamer-in.c (input_gimple_stmt): Strip MEM_REFs off\n\tdecls again if possible.\n\nFrom-SVN: r195976", "tree": {"sha": "3082c24d5254dce6d42804d8a47b5524c23c656d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3082c24d5254dce6d42804d8a47b5524c23c656d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43320568b265d6f0448e6f8ae7e6a8ace3a13be0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fdb1fa9ebe52bb178f41a27ea5b55b5c17d1aa3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb1fa9ebe52bb178f41a27ea5b55b5c17d1aa3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb1fa9ebe52bb178f41a27ea5b55b5c17d1aa3c"}], "stats": {"total": 59, "additions": 41, "deletions": 18}, "files": [{"sha": "a0ced1db78cdc38d9ddd74cb1f23e3863e003c8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43320568b265d6f0448e6f8ae7e6a8ace3a13be0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43320568b265d6f0448e6f8ae7e6a8ace3a13be0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "patch": "@@ -1,3 +1,9 @@\n+2013-02-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR lto/56295\n+\t* gimple-streamer-in.c (input_gimple_stmt): Strip MEM_REFs off\n+\tdecls again if possible.\n+\n 2013-02-12  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/56288"}, {"sha": "aff589a4c8feb86f027bfd2d75894f7380a46141", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43320568b265d6f0448e6f8ae7e6a8ace3a13be0/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43320568b265d6f0448e6f8ae7e6a8ace3a13be0/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "patch": "@@ -143,22 +143,23 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n     case GIMPLE_DEBUG:\n       for (i = 0; i < num_ops; i++)\n \t{\n-\t  tree op = stream_read_tree (ib, data_in);\n+\t  tree *opp, op = stream_read_tree (ib, data_in);\n \t  gimple_set_op (stmt, i, op);\n \t  if (!op)\n \t    continue;\n \n-\t  if (TREE_CODE (op) == ADDR_EXPR)\n-\t    op = TREE_OPERAND (op, 0);\n-\t  while (handled_component_p (op))\n+\t  opp = gimple_op_ptr (stmt, i);\n+\t  if (TREE_CODE (*opp) == ADDR_EXPR)\n+\t    opp = &TREE_OPERAND (*opp, 0);\n+\t  while (handled_component_p (*opp))\n \t    {\n-\t      if (TREE_CODE (op) == COMPONENT_REF)\n+\t      if (TREE_CODE (*opp) == COMPONENT_REF)\n \t\t{\n \t\t  /* Fixup FIELD_DECLs in COMPONENT_REFs, they are not handled\n \t\t     by decl merging.  */\n \t\t  tree field, type, tem;\n \t\t  tree closest_match = NULL_TREE;\n-\t\t  field = TREE_OPERAND (op, 1);\n+\t\t  field = TREE_OPERAND (*opp, 1);\n \t\t  type = DECL_CONTEXT (field);\n \t\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n \t\t    {\n@@ -186,12 +187,12 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t      if (warning_at (gimple_location (stmt), 0,\n \t\t\t\t      \"use of type %<%E%> with two mismatching \"\n \t\t\t\t      \"declarations at field %<%E%>\",\n-\t\t\t\t      type, TREE_OPERAND (op, 1)))\n+\t\t\t\t      type, TREE_OPERAND (*opp, 1)))\n \t\t\t{\n \t\t\t  if (TYPE_FIELDS (type))\n \t\t\t    inform (DECL_SOURCE_LOCATION (TYPE_FIELDS (type)),\n \t\t\t\t    \"original type declared here\");\n-\t\t\t  inform (DECL_SOURCE_LOCATION (TREE_OPERAND (op, 1)),\n+\t\t\t  inform (DECL_SOURCE_LOCATION (TREE_OPERAND (*opp, 1)),\n \t\t\t\t  \"field in mismatching type declared here\");\n \t\t\t  if (TYPE_NAME (TREE_TYPE (field))\n \t\t\t      && (TREE_CODE (TYPE_NAME (TREE_TYPE (field)))\n@@ -208,28 +209,44 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t\t\t    \"type of mismatching field declared here\");\n \t\t\t}\n \t\t      /* And finally fixup the types.  */\n-\t\t      TREE_OPERAND (op, 0)\n+\t\t      TREE_OPERAND (*opp, 0)\n \t\t\t= build1 (VIEW_CONVERT_EXPR, type,\n-\t\t\t\t  TREE_OPERAND (op, 0));\n+\t\t\t\t  TREE_OPERAND (*opp, 0));\n \t\t    }\n \t\t  else\n-\t\t    TREE_OPERAND (op, 1) = tem;\n+\t\t    TREE_OPERAND (*opp, 1) = tem;\n \t\t}\n-\t      else if ((TREE_CODE (op) == ARRAY_REF\n-\t\t\t|| TREE_CODE (op) == ARRAY_RANGE_REF)\n-\t\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (op, 0)))\n+\t      else if ((TREE_CODE (*opp) == ARRAY_REF\n+\t\t\t|| TREE_CODE (*opp) == ARRAY_RANGE_REF)\n+\t\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (*opp, 0)))\n \t\t\t   != ARRAY_TYPE))\n \t\t{\n \t\t  /* And ARRAY_REFs to objects that had mismatched types\n \t\t     during symbol merging to avoid ICEs.  */\n-\t\t  TREE_OPERAND (op, 0)\n+\t\t  TREE_OPERAND (*opp, 0)\n \t\t    = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t      build_array_type (TREE_TYPE (op), NULL_TREE),\n-\t\t\t      TREE_OPERAND (op, 0));\n+\t\t\t      build_array_type (TREE_TYPE (*opp), NULL_TREE),\n+\t\t\t      TREE_OPERAND (*opp, 0));\n \t\t}\n \n-\t      op = TREE_OPERAND (op, 0);\n+\t      opp = &TREE_OPERAND (*opp, 0);\n \t    }\n+\t  /* At LTO output time we wrap all global decls in MEM_REFs to\n+\t     allow seamless replacement with prevailing decls.  Undo this\n+\t     here if the prevailing decl allows for this.\n+\t     ???  Maybe we should simply fold all stmts.  */\n+\t  if (TREE_CODE (*opp) == MEM_REF\n+\t      && TREE_CODE (TREE_OPERAND (*opp, 0)) == ADDR_EXPR\n+\t      && integer_zerop (TREE_OPERAND (*opp, 1))\n+\t      && (TREE_THIS_VOLATILE (*opp)\n+\t\t  == TREE_THIS_VOLATILE\n+\t\t       (TREE_OPERAND (TREE_OPERAND (*opp, 0), 0)))\n+\t      && !TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (*opp, 1)))\n+\t      && (TREE_TYPE (*opp)\n+\t\t  == TREE_TYPE (TREE_TYPE (TREE_OPERAND (*opp, 1))))\n+\t      && (TREE_TYPE (*opp)\n+\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*opp, 0), 0))))\n+\t    *opp = TREE_OPERAND (TREE_OPERAND (*opp, 0), 0);\n \t}\n       if (is_gimple_call (stmt))\n \t{"}]}