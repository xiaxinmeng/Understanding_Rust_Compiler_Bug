{"sha": "dc0b3eff7222829d8ae75f4791aa16e617a03f23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwYjNlZmY3MjIyODI5ZDhhZTc1ZjQ3OTFhYTE2ZTYxN2EwM2YyMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T16:33:22Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T16:33:22Z"}, "message": "Force left-to-right evaluation of binary operations etc.\n\nd\n\tForce left-to-right evaluation of binary operations etc.\n\t* expr.c (force_evaluation_order), java-tree.h:  New function.\n\t* parse.y (java_complete_lhs):  Pass binary operations, procedure\n\tcalls, and ARRAY_REFs to force_evaluation_order.\n\t(various):  Set TREE_SIDE_EFFECTS more carefully.\n\tTolerate random (non-UTF8) encoding in comments without complaining.\n\t* lex.c (java_read_char):  Return 0xFFFE if bad UTF8 encoding.\n\t(java_is_eol):  Handle '\\r' followed by '\\n' instead of vice versa.\n\t* parse.y (resolve_qualified_expression_name):  Handle error_mark.\n\t(java_complete_node case EXPR_WITH_FILE_LOCATION):  Likewise.\n\t* parse.y (java_complete_lhs):  Ignore an empty statement in a\n\tCOMPOUND_EXPR.  Don't complain about empty statement after return.\n\nFrom-SVN: r25328", "tree": {"sha": "eba87d455cc8640b3e17a6c95b007f65a6035406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba87d455cc8640b3e17a6c95b007f65a6035406"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc0b3eff7222829d8ae75f4791aa16e617a03f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0b3eff7222829d8ae75f4791aa16e617a03f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0b3eff7222829d8ae75f4791aa16e617a03f23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0b3eff7222829d8ae75f4791aa16e617a03f23/comments", "author": null, "committer": null, "parents": [{"sha": "68ae3b17eb0110b389d4caa7eee9c433843e7c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ae3b17eb0110b389d4caa7eee9c433843e7c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ae3b17eb0110b389d4caa7eee9c433843e7c73"}], "stats": {"total": 93, "additions": 59, "deletions": 34}, "files": [{"sha": "98606cc3021122723714332e81824d760f44c6ef", "filename": "gcc/java/lex.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0b3eff7222829d8ae75f4791aa16e617a03f23/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0b3eff7222829d8ae75f4791aa16e617a03f23/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=dc0b3eff7222829d8ae75f4791aa16e617a03f23", "patch": "@@ -197,6 +197,8 @@ java_allocate_new_line ()\n   ctxp->c_line->white_space_only = 1;\n }\n \n+#define BAD_UTF8_VALUE 0xFFFE\n+\n static unicode_t\n java_read_char ()\n {\n@@ -235,9 +237,8 @@ java_read_char ()\n \t\t\t\t   (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n \t    }\n \t}\n-      java_lex_error (\"Bad utf8 encoding\", 0);\n+      return BAD_UTF8_VALUE;\n     }\n-  return 0;\n }\n \n static void\n@@ -1312,12 +1313,12 @@ java_is_eol (fp, c)\n   int next;\n   switch (c)\n     {\n-    case '\\n':\n+    case '\\r':\n       next = getc (fp);\n-      if (next != '\\r' && next != EOF)\n+      if (next != '\\n' && next != EOF)\n \tungetc (next, fp);\n       return 1;\n-    case '\\r':\n+    case '\\n':\n       return 1;\n     default:\n       return 0;"}, {"sha": "b548ad1b1a1185b12cf1de063579e14b533bc433", "filename": "gcc/java/parse.y", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0b3eff7222829d8ae75f4791aa16e617a03f23/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0b3eff7222829d8ae75f4791aa16e617a03f23/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=dc0b3eff7222829d8ae75f4791aa16e617a03f23", "patch": "@@ -6450,15 +6450,18 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t  return 1;\n \t\t}\n \t      \n-\t      if (!(field_decl = \n-\t\t    lookup_field_wrapper (type, EXPR_WFL_NODE (qual_wfl))))\n+\t      field_decl = lookup_field_wrapper (type,\n+\t\t\t\t\t\t EXPR_WFL_NODE (qual_wfl));\n+\t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context \n \t\t    (qual_wfl, \"No variable `%s' defined in class `%s'\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)), \n \t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t\t  return 1;\n \t\t}\n+\t      if (field_decl == error_mark_node)\n+\t\treturn 1;\n \n \t      /* Layout the type of field_decl, since we may need\n                  it. Don't do primitive types or loaded classes. The\n@@ -7576,7 +7579,8 @@ java_complete_lhs (node)\n \t  /* Now do the actual complete, without deep recursion for\n              long blocks. */\n \t  ptr = &BLOCK_EXPR_BODY (node);\n-\t  while (TREE_CODE (*ptr) == COMPOUND_EXPR)\n+\t  while (TREE_CODE (*ptr) == COMPOUND_EXPR\n+\t\t && TREE_OPERAND (*ptr, 1) != empty_stmt_node)\n \t    {\n \t      tree cur = java_complete_tree (TREE_OPERAND (*ptr, 0));\n \t      tree *next = &TREE_OPERAND (*ptr, 1);\n@@ -7596,8 +7600,7 @@ java_complete_lhs (node)\n \t\t\tbreak;\n \t\t    }\n \t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n-\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR\n-\t\t      && wfl_op2 != empty_stmt_node)\n+\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n \t\t    unreachable_stmt_error (*ptr);\n \t\t}\n \t      ptr = next;\n@@ -7787,26 +7790,30 @@ java_complete_lhs (node)\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 0) = nn = \n \tjava_complete_tree (TREE_OPERAND (node, 0));\n-      if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK\n-\t  && wfl_op2 != empty_stmt_node)\n-\t{\n-\t  /* An unreachable condition in a do-while statement\n-\t     is *not* (technically) an unreachable statement. */\n-\t  nn = wfl_op2;\n-\t  if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n-\t    nn = EXPR_WFL_NODE (nn);\n-\t  if (TREE_CODE (nn) != EXIT_EXPR)\n+      if (wfl_op2 == empty_stmt_node)\n+\tCAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (nn);\n+      else\n+\t{\n+\t  if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK)\n \t    {\n-\t      SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n-\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t      /* An unreachable condition in a do-while statement\n+\t\t is *not* (technically) an unreachable statement. */\n+\t      nn = wfl_op2;\n+\t      if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n+\t\tnn = EXPR_WFL_NODE (nn);\n+\t      if (TREE_CODE (nn) != EXIT_EXPR)\n+\t\t{\n+\t\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t\t  parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t\t}\n \t    }\n+\t  TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n+\t  if (TREE_OPERAND (node, 1) == error_mark_node)\n+\t    return error_mark_node;\n+\t  CAN_COMPLETE_NORMALLY (node)\n+\t    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n \t}\n-      TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n-      if (TREE_OPERAND (node, 1) == error_mark_node)\n-\treturn error_mark_node;\n       TREE_TYPE (node) = TREE_TYPE (TREE_OPERAND (node, 1));\n-      CAN_COMPLETE_NORMALLY (node)\n-\t= CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n       break;\n \n     case RETURN_EXPR:\n@@ -7818,6 +7825,8 @@ java_complete_lhs (node)\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n \t{\n \t  node = resolve_expression_name (node, NULL);\n+\t  if (node == error_mark_node)\n+\t    return node;\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t}\n       else\n@@ -7828,9 +7837,9 @@ java_complete_lhs (node)\n \t  body = java_complete_tree (EXPR_WFL_NODE (node));\n \t  lineno = save_lineno;\n \t  EXPR_WFL_NODE (node) = body;\n-\t  TREE_SIDE_EFFECTS (node) = 1;\n+\t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n-\t  if (EXPR_WFL_NODE (node) == error_mark_node)\n+\t  if (body == error_mark_node)\n \t    {\n \t      /* Its important for the evaluation of assignment that\n \t\t this mark on the TREE_TYPE is propagated. */\n@@ -7892,7 +7901,7 @@ java_complete_lhs (node)\n \t      tree_cons (wfl, decl, \n \t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n-\t  return node;\n+\t  return force_evaluation_order (node);\n \t}\n \n     case MODIFY_EXPR:\n@@ -8001,7 +8010,7 @@ java_complete_lhs (node)\n \t  if (TREE_OPERAND (node, 1) == error_mark_node)\n \t    return error_mark_node;\n \t}\n-      return patch_binop (node, wfl_op1, wfl_op2);\n+      return force_evaluation_order (patch_binop (node, wfl_op1, wfl_op2));\n \n     case INSTANCEOF_EXPR:\n       wfl_op1 = TREE_OPERAND (node, 0);\n@@ -8044,7 +8053,7 @@ java_complete_lhs (node)\n \treturn error_mark_node;\n       if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n-      return patch_array_ref (node);\n+      return force_evaluation_order (patch_array_ref (node));\n \n     case RECORD_TYPE:\n       return node;;\n@@ -8971,6 +8980,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t{\n \t  tree mod = build_java_binop (TRUNC_MOD_EXPR, prom_type, op1, op2);\n \t  COMPOUND_ASSIGN_P (mod) = COMPOUND_ASSIGN_P (node);\n+\t  TREE_SIDE_EFFECTS (mod)\n+\t    = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \t  return mod;\n \t}\n       break;\n@@ -9057,6 +9068,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  to_return = convert (prom_type, node);\n \t  /* Copy the original value of the COMPOUND_ASSIGN_P flag */\n \t  COMPOUND_ASSIGN_P (to_return) = COMPOUND_ASSIGN_P (node);\n+\t  TREE_SIDE_EFFECTS (to_return)\n+\t    = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \t  return to_return;\n \t}\n       break;\n@@ -9091,6 +9104,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  else if (flag_emit_class_files)\n \t    {\n \t      TREE_OPERAND (node, 1) = op2_type;\n+\t      TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op1);\n \t      return node;\n \t    }\n \t  /* Otherwise we have to invoke instance of to figure it out */\n@@ -9104,7 +9118,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t build_class_ref (op2_type))),\n \t\t       NULL_TREE);\n-\t      TREE_SIDE_EFFECTS (call) = 1;\n+\t      TREE_SIDE_EFFECTS (call) = TREE_SIDE_EFFECTS (op1);\n \t      return call;\n \t    }\n \t}\n@@ -9241,6 +9255,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n   TREE_OPERAND (node, 0) = op1;\n   TREE_OPERAND (node, 1) = op2;\n   TREE_TYPE (node) = prom_type;\n+  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n+  \n   return fold (node);\n }\n \n@@ -9360,6 +9376,8 @@ build_string_concatenation (op1, op2)\n      tree op1, op2;\n {\n   tree result;\n+  int side_effects = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n+\n   \n   /* Try to do some static optimization */\n   if ((result = string_constant_concatenation (op1, op2)))\n@@ -9412,7 +9430,8 @@ build_string_concatenation (op1, op2)\n \n   /* Mark the last node holding a crafted StringBuffer */\n   IS_CRAFTED_STRING_BUFFER_P (op1) = 1;\n-  \n+\n+  TREE_SIDE_EFFECTS (op1) = side_effects;\n   return op1;\n }\n \n@@ -9662,7 +9681,11 @@ patch_unaryop (node, wfl_op)\n \t  error_found = 1;\n \t}\n       else\n-\treturn fold (value);\n+\t{\n+\t  value = fold (value);\n+\t  TREE_SIDE_EFFECTS (value) = TREE_SIDE_EFFECTS (op);\n+\t  return value;\n+\t}\n       break;\n     }\n   \n@@ -9674,6 +9697,7 @@ patch_unaryop (node, wfl_op)\n      CONVERT_EXPR, {POST,PRE}{INCR,DECR}EMENT_EXPR. */\n   TREE_OPERAND (node, 0) = fold (op);\n   TREE_TYPE (node) = prom_type;\n+  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op);\n   return fold (node);\n }\n "}]}