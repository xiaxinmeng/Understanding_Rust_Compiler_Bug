{"sha": "1824da60663b4532199ecd051d8ba6da8995821d", "node_id": "C_kwDOANBUbNoAKDE4MjRkYTYwNjYzYjQ1MzIxOTllY2QwNTFkOGJhNmRhODk5NTgyMWQ", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-13T20:42:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-14T00:24:36Z"}, "message": "c++: local fn and generic lambda [PR97219]\n\nWhen instantiating the op() for a generic lambda, we can no longer do name\nlookup inside function scopes enclosing the lambda, so we need to remember\nthe lookup result from processing the definition of the lambda.  So the code\nin finish_call_expr to throw away the lookup result and instead look it up\nagain at instantiation time needs to be adjusted.  The approach I take is to\nonly discard the result if the local extern comes from dependent scope; once\nthe enclosing function template is instantiated and we're regenerating the\nlambda, then we can remember the result of lookup.  We also need any default\narguments to be instantiated at that point.\n\n\tPR c++/97219\n\ngcc/cp/ChangeLog:\n\n\t* name-lookup.cc (dependent_local_decl_p): New.\n\t* cp-tree.h (dependent_local_decl_p): Declare.\n\t* semantics.cc (finish_call_expr): Use it.\n\t* pt.cc (tsubst_arg_types): Also substitute default args\n\tfor local externs.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1y/lambda-generic-local-fn1.C: New test.", "tree": {"sha": "52bc8b3bc1d5569d87d6895f6d7af0da58d8c59e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52bc8b3bc1d5569d87d6895f6d7af0da58d8c59e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1824da60663b4532199ecd051d8ba6da8995821d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1824da60663b4532199ecd051d8ba6da8995821d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1824da60663b4532199ecd051d8ba6da8995821d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1824da60663b4532199ecd051d8ba6da8995821d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e00ccef6c706a4a4a6446bffaf4111f98d5771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e00ccef6c706a4a4a6446bffaf4111f98d5771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e00ccef6c706a4a4a6446bffaf4111f98d5771"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "e9a3d09ac4c6f360333dc28f5ccc5ab2343457f3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1824da60663b4532199ecd051d8ba6da8995821d", "patch": "@@ -8243,6 +8243,7 @@ extern tree fold_builtin_source_location\t(location_t);\n /* in name-lookup.cc */\n extern tree strip_using_decl                    (tree);\n extern void diagnose_name_conflict\t\t(tree, tree);\n+extern bool dependent_local_decl_p\t\t(tree);\n \n /* Tell the binding oracle what kind of binding we are looking for.  */\n "}, {"sha": "7b0638d316679ab8b93233c95897508f10258c0e", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=1824da60663b4532199ecd051d8ba6da8995821d", "patch": "@@ -8976,4 +8976,22 @@ cp_emit_debug_info_for_using (tree t, tree context)\n     }\n }\n \n+/* True if D is a local declaration in dependent scope.  Assumes that it is\n+   (part of) the current lookup result for its name.  */\n+\n+bool\n+dependent_local_decl_p (tree d)\n+{\n+  if (!DECL_LOCAL_DECL_P (d))\n+    return false;\n+\n+  cxx_binding *b = IDENTIFIER_BINDING (DECL_NAME (d));\n+  cp_binding_level *l = b->scope;\n+  while (!l->this_entity)\n+    l = l->level_chain;\n+  return uses_template_parms (l->this_entity);\n+}\n+\n+\n+\n #include \"gt-cp-name-lookup.h\""}, {"sha": "adc863de702ce089c6f2c15a9857738b262198e4", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=1824da60663b4532199ecd051d8ba6da8995821d", "patch": "@@ -15182,7 +15182,9 @@ tsubst_arg_types (tree arg_types,\n   /* Except that we do substitute default arguments under tsubst_lambda_expr,\n      since the new op() won't have any associated template arguments for us\n      to refer to later.  */\n-  if (lambda_fn_in_template_p (in_decl))\n+  if (lambda_fn_in_template_p (in_decl)\n+      || (in_decl && TREE_CODE (in_decl) == FUNCTION_DECL\n+\t  && DECL_LOCAL_DECL_P (in_decl)))\n     default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl,\n \t\t\t\t\t false/*fn*/, false/*constexpr*/);\n "}, {"sha": "f08c0b6281fba17d9333569ac5e97883e0f36caa", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=1824da60663b4532199ecd051d8ba6da8995821d", "patch": "@@ -2690,13 +2690,13 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \n   if (processing_template_decl)\n     {\n-      /* If FN is a local extern declaration or set thereof, look them up\n-\t again at instantiation time.  */\n+      /* If FN is a local extern declaration (or set thereof) in a template,\n+\t look it up again at instantiation time.  */\n       if (is_overloaded_fn (fn))\n \t{\n \t  tree ifn = get_first_fn (fn);\n \t  if (TREE_CODE (ifn) == FUNCTION_DECL\n-\t      && DECL_LOCAL_DECL_P (ifn))\n+\t      && dependent_local_decl_p (ifn))\n \t    orig_fn = DECL_NAME (ifn);\n \t}\n "}, {"sha": "06919c535d85d730b103cb91c47430bc5fcae91e", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-local-fn1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-local-fn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824da60663b4532199ecd051d8ba6da8995821d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-local-fn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-local-fn1.C?ref=1824da60663b4532199ecd051d8ba6da8995821d", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/97219\n+// { dg-do compile { target c++14 } }\n+\n+struct B;\n+\n+template <typename T>\n+auto f(T *) {\n+  void q(B *, void * = static_cast<T *>(0));\n+  return [](auto *p) { q(p); };\n+}\n+\n+void q(void *) = delete;\n+\n+int main(void) {\n+  B *bp = 0;\n+  f(bp)(bp);\n+}"}]}