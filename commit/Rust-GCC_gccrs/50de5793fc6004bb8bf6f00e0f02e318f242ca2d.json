{"sha": "50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkZTU3OTNmYzYwMDRiYjhiZjZmMDBlMGYwMmUzMThmMjQyY2EyZA==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-08-01T02:51:46Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-08-01T02:51:46Z"}, "message": "Change inchash to name space.\n\nChange class inchash to move into a inchash namespace as requested.\nThe class is now inchash::hash\n\nRename iterative_hstate_expr to inchash::add_expr\n... and convert existing users. It wasn't possible to use hash::,\nbecause that lead to name space conflicts with cp and objc.\n\nSo class inchash is now inchash::hash and iterative_hstate_expr\nis now inchash::add_expr.\n\ngcc/:\n\n2014-07-31  Andi Kleen  <ak@linux.intel.com>\n\n\t* inchash.h (inchash): Change inchash class to namespace.\n\t(class hash): ... Rename from inchash.\n\t(add_object): Move from macro to class template.\n\t* lto-streamer-out.c (hash_tree): Change inchash\n\tto inchash::hash.\n\t* tree.c (build_type_attribute_qual_variant): Dito.\n\t(type_hash_list): Dito.\n\t(attribute_hash_list): Dito.\n\t(iterative_hstate_expr): Rename to inchash::add_expr\n\t(build_range_type_1): Change inchash to inchash::hash\n\tand use hash::add_expr.\n\t(build_array_type_1): Dito.\n\t(build_function_type): Dito\n\t(build_method_type_directly): Dito.\n\t(build_offset_type): Dito.\n\t(build_complex_type): Dito.\n\t(make_vector_type): Dito.\n\t* tree.h (iterative_hash_expr): Dito.\n\ngcc/lto/:\n\n2014-07-31  Andi Kleen  <ak@linux.intel.com>\n\n\t* lto.c (hash_canonical_type): Use inchash::hash\n\tand use inchash::add_expr.\n\t(iterative_hash_canonical_type): Dito.\n\nFrom-SVN: r213394", "tree": {"sha": "9412b4e4e83474bf33e0a8d77c44c60844e63b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9412b4e4e83474bf33e0a8d77c44c60844e63b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/comments", "author": null, "committer": null, "parents": [{"sha": "79ce6d77f62b4ebc1b297a1e170e9acb2f758c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ce6d77f62b4ebc1b297a1e170e9acb2f758c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ce6d77f62b4ebc1b297a1e170e9acb2f758c0d"}], "stats": {"total": 126, "additions": 86, "deletions": 40}, "files": [{"sha": "3bd3e7abde26f0abc61ec184dac251576ae3367f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -1,3 +1,24 @@\n+2014-07-31  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* inchash.h (inchash): Change inchash class to namespace.\n+\t(class hash): ... Rename from inchash.\n+\t(add_object): Move from macro to class template.\n+\t* lto-streamer-out.c (hash_tree): Change inchash\n+\tto inchash::hash.\n+\t* tree.c (build_type_attribute_qual_variant): Dito.\n+\t(type_hash_list): Dito.\n+\t(attribute_hash_list): Dito.\n+\t(iterative_hstate_expr): Rename to inchash::add_expr\n+\t(build_range_type_1): Change inchash to inchash::hash\n+\tand use hash::add_expr.\n+\t(build_array_type_1): Dito.\n+\t(build_function_type): Dito\n+\t(build_method_type_directly): Dito.\n+\t(build_offset_type): Dito.\n+\t(build_complex_type): Dito.\n+\t(make_vector_type): Dito.\n+\t* tree.h (iterative_hash_expr): Dito.\n+\n 2014-07-31  Chen Gang  <gang.chen.5i5j@gmail.com>\n \n \t* gcc.c (do_spec_1): Allocate enough space for saved_suffix."}, {"sha": "c157e302509feeff120fe538d5c273a53e19ce08", "filename": "gcc/inchash.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Finchash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Finchash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finchash.h?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -35,12 +35,15 @@ along with GCC; see the file COPYING3.  If not see\n extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n \n-class inchash\n+namespace inchash\n+{\n+\n+class hash\n {\n  public:\n \n   /* Start incremential hashing, optionally with SEED.  */\n-  inchash (hashval_t seed = 0)\n+  hash (hashval_t seed = 0)\n   {\n     val = seed;\n     bits = 0;\n@@ -83,11 +86,16 @@ class inchash\n   }\n \n   /* Hash in state from other inchash OTHER.  */\n-  void merge (inchash &other)\n+  void merge (hash &other)\n   {\n     merge_hash (other.val);\n   }\n \n+  template<class T> void add_object(T &obj)\n+  {\n+    add (&obj, sizeof(T));\n+  }\n+\n   /* Support for accumulating boolean flags */\n \n   void add_flag (bool flag)\n@@ -105,7 +113,7 @@ class inchash\n      based on their value. This is useful for hashing commutative\n      expressions, so that A+B and B+A get the same hash.  */\n \n-  void add_commutative (inchash &a, inchash &b)\n+  void add_commutative (hash &a, hash &b)\n   {\n     if (a.end() > b.end())\n       {\n@@ -124,6 +132,6 @@ class inchash\n   unsigned bits;\n };\n \n-#define add_object(o) add (&(o), sizeof (o))\n+}\n \n #endif"}, {"sha": "23449f70aeeb62dcbd0f2db8910cf6d30f73160f", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -732,7 +732,7 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n static hashval_t\n hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map, tree t)\n {\n-  inchash hstate;\n+  inchash::hash hstate;\n \n #define visit(SIBLING) \\\n   do { \\"}, {"sha": "fbb9d6b82c1eb1621013945fd0698c304b2de7d3", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -1,3 +1,9 @@\n+2014-07-31  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* lto.c (hash_canonical_type): Use inchash::hash\n+\tand use inchash::add_expr.\n+\t(iterative_hash_canonical_type): Dito.\n+\n 2014-07-30  Richard Biener  <rguenther@suse.de>\n \n \t* lto-streamer.h (lto_write_data): New function."}, {"sha": "7ecdec2580899ba4b3e58b014260e5c034b332ec", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -267,7 +267,7 @@ static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n static unsigned long num_canonical_type_hash_entries;\n static unsigned long num_canonical_type_hash_queries;\n \n-static void iterative_hash_canonical_type (tree type, inchash &hstate);\n+static void iterative_hash_canonical_type (tree type, inchash::hash &hstate);\n static hashval_t gimple_canonical_type_hash (const void *p);\n static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n \n@@ -279,7 +279,7 @@ static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n static hashval_t\n hash_canonical_type (tree type)\n {\n-  inchash hstate;\n+  inchash::hash hstate;\n \n   /* Combine a few common features of types so that types are grouped into\n      smaller sets; when searching for existing matching types to merge,\n@@ -327,9 +327,9 @@ hash_canonical_type (tree type)\n       /* OMP lowering can introduce error_mark_node in place of\n \t random local decls in types.  */\n       if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\titerative_hstate_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), hstate);\n+\tinchash::add_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), hstate);\n       if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\titerative_hstate_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), hstate);\n+\tinchash::add_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), hstate);\n     }\n \n   /* Recurse for aggregates with a single element type.  */\n@@ -380,7 +380,7 @@ hash_canonical_type (tree type)\n /* Returning a hash value for gimple type TYPE combined with VAL.  */\n \n static void\n-iterative_hash_canonical_type (tree type, inchash &hstate)\n+iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n {\n   hashval_t v;\n   /* An already processed type.  */"}, {"sha": "074be6ee2e3fcfe6a0a7ab2805b53774aede8cab", "filename": "gcc/tree.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -231,8 +231,8 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n static int type_hash_marked_p (const void *);\n-static void type_hash_list (const_tree, inchash &);\n-static void attribute_hash_list (const_tree, inchash &);\n+static void type_hash_list (const_tree, inchash::hash &);\n+static void attribute_hash_list (const_tree, inchash::hash &);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -4593,7 +4593,7 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n {\n   if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n-      inchash hstate;\n+      inchash::hash hstate;\n       tree ntype;\n       int i;\n       tree t;\n@@ -6631,7 +6631,7 @@ decl_debug_args_insert (tree from)\n    of the individual types.  */\n \n static void\n-type_hash_list (const_tree list, inchash &hstate)\n+type_hash_list (const_tree list, inchash::hash &hstate)\n {\n   const_tree tail;\n \n@@ -6866,7 +6866,7 @@ print_type_hash_statistics (void)\n    by adding the hash codes of the individual attributes.  */\n \n static void\n-attribute_hash_list (const_tree list, inchash &hstate)\n+attribute_hash_list (const_tree list, inchash::hash &hstate)\n {\n   const_tree tail;\n \n@@ -7384,13 +7384,16 @@ commutative_ternary_tree_code (enum tree_code code)\n   return false;\n }\n \n+namespace inchash\n+{\n+\n /* Generate a hash value for an expression.  This can be used iteratively\n    by passing a previous result as the HSTATE argument.\n \n    This function is intended to produce the same hash for expressions which\n    would compare equal using operand_equal_p.  */\n void\n-iterative_hstate_expr (const_tree t, inchash &hstate)\n+add_expr (const_tree t, inchash::hash &hstate)\n {\n   int i;\n   enum tree_code code;\n@@ -7431,14 +7434,14 @@ iterative_hstate_expr (const_tree t, inchash &hstate)\n       hstate.add ((const void *) TREE_STRING_POINTER (t), TREE_STRING_LENGTH (t));\n       return;\n     case COMPLEX_CST:\n-      iterative_hstate_expr (TREE_REALPART (t), hstate);\n-      iterative_hstate_expr (TREE_IMAGPART (t), hstate);\n+      inchash::add_expr (TREE_REALPART (t), hstate);\n+      inchash::add_expr (TREE_IMAGPART (t), hstate);\n       return;\n     case VECTOR_CST:\n       {\n \tunsigned i;\n \tfor (i = 0; i < VECTOR_CST_NELTS (t); ++i)\n-\t  iterative_hstate_expr (VECTOR_CST_ELT (t, i), hstate);\n+\t  inchash::add_expr (VECTOR_CST_ELT (t, i), hstate);\n \treturn;\n       }\n     case SSA_NAME:\n@@ -7452,16 +7455,16 @@ iterative_hstate_expr (const_tree t, inchash &hstate)\n       /* A list of expressions, for a CALL_EXPR or as the elements of a\n \t VECTOR_CST.  */\n       for (; t; t = TREE_CHAIN (t))\n-\titerative_hstate_expr (TREE_VALUE (t), hstate);\n+\tinchash::add_expr (TREE_VALUE (t), hstate);\n       return;\n     case CONSTRUCTOR:\n       {\n \tunsigned HOST_WIDE_INT idx;\n \ttree field, value;\n \tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), idx, field, value)\n \t  {\n-\t    iterative_hstate_expr (field, hstate);\n-\t    iterative_hstate_expr (value, hstate);\n+\t    inchash::add_expr (field, hstate);\n+\t    inchash::add_expr (value, hstate);\n \t  }\n \treturn;\n       }\n@@ -7500,7 +7503,7 @@ iterative_hstate_expr (const_tree t, inchash &hstate)\n \t    {\n \t      /* Make sure to include signness in the hash computation.  */\n \t      hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n-\t      iterative_hstate_expr (TREE_OPERAND (t, 0), hstate);\n+\t      inchash::add_expr (TREE_OPERAND (t, 0), hstate);\n \t    }\n \n \t  else if (commutative_tree_code (code))\n@@ -7509,19 +7512,21 @@ iterative_hstate_expr (const_tree t, inchash &hstate)\n \t\t however it appears.  We do this by first hashing both operands\n \t\t and then rehashing based on the order of their independent\n \t\t hashes.  */\n-\t      inchash one, two;\n-\t      iterative_hstate_expr (TREE_OPERAND (t, 0), one);\n-\t      iterative_hstate_expr (TREE_OPERAND (t, 1), two);\n+\t      inchash::hash one, two;\n+\t      inchash::add_expr (TREE_OPERAND (t, 0), one);\n+\t      inchash::add_expr (TREE_OPERAND (t, 1), two);\n \t      hstate.add_commutative (one, two);\n \t    }\n \t  else\n \t    for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-\t      iterative_hstate_expr (TREE_OPERAND (t, i), hstate);\n+\t      inchash::add_expr (TREE_OPERAND (t, i), hstate);\n \t}\n       return;\n     }\n }\n \n+}\n+\n /* Constructors for pointer, array and function types.\n    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are\n    constructed by language-dependent code, not here.)  */\n@@ -7711,7 +7716,7 @@ static tree\n build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n {\n   tree itype = make_node (INTEGER_TYPE);\n-  inchash hstate;\n+  inchash::hash hstate;\n \n   TREE_TYPE (itype) = type;\n \n@@ -7739,8 +7744,8 @@ build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n       return itype;\n     }\n \n-  iterative_hstate_expr (TYPE_MIN_VALUE (itype), hstate);\n-  iterative_hstate_expr (TYPE_MAX_VALUE (itype), hstate);\n+  inchash::add_expr (TYPE_MIN_VALUE (itype), hstate);\n+  inchash::add_expr (TYPE_MAX_VALUE (itype), hstate);\n   hstate.merge_hash (TYPE_HASH (type));\n   itype = type_hash_canon (hstate.end (), itype);\n \n@@ -7847,7 +7852,7 @@ build_array_type_1 (tree elt_type, tree index_type, bool shared)\n \n   if (shared)\n     {\n-      inchash hstate;\n+      inchash::hash hstate;\n       hstate.add_object (TYPE_HASH (elt_type));\n       if (index_type)\n \thstate.add_object (TYPE_HASH (index_type));\n@@ -7991,7 +7996,7 @@ tree\n build_function_type (tree value_type, tree arg_types)\n {\n   tree t;\n-  inchash hstate;\n+  inchash::hash hstate;\n   bool any_structural_p, any_noncanonical_p;\n   tree canon_argtypes;\n \n@@ -8146,7 +8151,7 @@ build_method_type_directly (tree basetype,\n {\n   tree t;\n   tree ptype;\n-  inchash hstate;\n+  inchash::hash hstate;\n   bool any_structural_p, any_noncanonical_p;\n   tree canon_argtypes;\n \n@@ -8214,7 +8219,7 @@ tree\n build_offset_type (tree basetype, tree type)\n {\n   tree t;\n-  inchash hstate;\n+  inchash::hash hstate;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (OFFSET_TYPE);\n@@ -8251,7 +8256,7 @@ tree\n build_complex_type (tree component_type)\n {\n   tree t;\n-  inchash hstate;\n+  inchash::hash hstate;\n \n   gcc_assert (INTEGRAL_TYPE_P (component_type)\n \t      || SCALAR_FLOAT_TYPE_P (component_type)\n@@ -9403,7 +9408,7 @@ static tree\n make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n {\n   tree t;\n-  inchash hstate;\n+  inchash::hash hstate;\n \n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (innertype);"}, {"sha": "9f9090a1803471da0fe491f3bd3636534780a0cc", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50de5793fc6004bb8bf6f00e0f02e318f242ca2d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=50de5793fc6004bb8bf6f00e0f02e318f242ca2d", "patch": "@@ -4284,14 +4284,20 @@ extern int tree_log2 (const_tree);\n extern int tree_floor_log2 (const_tree);\n extern unsigned int tree_ctz (const_tree);\n extern int simple_cst_equal (const_tree, const_tree);\n-extern void iterative_hstate_expr (const_tree, inchash &);\n+\n+namespace inchash\n+{\n+\n+extern void add_expr (const_tree, hash &);\n+\n+}\n \n /* Compat version until all callers are converted. Return hash for\n    TREE with SEED.  */\n static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)\n {\n-  inchash hstate (seed);\n-  iterative_hstate_expr (tree, hstate);\n+  inchash::hash hstate (seed);\n+  inchash::add_expr (tree, hstate);\n   return hstate.end ();\n }\n "}]}