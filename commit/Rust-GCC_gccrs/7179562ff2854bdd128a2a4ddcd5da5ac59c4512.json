{"sha": "7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "node_id": "C_kwDOANBUbNoAKDcxNzk1NjJmZjI4NTRiZGQxMjhhMmE0ZGRjZDVkYTVhYzU5YzQ1MTI", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-02-08T15:19:41Z"}, "committer": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-02-08T15:28:04Z"}, "message": "typecheck: Refactor rust-hir-trait-reference.h\n\nMove function body to their own cc file instead of keeping them in the\nheader file.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add `rust-hir-trait-reference.o`.\n\t* typecheck/rust-hir-trait-reference.h: Remove multiple function body.\n\t* typecheck/rust-hir-trait-reference.cc: Add multiple function body.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "0fad3242a6580c57ddaea410a4c9d95ca4c3800c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fad3242a6580c57ddaea410a4c9d95ca4c3800c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f66312db45e3e157123108934f6cf0c71a1c235", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f66312db45e3e157123108934f6cf0c71a1c235", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f66312db45e3e157123108934f6cf0c71a1c235"}], "stats": {"total": 807, "additions": 510, "deletions": 297}, "files": [{"sha": "9e16d3d19be59064a62f95544bf81b3482ad78f0", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "patch": "@@ -122,6 +122,7 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n+    rust/rust-hir-trait-reference.o \\\n     rust/rust-hir-type-check-item.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\"}, {"sha": "651c55abc82172acf28e95794ee7182556500ef0", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.cc", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc?ref=7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "patch": "@@ -0,0 +1,463 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-trait-reference.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+std::string\n+TraitItemReference::as_string () const\n+{\n+  return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \" + \")\";\n+}\n+\n+bool\n+TraitItemReference::is_error () const\n+{\n+  return type == ERROR;\n+}\n+\n+bool\n+TraitItemReference::is_optional () const\n+{\n+  return optional_flag;\n+};\n+\n+std::string\n+TraitItemReference::get_identifier () const\n+{\n+  return identifier;\n+}\n+\n+TraitItemReference::TraitItemType\n+TraitItemReference::get_trait_item_type () const\n+{\n+  return type;\n+}\n+\n+HIR::TraitItem *\n+TraitItemReference::get_hir_trait_item () const\n+{\n+  return hir_trait_item;\n+}\n+\n+Location\n+TraitItemReference::get_locus () const\n+{\n+  return locus;\n+}\n+\n+const Analysis::NodeMapping\n+TraitItemReference::get_mappings () const\n+{\n+  return hir_trait_item->get_mappings ();\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_tyty () const\n+{\n+  rust_assert (hir_trait_item != nullptr);\n+\n+  switch (type)\n+    {\n+    case CONST:\n+      return get_type_from_constant (\n+\tstatic_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n+      break;\n+\n+    case TYPE:\n+      return get_type_from_typealias (\n+\tstatic_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+\n+    case FN:\n+      return get_type_from_fn (\n+\tstatic_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n+      break;\n+\n+    default:\n+      return get_error ();\n+    }\n+\n+  gcc_unreachable ();\n+  return get_error ();\n+}\n+\n+TyTy::ErrorType *\n+TraitItemReference::get_error () const\n+{\n+  return new TyTy::ErrorType (get_mappings ().get_hirid ());\n+}\n+\n+TraitReference::TraitReference (\n+  const HIR::Trait *hir_trait_ref, std::vector<TraitItemReference> item_refs,\n+  std::vector<const TraitReference *> super_traits,\n+  std::vector<TyTy::SubstitutionParamMapping> substs)\n+  : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n+    super_traits (super_traits)\n+{\n+  trait_substs.clear ();\n+  trait_substs.reserve (substs.size ());\n+  for (const auto &p : substs)\n+    trait_substs.push_back (p.clone ());\n+}\n+\n+TraitReference::TraitReference (TraitReference const &other)\n+  : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n+    super_traits (other.super_traits)\n+{\n+  trait_substs.clear ();\n+  trait_substs.reserve (other.trait_substs.size ());\n+  for (const auto &p : other.trait_substs)\n+    trait_substs.push_back (p.clone ());\n+}\n+\n+TraitReference &\n+TraitReference::operator= (TraitReference const &other)\n+{\n+  hir_trait_ref = other.hir_trait_ref;\n+  item_refs = other.item_refs;\n+  super_traits = other.super_traits;\n+\n+  trait_substs.clear ();\n+  trait_substs.reserve (other.trait_substs.size ());\n+  for (const auto &p : other.trait_substs)\n+    trait_substs.push_back (p.clone ());\n+\n+  return *this;\n+}\n+\n+bool\n+TraitReference::is_error () const\n+{\n+  return hir_trait_ref == nullptr;\n+}\n+\n+Location\n+TraitReference::get_locus () const\n+{\n+  return hir_trait_ref->get_locus ();\n+}\n+\n+std::string\n+TraitReference::get_name () const\n+{\n+  rust_assert (!is_error ());\n+  return hir_trait_ref->get_name ();\n+}\n+\n+std::string\n+TraitReference::as_string () const\n+{\n+  if (is_error ())\n+    return \"<trait-ref-error-node>\";\n+\n+  std::string item_buf;\n+  for (auto &item : item_refs)\n+    {\n+      item_buf += item.as_string () + \", \";\n+    }\n+  return \"HIR Trait: \" + get_name () + \"->\"\n+\t + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf + \"]\";\n+}\n+\n+const HIR::Trait *\n+TraitReference::get_hir_trait_ref () const\n+{\n+  return hir_trait_ref;\n+}\n+\n+const Analysis::NodeMapping &\n+TraitReference::get_mappings () const\n+{\n+  return hir_trait_ref->get_mappings ();\n+}\n+\n+DefId\n+TraitReference::get_defid () const\n+{\n+  return get_mappings ().get_defid ();\n+}\n+\n+bool\n+TraitReference::lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t\t       TraitItemReference **ref)\n+{\n+  return lookup_trait_item (item.trait_identifier (), ref);\n+}\n+\n+bool\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   TraitItemReference **ref)\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_trait_item_by_type (\n+  const std::string &ident, TraitItemReference::TraitItemType type,\n+  TraitItemReference **ref)\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_trait_item_by_type (\n+  const std::string &ident, TraitItemReference::TraitItemType type,\n+  const TraitItemReference **ref) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t\t       const TraitItemReference **ref) const\n+{\n+  return lookup_trait_item (item.trait_identifier (), ref);\n+}\n+\n+bool\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   const TraitItemReference **ref) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+\n+  // lookup super traits\n+  for (const auto &super_trait : super_traits)\n+    {\n+      bool found = super_trait->lookup_trait_item (ident, ref);\n+      if (found)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+const TraitItemReference *\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   TraitItemReference::TraitItemType type) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\treturn &item;\n+    }\n+\n+  // lookup super traits\n+  for (const auto &super_trait : super_traits)\n+    {\n+      const TraitItemReference *res\n+\t= super_trait->lookup_trait_item (ident, type);\n+      if (!res->is_error ())\n+\treturn res;\n+    }\n+\n+  return &TraitItemReference::error_node ();\n+}\n+\n+size_t\n+TraitReference::size () const\n+{\n+  return item_refs.size ();\n+}\n+\n+const std::vector<TraitItemReference> &\n+TraitReference::get_trait_items () const\n+{\n+  return item_refs;\n+}\n+\n+void\n+TraitReference::get_trait_items_and_supers (\n+  std::vector<const TraitItemReference *> &result) const\n+{\n+  for (const auto &item : item_refs)\n+    result.push_back (&item);\n+\n+  for (const auto &super_trait : super_traits)\n+    super_trait->get_trait_items_and_supers (result);\n+}\n+\n+void\n+TraitReference::on_resolved ()\n+{\n+  for (auto &item : item_refs)\n+    {\n+      item.on_resolved ();\n+    }\n+}\n+\n+void\n+TraitReference::clear_associated_types ()\n+{\n+  for (auto &item : item_refs)\n+    {\n+      bool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t   == TraitItemReference::TraitItemType::TYPE;\n+      if (is_assoc_type)\n+\titem.associated_type_reset ();\n+    }\n+}\n+\n+bool\n+TraitReference::is_equal (const TraitReference &other) const\n+{\n+  DefId this_id = get_mappings ().get_defid ();\n+  DefId other_id = other.get_mappings ().get_defid ();\n+  return this_id == other_id;\n+}\n+\n+const std::vector<const TraitReference *>\n+TraitReference::get_super_traits () const\n+{\n+  return super_traits;\n+}\n+\n+bool\n+TraitReference::is_object_safe (bool emit_error, Location locus) const\n+{\n+  // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n+  std::vector<const TraitReference *> non_object_super_traits;\n+  for (auto &item : super_traits)\n+    {\n+      if (!item->is_object_safe (false, Location ()))\n+\tnon_object_super_traits.push_back (item);\n+    }\n+\n+  std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n+  for (auto &item : get_trait_items ())\n+    {\n+      if (!item.is_object_safe ())\n+\tnon_object_safe_items.push_back (&item);\n+    }\n+\n+  bool is_safe\n+    = non_object_super_traits.empty () && non_object_safe_items.empty ();\n+  if (emit_error && !is_safe)\n+    {\n+      RichLocation r (locus);\n+      for (auto &item : non_object_super_traits)\n+\tr.add_range (item->get_locus ());\n+      for (auto &item : non_object_safe_items)\n+\tr.add_range (item->get_locus ());\n+\n+      rust_error_at (r, \"trait bound is not object safe\");\n+    }\n+\n+  return is_safe;\n+}\n+\n+bool\n+TraitReference::trait_has_generics () const\n+{\n+  return !trait_substs.empty ();\n+}\n+\n+std::vector<TyTy::SubstitutionParamMapping>\n+TraitReference::get_trait_substs () const\n+{\n+  return trait_substs;\n+}\n+\n+bool\n+TraitReference::satisfies_bound (const TraitReference &reference) const\n+{\n+  if (is_equal (reference))\n+    return true;\n+\n+  for (const auto &super_trait : super_traits)\n+    {\n+      if (super_trait->satisfies_bound (reference))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+AssociatedImplTrait::AssociatedImplTrait (TraitReference *trait,\n+\t\t\t\t\t  HIR::ImplBlock *impl,\n+\t\t\t\t\t  TyTy::BaseType *self,\n+\t\t\t\t\t  Resolver::TypeCheckContext *context)\n+  : trait (trait), impl (impl), self (self), context (context)\n+{}\n+\n+TraitReference *\n+AssociatedImplTrait::get_trait ()\n+{\n+  return trait;\n+}\n+\n+HIR::ImplBlock *\n+AssociatedImplTrait::get_impl_block ()\n+{\n+  return impl;\n+}\n+\n+TyTy::BaseType *\n+AssociatedImplTrait::get_self ()\n+{\n+  return self;\n+}\n+const TyTy::BaseType *\n+AssociatedImplTrait::get_self () const\n+{\n+  return self;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "40a1fd7970cd01b432a86010f862a8607cdb0563", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "modified", "additions": 46, "deletions": 297, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7179562ff2854bdd128a2a4ddcd5da5ac59c4512/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "patch": "@@ -20,8 +20,8 @@\n #define RUST_HIR_TRAIT_REF_H\n \n #include \"rust-hir-full.h\"\n-#include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-util.h\"\n+#include \"rust-tyty-visitor.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -61,13 +61,9 @@ class TraitItemReference\n     return error;\n   }\n \n-  bool is_error () const { return type == ERROR; }\n+  bool is_error () const;\n \n-  std::string as_string () const\n-  {\n-    return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n-\t   + \")\";\n-  }\n+  std::string as_string () const;\n \n   static std::string trait_item_type_as_string (TraitItemType ty)\n   {\n@@ -85,53 +81,24 @@ class TraitItemReference\n     return \"ERROR\";\n   }\n \n-  bool is_optional () const { return optional_flag; }\n-\n-  std::string get_identifier () const { return identifier; }\n-\n-  TraitItemType get_trait_item_type () const { return type; }\n-\n-  HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n+  bool is_optional () const;\n \n-  Location get_locus () const { return locus; }\n+  std::string get_identifier () const;\n \n-  const Analysis::NodeMapping get_mappings () const\n-  {\n-    return hir_trait_item->get_mappings ();\n-  }\n+  TraitItemType get_trait_item_type () const;\n \n-  TyTy::BaseType *get_tyty () const\n-  {\n-    rust_assert (hir_trait_item != nullptr);\n+  HIR::TraitItem *get_hir_trait_item () const;\n \n-    switch (type)\n-      {\n-      case CONST:\n-\treturn get_type_from_constant (\n-\t  static_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n-\tbreak;\n+  Location get_locus () const;\n \n-      case TYPE:\n-\treturn get_type_from_typealias (\n-\t  static_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+  const Analysis::NodeMapping get_mappings () const;\n \n-      case FN:\n-\treturn get_type_from_fn (\n-\t  static_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n-\tbreak;\n-\n-      default:\n-\treturn get_error ();\n-      }\n-\n-    gcc_unreachable ();\n-    return get_error ();\n-  }\n+  TyTy::BaseType *get_tyty () const;\n \n   Analysis::NodeMapping get_parent_trait_mappings () const;\n \n-  // this is called when the trait is completed resolution and gives the items a\n-  // chance to run their specific type resolution passes. If we call their\n+  // this is called when the trait is completed resolution and gives the items\n+  // a chance to run their specific type resolution passes. If we call their\n   // resolution on construction it can lead to a case where the trait being\n   // resolved recursively trying to resolve the trait itself infinitely since\n   // the trait will not be stored in its own map yet\n@@ -144,10 +111,7 @@ class TraitItemReference\n   bool is_object_safe () const;\n \n private:\n-  TyTy::ErrorType *get_error () const\n-  {\n-    return new TyTy::ErrorType (get_mappings ().get_hirid ());\n-  }\n+  TyTy::ErrorType *get_error () const;\n \n   TyTy::BaseType *get_type_from_typealias (/*const*/\n \t\t\t\t\t   HIR::TraitItemType &type) const;\n@@ -182,39 +146,11 @@ class TraitReference\n   TraitReference (const HIR::Trait *hir_trait_ref,\n \t\t  std::vector<TraitItemReference> item_refs,\n \t\t  std::vector<const TraitReference *> super_traits,\n-\t\t  std::vector<TyTy::SubstitutionParamMapping> substs)\n-    : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n-      super_traits (super_traits)\n-  {\n-    trait_substs.clear ();\n-    trait_substs.reserve (substs.size ());\n-    for (const auto &p : substs)\n-      trait_substs.push_back (p.clone ());\n-  }\n-\n-  TraitReference (TraitReference const &other)\n-    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n-      super_traits (other.super_traits)\n-  {\n-    trait_substs.clear ();\n-    trait_substs.reserve (other.trait_substs.size ());\n-    for (const auto &p : other.trait_substs)\n-      trait_substs.push_back (p.clone ());\n-  }\n-\n-  TraitReference &operator= (TraitReference const &other)\n-  {\n-    hir_trait_ref = other.hir_trait_ref;\n-    item_refs = other.item_refs;\n-    super_traits = other.super_traits;\n+\t\t  std::vector<TyTy::SubstitutionParamMapping> substs);\n \n-    trait_substs.clear ();\n-    trait_substs.reserve (other.trait_substs.size ());\n-    for (const auto &p : other.trait_substs)\n-      trait_substs.push_back (p.clone ());\n+  TraitReference (TraitReference const &other);\n \n-    return *this;\n-  }\n+  TraitReference &operator= (TraitReference const &other);\n \n   TraitReference (TraitReference &&other) = default;\n   TraitReference &operator= (TraitReference &&other) = default;\n@@ -224,256 +160,71 @@ class TraitReference\n     return TraitReference (nullptr, {}, {}, {});\n   }\n \n-  bool is_error () const { return hir_trait_ref == nullptr; }\n+  bool is_error () const;\n \n   static TraitReference &error_node ()\n   {\n     static TraitReference trait_error_node = TraitReference::error ();\n     return trait_error_node;\n   }\n \n-  Location get_locus () const { return hir_trait_ref->get_locus (); }\n+  Location get_locus () const;\n \n-  std::string get_name () const\n-  {\n-    rust_assert (!is_error ());\n-    return hir_trait_ref->get_name ();\n-  }\n+  std::string get_name () const;\n \n-  std::string as_string () const\n-  {\n-    if (is_error ())\n-      return \"<trait-ref-error-node>\";\n-\n-    std::string item_buf;\n-    for (auto &item : item_refs)\n-      {\n-\titem_buf += item.as_string () + \", \";\n-      }\n-    return \"HIR Trait: \" + get_name () + \"->\"\n-\t   + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf\n-\t   + \"]\";\n-  }\n+  std::string as_string () const;\n \n-  const HIR::Trait *get_hir_trait_ref () const { return hir_trait_ref; }\n+  const HIR::Trait *get_hir_trait_ref () const;\n \n-  const Analysis::NodeMapping &get_mappings () const\n-  {\n-    return hir_trait_ref->get_mappings ();\n-  }\n+  const Analysis::NodeMapping &get_mappings () const;\n \n-  DefId get_defid () const { return get_mappings ().get_defid (); }\n+  DefId get_defid () const;\n \n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n-\t\t\t      TraitItemReference **ref)\n-  {\n-    return lookup_trait_item (item.trait_identifier (), ref);\n-  }\n+\t\t\t      TraitItemReference **ref);\n \n-  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref)\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref);\n \n   bool lookup_trait_item_by_type (const std::string &ident,\n \t\t\t\t  TraitItemReference::TraitItemType type,\n-\t\t\t\t  TraitItemReference **ref)\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n-\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t  TraitItemReference **ref);\n \n   bool lookup_trait_item_by_type (const std::string &ident,\n \t\t\t\t  TraitItemReference::TraitItemType type,\n-\t\t\t\t  const TraitItemReference **ref) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n-\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t  const TraitItemReference **ref) const;\n \n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n-\t\t\t      const TraitItemReference **ref) const\n-  {\n-    return lookup_trait_item (item.trait_identifier (), ref);\n-  }\n+\t\t\t      const TraitItemReference **ref) const;\n \n   bool lookup_trait_item (const std::string &ident,\n-\t\t\t  const TraitItemReference **ref) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-\n-    // lookup super traits\n-    for (const auto &super_trait : super_traits)\n-      {\n-\tbool found = super_trait->lookup_trait_item (ident, ref);\n-\tif (found)\n-\t  return true;\n-      }\n-\n-    return false;\n-  }\n+\t\t\t  const TraitItemReference **ref) const;\n \n   const TraitItemReference *\n   lookup_trait_item (const std::string &ident,\n-\t\t     TraitItemReference::TraitItemType type) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n+\t\t     TraitItemReference::TraitItemType type) const;\n \n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  return &item;\n-      }\n+  size_t size () const;\n \n-    // lookup super traits\n-    for (const auto &super_trait : super_traits)\n-      {\n-\tconst TraitItemReference *res\n-\t  = super_trait->lookup_trait_item (ident, type);\n-\tif (!res->is_error ())\n-\t  return res;\n-      }\n-\n-    return &TraitItemReference::error_node ();\n-  }\n-\n-  size_t size () const { return item_refs.size (); }\n-\n-  const std::vector<TraitItemReference> &get_trait_items () const\n-  {\n-    return item_refs;\n-  }\n+  const std::vector<TraitItemReference> &get_trait_items () const;\n \n   void get_trait_items_and_supers (\n-    std::vector<const TraitItemReference *> &result) const\n-  {\n-    for (const auto &item : item_refs)\n-      result.push_back (&item);\n-\n-    for (const auto &super_trait : super_traits)\n-      super_trait->get_trait_items_and_supers (result);\n-  }\n-\n-  void on_resolved ()\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\titem.on_resolved ();\n-      }\n-  }\n-\n-  void clear_associated_types ()\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tbool is_assoc_type = item.get_trait_item_type ()\n-\t\t\t     == TraitItemReference::TraitItemType::TYPE;\n-\tif (is_assoc_type)\n-\t  item.associated_type_reset ();\n-      }\n-  }\n-\n-  bool is_equal (const TraitReference &other) const\n-  {\n-    DefId this_id = get_mappings ().get_defid ();\n-    DefId other_id = other.get_mappings ().get_defid ();\n-    return this_id == other_id;\n-  }\n-\n-  const std::vector<const TraitReference *> get_super_traits () const\n-  {\n-    return super_traits;\n-  }\n-\n-  bool is_object_safe (bool emit_error, Location locus) const\n-  {\n-    // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n-    std::vector<const TraitReference *> non_object_super_traits;\n-    for (auto &item : super_traits)\n-      {\n-\tif (!item->is_object_safe (false, Location ()))\n-\t  non_object_super_traits.push_back (item);\n-      }\n+    std::vector<const TraitItemReference *> &result) const;\n \n-    std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n-    for (auto &item : get_trait_items ())\n-      {\n-\tif (!item.is_object_safe ())\n-\t  non_object_safe_items.push_back (&item);\n-      }\n+  void on_resolved ();\n \n-    bool is_safe\n-      = non_object_super_traits.empty () && non_object_safe_items.empty ();\n-    if (emit_error && !is_safe)\n-      {\n-\tRichLocation r (locus);\n-\tfor (auto &item : non_object_super_traits)\n-\t  r.add_range (item->get_locus ());\n-\tfor (auto &item : non_object_safe_items)\n-\t  r.add_range (item->get_locus ());\n+  void clear_associated_types ();\n \n-\trust_error_at (r, \"trait bound is not object safe\");\n-      }\n+  bool is_equal (const TraitReference &other) const;\n \n-    return is_safe;\n-  }\n+  const std::vector<const TraitReference *> get_super_traits () const;\n \n-  bool trait_has_generics () const { return !trait_substs.empty (); }\n+  bool is_object_safe (bool emit_error, Location locus) const;\n \n-  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const\n-  {\n-    return trait_substs;\n-  }\n-\n-  bool satisfies_bound (const TraitReference &reference) const\n-  {\n-    if (is_equal (reference))\n-      return true;\n+  bool trait_has_generics () const;\n \n-    for (const auto &super_trait : super_traits)\n-      {\n-\tif (super_trait->satisfies_bound (reference))\n-\t  return true;\n-      }\n+  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const;\n \n-    return false;\n-  }\n+  bool satisfies_bound (const TraitReference &reference) const;\n \n private:\n   const HIR::Trait *hir_trait_ref;\n@@ -487,16 +238,14 @@ class AssociatedImplTrait\n public:\n   AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n \t\t       TyTy::BaseType *self,\n-\t\t       Resolver::TypeCheckContext *context)\n-    : trait (trait), impl (impl), self (self), context (context)\n-  {}\n+\t\t       Resolver::TypeCheckContext *context);\n \n-  TraitReference *get_trait () { return trait; }\n+  TraitReference *get_trait ();\n \n-  HIR::ImplBlock *get_impl_block () { return impl; }\n+  HIR::ImplBlock *get_impl_block ();\n \n-  TyTy::BaseType *get_self () { return self; }\n-  const TyTy::BaseType *get_self () const { return self; }\n+  TyTy::BaseType *get_self ();\n+  const TyTy::BaseType *get_self () const;\n \n   TyTy::BaseType *\n   setup_associated_types (const TyTy::BaseType *self,"}]}