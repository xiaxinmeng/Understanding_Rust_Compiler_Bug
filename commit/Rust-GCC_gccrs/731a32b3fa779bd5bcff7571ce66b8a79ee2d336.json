{"sha": "731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxYTMyYjNmYTc3OWJkNWJjZmY3NTcxY2U2NmI4YTc5ZWUyZDMzNg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:09Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:09Z"}, "message": "c++: More precise tracking of potentially unstable satisfaction\n\nThis makes tracking of potentially unstable satisfaction results more\nprecise by recording the specific types for which completion failed\nduring satisfaction.  We now recompute a satisfaction result only if one\nof these types has been completed since the last time we computed the\nsatisfaction result.  Thus the number of times that we recompute a\nsatisfaction result is now bounded by the number of such incomplete\ntypes, rather than being effectively unbounded.  This allows us to\nremove the invalid assumption in note_ftc_for_satisfaction that was\nadded to avoid a compile time performance regression in cmcstl2 due to\nrepeated recomputation of a satisfaction result that depended on\ncompletion of a permanently incomplete class template specialization.\n\nIn order to continue to detect the instability in concepts-complete3.C,\nwe also need to explicitly keep track of return type deduction failure\nalongside type completion failure.  So this patch also adds a call to\nnote_ftc_for_satisfaction in require_deduced_type.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (satisfying_constraint): Move up definition\n\tand give it bool type.\n\t(failed_type_completion_count): Replace with ...\n\t(failed_type_completions): ... this.\n\t(note_failed_type_completion_for_satisfaction): Append the\n\tsupplied argument to failed_type_completions.\n\t(some_type_complete_p): Define.\n\t(sat_entry::maybe_unstable): Replace with ...\n\t(sat_entry::ftc_begin, sat_entry::ftc_end): ... these.\n\t(satisfaction_cache::ftc_count): Replace with ...\n\t(satisfaction_cache::ftc_begin): ... this.\n\t(satisfaction_cache::satisfaction_cache): Adjust accordingly.\n\t(satisfaction_cache::get): Adjust accordingly, using\n\tsome_type_complete_p.\n\t(satisfaction_cache::save): Adjust accordingly.\n\t(satisfying_constraint_p): Remove unused function.\n\t(satisfy_constraint): Set satisfying_constraint.\n\t(satisfy_declaration_constraints): Likewise.\n\t* decl.c (require_deduced_type): Call\n\tnote_failed_type_completion_for_satisfaction.", "tree": {"sha": "af7ca9afcb418f9d02ee14a651b0873fc7754090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af7ca9afcb418f9d02ee14a651b0873fc7754090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731a32b3fa779bd5bcff7571ce66b8a79ee2d336/comments", "author": null, "committer": null, "parents": [{"sha": "79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f57d5cb070bb02ea0a34b5f42658d6659b19a8"}], "stats": {"total": 115, "additions": 65, "deletions": 50}, "files": [{"sha": "24fcbaa8c8e5ff0dc1fad173c1be3a4e4ed3c32b", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731a32b3fa779bd5bcff7571ce66b8a79ee2d336/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731a32b3fa779bd5bcff7571ce66b8a79ee2d336/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "patch": "@@ -2374,26 +2374,51 @@ tsubst_parameter_mapping (tree map, tree args, tsubst_flags_t complain, tree in_\n                         Constraint satisfaction\n ---------------------------------------------------------------------------*/\n \n-/* A counter incremented by note_failed_type_completion_for_satisfaction().\n-   It's used by the satisfaction caches in order to flag \"potentially unstable\"\n-   satisfaction results.  */\n+/* True if we are currently satisfying a constraint.  */\n \n-static unsigned failed_type_completion_count;\n+static bool satisfying_constraint;\n \n-/* Called whenever a type completion failure occurs that definitely affects\n-   the semantics of the program, by e.g. inducing substitution failure.  */\n+/* A vector of incomplete types (and of declarations with undeduced return type),\n+   appended to by note_failed_type_completion_for_satisfaction.  The\n+   satisfaction caches use this in order to keep track of \"potentially unstable\"\n+   satisfaction results.\n+\n+   Since references to entries in this vector are stored only in the\n+   GC-deletable sat_cache, it's safe to make this deletable as well.  */\n+\n+static GTY((deletable)) vec<tree, va_gc> *failed_type_completions;\n+\n+/* Called whenever a type completion (or return type deduction) failure occurs\n+   that definitely affects the meaning of the program, by e.g. inducing\n+   substitution failure.  */\n \n void\n-note_failed_type_completion_for_satisfaction (tree type)\n-{\n-  gcc_checking_assert (!COMPLETE_TYPE_P (type));\n-  if (CLASS_TYPE_P (type)\n-      && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-    /* After instantiation, a class template specialization that's\n-       incomplete will remain incomplete, so for our purposes we can\n-       ignore this completion failure event.  */;\n-  else\n-    ++failed_type_completion_count;\n+note_failed_type_completion_for_satisfaction (tree t)\n+{\n+  if (satisfying_constraint)\n+    {\n+      gcc_checking_assert ((TYPE_P (t) && !COMPLETE_TYPE_P (t))\n+\t\t\t   || (DECL_P (t) && undeduced_auto_decl (t)));\n+      vec_safe_push (failed_type_completions, t);\n+    }\n+}\n+\n+/* Returns true if the range [BEGIN, END) of elements within the\n+   failed_type_completions vector contains a complete type (or a\n+   declaration with a non-placeholder return type).  */\n+\n+static bool\n+some_type_complete_p (int begin, int end)\n+{\n+  for (int i = begin; i < end; i++)\n+    {\n+      tree t = (*failed_type_completions)[i];\n+      if (TYPE_P (t) && COMPLETE_TYPE_P (t))\n+\treturn true;\n+      if (DECL_P (t) && !undeduced_auto_decl (t))\n+\treturn true;\n+    }\n+  return false;\n }\n \n /* Hash functions and data types for satisfaction cache entries.  */\n@@ -2417,12 +2442,10 @@ struct GTY((for_user)) sat_entry\n      performed.  */\n   location_t location;\n \n-  /* True if this satisfaction result is flagged as \"potentially unstable\",\n-     i.e. the result might change at different points in the program if\n-     recomputed from scratch (which would be ill-formed).  This flag controls\n-     whether to recompute a cached satisfaction result from scratch even when\n-     evaluating quietly.  */\n-  bool maybe_unstable;\n+  /* The range of elements appended to the failed_type_completions vector\n+     during computation of this satisfaction result, encoded as a begin/end\n+     pair of offsets.  */\n+  int ftc_begin, ftc_end;\n \n   /* True if we want to diagnose the above instability when it's detected.\n      We don't always want to do so, in order to avoid emitting duplicate\n@@ -2522,15 +2545,15 @@ struct satisfaction_cache\n \n   sat_entry *entry;\n   sat_info info;\n-  unsigned ftc_count;\n+  int ftc_begin;\n };\n \n /* Constructor for the satisfaction_cache class.  We're performing satisfaction\n    of ATOM+ARGS according to INFO.  */\n \n satisfaction_cache\n ::satisfaction_cache (tree atom, tree args, sat_info info)\n-  : entry(nullptr), info(info), ftc_count(failed_type_completion_count)\n+  : entry(nullptr), info(info), ftc_begin(-1)\n {\n   if (!sat_cache)\n     sat_cache = hash_table<sat_hasher>::create_ggc (31);\n@@ -2569,7 +2592,7 @@ ::satisfaction_cache (tree atom, tree args, sat_info info)\n       entry->args = args;\n       entry->result = NULL_TREE;\n       entry->location = input_location;\n-      entry->maybe_unstable = false;\n+      entry->ftc_begin = entry->ftc_end = -1;\n       entry->diagnose_instability = false;\n       if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (atom))\n \t/* We always want to diagnose instability of an atom with an\n@@ -2607,10 +2630,16 @@ satisfaction_cache::get ()\n       return error_mark_node;\n     }\n \n-  if (info.noisy () || entry->maybe_unstable || !entry->result)\n+  /* This satisfaction result is \"potentially unstable\" if a type for which\n+     type completion failed during its earlier computation is now complete.  */\n+  bool maybe_unstable = some_type_complete_p (entry->ftc_begin,\n+\t\t\t\t\t      entry->ftc_end);\n+\n+  if (info.noisy () || maybe_unstable || !entry->result)\n     {\n       /* We're computing the satisfaction result from scratch.  */\n       entry->evaluating = true;\n+      ftc_begin = vec_safe_length (failed_type_completions);\n       return NULL_TREE;\n     }\n   else\n@@ -2658,32 +2687,16 @@ satisfaction_cache::save (tree result)\n   if (info.quiet ())\n     {\n       entry->result = result;\n-      /* We heuristically flag this satisfaction result as potentially unstable\n-\t iff during its computation, completion of a type failed.  Note that\n-\t this may also clear the flag if the result turned out to be\n-\t independent of the previously detected type completion failure.  */\n-      entry->maybe_unstable = (ftc_count != failed_type_completion_count);\n+      /* Store into this entry the list of relevant failed type completions\n+\t that occurred during (re)computation of the satisfaction result.  */\n+      gcc_checking_assert (ftc_begin != -1);\n+      entry->ftc_begin = ftc_begin;\n+      entry->ftc_end = vec_safe_length (failed_type_completions);\n     }\n \n   return result;\n }\n \n-static int satisfying_constraint = 0;\n-\n-/* Returns true if we are currently satisfying a constraint.\n-\n-   This is used to guard against recursive calls to evaluate_concept_check\n-   during template argument substitution.\n-\n-   TODO: Do we need this now that we fully normalize prior to evaluation?\n-   I think not. */\n-\n-bool\n-satisfying_constraint_p ()\n-{\n-  return satisfying_constraint;\n-}\n-\n /* Substitute ARGS into constraint-expression T during instantiation of\n    a member of a class template.  */\n \n@@ -3003,6 +3016,8 @@ satisfy_constraint (tree t, tree args, sat_info info)\n {\n   auto_timevar time (TV_CONSTRAINT_SAT);\n \n+  auto ovr = make_temp_override (satisfying_constraint, true);\n+\n   /* Turn off template processing. Constraint satisfaction only applies\n      to non-dependent terms, so we want to ensure full checking here.  */\n   processing_template_decl_sentinel proc (true);\n@@ -3111,7 +3126,7 @@ satisfy_declaration_constraints (tree t, sat_info info)\n       norm = normalize_nontemplate_requirements (t, info.noisy ());\n     }\n \n-  unsigned ftc_count = failed_type_completion_count;\n+  unsigned ftc_count = vec_safe_length (failed_type_completions);\n \n   tree result = boolean_true_node;\n   if (norm)\n@@ -3127,8 +3142,7 @@ satisfy_declaration_constraints (tree t, sat_info info)\n   /* True if this satisfaction is (heuristically) potentially unstable, i.e.\n      if its result may depend on where in the program it was performed.  */\n   bool maybe_unstable_satisfaction = false;\n-\n-  if (ftc_count != failed_type_completion_count)\n+  if (ftc_count != vec_safe_length (failed_type_completions))\n     /* Type completion failure occurred during satisfaction.  The satisfaction\n        result may (or may not) materially depend on the completeness of a type,\n        so we consider it potentially unstable.   */"}, {"sha": "6e8dd0b45fdc0401eb517376d0f593692e53c219", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731a32b3fa779bd5bcff7571ce66b8a79ee2d336/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731a32b3fa779bd5bcff7571ce66b8a79ee2d336/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=731a32b3fa779bd5bcff7571ce66b8a79ee2d336", "patch": "@@ -17869,6 +17869,7 @@ require_deduced_type (tree decl, tsubst_flags_t complain)\n \t/* We probably already complained about deduction failure.  */;\n       else if (complain & tf_error)\n \terror (\"use of %qD before deduction of %<auto%>\", decl);\n+      note_failed_type_completion_for_satisfaction (decl);\n       return false;\n     }\n   return true;"}]}