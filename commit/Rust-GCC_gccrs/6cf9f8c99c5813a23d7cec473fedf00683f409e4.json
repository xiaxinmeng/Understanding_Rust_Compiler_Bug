{"sha": "6cf9f8c99c5813a23d7cec473fedf00683f409e4", "node_id": "C_kwDOANBUbNoAKDZjZjlmOGM5OWM1ODEzYTIzZDdjZWM0NzNmZWRmMDA2ODNmNDA5ZTQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-01T17:26:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-01T17:26:07Z"}, "message": "Merge #983\n\n983: Parse proper cfg values r=CohenArthur a=CohenArthur\n\nCloses #936 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "cd590bc5f7b266c043499899e0529ff4c16cc5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd590bc5f7b266c043499899e0529ff4c16cc5ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf9f8c99c5813a23d7cec473fedf00683f409e4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiHlcvCRBK7hj4Ov3rIwAAUhYIADk2+clTGx8028NQz2bwMqxa\nxp0hKsUsPnkaxMz4C0iQKeLVGnIBOsrDrTnGIDI3HgarlICZN10JM7x1uHZRaGFH\niV5RLhSJwpQ/ZDAno7MDJru5Q0/DeBGVYrmFlsQOlor15aGHQ4rZnTqS/sDwJ0Dz\nJKgNrsVIl0PssnxiO4qu/9k0CR5IsXjSSXl0kcwVCkSCEzgCSNXcByepuNTqTF7X\nbcNyyR+lSPcwMt3A0u+Wr5JeHha+++1/tiyMCpXAiJuIqpQNUsEQMCVXoWty2MXz\n7cA34Q6MakAdFq0ov9PnFjs+FVLkQmyewtNfs03UUFwR7VXM64UYrq7V/scDiuI=\n=V7nR\n-----END PGP SIGNATURE-----\n", "payload": "tree cd590bc5f7b266c043499899e0529ff4c16cc5ec\nparent e82b59dfc9319d72f891bac099bfa0f46d8b8c99\nparent f7ff6020f8c68e4fb54c17c4460aa7f8a31f85bd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646155567 +0000\ncommitter GitHub <noreply@github.com> 1646155567 +0000\n\nMerge #983\n\n983: Parse proper cfg values r=CohenArthur a=CohenArthur\n\nCloses #936 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9f8c99c5813a23d7cec473fedf00683f409e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf9f8c99c5813a23d7cec473fedf00683f409e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9f8c99c5813a23d7cec473fedf00683f409e4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82b59dfc9319d72f891bac099bfa0f46d8b8c99"}, {"sha": "f7ff6020f8c68e4fb54c17c4460aa7f8a31f85bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ff6020f8c68e4fb54c17c4460aa7f8a31f85bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7ff6020f8c68e4fb54c17c4460aa7f8a31f85bd"}], "stats": {"total": 240, "additions": 154, "deletions": 86}, "files": [{"sha": "f620e15e1d31005af7b0fdafadf82609a685171e", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -128,7 +128,8 @@ Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n     token_queue (TokenSource (this))\n {\n   // inform line_table that file is being entered and is in line 1\n-  line_map->start_file (filename, current_line);\n+  if (linemap)\n+    line_map->start_file (filename, current_line);\n }\n \n Lexer::~Lexer ()\n@@ -152,7 +153,11 @@ Lexer::~Lexer ()\n Location\n Lexer::get_current_location ()\n {\n-  return line_map->get_location (current_column);\n+  if (line_map)\n+    return line_map->get_location (current_column);\n+  else\n+    // If we have no linemap, we're lexing something without proper locations\n+    return Location ();\n }\n \n int"}, {"sha": "c50f63208dee488c3da7a031ef2ed0767d73fb2b", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-buffered-queue.h\"\n #include \"rust-token.h\"\n \n+#include <cstdio>\n #include <utility>\n #include <tuple>\n \n@@ -49,6 +50,13 @@ struct RAIIFile\n       file = fopen (filename, \"r\");\n   }\n \n+  /**\n+   * Create a RAIIFile from an existing instance of FILE*\n+   */\n+  RAIIFile (FILE *raw, const char *filename = nullptr)\n+    : file (raw), filename (filename)\n+  {}\n+\n   RAIIFile (const RAIIFile &other) = delete;\n   RAIIFile &operator= (const RAIIFile &other) = delete;\n \n@@ -57,6 +65,7 @@ struct RAIIFile\n   {\n     other.file = nullptr;\n   }\n+\n   RAIIFile &operator= (RAIIFile &&other)\n   {\n     close ();\n@@ -132,6 +141,19 @@ class Lexer\n   Lexer (const char *filename, RAIIFile input, Linemap *linemap);\n   ~Lexer ();\n \n+  /**\n+   * Lex the contents of a string instead of a file\n+   */\n+  static Lexer lex_string (std::string input)\n+  {\n+    // We can perform this ugly cast to a non-const char* since we're only\n+    // *reading* the string. This would not be valid if we were doing any\n+    // modification to it.\n+    auto string_file = fmemopen (&input[0], input.length (), \"r\");\n+\n+    return Lexer (nullptr, RAIIFile (string_file), nullptr);\n+  }\n+\n   // don't allow copy semantics (for now, at least)\n   Lexer (const Lexer &other) = delete;\n   Lexer &operator= (const Lexer &other) = delete;"}, {"sha": "f98419b983b40dae55952b8cd716e29f4baf8493", "filename": "gcc/rust/parse/rust-cfg-parser.cc", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -1,45 +1,55 @@\n #include \"rust-cfg-parser.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-session-manager.h\"\n #include \"selftest.h\"\n \n namespace Rust {\n bool\n-parse_cfg_option (const std::string &input, std::string &key,\n-\t\t  std::string &value)\n+parse_cfg_option (std::string &input, std::string &key, std::string &value)\n {\n   key.clear ();\n   value.clear ();\n \n-  auto equal = input.find ('=');\n+  auto lexer = Lexer::lex_string (input);\n+  auto parser = Parser<Lexer> (std::move (lexer));\n \n-  // If there is no equal sign, it means there is no value. Clean up the key\n-  // and return\n-  if (equal == std::string::npos)\n+  auto token = parser.peek_current_token ();\n+  if (token->get_id () != IDENTIFIER)\n     {\n-      key = input;\n-\n-      // FIXME: Make sure key is a proper identifier\n-\n-      return true;\n+      return false;\n     }\n \n-  key = input.substr (0, equal);\n-\n-  auto remaining_input = input.substr (equal + 1);\n-  if (remaining_input[0] != '\"' || remaining_input.back () != '\"')\n-    return false;\n-\n-  // Remove the quotes around the value, by advancing one character\n-  value = remaining_input.substr (1);\n-  // And trimming the rightmost character. This is fine since we've already\n-  // checked that both the first and last characters were quotes.\n-  value.resize (value.size () - 1);\n+  key = token->get_str ();\n \n-  // FIXME: We need to sanitize here and make sure that both key and value\n-  // are proper identifiers\n+  rust_assert (parser.skip_token (IDENTIFIER));\n+  token = parser.peek_current_token ();\n \n-  return true;\n+  switch (token->get_id ())\n+    {\n+    case END_OF_FILE:\n+      // we're done parsing, we had a valid key, return happily\n+      return true;\n+    case EQUAL:\n+      // We have an equal sign: Skip the token and parse an identifier\n+      {\n+\trust_assert (parser.skip_token (EQUAL));\n+\n+\tauto value_expr = parser.parse_literal_expr ();\n+\t// We had an equal sign but no value, error out\n+\tif (!value_expr)\n+\t  return false;\n+\n+\tif (value_expr->get_lit_type () != AST::Literal::LitType::STRING)\n+\t  return false;\n+\n+\tvalue = value_expr->get_literal ().as_string ();\n+\treturn true;\n+      }\n+    default:\n+      return false;\n+    }\n }\n-\n } // namespace Rust\n \n #if CHECKING_P\n@@ -52,23 +62,49 @@ rust_cfg_parser_test (void)\n   std::string key;\n   std::string value;\n \n-  ASSERT_TRUE (Rust::parse_cfg_option (\"key-no-value\", key, value));\n-  ASSERT_EQ (key, \"key-no-value\");\n+  auto input = std::string (\"key_no_value\");\n+\n+  ASSERT_TRUE (Rust::parse_cfg_option (input, key, value));\n+  ASSERT_EQ (key, \"key_no_value\");\n   ASSERT_TRUE (value.empty ());\n \n-  ASSERT_TRUE (Rust::parse_cfg_option (\"k=\\\"v\\\"\", key, value));\n+  input = std::string (\"k=\\\"v\\\"\");\n+\n+  ASSERT_TRUE (Rust::parse_cfg_option (input, key, value));\n   ASSERT_EQ (key, \"k\");\n   ASSERT_EQ (value, \"v\");\n \n   // values should be between double quotes\n-  ASSERT_FALSE (Rust::parse_cfg_option (\"k=v\", key, value));\n+  input = std::string (\"k=v\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n \n   // No value is an error if there is an equal sign\n-  ASSERT_FALSE (Rust::parse_cfg_option (\"k=\", key, value));\n+  input = std::string (\"k=\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n \n   // No key is an error\n-  ASSERT_FALSE (Rust::parse_cfg_option (\"=\", key, value));\n-  ASSERT_FALSE (Rust::parse_cfg_option (\"=value\", key, value));\n+  input = std::string (\"=\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"=value\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // values that are not string literals are an error\n+  input = std::string (\"key=b\\\"a\\\"\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key='v'\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key=155\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key=3.14\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // kebab case is not valid for an identifier\n+  input = std::string (\"key-no-value\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n }\n } // namespace selftest\n "}, {"sha": "bf4ed4d496e962324d0397c2625cd816334d6082", "filename": "gcc/rust/parse/rust-cfg-parser.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Fparse%2Frust-cfg-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Fparse%2Frust-cfg-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-cfg-parser.h?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -41,8 +41,7 @@ namespace Rust {\n  * @return false if the given input was invalid, true otherwise\n  */\n bool\n-parse_cfg_option (const std::string &input, std::string &key,\n-\t\t  std::string &value);\n+parse_cfg_option (std::string &input, std::string &key, std::string &value);\n } // namespace Rust\n \n #if CHECKING_P"}, {"sha": "54a64435a60cd21c119a0f38b4cd900bc8fce9ad", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -366,9 +366,11 @@ Session::handle_option (\n       Compile::Mangler::set_mangling (flag_rust_mangling);\n       break;\n \n-    case OPT_frust_cfg_:\n-      ret = handle_cfg_option (std::string (arg));\n-      break;\n+      case OPT_frust_cfg_: {\n+\tauto string_arg = std::string (arg);\n+\tret = handle_cfg_option (string_arg);\n+\tbreak;\n+      }\n \n     default:\n       break;\n@@ -378,7 +380,7 @@ Session::handle_option (\n }\n \n bool\n-Session::handle_cfg_option (const std::string &input)\n+Session::handle_cfg_option (std::string &input)\n {\n   std::string key;\n   std::string value;\n@@ -402,8 +404,8 @@ Session::handle_cfg_option (const std::string &input)\n   return true;\n }\n \n-/* Enables a certain dump depending on the name passed in. Returns true if name\n- * is valid, false otherwise. */\n+/* Enables a certain dump depending on the name passed in. Returns true if\n+ * name is valid, false otherwise. */\n bool\n Session::enable_dump (std::string arg)\n {\n@@ -532,8 +534,8 @@ Session::parse_file (const char *filename)\n    * line into crate root)\n    *  - injection (some lint checks or dummy, register builtin macros, crate\n    * injection)\n-   *  - expansion (expands all macros, maybe build test harness, AST validation,\n-   * maybe macro crate)\n+   *  - expansion (expands all macros, maybe build test harness, AST\n+   * validation, maybe macro crate)\n    *  - resolution (name resolution, type resolution, maybe feature checking,\n    * maybe buffered lints)\n    *  TODO not done */\n@@ -603,8 +605,8 @@ Session::parse_file (const char *filename)\n   if (saw_errors ())\n     return;\n \n-  // scan unused has to be done after type resolution since methods are resolved\n-  // at that point\n+  // scan unused has to be done after type resolution since methods are\n+  // resolved at that point\n   Resolver::ScanUnused::Scan ();\n \n   if (saw_errors ())\n@@ -638,11 +640,11 @@ Session::debug_dump_load_crates (Parser<Lexer> &parser)\n \n   /* TODO: search through inner attrs and see whether any of those attr paths\n    * contain \"no_core\", \"no_std\", \"compiler_builtins\". If so/not, save certain\n-   * crate names. In these names, insert items at beginning of crate items. This\n-   * is crate injection. Also, inject prelude use decl at beginning (first name\n-   * is assumed to be prelude - prelude is a use decl automatically generated to\n-   * enable using Option and Copy without qualifying it or importing it via\n-   * 'use' manually) */\n+   * crate names. In these names, insert items at beginning of crate items.\n+   * This is crate injection. Also, inject prelude use decl at beginning\n+   * (first name is assumed to be prelude - prelude is a use decl\n+   * automatically generated to enable using Option and Copy without\n+   * qualifying it or importing it via 'use' manually) */\n \n   std::vector<std::string> crate_names;\n   for (const auto &item : crate.items)\n@@ -695,8 +697,8 @@ Session::injection (AST::Crate &crate)\n \n   // register builtin macros\n   /* In rustc, builtin macros are divided into 3 categories depending on use -\n-   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings of\n-   * these categories should be fairly obvious to anyone who has used rust.\n+   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings\n+   * of these categories should be fairly obvious to anyone who has used rust.\n    * Builtin macro list by category: Bang\n    *      - asm\n    *      - assert\n@@ -739,8 +741,8 @@ Session::injection (AST::Crate &crate)\n    * rustc also has a \"quote\" macro that is defined differently and is\n    * supposedly not stable so eh. */\n   /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and test should be prioritised since they seem to be used the\n-   * most. */\n+   * macros, cfg, and test should be prioritised since they seem to be used\n+   * the most. */\n \n   // crate injection\n   std::vector<std::string> names;\n@@ -804,11 +806,11 @@ Session::injection (AST::Crate &crate)\n   crate.items.insert (crate.items.begin (), std::move (use_decl));\n \n   /* TODO: potentially add checking attribute crate type? I can't figure out\n-   * what this does currently comment says \"Unconditionally collect crate types\n-   * from attributes to make them used\", which presumably refers to checking the\n-   * linkage info by \"crate_type\". It also seems to ensure that an invalid crate\n-   * type is not specified, so maybe just do that. Valid crate types: bin lib\n-   * dylib staticlib cdylib rlib proc-macro */\n+   * what this does currently comment says \"Unconditionally collect crate\n+   * types from attributes to make them used\", which presumably refers to\n+   * checking the linkage info by \"crate_type\". It also seems to ensure that\n+   * an invalid crate type is not specified, so maybe just do that. Valid\n+   * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n \n   rust_debug (\"finished injection\");\n }\n@@ -818,8 +820,8 @@ Session::expansion (AST::Crate &crate)\n {\n   rust_debug (\"started expansion\");\n \n-  /* rustc has a modification to windows PATH temporarily here, which may end up\n-   * being required */\n+  /* rustc has a modification to windows PATH temporarily here, which may end\n+   * up being required */\n \n   // create macro expansion config?\n   // if not, would at least have to configure recursion_limit\n@@ -1036,10 +1038,10 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  * [types/values] or absolute paths)\n  *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n  * module tree])\n- *  - resolve type aliases (replace any usages of type aliases with actual type\n- * [except associated types])\n- *  - resolve bind (iterate HIR tree and set binding annotations on all concrete\n- * types [avoids path lookups later])\n+ *  - resolve type aliases (replace any usages of type aliases with actual\n+ * type [except associated types])\n+ *  - resolve bind (iterate HIR tree and set binding annotations on all\n+ * concrete types [avoids path lookups later])\n  *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n  * for all types\n  *  - sort impls (small pass - sort impls into groups)\n@@ -1059,8 +1061,8 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  * function calls)\n  *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n  * 'v'])\n- *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true\n- * type)\n+ *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the\n+ * true type)\n  *  - typecheck expressions (validate - double check that previous passes\n  * haven't broke type system rules)\n  *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n@@ -1071,24 +1073,25 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  *  - MIR optimise (perform various simple optimisations on the MIR - constant\n  * propagation, dead code elimination, borrow elimination, some inlining)\n  *  - MIR validate PO (re-validate the MIR)\n- *  - MIR validate full (optionally: perform expensive state-tracking validation\n- * on MIR)\n- *  - trans enumerate (enumerate all items needed for code generation, primarily\n- * types used for generics)\n- *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n+ *  - MIR validate full (optionally: perform expensive state-tracking\n+ * validation on MIR)\n+ *  - trans enumerate (enumerate all items needed for code generation,\n+ * primarily types used for generics)\n+ *  - trans auto impls (create magic trait impls as enumerated in previous\n+ * pass)\n  *  - trans monomorph (generate monomorphised copies of all functions [with\n  * generics replaced with real types])\n- *  - MIR optimise inline (run optimisation again, this time with full type info\n- * [primarily for inlining])\n+ *  - MIR optimise inline (run optimisation again, this time with full type\n+ * info [primarily for inlining])\n  *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n  *  - trans codegen (generate final output file: emit C source file and call C\n  * compiler) */\n \n /* rustc compile pipeline (basic, in way less detail):\n  *  - parse input (parse .rs to AST)\n  *  - name resolution, macro expansion, and configuration (process AST\n- * recursively, resolving paths, expanding macros, processing #[cfg] nodes [i.e.\n- * maybe stripping stuff from AST])\n+ * recursively, resolving paths, expanding macros, processing #[cfg] nodes\n+ * [i.e. maybe stripping stuff from AST])\n  *  - lower to HIR\n  *  - type check and other analyses (e.g. privacy checking)\n  *  - lower to MIR and post-processing (and do stuff like borrow checking)\n@@ -1100,14 +1103,14 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  *  - register plugins (attributes injection, set various options, register\n  * lints, load plugins)\n  *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n- * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis of\n- * a test harness if required, injection of any std lib dependency and prelude,\n- * and name resolution) - actually documented inline\n+ * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis\n+ * of a test harness if required, injection of any std lib dependency and\n+ * prelude, and name resolution) - actually documented inline\n  *      - seeming pierced-together order: pre-AST expansion lint checks,\n  * registering builtin macros, crate injection, then expand all macros, then\n- * maybe build test harness, AST validation, maybe create a macro crate (if not\n- * rustdoc), name resolution, complete gated feature checking, add all buffered\n- * lints\n+ * maybe build test harness, AST validation, maybe create a macro crate (if\n+ * not rustdoc), name resolution, complete gated feature checking, add all\n+ * buffered lints\n  *  - create global context (lower to HIR)\n  *  - analysis on global context (HIR optimisations? create MIR?)\n  *  - code generation"}, {"sha": "99d16287973aae0f96c0f0115008d61805afb6d3", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -288,7 +288,7 @@ struct Session\n   void expansion (AST::Crate &crate);\n \n   // handle cfg_option\n-  bool handle_cfg_option (const std::string &data);\n+  bool handle_cfg_option (std::string &data);\n };\n } // namespace Rust\n "}, {"sha": "9190bd92a4304ec83d637b1e66800bb8c99feebd", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9f8c99c5813a23d7cec473fedf00683f409e4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=6cf9f8c99c5813a23d7cec473fedf00683f409e4", "patch": "@@ -139,7 +139,10 @@ NodeId\n Mappings::get_next_node_id (CrateNum crateNum)\n {\n   auto it = nodeIdIter.find (crateNum);\n-  rust_assert (it != nodeIdIter.end ());\n+  // We're probably *not* parsing actual rust code... but mostly reusing\n+  // the parser in another way. Return 0\n+  if (it == nodeIdIter.end ())\n+    return 0;\n \n   auto id = it->second + 1;\n   nodeIdIter[crateNum] = id;"}]}