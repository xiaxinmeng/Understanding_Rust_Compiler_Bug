{"sha": "bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhZjhhOTc4MDhjNjkxYWUzMTFhNTVjZmEwZTkzMGU5MmVlNjVhMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T13:27:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T13:27:02Z"}, "message": "[multiple changes]\n\n2017-01-23  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Indexed_Component_Form):\n\tAdapt to inlined prefix with string literal subtype.\n\t* inline.adb (Expand_Inlined_Call): Keep unchecked\n\tconversion inside inlined call when formal type is constrained.\n\n2017-01-23  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.adb (New_Copy_Tree): Code cleanup:\n\tremoval of global variables. All the global variables, global\n\tfunctions and tables of this subprogram are now declared locally.\n\nFrom-SVN: r244807", "tree": {"sha": "6cf0bfb149e1f6e7f829e54bd7462da4ed3a4229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cf0bfb149e1f6e7f829e54bd7462da4ed3a4229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/comments", "author": null, "committer": null, "parents": [{"sha": "9313a26a9ad02e45a1b75d9274f5025015356669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9313a26a9ad02e45a1b75d9274f5025015356669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9313a26a9ad02e45a1b75d9274f5025015356669"}], "stats": {"total": 271, "additions": 150, "deletions": 121}, "files": [{"sha": "bbd19a1149229eeabc09c96a7c39859b160b8cae", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "patch": "@@ -1,3 +1,16 @@\n+2017-01-23  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Indexed_Component_Form):\n+\tAdapt to inlined prefix with string literal subtype.\n+\t* inline.adb (Expand_Inlined_Call): Keep unchecked\n+\tconversion inside inlined call when formal type is constrained.\n+\n+2017-01-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_util.adb (New_Copy_Tree): Code cleanup:\n+\tremoval of global variables. All the global variables, global\n+\tfunctions and tables of this subprogram are now declared locally.\n+\n 2017-01-23  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_strm.ads: Minor reformatting and typo fixes."}, {"sha": "4e8dd7d88425b0499e054aa52de97ca37bf7ea67", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "patch": "@@ -959,6 +959,7 @@ package body Inline is\n \n       function Has_Single_Return_In_GNATprove_Mode return Boolean is\n          Last_Statement : Node_Id := Empty;\n+         Body_To_Inline : constant Node_Id := N;\n \n          function Check_Return (N : Node_Id) return Traverse_Result;\n          --  Returns OK on node N if this is not a return statement different\n@@ -970,18 +971,29 @@ package body Inline is\n \n          function Check_Return (N : Node_Id) return Traverse_Result is\n          begin\n-            if Nkind_In (N, N_Simple_Return_Statement,\n-                            N_Extended_Return_Statement)\n-            then\n-               if N = Last_Statement then\n-                  return OK;\n-               else\n-                  return Abandon;\n-               end if;\n+            case Nkind (N) is\n+               when N_Simple_Return_Statement\n+                  | N_Extended_Return_Statement\n+               =>\n+                  if N = Last_Statement then\n+                     return OK;\n+                  else\n+                     return Abandon;\n+                  end if;\n \n-            else\n-               return OK;\n-            end if;\n+               --  Skip locally declared subprogram bodies inside the body to\n+               --  inline, as the return statements inside those do not count.\n+\n+               when N_Subprogram_Body =>\n+                  if N = Body_To_Inline then\n+                     return OK;\n+                  else\n+                     return Skip;\n+                  end if;\n+\n+               when others =>\n+                  return OK;\n+            end case;\n          end Check_Return;\n \n          function Check_All_Returns is new Traverse_Func (Check_Return);\n@@ -3151,13 +3163,16 @@ package body Inline is\n                    Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n                    Expression   => Relocate_Node (Expression (A)));\n \n-            --  In GNATprove mode, keep the most precise type of the actual\n-            --  for the temporary variable. Otherwise, the AST may contain\n-            --  unexpected assignment statements to a temporary variable of\n-            --  unconstrained type renaming a local variable of constrained\n-            --  type, which is not expected by GNATprove.\n+            --  In GNATprove mode, keep the most precise type of the actual for\n+            --  the temporary variable, when the formal type is unconstrained.\n+            --  Otherwise, the AST may contain unexpected assignment statements\n+            --  to a temporary variable of unconstrained type renaming a\n+            --  local variable of constrained type, which is not expected\n+            --  by GNATprove.\n \n-            elsif Etype (F) /= Etype (A) and then not GNATprove_Mode then\n+            elsif Etype (F) /= Etype (A)\n+              and then (not GNATprove_Mode or else Is_Constrained (Etype (F)))\n+            then\n                New_A    := Unchecked_Convert_To (Etype (F), Relocate_Node (A));\n                Temp_Typ := Etype (F);\n "}, {"sha": "50fe00cccf198143cc99b262988ceb2cca06d59d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "patch": "@@ -2407,7 +2407,13 @@ package body Sem_Ch4 is\n             end if;\n \n             if Is_Array_Type (Array_Type) then\n-               null;\n+\n+               --  In order to correctly access First_Index component later,\n+               --  replace string literal subtype by its parent type.\n+\n+               if Ekind (Array_Type) = E_String_Literal_Subtype then\n+                  Array_Type := Etype (Array_Type);\n+               end if;\n \n             elsif Present (Pent) and then Ekind (Pent) = E_Entry_Family then\n                Analyze (Exp);"}, {"sha": "5f5d377310965b352e0b707bd2e4bc838f44f2cf", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 98, "deletions": 103, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaf8a97808c691ae311a55cfa0e930e92ee65a3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bfaf8a97808c691ae311a55cfa0e930e92ee65a3", "patch": "@@ -71,35 +71,6 @@ with GNAT.HTable; use GNAT.HTable;\n \n package body Sem_Util is\n \n-   ----------------------------------------\n-   -- Global Variables for New_Copy_Tree --\n-   ----------------------------------------\n-\n-   --  These global variables are used by New_Copy_Tree. See description of the\n-   --  body of this subprogram for details. Global variables can be safely used\n-   --  by New_Copy_Tree, since there is no case of a recursive call from the\n-   --  processing inside New_Copy_Tree.\n-\n-   NCT_Hash_Threshold : constant := 20;\n-   --  If there are more than this number of pairs of entries in the map, then\n-   --  Hash_Tables_Used will be set, and the hash tables will be initialized\n-   --  and used for the searches.\n-\n-   NCT_Hash_Tables_Used : Boolean := False;\n-   --  Set to True if hash tables are in use\n-\n-   NCT_Table_Entries : Nat := 0;\n-   --  Count entries in table to see if threshold is reached\n-\n-   NCT_Hash_Table_Setup : Boolean := False;\n-   --  Set to True if hash table contains data. We set this True if we setup\n-   --  the hash table with data, and leave it set permanently from then on,\n-   --  this is a signal that second and subsequent users of the hash table\n-   --  must clear the old entries before reuse.\n-\n-   subtype NCT_Header_Num is Int range 0 .. 511;\n-   --  Defines range of headers in hash tables (512 headers)\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1993,9 +1964,9 @@ package body Sem_Util is\n          function Contains (List : Elist_Id; N : Node_Id) return Boolean;\n          --  Returns True if List has a node whose Entity is Entity (N)\n \n-         -------------------------\n-         -- Check_Function_Call --\n-         -------------------------\n+         ----------------\n+         -- Check_Node --\n+         ----------------\n \n          function Check_Node (N : Node_Id) return Traverse_Result is\n             Is_Writable_Actual : Boolean := False;\n@@ -16245,71 +16216,6 @@ package body Sem_Util is\n       end if;\n    end New_Copy_List_Tree;\n \n-   --------------------------------------------------\n-   -- New_Copy_Tree Auxiliary Data and Subprograms --\n-   --------------------------------------------------\n-\n-   use Atree.Unchecked_Access;\n-   use Atree_Private_Part;\n-\n-   --  Our approach here requires a two pass traversal of the tree. The\n-   --  first pass visits all nodes that eventually will be copied looking\n-   --  for defining Itypes. If any defining Itypes are found, then they are\n-   --  copied, and an entry is added to the replacement map. In the second\n-   --  phase, the tree is copied, using the replacement map to replace any\n-   --  Itype references within the copied tree.\n-\n-   --  The following hash tables are used if the Map supplied has more\n-   --  than hash threshold entries to speed up access to the map. If\n-   --  there are fewer entries, then the map is searched sequentially\n-   --  (because setting up a hash table for only a few entries takes\n-   --  more time than it saves.\n-\n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n-   --  Hash function used for hash operations\n-\n-   -------------------\n-   -- New_Copy_Hash --\n-   -------------------\n-\n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n-   begin\n-      return Nat (E) mod (NCT_Header_Num'Last + 1);\n-   end New_Copy_Hash;\n-\n-   ---------------\n-   -- NCT_Assoc --\n-   ---------------\n-\n-   --  The hash table NCT_Assoc associates old entities in the table with their\n-   --  corresponding new entities (i.e. the pairs of entries presented in the\n-   --  original Map argument are Key-Element pairs).\n-\n-   package NCT_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n-     Element    => Entity_Id,\n-     No_Element => Empty,\n-     Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n-\n-   ---------------------\n-   -- NCT_Itype_Assoc --\n-   ---------------------\n-\n-   --  The hash table NCT_Itype_Assoc contains entries only for those old\n-   --  nodes which have a non-empty Associated_Node_For_Itype set. The key\n-   --  is the associated node, and the element is the new node itself (NOT\n-   --  the associated node for the new node).\n-\n-   package NCT_Itype_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n-     Element    => Entity_Id,\n-     No_Element => Empty,\n-     Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n-\n    -------------------\n    -- New_Copy_Tree --\n    -------------------\n@@ -16329,6 +16235,81 @@ package body Sem_Util is\n       --  (and normally is) initialized to No_Elist, and if we have mapped\n       --  entities, we have to reset it to point to a real Elist.\n \n+      NCT_Hash_Threshold : constant := 20;\n+      --  If there are more than this number of pairs of entries in the map,\n+      --  then Hash_Tables_Used will be set, and the hash tables will be\n+      --  initialized and used for the searches.\n+\n+      NCT_Hash_Tables_Used : Boolean := False;\n+      --  Set to True if hash tables are in use\n+\n+      NCT_Table_Entries : Nat := 0;\n+      --  Count entries in table to see if threshold is reached\n+\n+      NCT_Hash_Table_Setup : Boolean := False;\n+      --  Set to True if hash table contains data. We set this True if we setup\n+      --  the hash table with data. This is a signal that we must clear its\n+      --  contents before returning the tree copy.\n+\n+      ------------------------------------\n+      -- Auxiliary Data and Subprograms --\n+      ------------------------------------\n+\n+      use Atree.Unchecked_Access;\n+      use Atree_Private_Part;\n+\n+      --  Our approach here requires a two pass traversal of the tree. The\n+      --  first pass visits all nodes that eventually will be copied looking\n+      --  for defining Itypes. If any defining Itypes are found, then they are\n+      --  copied, and an entry is added to the replacement map. In the second\n+      --  phase, the tree is copied, using the replacement map to replace any\n+      --  Itype references within the copied tree.\n+\n+      --  The following hash tables are used if the Map supplied has more\n+      --  than hash threshold entries to speed up access to the map. If\n+      --  there are fewer entries, then the map is searched sequentially\n+      --  (because setting up a hash table for only a few entries takes\n+      --  more time than it saves.\n+\n+      subtype NCT_Header_Num is Int range 0 .. 511;\n+      --  Defines range of headers in hash tables (512 headers)\n+\n+      function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n+      --  Hash function used for hash operations\n+\n+      ---------------\n+      -- NCT_Assoc --\n+      ---------------\n+\n+      --  The hash table NCT_Assoc associates old entities in the table with\n+      --  their corresponding new entities (i.e. the pairs of entries presented\n+      --  in the original Map argument are Key-Element pairs).\n+\n+      package NCT_Assoc is new Simple_HTable (\n+        Header_Num => NCT_Header_Num,\n+        Element    => Entity_Id,\n+        No_Element => Empty,\n+        Key        => Entity_Id,\n+        Hash       => New_Copy_Hash,\n+        Equal      => Types.\"=\");\n+\n+      ---------------------\n+      -- NCT_Itype_Assoc --\n+      ---------------------\n+\n+      --  The hash table NCT_Itype_Assoc contains entries only for those old\n+      --  nodes which have a non-empty Associated_Node_For_Itype set. The key\n+      --  is the associated node, and the element is the new node itself (NOT\n+      --  the associated node for the new node).\n+\n+      package NCT_Itype_Assoc is new Simple_HTable (\n+        Header_Num => NCT_Header_Num,\n+        Element    => Entity_Id,\n+        No_Element => Empty,\n+        Key        => Entity_Id,\n+        Hash       => New_Copy_Hash,\n+        Equal      => Types.\"=\");\n+\n       function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n       --  Called during second phase to map entities into their corresponding\n       --  copies using Actual_Map. If the argument is not an entity, or is not\n@@ -16418,11 +16399,6 @@ package body Sem_Util is\n          Ent  : Entity_Id;\n \n       begin\n-         if NCT_Hash_Table_Setup then\n-            NCT_Assoc.Reset;\n-            NCT_Itype_Assoc.Reset;\n-         end if;\n-\n          Elmt := First_Elmt (Actual_Map);\n          while Present (Elmt) loop\n             Ent := Node (Elmt);\n@@ -16814,6 +16790,15 @@ package body Sem_Util is\n          return New_Node;\n       end Copy_Node_With_Replacement;\n \n+      -------------------\n+      -- New_Copy_Hash --\n+      -------------------\n+\n+      function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n+      begin\n+         return Nat (E) mod (NCT_Header_Num'Last + 1);\n+      end New_Copy_Hash;\n+\n       -----------------\n       -- Visit_Elist --\n       -----------------\n@@ -17161,7 +17146,17 @@ package body Sem_Util is\n \n       --  Now we can copy the actual tree\n \n-      return Copy_Node_With_Replacement (Source);\n+      declare\n+         Result : constant Node_Id := Copy_Node_With_Replacement (Source);\n+\n+      begin\n+         if NCT_Hash_Table_Setup then\n+            NCT_Assoc.Reset;\n+            NCT_Itype_Assoc.Reset;\n+         end if;\n+\n+         return Result;\n+      end;\n    end New_Copy_Tree;\n \n    -------------------------"}]}