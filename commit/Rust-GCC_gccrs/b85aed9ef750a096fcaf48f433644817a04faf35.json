{"sha": "b85aed9ef750a096fcaf48f433644817a04faf35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1YWVkOWVmNzUwYTA5NmZjYWY0OGY0MzM2NDQ4MTdhMDRmYWYzNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-01-18T09:42:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-01-18T09:42:11Z"}, "message": "mips.c: Include cfglayout.h.\n\n\t* config/mips/mips.c: Include cfglayout.h.\n\t(TARGET_ASM_OUTPUT_MI_THUNK, TARGET_ASM_CAN_OUTPUT_MI_THUNK): Define.\n\t(mips_unspec_offset_high): Add temporary register argument.\n\t(mips_load_call_address): New function, split out from...\n\t(mips_expand_call): ...here.\n\t(mips_output_cplocal): New function.\n\t(mips_output_function_prologue, mips_output_function_epilogue): Use it.\n\t(mips_emit_loadgp): New function, split out from...\n\t(mips_expand_prologue): ...here.\n\t(mips_output_mi_thunk): New function.\n\nFrom-SVN: r76088", "tree": {"sha": "ba5513c9d17594eda333d4a7d51b944f2e213e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba5513c9d17594eda333d4a7d51b944f2e213e84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b85aed9ef750a096fcaf48f433644817a04faf35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85aed9ef750a096fcaf48f433644817a04faf35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85aed9ef750a096fcaf48f433644817a04faf35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85aed9ef750a096fcaf48f433644817a04faf35/comments", "author": null, "committer": null, "parents": [{"sha": "e5d95b699363ad0c5841c0b89ee0b43e92e89bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d95b699363ad0c5841c0b89ee0b43e92e89bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5d95b699363ad0c5841c0b89ee0b43e92e89bcc"}], "stats": {"total": 270, "additions": 230, "deletions": 40}, "files": [{"sha": "04568ec916382ac10ccc66c8218d08e7025f3481", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85aed9ef750a096fcaf48f433644817a04faf35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85aed9ef750a096fcaf48f433644817a04faf35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b85aed9ef750a096fcaf48f433644817a04faf35", "patch": "@@ -1,3 +1,16 @@\n+2004-01-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c: Include cfglayout.h.\n+\t(TARGET_ASM_OUTPUT_MI_THUNK, TARGET_ASM_CAN_OUTPUT_MI_THUNK): Define.\n+\t(mips_unspec_offset_high): Add temporary register argument.\n+\t(mips_load_call_address): New function, split out from...\n+\t(mips_expand_call): ...here.\n+\t(mips_output_cplocal): New function.\n+\t(mips_output_function_prologue, mips_output_function_epilogue): Use it.\n+\t(mips_emit_loadgp): New function, split out from...\n+\t(mips_expand_prologue): ...here.\n+\t(mips_output_mi_thunk): New function.\n+\n 2004-01-17  Bernardo Innocenti  <bernie@develer.com>\n \n \t* longlong.h (mc68020, __mc68030__, mc68030, __mc68040__, mc68040,"}, {"sha": "131c5594015a3d0107fb7630ec709ba26250e2f6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 217, "deletions": 40, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85aed9ef750a096fcaf48f433644817a04faf35/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85aed9ef750a096fcaf48f433644817a04faf35/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b85aed9ef750a096fcaf48f433644817a04faf35", "patch": "@@ -53,6 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"integrate.h\"\n #include \"langhooks.h\"\n+#include \"cfglayout.h\"\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n@@ -200,7 +201,7 @@ static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_force_temporary (rtx, rtx);\n static rtx mips_split_symbol (rtx, rtx);\n static rtx mips_unspec_address (rtx, enum mips_symbol_type);\n-static rtx mips_unspec_offset_high (rtx, rtx, enum mips_symbol_type);\n+static rtx mips_unspec_offset_high (rtx, rtx, rtx, enum mips_symbol_type);\n static rtx mips_load_got (rtx, rtx, enum mips_symbol_type);\n static rtx mips_add_offset (rtx, HOST_WIDE_INT);\n static unsigned int mips_build_shift (struct mips_integer_op *, HOST_WIDE_INT);\n@@ -216,6 +217,7 @@ static int mips_address_cost (rtx);\n static enum internal_test map_test_to_internal_test (enum rtx_code);\n static void get_float_compare_codes (enum rtx_code, enum rtx_code *,\n \t\t\t\t     enum rtx_code *);\n+static void mips_load_call_address (rtx, rtx, int);\n static bool mips_function_ok_for_sibcall (tree, tree);\n static void mips_block_move_straight (rtx, rtx, HOST_WIDE_INT);\n static void mips_adjust_block_mem (rtx, HOST_WIDE_INT, rtx *, rtx *);\n@@ -239,12 +241,16 @@ static bool mips_save_reg_p (unsigned int);\n static void mips_save_restore_reg (enum machine_mode, int, HOST_WIDE_INT,\n \t\t\t\t   mips_save_restore_fn);\n static void mips_for_each_saved_reg (HOST_WIDE_INT, mips_save_restore_fn);\n+static void mips_output_cplocal (void);\n+static void mips_emit_loadgp (void);\n static void mips_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void mips_set_frame_expr (rtx);\n static rtx mips_frame_set (rtx, rtx);\n static void mips_save_reg (rtx, rtx);\n static void mips_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void mips_restore_reg (rtx, rtx);\n+static void mips_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t  HOST_WIDE_INT, tree);\n static int symbolic_expression_p (rtx);\n static void mips_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t     unsigned HOST_WIDE_INT);\n@@ -792,6 +798,11 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #undef TARGET_RETURN_IN_MSB\n #define TARGET_RETURN_IN_MSB mips_return_in_msb\n \n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK mips_output_mi_thunk\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n@@ -1648,17 +1659,19 @@ mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n \n /* If mips_unspec_address (ADDR, SYMBOL_TYPE) is a 32-bit value, add the\n    high part to BASE and return the result.  Just return BASE otherwise.\n+   TEMP is available as a temporary register if needed.\n \n    The returned expression can be used as the first operand to a LO_SUM.  */\n \n static rtx\n-mips_unspec_offset_high (rtx base, rtx addr, enum mips_symbol_type symbol_type)\n+mips_unspec_offset_high (rtx temp, rtx base, rtx addr,\n+\t\t\t enum mips_symbol_type symbol_type)\n {\n   if (mips_split_p[symbol_type])\n     {\n       addr = gen_rtx_HIGH (Pmode, mips_unspec_address (addr, symbol_type));\n-      base = force_reg (Pmode, expand_simple_binop (Pmode, PLUS, base, addr,\n-\t\t\t\t\t\t    NULL, 0, OPTAB_WIDEN));\n+      addr = mips_force_temporary (temp, addr);\n+      return mips_force_temporary (temp, gen_rtx_PLUS (Pmode, addr, base));\n     }\n   return base;\n }\n@@ -3192,6 +3205,35 @@ mips_gen_conditional_trap (rtx *operands)\n \t\t\t      operands[1]));\n }\n \f\n+/* Load function address ADDR into register DEST.  SIBCALL_P is true\n+   if the address is needed for a sibling call.  */\n+\n+static void\n+mips_load_call_address (rtx dest, rtx addr, int sibcall_p)\n+{\n+  /* If we're generating PIC, and this call is to a global function,\n+     try to allow its address to be resolved lazily.  This isn't\n+     possible for NewABI sibcalls since the value of $gp on entry\n+     to the stub would be our caller's gp, not ours.  */\n+  if (TARGET_EXPLICIT_RELOCS\n+      && !(sibcall_p && TARGET_NEWABI)\n+      && global_got_operand (addr, VOIDmode))\n+    {\n+      rtx high, lo_sum_symbol;\n+\n+      high = mips_unspec_offset_high (dest, pic_offset_table_rtx,\n+\t\t\t\t      addr, SYMBOL_GOTOFF_CALL);\n+      lo_sum_symbol = mips_unspec_address (addr, SYMBOL_GOTOFF_CALL);\n+      if (Pmode == SImode)\n+\temit_insn (gen_load_callsi (dest, high, lo_sum_symbol));\n+      else\n+\temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n+    }\n+  else\n+    emit_move_insn (dest, addr);\n+}\n+\n+\n /* Expand a call or call_value instruction.  RESULT is where the\n    result will go (null for calls), ADDR is the address of the\n    function, ARGS_SIZE is the size of the arguments and AUX is\n@@ -3204,27 +3246,9 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n {\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n-      /* If we're generating PIC, and this call is to a global function,\n-\t try to allow its address to be resolved lazily.  This isn't\n-\t possible for NewABI sibcalls since the value of $gp on entry\n-\t to the stub would be our caller's gp, not ours.  */\n-      if (TARGET_EXPLICIT_RELOCS\n-\t  && !(sibcall_p && TARGET_NEWABI)\n-\t  && global_got_operand (addr, VOIDmode))\n-\t{\n-\t  rtx high, lo_sum_symbol;\n-\n-\t  high = mips_unspec_offset_high (pic_offset_table_rtx,\n-\t\t\t\t\t  addr, SYMBOL_GOTOFF_CALL);\n-\t  lo_sum_symbol = mips_unspec_address (addr, SYMBOL_GOTOFF_CALL);\n-\t  addr = gen_reg_rtx (Pmode);\n-\t  if (Pmode == SImode)\n-\t    emit_insn (gen_load_callsi (addr, high, lo_sum_symbol));\n-\t  else\n-\t    emit_insn (gen_load_calldi (addr, high, lo_sum_symbol));\n-\t}\n-      else\n-\taddr = force_reg (Pmode, addr);\n+      rtx dest = gen_reg_rtx (Pmode);\n+      mips_load_call_address (dest, addr, sibcall_p);\n+      addr = dest;\n     }\n \n   if (TARGET_MIPS16\n@@ -6466,6 +6490,38 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n #undef BITSET_P\n }\n \f\n+/* If we're generating n32 or n64 abicalls, and the current function\n+   does not use $28 as its global pointer, emit a cplocal directive.\n+   Use pic_offset_table_rtx as the argument to the directive.  */\n+\n+static void\n+mips_output_cplocal (void)\n+{\n+  if (!TARGET_EXPLICIT_RELOCS\n+      && cfun->machine->global_pointer > 0\n+      && cfun->machine->global_pointer != GLOBAL_POINTER_REGNUM)\n+    output_asm_insn (\".cplocal %+\", 0);\n+}\n+\n+/* If we're generating n32 or n64 abicalls, emit instructions\n+   to set up the global pointer.  */\n+\n+static void\n+mips_emit_loadgp (void)\n+{\n+  if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n+    {\n+      rtx addr, offset, incoming_address;\n+\n+      addr = XEXP (DECL_RTL (current_function_decl), 0);\n+      offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);\n+      incoming_address = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n+      emit_insn (gen_loadgp (offset, incoming_address));\n+      if (!TARGET_EXPLICIT_RELOCS)\n+\temit_insn (gen_loadgp_blockage ());\n+    }\n+}\n+\n /* Set up the stack and frame (if desired) for the function.  */\n \n static void\n@@ -6554,6 +6610,11 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     }\n   else if (cfun->machine->all_noreorder_p)\n     output_asm_insn (\"%(%<\", 0);\n+\n+  /* Tell the assembler which register we're using as the global\n+     pointer.  This is needed for thunks, since they can use either\n+     explicit relocs or assembler macros.  */\n+  mips_output_cplocal ();\n }\n \f\n /* Make the last instruction frame related and note that it performs\n@@ -6709,18 +6770,7 @@ mips_expand_prologue (void)\n   if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n     emit_insn (gen_cprestore (GEN_INT (current_function_outgoing_args_size)));\n \n-  /* If generating n32/n64 abicalls, emit the instructions to load $gp.  */\n-  if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n-    {\n-      rtx addr, offset, incoming_address;\n-\n-      addr = XEXP (DECL_RTL (current_function_decl), 0);\n-      offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);\n-      incoming_address = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n-      emit_insn (gen_loadgp (offset, incoming_address));\n-      if (!TARGET_EXPLICIT_RELOCS)\n-\temit_insn (gen_loadgp_blockage ());\n-    }\n+  mips_emit_loadgp ();\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n@@ -6741,6 +6791,10 @@ mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n {\n   rtx string;\n \n+  /* Reinstate the normal $gp.  */\n+  REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n+  mips_output_cplocal ();\n+\n   if (cfun->machine->all_noreorder_p)\n     {\n       /* Avoid using %>%) since it adds excess whitespace.  */\n@@ -6781,9 +6835,6 @@ mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n   for (string = mips16_strings; string != 0; string = XEXP (string, 1))\n     SYMBOL_REF_FLAG (XEXP (string, 0)) = 0;\n   free_EXPR_LIST_list (&mips16_strings);\n-\n-  /* Reinstate the normal $gp.  */\n-  REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n }\n \f\n /* Emit instructions to restore register REG from slot MEM.  */\n@@ -6954,6 +7005,132 @@ mips_can_use_return_insn (void)\n   return compute_frame_size (get_frame_size ()) == 0;\n }\n \f\n+/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n+   in order to avoid duplicating too much logic from elsewhere.  */\n+\n+static void\n+mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t      tree function)\n+{\n+  rtx this, temp1, temp2, insn, fnaddr;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  no_new_pseudos = 1;\n+  reload_completed = 1;\n+\n+  /* Pick a global pointer for -mabicalls.  Use $15 rather than $28\n+     for TARGET_NEWABI since the latter is a call-saved register.  */\n+  if (TARGET_ABICALLS)\n+    cfun->machine->global_pointer\n+      = REGNO (pic_offset_table_rtx)\n+      = TARGET_NEWABI ? 15 : GLOBAL_POINTER_REGNUM;\n+\n+  /* Set up the global pointer for n32 or n64 abicalls.  */\n+  mips_emit_loadgp ();\n+\n+  /* We need two temporary registers in some cases.  */\n+  temp1 = gen_rtx_REG (Pmode, 2);\n+  temp2 = gen_rtx_REG (Pmode, 3);\n+\n+  /* Find out which register contains the \"this\" pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this = gen_rtx_REG (Pmode, GP_ARG_FIRST + 1);\n+  else\n+    this = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n+\n+  /* Add DELTA to THIS.  */\n+  if (delta != 0)\n+    {\n+      rtx offset = GEN_INT (delta);\n+      if (!SMALL_OPERAND (delta))\n+\t{\n+\t  emit_move_insn (temp1, offset);\n+\t  offset = temp1;\n+\t}\n+      emit_insn (gen_add3_insn (this, this, offset));\n+    }\n+\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      rtx addr;\n+\n+      /* Set TEMP1 to *THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+\n+      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      if (SMALL_OPERAND (vcall_offset))\n+\taddr = gen_rtx_PLUS (Pmode, temp1, GEN_INT (vcall_offset));\n+      else if (TARGET_MIPS16)\n+\t{\n+\t  /* Load the full offset into a register so that we can use\n+\t     an unextended instruction for the load itself.  */\n+\t  emit_move_insn (temp2, GEN_INT (vcall_offset));\n+\t  emit_insn (gen_add3_insn (temp1, temp1, temp2));\n+\t  addr = temp1;\n+\t}\n+      else\n+\t{\n+\t  /* Load the high part of the offset into a register and\n+\t     leave the low part for the address.  */\n+\t  emit_move_insn (temp2, GEN_INT (CONST_HIGH_PART (vcall_offset)));\n+\t  emit_insn (gen_add3_insn (temp1, temp1, temp2));\n+\t  addr = gen_rtx_PLUS (Pmode, temp1,\n+\t\t\t       GEN_INT (CONST_LOW_PART (vcall_offset)));\n+\t}\n+\n+      /* Load the offset and add it to THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (this, this, temp1));\n+    }\n+\n+  /* Jump to the target function.  Use a sibcall if direct jumps are\n+     allowed, otherwise load the address into a register first.  */\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n+  if (TARGET_MIPS16 || TARGET_ABICALLS || TARGET_LONG_CALLS)\n+    {\n+      /* This is messy.  gas treats \"la $25,foo\" as part of a call\n+\t sequence and may allow a global \"foo\" to be lazily bound.\n+\t The general move patterns therefore reject this combination.\n+\n+\t In this context, lazy binding would actually be OK for o32 and o64,\n+\t but it's still wrong for n32 and n64; see mips_load_call_address.\n+\t We must therefore load the address via a temporary register if\n+\t mips_dangerous_for_la25_p.\n+\n+\t If we jump to the temporary register rather than $25, the assembler\n+\t can use the move insn to fill the jump's delay slot.  */\n+      if (TARGET_ABICALLS && !mips_dangerous_for_la25_p (fnaddr))\n+\ttemp1 = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n+      mips_load_call_address (temp1, fnaddr, true);\n+\n+      if (TARGET_ABICALLS && REGNO (temp1) != PIC_FUNCTION_ADDR_REGNUM)\n+\temit_move_insn (gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM), temp1);\n+      emit_jump_insn (gen_indirect_jump (temp1));\n+    }\n+  else\n+    {\n+      insn = emit_call_insn (gen_sibcall_internal (fnaddr, const0_rtx));\n+      SIBLING_CALL_P (insn) = 1;\n+    }\n+\n+  /* Run just enough of rest_of_compilation.  This sequence was\n+     \"borrowed\" from alpha.c.  */\n+  insn = get_insns ();\n+  insn_locators_initialize ();\n+  split_all_insns_noflow ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1, 0);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  Note that final_end_function resets\n+     the global pointer for us.  */\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n+}\n+\f\n /* Returns nonzero if X contains a SYMBOL_REF.  */\n \n static int"}]}