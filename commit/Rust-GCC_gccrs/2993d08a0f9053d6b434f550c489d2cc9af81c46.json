{"sha": "2993d08a0f9053d6b434f550c489d2cc9af81c46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk5M2QwOGEwZjkwNTNkNmI0MzRmNTUwYzQ4OWQyY2M5YWY4MWM0Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-09-15T19:34:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-09-15T19:34:42Z"}, "message": "Core DR 904 PR c++/41933\n\n\tCore DR 904\n\tPR c++/41933\n\t* parser.c (cp_parser_lambda_introducer): Handle variadic capture.\n\t* lambda.c (add_capture): Handle variadic capture.\n\t(add_default_capture, lambda_capture_field_type): Likewise.\n\t(build_capture_proxy, register_capture_members): Likewise.\n\t* pt.c (register_specialization): Allow FIELD_DECL.\n\t(retrieve_specialization): Likewise.\n\t(find_parameter_packs_r): Handle FIELD_DECL and VAR_DECL.\n\t(tsubst_pack_expansion): Handle FIELD_DECL packs.\n\t(gen_elem_of_pack_expansion_instantiation): Likewise.\n\t(instantiate_class_template_1): Likewise.\n\t(tsubst_decl, tsubst_copy): Likewise.\n\t(tsubst_expr) [DECL_EXPR]: Handle capture proxy packs.\n\t(tsubst_copy_and_build) [VAR_DECL]: Likewise.\n\t* semantics.c (finish_non_static_data_member): Don't try to represent\n\tthe type of a COMPOUND_REF of a FIELD_DECL pack.\n\nFrom-SVN: r202605", "tree": {"sha": "1ea5c1ef411fbda7152061fe7ec9543ea81fc0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ea5c1ef411fbda7152061fe7ec9543ea81fc0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2993d08a0f9053d6b434f550c489d2cc9af81c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2993d08a0f9053d6b434f550c489d2cc9af81c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2993d08a0f9053d6b434f550c489d2cc9af81c46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2993d08a0f9053d6b434f550c489d2cc9af81c46/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "73f4e2d261705d356b2283ae1576e495b74e7992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73f4e2d261705d356b2283ae1576e495b74e7992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73f4e2d261705d356b2283ae1576e495b74e7992"}], "stats": {"total": 433, "additions": 338, "deletions": 95}, "files": [{"sha": "c3c2edeb414dddc79085f06dd407e538ab172b91", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -1,5 +1,23 @@\n 2013-09-15  Jason Merrill  <jason@redhat.com>\n \n+\tCore DR 904\n+\tPR c++/41933\n+\t* parser.c (cp_parser_lambda_introducer): Handle variadic capture.\n+\t* lambda.c (add_capture): Handle variadic capture.\n+\t(add_default_capture, lambda_capture_field_type): Likewise.\n+\t(build_capture_proxy, register_capture_members): Likewise.\n+\t* pt.c (register_specialization): Allow FIELD_DECL.\n+\t(retrieve_specialization): Likewise.\n+\t(find_parameter_packs_r): Handle FIELD_DECL and VAR_DECL.\n+\t(tsubst_pack_expansion): Handle FIELD_DECL packs.\n+\t(gen_elem_of_pack_expansion_instantiation): Likewise.\n+\t(instantiate_class_template_1): Likewise.\n+\t(tsubst_decl, tsubst_copy): Likewise.\n+\t(tsubst_expr) [DECL_EXPR]: Handle capture proxy packs.\n+\t(tsubst_copy_and_build) [VAR_DECL]: Likewise.\n+\t* semantics.c (finish_non_static_data_member): Don't try to represent\n+\tthe type of a COMPOUND_REF of a FIELD_DECL pack.\n+\n \tPR c++/41933\n \t* cp-tree.h (DECL_PACK_P): Replace FUNCTION_PARAMETER_PACK_P.\n \t* cxx-pretty-print.c (direct_declarator): Adjust."}, {"sha": "1af301d47afae6be2bb39aa21260f2f9a74d20dc", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -215,7 +215,8 @@ lambda_capture_field_type (tree expr, bool explicit_init_p)\n     }\n   else\n     type = non_reference (unlowered_expr_type (expr));\n-  if (!type || WILDCARD_TYPE_P (type) || type_uses_auto (type))\n+  if (!type || WILDCARD_TYPE_P (type) || type_uses_auto (type)\n+      || DECL_PACK_P (expr))\n     {\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n@@ -320,15 +321,21 @@ tree\n lambda_proxy_type (tree ref)\n {\n   tree type;\n+  if (ref == error_mark_node)\n+    return error_mark_node;\n   if (REFERENCE_REF_P (ref))\n     ref = TREE_OPERAND (ref, 0);\n+  gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n   type = TREE_TYPE (ref);\n-  if (type && !WILDCARD_TYPE_P (non_reference (type)))\n-    return type;\n-  type = cxx_make_type (DECLTYPE_TYPE);\n-  DECLTYPE_TYPE_EXPR (type) = ref;\n-  DECLTYPE_FOR_LAMBDA_PROXY (type) = true;\n-  SET_TYPE_STRUCTURAL_EQUALITY (type);\n+  if (!type || WILDCARD_TYPE_P (non_reference (type)))\n+    {\n+      type = cxx_make_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = ref;\n+      DECLTYPE_FOR_LAMBDA_PROXY (type) = true;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+    }\n+  if (DECL_PACK_P (TREE_OPERAND (ref, 1)))\n+    type = make_pack_expansion (type);\n   return type;\n }\n \n@@ -341,6 +348,9 @@ build_capture_proxy (tree member)\n {\n   tree var, object, fn, closure, name, lam, type;\n \n+  if (PACK_EXPANSION_P (member))\n+    member = PACK_EXPANSION_PATTERN (member);\n+\n   closure = DECL_CONTEXT (member);\n   fn = lambda_function (closure);\n   lam = CLASSTYPE_LAMBDA_EXPR (closure);\n@@ -422,12 +432,20 @@ vla_capture_type (tree array_type)\n    and return it.  */\n \n tree\n-add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n+add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n \t     bool explicit_init_p)\n {\n   char *buf;\n   tree type, member, name;\n   bool vla = false;\n+  bool variadic = false;\n+  tree initializer = orig_init;\n+\n+  if (PACK_EXPANSION_P (initializer))\n+    {\n+      initializer = PACK_EXPANSION_PATTERN (initializer);\n+      variadic = true;\n+    }\n \n   if (TREE_CODE (initializer) == TREE_LIST)\n     initializer = build_x_compound_expr_from_list (initializer, ELK_INIT,\n@@ -498,6 +516,9 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n       IDENTIFIER_MARKED (name) = true;\n     }\n \n+  if (variadic)\n+    type = make_pack_expansion (type);\n+\n   /* Make member variable.  */\n   member = build_decl (input_location, FIELD_DECL, name, type);\n   DECL_VLA_CAPTURE_P (member) = vla;\n@@ -518,8 +539,14 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n       && current_class_type == LAMBDA_EXPR_CLOSURE (lambda))\n     finish_member_declaration (member);\n \n+  tree listmem = member;\n+  if (variadic)\n+    {\n+      listmem = make_pack_expansion (member);\n+      initializer = orig_init;\n+    }\n   LAMBDA_EXPR_CAPTURE_LIST (lambda)\n-    = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n+    = tree_cons (listmem, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n \n   if (LAMBDA_EXPR_CLOSURE (lambda))\n     return build_capture_proxy (member);\n@@ -538,9 +565,14 @@ register_capture_members (tree captures)\n     return;\n \n   register_capture_members (TREE_CHAIN (captures));\n+\n+  tree field = TREE_PURPOSE (captures);\n+  if (PACK_EXPANSION_P (field))\n+    field = PACK_EXPANSION_PATTERN (field);\n+\n   /* We set this in add_capture to avoid duplicates.  */\n-  IDENTIFIER_MARKED (DECL_NAME (TREE_PURPOSE (captures))) = false;\n-  finish_member_declaration (TREE_PURPOSE (captures));\n+  IDENTIFIER_MARKED (DECL_NAME (field)) = false;\n+  finish_member_declaration (field);\n }\n \n /* Similar to add_capture, except this works on a stack of nested lambdas.\n@@ -565,6 +597,8 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n       tree lambda = TREE_VALUE (node);\n \n       current_class_type = LAMBDA_EXPR_CLOSURE (lambda);\n+      if (DECL_PACK_P (initializer))\n+\tinitializer = make_pack_expansion (initializer);\n       var = add_capture (lambda,\n                             id,\n                             initializer,"}, {"sha": "2b0695ae1e5c179a5ed1a6fac78c32ad2d974037", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -8753,6 +8753,14 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n                  /*template_arg_p=*/false,\n                  &error_msg,\n                  capture_token->location);\n+\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      capture_init_expr = make_pack_expansion (capture_init_expr);\n+\t    }\n+\t  else\n+\t    check_for_bare_parameter_packs (capture_init_expr);\n \t}\n \n       if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE"}, {"sha": "2ef160aacf892149c48281d712e2328176d6187a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 207, "deletions": 84, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -1004,7 +1004,10 @@ optimize_specialization_lookup_p (tree tmpl)\n \n    If TMPL is a type template and CLASS_SPECIALIZATIONS_P is true,\n    then we search for a partial specialization matching ARGS.  This\n-   parameter is ignored if TMPL is not a class template.  */\n+   parameter is ignored if TMPL is not a class template.\n+\n+   We can also look up a FIELD_DECL, if it is a lambda capture pack; the\n+   result is a NONTYPE_ARGUMENT_PACK.  */\n \n static tree\n retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n@@ -1015,12 +1018,15 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n   if (args == error_mark_node)\n     return NULL_TREE;\n \n-  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL\n+\t      || TREE_CODE (tmpl) == FIELD_DECL);\n \n   /* There should be as many levels of arguments as there are\n      levels of parameters.  */\n   gcc_assert (TMPL_ARGS_DEPTH (args)\n-\t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)));\n+\t      == (TREE_CODE (tmpl) == TEMPLATE_DECL\n+\t\t  ? TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl))\n+\t\t  : template_class_depth (DECL_CONTEXT (tmpl))));\n \n   if (optimize_specialization_lookup_p (tmpl))\n     {\n@@ -1311,7 +1317,10 @@ is_specialization_of_friend (tree decl, tree friend_decl)\n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  IS_FRIEND indicates whether the specialization\n    is actually just a friend declaration.  Returns SPEC, or an\n-   equivalent prior declaration, if available.  */\n+   equivalent prior declaration, if available.\n+\n+   We also store instantiations of field packs in the hash table, even\n+   though they are not themselves templates, to make lookup easier.  */\n \n static tree\n register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n@@ -1321,7 +1330,9 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n   void **slot = NULL;\n   spec_entry elt;\n \n-  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL && DECL_P (spec));\n+  gcc_assert ((TREE_CODE (tmpl) == TEMPLATE_DECL && DECL_P (spec))\n+\t      || (TREE_CODE (tmpl) == FIELD_DECL\n+\t\t  && TREE_CODE (spec) == NONTYPE_ARGUMENT_PACK));\n \n   if (TREE_CODE (spec) == FUNCTION_DECL\n       && uses_template_parms (DECL_TI_ARGS (spec)))\n@@ -1443,7 +1454,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \n   /* A specialization must be declared in the same namespace as the\n      template it is specializing.  */\n-  if (DECL_TEMPLATE_SPECIALIZATION (spec)\n+  if (DECL_P (spec) && DECL_TEMPLATE_SPECIALIZATION (spec)\n       && !check_specialization_namespace (tmpl))\n     DECL_CONTEXT (spec) = DECL_CONTEXT (tmpl);\n \n@@ -3084,6 +3095,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n         parameter_pack_p = true;\n       break;\n \n+    case FIELD_DECL:\n     case PARM_DECL:\n       if (DECL_PACK_P (t))\n         {\n@@ -3094,6 +3106,18 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n         }\n       break;\n \n+      /* Look through a lambda capture proxy to the field pack.  */\n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n+\t{\n+\t  tree v = DECL_VALUE_EXPR (t);\n+\t  cp_walk_tree (&v,\n+\t\t\t&find_parameter_packs_r,\n+\t\t\tppd, ppd->visited);\n+\t  *walk_subtrees = 0;\n+\t}\n+      break;\n+\n     case BASES:\n       parameter_pack_p = true;\n       break;\n@@ -8913,6 +8937,8 @@ instantiate_class_template_1 (tree type)\n \t      else if (TREE_CODE (t) != CONST_DECL)\n \t\t{\n \t\t  tree r;\n+\t\t  tree vec = NULL_TREE;\n+\t\t  int len = 1;\n \n \t\t  /* The file and line for this declaration, to\n \t\t     assist in error message reporting.  Since we\n@@ -8925,55 +8951,68 @@ instantiate_class_template_1 (tree type)\n \t\t  r = tsubst (t, args, tf_warning_or_error, NULL_TREE);\n \t\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t\t    --processing_template_decl;\n-\t\t  if (VAR_P (r))\n+\n+\t\t  if (TREE_CODE (r) == TREE_VEC)\n \t\t    {\n-\t\t      /* In [temp.inst]:\n-\n-\t\t\t   [t]he initialization (and any associated\n-\t\t\t   side-effects) of a static data member does\n-\t\t\t   not occur unless the static data member is\n-\t\t\t   itself used in a way that requires the\n-\t\t\t   definition of the static data member to\n-\t\t\t   exist.\n-\n-\t\t\t Therefore, we do not substitute into the\n-\t\t\t initialized for the static data member here.  */\n-\t\t      finish_static_data_member_decl\n-\t\t\t(r,\n-\t\t\t /*init=*/NULL_TREE,\n-\t\t\t /*init_const_expr_p=*/false,\n-\t\t\t /*asmspec_tree=*/NULL_TREE,\n-\t\t\t /*flags=*/0);\n-\t\t      /* Instantiate members marked with attribute used.  */\n-\t\t      if (r != error_mark_node && DECL_PRESERVE_P (r))\n-\t\t\tmark_used (r);\n+\t\t      /* A capture pack became multiple fields.  */\n+\t\t      vec = r;\n+\t\t      len = TREE_VEC_LENGTH (vec);\n \t\t    }\n-\t\t  else if (TREE_CODE (r) == FIELD_DECL)\n+\n+\t\t  for (int i = 0; i < len; ++i)\n \t\t    {\n-\t\t      /* Determine whether R has a valid type and can be\n-\t\t\t completed later.  If R is invalid, then its type is\n-\t\t\t replaced by error_mark_node.  */\n-\t\t      tree rtype = TREE_TYPE (r);\n-\t\t      if (can_complete_type_without_circularity (rtype))\n-\t\t\tcomplete_type (rtype);\n-\n-\t\t      if (!COMPLETE_TYPE_P (rtype))\n+\t\t      if (vec)\n+\t\t\tr = TREE_VEC_ELT (vec, i);\n+\t\t      if (VAR_P (r))\n \t\t\t{\n-\t\t\t  cxx_incomplete_type_error (r, rtype);\n-\t\t\t  TREE_TYPE (r) = error_mark_node;\n+\t\t\t  /* In [temp.inst]:\n+\n+\t\t\t     [t]he initialization (and any associated\n+\t\t\t     side-effects) of a static data member does\n+\t\t\t     not occur unless the static data member is\n+\t\t\t     itself used in a way that requires the\n+\t\t\t     definition of the static data member to\n+\t\t\t     exist.\n+\n+\t\t\t     Therefore, we do not substitute into the\n+\t\t\t     initialized for the static data member here.  */\n+\t\t\t  finish_static_data_member_decl\n+\t\t\t    (r,\n+\t\t\t     /*init=*/NULL_TREE,\n+\t\t\t     /*init_const_expr_p=*/false,\n+\t\t\t     /*asmspec_tree=*/NULL_TREE,\n+\t\t\t     /*flags=*/0);\n+\t\t\t  /* Instantiate members marked with attribute used. */\n+\t\t\t  if (r != error_mark_node && DECL_PRESERVE_P (r))\n+\t\t\t    mark_used (r);\n+\t\t\t}\n+\t\t      else if (TREE_CODE (r) == FIELD_DECL)\n+\t\t\t{\n+\t\t\t  /* Determine whether R has a valid type and can be\n+\t\t\t     completed later.  If R is invalid, then its type\n+\t\t\t     is replaced by error_mark_node.  */\n+\t\t\t  tree rtype = TREE_TYPE (r);\n+\t\t\t  if (can_complete_type_without_circularity (rtype))\n+\t\t\t    complete_type (rtype);\n+\n+\t\t\t  if (!COMPLETE_TYPE_P (rtype))\n+\t\t\t    {\n+\t\t\t      cxx_incomplete_type_error (r, rtype);\n+\t\t\t      TREE_TYPE (r) = error_mark_node;\n+\t\t\t    }\n \t\t\t}\n-\t\t    }\n \n-\t\t  /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,\n-\t\t     such a thing will already have been added to the field\n-\t\t     list by tsubst_enum in finish_member_declaration in the\n-\t\t     CLASSTYPE_NESTED_UTDS case above.  */\n-\t\t  if (!(TREE_CODE (r) == TYPE_DECL\n-\t\t\t&& TREE_CODE (TREE_TYPE (r)) == ENUMERAL_TYPE\n-\t\t\t&& DECL_ARTIFICIAL (r)))\n-\t\t    {\n-\t\t      set_current_access_from_decl (r);\n-\t\t      finish_member_declaration (r);\n+\t\t      /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,\n+\t\t\t such a thing will already have been added to the field\n+\t\t\t list by tsubst_enum in finish_member_declaration in the\n+\t\t\t CLASSTYPE_NESTED_UTDS case above.  */\n+\t\t      if (!(TREE_CODE (r) == TYPE_DECL\n+\t\t\t    && TREE_CODE (TREE_TYPE (r)) == ENUMERAL_TYPE\n+\t\t\t    && DECL_ARTIFICIAL (r)))\n+\t\t\t{\n+\t\t\t  set_current_access_from_decl (r);\n+\t\t\t  finish_member_declaration (r);\n+\t\t\t}\n \t\t    }\n \t\t}\n \t    }\n@@ -9367,7 +9406,8 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n \targument_pack_element_is_expansion_p (arg_pack, index);\n \n       /* Select the Ith argument from the pack.  */\n-      if (TREE_CODE (parm) == PARM_DECL)\n+      if (TREE_CODE (parm) == PARM_DECL\n+\t  || TREE_CODE (parm) == FIELD_DECL)\n \t{\n \t  if (index == 0)\n \t    {\n@@ -9481,6 +9521,8 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t      need_local_specializations = true;\n \t    }\n \t}\n+      else if (TREE_CODE (parm_pack) == FIELD_DECL)\n+\targ_pack = tsubst_copy (parm_pack, args, complain, in_decl);\n       else\n         {\n \t  int idx;\n@@ -9605,7 +9647,8 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n     {\n       tree parm = TREE_PURPOSE (pack);\n \n-      if (TREE_CODE (parm) == PARM_DECL)\n+      if (TREE_CODE (parm) == PARM_DECL\n+\t  || TREE_CODE (parm) == FIELD_DECL)\n         register_local_specialization (TREE_TYPE (pack), parm);\n       else\n         {\n@@ -10572,39 +10615,88 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n     case FIELD_DECL:\n       {\n-\ttree type;\n+\ttree type = NULL_TREE;\n+\ttree vec = NULL_TREE;\n+\ttree expanded_types = NULL_TREE;\n+\tint len = 1;\n \n-\tr = copy_decl (t);\n-\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\tif (type == error_mark_node)\n-\t  RETURN (error_mark_node);\n-\tTREE_TYPE (r) = type;\n-\tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n+\tif (PACK_EXPANSION_P (TREE_TYPE (t)))\n+\t  {\n+\t    /* This field is a lambda capture pack.  Return a TREE_VEC of\n+\t       the expanded fields to instantiate_class_template_1 and\n+\t       store them in the specializations hash table as a\n+\t       NONTYPE_ARGUMENT_PACK so that tsubst_copy can find them.  */\n+            expanded_types = tsubst_pack_expansion (TREE_TYPE (t), args,\n+\t\t\t\t\t\t    complain, in_decl);\n+            if (TREE_CODE (expanded_types) == TREE_VEC)\n+              {\n+                len = TREE_VEC_LENGTH (expanded_types);\n+\t\tvec = make_tree_vec (len);\n+              }\n+            else\n+              {\n+                /* All we did was update the type. Make a note of that.  */\n+                type = expanded_types;\n+                expanded_types = NULL_TREE;\n+              }\n+\t  }\n \n-\tif (DECL_C_BIT_FIELD (r))\n-\t  /* For bit-fields, DECL_INITIAL gives the number of bits.  For\n-\t     non-bit-fields DECL_INITIAL is a non-static data member\n-\t     initializer, which gets deferred instantiation.  */\n-\t  DECL_INITIAL (r)\n-\t    = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t   complain, in_decl,\n-\t\t\t   /*integral_constant_expression_p=*/true);\n-\telse if (DECL_INITIAL (t))\n+\tfor (int i = 0; i < len; ++i)\n \t  {\n-\t    /* Set up DECL_TEMPLATE_INFO so that we can get at the\n-\t       NSDMI in perform_member_init.  Still set DECL_INITIAL\n-\t       so that we know there is one.  */\n-\t    DECL_INITIAL (r) = void_zero_node;\n-\t    gcc_assert (DECL_LANG_SPECIFIC (r) == NULL);\n-\t    retrofit_lang_decl (r);\n-\t    DECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n+\t    r = copy_decl (t);\n+\t    if (expanded_types)\n+\t      {\n+\t\ttype = TREE_VEC_ELT (expanded_types, i);\n+\t\tDECL_NAME (r)\n+\t\t  = make_ith_pack_parameter_name (DECL_NAME (r), i);\n+\t      }\n+            else if (!type)\n+              type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\n+\t    if (type == error_mark_node)\n+\t      RETURN (error_mark_node);\n+\t    TREE_TYPE (r) = type;\n+\t    cp_apply_type_quals_to_decl (cp_type_quals (type), r);\n+\n+\t    if (DECL_C_BIT_FIELD (r))\n+\t      /* For bit-fields, DECL_INITIAL gives the number of bits.  For\n+\t\t non-bit-fields DECL_INITIAL is a non-static data member\n+\t\t initializer, which gets deferred instantiation.  */\n+\t      DECL_INITIAL (r)\n+\t\t= tsubst_expr (DECL_INITIAL (t), args,\n+\t\t\t       complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/true);\n+\t    else if (DECL_INITIAL (t))\n+\t      {\n+\t\t/* Set up DECL_TEMPLATE_INFO so that we can get at the\n+\t\t   NSDMI in perform_member_init.  Still set DECL_INITIAL\n+\t\t   so that we know there is one.  */\n+\t\tDECL_INITIAL (r) = void_zero_node;\n+\t\tgcc_assert (DECL_LANG_SPECIFIC (r) == NULL);\n+\t\tretrofit_lang_decl (r);\n+\t\tDECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n+\t      }\n+\t    /* We don't have to set DECL_CONTEXT here; it is set by\n+\t       finish_member_declaration.  */\n+\t    DECL_CHAIN (r) = NULL_TREE;\n+\n+\t    apply_late_template_attributes (&r, DECL_ATTRIBUTES (r), 0,\n+\t\t\t\t\t    args, complain, in_decl);\n+\n+\t    if (vec)\n+\t      TREE_VEC_ELT (vec, i) = r;\n \t  }\n-\t/* We don't have to set DECL_CONTEXT here; it is set by\n-\t   finish_member_declaration.  */\n-\tDECL_CHAIN (r) = NULL_TREE;\n \n-\tapply_late_template_attributes (&r, DECL_ATTRIBUTES (r), 0,\n-\t\t\t\t\targs, complain, in_decl);\n+\tif (vec)\n+\t  {\n+\t    r = vec;\n+\t    tree pack = make_node (NONTYPE_ARGUMENT_PACK);\n+\t    tree tpack = cxx_make_type (TYPE_ARGUMENT_PACK);\n+\t    SET_ARGUMENT_PACK_ARGS (pack, vec);\n+\t    SET_ARGUMENT_PACK_ARGS (tpack, expanded_types);\n+\t    TREE_TYPE (pack) = tpack;\n+\t    register_specialization (pack, t, args, false, 0);\n+\t  }\n       }\n       break;\n \n@@ -10753,14 +10845,14 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t      {\n \t\t/* It may seem that this case cannot occur, since:\n \n-\t\t     typedef void f();\n-\t\t     void g() { f x; }\n+\t\t   typedef void f();\n+\t\t   void g() { f x; }\n \n \t\t   declares a function, not a variable.  However:\n       \n-\t\t     typedef void f();\n-\t\t     template <typename T> void g() { T t; }\n-\t\t     template void g<f>();\n+\t\t   typedef void f();\n+\t\t   template <typename T> void g() { T t; }\n+\t\t   template void g<f>();\n \n \t\t   is an attempt to declare a variable with function\n \t\t   type.  */\n@@ -12261,6 +12353,23 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case FIELD_DECL:\n+      if (PACK_EXPANSION_P (TREE_TYPE (t)))\n+\t{\n+\t  /* Check for a local specialization set up by\n+\t     tsubst_pack_expansion.  */\n+\t  tree r = retrieve_local_specialization (t);\n+\t  if (r)\n+\t    {\n+\t      if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)\n+\t\tr = ARGUMENT_PACK_SELECT_ARG (r);\n+\t      return r;\n+\t    }\n+\n+\t  /* Otherwise return the full NONTYPE_ARGUMENT_PACK that\n+\t     tsubst_decl put in the hash table.  */\n+\t  return retrieve_specialization (t, args, 0);\n+\t}\n+\n       if (DECL_CONTEXT (t))\n \t{\n \t  tree ctx;\n@@ -13020,6 +13129,12 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    else\n \t      do_local_using_decl (decl, scope, name);\n \t  }\n+\telse if (DECL_PACK_P (decl))\n+\t  {\n+\t    /* Don't build up decls for a variadic capture proxy, we'll\n+\t       instantiate the elements directly as needed.  */\n+\t    break;\n+\t  }\n \telse\n \t  {\n \t    init = DECL_INITIAL (decl);\n@@ -14585,6 +14700,14 @@ tsubst_copy_and_build (tree t,\n     case VAR_DECL:\n       if (!args)\n \tRETURN (t);\n+      else if (DECL_PACK_P (t))\n+\t{\n+\t  /* We don't build decls for an instantiation of a\n+\t     variadic capture proxy, we instantiate the elements\n+\t     when needed.  */\n+\t  gcc_assert (DECL_HAS_VALUE_EXPR_P (t));\n+\t  return RECUR (DECL_VALUE_EXPR (t));\n+\t}\n       /* Fall through */\n \n     case PARM_DECL:"}, {"sha": "0299b690fb19774cd721146c5bef7be38ebe0abf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -1604,6 +1604,9 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \t/* Quals on the object don't matter.  */;\n+      else if (PACK_EXPANSION_P (type))\n+\t/* Don't bother trying to represent this.  */\n+\ttype = NULL_TREE;\n       else\n \t{\n \t  /* Set the cv qualifiers.  */"}, {"sha": "fab1f6ca6ac2968a092cd767f349fed75d655a2f", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic2.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2993d08a0f9053d6b434f550c489d2cc9af81c46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic2.C?ref=2993d08a0f9053d6b434f550c489d2cc9af81c46", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do run { target c++11 } }\n+\n+int g() { return 0; }\n+template <class T, class... U>\n+int g(T t, U... u)\n+{\n+  return t + g(u...);\n+}\n+\n+template <class... T>\n+int f1(T... t)\n+{\n+  return [t...] {\n+    return g(t...);\n+  }();\n+}\n+\n+template <class... T>\n+int f2(T... t)\n+{\n+  return [&t...] {\n+    return g(t...);\n+  }();\n+}\n+\n+template <class... T>\n+int f3(T... t)\n+{\n+  return [=] {\n+    return g(t...);\n+  }();\n+}\n+\n+template <class... T>\n+int f4(T... t)\n+{\n+  return [&] {\n+    return g(t...);\n+  }();\n+}\n+\n+#define assert(E) do { if (!(E)) __builtin_abort(); } while(0)\n+int main()\n+{\n+  assert (f1() == 0);\n+  assert (f2() == 0);\n+  assert (f3() == 0);\n+  assert (f4() == 0);\n+  assert (f1(42) == 42);\n+  assert (f2(42) == 42);\n+  assert (f3(42) == 42);\n+  assert (f4(42) == 42);\n+  assert (f1(1,2,3) == 6);\n+  assert (f2(1,2,3) == 6);\n+  assert (f3(1,2,3) == 6);\n+  assert (f4(1,2,3) == 6);\n+}"}]}