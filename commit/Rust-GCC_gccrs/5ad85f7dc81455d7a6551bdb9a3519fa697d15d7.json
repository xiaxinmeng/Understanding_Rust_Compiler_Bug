{"sha": "5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkODVmN2RjODE0NTVkN2E2NTUxYmRiOWEzNTE5ZmE2OTdkMTVkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-13T02:32:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-13T02:32:06Z"}, "message": "re PR rtl-optimization/17186 (ICE in move_for_stack_reg, at reg-stack.c:1065)\n\n        PR rtl-opt/17186\n        * reg-stack.c (move_nan_for_stack_reg): New.\n        (subst_stack_regs_pat): Use it.\n        (move_for_stack_reg): Handle source register not live with a nan.\n\nFrom-SVN: r92073", "tree": {"sha": "5070814a21016136d25e836352ef412330dfe833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5070814a21016136d25e836352ef412330dfe833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7/comments", "author": null, "committer": null, "parents": [{"sha": "56d76b697d2cf1a0197742400edd8f6dda63308a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d76b697d2cf1a0197742400edd8f6dda63308a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d76b697d2cf1a0197742400edd8f6dda63308a"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "b62d1622024d061289118aca8b0cd3a8c6092a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "patch": "@@ -1,3 +1,10 @@\n+2004-12-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/17186\n+\t* reg-stack.c (move_nan_for_stack_reg): New.\n+\t(subst_stack_regs_pat): Use it.\n+\t(move_for_stack_reg): Handle source register not live with a nan.\n+\n 2004-12-12  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_gimplify_va_arg): Fix type mismatch"}, {"sha": "d561416fa2c741320b481f1be19c463a456f37d1", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad85f7dc81455d7a6551bdb9a3519fa697d15d7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=5ad85f7dc81455d7a6551bdb9a3519fa697d15d7", "patch": "@@ -251,6 +251,7 @@ static rtx emit_pop_insn (rtx, stack, rtx, enum emit_where);\n static void emit_swap_insn (rtx, stack, rtx);\n static void swap_to_top(rtx, stack, rtx, rtx);\n static bool move_for_stack_reg (rtx, stack, rtx);\n+static bool move_nan_for_stack_reg (rtx, stack, rtx);\n static int swap_rtx_condition_1 (rtx);\n static int swap_rtx_condition (rtx);\n static void compare_for_stack_reg (rtx, stack, rtx);\n@@ -1055,10 +1056,14 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \t    if (regstack->reg[i] == REGNO (src))\n \t      break;\n \n-\t  /* The source must be live, and the dest must be dead.  */\n-\t  gcc_assert (i >= 0);\n+\t  /* The destination must be dead, or life analysis is borked.  */\n \t  gcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n \n+\t  /* If the source is not live, this is yet another case of\n+\t     uninitialized variables.  Load up a NaN instead.  */\n+\t  if (i < 0)\n+\t    return move_nan_for_stack_reg (insn, regstack, dest);\n+\n \t  /* It is possible that the dest is unused after this insn.\n \t     If so, just pop the src.  */\n \n@@ -1159,6 +1164,22 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \n   return control_flow_insn_deleted;\n }\n+\n+/* A helper function which replaces INSN with a pattern that loads up\n+   a NaN into DEST, then invokes move_for_stack_reg.  */\n+\n+static bool\n+move_nan_for_stack_reg (rtx insn, stack regstack, rtx dest)\n+{\n+  rtx pat;\n+\n+  dest = FP_MODE_REG (REGNO (dest), SFmode);\n+  pat = gen_rtx_SET (VOIDmode, dest, not_a_num);\n+  PATTERN (insn) = pat;\n+  INSN_CODE (insn) = -1;\n+\n+  return move_for_stack_reg (insn, regstack, pat);\n+}\n \f\n /* Swap the condition on a branch, if there is one.  Return true if we\n    found a condition to swap.  False if the condition was not used as\n@@ -1430,23 +1451,19 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t   all other clobbers, this must be due to a function\n \t\t   returning without a value.  Load up a NaN.  */\n \n-\t\tif (! note\n-\t\t    && get_hard_regnum (regstack, *dest) == -1)\n-\t\t  {\n-\t\t    pat = gen_rtx_SET (VOIDmode,\n-\t\t\t\t       FP_MODE_REG (REGNO (*dest), SFmode),\n-\t\t\t\t       not_a_num);\n-\t\t    PATTERN (insn) = pat;\n-\t\t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n-\t\t  }\n-\t\tif (! note && COMPLEX_MODE_P (GET_MODE (*dest))\n-\t\t    && get_hard_regnum (regstack, FP_MODE_REG (REGNO (*dest), DFmode)) == -1)\n+\t\tif (!note)\n \t\t  {\n-\t\t    pat = gen_rtx_SET (VOIDmode,\n-\t\t\t\t       FP_MODE_REG (REGNO (*dest) + 1, SFmode),\n-\t\t\t\t       not_a_num);\n-\t\t    PATTERN (insn) = pat;\n-\t\t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n+\t\t    rtx t = *dest;\n+\t\t    if (get_hard_regnum (regstack, t) == -1)\n+\t\t      control_flow_insn_deleted\n+\t\t\t|= move_nan_for_stack_reg (insn, regstack, t);\n+\t\t    if (COMPLEX_MODE_P (GET_MODE (t)))\n+\t\t      {\n+\t\t\tt = FP_MODE_REG (REGNO (t) + 1, DFmode);\n+\t\t\tif (get_hard_regnum (regstack, t) == -1)\n+\t\t\t  control_flow_insn_deleted\n+\t\t\t    |= move_nan_for_stack_reg (insn, regstack, t);\n+\t\t      }\n \t\t  }\n \t      }\n \t  }\n@@ -2921,13 +2938,9 @@ convert_regs_1 (FILE *file, basic_block block)\n \t  rtx set;\n \n \t  if (file)\n-\t    {\n-\t      fprintf (file, \"Emitting insn initializing reg %d\\n\",\n-\t\t       reg);\n-\t    }\n+\t    fprintf (file, \"Emitting insn initializing reg %d\\n\", reg);\n \n-\t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode),\n-\t\t\t     not_a_num);\n+\t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode), not_a_num);\n \t  insn = emit_insn_after (set, insn);\n \t  control_flow_insn_deleted |= subst_stack_regs (insn, &regstack);\n \t}"}]}