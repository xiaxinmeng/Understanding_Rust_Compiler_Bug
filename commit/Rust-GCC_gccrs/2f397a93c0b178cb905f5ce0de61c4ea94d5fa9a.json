{"sha": "2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzOTdhOTNjMGIxNzhjYjkwNWY1Y2UwZGU2MWM0ZWE5NGQ1ZmE5YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-01-22T11:11:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-01-22T11:11:00Z"}, "message": "re PR tree-optimization/30038 (Call to sin(x), cos(x) should be transformed to sincos(x))\n\n2007-01-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/30038\n\t* tree-ssa-math-opts.c (maybe_record_sincos): New static helper\n\tfunction.\n\t(execute_cse_sincos_1): Likewise.\n\t(execute_cse_sincos): Likewise.\n\t(gate_cse_sincos): Likewise.\n\t(pass_cse_sincos): New pass CSEing sin() and cos() calls using\n\tthe cexpi() canonicalization of sincos().\n\t* tree-pass.h (pass_cse_sincos): Declare.\n\t* passes.c (init_optimization_passes): New pass pas_cse_sincos.\n\n\t* gcc.dg/builtins-62.c: New testcase.\n\nFrom-SVN: r121052", "tree": {"sha": "4e252e76c93f9c1a661427d2bf5a5d9b4e1dfcf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e252e76c93f9c1a661427d2bf5a5d9b4e1dfcf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "609610af72877b0ddadef9c20301d0b367e7ddc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/609610af72877b0ddadef9c20301d0b367e7ddc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/609610af72877b0ddadef9c20301d0b367e7ddc4"}], "stats": {"total": 268, "additions": 266, "deletions": 2}, "files": [{"sha": "038da597b41c2c4c7892bf6f06e95a9cd1529ccc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -1,3 +1,16 @@\n+2007-01-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30038\n+\t* tree-ssa-math-opts.c (maybe_record_sincos): New static helper\n+\tfunction.\n+\t(execute_cse_sincos_1): Likewise.\n+\t(execute_cse_sincos): Likewise.\n+\t(gate_cse_sincos): Likewise.\n+\t(pass_cse_sincos): New pass CSEing sin() and cos() calls using\n+\tthe cexpi() canonicalization of sincos().\n+\t* tree-pass.h (pass_cse_sincos): Declare.\n+\t* passes.c (init_optimization_passes): New pass pas_cse_sincos.\n+\n 2007-01-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR rtl-optimization/29329"}, {"sha": "2e17599bc8c367843cd89489fad93c2795e532c9", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -573,6 +573,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_store_ccp);\n   NEXT_PASS (pass_store_copy_prop);\n   NEXT_PASS (pass_fold_builtins);\n+  NEXT_PASS (pass_cse_sincos);\n   /* FIXME: May alias should a TODO but for 4.0.0,\n      we add may_alias right after fold builtins\n      which can create arbitrary GIMPLE.  */"}, {"sha": "aef566ae1d4763e7edafa5f600a2015243bbff4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -1,3 +1,8 @@\n+2007-01-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30038\n+\t* gcc.dg/builtins-62.c: New testcase.\n+\n 2007-01-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.c-torture/compile/20070121.c: New test."}, {"sha": "af7a02a4c07d0f86ec4f70a849304523870bda0a", "filename": "gcc/testsuite/gcc.dg/builtins-62.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-62.c?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ffinite-math-only -fdump-tree-optimized\" } */\n+\n+double test1 (double x)\n+{\n+  double s, c;\n+  s = __builtin_sin (x);\n+  c = __builtin_cos (x);\n+  return s + c;\n+}\n+\n+double test2 (double x)\n+{\n+  double s, c;\n+  x = x * 2;\n+  s = __builtin_sin (x);\n+  c = __builtin_cos (x);\n+  return s + c;\n+}\n+\n+double test3 (double x, int b)\n+{\n+  double s, c;\n+  if (b)\n+    x = x * 2;\n+  s = __builtin_sin (x);\n+  c = __builtin_cos (x);\n+  return s + c;\n+}\n+\n+double test4 (double x)\n+{\n+  double s;\n+  x = x * 2;\n+  s = __builtin_sin (x);\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"cexpi\" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8556eb771c9b2d3c862e28118d9e79944f90b47d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -282,6 +282,7 @@ extern struct tree_opt_pass pass_stdarg;\n extern struct tree_opt_pass pass_early_warn_uninitialized;\n extern struct tree_opt_pass pass_late_warn_uninitialized;\n extern struct tree_opt_pass pass_cse_reciprocals;\n+extern struct tree_opt_pass pass_cse_sincos;\n extern struct tree_opt_pass pass_warn_function_return;\n extern struct tree_opt_pass pass_warn_function_noreturn;\n extern struct tree_opt_pass pass_phiopt;"}, {"sha": "ae7a40bf8ca50c0dbc914de2906375a82b998d4c", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 206, "deletions": 2, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=2f397a93c0b178cb905f5ce0de61c4ea94d5fa9a", "patch": "@@ -440,14 +440,12 @@ execute_cse_reciprocals_1 (block_stmt_iterator *def_bsi, tree def)\n   occ_head = NULL;\n }\n \n-\n static bool\n gate_cse_reciprocals (void)\n {\n   return optimize && !optimize_size && flag_unsafe_math_optimizations;\n }\n \n-\n /* Go through all the floating-point SSA_NAMEs, and call\n    execute_cse_reciprocals_1 on each of them.  */\n static unsigned int\n@@ -490,6 +488,7 @@ execute_cse_reciprocals (void)\n       for (bsi = bsi_after_labels (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  tree stmt = bsi_stmt (bsi);\n+\n \t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n \t      && FLOAT_TYPE_P (TREE_TYPE (def))\n@@ -521,3 +520,208 @@ struct tree_opt_pass pass_cse_reciprocals =\n     | TODO_verify_stmts,                /* todo_flags_finish */\n   0\t\t\t\t        /* letter */\n };\n+\n+/* Records an occurance at statement USE_STMT in the vector of trees\n+   STMTS if it is dominated by *TOP_BB or dominates it or this basic block\n+   is not yet initialized.  Returns true if the occurance was pushed on\n+   the vector.  Adjusts *TOP_BB to be the basic block dominating all\n+   statements in the vector.  */\n+\n+static bool\n+maybe_record_sincos (VEC(tree, heap) **stmts,\n+\t\t     basic_block *top_bb, tree use_stmt)\n+{\n+  basic_block use_bb = bb_for_stmt (use_stmt);\n+  if (*top_bb\n+      && (*top_bb == use_bb\n+\t  || dominated_by_p (CDI_DOMINATORS, use_bb, *top_bb)))\n+    VEC_safe_push (tree, heap, *stmts, use_stmt);\n+  else if (!*top_bb\n+\t   || dominated_by_p (CDI_DOMINATORS, *top_bb, use_bb))\n+    {\n+      VEC_safe_push (tree, heap, *stmts, use_stmt);\n+      *top_bb = use_bb;\n+    }\n+  else\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Look for sin, cos and cexpi calls with the same argument NAME and\n+   create a single call to cexpi CSEing the result in this case.\n+   We first walk over all immediate uses of the argument collecting\n+   statements that we can CSE in a vector and in a second pass replace\n+   the statement rhs with a REALPART or IMAGPART expression on the\n+   result of the cexpi call we insert before the use statement that\n+   dominates all other candidates.  */\n+\n+static void\n+execute_cse_sincos_1 (tree name)\n+{\n+  block_stmt_iterator bsi;\n+  imm_use_iterator use_iter;\n+  tree def_stmt, use_stmt, fndecl, res, call, stmt, type;\n+  int seen_cos = 0, seen_sin = 0, seen_cexpi = 0;\n+  VEC(tree, heap) *stmts = NULL;\n+  basic_block top_bb = NULL;\n+  int i;\n+\n+  type = TREE_TYPE (name);\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, name)\n+    {\n+      if (TREE_CODE (use_stmt) != GIMPLE_MODIFY_STMT\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) != CALL_EXPR\n+\t  || !(fndecl = get_callee_fndecl (GIMPLE_STMT_OPERAND (use_stmt, 1)))\n+\t  || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n+\tcontinue;\n+\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tCASE_FLT_FN (BUILT_IN_COS):\n+\t  seen_cos |= maybe_record_sincos (&stmts, &top_bb, use_stmt) ? 1 : 0;\n+\t  break;\n+\n+\tCASE_FLT_FN (BUILT_IN_SIN):\n+\t  seen_sin |= maybe_record_sincos (&stmts, &top_bb, use_stmt) ? 1 : 0;\n+\t  break;\n+\n+\tCASE_FLT_FN (BUILT_IN_CEXPI):\n+\t  seen_cexpi |= maybe_record_sincos (&stmts, &top_bb, use_stmt) ? 1 : 0;\n+\t  break;\n+\n+\tdefault:;\n+\t}\n+    }\n+\n+  if (seen_cos + seen_sin + seen_cexpi <= 1)\n+    {\n+      VEC_free(tree, heap, stmts);\n+      return;\n+    }\n+\n+  /* Simply insert cexpi at the beginning of top_bb but not earlier than\n+     the name def statement.  */\n+  fndecl = mathfn_built_in (type, BUILT_IN_CEXPI);\n+  if (!fndecl)\n+    return;\n+  res = make_rename_temp (TREE_TYPE (TREE_TYPE (fndecl)), \"sincostmp\");\n+  call = build_function_call_expr (fndecl, build_tree_list (NULL_TREE, name));\n+  stmt = build2 (GIMPLE_MODIFY_STMT, NULL_TREE, res, call);\n+  def_stmt = SSA_NAME_DEF_STMT (name);\n+  if (bb_for_stmt (def_stmt) == top_bb\n+      && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT)\n+    {\n+      bsi = bsi_for_stmt (def_stmt);\n+      bsi_insert_after (&bsi, stmt, BSI_SAME_STMT);\n+    }\n+  else\n+    {\n+      bsi = bsi_after_labels (top_bb);\n+      bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n+    }\n+  update_stmt (stmt);\n+\n+  /* And adjust the recorded old call sites.  */\n+  for (i = 0; VEC_iterate(tree, stmts, i, use_stmt); ++i)\n+    {\n+      fndecl = get_callee_fndecl (GIMPLE_STMT_OPERAND (use_stmt, 1));\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tCASE_FLT_FN (BUILT_IN_COS):\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = fold_build1 (REALPART_EXPR,\n+\t\t\t\t\t\t\t   type, res);\n+\t  break;\n+\n+\tCASE_FLT_FN (BUILT_IN_SIN):\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = fold_build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t\t   type, res);\n+\t  break;\n+\n+\tCASE_FLT_FN (BUILT_IN_CEXPI):\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = res;\n+\t  break;\n+\n+\tdefault:;\n+\t  gcc_unreachable ();\n+\t}\n+\n+\tupdate_stmt (use_stmt);\n+    }\n+\n+  VEC_free(tree, heap, stmts);\n+}\n+\n+/* Go through all calls to sin, cos and cexpi and call execute_cse_sincos_1\n+   on the SSA_NAME argument of each of them.  */\n+\n+static unsigned int\n+execute_cse_sincos (void)\n+{\n+  basic_block bb;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+\n+      for (bsi = bsi_after_labels (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+        {\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  tree fndecl;\n+\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR\n+\t      && (fndecl = get_callee_fndecl (GIMPLE_STMT_OPERAND (stmt, 1)))\n+\t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t    {\n+\t      tree arg;\n+\n+\t      switch (DECL_FUNCTION_CODE (fndecl))\n+\t\t{\n+\t\tCASE_FLT_FN (BUILT_IN_COS):\n+\t\tCASE_FLT_FN (BUILT_IN_SIN):\n+\t\tCASE_FLT_FN (BUILT_IN_CEXPI):\n+\t\t  arg = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t\t  arg = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t\t    execute_cse_sincos_1 (arg);\n+\t\t  break;\n+\n+\t\tdefault:;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+  return 0;\n+}\n+\n+static bool\n+gate_cse_sincos (void)\n+{\n+  /* Make sure we have either sincos or cexp.  */\n+  return (TARGET_HAS_SINCOS\n+\t  || TARGET_C99_FUNCTIONS)\n+\t && optimize;\n+}\n+\n+struct tree_opt_pass pass_cse_sincos =\n+{\n+  \"sincos\",\t\t\t\t/* name */\n+  gate_cse_sincos,\t\t\t/* gate */\n+  execute_cse_sincos,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts,                /* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\n+};"}]}