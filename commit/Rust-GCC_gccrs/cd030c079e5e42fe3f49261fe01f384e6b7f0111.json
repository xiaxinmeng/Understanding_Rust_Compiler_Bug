{"sha": "cd030c079e5e42fe3f49261fe01f384e6b7f0111", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwMzBjMDc5ZTVlNDJmZTNmNDkyNjFmZTAxZjM4NGU2YjdmMDExMQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2013-01-24T15:13:46Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2013-01-24T15:13:46Z"}, "message": "Remove zone allocator.\n\nThis patch removes the GC zone allocator.  It is not used and it\nproduces several regressions in the testsuite.  Furthermore, it\ncomplicates things for the plan to implement manual GC markers\n(http://gcc.gnu.org/wiki/cxx-conversion/gc-alternatives#Do_GC_marking_manually).\n\nTested on x86_64 with standard checking, --enable-checking=gc and\n--enable-checking=release.\n\nFrom-SVN: r195426", "tree": {"sha": "34d4eb3cfee54bbc5c75bfb073ac74fea18fdc6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34d4eb3cfee54bbc5c75bfb073ac74fea18fdc6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd030c079e5e42fe3f49261fe01f384e6b7f0111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd030c079e5e42fe3f49261fe01f384e6b7f0111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd030c079e5e42fe3f49261fe01f384e6b7f0111", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd030c079e5e42fe3f49261fe01f384e6b7f0111/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3"}], "stats": {"total": 2999, "additions": 110, "deletions": 2889}, "files": [{"sha": "20f44e822f08dd8714cefb1697da65f6cf0efacb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -1,3 +1,52 @@\n+2013-01-24  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Makefile.in (GGC): Remove.  Replace all instances with\n+\tggc-page.o.\n+\t(ggc-zone.o): Remove.\n+\t* configure.ac: Remove option --with-gc.\n+\t* configure: Re-generate.\n+\t* doc/install.texi: Remove documentation for --with-gc.\n+\t* gengtype.c (write_enum_defn): Remove.  Update all users.\n+\t(write_Types_process_field): Remove generation of gt_e_* argument.\n+\t(output_type_enum): Remove.  Update all users.\n+\t(write_enum_defn): Remove.  Update all users.\n+\t(enum alloc_zone): Remove.  Update all users.\n+\t(write_splay_tree_allocator_def): Remove generation of gt_e_*\n+\targument.\n+\t* ggc-common.c (ggc_splay_alloc): Remove first argument.\n+\tUpdate all callers.\n+\t(struct ptr_data): Remove field TYPE.  Update all users.\n+\t(gt_pch_note_object): Remove argument TYPE.  Update all\n+\tusers.\n+\t* ggc-internal.h (ggc_pch_alloc_object): Remove last argument.\n+\tUpdate all users.\n+\t* gcc/ggc-none.c (ggc_alloc_typed_stat): Remove.\n+\t(struct alloc_zone): Remove.\n+\t(ggc_internal_alloc_zone_stat): Remove.\n+\t(ggc_internal_cleared_alloc_zone_stat): Remove.\n+\t* ggc-page.c (ggc_alloc_typed_stat): Remove.\n+\t(ggc_pch_count_object): Remove last argument.  Update all\n+\tusers.\n+\t(ggc_pch_alloc_object): Remove last argument.  Update all\n+\tusers.\n+\t(struct alloc_zone): Remove.\n+\t* ggc-zone.c: Remove.\n+\t* ggc.h (gt_pch_note_object): Remove last argument.  Update\n+\tall users.\n+\t(struct alloc_zone): Remove.\n+\t(ggc_alloc_typed_stat): Remove.\n+\t(ggc_alloc_typed): Remove.\n+\t(ggc_splay_alloc): Remove first argument.\n+\t(rtl_zone): Remove.  Update all users.\n+\t(tree_zone): Remove.  Update all users.\n+\t(tree_id_zone): Remove.  Update all users.\n+\t(ggc_internal_zone_alloc_stat): Remove.  Update all users.\n+\t(ggc_internal_zone_cleared_alloc_stat): Remove.  Update all\n+\tusers.\n+\t(ggc_internal_zone_vec_alloc_stat): Remove.  Update all users.\n+\t* tree-ssanames.c: Remove references to zone allocator in\n+\tcomments.\n+\n 2013-01-24  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.c (avr_out_fract): Make register numbers that"}, {"sha": "6fe634579fac60a3e46c19b0a41e069671b6084d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -661,9 +661,6 @@ LIBINTL_DEP = @LIBINTL_DEP@\n LIBICONV = @LIBICONV@\n LIBICONV_DEP = @LIBICONV_DEP@\n \n-# The GC method to be used on this system.\n-GGC=@GGC@.o\n-\n # If a supplementary library is being used for the GC.\n GGC_LIB=\n \n@@ -1157,7 +1154,7 @@ OBJS = \\\n \tinsn-preds.o \\\n \tinsn-recog.o \\\n \tinsn-enums.o \\\n-\t$(GGC) \\\n+\tggc-page.o \\\n \talias.o \\\n \talloc-pool.o \\\n \tauto-inc-dec.o \\\n@@ -2120,10 +2117,6 @@ ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TR\n \t$(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) \\\n \t$(TREE_FLOW_H) $(PLUGIN_H) $(GGC_INTERNAL_H)\n \n-ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-\t$(TREE_H) $(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) \\\n-\t$(PARAMS_H) $(BITMAP_H) $(PLUGIN_H) $(GGC_INTERNAL_H)\n-\n ggc-none.o: ggc-none.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(BCONFIG_H)\n "}, {"sha": "a4a773ae780a6404c7f0932ab418491c62ee4eef", "filename": "gcc/configure", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -674,7 +674,6 @@ MAINT\n zlibinc\n zlibdir\n HOST_LIBS\n-GGC\n libgcc_visibility\n gcc_cv_readelf\n gcc_cv_objdump\n@@ -1670,7 +1669,8 @@ Optional Packages:\n   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]\n   --with-plugin-ld=[ARG]  specify the plugin linker\n   --with-long-double-128  use 128-bit long double by default\n-  --with-gc={page,zone}   choose the garbage collection mechanism to use with\n+  --with-gc={page,zone}   this option is not supported anymore. It used to\n+                          choose the garbage collection mechanism to use with\n                           the compiler\n   --with-system-zlib      use installed libz\n   --with-linker-hash-style={sysv,gnu,both}\n@@ -26807,31 +26807,15 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_target_dl_iterate_phdr\" >&5\n $as_echo \"$gcc_cv_target_dl_iterate_phdr\" >&6; }\n \n-# Find out what GC implementation we want, or may, use.\n+# We no longer support different GC mechanisms.  Emit an error if\n+# the user configures with --with-gc.\n \n # Check whether --with-gc was given.\n if test \"${with_gc+set}\" = set; then :\n-  withval=$with_gc; case \"$withval\" in\n-  page)\n-    GGC=ggc-$withval\n-    ;;\n-  zone)\n-    GGC=ggc-$withval\n-\n-$as_echo \"#define GGC_ZONE 1\" >>confdefs.h\n-\n-    ;;\n-  *)\n-    as_fn_error \"$withval is an invalid option to --with-gc\" \"$LINENO\" 5\n-    ;;\n-esac\n-else\n-  GGC=ggc-page\n+  withval=$with_gc; as_fn_error \"Configure option --with-gc is only supported up to GCC 4.7.x\" \"$LINENO\" 5\n fi\n \n \n-echo \"Using $GGC for garbage collection.\"\n-\n # Libraries to use on the host.  This will normally be set by the top\n # level Makefile.  Here we simply capture the value for our Makefile.\n if test -z \"${HOST_LIBS+set}\"; then"}, {"sha": "24568f1371fe3293d79c9f158a22bbf18f04f1ff", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -4797,26 +4797,14 @@ if test x$gcc_cv_target_dl_iterate_phdr = xyes; then\n fi\n AC_MSG_RESULT($gcc_cv_target_dl_iterate_phdr)\n \n-# Find out what GC implementation we want, or may, use.\n+# We no longer support different GC mechanisms.  Emit an error if\n+# the user configures with --with-gc.\n AC_ARG_WITH(gc,\n [AS_HELP_STRING([--with-gc={page,zone}],\n-\t\t[choose the garbage collection mechanism to use\n-                 with the compiler])],\n-[case \"$withval\" in\n-  page)\n-    GGC=ggc-$withval\n-    ;;\n-  zone)\n-    GGC=ggc-$withval\n-    AC_DEFINE(GGC_ZONE, 1, [Define if the zone collector is in use])\n-    ;;\n-  *)\n-    AC_MSG_ERROR([$withval is an invalid option to --with-gc])\n-    ;;\n-esac],\n-[GGC=ggc-page])\n-AC_SUBST(GGC)\n-echo \"Using $GGC for garbage collection.\"\n+\t\t[this option is not supported anymore.  It used to choose\n+\t\t the garbage collection mechanism to use with the compiler])],\n+[AC_MSG_ERROR([Configure option --with-gc is only supported up to GCC 4.7.x])],\n+[])\n \n # Libraries to use on the host.  This will normally be set by the top\n # level Makefile.  Here we simply capture the value for our Makefile."}, {"sha": "92bfc8bd396e495f766f3ae34c2d07e0bc848a5a", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -1523,12 +1523,6 @@ When this option is specified more detailed information on memory\n allocation is gathered.  This information is printed when using\n @option{-fmem-report}.\n \n-@item --with-gc\n-@itemx --with-gc=@var{choice}\n-With this option you can specify the garbage collector implementation\n-used during the compilation process.  @var{choice} can be one of\n-@samp{page} and @samp{zone}, where @samp{page} is the default.\n-\n @item --enable-nls\n @itemx --disable-nls\n The @option{--enable-nls} option enables Native Language Support (NLS),"}, {"sha": "a2eebf2725da7012395d43d26689f0c8bf374aed", "filename": "gcc/gengtype.c", "status": "modified", "additions": 17, "deletions": 124, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -2414,7 +2414,6 @@ static void write_local_func_for_structure\n   (const_type_p orig_s, type_p s, type_p *param);\n static void write_local (outf_p output_header,\n \t\t\t type_p structures, type_p param_structs);\n-static void write_enum_defn (type_p structures, type_p param_structs);\n static int contains_scalar_p (type_p t);\n static void put_mangled_filename (outf_p, const input_file *);\n static void finish_root_table (struct flist *flp, const char *pfx,\n@@ -3169,20 +3168,6 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \t    }\n \t  else\n \t    oprintf (d->of, \", gt_%sa_%s\", wtd->param_prefix, d->prev_val[0]);\n-\n-\t  if (f->u.p->kind == TYPE_PARAM_STRUCT\n-\t      && f->u.p->u.s.line.file != NULL)\n-\t    {\n-\t      oprintf (d->of, \", gt_e_\");\n-\t      output_mangled_typename (d->of, f);\n-\t    }\n-\t  else if (union_or_struct_p (f) && f->u.p->u.s.line.file != NULL)\n-\t    {\n-\t      oprintf (d->of, \", gt_ggc_e_\");\n-\t      output_mangled_typename (d->of, f);\n-\t    }\n-\t  else\n-\t    oprintf (d->of, \", gt_types_enum_last\");\n \t}\n       oprintf (d->of, \");\\n\");\n       if (d->reorder_fn && wtd->reorder_note_routine)\n@@ -3227,25 +3212,6 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n     }\n }\n \n-/* A subroutine of write_func_for_structure.  Write the enum tag for S.  */\n-\n-static void\n-output_type_enum (outf_p of, type_p s)\n-{\n-  if (s->kind == TYPE_PARAM_STRUCT && s->u.param_struct.line.file != NULL)\n-    {\n-      oprintf (of, \", gt_e_\");\n-      output_mangled_typename (of, s);\n-    }\n-  else if (union_or_struct_p (s) && s->u.s.line.file != NULL)\n-    {\n-      oprintf (of, \", gt_ggc_e_\");\n-      output_mangled_typename (of, s);\n-    }\n-  else\n-    oprintf (of, \", gt_types_enum_last\");\n-}\n-\n /* Return an output file that is suitable for definitions which can\n    reference struct S */\n \n@@ -3520,7 +3486,6 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t{\n \t  oprintf (d.of, \", x, gt_%s_\", wtd->param_prefix);\n \t  output_mangled_typename (d.of, orig_s);\n-\t  output_type_enum (d.of, orig_s);\n \t}\n       oprintf (d.of, \"))\\n\");\n     }\n@@ -3534,7 +3499,6 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t{\n \t  oprintf (d.of, \", xlimit, gt_%s_\", wtd->param_prefix);\n \t  output_mangled_typename (d.of, orig_s);\n-\t  output_type_enum (d.of, orig_s);\n \t}\n       oprintf (d.of, \"))\\n\");\n       if (chain_circular != NULL)\n@@ -3568,7 +3532,6 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t    {\n \t      oprintf (d.of, \", xprev, gt_%s_\", wtd->param_prefix);\n \t      output_mangled_typename (d.of, orig_s);\n-\t      output_type_enum (d.of, orig_s);\n \t    }\n \t  oprintf (d.of, \");\\n\");\n \t  oprintf (d.of, \"      }\\n\");\n@@ -3580,7 +3543,6 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t    {\n \t      oprintf (d.of, \", xlimit, gt_%s_\", wtd->param_prefix);\n \t      output_mangled_typename (d.of, orig_s);\n-\t      output_type_enum (d.of, orig_s);\n \t    }\n \t  oprintf (d.of, \"));\\n\");\n \t  if (mark_hook_name && !wtd->skip_hooks)\n@@ -4091,50 +4053,6 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \t       && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))))))\n \n \n-/* Write out the 'enum' definition for gt_types_enum.  */\n-\n-static void\n-write_enum_defn (type_p structures, type_p param_structs)\n-{\n-  type_p s;\n-  int nbstruct = 0;\n-  int nbparamstruct = 0;\n-\n-  if (!header_file)\n-    return;\n-  oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n-  oprintf (header_file, \"enum gt_types_enum {\\n\");\n-  for (s = structures; s; s = s->next)\n-    if (USED_BY_TYPED_GC_P (s))\n-      {\n-\tnbstruct++;\n-\tDBGPRINTF (\"write_enum_defn s @ %p nbstruct %d\",\n-\t\t   (void*) s, nbstruct);\n-\tif (union_or_struct_p (s))\n-\t  DBGPRINTF (\"write_enum_defn s %p #%d is unionorstruct tagged %s\",\n-\t\t     (void*) s, nbstruct, s->u.s.tag);\n-\toprintf (header_file, \" gt_ggc_e_\");\n-\toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \",\\n\");\n-      }\n-  for (s = param_structs; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO)\n-      {\n-\tnbparamstruct++;\n-\tDBGPRINTF (\"write_enum_defn s %p nbparamstruct %d\",\n-\t\t   (void*) s, nbparamstruct);\n-\toprintf (header_file, \" gt_e_\");\n-\toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \",\\n\");\n-      }\n-  oprintf (header_file, \" gt_types_enum_last\\n\");\n-  oprintf (header_file, \"};\\n\");\n-  if (verbosity_level >= 2)\n-    printf (\"%s handled %d GTY-ed structures & %d parameterized structures.\\n\",\n-\t    progname, nbstruct, nbparamstruct);\n-\n-}\n-\n /* Might T contain any non-pointer elements?  */\n \n static int\n@@ -4804,38 +4722,30 @@ variable_size_p (const type_p s)\n \n enum alloc_quantity\n { single, vector };\n-enum alloc_zone\n-{ any_zone, specific_zone };\n \n /* Writes one typed allocator definition into output F for type\n    identifier TYPE_NAME with optional type specifier TYPE_SPECIFIER.\n    The allocator name will contain ALLOCATOR_TYPE.  If VARIABLE_SIZE\n    is true, the allocator will have an extra parameter specifying\n    number of bytes to allocate.  If QUANTITY is set to VECTOR, a\n-   vector allocator will be output, if ZONE is set to SPECIFIC_ZONE,\n-   the allocator will be zone-specific.  */\n+   vector allocator will be output.  */\n \n static void\n write_typed_alloc_def (outf_p f, \n                        bool variable_size, const char *type_specifier,\n                        const char *type_name, const char *allocator_type,\n-                       enum alloc_quantity quantity, enum alloc_zone zone)\n+                       enum alloc_quantity quantity)\n {\n   bool two_args = variable_size && (quantity == vector);\n-  bool third_arg = ((zone == specific_zone)\n-\t\t    && (variable_size || (quantity == vector)));\n   gcc_assert (f != NULL);\n   const char *type_name_as_id = filter_type_name (type_name);\n   oprintf (f, \"#define ggc_alloc_%s%s\", allocator_type, type_name_as_id);\n-  oprintf (f, \"(%s%s%s%s%s) \",\n+  oprintf (f, \"(%s%s%s) \",\n \t   (variable_size ? \"SIZE\" : \"\"),\n \t   (two_args ? \", \" : \"\"),\n-\t   (quantity == vector) ? \"n\" : \"\",\n-\t   (third_arg ? \", \" : \"\"), (zone == specific_zone) ? \"z\" : \"\");\n+\t   (quantity == vector) ? \"n\" : \"\");\n   oprintf (f, \"((%s%s *)\", type_specifier, type_name);\n   oprintf (f, \"(ggc_internal_%salloc_stat (\", allocator_type);\n-  if (zone == specific_zone)\n-    oprintf (f, \"z, \");\n   if (variable_size)\n     oprintf (f, \"SIZE\");\n   else\n@@ -4853,12 +4763,11 @@ write_typed_alloc_def (outf_p f,\n static void\n write_typed_struct_alloc_def (outf_p f,\n \t\t\t      const type_p s, const char *allocator_type,\n-\t\t\t      enum alloc_quantity quantity,\n-\t\t\t      enum alloc_zone zone)\n+\t\t\t      enum alloc_quantity quantity)\n {\n   gcc_assert (union_or_struct_p (s));\n   write_typed_alloc_def (f, variable_size_p (s), get_type_specifier (s),\n-                         s->u.s.tag, allocator_type, quantity, zone);\n+                         s->u.s.tag, allocator_type, quantity);\n }\n \n /* Writes a typed allocator definition into output F for a typedef P,\n@@ -4867,11 +4776,10 @@ write_typed_struct_alloc_def (outf_p f,\n static void\n write_typed_typedef_alloc_def (outf_p f,\n                                const pair_p p, const char *allocator_type,\n-                               enum alloc_quantity quantity,\n-                               enum alloc_zone zone)\n+                               enum alloc_quantity quantity)\n {\n   write_typed_alloc_def (f, variable_size_p (p->type), \"\", p->name,\n-                         allocator_type, quantity, zone);\n+                         allocator_type, quantity);\n }\n \n /* Writes typed allocator definitions into output F for the types in\n@@ -4897,16 +4805,10 @@ write_typed_alloc_defns (outf_p f,\n       if (nb_plugin_files > 0 \n \t  && ((s->u.s.line.file == NULL) || !s->u.s.line.file->inpisplugin))\n \tcontinue;\n-      write_typed_struct_alloc_def (f, s, \"\", single, any_zone);\n-      write_typed_struct_alloc_def (f, s, \"cleared_\", single, any_zone);\n-      write_typed_struct_alloc_def (f, s, \"vec_\", vector, any_zone);\n-      write_typed_struct_alloc_def (f, s, \"cleared_vec_\", vector, any_zone);\n-      write_typed_struct_alloc_def (f, s, \"zone_\", single, specific_zone);\n-      write_typed_struct_alloc_def (f, s, \"zone_cleared_\", single,\n-\t\t\t\t    specific_zone);\n-      write_typed_struct_alloc_def (f, s, \"zone_vec_\", vector, specific_zone);\n-      write_typed_struct_alloc_def (f, s, \"zone_cleared_vec_\", vector,\n-\t\t\t\t    specific_zone);\n+      write_typed_struct_alloc_def (f, s, \"\", single);\n+      write_typed_struct_alloc_def (f, s, \"cleared_\", single);\n+      write_typed_struct_alloc_def (f, s, \"vec_\", vector);\n+      write_typed_struct_alloc_def (f, s, \"cleared_vec_\", vector);\n     }\n \n   oprintf (f, \"\\n/* Allocators for known typedefs.  */\\n\");\n@@ -4923,15 +4825,10 @@ write_typed_alloc_defns (outf_p f,\n \t  if (!filoc || !filoc->file->inpisplugin)\n \t    continue;\n \t};\n-      write_typed_typedef_alloc_def (f, p, \"\", single, any_zone);\n-      write_typed_typedef_alloc_def (f, p, \"cleared_\", single, any_zone);\n-      write_typed_typedef_alloc_def (f, p, \"vec_\", vector, any_zone);\n-      write_typed_typedef_alloc_def (f, p, \"cleared_vec_\", vector, any_zone);\n-      write_typed_typedef_alloc_def (f, p, \"zone_\", single, specific_zone);\n-      write_typed_typedef_alloc_def (f, p, \"zone_cleared_\", single,\n-\t\t\t\t     specific_zone);\n-      write_typed_typedef_alloc_def (f, p, \"zone_cleared_vec_\", vector,\n-\t\t\t\t     specific_zone);\n+      write_typed_typedef_alloc_def (f, p, \"\", single);\n+      write_typed_typedef_alloc_def (f, p, \"cleared_\", single);\n+      write_typed_typedef_alloc_def (f, p, \"vec_\", vector);\n+      write_typed_typedef_alloc_def (f, p, \"cleared_vec_\", vector);\n     }\n }\n \n@@ -4990,10 +4887,7 @@ write_splay_tree_allocator_def (const_type_p s)\n   output_typename (of, s);\n   oprintf (of, \" (int sz, void * nl)\\n\");\n   oprintf (of, \"{\\n\");\n-  oprintf (of, \"  return ggc_splay_alloc (\");\n-  oprintf (of, \"gt_e_\");\n-  output_mangled_typename (of, s);\n-  oprintf (of, \", sz, nl);\\n\");\n+  oprintf (of, \"  return ggc_splay_alloc (sz, nl);\\n\");\n   oprintf (of, \"}\\n\\n\");\n }\n \n@@ -5647,7 +5541,6 @@ main (int argc, char **argv)\n \n   open_base_files ();\n \n-  write_enum_defn (structures, param_structs);\n   output_header = plugin_output ? plugin_output : header_file;\n   write_typed_alloc_defns (output_header, structures, typedefs);\n   DBGPRINT_COUNT_TYPE (\"structures before write_types outputheader\","}, {"sha": "f02224a9c59283726a9e493be930d79d19b7b10a", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -250,8 +250,7 @@ ggc_cleared_alloc_ptr_array_two_args (size_t c, size_t n)\n \n /* These are for splay_tree_new_ggc.  */\n void *\n-ggc_splay_alloc (enum gt_types_enum obj_type ATTRIBUTE_UNUSED, int sz,\n-\t\t void *nl)\n+ggc_splay_alloc (int sz, void *nl)\n {\n   gcc_assert (!nl);\n   return ggc_internal_alloc (sz);\n@@ -300,7 +299,6 @@ struct ptr_data\n   gt_handle_reorder reorder_fn;\n   size_t size;\n   void *new_addr;\n-  enum gt_types_enum type;\n };\n \n #define POINTER_HASH(x) (hashval_t)((intptr_t)x >> 3)\n@@ -309,8 +307,7 @@ struct ptr_data\n \n int\n gt_pch_note_object (void *obj, void *note_ptr_cookie,\n-\t\t    gt_note_pointers note_ptr_fn,\n-\t\t    enum gt_types_enum type)\n+\t\t    gt_note_pointers note_ptr_fn)\n {\n   struct ptr_data **slot;\n \n@@ -335,7 +332,6 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n     (*slot)->size = strlen ((const char *)obj) + 1;\n   else\n     (*slot)->size = ggc_get_size (obj);\n-  (*slot)->type = type;\n   return 1;\n }\n \n@@ -391,8 +387,7 @@ call_count (void **slot, void *state_p)\n   struct traversal_state *state = (struct traversal_state *)state_p;\n \n   ggc_pch_count_object (state->d, d->obj, d->size,\n-\t\t\td->note_ptr_fn == gt_pch_p_S,\n-\t\t\td->type);\n+\t\t\td->note_ptr_fn == gt_pch_p_S);\n   state->count++;\n   return 1;\n }\n@@ -404,8 +399,7 @@ call_alloc (void **slot, void *state_p)\n   struct traversal_state *state = (struct traversal_state *)state_p;\n \n   d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size,\n-\t\t\t\t      d->note_ptr_fn == gt_pch_p_S,\n-\t\t\t\t      d->type);\n+\t\t\t\t      d->note_ptr_fn == gt_pch_p_S);\n   state->ptrs[state->ptrs_i++] = d;\n   return 1;\n }"}, {"sha": "021961579f2322437b75eaf947710c316a703de2", "filename": "gcc/ggc-internal.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-internal.h?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -55,8 +55,7 @@ extern struct ggc_pch_data *init_ggc_pch (void);\n    of an object.  Update the ggc_pch_data structure with as much of\n    that information as is necessary. The bool argument should be true\n    if the object is a string.  */\n-extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool,\n-\t\t\t\t  enum gt_types_enum);\n+extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool);\n \n /* Return the total size of the data to be written to hold all\n    the objects previously passed to ggc_pch_count_object.  */\n@@ -69,8 +68,7 @@ extern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n /* Assuming that the objects really do end up at the address\n    passed to ggc_pch_this_base, return the address of this object.\n    The bool argument should be true if the object is a string.  */\n-extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool,\n-\t\t\t\t   enum gt_types_enum);\n+extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool);\n \n /* Write out any initial information required.  */\n extern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);"}, {"sha": "9a9a4e3b2e8647b70e16df65b9a418d5d0202b34", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -31,13 +31,6 @@\n #include \"coretypes.h\"\n #include \"ggc.h\"\n \n-void *\n-ggc_alloc_typed_stat (enum gt_types_enum ARG_UNUSED (gte), size_t size\n-\t\t      MEM_STAT_DECL)\n-{\n-  return xmalloc (size);\n-}\n-\n /* For a given size of memory requested for allocation, return the\n    actual size that is going to be allocated.  */\n \n@@ -70,31 +63,3 @@ ggc_free (void *p)\n {\n   free (p);\n }\n-\n-struct alloc_zone\n-{\n-  int dummy;\n-};\n-\n-struct alloc_zone rtl_zone;\n-struct alloc_zone tree_zone;\n-struct alloc_zone tree_id_zone;\n-\n-#if defined (GGC_ZONE) && !defined (GENERATOR_FILE)\n-\n-void *\n-ggc_internal_alloc_zone_stat (size_t size,\n-                              struct alloc_zone * ARG_UNUSED(z) MEM_STAT_DECL)\n-{\n-    return xmalloc (size);\n-}\n-\n-void *\n-ggc_internal_cleared_alloc_zone_stat (size_t size,\n-                                      struct alloc_zone * ARG_UNUSED(z)\n-                                      MEM_STAT_DECL)\n-{\n-    return xcalloc (size, 1);\n-}\n-\n-#endif"}, {"sha": "32768b2fc86cd0b838d48a0c3d237a3a09e2f199", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -1199,15 +1199,6 @@ ggc_round_alloc_size (size_t requested_size)\n   return size;\n }\n \n-/* Typed allocation function.  Does nothing special in this collector.  */\n-\n-void *\n-ggc_alloc_typed_stat (enum gt_types_enum type ATTRIBUTE_UNUSED, size_t size\n-\t\t      MEM_STAT_DECL)\n-{\n-  return ggc_internal_alloc_stat (size PASS_MEM_STAT);\n-}\n-\n /* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */\n \n void *\n@@ -2230,8 +2221,7 @@ init_ggc_pch (void)\n \n void\n ggc_pch_count_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED,\n-\t\t      enum gt_types_enum type ATTRIBUTE_UNUSED)\n+\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n {\n   unsigned order;\n \n@@ -2274,8 +2264,7 @@ ggc_pch_this_base (struct ggc_pch_data *d, void *base)\n \n char *\n ggc_pch_alloc_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED,\n-\t\t      enum gt_types_enum type ATTRIBUTE_UNUSED)\n+\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n {\n   unsigned order;\n   char *result;\n@@ -2507,12 +2496,3 @@ ggc_pch_read (FILE *f, void *addr)\n   /* Update the statistics.  */\n   G.allocated = G.allocated_last_gc = offs - (char *)addr;\n }\n-\n-struct alloc_zone\n-{\n-  int dummy;\n-};\n-\n-struct alloc_zone rtl_zone;\n-struct alloc_zone tree_zone;\n-struct alloc_zone tree_id_zone;"}, {"sha": "b3896af5557e460582b726912495366f9877589f", "filename": "gcc/ggc-zone.c", "status": "removed", "additions": 0, "deletions": 2526, "changes": 2526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=a861ffa4f3272dd7b87e68d5e2a5876cde3f63c3", "patch": "@@ -1,2526 +0,0 @@\n-/* \"Bag-of-pages\" zone garbage collector for the GNU compiler.\n-   Copyright (C) 1999-2013 Free Software Foundation, Inc.\n-\n-   Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin\n-   (dberlin@dberlin.org).  Rewritten by Daniel Jacobowitz\n-   <dan@codesourcery.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"diagnostic-core.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"ggc-internal.h\"\n-#include \"timevar.h\"\n-#include \"params.h\"\n-#include \"bitmap.h\"\n-#include \"plugin.h\"\n-\n-/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n-   file open.  Prefer either to valloc.  */\n-#ifdef HAVE_MMAP_ANON\n-# undef HAVE_MMAP_DEV_ZERO\n-# define USING_MMAP\n-#endif\n-\n-#ifdef HAVE_MMAP_DEV_ZERO\n-# define USING_MMAP\n-#endif\n-\n-#ifndef USING_MMAP\n-#error Zone collector requires mmap\n-#endif\n-\n-#if (GCC_VERSION < 3001)\n-#define prefetch(X) ((void) X)\n-#define prefetchw(X) ((void) X)\n-#else\n-#define prefetch(X) __builtin_prefetch (X)\n-#define prefetchw(X) __builtin_prefetch (X, 1, 3)\n-#endif\n-\n-/* FUTURE NOTES:\n-\n-   If we track inter-zone pointers, we can mark single zones at a\n-   time.\n-\n-   If we have a zone where we guarantee no inter-zone pointers, we\n-   could mark that zone separately.\n-\n-   The garbage zone should not be marked, and we should return 1 in\n-   ggc_set_mark for any object in the garbage zone, which cuts off\n-   marking quickly.  */\n-\n-/* Strategy:\n-\n-   This garbage-collecting allocator segregates objects into zones.\n-   It also segregates objects into \"large\" and \"small\" bins.  Large\n-   objects are greater than page size.\n-\n-   Pages for small objects are broken up into chunks.  The page has\n-   a bitmap which marks the start position of each chunk (whether\n-   allocated or free).  Free chunks are on one of the zone's free\n-   lists and contain a pointer to the next free chunk.  Chunks in\n-   most of the free lists have a fixed size determined by the\n-   free list.  Chunks in the \"other\" sized free list have their size\n-   stored right after their chain pointer.\n-\n-   Empty pages (of all sizes) are kept on a single page cache list,\n-   and are considered first when new pages are required; they are\n-   deallocated at the start of the next collection if they haven't\n-   been recycled by then.  The free page list is currently per-zone.  */\n-\n-/* Define GGC_DEBUG_LEVEL to print debugging information.\n-     0: No debugging output.\n-     1: GC statistics only.\n-     2: Page-entry allocations/deallocations as well.\n-     3: Object allocations as well.\n-     4: Object marks as well.  */\n-#define GGC_DEBUG_LEVEL (0)\n-\n-#ifndef HOST_BITS_PER_PTR\n-#define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n-#endif\n-\n-/* This structure manages small free chunks.  The SIZE field is only\n-   initialized if the chunk is in the \"other\" sized free list.  Large\n-   chunks are allocated one at a time to their own page, and so don't\n-   come in here.  */\n-\n-struct alloc_chunk {\n-  struct alloc_chunk *next_free;\n-  unsigned int size;\n-};\n-\n-/* The size of the fixed-size portion of a small page descriptor.  */\n-#define PAGE_OVERHEAD   (offsetof (struct small_page_entry, alloc_bits))\n-\n-/* The collector's idea of the page size.  This must be a power of two\n-   no larger than the system page size, because pages must be aligned\n-   to this amount and are tracked at this granularity in the page\n-   table.  We choose a size at compile time for efficiency.\n-\n-   We could make a better guess at compile time if PAGE_SIZE is a\n-   constant in system headers, and PAGE_SHIFT is defined...  */\n-#define GGC_PAGE_SIZE\t4096\n-#define GGC_PAGE_MASK\t(GGC_PAGE_SIZE - 1)\n-#define GGC_PAGE_SHIFT\t12\n-\n-#if 0\n-/* Alternative definitions which use the runtime page size.  */\n-#define GGC_PAGE_SIZE\tG.pagesize\n-#define GGC_PAGE_MASK\tG.page_mask\n-#define GGC_PAGE_SHIFT\tG.lg_pagesize\n-#endif\n-\n-/* The size of a small page managed by the garbage collector.  This\n-   must currently be GGC_PAGE_SIZE, but with a few changes could\n-   be any multiple of it to reduce certain kinds of overhead.  */\n-#define SMALL_PAGE_SIZE GGC_PAGE_SIZE\n-\n-/* Free bin information.  These numbers may be in need of re-tuning.\n-   In general, decreasing the number of free bins would seem to\n-   increase the time it takes to allocate... */\n-\n-/* FIXME: We can't use anything but MAX_ALIGNMENT for the bin size\n-   today.  */\n-\n-#define NUM_FREE_BINS\t\t64\n-#define FREE_BIN_DELTA\t\tMAX_ALIGNMENT\n-#define SIZE_BIN_DOWN(SIZE)\t((SIZE) / FREE_BIN_DELTA)\n-\n-/* Allocation and marking parameters.  */\n-\n-/* The smallest allocatable unit to keep track of.  */\n-#define BYTES_PER_ALLOC_BIT\tMAX_ALIGNMENT\n-\n-/* The smallest markable unit.  If we require each allocated object\n-   to contain at least two allocatable units, we can use half as many\n-   bits for the mark bitmap.  But this adds considerable complexity\n-   to sweeping.  */\n-#define BYTES_PER_MARK_BIT\tBYTES_PER_ALLOC_BIT\n-\n-#define BYTES_PER_MARK_WORD\t(8 * BYTES_PER_MARK_BIT * sizeof (mark_type))\n-\n-/* We use this structure to determine the alignment required for\n-   allocations.\n-\n-   There are several things wrong with this estimation of alignment.\n-\n-   The maximum alignment for a structure is often less than the\n-   maximum alignment for a basic data type; for instance, on some\n-   targets long long must be aligned to sizeof (int) in a structure\n-   and sizeof (long long) in a variable.  i386-linux is one example;\n-   Darwin is another (sometimes, depending on the compiler in use).\n-\n-   Also, long double is not included.  Nothing in GCC uses long\n-   double, so we assume that this is OK.  On powerpc-darwin, adding\n-   long double would bring the maximum alignment up to 16 bytes,\n-   and until we need long double (or to vectorize compiler operations)\n-   that's painfully wasteful.  This will need to change, some day.  */\n-\n-struct max_alignment {\n-  char c;\n-  union {\n-    HOST_WIDEST_INT i;\n-    double d;\n-  } u;\n-};\n-\n-/* The biggest alignment required.  */\n-\n-#define MAX_ALIGNMENT (offsetof (struct max_alignment, u))\n-\n-/* Compute the smallest multiple of F that is >= X.  */\n-\n-#define ROUND_UP(x, f) (CEIL (x, f) * (f))\n-\n-/* Types to use for the allocation and mark bitmaps.  It might be\n-   a good idea to add ffsl to libiberty and use unsigned long\n-   instead; that could speed us up where long is wider than int.  */\n-\n-typedef unsigned int alloc_type;\n-typedef unsigned int mark_type;\n-#define alloc_ffs(x) ffs(x)\n-\n-/* A page_entry records the status of an allocation page.  This is the\n-   common data between all three kinds of pages - small, large, and\n-   PCH.  */\n-typedef struct page_entry\n-{\n-  /* The address at which the memory is allocated.  */\n-  char *page;\n-\n-  /* The zone that this page entry belongs to.  */\n-  struct alloc_zone *zone;\n-\n-  /* How many collections we've survived.  */\n-  size_t survived;\n-\n-  /* Does this page contain small objects, or one large object?  */\n-  bool large_p;\n-\n-  /* Is this page part of the loaded PCH?  */\n-  bool pch_p;\n-} page_entry;\n-\n-/* Additional data needed for small pages.  */\n-struct small_page_entry\n-{\n-  struct page_entry common;\n-\n-  /* The next small page entry, or NULL if this is the last.  */\n-  struct small_page_entry *next;\n-\n-  /* If currently marking this zone, a pointer to the mark bits\n-     for this page.  If we aren't currently marking this zone,\n-     this pointer may be stale (pointing to freed memory).  */\n-  mark_type *mark_bits;\n-\n-  /* The allocation bitmap.  This array extends far enough to have\n-     one bit for every BYTES_PER_ALLOC_BIT bytes in the page.  */\n-  alloc_type alloc_bits[1];\n-};\n-\n-/* Additional data needed for large pages.  */\n-struct large_page_entry\n-{\n-  struct page_entry common;\n-\n-  /* The next large page entry, or NULL if this is the last.  */\n-  struct large_page_entry *next;\n-\n-  /* The number of bytes allocated, not including the page entry.  */\n-  size_t bytes;\n-\n-  /* The previous page in the list, so that we can unlink this one.  */\n-  struct large_page_entry *prev;\n-\n-  /* During marking, is this object marked?  */\n-  bool mark_p;\n-};\n-\n-/* A two-level tree is used to look up the page-entry for a given\n-   pointer.  Two chunks of the pointer's bits are extracted to index\n-   the first and second levels of the tree, as follows:\n-\n-\t\t\t\t   HOST_PAGE_SIZE_BITS\n-\t\t\t   32\t\t|      |\n-       msb +----------------+----+------+------+ lsb\n-\t\t\t    |    |      |\n-\t\t\t PAGE_L1_BITS   |\n-\t\t\t\t |      |\n-\t\t\t       PAGE_L2_BITS\n-\n-   The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry\n-   pages are aligned on system page boundaries.  The next most\n-   significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first\n-   index values in the lookup table, respectively.\n-\n-   For 32-bit architectures and the settings below, there are no\n-   leftover bits.  For architectures with wider pointers, the lookup\n-   tree points to a list of pages, which must be scanned to find the\n-   correct one.  */\n-\n-#define PAGE_L1_BITS\t(8)\n-#define PAGE_L2_BITS\t(32 - PAGE_L1_BITS - GGC_PAGE_SHIFT)\n-#define PAGE_L1_SIZE\t((size_t) 1 << PAGE_L1_BITS)\n-#define PAGE_L2_SIZE\t((size_t) 1 << PAGE_L2_BITS)\n-\n-#define LOOKUP_L1(p) \\\n-  (((size_t) (p) >> (32 - PAGE_L1_BITS)) & ((1 << PAGE_L1_BITS) - 1))\n-\n-#define LOOKUP_L2(p) \\\n-  (((size_t) (p) >> GGC_PAGE_SHIFT) & ((1 << PAGE_L2_BITS) - 1))\n-\n-#if HOST_BITS_PER_PTR <= 32\n-\n-/* On 32-bit hosts, we use a two level page table, as pictured above.  */\n-typedef page_entry **page_table[PAGE_L1_SIZE];\n-\n-#else\n-\n-/* On 64-bit hosts, we use the same two level page tables plus a linked\n-   list that disambiguates the top 32-bits.  There will almost always be\n-   exactly one entry in the list.  */\n-typedef struct page_table_chain\n-{\n-  struct page_table_chain *next;\n-  size_t high_bits;\n-  page_entry **table[PAGE_L1_SIZE];\n-} *page_table;\n-\n-#endif\n-\n-/* The global variables.  */\n-static struct globals\n-{\n-  /* The linked list of zones.  */\n-  struct alloc_zone *zones;\n-\n-  /* Lookup table for associating allocation pages with object addresses.  */\n-  page_table lookup;\n-\n-  /* The system's page size, and related constants.  */\n-  size_t pagesize;\n-  size_t lg_pagesize;\n-  size_t page_mask;\n-\n-  /* The size to allocate for a small page entry.  This includes\n-     the size of the structure and the size of the allocation\n-     bitmap.  */\n-  size_t small_page_overhead;\n-\n-#if defined (HAVE_MMAP_DEV_ZERO)\n-  /* A file descriptor open to /dev/zero for reading.  */\n-  int dev_zero_fd;\n-#endif\n-\n-  /* Allocate pages in chunks of this size, to throttle calls to memory\n-     allocation routines.  The first page is used, the rest go onto the\n-     free list.  */\n-  size_t quire_size;\n-\n-  /* The file descriptor for debugging output.  */\n-  FILE *debug_file;\n-} G;\n-\n-/* A zone allocation structure.  There is one of these for every\n-   distinct allocation zone.  */\n-struct alloc_zone\n-{\n-  /* The most recent free chunk is saved here, instead of in the linked\n-     free list, to decrease list manipulation.  It is most likely that we\n-     will want this one.  */\n-  char *cached_free;\n-  size_t cached_free_size;\n-\n-  /* Linked lists of free storage.  Slots 1 ... NUM_FREE_BINS have chunks of size\n-     FREE_BIN_DELTA.  All other chunks are in slot 0.  */\n-  struct alloc_chunk *free_chunks[NUM_FREE_BINS + 1];\n-\n-  /* The highest bin index which might be non-empty.  It may turn out\n-     to be empty, in which case we have to search downwards.  */\n-  size_t high_free_bin;\n-\n-  /* Bytes currently allocated in this zone.  */\n-  size_t allocated;\n-\n-  /* Linked list of the small pages in this zone.  */\n-  struct small_page_entry *pages;\n-\n-  /* Doubly linked list of large pages in this zone.  */\n-  struct large_page_entry *large_pages;\n-\n-  /* If we are currently marking this zone, a pointer to the mark bits.  */\n-  mark_type *mark_bits;\n-\n-  /* Name of the zone.  */\n-  const char *name;\n-\n-  /* The number of small pages currently allocated in this zone.  */\n-  size_t n_small_pages;\n-\n-  /* Bytes allocated at the end of the last collection.  */\n-  size_t allocated_last_gc;\n-\n-  /* Total amount of memory mapped.  */\n-  size_t bytes_mapped;\n-\n-  /* A cache of free system pages.  */\n-  struct small_page_entry *free_pages;\n-\n-  /* Next zone in the linked list of zones.  */\n-  struct alloc_zone *next_zone;\n-\n-  /* True if this zone was collected during this collection.  */\n-  bool was_collected;\n-\n-  /* True if this zone should be destroyed after the next collection.  */\n-  bool dead;\n-\n-  struct\n-  {\n-    /* Total GC-allocated memory.  */\n-    unsigned long long total_allocated;\n-    /* Total overhead for GC-allocated memory.  */\n-    unsigned long long total_overhead;\n-\n-    /* Total allocations and overhead for sizes less than 32, 64 and 128.\n-       These sizes are interesting because they are typical cache line\n-       sizes.  */\n-\n-    unsigned long long total_allocated_under32;\n-    unsigned long long total_overhead_under32;\n-\n-    unsigned long long total_allocated_under64;\n-    unsigned long long total_overhead_under64;\n-\n-    unsigned long long total_allocated_under128;\n-    unsigned long long total_overhead_under128;\n-  } stats;\n-} main_zone;\n-\n-/* Some default zones.  */\n-struct alloc_zone rtl_zone;\n-struct alloc_zone tree_zone;\n-struct alloc_zone tree_id_zone;\n-\n-/* The PCH zone does not need a normal zone structure, and it does\n-   not live on the linked list of zones.  */\n-struct pch_zone\n-{\n-  /* The start of the PCH zone.  NULL if there is none.  */\n-  char *page;\n-\n-  /* The end of the PCH zone.  NULL if there is none.  */\n-  char *end;\n-\n-  /* The size of the PCH zone.  0 if there is none.  */\n-  size_t bytes;\n-\n-  /* The allocation bitmap for the PCH zone.  */\n-  alloc_type *alloc_bits;\n-\n-  /* If we are currently marking, the mark bitmap for the PCH zone.\n-     When it is first read in, we could avoid marking the PCH,\n-     because it will not contain any pointers to GC memory outside\n-     of the PCH; however, the PCH is currently mapped as writable,\n-     so we must mark it in case new pointers are added.  */\n-  mark_type *mark_bits;\n-} pch_zone;\n-\n-#ifdef USING_MMAP\n-static char *alloc_anon (char *, size_t, struct alloc_zone *);\n-#endif\n-static struct small_page_entry * alloc_small_page (struct alloc_zone *);\n-static struct large_page_entry * alloc_large_page (size_t, struct alloc_zone *);\n-static void free_chunk (char *, size_t, struct alloc_zone *);\n-static void free_small_page (struct small_page_entry *);\n-static void free_large_page (struct large_page_entry *);\n-static void release_pages (struct alloc_zone *);\n-static void sweep_pages (struct alloc_zone *);\n-static bool ggc_collect_1 (struct alloc_zone *, bool);\n-static void new_ggc_zone_1 (struct alloc_zone *, const char *);\n-\n-/* Traverse the page table and find the entry for a page.\n-   Die (probably) if the object wasn't allocated via GC.  */\n-\n-static inline page_entry *\n-lookup_page_table_entry (const void *p)\n-{\n-  page_entry ***base;\n-  size_t L1, L2;\n-\n-#if HOST_BITS_PER_PTR <= 32\n-  base = &G.lookup[0];\n-#else\n-  page_table table = G.lookup;\n-  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n-  while (table->high_bits != high_bits)\n-    table = table->next;\n-  base = &table->table[0];\n-#endif\n-\n-  /* Extract the level 1 and 2 indices.  */\n-  L1 = LOOKUP_L1 (p);\n-  L2 = LOOKUP_L2 (p);\n-\n-  return base[L1][L2];\n-}\n-\n-/* Traverse the page table and find the entry for a page.\n-   Return NULL if the object wasn't allocated via the GC.  */\n-\n-static inline page_entry *\n-lookup_page_table_if_allocated (const void *p)\n-{\n-  page_entry ***base;\n-  size_t L1, L2;\n-\n-#if HOST_BITS_PER_PTR <= 32\n-  base = &G.lookup[0];\n-#else\n-  page_table table = G.lookup;\n-  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n-  while (1)\n-    {\n-      if (table == NULL)\n-\treturn NULL;\n-      if (table->high_bits == high_bits)\n-\tbreak;\n-      table = table->next;\n-    }\n-  base = &table->table[0];\n-#endif\n-\n-  /* Extract the level 1 and 2 indices.  */\n-  L1 = LOOKUP_L1 (p);\n-  if (! base[L1])\n-    return NULL;\n-\n-  L2 = LOOKUP_L2 (p);\n-  if (L2 >= PAGE_L2_SIZE)\n-    return NULL;\n-  /* We might have a page entry which does not correspond exactly to a\n-     system page.  */\n-  if (base[L1][L2] && (const char *) p < base[L1][L2]->page)\n-    return NULL;\n-\n-  return base[L1][L2];\n-}\n-\n-/* Set the page table entry for the page that starts at P.  If ENTRY\n-   is NULL, clear the entry.  */\n-\n-static void\n-set_page_table_entry (void *p, page_entry *entry)\n-{\n-  page_entry ***base;\n-  size_t L1, L2;\n-\n-#if HOST_BITS_PER_PTR <= 32\n-  base = &G.lookup[0];\n-#else\n-  page_table table;\n-  size_t high_bits = (size_t) p & ~ (size_t) 0xffffffff;\n-  for (table = G.lookup; table; table = table->next)\n-    if (table->high_bits == high_bits)\n-      goto found;\n-\n-  /* Not found -- allocate a new table.  */\n-  table = XCNEW (struct page_table_chain);\n-  table->next = G.lookup;\n-  table->high_bits = high_bits;\n-  G.lookup = table;\n-found:\n-  base = &table->table[0];\n-#endif\n-\n-  /* Extract the level 1 and 2 indices.  */\n-  L1 = LOOKUP_L1 (p);\n-  L2 = LOOKUP_L2 (p);\n-\n-  if (base[L1] == NULL)\n-    base[L1] = XCNEWVEC (page_entry *, PAGE_L2_SIZE);\n-\n-  base[L1][L2] = entry;\n-}\n-\n-/* Find the page table entry associated with OBJECT.  */\n-\n-static inline struct page_entry *\n-zone_get_object_page (const void *object)\n-{\n-  return lookup_page_table_entry (object);\n-}\n-\n-/* Find which element of the alloc_bits array OBJECT should be\n-   recorded in.  */\n-static inline unsigned int\n-zone_get_object_alloc_word (const void *object)\n-{\n-  return (((size_t) object & (GGC_PAGE_SIZE - 1))\n-\t  / (8 * sizeof (alloc_type) * BYTES_PER_ALLOC_BIT));\n-}\n-\n-/* Find which bit of the appropriate word in the alloc_bits array\n-   OBJECT should be recorded in.  */\n-static inline unsigned int\n-zone_get_object_alloc_bit (const void *object)\n-{\n-  return (((size_t) object / BYTES_PER_ALLOC_BIT)\n-\t  % (8 * sizeof (alloc_type)));\n-}\n-\n-/* Find which element of the mark_bits array OBJECT should be recorded\n-   in.  */\n-static inline unsigned int\n-zone_get_object_mark_word (const void *object)\n-{\n-  return (((size_t) object & (GGC_PAGE_SIZE - 1))\n-\t  / (8 * sizeof (mark_type) * BYTES_PER_MARK_BIT));\n-}\n-\n-/* Find which bit of the appropriate word in the mark_bits array\n-   OBJECT should be recorded in.  */\n-static inline unsigned int\n-zone_get_object_mark_bit (const void *object)\n-{\n-  return (((size_t) object / BYTES_PER_MARK_BIT)\n-\t  % (8 * sizeof (mark_type)));\n-}\n-\n-/* Set the allocation bit corresponding to OBJECT in its page's\n-   bitmap.  Used to split this object from the preceding one.  */\n-static inline void\n-zone_set_object_alloc_bit (const void *object)\n-{\n-  struct small_page_entry *page\n-    = (struct small_page_entry *) zone_get_object_page (object);\n-  unsigned int start_word = zone_get_object_alloc_word (object);\n-  unsigned int start_bit = zone_get_object_alloc_bit (object);\n-\n-  page->alloc_bits[start_word] |= 1L << start_bit;\n-}\n-\n-/* Clear the allocation bit corresponding to OBJECT in PAGE's\n-   bitmap.  Used to coalesce this object with the preceding\n-   one.  */\n-static inline void\n-zone_clear_object_alloc_bit (struct small_page_entry *page,\n-\t\t\t     const void *object)\n-{\n-  unsigned int start_word = zone_get_object_alloc_word (object);\n-  unsigned int start_bit = zone_get_object_alloc_bit (object);\n-\n-  /* Would xor be quicker?  */\n-  page->alloc_bits[start_word] &= ~(1L << start_bit);\n-}\n-\n-/* Find the size of the object which starts at START_WORD and\n-   START_BIT in ALLOC_BITS, which is at most MAX_SIZE bytes.\n-   Helper function for ggc_get_size and zone_find_object_size.  */\n-\n-static inline size_t\n-zone_object_size_1 (alloc_type *alloc_bits,\n-\t\t    size_t start_word, size_t start_bit,\n-\t\t    size_t max_size)\n-{\n-  size_t size;\n-  alloc_type alloc_word;\n-  int indx;\n-\n-  /* Load the first word.  */\n-  alloc_word = alloc_bits[start_word++];\n-\n-  /* If that was the last bit in this word, we'll want to continue\n-     with the next word.  Otherwise, handle the rest of this word.  */\n-  if (start_bit)\n-    {\n-      indx = alloc_ffs (alloc_word >> start_bit);\n-      if (indx)\n-\t/* indx is 1-based.  We started at the bit after the object's\n-\t   start, but we also ended at the bit after the object's end.\n-\t   It cancels out.  */\n-\treturn indx * BYTES_PER_ALLOC_BIT;\n-\n-      /* The extra 1 accounts for the starting unit, before start_bit.  */\n-      size = (sizeof (alloc_type) * 8 - start_bit + 1) * BYTES_PER_ALLOC_BIT;\n-\n-      if (size >= max_size)\n-\treturn max_size;\n-\n-      alloc_word = alloc_bits[start_word++];\n-    }\n-  else\n-    size = BYTES_PER_ALLOC_BIT;\n-\n-  while (alloc_word == 0)\n-    {\n-      size += sizeof (alloc_type) * 8 * BYTES_PER_ALLOC_BIT;\n-      if (size >= max_size)\n-\treturn max_size;\n-      alloc_word = alloc_bits[start_word++];\n-    }\n-\n-  indx = alloc_ffs (alloc_word);\n-  return size + (indx - 1) * BYTES_PER_ALLOC_BIT;\n-}\n-\n-/* Find the size of OBJECT on small page PAGE.  */\n-\n-static inline size_t\n-zone_find_object_size (struct small_page_entry *page,\n-\t\t       const void *object)\n-{\n-  const char *object_midptr = (const char *) object + BYTES_PER_ALLOC_BIT;\n-  unsigned int start_word = zone_get_object_alloc_word (object_midptr);\n-  unsigned int start_bit = zone_get_object_alloc_bit (object_midptr);\n-  size_t max_size = (page->common.page + SMALL_PAGE_SIZE\n-\t\t     - (const char *) object);\n-\n-  return zone_object_size_1 (page->alloc_bits, start_word, start_bit,\n-\t\t\t     max_size);\n-}\n-\n-/* highest_bit assumes that alloc_type is 32 bits.  */\n-extern char check_alloc_type_size[(sizeof (alloc_type) == 4) ? 1 : -1];\n-\n-/* Find the highest set bit in VALUE.  Returns the bit number of that\n-   bit, using the same values as ffs.  */\n-static inline alloc_type\n-highest_bit (alloc_type value)\n-{\n-  /* This also assumes that alloc_type is unsigned.  */\n-  value |= value >> 1;\n-  value |= value >> 2;\n-  value |= value >> 4;\n-  value |= value >> 8;\n-  value |= value >> 16;\n-  value = value ^ (value >> 1);\n-  return alloc_ffs (value);\n-}\n-\n-/* Find the offset from the start of an object to P, which may point\n-   into the interior of the object.  */\n-\n-static unsigned long\n-zone_find_object_offset (alloc_type *alloc_bits, size_t start_word,\n-\t\t\t size_t start_bit)\n-{\n-  unsigned int offset_in_bits;\n-  alloc_type alloc_word = alloc_bits[start_word];\n-\n-  /* Mask off any bits after the initial bit, but make sure to include\n-     the initial bit in the result.  Note that START_BIT is\n-     0-based.  */\n-  if (start_bit < 8 * sizeof (alloc_type) - 1)\n-    alloc_word &= (1 << (start_bit + 1)) - 1;\n-  offset_in_bits = start_bit;\n-\n-  /* Search for the start of the object.  */\n-  while (alloc_word == 0 && start_word > 0)\n-    {\n-      alloc_word = alloc_bits[--start_word];\n-      offset_in_bits += 8 * sizeof (alloc_type);\n-    }\n-  /* We must always find a set bit.  */\n-  gcc_assert (alloc_word != 0);\n-  /* Note that the result of highest_bit is 1-based.  */\n-  offset_in_bits -= highest_bit (alloc_word) - 1;\n-\n-  return BYTES_PER_ALLOC_BIT * offset_in_bits;\n-}\n-\n-/* Allocate the mark bits for every zone, and set the pointers on each\n-   page.  */\n-static void\n-zone_allocate_marks (void)\n-{\n-  struct alloc_zone *zone;\n-\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    {\n-      struct small_page_entry *page;\n-      mark_type *cur_marks;\n-      size_t mark_words, mark_words_per_page;\n-#ifdef ENABLE_CHECKING\n-      size_t n = 0;\n-#endif\n-\n-      mark_words_per_page\n-\t= (GGC_PAGE_SIZE + BYTES_PER_MARK_WORD - 1) / BYTES_PER_MARK_WORD;\n-      mark_words = zone->n_small_pages * mark_words_per_page;\n-      zone->mark_bits = (mark_type *) xcalloc (sizeof (mark_type),\n-\t\t\t\t\t\t   mark_words);\n-      cur_marks = zone->mark_bits;\n-      for (page = zone->pages; page; page = page->next)\n-\t{\n-\t  page->mark_bits = cur_marks;\n-\t  cur_marks += mark_words_per_page;\n-#ifdef ENABLE_CHECKING\n-\t  n++;\n-#endif\n-\t}\n-      gcc_checking_assert (n == zone->n_small_pages);\n-    }\n-\n-  /* We don't collect the PCH zone, but we do have to mark it\n-     (for now).  */\n-  if (pch_zone.bytes)\n-    pch_zone.mark_bits\n-      = (mark_type *) xcalloc (sizeof (mark_type),\n-\t\t\t       CEIL (pch_zone.bytes, BYTES_PER_MARK_WORD));\n-}\n-\n-/* After marking and sweeping, release the memory used for mark bits.  */\n-static void\n-zone_free_marks (void)\n-{\n-  struct alloc_zone *zone;\n-\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    if (zone->mark_bits)\n-      {\n-\tfree (zone->mark_bits);\n-\tzone->mark_bits = NULL;\n-      }\n-\n-  if (pch_zone.bytes)\n-    {\n-      free (pch_zone.mark_bits);\n-      pch_zone.mark_bits = NULL;\n-    }\n-}\n-\n-#ifdef USING_MMAP\n-/* Allocate SIZE bytes of anonymous memory, preferably near PREF,\n-   (if non-null).  The ifdef structure here is intended to cause a\n-   compile error unless exactly one of the HAVE_* is defined.  */\n-\n-static inline char *\n-alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size, struct alloc_zone *zone)\n-{\n-#ifdef HAVE_MMAP_ANON\n-  char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n-\t\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n-#endif\n-#ifdef HAVE_MMAP_DEV_ZERO\n-  char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n-\t\t\t      MAP_PRIVATE, G.dev_zero_fd, 0);\n-#endif\n-\n-  if (page == (char *) MAP_FAILED)\n-    {\n-      perror (\"virtual memory exhausted\");\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  /* Remember that we allocated this memory.  */\n-  zone->bytes_mapped += size;\n-\n-  /* Pretend we don't have access to the allocated pages.  We'll enable\n-     access to smaller pieces of the area in ggc_internal_alloc.  Discard the\n-     handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (page, size));\n-\n-  return page;\n-}\n-#endif\n-\n-/* Allocate a new page for allocating small objects in ZONE, and\n-   return an entry for it.  */\n-\n-static struct small_page_entry *\n-alloc_small_page (struct alloc_zone *zone)\n-{\n-  struct small_page_entry *entry;\n-\n-  /* Check the list of free pages for one we can use.  */\n-  entry = zone->free_pages;\n-  if (entry != NULL)\n-    {\n-      /* Recycle the allocated memory from this page ...  */\n-      zone->free_pages = entry->next;\n-    }\n-  else\n-    {\n-      /* We want just one page.  Allocate a bunch of them and put the\n-\t extras on the freelist.  (Can only do this optimization with\n-\t mmap for backing store.)  */\n-      struct small_page_entry *e, *f = zone->free_pages;\n-      int i;\n-      char *page;\n-\n-      page = alloc_anon (NULL, GGC_PAGE_SIZE * G.quire_size, zone);\n-\n-      /* This loop counts down so that the chain will be in ascending\n-\t memory order.  */\n-      for (i = G.quire_size - 1; i >= 1; i--)\n-\t{\n-\t  e = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n-\t  e->common.page = page + (i << GGC_PAGE_SHIFT);\n-\t  e->common.zone = zone;\n-\t  e->next = f;\n-\t  f = e;\n-\t  set_page_table_entry (e->common.page, &e->common);\n-\t}\n-\n-      zone->free_pages = f;\n-\n-      entry = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n-      entry->common.page = page;\n-      entry->common.zone = zone;\n-      set_page_table_entry (page, &entry->common);\n-    }\n-\n-  zone->n_small_pages++;\n-\n-  if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file,\n-\t     \"Allocating %s page at %p, data %p-%p\\n\",\n-\t     entry->common.zone->name, (PTR) entry, entry->common.page,\n-\t     entry->common.page + SMALL_PAGE_SIZE - 1);\n-\n-  return entry;\n-}\n-\n-/* Allocate a large page of size SIZE in ZONE.  */\n-\n-static struct large_page_entry *\n-alloc_large_page (size_t size, struct alloc_zone *zone)\n-{\n-  struct large_page_entry *entry;\n-  char *page;\n-  size_t needed_size;\n-\n-  needed_size = size + sizeof (struct large_page_entry);\n-  page = XNEWVAR (char, needed_size);\n-\n-  entry = (struct large_page_entry *) page;\n-\n-  entry->next = NULL;\n-  entry->common.page = page + sizeof (struct large_page_entry);\n-  entry->common.large_p = true;\n-  entry->common.pch_p = false;\n-  entry->common.zone = zone;\n-  entry->common.survived = 0;\n-  entry->mark_p = false;\n-  entry->bytes = size;\n-  entry->prev = NULL;\n-\n-  set_page_table_entry (entry->common.page, &entry->common);\n-\n-  if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file,\n-\t     \"Allocating %s large page at %p, data %p-%p\\n\",\n-\t     entry->common.zone->name, (PTR) entry, entry->common.page,\n-\t     entry->common.page + SMALL_PAGE_SIZE - 1);\n-\n-  return entry;\n-}\n-\n-\n-/* For a page that is no longer needed, put it on the free page list.  */\n-\n-static inline void\n-free_small_page (struct small_page_entry *entry)\n-{\n-  if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file,\n-\t     \"Deallocating %s page at %p, data %p-%p\\n\",\n-\t     entry->common.zone->name, (PTR) entry,\n-\t     entry->common.page, entry->common.page + SMALL_PAGE_SIZE - 1);\n-\n-  gcc_assert (!entry->common.large_p);\n-\n-  /* Mark the page as inaccessible.  Discard the handle to\n-     avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (entry->common.page,\n-\t\t\t\t\t\tSMALL_PAGE_SIZE));\n-\n-  entry->next = entry->common.zone->free_pages;\n-  entry->common.zone->free_pages = entry;\n-  entry->common.zone->n_small_pages--;\n-}\n-\n-/* Release a large page that is no longer needed.  */\n-\n-static inline void\n-free_large_page (struct large_page_entry *entry)\n-{\n-  if (GGC_DEBUG_LEVEL >= 2)\n-    fprintf (G.debug_file,\n-\t     \"Deallocating %s page at %p, data %p-%p\\n\",\n-\t     entry->common.zone->name, (PTR) entry,\n-\t     entry->common.page, entry->common.page + SMALL_PAGE_SIZE - 1);\n-\n-  gcc_assert (entry->common.large_p);\n-\n-  set_page_table_entry (entry->common.page, NULL);\n-  free (entry);\n-}\n-\n-/* Release the free page cache to the system.  */\n-\n-static void\n-release_pages (struct alloc_zone *zone)\n-{\n-#ifdef USING_MMAP\n-  struct small_page_entry *p, *next;\n-  char *start;\n-  size_t len;\n-\n-  /* Gather up adjacent pages so they are unmapped together.  */\n-  p = zone->free_pages;\n-\n-  while (p)\n-    {\n-      start = p->common.page;\n-      next = p->next;\n-      len = SMALL_PAGE_SIZE;\n-      set_page_table_entry (p->common.page, NULL);\n-      p = next;\n-\n-      while (p && p->common.page == start + len)\n-\t{\n-\t  next = p->next;\n-\t  len += SMALL_PAGE_SIZE;\n-\t  set_page_table_entry (p->common.page, NULL);\n-\t  p = next;\n-\t}\n-\n-      munmap (start, len);\n-      zone->bytes_mapped -= len;\n-    }\n-\n-  zone->free_pages = NULL;\n-#endif\n-}\n-\n-/* Place the block at PTR of size SIZE on the free list for ZONE.  */\n-\n-static inline void\n-free_chunk (char *ptr, size_t size, struct alloc_zone *zone)\n-{\n-  struct alloc_chunk *chunk = (struct alloc_chunk *) ptr;\n-  size_t bin = 0;\n-\n-  bin = SIZE_BIN_DOWN (size);\n-  gcc_assert (bin != 0);\n-  if (bin > NUM_FREE_BINS)\n-    {\n-      bin = 0;\n-      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (chunk,\n-\t\t\t\t\t\t     sizeof (struct\n-\t\t\t\t\t\t\t     alloc_chunk)));\n-      chunk->size = size;\n-      chunk->next_free = zone->free_chunks[bin];\n-      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (ptr\n-\t\t\t\t\t\t    + sizeof (struct\n-\t\t\t\t\t\t\t      alloc_chunk),\n-\t\t\t\t\t\t    size\n-\t\t\t\t\t\t    - sizeof (struct\n-\t\t\t\t\t\t\t      alloc_chunk)));\n-    }\n-  else\n-    {\n-      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (chunk,\n-\t\t\t\t\t\t     sizeof (struct\n-\t\t\t\t\t\t\t     alloc_chunk *)));\n-      chunk->next_free = zone->free_chunks[bin];\n-      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (ptr\n-\t\t\t\t\t\t    + sizeof (struct\n-\t\t\t\t\t\t\t      alloc_chunk *),\n-\t\t\t\t\t\t    size\n-\t\t\t\t\t\t    - sizeof (struct\n-\t\t\t\t\t\t\t      alloc_chunk *)));\n-    }\n-\n-  zone->free_chunks[bin] = chunk;\n-  if (bin > zone->high_free_bin)\n-    zone->high_free_bin = bin;\n-  if (GGC_DEBUG_LEVEL >= 3)\n-    fprintf (G.debug_file, \"Deallocating object, chunk=%p\\n\", (void *)chunk);\n-}\n-\n-/* For a given size of memory requested for allocation, return the\n-   actual size that is going to be allocated.  */\n-\n-size_t\n-ggc_round_alloc_size (size_t requested_size)\n-{\n-  size_t size;\n-\n-  /* Make sure that zero-sized allocations get a unique and freeable\n-     pointer.  */\n-  if (requested_size == 0)\n-    size = MAX_ALIGNMENT;\n-  else\n-    size = (requested_size + MAX_ALIGNMENT - 1) & -MAX_ALIGNMENT;\n-\n-  return size;\n-}\n-\n-/* Allocate a chunk of memory of at least ORIG_SIZE bytes, in ZONE.  */\n-\n-void *\n-ggc_internal_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n-\t\t\t      MEM_STAT_DECL)\n-{\n-  size_t bin;\n-  size_t csize;\n-  struct small_page_entry *entry;\n-  struct alloc_chunk *chunk, **pp;\n-  void *result;\n-  size_t size = ggc_round_alloc_size (orig_size);\n-\n-  /* Try to allocate the object from several different sources.  Each\n-     of these cases is responsible for setting RESULT and SIZE to\n-     describe the allocated block, before jumping to FOUND.  If a\n-     chunk is split, the allocate bit for the new chunk should also be\n-     set.\n-\n-     Large objects are handled specially.  However, they'll just fail\n-     the next couple of conditions, so we can wait to check for them\n-     below.  The large object case is relatively rare (< 1%), so this\n-     is a win.  */\n-\n-  /* First try to split the last chunk we allocated.  For best\n-     fragmentation behavior it would be better to look for a\n-     free bin of the appropriate size for a small object.  However,\n-     we're unlikely (1% - 7%) to find one, and this gives better\n-     locality behavior anyway.  This case handles the lion's share\n-     of all calls to this function.  */\n-  if (size <= zone->cached_free_size)\n-    {\n-      result = zone->cached_free;\n-\n-      zone->cached_free_size -= size;\n-      if (zone->cached_free_size)\n-\t{\n-\t  zone->cached_free += size;\n-\t  zone_set_object_alloc_bit (zone->cached_free);\n-\t}\n-\n-      goto found;\n-    }\n-\n-  /* Next, try to find a free bin of the exactly correct size.  */\n-\n-  /* We want to round SIZE up, rather than down, but we know it's\n-     already aligned to at least FREE_BIN_DELTA, so we can just\n-     shift.  */\n-  bin = SIZE_BIN_DOWN (size);\n-\n-  if (bin <= NUM_FREE_BINS\n-      && (chunk = zone->free_chunks[bin]) != NULL)\n-    {\n-      /* We have a chunk of the right size.  Pull it off the free list\n-\t and use it.  */\n-\n-      zone->free_chunks[bin] = chunk->next_free;\n-\n-      /* NOTE: SIZE is only guaranteed to be right if MAX_ALIGNMENT\n-\t == FREE_BIN_DELTA.  */\n-      result = chunk;\n-\n-      /* The allocation bits are already set correctly.  HIGH_FREE_BIN\n-\t may now be wrong, if this was the last chunk in the high bin.\n-\t Rather than fixing it up now, wait until we need to search\n-\t the free bins.  */\n-\n-      goto found;\n-    }\n-\n-  /* Next, if there wasn't a chunk of the ideal size, look for a chunk\n-     to split.  We can find one in the too-big bin, or in the largest\n-     sized bin with a chunk in it.  Try the largest normal-sized bin\n-     first.  */\n-\n-  if (zone->high_free_bin > bin)\n-    {\n-      /* Find the highest numbered free bin.  It will be at or below\n-\t the watermark.  */\n-      while (zone->high_free_bin > bin\n-\t     && zone->free_chunks[zone->high_free_bin] == NULL)\n-\tzone->high_free_bin--;\n-\n-      if (zone->high_free_bin > bin)\n-\t{\n-\t  size_t tbin = zone->high_free_bin;\n-\t  chunk = zone->free_chunks[tbin];\n-\n-\t  /* Remove the chunk from its previous bin.  */\n-\t  zone->free_chunks[tbin] = chunk->next_free;\n-\n-\t  result = (char *) chunk;\n-\n-\t  /* Save the rest of the chunk for future allocation.  */\n-\t  if (zone->cached_free_size)\n-\t    free_chunk (zone->cached_free, zone->cached_free_size, zone);\n-\n-\t  chunk = (struct alloc_chunk *) ((char *) result + size);\n-\t  zone->cached_free = (char *) chunk;\n-\t  zone->cached_free_size = (tbin - bin) * FREE_BIN_DELTA;\n-\n-\t  /* Mark the new free chunk as an object, so that we can\n-\t     find the size of the newly allocated object.  */\n-\t  zone_set_object_alloc_bit (chunk);\n-\n-\t  /* HIGH_FREE_BIN may now be wrong, if this was the last\n-\t     chunk in the high bin.  Rather than fixing it up now,\n-\t     wait until we need to search the free bins.  */\n-\n-\t  goto found;\n-\t}\n-    }\n-\n-  /* Failing that, look through the \"other\" bucket for a chunk\n-     that is large enough.  */\n-  pp = &(zone->free_chunks[0]);\n-  chunk = *pp;\n-  while (chunk && chunk->size < size)\n-    {\n-      pp = &chunk->next_free;\n-      chunk = *pp;\n-    }\n-\n-  if (chunk)\n-    {\n-      /* Remove the chunk from its previous bin.  */\n-      *pp = chunk->next_free;\n-\n-      result = (char *) chunk;\n-\n-      /* Save the rest of the chunk for future allocation, if there's any\n-\t left over.  */\n-      csize = chunk->size;\n-      if (csize > size)\n-\t{\n-\t  if (zone->cached_free_size)\n-\t    free_chunk (zone->cached_free, zone->cached_free_size, zone);\n-\n-\t  chunk = (struct alloc_chunk *) ((char *) result + size);\n-\t  zone->cached_free = (char *) chunk;\n-\t  zone->cached_free_size = csize - size;\n-\n-\t  /* Mark the new free chunk as an object.  */\n-\t  zone_set_object_alloc_bit (chunk);\n-\t}\n-\n-      goto found;\n-    }\n-\n-  /* Handle large allocations.  We could choose any threshold between\n-     GGC_PAGE_SIZE - sizeof (struct large_page_entry) and\n-     GGC_PAGE_SIZE.  It can't be smaller, because then it wouldn't\n-     be guaranteed to have a unique entry in the lookup table.  Large\n-     allocations will always fall through to here.  */\n-  if (size > GGC_PAGE_SIZE)\n-    {\n-      struct large_page_entry *entry = alloc_large_page (size, zone);\n-\n-      entry->common.survived = 0;\n-\n-      entry->next = zone->large_pages;\n-      if (zone->large_pages)\n-\tzone->large_pages->prev = entry;\n-      zone->large_pages = entry;\n-\n-      result = entry->common.page;\n-\n-      goto found;\n-    }\n-\n-  /* Failing everything above, allocate a new small page.  */\n-\n-  entry = alloc_small_page (zone);\n-  entry->next = zone->pages;\n-  zone->pages = entry;\n-\n-  /* Mark the first chunk in the new page.  */\n-  entry->alloc_bits[0] = 1;\n-\n-  result = entry->common.page;\n-  if (size < SMALL_PAGE_SIZE)\n-    {\n-      if (zone->cached_free_size)\n-\tfree_chunk (zone->cached_free, zone->cached_free_size, zone);\n-\n-      zone->cached_free = (char *) result + size;\n-      zone->cached_free_size = SMALL_PAGE_SIZE - size;\n-\n-      /* Mark the new free chunk as an object.  */\n-      zone_set_object_alloc_bit (zone->cached_free);\n-    }\n-\n- found:\n-\n-  /* We could save TYPE in the chunk, but we don't use that for\n-     anything yet.  If we wanted to, we could do it by adding it\n-     either before the beginning of the chunk or after its end,\n-     and adjusting the size and pointer appropriately.  */\n-\n-  /* We'll probably write to this after we return.  */\n-  prefetchw (result);\n-\n-#ifdef ENABLE_GC_CHECKING\n-  /* `Poison' the entire allocated object.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, size));\n-  memset (result, 0xaf, size);\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (result + orig_size,\n-\t\t\t\t\t\tsize - orig_size));\n-#endif\n-\n-  /* Tell Valgrind that the memory is there, but its content isn't\n-     defined.  The bytes at the end of the object are still marked\n-     unaccessible.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, orig_size));\n-\n-  /* Keep track of how many bytes are being allocated.  This\n-     information is used in deciding when to collect.  */\n-  zone->allocated += size;\n-\n-  timevar_ggc_mem_total += size;\n-\n-  if (GATHER_STATISTICS)\n-    ggc_record_overhead (orig_size, size - orig_size, result FINAL_PASS_MEM_STAT);\n-\n-  {\n-    size_t object_size = size;\n-    size_t overhead = object_size - orig_size;\n-\n-    zone->stats.total_overhead += overhead;\n-    zone->stats.total_allocated += object_size;\n-\n-    if (orig_size <= 32)\n-      {\n-\tzone->stats.total_overhead_under32 += overhead;\n-\tzone->stats.total_allocated_under32 += object_size;\n-      }\n-    if (orig_size <= 64)\n-      {\n-\tzone->stats.total_overhead_under64 += overhead;\n-\tzone->stats.total_allocated_under64 += object_size;\n-      }\n-    if (orig_size <= 128)\n-      {\n-\tzone->stats.total_overhead_under128 += overhead;\n-\tzone->stats.total_allocated_under128 += object_size;\n-      }\n-  }\n-#endif\n-\n-  if (GGC_DEBUG_LEVEL >= 3)\n-    fprintf (G.debug_file, \"Allocating object, size=%lu at %p\\n\",\n-\t     (unsigned long) size, result);\n-\n-  return result;\n-}\n-\n-#define ggc_internal_alloc_zone_pass_stat(s,z)          \\\n-    ggc_internal_alloc_zone_stat (s,z PASS_MEM_STAT)\n-\n-void *\n-ggc_internal_cleared_alloc_zone_stat (size_t orig_size,\n-\t\t\t\t      struct alloc_zone *zone MEM_STAT_DECL)\n-{\n-  void * result = ggc_internal_alloc_zone_pass_stat (orig_size, zone);\n-  memset (result, 0, orig_size);\n-  return result;\n-}\n-\n-\n-/* Allocate a SIZE of chunk memory of GTE type, into an appropriate zone\n-   for that type.  */\n-\n-void *\n-ggc_alloc_typed_stat (enum gt_types_enum gte, size_t size\n-\t\t      MEM_STAT_DECL)\n-{\n-  switch (gte)\n-    {\n-    case gt_ggc_e_14lang_tree_node:\n-      return ggc_internal_alloc_zone_pass_stat (size, &tree_zone);\n-\n-    case gt_ggc_e_7rtx_def:\n-      return ggc_internal_alloc_zone_pass_stat (size, &rtl_zone);\n-\n-    case gt_ggc_e_9rtvec_def:\n-      return ggc_internal_alloc_zone_pass_stat (size, &rtl_zone);\n-\n-    default:\n-      return ggc_internal_alloc_zone_pass_stat (size, &main_zone);\n-    }\n-}\n-\n-/* Normal GC allocation simply allocates into the main zone.  */\n-\n-void *\n-ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n-{\n-  return ggc_internal_alloc_zone_pass_stat (size, &main_zone);\n-}\n-\n-/* Poison the chunk.  */\n-#ifdef ENABLE_GC_CHECKING\n-#define poison_region(PTR, SIZE)\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t      \\\n-    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED ((PTR), (SIZE)));   \\\n-    memset ((PTR), 0xa5, (SIZE));\t\t\t\t      \\\n-    VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS ((PTR), (SIZE)));    \\\n-  } while (0)\n-#else\n-#define poison_region(PTR, SIZE)\n-#endif\n-\n-/* Free the object at P.  */\n-\n-void\n-ggc_free (void *p)\n-{\n-  struct page_entry *page;\n-\n-  if (GATHER_STATISTICS)\n-    ggc_free_overhead (p);\n-\n-  poison_region (p, ggc_get_size (p));\n-\n-  page = zone_get_object_page (p);\n-\n-  if (page->large_p)\n-    {\n-      struct large_page_entry *large_page\n-\t= (struct large_page_entry *) page;\n-\n-      /* Remove the page from the linked list.  */\n-      if (large_page->prev)\n-\tlarge_page->prev->next = large_page->next;\n-      else\n-\t{\n-\t  gcc_assert (large_page->common.zone->large_pages == large_page);\n-\t  large_page->common.zone->large_pages = large_page->next;\n-\t}\n-      if (large_page->next)\n-\tlarge_page->next->prev = large_page->prev;\n-\n-      large_page->common.zone->allocated -= large_page->bytes;\n-\n-      /* Release the memory associated with this object.  */\n-      free_large_page (large_page);\n-    }\n-  else if (page->pch_p)\n-    /* Don't do anything.  We won't allocate a new object from the\n-       PCH zone so there's no point in releasing anything.  */\n-    ;\n-  else\n-    {\n-      size_t size = ggc_get_size (p);\n-\n-      page->zone->allocated -= size;\n-\n-      /* Add the chunk to the free list.  We don't bother with coalescing,\n-\t since we are likely to want a chunk of this size again.  */\n-      free_chunk ((char *)p, size, page->zone);\n-    }\n-}\n-\n-/* Mark function for strings.  */\n-\n-void\n-gt_ggc_m_S (const void *p)\n-{\n-  page_entry *entry;\n-  unsigned long offset;\n-\n-  if (!p)\n-    return;\n-\n-  /* Look up the page on which the object is alloced.  .  */\n-  entry = lookup_page_table_if_allocated (p);\n-  if (! entry)\n-    return;\n-\n-  if (entry->pch_p)\n-    {\n-      size_t alloc_word, alloc_bit, t;\n-      t = ((const char *) p - pch_zone.page) / BYTES_PER_ALLOC_BIT;\n-      alloc_word = t / (8 * sizeof (alloc_type));\n-      alloc_bit = t % (8 * sizeof (alloc_type));\n-      offset = zone_find_object_offset (pch_zone.alloc_bits, alloc_word,\n-\t\t\t\t\talloc_bit);\n-    }\n-  else if (entry->large_p)\n-    {\n-      struct large_page_entry *le = (struct large_page_entry *) entry;\n-      offset = ((const char *) p) - entry->page;\n-      gcc_assert (offset < le->bytes);\n-    }\n-  else\n-    {\n-      struct small_page_entry *se = (struct small_page_entry *) entry;\n-      unsigned int start_word = zone_get_object_alloc_word (p);\n-      unsigned int start_bit = zone_get_object_alloc_bit (p);\n-      offset = zone_find_object_offset (se->alloc_bits, start_word, start_bit);\n-\n-      /* On some platforms a char* will not necessarily line up on an\n-\t allocation boundary, so we have to update the offset to\n-\t account for the leftover bytes.  */\n-      offset += (size_t) p % BYTES_PER_ALLOC_BIT;\n-    }\n-\n-  if (offset)\n-    {\n-      /* Here we've seen a char* which does not point to the beginning\n-\t of an allocated object.  We assume it points to the middle of\n-\t a STRING_CST.  */\n-      gcc_assert (offset == offsetof (struct tree_string, str));\n-      p = ((const char *) p) - offset;\n-      gt_ggc_mx_lang_tree_node (CONST_CAST(void *, p));\n-      return;\n-    }\n-\n-  /* Inefficient, but also unlikely to matter.  */\n-  ggc_set_mark (p);\n-}\n-\n-\n-/* User-callable entry points for marking string X.  */\n-\n-void\n-gt_ggc_mx (const char *& x)\n-{\n-  gt_ggc_m_S (x);\n-}\n-\n-void\n-gt_ggc_mx (unsigned char *& x)\n-{\n-  gt_ggc_m_S (x);\n-}\n-\n-void\n-gt_ggc_mx (unsigned char& x ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* If P is not marked, mark it and return false.  Otherwise return true.\n-   P must have been allocated by the GC allocator; it mustn't point to\n-   static objects, stack variables, or memory allocated with malloc.  */\n-\n-int\n-ggc_set_mark (const void *p)\n-{\n-  struct page_entry *page;\n-  const char *ptr = (const char *) p;\n-\n-  page = zone_get_object_page (p);\n-\n-  if (page->pch_p)\n-    {\n-      size_t mark_word, mark_bit, offset;\n-      offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n-      mark_word = offset / (8 * sizeof (mark_type));\n-      mark_bit = offset % (8 * sizeof (mark_type));\n-\n-      if (pch_zone.mark_bits[mark_word] & (1 << mark_bit))\n-\treturn 1;\n-      pch_zone.mark_bits[mark_word] |= (1 << mark_bit);\n-    }\n-  else if (page->large_p)\n-    {\n-      struct large_page_entry *large_page\n-\t= (struct large_page_entry *) page;\n-\n-      if (large_page->mark_p)\n-\treturn 1;\n-      large_page->mark_p = true;\n-    }\n-  else\n-    {\n-      struct small_page_entry *small_page\n-\t= (struct small_page_entry *) page;\n-\n-      if (small_page->mark_bits[zone_get_object_mark_word (p)]\n-\t  & (1 << zone_get_object_mark_bit (p)))\n-\treturn 1;\n-      small_page->mark_bits[zone_get_object_mark_word (p)]\n-\t|= (1 << zone_get_object_mark_bit (p));\n-    }\n-\n-  if (GGC_DEBUG_LEVEL >= 4)\n-    fprintf (G.debug_file, \"Marking %p\\n\", p);\n-\n-  return 0;\n-}\n-\n-/* Return 1 if P has been marked, zero otherwise.\n-   P must have been allocated by the GC allocator; it mustn't point to\n-   static objects, stack variables, or memory allocated with malloc.  */\n-\n-int\n-ggc_marked_p (const void *p)\n-{\n-  struct page_entry *page;\n-  const char *ptr = (const char *) p;\n-\n-  page = zone_get_object_page (p);\n-\n-  if (page->pch_p)\n-    {\n-      size_t mark_word, mark_bit, offset;\n-      offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n-      mark_word = offset / (8 * sizeof (mark_type));\n-      mark_bit = offset % (8 * sizeof (mark_type));\n-\n-      return (pch_zone.mark_bits[mark_word] & (1 << mark_bit)) != 0;\n-    }\n-\n-  if (page->large_p)\n-    {\n-      struct large_page_entry *large_page\n-\t= (struct large_page_entry *) page;\n-\n-      return large_page->mark_p;\n-    }\n-  else\n-    {\n-      struct small_page_entry *small_page\n-\t= (struct small_page_entry *) page;\n-\n-      return 0 != (small_page->mark_bits[zone_get_object_mark_word (p)]\n-\t\t   & (1 << zone_get_object_mark_bit (p)));\n-    }\n-}\n-\n-/* Return the size of the gc-able object P.  */\n-\n-size_t\n-ggc_get_size (const void *p)\n-{\n-  struct page_entry *page;\n-  const char *ptr = (const char *) p;\n-\n-  page = zone_get_object_page (p);\n-\n-  if (page->pch_p)\n-    {\n-      size_t alloc_word, alloc_bit, offset, max_size;\n-      offset = (ptr - pch_zone.page) / BYTES_PER_ALLOC_BIT + 1;\n-      alloc_word = offset / (8 * sizeof (alloc_type));\n-      alloc_bit = offset % (8 * sizeof (alloc_type));\n-      max_size = pch_zone.bytes - (ptr - pch_zone.page);\n-      return zone_object_size_1 (pch_zone.alloc_bits, alloc_word, alloc_bit,\n-\t\t\t\t max_size);\n-    }\n-\n-  if (page->large_p)\n-    return ((struct large_page_entry *)page)->bytes;\n-  else\n-    return zone_find_object_size ((struct small_page_entry *) page, p);\n-}\n-\n-/* Initialize the ggc-zone-mmap allocator.  */\n-void\n-init_ggc (void)\n-{\n-  /* The allocation size must be greater than BYTES_PER_MARK_BIT, and\n-     a multiple of both BYTES_PER_ALLOC_BIT and FREE_BIN_DELTA, for\n-     the current assumptions to hold.  */\n-\n-  gcc_assert (FREE_BIN_DELTA == MAX_ALIGNMENT);\n-\n-  /* Set up the main zone by hand.  */\n-  main_zone.name = \"Main zone\";\n-  G.zones = &main_zone;\n-\n-  /* Allocate the default zones.  */\n-  new_ggc_zone_1 (&rtl_zone, \"RTL zone\");\n-  new_ggc_zone_1 (&tree_zone, \"Tree zone\");\n-  new_ggc_zone_1 (&tree_id_zone, \"Tree identifier zone\");\n-\n-  G.pagesize = getpagesize();\n-  G.lg_pagesize = exact_log2 (G.pagesize);\n-  G.page_mask = ~(G.pagesize - 1);\n-\n-  /* Require the system page size to be a multiple of GGC_PAGE_SIZE.  */\n-  gcc_assert ((G.pagesize & (GGC_PAGE_SIZE - 1)) == 0);\n-\n-  /* Allocate 16 system pages at a time.  */\n-  G.quire_size = 16 * G.pagesize / GGC_PAGE_SIZE;\n-\n-  /* Calculate the size of the allocation bitmap and other overhead.  */\n-  /* Right now we allocate bits for the page header and bitmap.  These\n-     are wasted, but a little tricky to eliminate.  */\n-  G.small_page_overhead\n-    = PAGE_OVERHEAD + (GGC_PAGE_SIZE / BYTES_PER_ALLOC_BIT / 8);\n-  /* G.small_page_overhead = ROUND_UP (G.small_page_overhead, MAX_ALIGNMENT); */\n-\n-#ifdef HAVE_MMAP_DEV_ZERO\n-  G.dev_zero_fd = open (\"/dev/zero\", O_RDONLY);\n-  gcc_assert (G.dev_zero_fd != -1);\n-#endif\n-\n-#if 0\n-  G.debug_file = fopen (\"ggc-mmap.debug\", \"w\");\n-  setlinebuf (G.debug_file);\n-#else\n-  G.debug_file = stdout;\n-#endif\n-\n-#ifdef USING_MMAP\n-  /* StunOS has an amazing off-by-one error for the first mmap allocation\n-     after fiddling with RLIMIT_STACK.  The result, as hard as it is to\n-     believe, is an unaligned page allocation, which would cause us to\n-     hork badly if we tried to use it.  */\n-  {\n-    char *p = alloc_anon (NULL, G.pagesize, &main_zone);\n-    struct small_page_entry *e;\n-    if ((size_t)p & (G.pagesize - 1))\n-      {\n-\t/* How losing.  Discard this one and try another.  If we still\n-\t   can't get something useful, give up.  */\n-\n-\tp = alloc_anon (NULL, G.pagesize, &main_zone);\n-\tgcc_assert (!((size_t)p & (G.pagesize - 1)));\n-      }\n-\n-    if (GGC_PAGE_SIZE == G.pagesize)\n-      {\n-\t/* We have a good page, might as well hold onto it...  */\n-\te = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n-\te->common.page = p;\n-\te->common.zone = &main_zone;\n-\te->next = main_zone.free_pages;\n-\tset_page_table_entry (e->common.page, &e->common);\n-\tmain_zone.free_pages = e;\n-      }\n-    else\n-      {\n-\tmunmap (p, G.pagesize);\n-      }\n-  }\n-#endif\n-}\n-\n-/* Start a new GGC zone.  */\n-\n-static void\n-new_ggc_zone_1 (struct alloc_zone *new_zone, const char * name)\n-{\n-  new_zone->name = name;\n-  new_zone->next_zone = G.zones->next_zone;\n-  G.zones->next_zone = new_zone;\n-}\n-\n-/* Free all empty pages and objects within a page for a given zone  */\n-\n-static void\n-sweep_pages (struct alloc_zone *zone)\n-{\n-  struct large_page_entry **lpp, *lp, *lnext;\n-  struct small_page_entry **spp, *sp, *snext;\n-  char *last_free;\n-  size_t allocated = 0;\n-  bool nomarksinpage;\n-\n-  /* First, reset the free_chunks lists, since we are going to\n-     re-free free chunks in hopes of coalescing them into large chunks.  */\n-  memset (zone->free_chunks, 0, sizeof (zone->free_chunks));\n-  zone->high_free_bin = 0;\n-  zone->cached_free = NULL;\n-  zone->cached_free_size = 0;\n-\n-  /* Large pages are all or none affairs. Either they are completely\n-     empty, or they are completely full.  */\n-  lpp = &zone->large_pages;\n-  for (lp = zone->large_pages; lp != NULL; lp = lnext)\n-    {\n-      gcc_assert (lp->common.large_p);\n-\n-      lnext = lp->next;\n-\n-      /* This page has now survived another collection.  */\n-      lp->common.survived++;\n-\n-      if (lp->mark_p)\n-\t{\n-\t  lp->mark_p = false;\n-\t  allocated += lp->bytes;\n-\t  lpp = &lp->next;\n-\t}\n-      else\n-\t{\n-\t  *lpp = lnext;\n-#ifdef ENABLE_GC_CHECKING\n-\t  /* Poison the page.  */\n-\t  memset (lp->common.page, 0xb5, SMALL_PAGE_SIZE);\n-#endif\n-\t  if (lp->prev)\n-\t    lp->prev->next = lp->next;\n-\t  if (lp->next)\n-\t    lp->next->prev = lp->prev;\n-\t  free_large_page (lp);\n-\t}\n-    }\n-\n-  spp = &zone->pages;\n-  for (sp = zone->pages; sp != NULL; sp = snext)\n-    {\n-      char *object, *last_object;\n-      char *end;\n-      alloc_type *alloc_word_p;\n-      mark_type *mark_word_p;\n-\n-      gcc_assert (!sp->common.large_p);\n-\n-      snext = sp->next;\n-\n-      /* This page has now survived another collection.  */\n-      sp->common.survived++;\n-\n-      /* Step through all chunks, consolidate those that are free and\n-\t insert them into the free lists.  Note that consolidation\n-\t slows down collection slightly.  */\n-\n-      last_object = object = sp->common.page;\n-      end = sp->common.page + SMALL_PAGE_SIZE;\n-      last_free = NULL;\n-      nomarksinpage = true;\n-      mark_word_p = sp->mark_bits;\n-      alloc_word_p = sp->alloc_bits;\n-\n-      gcc_assert (BYTES_PER_ALLOC_BIT == BYTES_PER_MARK_BIT);\n-\n-      object = sp->common.page;\n-      do\n-\t{\n-\t  unsigned int i, n;\n-\t  alloc_type alloc_word;\n-\t  mark_type mark_word;\n-\n-\t  alloc_word = *alloc_word_p++;\n-\t  mark_word = *mark_word_p++;\n-\n-\t  if (mark_word)\n-\t    nomarksinpage = false;\n-\n-\t  /* There ought to be some way to do this without looping...  */\n-\t  i = 0;\n-\t  while ((n = alloc_ffs (alloc_word)) != 0)\n-\t    {\n-\t      /* Extend the current state for n - 1 bits.  We can't\n-\t\t shift alloc_word by n, even though it isn't used in the\n-\t\t loop, in case only the highest bit was set.  */\n-\t      alloc_word >>= n - 1;\n-\t      mark_word >>= n - 1;\n-\t      object += BYTES_PER_MARK_BIT * (n - 1);\n-\n-\t      if (mark_word & 1)\n-\t\t{\n-\t\t  if (last_free)\n-\t\t    {\n-\t\t      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (last_free,\n-\t\t\t\t\t\t\t\t     object\n-\t\t\t\t\t\t\t\t     - last_free));\n-\t\t      poison_region (last_free, object - last_free);\n-\t\t      free_chunk (last_free, object - last_free, zone);\n-\t\t      last_free = NULL;\n-\t\t    }\n-\t\t  else\n-\t\t    allocated += object - last_object;\n-\t\t  last_object = object;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (last_free == NULL)\n-\t\t    {\n-\t\t      last_free = object;\n-\t\t      allocated += object - last_object;\n-\t\t    }\n-\t\t  else\n-\t\t    zone_clear_object_alloc_bit (sp, object);\n-\t\t}\n-\n-\t      /* Shift to just after the alloc bit we handled.  */\n-\t      alloc_word >>= 1;\n-\t      mark_word >>= 1;\n-\t      object += BYTES_PER_MARK_BIT;\n-\n-\t      i += n;\n-\t    }\n-\n-\t  object += BYTES_PER_MARK_BIT * (8 * sizeof (alloc_type) - i);\n-\t}\n-      while (object < end);\n-\n-      if (nomarksinpage)\n-\t{\n-\t  *spp = snext;\n-#ifdef ENABLE_GC_CHECKING\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (sp->common.page,\n-\t\t\t\t\t\t\t SMALL_PAGE_SIZE));\n-\t  /* Poison the page.  */\n-\t  memset (sp->common.page, 0xb5, SMALL_PAGE_SIZE);\n-#endif\n-\t  free_small_page (sp);\n-\t  continue;\n-\t}\n-      else if (last_free)\n-\t{\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (last_free,\n-\t\t\t\t\t\t\t object - last_free));\n-\t  poison_region (last_free, object - last_free);\n-\t  free_chunk (last_free, object - last_free, zone);\n-\t}\n-      else\n-\tallocated += object - last_object;\n-\n-      spp = &sp->next;\n-    }\n-\n-  zone->allocated = allocated;\n-}\n-\n-/* mark-and-sweep routine for collecting a single zone.  NEED_MARKING\n-   is true if we need to mark before sweeping, false if some other\n-   zone collection has already performed marking for us.  Returns true\n-   if we collected, false otherwise.  */\n-\n-static bool\n-ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n-{\n-#if 0\n-  /* */\n-  {\n-    int i;\n-    for (i = 0; i < NUM_FREE_BINS + 1; i++)\n-      {\n-\tstruct alloc_chunk *chunk;\n-\tint n, tot;\n-\n-\tn = 0;\n-\ttot = 0;\n-\tchunk = zone->free_chunks[i];\n-\twhile (chunk)\n-\t  {\n-\t    n++;\n-\t    tot += chunk->size;\n-\t    chunk = chunk->next_free;\n-\t  }\n-\tfprintf (stderr, \"Bin %d: %d free chunks (%d bytes)\\n\",\n-\t\t i, n, tot);\n-      }\n-  }\n-  /* */\n-#endif\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \" {%s GC %luk -> \",\n-\t     zone->name, (unsigned long) zone->allocated / 1024);\n-\n-  /* Zero the total allocated bytes.  This will be recalculated in the\n-     sweep phase.  */\n-  zone->allocated = 0;\n-\n-  /* Release the pages we freed the last time we collected, but didn't\n-     reuse in the interim.  */\n-  release_pages (zone);\n-\n-  if (need_marking)\n-    {\n-      zone_allocate_marks ();\n-      ggc_mark_roots ();\n-      if (GATHER_STATISTICS)\n-\tggc_prune_overhead_list ();\n-    }\n-\n-  sweep_pages (zone);\n-  zone->was_collected = true;\n-  zone->allocated_last_gc = zone->allocated;\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"%luk}\", (unsigned long) zone->allocated / 1024);\n-  return true;\n-}\n-\n-/* Calculate the average page survival rate in terms of number of\n-   collections.  */\n-\n-static float\n-calculate_average_page_survival (struct alloc_zone *zone)\n-{\n-  float count = 0.0;\n-  float survival = 0.0;\n-  struct small_page_entry *p;\n-  struct large_page_entry *lp;\n-  for (p = zone->pages; p; p = p->next)\n-    {\n-      count += 1.0;\n-      survival += p->common.survived;\n-    }\n-  for (lp = zone->large_pages; lp; lp = lp->next)\n-    {\n-      count += 1.0;\n-      survival += lp->common.survived;\n-    }\n-  return survival/count;\n-}\n-\n-/* Top level collection routine.  */\n-\n-void\n-ggc_collect (void)\n-{\n-  struct alloc_zone *zone;\n-  bool marked = false;\n-\n-  timevar_push (TV_GC);\n-\n-  if (!ggc_force_collect)\n-    {\n-      float allocated_last_gc = 0, allocated = 0, min_expand;\n-\n-      for (zone = G.zones; zone; zone = zone->next_zone)\n-\t{\n-\t  allocated_last_gc += zone->allocated_last_gc;\n-\t  allocated += zone->allocated;\n-\t}\n-\n-      allocated_last_gc =\n-\tMAX (allocated_last_gc,\n-\t     (size_t) PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n-      min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n-\n-      if (allocated < allocated_last_gc + min_expand)\n-\t{\n-\t  timevar_pop (TV_GC);\n-\t  return;\n-\t}\n-    }\n-\n-  invoke_plugin_callbacks (PLUGIN_GGC_START, NULL);\n-\n-  /* Start by possibly collecting the main zone.  */\n-  main_zone.was_collected = false;\n-  marked |= ggc_collect_1 (&main_zone, true);\n-\n-  /* In order to keep the number of collections down, we don't\n-     collect other zones unless we are collecting the main zone.  This\n-     gives us roughly the same number of collections as we used to\n-     have with the old gc.  The number of collection is important\n-     because our main slowdown (according to profiling) is now in\n-     marking.  So if we mark twice as often as we used to, we'll be\n-     twice as slow.  Hopefully we'll avoid this cost when we mark\n-     zone-at-a-time.  */\n-  /* NOTE drow/2004-07-28: We now always collect the main zone, but\n-     keep this code in case the heuristics are further refined.  */\n-\n-  if (main_zone.was_collected)\n-    {\n-      struct alloc_zone *zone;\n-\n-      for (zone = main_zone.next_zone; zone; zone = zone->next_zone)\n-\t{\n-\t  zone->was_collected = false;\n-\t  marked |= ggc_collect_1 (zone, !marked);\n-\t}\n-    }\n-\n-  /* Print page survival stats, if someone wants them.  */\n-  if (GATHER_STATISTICS && GGC_DEBUG_LEVEL >= 2)\n-    {\n-      for (zone = G.zones; zone; zone = zone->next_zone)\n-\t{\n-\t  if (zone->was_collected)\n-\t    {\n-\t      float f = calculate_average_page_survival (zone);\n-\t      printf (\"Average page survival in zone `%s' is %f\\n\",\n-\t\t      zone->name, f);\n-\t    }\n-\t}\n-    }\n-\n-  if (marked)\n-    zone_free_marks ();\n-\n-  /* Free dead zones.  */\n-  for (zone = G.zones; zone && zone->next_zone; zone = zone->next_zone)\n-    {\n-      if (zone->next_zone->dead)\n-\t{\n-\t  struct alloc_zone *dead_zone = zone->next_zone;\n-\n-\t  printf (\"Zone `%s' is dead and will be freed.\\n\", dead_zone->name);\n-\n-\t  /* The zone must be empty.  */\n-\t  gcc_assert (!dead_zone->allocated);\n-\n-\t  /* Unchain the dead zone, release all its pages and free it.  */\n-\t  zone->next_zone = zone->next_zone->next_zone;\n-\t  release_pages (dead_zone);\n-\t  free (dead_zone);\n-\t}\n-    }\n-\n-  invoke_plugin_callbacks (PLUGIN_GGC_END, NULL);\n-\n-  timevar_pop (TV_GC);\n-}\n-\n-/* Print allocation statistics.  */\n-#define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n-\t\t  ? (x) \\\n-\t\t  : ((x) < 1024*1024*10 \\\n-\t\t     ? (x) / 1024 \\\n-\t\t     : (x) / (1024*1024))))\n-#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n-\n-void\n-ggc_print_statistics (void)\n-{\n-  struct alloc_zone *zone;\n-  struct ggc_statistics stats;\n-  size_t total_overhead = 0, total_allocated = 0, total_bytes_mapped = 0;\n-  size_t pte_overhead, i;\n-\n-  /* Clear the statistics.  */\n-  memset (&stats, 0, sizeof (stats));\n-\n-  /* Make sure collection will really occur.  */\n-  ggc_force_collect = true;\n-\n-  /* Collect and print the statistics common across collectors.  */\n-  ggc_print_common_statistics (stderr, &stats);\n-\n-  ggc_force_collect = false;\n-\n-  /* Release free pages so that we will not count the bytes allocated\n-     there as part of the total allocated memory.  */\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    release_pages (zone);\n-\n-  /* Collect some information about the various sizes of\n-     allocation.  */\n-  fprintf (stderr,\n-           \"Memory still allocated at the end of the compilation process\\n\");\n-\n-  fprintf (stderr, \"%20s %10s  %10s  %10s\\n\",\n-\t   \"Zone\", \"Allocated\", \"Used\", \"Overhead\");\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    {\n-      struct large_page_entry *large_page;\n-      size_t overhead, allocated, in_use;\n-\n-      /* Skip empty zones.  */\n-      if (!zone->pages && !zone->large_pages)\n-\tcontinue;\n-\n-      allocated = in_use = 0;\n-\n-      overhead = sizeof (struct alloc_zone);\n-\n-      for (large_page = zone->large_pages; large_page != NULL;\n-\t   large_page = large_page->next)\n-\t{\n-\t  allocated += large_page->bytes;\n-\t  in_use += large_page->bytes;\n-\t  overhead += sizeof (struct large_page_entry);\n-\t}\n-\n-      /* There's no easy way to walk through the small pages finding\n-\t used and unused objects.  Instead, add all the pages, and\n-\t subtract out the free list.  */\n-\n-      allocated += GGC_PAGE_SIZE * zone->n_small_pages;\n-      in_use += GGC_PAGE_SIZE * zone->n_small_pages;\n-      overhead += G.small_page_overhead * zone->n_small_pages;\n-\n-      for (i = 0; i <= NUM_FREE_BINS; i++)\n-\t{\n-\t  struct alloc_chunk *chunk = zone->free_chunks[i];\n-\t  while (chunk)\n-\t    {\n-\t      in_use -= ggc_get_size (chunk);\n-\t      chunk = chunk->next_free;\n-\t    }\n-\t}\n-\n-      fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\",\n-\t       zone->name,\n-\t       SCALE (allocated), LABEL (allocated),\n-\t       SCALE (in_use), LABEL (in_use),\n-\t       SCALE (overhead), LABEL (overhead));\n-\n-      gcc_assert (in_use == zone->allocated);\n-\n-      total_overhead += overhead;\n-      total_allocated += zone->allocated;\n-      total_bytes_mapped += zone->bytes_mapped;\n-    }\n-\n-  /* Count the size of the page table as best we can.  */\n-#if HOST_BITS_PER_PTR <= 32\n-  pte_overhead = sizeof (G.lookup);\n-  for (i = 0; i < PAGE_L1_SIZE; i++)\n-    if (G.lookup[i])\n-      pte_overhead += PAGE_L2_SIZE * sizeof (struct page_entry *);\n-#else\n-  {\n-    page_table table = G.lookup;\n-    pte_overhead = 0;\n-    while (table)\n-      {\n-\tpte_overhead += sizeof (*table);\n-\tfor (i = 0; i < PAGE_L1_SIZE; i++)\n-\t  if (table->table[i])\n-\t    pte_overhead += PAGE_L2_SIZE * sizeof (struct page_entry *);\n-\ttable = table->next;\n-      }\n-  }\n-#endif\n-  fprintf (stderr, \"%20s %11s %11s %10lu%c\\n\", \"Page Table\",\n-\t   \"\", \"\", SCALE (pte_overhead), LABEL (pte_overhead));\n-  total_overhead += pte_overhead;\n-\n-  fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\", \"Total\",\n-\t   SCALE (total_bytes_mapped), LABEL (total_bytes_mapped),\n-\t   SCALE (total_allocated), LABEL(total_allocated),\n-\t   SCALE (total_overhead), LABEL (total_overhead));\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      unsigned long long all_overhead = 0, all_allocated = 0;\n-      unsigned long long all_overhead_under32 = 0, all_allocated_under32 = 0;\n-      unsigned long long all_overhead_under64 = 0, all_allocated_under64 = 0;\n-      unsigned long long all_overhead_under128 = 0, all_allocated_under128 = 0;\n-\n-      fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n-\n-      for (zone = G.zones; zone; zone = zone->next_zone)\n-\t{\n-\t  all_overhead += zone->stats.total_overhead;\n-\t  all_allocated += zone->stats.total_allocated;\n-\n-\t  all_allocated_under32 += zone->stats.total_allocated_under32;\n-\t  all_overhead_under32 += zone->stats.total_overhead_under32;\n-\n-\t  all_allocated_under64 += zone->stats.total_allocated_under64;\n-\t  all_overhead_under64 += zone->stats.total_overhead_under64;\n-\n-\t  all_allocated_under128 += zone->stats.total_allocated_under128;\n-\t  all_overhead_under128 += zone->stats.total_overhead_under128;\n-\n-\t  fprintf (stderr, \"%20s:                  %10lld\\n\",\n-\t\t   zone->name, zone->stats.total_allocated);\n-\t}\n-\n-      fprintf (stderr, \"\\n\");\n-\n-      fprintf (stderr, \"Total Overhead:                        %10lld\\n\",\n-\t       all_overhead);\n-      fprintf (stderr, \"Total Allocated:                       %10lld\\n\",\n-\t       all_allocated);\n-\n-      fprintf (stderr, \"Total Overhead  under  32B:            %10lld\\n\",\n-\t       all_overhead_under32);\n-      fprintf (stderr, \"Total Allocated under  32B:            %10lld\\n\",\n-\t       all_allocated_under32);\n-      fprintf (stderr, \"Total Overhead  under  64B:            %10lld\\n\",\n-\t       all_overhead_under64);\n-      fprintf (stderr, \"Total Allocated under  64B:            %10lld\\n\",\n-\t       all_allocated_under64);\n-      fprintf (stderr, \"Total Overhead  under 128B:            %10lld\\n\",\n-\t       all_overhead_under128);\n-      fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n-\t       all_allocated_under128);\n-    }\n-}\n-\n-/* Precompiled header support.  */\n-\n-/* For precompiled headers, we sort objects based on their type.  We\n-   also sort various objects into their own buckets; currently this\n-   covers strings and IDENTIFIER_NODE trees.  The choices of how\n-   to sort buckets have not yet been tuned.  */\n-\n-#define NUM_PCH_BUCKETS\t\t(gt_types_enum_last + 3)\n-\n-#define OTHER_BUCKET\t\t(gt_types_enum_last + 0)\n-#define IDENTIFIER_BUCKET\t(gt_types_enum_last + 1)\n-#define STRING_BUCKET\t\t(gt_types_enum_last + 2)\n-\n-struct ggc_pch_ondisk\n-{\n-  size_t total;\n-  size_t type_totals[NUM_PCH_BUCKETS];\n-};\n-\n-struct ggc_pch_data\n-{\n-  struct ggc_pch_ondisk d;\n-  size_t base;\n-  size_t orig_base;\n-  size_t alloc_size;\n-  alloc_type *alloc_bits;\n-  size_t type_bases[NUM_PCH_BUCKETS];\n-  size_t start_offset;\n-};\n-\n-/* Initialize the PCH data structure.  */\n-\n-struct ggc_pch_data *\n-init_ggc_pch (void)\n-{\n-  return XCNEW (struct ggc_pch_data);\n-}\n-\n-/* Return which of the page-aligned buckets the object at X, with type\n-   TYPE, should be sorted into in the PCH.  Strings will have\n-   IS_STRING set and TYPE will be gt_types_enum_last.  Other objects\n-   of unknown type will also have TYPE equal to gt_types_enum_last.  */\n-\n-static int\n-pch_bucket (void *x, enum gt_types_enum type,\n-\t    bool is_string)\n-{\n-  /* Sort identifiers into their own bucket, to improve locality\n-     when searching the identifier hash table.  */\n-  if (type == gt_ggc_e_14lang_tree_node\n-      && TREE_CODE ((tree) x) == IDENTIFIER_NODE)\n-    return IDENTIFIER_BUCKET;\n-  else if (type == gt_types_enum_last)\n-    {\n-      if (is_string)\n-\treturn STRING_BUCKET;\n-      return OTHER_BUCKET;\n-    }\n-  return type;\n-}\n-\n-/* Add the size of object X to the size of the PCH data.  */\n-\n-void\n-ggc_pch_count_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size, bool is_string, enum gt_types_enum type)\n-{\n-  /* NOTE: Right now we don't need to align up the size of any objects.\n-     Strings can be unaligned, and everything else is allocated to a\n-     MAX_ALIGNMENT boundary already.  */\n-\n-  d->d.type_totals[pch_bucket (x, type, is_string)] += size;\n-}\n-\n-/* Return the total size of the PCH data.  */\n-\n-size_t\n-ggc_pch_total_size (struct ggc_pch_data *d)\n-{\n-  int i;\n-  size_t alloc_size, total_size;\n-\n-  total_size = 0;\n-  for (i = 0; i < NUM_PCH_BUCKETS; i++)\n-    {\n-      d->d.type_totals[i] = ROUND_UP (d->d.type_totals[i], GGC_PAGE_SIZE);\n-      total_size += d->d.type_totals[i];\n-    }\n-  d->d.total = total_size;\n-\n-  /* Include the size of the allocation bitmap.  */\n-  alloc_size = CEIL (d->d.total, BYTES_PER_ALLOC_BIT * 8);\n-  alloc_size = ROUND_UP (alloc_size, MAX_ALIGNMENT);\n-  d->alloc_size = alloc_size;\n-\n-  return d->d.total + alloc_size;\n-}\n-\n-/* Set the base address for the objects in the PCH file.  */\n-\n-void\n-ggc_pch_this_base (struct ggc_pch_data *d, void *base_)\n-{\n-  int i;\n-  size_t base = (size_t) base_;\n-\n-  d->base = d->orig_base = base;\n-  for (i = 0; i < NUM_PCH_BUCKETS; i++)\n-    {\n-      d->type_bases[i] = base;\n-      base += d->d.type_totals[i];\n-    }\n-\n-  if (d->alloc_bits == NULL)\n-    d->alloc_bits = XCNEWVAR (alloc_type, d->alloc_size);\n-}\n-\n-/* Allocate a place for object X of size SIZE in the PCH file.  */\n-\n-char *\n-ggc_pch_alloc_object (struct ggc_pch_data *d, void *x,\n-\t\t      size_t size, bool is_string,\n-\t\t      enum gt_types_enum type)\n-{\n-  size_t alloc_word, alloc_bit;\n-  char *result;\n-  int bucket = pch_bucket (x, type, is_string);\n-\n-  /* Record the start of the object in the allocation bitmap.  We\n-     can't assert that the allocation bit is previously clear, because\n-     strings may violate the invariant that they are at least\n-     BYTES_PER_ALLOC_BIT long.  This is harmless - ggc_get_size\n-     should not be called for strings.  */\n-  alloc_word = ((d->type_bases[bucket] - d->orig_base)\n-\t\t/ (8 * sizeof (alloc_type) * BYTES_PER_ALLOC_BIT));\n-  alloc_bit = ((d->type_bases[bucket] - d->orig_base)\n-\t       / BYTES_PER_ALLOC_BIT) % (8 * sizeof (alloc_type));\n-  d->alloc_bits[alloc_word] |= 1L << alloc_bit;\n-\n-  /* Place the object at the current pointer for this bucket.  */\n-  result = (char *) d->type_bases[bucket];\n-  d->type_bases[bucket] += size;\n-  return result;\n-}\n-\n-/* Prepare to write out the PCH data to file F.  */\n-\n-void\n-ggc_pch_prepare_write (struct ggc_pch_data *d,\n-\t\t       FILE *f)\n-{\n-  /* We seek around a lot while writing.  Record where the end\n-     of the padding in the PCH file is, so that we can\n-     locate each object's offset.  */\n-  d->start_offset = ftell (f);\n-}\n-\n-/* Write out object X of SIZE to file F.  */\n-\n-void\n-ggc_pch_write_object (struct ggc_pch_data *d,\n-\t\t      FILE *f, void *x, void *newx,\n-\t\t      size_t size, bool is_string ATTRIBUTE_UNUSED)\n-{\n-  if (fseek (f, (size_t) newx - d->orig_base + d->start_offset, SEEK_SET) != 0)\n-    fatal_error (\"can%'t seek PCH file: %m\");\n-\n-  if (fwrite (x, size, 1, f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n-}\n-\n-void\n-ggc_pch_finish (struct ggc_pch_data *d, FILE *f)\n-{\n-  /* Write out the allocation bitmap.  */\n-  if (fseek (f, d->start_offset + d->d.total, SEEK_SET) != 0)\n-    fatal_error (\"can%'t seek PCH file: %m\");\n-\n-  if (fwrite (d->alloc_bits, d->alloc_size, 1, f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n-\n-  /* Done with the PCH, so write out our footer.  */\n-  if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n-\n-  free (d->alloc_bits);\n-  free (d);\n-}\n-\n-/* The PCH file from F has been mapped at ADDR.  Read in any\n-   additional data from the file and set up the GC state.  */\n-\n-void\n-ggc_pch_read (FILE *f, void *addr)\n-{\n-  struct ggc_pch_ondisk d;\n-  size_t alloc_size;\n-  struct alloc_zone *zone;\n-  struct page_entry *pch_page;\n-  char *p;\n-\n-  if (fread (&d, sizeof (d), 1, f) != 1)\n-    fatal_error (\"can%'t read PCH file: %m\");\n-\n-  alloc_size = CEIL (d.total, BYTES_PER_ALLOC_BIT * 8);\n-  alloc_size = ROUND_UP (alloc_size, MAX_ALIGNMENT);\n-\n-  pch_zone.bytes = d.total;\n-  pch_zone.alloc_bits = (alloc_type *) ((char *) addr + pch_zone.bytes);\n-  pch_zone.page = (char *) addr;\n-  pch_zone.end = (char *) pch_zone.alloc_bits;\n-\n-  if (GATHER_STATISTICS)\n-    {\n-      /* We've just read in a PCH file.  So, every object that used to be\n-\t allocated is now free.  */\n-      zone_allocate_marks ();\n-      ggc_prune_overhead_list ();\n-      zone_free_marks ();\n-    }\n-\n-  for (zone = G.zones; zone; zone = zone->next_zone)\n-    {\n-      struct small_page_entry *page, *next_page;\n-      struct large_page_entry *large_page, *next_large_page;\n-\n-      zone->allocated = 0;\n-\n-      /* Clear the zone's free chunk list.  */\n-      memset (zone->free_chunks, 0, sizeof (zone->free_chunks));\n-      zone->high_free_bin = 0;\n-      zone->cached_free = NULL;\n-      zone->cached_free_size = 0;\n-\n-      /* Move all the small pages onto the free list.  */\n-      for (page = zone->pages; page != NULL; page = next_page)\n-\t{\n-\t  next_page = page->next;\n-\t  memset (page->alloc_bits, 0,\n-\t\t  G.small_page_overhead - PAGE_OVERHEAD);\n-\t  free_small_page (page);\n-\t}\n-\n-      /* Discard all the large pages.  */\n-      for (large_page = zone->large_pages; large_page != NULL;\n-\t   large_page = next_large_page)\n-\t{\n-\t  next_large_page = large_page->next;\n-\t  free_large_page (large_page);\n-\t}\n-\n-      zone->pages = NULL;\n-      zone->large_pages = NULL;\n-    }\n-\n-  /* Allocate the dummy page entry for the PCH, and set all pages\n-     mapped into the PCH to reference it.  */\n-  pch_page = XCNEW (struct page_entry);\n-  pch_page->page = pch_zone.page;\n-  pch_page->pch_p = true;\n-\n-  for (p = pch_zone.page; p < pch_zone.end; p += GGC_PAGE_SIZE)\n-    set_page_table_entry (p, pch_page);\n-}"}, {"sha": "b31bc80489f2a50aed4b110d4c7035805000b924", "filename": "gcc/ggc.h", "status": "modified", "additions": 11, "deletions": 91, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -48,8 +48,7 @@ typedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,\n \t\t\t\t   void *);\n \n /* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\n-extern int gt_pch_note_object (void *, void *, gt_note_pointers,\n-\t\t\t       enum gt_types_enum = gt_types_enum_last);\n+extern int gt_pch_note_object (void *, void *, gt_note_pointers);\n \n /* Used by the gt_pch_n_* routines.  Register that an object has a reorder\n    function.  */\n@@ -118,8 +117,6 @@ extern void gt_ggc_m_S (const void *);\n \n /* End of GTY machinery API.  */\n \n-struct alloc_zone;\n-\n /* Initialize the string pool.  */\n extern void init_stringpool (void);\n \n@@ -146,12 +143,6 @@ extern size_t ggc_round_alloc_size (size_t requested_size);\n \n #define ggc_internal_alloc(s) ggc_internal_alloc_stat (s MEM_STAT_INFO)\n \n-/* Allocate an object of the specified type and size.  */\n-extern void *ggc_alloc_typed_stat (enum gt_types_enum, size_t MEM_STAT_DECL)\n-  ATTRIBUTE_MALLOC;\n-\n-#define ggc_alloc_typed(s, z) ggc_alloc_typed_stat (s, z MEM_STAT_INFO)\n-\n /* Allocates cleared memory.  */\n extern void *ggc_internal_cleared_alloc_stat (size_t MEM_STAT_DECL)\n   ATTRIBUTE_MALLOC;\n@@ -213,7 +204,7 @@ extern void *ggc_cleared_alloc_ptr_array_two_args (size_t, size_t)\n   splay_tree_new_typed_alloc (COMPARE, NULL, NULL, &ALLOC_TREE, &ALLOC_NODE, \\\n \t\t\t      &ggc_splay_dont_free, NULL)\n \n-extern void *ggc_splay_alloc (enum gt_types_enum, int, void *)\n+extern void *ggc_splay_alloc (int, void *)\n   ATTRIBUTE_MALLOC;\n \n extern void ggc_splay_dont_free (void *, void *);\n@@ -254,99 +245,28 @@ extern void stringpool_statistics (void);\n /* Heuristics.  */\n extern void init_ggc_heuristics (void);\n \n-/* Zone collection.  */\n-\n-/* For regular rtl allocations.  */\n-extern struct alloc_zone rtl_zone;\n-\n-/* For regular tree allocations.  */\n-extern struct alloc_zone tree_zone;\n-\n-/* For IDENTIFIER_NODE allocations.  */\n-extern struct alloc_zone tree_id_zone;\n-\n-#define ggc_alloc_rtvec_sized(NELT)                                     \\\n-  ggc_alloc_zone_rtvec_def (sizeof (struct rtvec_def)\t\t\t\\\n-\t\t\t    + ((NELT) - 1) * sizeof (rtx),\t\t\\\n-\t\t\t    &rtl_zone)\n-\n-#if defined (GGC_ZONE) && !defined (GENERATOR_FILE)\n-\n-/* Allocate an object into the specified allocation zone.  */\n-extern void *ggc_internal_alloc_zone_stat (size_t,\n-\t\t\t\t\t  struct alloc_zone * MEM_STAT_DECL)\n-  ATTRIBUTE_MALLOC;\n-\n-extern void *ggc_internal_cleared_alloc_zone_stat (size_t,\n-\t\t\t\t\t  struct alloc_zone * MEM_STAT_DECL)\n-  ATTRIBUTE_MALLOC;\n-\n-static inline void *\n-ggc_internal_zone_alloc_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n-{\n-    return ggc_internal_alloc_zone_stat (s, z PASS_MEM_STAT);\n-}\n-\n-static inline void *\n-ggc_internal_zone_cleared_alloc_stat (struct alloc_zone * z, size_t s\n-                                      MEM_STAT_DECL)\n-{\n-    return ggc_internal_cleared_alloc_zone_stat (s, z PASS_MEM_STAT);\n-}\n-\n-static inline void *\n-ggc_internal_zone_vec_alloc_stat (struct alloc_zone * z, size_t s, size_t n\n-                                  MEM_STAT_DECL)\n-{\n-    return ggc_internal_alloc_zone_stat (s * n, z PASS_MEM_STAT);\n-}\n-\n-\n-#else\n-\n-static inline void *\n-ggc_internal_zone_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n-                              size_t s MEM_STAT_DECL)\n-{\n-    return ggc_internal_alloc_stat (s PASS_MEM_STAT);\n-}\n-\n-static inline void *\n-ggc_internal_zone_cleared_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n-                                      size_t s MEM_STAT_DECL)\n-{\n-    return ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n-}\n-\n-static inline void *\n-ggc_internal_zone_vec_alloc_stat (struct alloc_zone * z ATTRIBUTE_UNUSED,\n-                                  size_t s, size_t n MEM_STAT_DECL)\n-{\n-    return ggc_internal_vec_alloc_stat (s, n PASS_MEM_STAT);\n-}\n-\n-#endif\n+#define ggc_alloc_rtvec_sized(NELT)\t\t\t\t\\\n+  ggc_alloc_rtvec_def (sizeof (struct rtvec_def)\t\t\\\n+\t\t       + ((NELT) - 1) * sizeof (rtx))\t\t\\\n \n /* Memory statistics passing versions of some allocators.  Too few of them to\n    make gengtype produce them, so just define the needed ones here.  */\n static inline struct rtx_def *\n-ggc_alloc_zone_rtx_def_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n+ggc_alloc_rtx_def_stat (size_t s MEM_STAT_DECL)\n {\n-  return (struct rtx_def *) ggc_internal_zone_alloc_stat (z, s PASS_MEM_STAT);\n+  return (struct rtx_def *) ggc_internal_alloc_stat (s PASS_MEM_STAT);\n }\n \n static inline union tree_node *\n-ggc_alloc_zone_tree_node_stat (struct alloc_zone * z, size_t s MEM_STAT_DECL)\n+ggc_alloc_tree_node_stat (size_t s MEM_STAT_DECL)\n {\n-  return (union tree_node *) ggc_internal_zone_alloc_stat (z, s PASS_MEM_STAT);\n+  return (union tree_node *) ggc_internal_alloc_stat (s PASS_MEM_STAT);\n }\n \n static inline union tree_node *\n-ggc_alloc_zone_cleared_tree_node_stat (struct alloc_zone * z, size_t s\n-                                       MEM_STAT_DECL)\n+ggc_alloc_cleared_tree_node_stat (size_t s MEM_STAT_DECL)\n {\n-  return (union tree_node *)\n-    ggc_internal_zone_cleared_alloc_stat (z, s PASS_MEM_STAT);\n+  return (union tree_node *) ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n \n static inline union gimple_statement_d *"}, {"sha": "bc49fc86fe999587e259d2181d79769571ef20a2", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -192,8 +192,7 @@ rtx_size (const_rtx x)\n rtx\n rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n {\n-  rtx rt = ggc_alloc_zone_rtx_def_stat (&rtl_zone, RTX_CODE_SIZE (code)\n-                                        PASS_MEM_STAT);\n+  rtx rt = ggc_alloc_rtx_def_stat (RTX_CODE_SIZE (code) PASS_MEM_STAT);\n \n   /* We want to clear everything up to the FLD array.  Normally, this\n      is one int, but we don't want to assume that and it isn't very\n@@ -329,7 +328,7 @@ rtx\n shallow_copy_rtx_stat (const_rtx orig MEM_STAT_DECL)\n {\n   const unsigned int size = rtx_size (orig);\n-  rtx const copy = ggc_alloc_zone_rtx_def_stat (&rtl_zone, size PASS_MEM_STAT);\n+  rtx const copy = ggc_alloc_rtx_def_stat (size PASS_MEM_STAT);\n   return (rtx) memcpy (copy, orig, size);\n }\n \f"}, {"sha": "f4d0daebdd9ce42b0254fa87b368a213ec057ef5", "filename": "gcc/stringpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -207,7 +207,7 @@ void\n gt_pch_n_S (const void *x)\n {\n   gt_pch_note_object (CONST_CAST (void *, x), CONST_CAST (void *, x),\n-\t\t      &gt_pch_p_S, gt_types_enum_last);\n+\t\t      &gt_pch_p_S);\n }\n \n "}, {"sha": "44997537ccbca2d30c0d72e8057d770083591eac", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -42,10 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n    garbage collector.  Similar results have been seen on a wider variety\n    of tests (such as the compiler itself).\n \n-   We could also use a zone allocator for these objects since they have\n-   a very well defined lifetime.  If someone wants to experiment with that\n-   this is the place to try it.\n-\n    PHI nodes have different sizes, so we can't have a single list of all\n    the PHI nodes as it would be too expensive to walk down that list to\n    find a PHI of a suitable size."}, {"sha": "be078ce96ce82571d19ee8159f1aa8e923fec5ca", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -50,11 +50,8 @@ along with GCC; see the file COPYING3.  If not see\n    External code should also not assume the version number on nodes is\n    monotonically increasing.  We reuse the version number when we\n    reuse an SSA_NAME expression.  This helps keep arrays and bitmaps\n-   more compact.\n+   more compact.  */\n \n-   We could also use a zone allocator for these objects since they have\n-   a very well defined lifetime.  If someone wants to experiment with that\n-   this is the place to try it.  */\n \n /* Version numbers with special meanings.  We start allocating new version\n    numbers after the special ones.  */"}, {"sha": "98ad5d8784b0078be212087781ce8c061a017a90", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -857,9 +857,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \n   record_node_allocation_statistics (code, length);\n \n-  t = ggc_alloc_zone_cleared_tree_node_stat (\n-               (code == IDENTIFIER_NODE) ? &tree_id_zone : &tree_zone,\n-               length PASS_MEM_STAT);\n+  t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n   TREE_SET_CODE (t, code);\n \n   switch (type)\n@@ -953,7 +951,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \n   length = tree_size (node);\n   record_node_allocation_statistics (code, length);\n-  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_tree_node_stat (length PASS_MEM_STAT);\n   memcpy (t, node, length);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMMON))\n@@ -1311,7 +1309,7 @@ make_vector_stat (unsigned len MEM_STAT_DECL)\n \n   record_node_allocation_statistics (VECTOR_CST, length);\n \n-  t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, VECTOR_CST);\n   TREE_CONSTANT (t) = 1;\n@@ -1674,7 +1672,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n \n   record_node_allocation_statistics (TREE_BINFO, length);\n \n-  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_tree_node_stat (length PASS_MEM_STAT);\n \n   memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n@@ -1713,7 +1711,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n \n   record_node_allocation_statistics (TREE_VEC, length);\n \n-  t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, TREE_VEC);\n   TREE_VEC_LENGTH (t) = len;\n@@ -2330,8 +2328,7 @@ tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n {\n   tree node;\n \n-  node = ggc_alloc_zone_tree_node_stat (&tree_zone, sizeof (struct tree_list)\n-                                        PASS_MEM_STAT);\n+  node = ggc_alloc_tree_node_stat (sizeof (struct tree_list) PASS_MEM_STAT);\n   memset (node, 0, sizeof (struct tree_common));\n \n   record_node_allocation_statistics (TREE_LIST, sizeof (struct tree_list));\n@@ -3800,7 +3797,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n-  t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_tree_node_stat (length PASS_MEM_STAT);\n \n   memset (t, 0, sizeof (struct tree_common));\n \n@@ -10073,7 +10070,7 @@ build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n \n   record_node_allocation_statistics (code, length);\n \n-  t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n+  t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, code);\n "}, {"sha": "6b941badd89d638b0fcad5cbfcde955484aff26d", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd030c079e5e42fe3f49261fe01f384e6b7f0111/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=cd030c079e5e42fe3f49261fe01f384e6b7f0111", "patch": "@@ -374,7 +374,7 @@ create_block_symbol (const char *label, struct object_block *block,\n \n   /* Create the extended SYMBOL_REF.  */\n   size = RTX_HDR_SIZE + sizeof (struct block_symbol);\n-  symbol = ggc_alloc_zone_rtx_def (size, &rtl_zone);\n+  symbol = ggc_alloc_rtx_def (size);\n \n   /* Initialize the normal SYMBOL_REF fields.  */\n   memset (symbol, 0, size);"}]}