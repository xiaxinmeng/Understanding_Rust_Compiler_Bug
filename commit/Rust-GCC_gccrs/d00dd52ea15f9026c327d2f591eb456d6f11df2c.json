{"sha": "d00dd52ea15f9026c327d2f591eb456d6f11df2c", "node_id": "C_kwDOANBUbNoAKGQwMGRkNTJlYTE1ZjkwMjZjMzI3ZDJmNTkxZWI0NTZkNmYxMWRmMmM", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-03-26T00:23:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-04-15T21:27:05Z"}, "message": "compiler: revert `for package-scope \"a = b; b = x\" just set \"a = x\"`\n\nRevert CL 245098.  It caused incorrect initialization ordering.\n\nAdjust the runtime package to work even with the CL reverted.\n\nOriginal description of CL 245098:\n\n    This avoids requiring an init function to initialize the variable.\n    This can only be done if x is a static initializer.\n\n    The go1.15rc1 runtime package relies on this optimization.\n    The package has a variable \"var maxSearchAddr = maxOffAddr\".\n    The maxSearchAddr variable is used by code that runs before package\n    initialization is complete.\n\nFor golang/go#51913\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/395994", "tree": {"sha": "278f15dc95ab9f1cebaa975bece1cbd395f127de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/278f15dc95ab9f1cebaa975bece1cbd395f127de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d00dd52ea15f9026c327d2f591eb456d6f11df2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00dd52ea15f9026c327d2f591eb456d6f11df2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d00dd52ea15f9026c327d2f591eb456d6f11df2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00dd52ea15f9026c327d2f591eb456d6f11df2c/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e76cef873342a66408c126abceaf7dbddd3f477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e76cef873342a66408c126abceaf7dbddd3f477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e76cef873342a66408c126abceaf7dbddd3f477"}], "stats": {"total": 53, "additions": 16, "deletions": 37}, "files": [{"sha": "bcb526c85b91444cee253e5496b0ae748250f816", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00dd52ea15f9026c327d2f591eb456d6f11df2c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00dd52ea15f9026c327d2f591eb456d6f11df2c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d00dd52ea15f9026c327d2f591eb456d6f11df2c", "patch": "@@ -1,4 +1,4 @@\n-323ab0e6fab89978bdbd83dca9c2ad9c5dcd690f\n+62fc90f52da2f52cbe3b4f10e560dc6aa59baeb5\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d35c6baf5825f8a1fd4a01e894837a7a089a3091", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00dd52ea15f9026c327d2f591eb456d6f11df2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00dd52ea15f9026c327d2f591eb456d6f11df2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=d00dd52ea15f9026c327d2f591eb456d6f11df2c", "patch": "@@ -1612,31 +1612,16 @@ Gogo::write_globals()\n               // The initializer is constant if it is the zero-value of the\n               // variable's type or if the initial value is an immutable value\n               // that is not copied to the heap.\n-\t      Expression* init = var->init();\n-\n-\t      // If we see \"a = b; b = x\", and x is a static\n-\t      // initializer, just set a to x.\n-\t      while (init != NULL && init->var_expression() != NULL)\n-\t\t{\n-\t\t  Named_object* ino = init->var_expression()->named_object();\n-\t\t  if (!ino->is_variable() || ino->package() != NULL)\n-\t\t    break;\n-\t\t  Expression* ino_init = ino->var_value()->init();\n-\t\t  if (ino->var_value()->has_pre_init()\n-\t\t      || ino_init == NULL\n-\t\t      || !ino_init->is_static_initializer())\n-\t\t    break;\n-\t\t  init = ino_init;\n-\t\t}\n-\n-              bool is_static_initializer;\n-              if (init == NULL)\n+              bool is_static_initializer = false;\n+              if (var->init() == NULL)\n                 is_static_initializer = true;\n               else\n                 {\n                   Type* var_type = var->type();\n-                  init = Expression::make_cast(var_type, init, var->location());\n-                  is_static_initializer = init->is_static_initializer();\n+                  Expression* init = var->init();\n+                  Expression* init_cast =\n+                      Expression::make_cast(var_type, init, var->location());\n+                  is_static_initializer = init_cast->is_static_initializer();\n                 }\n \n \t      // Non-constant variable initializations might need to create\n@@ -1655,15 +1640,7 @@ Gogo::write_globals()\n                     }\n \t\t  var_init_fn = init_fndecl;\n \t\t}\n-\n-\t      Bexpression* var_binit;\n-\t      if (init == NULL)\n-\t\tvar_binit = NULL;\n-\t      else\n-\t\t{\n-\t\t  Translate_context context(this, var_init_fn, NULL, NULL);\n-\t\t  var_binit = init->get_backend(&context);\n-\t\t}\n+              Bexpression* var_binit = var->get_init(this, var_init_fn);\n \n               if (var_binit == NULL)\n \t\t;"}, {"sha": "5e40da45d179b2c8f33b0d549d1d77682ba4da6b", "filename": "libgo/go/runtime/mpagealloc.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00dd52ea15f9026c327d2f591eb456d6f11df2c/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00dd52ea15f9026c327d2f591eb456d6f11df2c/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc.go?ref=d00dd52ea15f9026c327d2f591eb456d6f11df2c", "patch": "@@ -87,7 +87,9 @@ const (\n //\n // We alias maxOffAddr just to make it clear that this is the maximum address\n // for the page allocator's search space. See maxOffAddr for details.\n-var maxSearchAddr = maxOffAddr\n+func maxSearchAddr() offAddr {\n+\treturn maxOffAddr\n+}\n \n // Global chunk index.\n //\n@@ -331,13 +333,13 @@ func (p *pageAlloc) init(mheapLock *mutex, sysStat *sysMemStat) {\n \tp.sysInit()\n \n \t// Start with the searchAddr in a state indicating there's no free memory.\n-\tp.searchAddr = maxSearchAddr\n+\tp.searchAddr = maxSearchAddr()\n \n \t// Set the mheapLock.\n \tp.mheapLock = mheapLock\n \n \t// Initialize scavenge tracking state.\n-\tp.scav.scavLWM = maxSearchAddr\n+\tp.scav.scavLWM = maxSearchAddr()\n }\n \n // tryChunkOf returns the bitmap data for the given chunk.\n@@ -760,7 +762,7 @@ nextLevel:\n \t\t}\n \t\tif l == 0 {\n \t\t\t// We're at level zero, so that means we've exhausted our search.\n-\t\t\treturn 0, maxSearchAddr\n+\t\t\treturn 0, maxSearchAddr()\n \t\t}\n \n \t\t// We're not at level zero, and we exhausted the level we were looking in.\n@@ -854,7 +856,7 @@ func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr) {\n \t\t\t// exhausted. Otherwise, the heap still might have free\n \t\t\t// space in it, just not enough contiguous space to\n \t\t\t// accommodate npages.\n-\t\t\tp.searchAddr = maxSearchAddr\n+\t\t\tp.searchAddr = maxSearchAddr()\n \t\t}\n \t\treturn 0, 0\n \t}"}, {"sha": "5bad4f789a11982659da1d894509f312859f8faa", "filename": "libgo/go/runtime/mpagecache.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00dd52ea15f9026c327d2f591eb456d6f11df2c/libgo%2Fgo%2Fruntime%2Fmpagecache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00dd52ea15f9026c327d2f591eb456d6f11df2c/libgo%2Fgo%2Fruntime%2Fmpagecache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagecache.go?ref=d00dd52ea15f9026c327d2f591eb456d6f11df2c", "patch": "@@ -143,7 +143,7 @@ func (p *pageAlloc) allocToCache() pageCache {\n \t\tif addr == 0 {\n \t\t\t// We failed to find adequate free space, so mark the searchAddr as OoM\n \t\t\t// and return an empty pageCache.\n-\t\t\tp.searchAddr = maxSearchAddr\n+\t\t\tp.searchAddr = maxSearchAddr()\n \t\t\treturn pageCache{}\n \t\t}\n \t\tci := chunkIndex(addr)"}]}