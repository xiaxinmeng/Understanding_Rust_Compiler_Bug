{"sha": "21e69789dd50e5a8161025a3d15dc79f791f6812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFlNjk3ODlkZDUwZTVhODE2MTAyNWEzZDE1ZGM3OWY3OTFmNjgxMg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-09-25T10:17:00Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-25T10:17:00Z"}, "message": "2003-09-25  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/nio/DatagramChannelImpl.java\n\t(DatagramChannelImpl): Made class final.\n\t(blocking): Made private.\n\t(socket): Made it a NIODatagramSocket and private.\n\t(DatagramChannelImpl): create NIODatagramSocket instead of\n\tDatagramSocket.\n\t(implConfigureBlocking): Set socket timeout.\n\t(connect): Check that channel is not closed.\n\t(write): Implemented.\n\t(write): Rewritten.\n\t(read): Implemented.\n\t(read): Rewritten.\n\t(receive): Implemented.\n\t(send): Implemented.\n\t* gnu/java/nio/SelectionKeyImpl.java\n\t(readyOps): Made private.\n\t(interestOps): Made private.\n\t(impl): Made private.\n\t(ch): Made private.\n\t(readyOps): Check if selection key is valid.\n\t(interestOps): Likewise.\n\t* gnu/java/nio/SelectorImpl.java\n\t(closed): Removed.\n\t(keys): Made private.\n\t(selected): Made private.\n\t(finalize): New method.\n\t(implCloseSelector): Rewritten.\n\t(keys): Return unmodifiable Set.\n\t(deregisterCancelledKeys): Fixed typo in method name.\n\t* gnu/java/nio/SocketChannelImpl.java\n\t(SocketChannelImpl): Made class final.\n\t(socket): Made it a NIOSocket and private.\n\t(blocking): Made private.\n\t(connected): Made private.\n\t(connectionPending): New member variable.\n\t(SocketChannelImpl): New implementation.\n\t(finalizer): Use isConnected().\n\t(connect): Rewritten.\n\t(finishConnect): Throws IOException, implemented.\n\t(isConnectionPending): Return connectionPending.\n\t(read): Rewritten.\n\t(write): Rewritten.\n\t* gnu/java/nio/NIOConstants.java: New file.\n\t* Makefile.am (ordinary_java_source_files):\n\tAdded gnu/java/nio/NIOConstants.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r71769", "tree": {"sha": "f64cac1e9b4351a90bd0d14b21a18d7bf91b962b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f64cac1e9b4351a90bd0d14b21a18d7bf91b962b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21e69789dd50e5a8161025a3d15dc79f791f6812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e69789dd50e5a8161025a3d15dc79f791f6812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e69789dd50e5a8161025a3d15dc79f791f6812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e69789dd50e5a8161025a3d15dc79f791f6812/comments", "author": null, "committer": null, "parents": [{"sha": "131b9f3dcd61bc5048fcc0ab3b90d7fc29774ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131b9f3dcd61bc5048fcc0ab3b90d7fc29774ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131b9f3dcd61bc5048fcc0ab3b90d7fc29774ae7"}], "stats": {"total": 524, "additions": 439, "deletions": 85}, "files": [{"sha": "fdcc1c90689e6b53e35613a85f9176d5871f7fb9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1,3 +1,52 @@\n+2003-09-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/nio/DatagramChannelImpl.java\n+\t(DatagramChannelImpl): Made class final.\n+\t(blocking): Made private.\n+\t(socket): Made it a NIODatagramSocket and private.\n+\t(DatagramChannelImpl): create NIODatagramSocket instead of\n+\tDatagramSocket.\n+\t(implConfigureBlocking): Set socket timeout.\n+\t(connect): Check that channel is not closed.\n+\t(write): Implemented.\n+\t(write): Rewritten.\n+\t(read): Implemented.\n+\t(read): Rewritten.\n+\t(receive): Implemented.\n+\t(send): Implemented.\n+\t* gnu/java/nio/SelectionKeyImpl.java\n+\t(readyOps): Made private.\n+\t(interestOps): Made private.\n+\t(impl): Made private.\n+\t(ch): Made private.\n+\t(readyOps): Check if selection key is valid.\n+\t(interestOps): Likewise.\n+\t* gnu/java/nio/SelectorImpl.java\n+\t(closed): Removed.\n+\t(keys): Made private.\n+\t(selected): Made private.\n+\t(finalize): New method.\n+\t(implCloseSelector): Rewritten.\n+\t(keys): Return unmodifiable Set.\n+\t(deregisterCancelledKeys): Fixed typo in method name.\n+\t* gnu/java/nio/SocketChannelImpl.java\n+\t(SocketChannelImpl): Made class final.\n+\t(socket): Made it a NIOSocket and private.\n+\t(blocking): Made private.\n+\t(connected): Made private.\n+\t(connectionPending): New member variable.\n+\t(SocketChannelImpl): New implementation.\n+\t(finalizer): Use isConnected().\n+\t(connect): Rewritten.\n+\t(finishConnect): Throws IOException, implemented.\n+\t(isConnectionPending): Return connectionPending.\n+\t(read): Rewritten.\n+\t(write): Rewritten.\n+\t* gnu/java/nio/NIOConstants.java: New file.\n+\t* Makefile.am (ordinary_java_source_files):\n+\tAdded gnu/java/nio/NIOConstants.java.\n+\t* Makefile.in: Regenerated.\n+\n 2003-09-25  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/InetAddress.java:"}, {"sha": "889d092297cf3aa555e73879f7333575b6195d11", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -2184,6 +2184,7 @@ gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/nio/DatagramChannelImpl.java \\\n gnu/java/nio/FileLockImpl.java \\\n+gnu/java/nio/NIOConstants.java \\\n gnu/java/nio/NIODatagramSocket.java \\\n gnu/java/nio/NIOSocket.java \\\n gnu/java/nio/PipeImpl.java \\"}, {"sha": "87b065783e4694519bd083919cac4f056d382bf0", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1902,6 +1902,7 @@ gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/nio/DatagramChannelImpl.java \\\n gnu/java/nio/FileLockImpl.java \\\n+gnu/java/nio/NIOConstants.java \\\n gnu/java/nio/NIODatagramSocket.java \\\n gnu/java/nio/NIOSocket.java \\\n gnu/java/nio/PipeImpl.java \\\n@@ -3025,7 +3026,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/net/natPlainDatagramSocketImpl.P \\\n .deps/gnu/java/net/natPlainSocketImpl.P \\\n .deps/gnu/java/nio/DatagramChannelImpl.P \\\n-.deps/gnu/java/nio/FileLockImpl.P \\\n+.deps/gnu/java/nio/FileLockImpl.P .deps/gnu/java/nio/NIOConstants.P \\\n .deps/gnu/java/nio/NIODatagramSocket.P .deps/gnu/java/nio/NIOSocket.P \\\n .deps/gnu/java/nio/PipeImpl.P .deps/gnu/java/nio/SelectionKeyImpl.P \\\n .deps/gnu/java/nio/SelectorImpl.P \\"}, {"sha": "a4f46df18611b7862b693089ef73e461302c2e22", "filename": "libjava/gnu/java/nio/DatagramChannelImpl.java", "status": "modified", "additions": 120, "deletions": 20, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1,5 +1,5 @@\n /* DatagramChannelImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,23 +39,30 @@\n package gnu.java.nio;\n \n import java.io.IOException;\n+import java.net.DatagramPacket;\n import java.net.DatagramSocket;\n+import gnu.java.net.PlainDatagramSocketImpl;\n import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.DatagramChannel;\n import java.nio.channels.NotYetConnectedException;\n import java.nio.channels.spi.SelectorProvider;\n \n-public class DatagramChannelImpl extends DatagramChannel\n+/**\n+ * @author Michael Koch\n+ */\n+public final class DatagramChannelImpl extends DatagramChannel\n {\n-  boolean blocking = false;\n-  DatagramSocket socket;\n+  private NIODatagramSocket socket;\n+  private boolean blocking = false;\n   \n   protected DatagramChannelImpl (SelectorProvider provider)\n     throws IOException\n   {\n     super (provider);\n-    socket = new DatagramSocket ();\n+    socket = new NIODatagramSocket (new PlainDatagramSocketImpl(), this);\n   }\n     \n   public DatagramSocket socket ()\n@@ -72,12 +79,16 @@ protected void implCloseSelectableChannel ()\n   protected void implConfigureBlocking (boolean blocking)\n     throws IOException\n   {\n-    this.blocking = blocking; // FIXME\n+    socket.setSoTimeout (blocking ? 0 : NIOConstants.DEFAULT_TIMEOUT);\n+    this.blocking = blocking;\n   }\n \n   public DatagramChannel connect (SocketAddress remote)\n     throws IOException\n   {\n+    if (!isOpen())\n+      throw new ClosedChannelException();\n+    \n     socket.connect (remote);\n     return this;\n   }\n@@ -100,19 +111,25 @@ public int write (ByteBuffer src)\n     if (!isConnected ())\n       throw new NotYetConnectedException ();\n     \n-    throw new Error (\"Not implemented\");\n+    return send (src, socket.getRemoteSocketAddress());\n   }\n \n   public long write (ByteBuffer[] srcs, int offset, int length)\n     throws IOException\n   {\n-    // FIXME: Should we throw an exception if offset and/or length\n-    // have wrong values ?\n-\n+    if (!isConnected())\n+      throw new NotYetConnectedException();\n+\n+    if ((offset < 0)\n+        || (offset > srcs.length)\n+        || (length < 0)\n+        || (length > (srcs.length - offset)))\n+      throw new IndexOutOfBoundsException();\n+      \n     long result = 0;\n \n-    for (int i = offset; i < offset + length; i++)\n-      result += write (srcs [i]);\n+    for (int index = offset; index < offset + length; index++)\n+      result += write (srcs [index]);\n \n     return result;\n   }\n@@ -123,32 +140,115 @@ public int read (ByteBuffer dst)\n     if (!isConnected ())\n       throw new NotYetConnectedException ();\n     \n-    throw new Error (\"Not implemented\");\n+    int remaining = dst.remaining();\n+    receive (dst);\n+    return remaining - dst.remaining();\n   }\n     \n   public long read (ByteBuffer[] dsts, int offset, int length)\n     throws IOException\n   {\n-    // FIXME: Should we throw an exception if offset and/or length\n-    // have wrong values ?\n-\n+    if (!isConnected())\n+      throw new NotYetConnectedException();\n+    \n+    if ((offset < 0)\n+        || (offset > dsts.length)\n+        || (length < 0)\n+        || (length > (dsts.length - offset)))\n+      throw new IndexOutOfBoundsException();\n+      \n     long result = 0;\n \n-    for (int i = offset; i < offset + length; i++)\n-      result += read (dsts [i]);\n+    for (int index = offset; index < offset + length; index++)\n+      result += read (dsts [index]);\n \n     return result;\n   }\n     \n   public SocketAddress receive (ByteBuffer dst)\n     throws IOException\n   {\n-    throw new Error (\"Not implemented\");\n+    if (!isOpen())\n+      throw new ClosedChannelException();\n+    \n+    try\n+      {\n+        DatagramPacket packet;\n+        int len = dst.remaining();\n+        \n+        if (dst.hasArray())\n+          {\n+            packet = new DatagramPacket (dst.array(),\n+                                         dst.arrayOffset() + dst.position(),\n+                                         len);\n+          }\n+        else\n+          {\n+            packet = new DatagramPacket (new byte [len], len);\n+          }\n+\n+        boolean completed = false;\n+\n+        try\n+          {\n+            begin();\n+            socket.receive (packet);\n+            completed = true;\n+          }\n+        finally\n+          {\n+            end (completed);\n+          }\n+\n+        if (!dst.hasArray())\n+          {\n+            dst.put (packet.getData(), packet.getOffset(), packet.getLength());\n+          }\n+\n+        // FIMXE: remove this testing code.\n+        for (int i = 0; i < packet.getLength(); i++)\n+          {\n+            System.out.println (\"Byte \" + i + \" has value \" + packet.getData() [packet.getOffset() + i]);\n+          }\n+\n+        return packet.getSocketAddress();\n+      }\n+    catch (SocketTimeoutException e)\n+      {\n+        return null;\n+      }\n   }\n     \n   public int send (ByteBuffer src, SocketAddress target)\n     throws IOException\n   {\n-    throw new Error (\"Not implemented\");\n+    if (!isOpen())\n+      throw new ClosedChannelException();\n+    \n+    byte[] buffer;\n+    int offset = 0;\n+    int len = src.remaining();\n+    \n+    if (src.hasArray())\n+      {\n+        buffer = src.array();\n+        offset = src.arrayOffset() + src.position();\n+      }\n+    else\n+      {\n+        buffer = new byte [len];\n+        src.get (buffer);\n+      }\n+\n+    DatagramPacket packet = new DatagramPacket (buffer, offset, len, target);\n+\n+    // FIMXE: remove this testing code.\n+    for (int i = 0; i < packet.getLength(); i++)\n+      {\n+        System.out.println (\"Byte \" + i + \" has value \" + packet.getData() [packet.getOffset() + i]);\n+      }\n+\n+    socket.send (packet);\n+    return len;\n   }\n }"}, {"sha": "8a71202a347b64fd1ef28e171dbbaed55b0d8857", "filename": "libjava/gnu/java/nio/NIOConstants.java", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FNIOConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FNIOConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FNIOConstants.java?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -0,0 +1,47 @@\n+/* NIOConstants.java --\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+/**\n+ * @author Michael Koch\n+ */\n+public final class NIOConstants\n+{\n+  public static final int DEFAULT_TIMEOUT = 50;\n+}"}, {"sha": "df4faa3a9359edcdd06ccb718560bcad9515b0da", "filename": "libjava/gnu/java/nio/SelectionKeyImpl.java", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1,5 +1,5 @@\n /* SelectionKeyImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n package gnu.java.nio;\n \n+import java.nio.channels.CancelledKeyException;\n import java.nio.channels.SelectableChannel;\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n@@ -45,10 +46,10 @@\n public class SelectionKeyImpl extends AbstractSelectionKey\n {\n   int fd;\n-  int readyOps;\n-  int interestOps;\n-  SelectorImpl impl;\n-  SelectableChannel ch;\n+  private int readyOps;\n+  private int interestOps;\n+  private SelectorImpl impl;\n+  private SelectableChannel ch;\n \n   public SelectionKeyImpl (SelectableChannel ch, SelectorImpl impl, int fd)\n   {\n@@ -64,22 +65,34 @@ public SelectableChannel channel ()\n \n   public int readyOps ()\n   {\n+    if (!isValid())\n+      throw new CancelledKeyException();\n+    \n     return readyOps;\n   }\n \n   public SelectionKey readyOps (int ops)\n   {\n+    if (!isValid())\n+      throw new CancelledKeyException();\n+    \n     readyOps = ops;\n     return this;\n   }\n \n   public int interestOps ()\n   {\n+    if (!isValid())\n+      throw new CancelledKeyException();\n+    \n     return interestOps;    \n   }\n \n   public SelectionKey interestOps (int ops)\n   {\n+    if (!isValid())\n+      throw new CancelledKeyException();\n+    \n     interestOps = ops;\n     return this;\n   }"}, {"sha": "a906641ac75e19bb7a1c42e1bd4f2feb6bdbf5c9", "filename": "libjava/gnu/java/nio/SelectorImpl.java", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1,5 +1,5 @@\n /* SelectorImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,34 +37,47 @@\n \n package gnu.java.nio;\n \n+import java.io.IOException;\n import java.nio.channels.ClosedSelectorException;\n import java.nio.channels.SelectableChannel;\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.AbstractSelector;\n import java.nio.channels.spi.SelectorProvider;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Set;\n \n public class SelectorImpl extends AbstractSelector\n {\n-  boolean closed = false;\n-  Set keys, selected, canceled;\n+  private Set keys;\n+  private Set selected;\n \n   public SelectorImpl (SelectorProvider provider)\n   {\n     super (provider);\n     \n     keys = new HashSet ();\n     selected = new HashSet ();\n-    canceled = new HashSet ();\n   }\n \n-  public Set keys ()\n+  protected void finalize() throws Throwable\n   {\n-    return keys;\n+    close();\n+  }\n+\n+  protected final void implCloseSelector()\n+    throws IOException\n+  {\n+    // FIXME: We surely need to do more here.\n+    wakeup();\n+  }\n+\n+  public final Set keys()\n+  {\n+    return Collections.unmodifiableSet (keys);\n   }\n     \n   public int selectNow ()\n@@ -120,10 +133,8 @@ private int[] getFDsAsArray (int ops)\n \n   public int select (long timeout)\n   {\n-    if (closed)\n-      {\n-        throw new ClosedSelectorException ();\n-      }\n+    if (!isOpen())\n+      throw new ClosedSelectorException ();\n \n     if (keys == null)\n \t    {\n@@ -132,7 +143,7 @@ public int select (long timeout)\n \n     int ret = 0;\n \n-    deregisterCanceledKeys ();\n+    deregisterCancelledKeys();\n \n     // Set only keys with the needed interest ops into the arrays.\n     int[] read = getFDsAsArray (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);\n@@ -202,7 +213,7 @@ public int select (long timeout)\n         key.readyOps (key.interestOps () & ops);\n       }\n \n-    deregisterCanceledKeys ();\n+    deregisterCancelledKeys();\n     return ret;\n   }\n     \n@@ -226,14 +237,9 @@ void add_selected (SelectionKeyImpl k)\n     selected.add (k);\n   }\n \n-  protected void implCloseSelector ()\n-  {\n-    closed = true;\n-  }\n-\n-  private void deregisterCanceledKeys ()\n+  private void deregisterCancelledKeys ()\n   {\n-    Iterator it = canceled.iterator ();\n+    Iterator it = cancelledKeys().iterator();\n \n     while (it.hasNext ())\n       {"}, {"sha": "a114b06a5b8c9d170bd8fd1f756f3850e844779e", "filename": "libjava/gnu/java/nio/SocketChannelImpl.java", "status": "modified", "additions": 177, "deletions": 40, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21e69789dd50e5a8161025a3d15dc79f791f6812/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java?ref=21e69789dd50e5a8161025a3d15dc79f791f6812", "patch": "@@ -1,5 +1,5 @@\n /* SocketChannelImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,32 +38,55 @@\n \n package gnu.java.nio;\n \n+import java.io.InputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import gnu.java.net.PlainSocketImpl;\n import java.net.Socket;\n import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n import java.nio.ByteBuffer;\n import java.nio.channels.AlreadyConnectedException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ConnectionPendingException;\n+import java.nio.channels.NoConnectionPendingException;\n+import java.nio.channels.NotYetConnectedException;\n+import java.nio.channels.UnresolvedAddressException;\n+import java.nio.channels.UnsupportedAddressTypeException;\n import java.nio.channels.SocketChannel;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SelectionKey;\n import java.nio.channels.spi.SelectorProvider;\n import gnu.classpath.Configuration;\n \n-public class SocketChannelImpl extends SocketChannel\n+public final class SocketChannelImpl extends SocketChannel\n {\n-  Socket socket;\n-  boolean blocking = true;\n-  boolean connected = false;\n+  private NIOSocket socket;\n+  private boolean blocking = true;\n+  private boolean connected = false;\n+  private boolean connectionPending = false;\n \n-  public SocketChannelImpl (SelectorProvider provider)\t\t      \n+  SocketChannelImpl (SelectorProvider provider)\n+    throws IOException\n   {\n     super (provider);\n-    socket = new Socket ();\n+    socket = new NIOSocket (new PlainSocketImpl(), this);\n+  }\n+  \n+  SocketChannelImpl (SelectorProvider provider,\n+                     NIOSocket socket)\n+    throws IOException\n+  {\n+    super (provider);\n+    this.socket = socket;\n+    this.connected = socket.isConnected();\n   }\n \n   public void finalizer()\n   {\n-    if (connected)\n+    if (isConnected())\n       {\n         try\n           {\n@@ -83,21 +106,82 @@ protected void implCloseSelectableChannel () throws IOException\n \n   protected void implConfigureBlocking (boolean blocking) throws IOException\n   {\n-    this.blocking = blocking; // FIXME\n+    socket.setSoTimeout (blocking ? 0 : NIOConstants.DEFAULT_TIMEOUT);\n+    this.blocking = blocking;\n   }   \n \n   public boolean connect (SocketAddress remote) throws IOException\n   {\n-    if (connected)\n+    if (!isOpen())\n+      throw new ClosedChannelException();\n+    \n+    if (isConnected())\n       throw new AlreadyConnectedException();\n-\t\n-    socket.connect (remote, 50);\n-    connected = true;\n-    return blocking; // FIXME\n+\n+    if (connectionPending)\n+      throw new ConnectionPendingException();\n+\n+    if (!(remote instanceof InetSocketAddress))\n+      throw new UnsupportedAddressTypeException();\n+\n+    if (((InetSocketAddress) remote).isUnresolved())\n+      throw new UnresolvedAddressException();\n+    \n+    if (blocking)\n+      {\n+        // Do blocking connect.\n+        socket.connect (remote);\n+        connected = true;\n+        return true;\n+      }\n+\n+    // Do non-blocking connect.\n+    try\n+      {\n+        socket.connect (remote, NIOConstants.DEFAULT_TIMEOUT);\n+        connected = true;\n+        return true;\n+      }\n+    catch (SocketTimeoutException e)\n+      {\n+        connectionPending = true;\n+        return false;\n+      }\n   }\n     \n   public boolean finishConnect ()\n+    throws IOException\n   {\n+    if (!isOpen())\n+      throw new ClosedChannelException();\n+    \n+    if (!connectionPending)\n+      throw new NoConnectionPendingException();\n+    \n+    if (isConnected())\n+      return true;\n+\n+    // FIXME: Handle blocking/non-blocking mode.\n+\n+    Selector selector = provider().openSelector();\n+    register (selector, SelectionKey.OP_CONNECT);\n+\n+    if (isBlocking())\n+      {\n+        selector.select(); // blocking until channel is connected.\n+        connected = true;\n+        connectionPending = false;\n+        return true;\n+      }\n+\n+    int ready = selector.selectNow(); // non-blocking\n+    if (ready == 1)\n+      {\n+        connected = true;\n+        connectionPending = false;\n+        return true;\n+      }\n+\n     return false;\n   }\n \n@@ -108,7 +192,7 @@ public boolean isConnected ()\n     \n   public boolean isConnectionPending ()\n   {\n-    return blocking ? true : false;\n+    return connectionPending;\n   }\n     \n   public Socket socket ()\n@@ -118,67 +202,120 @@ public Socket socket ()\n \n   public int read (ByteBuffer dst) throws IOException\n   {\n+    if (!connected)\n+      throw new NotYetConnectedException();\n+    \n     byte[] data;\n-    int bytes = 0;\n-    int len = dst.remaining ();\n+    int offset = 0;\n+    int len = dst.remaining();\n \t\n-    if (!dst.hasArray ())\n+    if (dst.hasArray())\n       {\n-        data = new byte [len];\n-        dst.get (data, 0, len);\n+        offset = dst.arrayOffset() + dst.position();\n+        data = dst.array();\n       }\n     else\n       {\n-        data = dst.array ();\n+        data = new byte [len];\n       }\n+\n+    InputStream input = socket.getInputStream();\n+    int available = input.available();\n+\n+    if (available == 0)\n+      return 0;\n     \n-    return socket.getInputStream().read (data, 0, len);\n+    if (len > available)\n+      len = available;\n+\n+    int readBytes = 0;\n+    boolean completed = false;\n+\n+    try\n+      {\n+        begin();\n+        readBytes = input.read (data, offset, len);\n+        completed = true;\n+      }\n+    finally\n+      {\n+        end (completed);\n+      }\n+\n+    if (readBytes > 0\n+        && !dst.hasArray())\n+      {\n+        dst.put (data);\n+      }\n+\n+    return readBytes;\n   }\n     \n   public long read (ByteBuffer[] dsts, int offset, int length)\n     throws IOException\n   {\n-    long bytes = 0;\n+    if (!connected)\n+      throw new NotYetConnectedException();\n+    \n+    if ((offset < 0)\n+        || (offset > dsts.length)\n+        || (length < 0)\n+        || (length > (dsts.length - offset)))\n+      throw new IndexOutOfBoundsException();\n+      \n+    long readBytes = 0;\n \n-    for (int i = offset; i < length; i++)\n-      {\n-        bytes += read (dsts [i]);\n-      }\n+    for (int index = offset; index < length; index++)\n+      readBytes += read (dsts [index]);\n \n-    return bytes;\n+    return readBytes;\n   }\n      \n   public int write (ByteBuffer src)\n     throws IOException\n   {\n+    if (!connected)\n+      throw new NotYetConnectedException();\n+    \n     byte[] data;\n-    int bytes = 0;\n-    int len = src.remaining ();\n+    int offset = 0;\n+    int len = src.remaining();\n     \n-    if (!src.hasArray ())\n+    if (!src.hasArray())\n       {\n         data = new byte [len];\n         src.get (data, 0, len);\n       }\n     else\n       {\n-        data = src.array ();\n+        offset = src.arrayOffset() + src.position();\n+        data = src.array();\n       }\n-   \n-    socket.getOutputStream().write (data, 0, len);\n+\n+    System.out.println (\"INTERNAL: writing to socket outputstream\");\n+    \n+    OutputStream output = socket.getOutputStream();\n+    output.write (data, offset, len);\n     return len;\n   }\n \n   public long write (ByteBuffer[] srcs, int offset, int length)\n     throws IOException\n   {\n-    long bytes = 0;\n+    if (!connected)\n+      throw new NotYetConnectedException();\n+    \n+    if ((offset < 0)\n+        || (offset > srcs.length)\n+        || (length < 0)\n+        || (length > (srcs.length - offset)))\n+      throw new IndexOutOfBoundsException();\n+      \n+    long writtenBytes = 0;\n \n-    for (int i = offset; i < length; i++)\n-      {\n-        bytes += write (srcs [i]);\n-      }\n+    for (int index = offset; index < length; index++)\n+      writtenBytes += write (srcs [index]);\n \n-    return bytes;\n+    return writtenBytes;\n   }\n }"}]}