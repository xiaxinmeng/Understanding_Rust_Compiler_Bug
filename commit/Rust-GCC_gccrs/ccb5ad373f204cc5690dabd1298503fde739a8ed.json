{"sha": "ccb5ad373f204cc5690dabd1298503fde739a8ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NiNWFkMzczZjIwNGNjNTY5MGRhYmQxMjk4NTAzZmRlNzM5YThlZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-06-07T21:30:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-06-07T21:30:58Z"}, "message": "alias.c (get_alias_set): Be ready for TYPE_CANONICAL of ptr_type_node to not be ptr_to_node.\n\n\n\t* alias.c (get_alias_set): Be ready for TYPE_CANONICAL\n\tof ptr_type_node to not be ptr_to_node.\n\t* tree.c (gimple_types_compatible_p): Do not match TREE_CODE of\n\tTREE_TYPE of pointers.\n\t* gimple-expr.c (useless_type_conversion): Reorder the check for\n\tfunction pointers and TYPE_CANONICAL.\n\t* lto.c (hash_canonical_type): Do not hash TREE_CODE of TREE_TYPE of\n\tpointers.\n\t* gfortran.dg/lto/bind_c-1_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-1_1.c: New testcase.\n\t* gcc.dg/lto/c-compatible-types_0.c: Rename to ...\n\t* gcc.dg/lto/c-compatible-types-1_0.c: this one; fix template\n\t* gcc.dg/lto/c-compatible-types_1.c: Rename to ...\n\t* gcc.dg/lto/c-compatible-types-1_1.c: this one; harden for\n\t-fshort-enum.\n\nFrom-SVN: r224201", "tree": {"sha": "99c2edf394ef8a6f40706dc42eb4d7f0f1f7b48d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99c2edf394ef8a6f40706dc42eb4d7f0f1f7b48d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccb5ad373f204cc5690dabd1298503fde739a8ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb5ad373f204cc5690dabd1298503fde739a8ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb5ad373f204cc5690dabd1298503fde739a8ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb5ad373f204cc5690dabd1298503fde739a8ed/comments", "author": null, "committer": null, "parents": [{"sha": "d7b35f22be0a732140022245c766fa323f1a768d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b35f22be0a732140022245c766fa323f1a768d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b35f22be0a732140022245c766fa323f1a768d"}], "stats": {"total": 123, "additions": 100, "deletions": 23}, "files": [{"sha": "e1bd305f9739441c174587a79e4b3dfdcb14b241", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1,3 +1,12 @@\n+2015-06-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* alias.c (get_alias_set): Be ready for TYPE_CANONICAL\n+\tof ptr_type_node to not be ptr_to_node.\n+\t* tree.c (gimple_types_compatible_p): Do not match TREE_CODE of\n+\tTREE_TYPE of pointers.\n+\t* gimple-expr.c (useless_type_conversion): Reorder the check for\n+\tfunction pointers and TYPE_CANONICAL.\n+\n 2015-06-06  John David Anglin  <danglin@gcc.gnu.org>\n \n \tPR bootstrap/66319"}, {"sha": "6cc3aa2644e0ab24407f07cfc14c894a53d7267f", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1072,8 +1072,9 @@ get_alias_set (tree t)\n     }\n   /* In LTO the rules above needs to be part of canonical type machinery.\n      For now just punt.  */\n-  else if (POINTER_TYPE_P (t) && t != ptr_type_node && in_lto_p)\n-    set = get_alias_set (ptr_type_node);\n+  else if (POINTER_TYPE_P (t)\n+\t   && t != TYPE_CANONICAL (ptr_type_node) && in_lto_p)\n+    set = get_alias_set (TYPE_CANONICAL (ptr_type_node));\n \n   /* Otherwise make a new alias set for this type.  */\n   else"}, {"sha": "d2fbe22cfc1e21dcf9d78356d43f98f965166631", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -84,6 +84,12 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n       if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))\n \t  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))\n \treturn false;\n+      /* Do not lose casts to function pointer types.  */\n+      if ((TREE_CODE (TREE_TYPE (outer_type)) == FUNCTION_TYPE\n+\t   || TREE_CODE (TREE_TYPE (outer_type)) == METHOD_TYPE)\n+\t  && !(TREE_CODE (TREE_TYPE (inner_type)) == FUNCTION_TYPE\n+\t       || TREE_CODE (TREE_TYPE (inner_type)) == METHOD_TYPE))\n+\treturn false;\n     }\n \n   /* From now on qualifiers on value types do not matter.  */\n@@ -142,13 +148,6 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   else if (POINTER_TYPE_P (inner_type)\n \t   && POINTER_TYPE_P (outer_type))\n     {\n-      /* Do not lose casts to function pointer types.  */\n-      if ((TREE_CODE (TREE_TYPE (outer_type)) == FUNCTION_TYPE\n-\t   || TREE_CODE (TREE_TYPE (outer_type)) == METHOD_TYPE)\n-\t  && !(TREE_CODE (TREE_TYPE (inner_type)) == FUNCTION_TYPE\n-\t       || TREE_CODE (TREE_TYPE (inner_type)) == METHOD_TYPE))\n-\treturn false;\n-\n       /* We do not care for const qualification of the pointed-to types\n \t as const qualification has no semantic value to the middle-end.  */\n "}, {"sha": "d9dffefcbdc949db3c8a0f228dd6aa22ef911a62", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1,3 +1,8 @@\n+2015-06-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (hash_canonical_type): Do not hash TREE_CODE of TREE_TYPE of\n+\tpointers.\n+\n 2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* lto-lang.c (lto_write_globals): Remove."}, {"sha": "b93e512e08e8f2aa9710612eba37a4d1990ba98d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -337,12 +337,12 @@ hash_canonical_type (tree type)\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     hstate.add_int (TYPE_UNSIGNED (type));\n \n-  /* For pointer and reference types, fold in information about the type\n-     pointed to but do not recurse to the pointed-to type.  */\n+  /* Fortran standard define C_PTR type that is compatible with every\n+     C pointer.  For this reason we need to glob all pointers into one.\n+     Still pointers in different address spaces are not compatible.  */\n   if (POINTER_TYPE_P (type))\n     {\n       hstate.add_int (TYPE_ADDR_SPACE (TREE_TYPE (type)));\n-      hstate.add_int (TREE_CODE (TREE_TYPE (type)));\n     }\n \n   /* For integer types hash only the string flag.  */"}, {"sha": "71d38586c446aeb8c21088c9e10ddd1c3d5e4f42", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1,3 +1,13 @@\n+2015-06-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gfortran.dg/lto/bind_c-1_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-1_1.c: New testcase.\n+\t* gcc.dg/lto/c-compatible-types_0.c: Rename to ...\n+\t* gcc.dg/lto/c-compatible-types-1_0.c: this one; fix template\n+\t* gcc.dg/lto/c-compatible-types_1.c: Rename to ...\n+\t* gcc.dg/lto/c-compatible-types-1_1.c: this one; harden for\n+\t-fshort-enum.\n+\n 2015-06-06  Thomas Koenig  <tkoenig@netcologne.de>\n \n \tPR fortran/47659"}, {"sha": "376da00599d04a738b8b5d6c6d3625d915cae83b", "filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types-1_0.c", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_0.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1,6 +1,5 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O3\" } */\n-/* { dg-skip-if \"require -fno-short-enums to work\" {target short_enums} } */\n+/* { dg-lto-do run } */\n+/* { dg-lto-options \"-O3\" } */\n \n /* By C standard Each enumerated type shall be compatible with char, a  signed\n    integer, type, or an unsigned integer type. The choice of type is", "previous_filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types_0.c"}, {"sha": "40cd07ddbbb2a477e64c7d051910fe08a1601593", "filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types-1_1.c", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types-1_1.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -1,4 +1,5 @@\n-enum a {test1, test2};\n+#include <limits.h>\n+enum a {test1, test2, test3=INT_MAX};\n enum a a;\n enum a *b;\n ", "previous_filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types_1.c"}, {"sha": "79be99a53c542d585ef5557af0c5aecaaaf12104", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-1_0.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_0.f90?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if C_PTR is not interoperable with both int *\n+! and float *\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type, bind(c) :: MYFTYPE_1\n+     type(c_ptr) :: ptr\n+     type(c_ptr) :: ptrb\n+  end type MYFTYPE_1\n+\n+  type(myftype_1), bind(c, name=\"myVar\") :: myVar\n+\n+contains\n+  subroutine types_test() bind(c)\n+    myVar%ptr = myVar%ptrb\n+  end subroutine types_test\n+end module lto_type_merge_test\n+"}, {"sha": "2e5a415ed994340e6ceab8428d0b72bb1b9638b2", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-1_1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-1_1.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -0,0 +1,36 @@\n+#include <stdlib.h>\n+/* interopse with myftype_1 */\n+typedef struct {\n+   float *ptr;\n+   int *ptr2;\n+} myctype_t;\n+\n+\n+extern void abort(void);\n+void types_test(void);\n+/* declared in the fortran module */\n+extern myctype_t myVar;\n+\n+int main(int argc, char **argv)\n+{\n+   myctype_t *cptr;\n+   asm(\"\":\"=r\"(cptr):\"0\"(&myVar));\n+   cptr->ptr = (float *)(size_t) (void *)1;\n+   cptr->ptr2 = (int *)(size_t) (void *)2;\n+\n+   types_test();\n+\n+   if(cptr->ptr != (float *)(size_t) (void *)2)\n+      abort();\n+   if(cptr->ptr2 != (int *)(size_t) (void *)2)\n+      abort();\n+   myVar.ptr2 = (int *)(size_t) (void *)3;\n+   types_test();\n+\n+   if(myVar.ptr != (float *)(size_t) (void *)3)\n+      abort();\n+   if(myVar.ptr2 != (int *)(size_t) (void *)3)\n+      abort();\n+   return 0;\n+}\n+"}, {"sha": "e92e63f91a758f982480987f39865cba7584f389", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb5ad373f204cc5690dabd1298503fde739a8ed/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ccb5ad373f204cc5690dabd1298503fde739a8ed", "patch": "@@ -12958,18 +12958,14 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n \t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n \treturn false;\n \n-      /* For canonical type comparisons we do not want to build SCCs\n-\t so we cannot compare pointed-to types.  But we can, for now,\n-\t require the same pointed-to type kind and match what\n-\t useless_type_conversion_p would do.  */\n+      /* Fortran standard define C_PTR type that is compatible with every\n+ \t C pointer.  For this reason we need to glob all pointers into one.\n+\t Still pointers in different address spaces are not compatible.  */\n       if (POINTER_TYPE_P (t1))\n \t{\n \t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n \t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n \t    return false;\n-\n-\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n-\t    return false;\n \t}\n \n       /* Tail-recurse to components.  */"}]}