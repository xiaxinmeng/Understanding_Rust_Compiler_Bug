{"sha": "18c2f7a740a61e317e1911ee0ad7dea6043ea511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjMmY3YTc0MGE2MWUzMTdlMTkxMWVlMGFkN2RlYTYwNDNlYTUxMQ==", "commit": {"author": {"name": "Michael Meissner", "email": "Michael Meissner meissner@linux.ibm.com", "date": "2020-05-05T17:32:22Z"}, "committer": {"name": "Michael Meissner", "email": "Michael Meissner meissner@linux.ibm.com", "date": "2020-05-05T17:32:22Z"}, "message": "Patch ieee128-lib-patch004b", "tree": {"sha": "bd89c4f0350150d2650b4b5a58f95bc5282ca8ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd89c4f0350150d2650b4b5a58f95bc5282ca8ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18c2f7a740a61e317e1911ee0ad7dea6043ea511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c2f7a740a61e317e1911ee0ad7dea6043ea511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c2f7a740a61e317e1911ee0ad7dea6043ea511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c2f7a740a61e317e1911ee0ad7dea6043ea511/comments", "author": null, "committer": null, "parents": [{"sha": "6034b9ca2428c073af950db3447bec785216ed05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6034b9ca2428c073af950db3447bec785216ed05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6034b9ca2428c073af950db3447bec785216ed05"}], "stats": {"total": 148, "additions": 97, "deletions": 51}, "files": [{"sha": "342a439dafdaa60249990c12d5e6e10f56585b1b", "filename": "gcc/ChangeLog.meissner", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c2f7a740a61e317e1911ee0ad7dea6043ea511/gcc%2FChangeLog.meissner", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c2f7a740a61e317e1911ee0ad7dea6043ea511/gcc%2FChangeLog.meissner", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.meissner?ref=18c2f7a740a61e317e1911ee0ad7dea6043ea511", "patch": "@@ -1,3 +1,10 @@\n+2020-05-05  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t(ieee128-lib-patch004b)\n+\t* config/rs6000/rs6000.c (rs6000_mangle_decl_assembler_name): Add\n+\tspecial cases for built-in functions that return or use long\n+\tdouble, but don't end in 'l'.\n+\n 2020-05-05  Michael Meissner  <meissner@linux.ibm.com>\n \n \t(ieee128-lib-patch002b)"}, {"sha": "6271d4c00e0ae1d162152d2eaf59281d036e2dfb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c2f7a740a61e317e1911ee0ad7dea6043ea511/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c2f7a740a61e317e1911ee0ad7dea6043ea511/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=18c2f7a740a61e317e1911ee0ad7dea6043ea511", "patch": "@@ -26335,75 +26335,114 @@ static tree\n rs6000_mangle_decl_assembler_name (tree decl, tree id)\n {\n   if (TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n-      && TREE_CODE (decl) == FUNCTION_DECL && DECL_IS_BUILTIN (decl) )\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      && fndecl_built_in_p (decl, BUILT_IN_NORMAL))\n     {\n       size_t len = IDENTIFIER_LENGTH (id);\n       const char *name = IDENTIFIER_POINTER (id);\n+      const char *newname = NULL;\n \n-      /* Update the __builtin_*printf && __builtin_*scanf functions.  */\n-      const size_t printf_len = sizeof (\"printf\") - 1;\n-      const size_t scanf_len = sizeof (\"scanf\") - 1;\n-      const size_t printf_extra = sizeof (\"__\") - 1 + sizeof (\"ieee128\") - 1;\n-      const size_t scanf_extra = sizeof (\"__isoc99_\") - 1 + sizeof (\"ieee128\") - 1;\n-\n-      if (len >= printf_len\n-\t  && strcmp (name + len - printf_len, \"printf\") == 0)\n-\t{\n-\t  char *newname = (char *) alloca (len + 1 + printf_extra);\n-\t  strcpy (newname, \"__\");\n-\t  memcpy (newname + 2, name, len);\n-\t  strcpy (newname + 2 + len, \"ieee128\");\n-\t  id = get_identifier (newname);\n-\t}\n-\n-      else if (len >= scanf_len\n-\t       && strcmp (name + len - scanf_len, \"scanf\") == 0)\n+      /* See if it is one of the built-in functions with an unusual name.  */\n+      switch (DECL_FUNCTION_CODE (decl))\n \t{\n-\t  char *newname = (char *) alloca (len + 1 + scanf_extra);\n-\t  strcpy (newname, \"__isoc99_\");\n-\t  memcpy (newname + sizeof (\"__isoc99\") - 1, name, len);\n-\t  strcpy (newname + sizeof (\"__isoc99\") - 1 + len, \"ieee128\");\n-\t  id = get_identifier (newname);\n+\tdefault:\n+\t  break;\n+\n+\tcase BUILT_IN_GAMMAL_R:\n+\tcase BUILT_IN_LGAMMAL_R:\n+\t  newname = \"__lgammaieee128_r\";\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARD:\n+\t  newname = \"__nexttoward_to_ieee128\";\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARDF:\n+\t  newname = \"__nexttowardf_to_ieee128\";\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARDL:\n+\t  newname = \"__nexttowardieee128\";\n+\t  break;\n \t}\n \n-      else if (name[len - 1] == 'l')\n+      /* Update the __builtin_*printf && __builtin_*scanf functions.  */\n+      if (!newname)\n \t{\n-\t  bool uses_ieee128_p = false;\n-\t  tree type = TREE_TYPE (decl);\n-\t  machine_mode ret_mode = TYPE_MODE (type);\n+\t  const size_t printf_len = sizeof (\"printf\") - 1;\n+\t  const size_t scanf_len = sizeof (\"scanf\") - 1;\n+\t  const size_t printf_extra\n+\t    = sizeof (\"__\") - 1 + sizeof (\"ieee128\") - 1;\n+\t  const size_t scanf_extra\n+\t    = sizeof (\"__isoc99_\") - 1 + sizeof (\"ieee128\") - 1;\n \n-\t  /* See if the function returns a IEEE 128-bit floating point type or\n-\t     complex type.  */\n-\t  if (ret_mode == TFmode || ret_mode == TCmode)\n-\t    uses_ieee128_p = true;\n-\t  else\n+\t  if (len >= printf_len\n+\t      && strcmp (name + len - printf_len, \"printf\") == 0)\n \t    {\n-\t      function_args_iterator args_iter;\n-\t      tree arg;\n+\t      char *name2 = (char *) alloca (len + 1 + printf_extra);\n+\t      strcpy (name2, \"__\");\n+\t      memcpy (name2 + 2, name, len);\n+\t      strcpy (name2 + 2 + len, \"ieee128\");\n+\t      newname = (const char *) name2;\n+\t    }\n \n-\t      /* See if the function passes a IEEE 128-bit floating point type\n-\t\t or complex type.  */\n-\t      FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n+\t  else if (len >= scanf_len\n+\t\t   && strcmp (name + len - scanf_len, \"scanf\") == 0)\n+\t    {\n+\t      char *name2 = (char *) alloca (len + 1 + scanf_extra);\n+\t      strcpy (name2, \"__isoc99_\");\n+\t      memcpy (name2 + sizeof (\"__isoc99\") - 1, name, len);\n+\t      strcpy (name2 + sizeof (\"__isoc99\") - 1 + len, \"ieee128\");\n+\t      newname = (const char *) name2;\n+\t    }\n+\n+\t  else if (name[len - 1] == 'l')\n+\t    {\n+\t      bool uses_ieee128_p = false;\n+\t      tree type = TREE_TYPE (decl);\n+\t      machine_mode ret_mode = TYPE_MODE (type);\n+\n+\t      /* See if the function returns a IEEE 128-bit floating point type or\n+\t\t complex type.  */\n+\t      if (ret_mode == TFmode || ret_mode == TCmode)\n+\t\tuses_ieee128_p = true;\n+\t      else\n \t\t{\n-\t\t  machine_mode arg_mode = TYPE_MODE (arg);\n-\t\t  if (arg_mode == TFmode || arg_mode == TCmode)\n+\t\t  function_args_iterator args_iter;\n+\t\t  tree arg;\n+\n+\t\t  /* See if the function passes a IEEE 128-bit floating point type\n+\t\t     or complex type.  */\n+\t\t  FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n \t\t    {\n-\t\t      uses_ieee128_p = true;\n-\t\t      break;\n+\t\t      machine_mode arg_mode = TYPE_MODE (arg);\n+\t\t      if (arg_mode == TFmode || arg_mode == TCmode)\n+\t\t\t{\n+\t\t\t  uses_ieee128_p = true;\n+\t\t\t  break;\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t    }\n \n-\t  /* If we passed or returned an IEEE 128-bit floating point type,\n-\t     change the name.  */\n-\t  if (uses_ieee128_p)\n-\t    {\n-\t      char *name2 = (char *) alloca (len + 4);\n-\t      memcpy (name2, name, len - 1);\n-\t      strcpy (name2 + len - 1, \"f128\");\n-\t      id = get_identifier (name2);\n+\t      /* If we passed or returned an IEEE 128-bit floating point type,\n+\t\t change the name.  */\n+\t      if (uses_ieee128_p)\n+\t\t{\n+\t\t  char *name2 = (char *) alloca (len + 4);\n+\t\t  memcpy (name2, name, len - 1);\n+\t\t  strcpy (name2 + len - 1, \"f128\");\n+\t\t  newname = (const char *) name2;\n+\t\t}\n \t    }\n \t}\n+\n+      if (newname)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"Map %s => %s\\n\", name, newname);\n+\n+\t  id = get_identifier (newname);\n+\t}\n     }\n \n   return id;"}]}