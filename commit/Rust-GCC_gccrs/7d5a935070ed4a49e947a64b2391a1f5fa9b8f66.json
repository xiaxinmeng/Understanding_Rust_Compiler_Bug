{"sha": "7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "node_id": "C_kwDOANBUbNoAKDdkNWE5MzUwNzBlZDRhNDllOTQ3YTY0YjIzOTFhMWY1ZmE5YjhmNjY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-02-13T11:38:45Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-02-13T11:38:45Z"}, "message": "ifcvt: Fix regression in aarch64/fcsel_1.c\n\naarch64/fcsel_1.c contains:\n\ndouble\nf_2 (double a, double b, double c, double d)\n{\n  if (a > b)\n    return c;\n  else\n    return d;\n}\n\nwhich started failing in the GCC 12 timeframe.  When it passed,\nthe RTL had the form:\n\n[A]\n  (set (reg ret) (reg c))\n  (set (pc) (if_then_else (gt ...) (label_ref ret) (pc)))\n    edge to ret, fallthru to else\nelse:\n  (set (reg ret) (reg d))\n    fallthru to ret\nret:\n  ...exit...\n\ni.e. a branch around.  Now the RTL has form:\n\n[B]\n  (set (reg ret) (reg d))\n  (set (pc) (if_then_else (gt ...) (label_ref then) (pc)))\n    edge to then, fallthru to ret\nret:\n  ...exit...\n\nthen:\n  (set (reg ret) (reg c))\n    edge to ret\n\ni.e. a branch out.\n\nBoth are valid, of course, and there's no easy way to predict\nwhich we'll get.  But ifcvt canonicalises its representation on:\n\n  if (cond) goto fallthru else goto non-fallthru\n\nThat is, it canoncalises on the branch-around case for half-diamonds.\nIt therefore wants to invert the comparison in [B] to get:\n\n  if (...) goto ret else goto then\n\nBut that isn't possible for strict FP gt, so the optimisation fails.\n\nCanonicalising on the branch-around case seems like the wrong choice for\nhalf diamonds.  The natural way of expressing a conditional branch is\nfor the label_ref to be the \"then\" destination and pc to be the \"else\"\ndestination.  And the natural choice of condition seems to be the one\nunder which extra stuff *is* done, rather than the one under which extra\nstuff *isn't* done.  But that decision goes back at least 20 years and\nit doesn't seem like a good idea to change it in stage 4.\n\nThis patch instead allows the internal structure to store the\ncondition in inverted form.  For simplicity it handles only\nconditional moves, which is the one case that is needed\nto fix the known regression.  (There are probably unknown\nregressions too, but still.)\n\ngcc/\n\t* ifcvt.h (noce_if_info::cond_inverted): New field.\n\t* ifcvt.cc (cond_move_convert_if_block): Swap the then and else\n\tvalues when cond_inverted is true.\n\t(noce_find_if_block): Allow the condition to be inverted when\n\thandling conditional moves.", "tree": {"sha": "c74a6121b29d19d3b19e411d67937a7adf91abf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c74a6121b29d19d3b19e411d67937a7adf91abf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e191d19b5c182c9e919ca2a331e52b68132f7ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e191d19b5c182c9e919ca2a331e52b68132f7ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e191d19b5c182c9e919ca2a331e52b68132f7ac"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "e4168d95ad9fd158d11226648e7988984a47f963", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "patch": "@@ -4253,6 +4253,9 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n \t    e = dest;\n \t}\n \n+      if (if_infop->cond_inverted)\n+\tstd::swap (t, e);\n+\n       target = noce_emit_cmove (if_infop, dest, code, cond_arg0, cond_arg1,\n \t\t\t\tt, e);\n       if (!target)\n@@ -4405,7 +4408,6 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   basic_block then_bb, else_bb, join_bb;\n   bool then_else_reversed = false;\n   rtx_insn *jump;\n-  rtx cond;\n   rtx_insn *cond_earliest;\n   struct noce_if_info if_info;\n   bool speed_p = optimize_bb_for_speed_p (test_bb);\n@@ -4481,25 +4483,28 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   if (! onlyjump_p (jump))\n     return FALSE;\n \n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  cond = noce_get_condition (jump, &cond_earliest, then_else_reversed);\n-  if (!cond)\n-    return FALSE;\n-\n-  /* We must be comparing objects whose modes imply the size.  */\n-  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n-    return FALSE;\n-\n   /* Initialize an IF_INFO struct to pass around.  */\n   memset (&if_info, 0, sizeof if_info);\n   if_info.test_bb = test_bb;\n   if_info.then_bb = then_bb;\n   if_info.else_bb = else_bb;\n   if_info.join_bb = join_bb;\n-  if_info.cond = cond;\n+  if_info.cond = noce_get_condition (jump, &cond_earliest,\n+\t\t\t\t     then_else_reversed);\n   rtx_insn *rev_cond_earliest;\n   if_info.rev_cond = noce_get_condition (jump, &rev_cond_earliest,\n \t\t\t\t\t !then_else_reversed);\n+  if (!if_info.cond && !if_info.rev_cond)\n+    return FALSE;\n+  if (!if_info.cond)\n+    {\n+      std::swap (if_info.cond, if_info.rev_cond);\n+      std::swap (cond_earliest, rev_cond_earliest);\n+      if_info.cond_inverted = true;\n+    }\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (if_info.cond, 0)) == BLKmode)\n+    return FALSE;\n   gcc_assert (if_info.rev_cond == NULL_RTX\n \t      || rev_cond_earliest == cond_earliest);\n   if_info.cond_earliest = cond_earliest;\n@@ -4518,7 +4523,9 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n \n   /* Do the real work.  */\n \n-  if (noce_process_if_block (&if_info))\n+  /* ??? noce_process_if_block has not yet been updated to handle\n+     inverted conditions.  */\n+  if (!if_info.cond_inverted && noce_process_if_block (&if_info))\n     return TRUE;\n \n   if (HAVE_conditional_move"}, {"sha": "be1385aabe408d0ef473b675dba9406d2df54d08", "filename": "gcc/ifcvt.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66/gcc%2Fifcvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5a935070ed4a49e947a64b2391a1f5fa9b8f66/gcc%2Fifcvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.h?ref=7d5a935070ed4a49e947a64b2391a1f5fa9b8f66", "patch": "@@ -86,6 +86,14 @@ struct noce_if_info\n      form as well.  */\n   bool then_else_reversed;\n \n+  /* True if THEN_BB is conditional on !COND rather than COND.\n+     This is used if:\n+\n+     - JUMP branches to THEN_BB on COND\n+     - JUMP falls through to JOIN_BB on !COND\n+     - COND cannot be reversed.  */\n+  bool cond_inverted;\n+\n   /* True if the contents of then_bb and else_bb are a\n      simple single set instruction.  */\n   bool then_simple;"}]}