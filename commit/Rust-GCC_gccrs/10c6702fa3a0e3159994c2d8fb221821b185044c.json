{"sha": "10c6702fa3a0e3159994c2d8fb221821b185044c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjNjcwMmZhM2EwZTMxNTk5OTRjMmQ4ZmIyMjE4MjFiMTg1MDQ0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:13:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:13:36Z"}, "message": "Initial revision\n\nFrom-SVN: r11451", "tree": {"sha": "ded0838b24edc2cd66a999933d2d6d89fc018adb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ded0838b24edc2cd66a999933d2d6d89fc018adb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c6702fa3a0e3159994c2d8fb221821b185044c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c6702fa3a0e3159994c2d8fb221821b185044c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c6702fa3a0e3159994c2d8fb221821b185044c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c6702fa3a0e3159994c2d8fb221821b185044c/comments", "author": null, "committer": null, "parents": [{"sha": "749815a2e8588045735b2e9a1499b12721408431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749815a2e8588045735b2e9a1499b12721408431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749815a2e8588045735b2e9a1499b12721408431"}], "stats": {"total": 206, "additions": 206, "deletions": 0}, "files": [{"sha": "f94a2076502c3040d1d0be31db8bfc4f69f4fc99", "filename": "gcc/objc/THREADS", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6702fa3a0e3159994c2d8fb221821b185044c/gcc%2Fobjc%2FTHREADS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6702fa3a0e3159994c2d8fb221821b185044c/gcc%2Fobjc%2FTHREADS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FTHREADS?ref=10c6702fa3a0e3159994c2d8fb221821b185044c", "patch": "@@ -0,0 +1,206 @@\n+This file describes in little detail the modifications to the\n+Objective-C runtime needed to make it thread safe. \n+\n+First off, kudos to Galen Hunt who is the author of this great work.\n+\n+If you have an comments or just want to know where to\n+send me money to express your undying graditude for threading the\n+Objective-C runtime you can reach Galen at:\n+\n+\tgchunt@cs.rochester.edu\n+\n+Any questions, comments, bug reports, etc. should send email either to the\n+GCC bug account or to:\n+\n+\tScott Christley <scottc@ocbi.com>\n+\n+******************************************************************************\n+* Simple test program:\n+\n+A simple test program can be found in the thread-test directory.\n+\n+******************************************************************************\n+* Sarray Threading:\n+\n+The most critical component of the Objective-C runtime is the sparse array\n+structure (sarray).  Sarrays store object selectors and implementations.  \n+Following in the tradition of the Objective-C runtime, my threading\n+support assumes that fast message dispatching is far more important\n+than *ANY* and *ALL* other operations.  The message dispatching thus\n+uses *NO* locks on any kind.  In fact, if you look in sarray.h, you\n+will notice that the message dispatching has not been modified.\n+Instead, I have modified the sarray management functions so that all\n+updates to the sarray data structure can be made in parallel will\n+message dispatching.  \n+\n+To support concurrent message dispatching, no dynamically allocated\n+sarray data structures are freed while more than one thread is\n+operational.  Sarray data structures that are no longer in use are\n+kept in a linked list of garbage and are released whenever the program\n+is operating with a single thread.  The programmer can also flush the \n+garbage list by calling sarray_remove_garbage when the programmer can\n+ensure that no message dispatching is taking place concurrently.  The\n+amount of un-reclaimed sarray garbage should normally be extremely\n+small in a real program as sarray structures are freed only when using\n+the \"poseAs\" functionality and early in program initialization, which\n+normally occurs while the program is single threaded.\n+\n+******************************************************************************\n+* Static Variables:\n+\n+The following variables are either statically or globally defined. This list \n+does not include variables which are internal to implementation dependent \n+versions of thread-*.c.\n+\n+The following threading designations are used:\n+\tSAFE   : Implicitly thread safe.\n+\tSINGLE : Must only be used in single thread mode.\n+\tMUTEX  : Protected by single global mutex objc_runtime_mutex.\n+\tUNUSED : Not used in the runtime.\n+\n+Variable Name:\t\t\tUsage:  Defined:\tAlso used in:\n+===========================\t======\t============\t=====================\n+__objc_class_hash\t\tMUTEX\tclass.c\n+__objc_class_links_resolved\tUNUSED\tclass.c\t\truntime.h\n+__objc_class_number\t\tMUTEX\tclass.c\n+__objc_dangling_categories\tUNUSED\tinit.c\n+__objc_module_list\t\tMUTEX\tinit.c\n+__objc_selector_array\t\tMUTEX\tselector.c\n+__objc_selector_hash\t\tMUTEX\tselector.c\n+__objc_selector_max_index\tMUTEX\tselector.c\tsendmsg.c runtime.h\n+__objc_selector_names\t\tMUTEX\tselector.c\n+__objc_thread_exit_status\tSAFE\tthread.c\n+__objc_uninstalled_dtable\tMUTEX\tsendmsg.c\tselector.c\n+_objc_load_callback\t\tSAFE\tinit.c\t\tobjc-api.h\n+_objc_lookup_class\t\tSAFE\tclass.c\t\tobjc-api.h\n+_objc_object_alloc\t\tSINGLE\tobjects.c\tobjc-api.h\n+_objc_object_copy\t\tSINGLE\tobjects.c\tobjc-api.h\n+_objc_object_dispose\t\tSINGLE\tobjects.c\tobjc-api.h\n+frwd_sel\t\t\tSAFE2\tsendmsg.c\n+idxsize\t\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+initialize_sel\t\t\tSAFE2\tsendmsg.c\n+narrays\t\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+nbuckets\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+nindices\t\t\tMUTEX\tsarray.c\tsarray.h\n+previous_constructors\t\tSAFE1\tinit.c\n+proto_class\t\t\tSAFE1\tinit.c\n+unclaimed_categories\t\tMUTEX\tinit.c\n+unclaimed_proto_list\t\tMUTEX\tinit.c\n+uninitialized_statics\t\tMUTEX\tinit.c\n+\n+Notes:\n+1) Initialized once in unithread mode.\n+2) Initialized value will always be same, guaranteed by lock on selector \n+   hash table.\n+\n+******************************************************************************\n+* Linking:\n+\n+On Solaris, you must link with -lthread to include the system\n+thread library.  We use its low level thread and mutex implementations.\n+\n+On OSF/1, you must link with -lpthreads to include the pthreads library.\n+\n+On WIN32, thread support is built-in to the WIN32 API; refer to your\n+compiler documentation for the appropriate library.\n+\n+******************************************************************************\n+* Threads:\n+\n+The thread system attempts to create multiple threads using whatever\n+operating system or library thread support is available.  It does\n+assume that all system functions are thread safe.  Notably this means\n+that the system implementation of malloc and free must be thread safe.\n+If a system has multiple processors, the threads are configured for\n+full parallel processing.\n+\n+__objc_init_thread_system(void), int\n+\tInitialize the thread subsystem.  Call once by __objc_exec_class.\n+\n+__objc_fini_thread_system(void), int\n+\tCloses the thread subsystem.\n+\n+objc_thread_detach(SEL selector, id object, id argument), int\n+\tCreates and detaches a new thread.  The new thread starts by\n+\tsending the given selector with a single argument to the\n+\tgiven object.\n+\n+objc_thread_set_priority(int priority), int\n+\tSets a threads relative priority within the program.  Valid\n+\toptions are:\n+\t\n+\tOBJC_THREAD_INTERACTIVE_PRIORITY\n+\tOBJC_THREAD_BACKGROUND_PRIORITY\n+\tOBJC_THREAD_LOW_PRIORITY\n+\n+objc_thread_get_priority(void), int\n+\tQuery a threads priority.\n+\n+objc_thread_yield(void), void\n+\tYields processor to another thread with equal or higher\n+\tpriority.  It is up to the system scheduler to determine if\n+\tthe processor is taken or not.\n+\n+objc_thread_exit(void), int\n+\tTerminates a thread.  If this is the last thread executing\n+\tthen the program will terminate.\n+\n+objc_thread_id(void), int\n+\tReturns the current thread's id.\n+\n+objc_thread_set_data(void *value), int\n+\tSet a pointer to the thread's local storage.  Local storage is\n+\tthread specific.\n+\n+objc_thread_get_data(void), void *\n+\tReturns the pointer to the thread's local storage.\n+\n+******************************************************************************\n+* Mutexs:\n+\n+Mutexs can be locked recursively.  Each mutex locked mutex remembers\n+its owner (by thread id) and how many times it has been locked.  The\n+last unlock on a mutex removes the system lock and allows other\n+threads to access the mutex.\n+\n+objc_mutex_allocate(void), Mutex_t\n+\tAllocates a new mutex.  Mutex is initially unlocked.\n+\n+objc_mutex_deallocate(Mutex_t mutex), int\n+\tFree a mutex.  Before freeing the mutex, makes sure that no\n+\tone else is using it.\n+\n+objc_mutex_lock(Mutex_t mutex), int\n+\tLocks a mutex.  As mentioned earlier, the same thread may call\n+\tthis routine repeatedly.\n+\t\n+objc_mutex_trylock(Mutex_t mutex), int\n+\tAttempts to lock a mutex.  Returns -1 if failed.  If lock on\n+\tmutex can be acquired then function operates exactly as\n+\tobjc_mutex_lock.\n+\n+objc_mutex_unlock(Mutex_t mutex), int\n+\tUnlocks the mutex by one level.  Other threads may not acquire\n+\tthe mutex until this thread has released all locks on it.\n+\n+******************************************************************************\n+* Sample run of thread-test/checks/test01.m\n+\n+<< program started >>\t\t\t\t-- Program started\n+__objc_exec_class(Object.m)\t\t\t-- Initialize once \n+__objc_init_mutex_system\n+__objc_init_thread_system\n+__objc_init_selector_tables()  \n+__objc_init_class_tables()  \n+__objc_init_dispatch_tables() \n+__objc_exec_class(Protocol.m)\t\t\t-- Called repeatedly\n+__objc_init_protocols(0x000746d4) \t\t-- Called repeatedly\n+class_add_method_list(0x74718, 0x74208) \t-- Called repeatedly\n+<< main called >>\t\t\t\t-- Main called\n+__objc_init_install_dtable(0x6d980, 0x6d5c0)    -- Called repeatedly\n+<< delegatePool filled, count=10 >>\t\t-- Code in secondary function\n+__objc_init_install_dtable(0x76268, 0x70614)    -- Called repeatedly\n+Array: count=1\t\t\t\t\t-- More secondary code.\n+EltNodeCollector: count=1\n+<< end of program >>\t\t\t\t-- End of program\n+"}]}