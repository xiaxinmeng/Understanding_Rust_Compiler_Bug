{"sha": "73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjZTRkMWVkNjhhMmY0ZTM2YzI3YmU2MDRjZTM1YzI0MjA0OGY5ZA==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2010-07-23T05:33:51Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2010-07-23T05:33:51Z"}, "message": "re PR lto/44992 (ld -r breaks LTO)\n\ngcc:\n\n2010-07-10   Andi Kleen <ak@linux.intel.com>\n\n        PR lto/44992\n        * lto-opts.c (lto_write_options): Add NULL file_data argument to \n\tlto_get_section_name.\n\t* lto-section-out.c (lto_destroy_simple_output_block): Likewise.\n\t* lto-streamer-out.c (produce_asm): Likewise.\n\t(copy_function): Likewise.\n\t(produce_symtab): Likewise.\n\t(produce_asm_for_decls): Likewise.\n\t* lto-streamer.c (lto_get_section_name): Add file_data argument.\t\n\tRewrite to add random postfix to LTO sections.\n\t* lto-streamer.h (lto_file_decl_data): Add next, id, resolutions.\n\t(lto_get_section_name): Add file_data argument to prototype.\n\t\n\nlto:\n\n2010-07-10   Andi Kleen <ak@linux.intel.com>\n\n        PR lto/44992\n        * lto.c: Include splay-tree.h\n\t(lto_resolution_read): Change to walk file_ids tree and parse\n\textra file_id in resolution file.\n\t(lto_section_with_id): Add.\n\t(create_subid_section_table): Add.\n\t(lwstate): Add.\n\t(lto_create_files_from_ids): Add.\n\t(lto_file_read): Change to handle sub file ids and create list\n\tof file_datas. Add output argument for count.\n\t(get_section_data): Pass file_data to lto_get_section_name.\n\t(lto_flatten_file): Add.\n\t(read_cgraph_and_symbols): Handle linked lists of file_datas.\n\t\nlto-plugin:\n\n2010-07-10   Andi Kleen <ak@linux.intel.com>\n\n        PR lto/44992\n        * lto-plugin.c (sym_aux): Add.\n\t(plugin_symtab): Remove slots. Add aux and id.\n\t(parse_table_entry): Change to use aux instead of slots.\n\t(LTO_SECTION_PREFIX): Add.\n\t(translate): Improve buffer allocation. Change to append\n\tsymbols to existing out buffer.\n\t(get_section): Remove.\n\t(process_symtab): Add. \n\t(free_2): Free symtab->aux.\n\t(write_resolution): Handle aux instead of slots.\n\tPrint sub id to resolution file.\n\t(claim_file_handler): Clear lto_file. Replace get_symtab/translate\n\tcalls with call to process_symtab.\n\nFrom-SVN: r162443", "tree": {"sha": "50e055bbea281c232261eb1e07af42e60ab3a165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50e055bbea281c232261eb1e07af42e60ab3a165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/comments", "author": null, "committer": null, "parents": [{"sha": "0011a34c22ab26fc474b70bb7773bdf2f95c8d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0011a34c22ab26fc474b70bb7773bdf2f95c8d6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0011a34c22ab26fc474b70bb7773bdf2f95c8d6f"}], "stats": {"total": 488, "additions": 341, "deletions": 147}, "files": [{"sha": "99635b600ae99f964551b9fa0031da3fc7e3dd9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -1,3 +1,18 @@\n+2010-07-10   Andi Kleen <ak@linux.intel.com>\n+\n+\tPR lto/44992\n+        * lto-opts.c (lto_write_options): Add NULL file_data argument to\n+\tlto_get_section_name.\n+\t* lto-section-out.c (lto_destroy_simple_output_block): Likewise.\n+\t* lto-streamer-out.c (produce_asm): Likewise.\n+\t(copy_function): Likewise.\n+\t(produce_symtab): Likewise.\n+\t(produce_asm_for_decls): Likewise.\n+\t* lto-streamer.c (lto_get_section_name): Add file_data argument.\n+\tRewrite to add random postfix to LTO sections.\n+\t* lto-streamer.h (lto_file_decl_data): Add next, id, resolutions.\n+\t(lto_get_section_name): Add file_data argument to prototype.\n+\n 2010-07-10   Andi Kleen <ak@linux.intel.com>\n \n \t* lto-opts.c (lto_read_file_options): Check for missing section."}, {"sha": "fa52f953608318b980c3ebaa8037c0f40cd86413", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -294,7 +294,7 @@ output_options (struct lto_output_stream *stream)\n void\n lto_write_options (void)\n {\n-  char *const section_name = lto_get_section_name (LTO_section_opts, NULL);\n+  char *const section_name = lto_get_section_name (LTO_section_opts, NULL, NULL);\n   struct lto_output_stream stream;\n   struct lto_simple_header header;\n   struct lto_output_stream *header_stream;"}, {"sha": "e9b7b0a70fa7a8505c9e1366d7e5b24730b8e98e", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -486,7 +486,7 @@ lto_destroy_simple_output_block (struct lto_simple_output_block *ob)\n   struct lto_simple_header header;\n   struct lto_output_stream *header_stream;\n \n-  section_name = lto_get_section_name (ob->section_type, NULL);\n+  section_name = lto_get_section_name (ob->section_type, NULL, NULL);\n   lto_begin_section (section_name, !flag_wpa);\n   free (section_name);\n "}, {"sha": "c96c13aeefe6ca34bed1fe3a1f2c3c44067ce789", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -1810,10 +1810,10 @@ produce_asm (struct output_block *ob, tree fn)\n   if (section_type == LTO_section_function_body)\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fn));\n-      section_name = lto_get_section_name (section_type, name);\n+      section_name = lto_get_section_name (section_type, name, NULL);\n     }\n   else\n-    section_name = lto_get_section_name (section_type, NULL);\n+    section_name = lto_get_section_name (section_type, NULL, NULL);\n \n   lto_begin_section (section_name, !flag_wpa);\n   free (section_name);\n@@ -2041,7 +2041,7 @@ copy_function (struct cgraph_node *node)\n   size_t len;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function));\n   char *section_name =\n-    lto_get_section_name (LTO_section_function_body, name);\n+    lto_get_section_name (LTO_section_function_body, name, NULL);\n   size_t i, j;\n   struct lto_in_decl_state *in_state;\n   struct lto_out_decl_state *out_state = lto_get_out_decl_state ();\n@@ -2398,7 +2398,7 @@ produce_symtab (struct output_block *ob,\n \t        cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_streamer_cache_d *cache = ob->writer_cache;\n-  char *section_name = lto_get_section_name (LTO_section_symtab, NULL);\n+  char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n   bitmap seen;\n   struct cgraph_node *node, *alias;\n   struct varpool_node *vnode, *valias;\n@@ -2477,7 +2477,7 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n \n   memset (&header, 0, sizeof (struct lto_decl_header));\n \n-  section_name = lto_get_section_name (LTO_section_decls, NULL);\n+  section_name = lto_get_section_name (LTO_section_decls, NULL, NULL);\n   lto_begin_section (section_name, !flag_wpa);\n   free (section_name);\n "}, {"sha": "0536bb97b250a29f0235c88010273a3717def1ce", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 29, "deletions": 41, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -133,57 +133,45 @@ lto_bitmap_free (bitmap b)\n \n \n /* Get a section name for a particular type or name.  The NAME field\n-   is only used if SECTION_TYPE is LTO_section_function_body or\n-   LTO_static_initializer.  For all others it is ignored.  The callee\n-   of this function is responcible to free the returned name.  */\n+   is only used if SECTION_TYPE is LTO_section_function_body. For all\n+   others it is ignored.  The callee of this function is responsible\n+   to free the returned name.  */\n \n char *\n-lto_get_section_name (int section_type, const char *name)\n+lto_get_section_name (int section_type, const char *name, struct lto_file_decl_data *f)\n {\n-  switch (section_type)\n+  const char *add;\n+  char post[32];\n+  const char *sep;\n+\n+  if (section_type == LTO_section_function_body)\n     {\n-    case LTO_section_function_body:\n       gcc_assert (name != NULL);\n       if (name[0] == '*')\n \tname++;\n-      return concat (LTO_SECTION_NAME_PREFIX, name, NULL);\n-\n-    case LTO_section_static_initializer:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".statics\", NULL);\n-\n-    case LTO_section_symtab:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".symtab\", NULL);\n-\n-    case LTO_section_decls:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".decls\", NULL);\n-\n-    case LTO_section_cgraph:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".cgraph\", NULL);\n-\n-    case LTO_section_varpool:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".vars\", NULL);\n-\n-    case LTO_section_refs:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".refs\", NULL);\n-\n-    case LTO_section_jump_functions:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".jmpfuncs\", NULL);\n-\n-    case LTO_section_ipa_pure_const:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".pureconst\", NULL);\n-\n-    case LTO_section_ipa_reference:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".reference\", NULL);\n+      add = name;\n+      sep = \"\";\n+    }\n+  else if (section_type < LTO_N_SECTION_TYPES)\n+    {\n+      add = lto_section_name[section_type];\n+      sep = \".\";\n+    }\n+  else\n+    internal_error (\"bytecode stream: unexpected LTO section %s\", name);\n \n-    case LTO_section_opts:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".opts\", NULL);\n+  /* Make the section name unique so that ld -r combining sections\n+     doesn't confuse the reader with merged sections.\n \n-    case LTO_section_cgraph_opt_sum:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".cgraphopt\", NULL);\n+     For options don't add a ID, the option reader cannot deal with them\n+     and merging should be ok here.\n \n-    default:\n-      internal_error (\"bytecode stream: unexpected LTO section %s\", name);\n-    }\n+     XXX: use crc64 to minimize collisions? */\n+  if (section_type == LTO_section_opts)\n+    strcpy (post, \"\");\n+  else\n+    sprintf (post, \".%x\", f ? f->id : crc32_string(0, get_random_seed (false)));\n+  return concat (LTO_SECTION_NAME_PREFIX, sep, add, post, NULL);\n }\n \n "}, {"sha": "3304132b1d05f2b844a3e26fd5afb3a677990b51", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -600,6 +600,15 @@ struct GTY(()) lto_file_decl_data\n \n   /* Hash new name of renamed global declaration to its original name.  */\n   htab_t GTY((skip)) renaming_hash_table;\n+\n+  /* Linked list used temporarily in reader */\n+  struct lto_file_decl_data *next;\n+\n+  /* Sub ID for merged objects. */\n+  unsigned id;\n+\n+  /* Symbol resolutions for this file */\n+  VEC(ld_plugin_symbol_resolution_t,heap) *resolutions;\n };\n \n typedef struct lto_file_decl_data *lto_file_decl_data_ptr;\n@@ -815,7 +824,7 @@ extern void lto_record_function_out_decl_state (tree,\n extern const char *lto_tag_name (enum LTO_tags);\n extern bitmap lto_bitmap_alloc (void);\n extern void lto_bitmap_free (bitmap);\n-extern char *lto_get_section_name (int, const char *);\n+extern char *lto_get_section_name (int, const char *, struct lto_file_decl_data *);\n extern void print_lto_report (void);\n extern bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n \t\t\t\t       int *, unsigned *);"}, {"sha": "97853b34a3752327a01bbf04d621fd6c92ca3c50", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -1,3 +1,19 @@\n+2010-07-10   Andi Kleen <ak@linux.intel.com>\n+\n+\tPR lto/44992\n+        * lto.c: Include splay-tree.h\n+\t(lto_resolution_read): Change to walk file_ids tree and parse\n+\textra file_id in resolution file.\n+\t(lto_section_with_id): Add.\n+\t(create_subid_section_table): Add.\n+\t(lwstate): Add.\n+\t(lto_create_files_from_ids): Add.\n+\t(lto_file_read): Change to handle sub file ids and create list\n+\tof file_datas. Add output argument for count.\n+\t(get_section_data): Pass file_data to lto_get_section_name.\n+\t(lto_flatten_file): Add.\n+\t(read_cgraph_and_symbols): Handle linked lists of file_datas.\n+\n 2010-07-08  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* lto-coff.c: Include diagnostic-core.h in every file that"}, {"sha": "e4ee214f622f3fa351a4f408306ff8c30615f222", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 181, "deletions": 36, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto.h\"\n #include \"lto-tree.h\"\n #include \"lto-streamer.h\"\n+#include \"splay-tree.h\"\n \n /* This needs to be included after config.h.  Otherwise, _GNU_SOURCE will not\n    be defined in time to set __USE_GNU in the system headers, and strsignal\n@@ -309,23 +310,23 @@ lto_parse_hex (const char *p) {\n }\n \n /* Read resolution for file named FILE_NAME. The resolution is read from\n-   RESOLUTION. An array with the symbol resolution is returned. The array\n-   size is written to SIZE. */\n+   RESOLUTION. */\n \n-static VEC(ld_plugin_symbol_resolution_t,heap) *\n-lto_resolution_read (FILE *resolution, lto_file *file)\n+static void\n+lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n {\n   /* We require that objects in the resolution file are in the same\n      order as the lto1 command line. */\n   unsigned int name_len;\n   char *obj_name;\n   unsigned int num_symbols;\n   unsigned int i;\n-  VEC(ld_plugin_symbol_resolution_t,heap) *ret = NULL;\n+  struct lto_file_decl_data *file_data;\n   unsigned max_index = 0;\n+  splay_tree_node nd = NULL; \n \n   if (!resolution)\n-    return NULL;\n+    return;\n \n   name_len = strlen (file->filename);\n   obj_name = XNEWVEC (char, name_len + 1);\n@@ -356,15 +357,15 @@ lto_resolution_read (FILE *resolution, lto_file *file)\n   for (i = 0; i < num_symbols; i++)\n     {\n       int t;\n-      unsigned index;\n+      unsigned index, id;\n       char r_str[27];\n       enum ld_plugin_symbol_resolution r = (enum ld_plugin_symbol_resolution) 0;\n       unsigned int j;\n       unsigned int lto_resolution_str_len =\n \tsizeof (lto_resolution_str) / sizeof (char *);\n \n-      t = fscanf (resolution, \"%u %26s %*[^\\n]\\n\", &index, r_str);\n-      if (t != 2)\n+      t = fscanf (resolution, \"%u %x %26s %*[^\\n]\\n\", &index, &id, r_str);\n+      if (t != 3)\n         internal_error (\"Invalid line in the resolution file.\");\n       if (index > max_index)\n \tmax_index = index;\n@@ -380,12 +381,120 @@ lto_resolution_read (FILE *resolution, lto_file *file)\n       if (j == lto_resolution_str_len)\n \tinternal_error (\"Invalid resolution in the resolution file.\");\n \n-      VEC_safe_grow_cleared (ld_plugin_symbol_resolution_t, heap, ret,\n+      if (!(nd && nd->key == id))\n+\t{\n+\t  nd = splay_tree_lookup (file_ids, id);\n+\t  if (nd == NULL)\n+\t    internal_error (\"Resolution sub id %x not in object file\", id);\n+\t}\n+\n+      file_data = (struct lto_file_decl_data *)nd->value;\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"Adding resolution %u %u to id %x\\n\",\n+\t\t index, r, file_data->id);\n+      VEC_safe_grow_cleared (ld_plugin_symbol_resolution_t, heap, \n+\t\t\t     file_data->resolutions,\n \t\t\t     max_index + 1);\n-      VEC_replace (ld_plugin_symbol_resolution_t, ret, index, r);\n+      VEC_replace (ld_plugin_symbol_resolution_t, \n+\t\t   file_data->resolutions, index, r);\n     }\n+}\n \n-  return ret;\n+/* Is the name for a id'ed LTO section? */\n+\n+static int \n+lto_section_with_id (const char *name, unsigned *id)\n+{\n+  char *s;\n+\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX, strlen (LTO_SECTION_NAME_PREFIX)))\n+    return 0;\n+  s = strrchr (name, '.');\n+  return s && sscanf (s, \".%x\", id) == 1;\n+}\n+\n+/* Create file_data of each sub file id */\n+\n+static int \n+create_subid_section_table (void **slot, void *data)\n+{\n+  struct lto_section_slot s_slot, *new_slot;\n+  struct lto_section_slot *ls = *(struct lto_section_slot **)slot;\n+  splay_tree file_ids = (splay_tree)data;\n+  unsigned id;\n+  splay_tree_node nd;\n+  void **hash_slot;\n+  char *new_name;\n+  struct lto_file_decl_data *file_data;\n+\n+  if (!lto_section_with_id (ls->name, &id))\n+    return 1;\n+  \n+  /* Find hash table of sub module id */\n+  nd = splay_tree_lookup (file_ids, id);\n+  if (nd != NULL)\n+    {\n+      file_data = (struct lto_file_decl_data *)nd->value;\n+    }\n+  else\n+    {\n+      file_data = ggc_alloc_lto_file_decl_data ();\n+      memset(file_data, 0, sizeof (struct lto_file_decl_data));\n+      file_data->id = id;\n+      file_data->section_hash_table = lto_obj_create_section_hash_table ();;\n+      splay_tree_insert (file_ids, id, (splay_tree_value)file_data);\n+    }\n+\n+  /* Copy section into sub module hash table */\n+  new_name = XDUPVEC (char, ls->name, strlen (ls->name) + 1);\n+  s_slot.name = new_name;\n+  hash_slot = htab_find_slot (file_data->section_hash_table, &s_slot, INSERT);\n+  gcc_assert (*hash_slot == NULL);\n+\n+  new_slot = XDUP (struct lto_section_slot, ls);\n+  new_slot->name = new_name;\n+  *hash_slot = new_slot;\n+  return 1;\n+}\n+\n+/* Read declarations and other initializations for a FILE_DATA. */\n+\n+static void\n+lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n+{\n+  const char *data;\n+  size_t len;\n+\n+  file_data->renaming_hash_table = lto_create_renaming_table ();\n+  file_data->file_name = file->filename;\n+  data = lto_get_section_data (file_data, LTO_section_decls, NULL, &len);\n+  gcc_assert (data != NULL);\n+  lto_read_decls (file_data, data, file_data->resolutions);\n+  lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n+}\n+\n+struct lwstate\n+{\n+  lto_file *file;\n+  struct lto_file_decl_data **file_data;\n+  int *count;\n+};\n+\n+/* Traverse ids and create a list of file_datas out of it. */      \n+\n+static int lto_create_files_from_ids (splay_tree_node node, void *data)\n+{\n+  struct lwstate *lw = (struct lwstate *)data;\n+  struct lto_file_decl_data *file_data = (struct lto_file_decl_data *)node->value;\n+\n+  lto_file_finalize (file_data, lw->file);\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Creating file %s with sub id %x\\n\", \n+\t     file_data->file_name, file_data->id);\n+  file_data->next = *lw->file_data;\n+  *lw->file_data = file_data;\n+  (*lw->count)++;\n+  return 0;\n }\n \n /* Generate a TREE representation for all types and external decls\n@@ -396,23 +505,32 @@ lto_resolution_read (FILE *resolution, lto_file *file)\n    the .o file to load the functions and ipa information.   */\n \n static struct lto_file_decl_data *\n-lto_file_read (lto_file *file, FILE *resolution_file)\n+lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n {\n-  struct lto_file_decl_data *file_data;\n-  const char *data;\n-  size_t len;\n-  VEC(ld_plugin_symbol_resolution_t,heap) *resolutions;\n+  struct lto_file_decl_data *file_data = NULL;\n+  splay_tree file_ids;\n+  htab_t section_hash_table;\n+  struct lwstate state;\n   \n-  resolutions = lto_resolution_read (resolution_file, file);\n+  section_hash_table = lto_obj_build_section_table (file);\n \n-  file_data = ggc_alloc_lto_file_decl_data ();\n-  file_data->file_name = file->filename;\n-  file_data->section_hash_table = lto_obj_build_section_table (file);\n-  file_data->renaming_hash_table = lto_create_renaming_table ();\n-\n-  data = lto_get_section_data (file_data, LTO_section_decls, NULL, &len);\n-  lto_read_decls (file_data, data, resolutions);\n-  lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n+  /* Find all sub modules in the object and put their sections into new hash\n+     tables in a splay tree. */\n+  file_ids = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n+  htab_traverse (section_hash_table, create_subid_section_table, file_ids);\n+  \n+  /* Add resolutions to file ids */\n+  lto_resolution_read (file_ids, resolution_file, file);\n+\n+  /* Finalize each lto file for each submodule in the merged object\n+     and create list for returning. */\n+  state.file = file;\n+  state.file_data = &file_data;\n+  state.count = count;\n+  splay_tree_foreach (file_ids, lto_create_files_from_ids, &state);\n+    \n+  splay_tree_delete (file_ids);\n+  htab_delete (section_hash_table);\n \n   return file_data;\n }\n@@ -507,7 +625,7 @@ get_section_data (struct lto_file_decl_data *file_data,\n   htab_t section_hash_table = file_data->section_hash_table;\n   struct lto_section_slot *f_slot;\n   struct lto_section_slot s_slot;\n-  const char *section_name = lto_get_section_name (section_type, name);\n+  const char *section_name = lto_get_section_name (section_type, name, file_data);\n   char *data = NULL;\n \n   *len = 0;\n@@ -1538,6 +1656,33 @@ lto_read_all_file_options (void)\n \n static GTY((length (\"lto_stats.num_input_files + 1\"))) struct lto_file_decl_data **all_file_decl_data;\n \n+/* Turn file datas for sub files into a single array, so that they look\n+   like separate files for further passes. */\n+\n+static void\n+lto_flatten_files (struct lto_file_decl_data **orig, int count, int last_file_ix)\n+{\n+  struct lto_file_decl_data *n, *next;\n+  int i, k;\n+\n+  lto_stats.num_input_files = count;\n+  all_file_decl_data\n+    = ggc_alloc_cleared_vec_lto_file_decl_data_ptr (count + 1);\n+  /* Set the hooks so that all of the ipa passes can read in their data.  */\n+  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n+  for (i = 0, k = 0; i < last_file_ix; i++) \n+    {\n+      for (n = orig[i]; n != NULL; n = next)\n+\t{\n+\t  all_file_decl_data[k++] = n;\n+\t  next = n->next;\n+\t  n->next = NULL;\n+\t}\n+    }\n+  all_file_decl_data[k] = NULL;\n+  gcc_assert (k == count);\n+}\n+\n /* Read all the symbols from the input files FNAMES.  NFILES is the\n    number of files requested in the command line.  Instantiate a\n    global call graph by aggregating all the sub-graphs found in each\n@@ -1549,16 +1694,14 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   unsigned int i, last_file_ix;\n   FILE *resolution;\n   struct cgraph_node *node;\n+  int count = 0;\n+  struct lto_file_decl_data **decl_data;\n \n-  lto_stats.num_input_files = nfiles;\n   init_cgraph ();\n \n   timevar_push (TV_IPA_LTO_DECL_IN);\n \n-  /* Set the hooks so that all of the ipa passes can read in their data.  */\n-  all_file_decl_data\n-    = ggc_alloc_cleared_vec_lto_file_decl_data_ptr (nfiles + 1);\n-  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n+  decl_data = (struct lto_file_decl_data **)xmalloc (sizeof(*decl_data) * (nfiles+1));\n \n   /* Read the resolution file.  */\n   resolution = NULL;\n@@ -1595,23 +1738,25 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       if (!current_lto_file)\n \tbreak;\n \n-      file_data = lto_file_read (current_lto_file, resolution);\n+      file_data = lto_file_read (current_lto_file, resolution, &count);\n       if (!file_data)\n \tbreak;\n \n-      all_file_decl_data[last_file_ix++] = file_data;\n+      decl_data[last_file_ix++] = file_data;\n \n       lto_obj_file_close (current_lto_file);\n       current_lto_file = NULL;\n       /* ???  We'd want but can't ggc_collect () here as the type merging\n          code in gimple.c uses hashtables that are not ggc aware.  */\n     }\n \n+  lto_flatten_files (decl_data, count, last_file_ix);\n+  lto_stats.num_input_files = count;\n+  free(decl_data);\n+\n   if (resolution_file_name)\n     fclose (resolution);\n \n-  all_file_decl_data[last_file_ix] = NULL;\n-\n   /* Set the hooks so that all of the ipa passes can read in their data.  */\n   lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n "}, {"sha": "a8f7461298c2b4c6f59eeee1d5223429629ac27c", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -1,3 +1,20 @@\n+2010-07-10   Andi Kleen <ak@linux.intel.com>\n+\n+\tPR lto/44992\n+\t* lto-plugin.c (sym_aux): Add.\n+\t(plugin_symtab): Remove slots. Add aux and id.\n+\t(parse_table_entry): Change to use aux instead of slots.\n+\t(LTO_SECTION_PREFIX): Add.\n+\t(translate): Improve buffer allocation. Change to append\n+\tsymbols to existing out buffer.\n+\t(get_section): Remove.\n+\t(process_symtab): Add.\n+\t(free_2): Free symtab->aux.\n+\t(write_resolution): Handle aux instead of slots.\n+\tPrint sub id to resolution file.\n+\t(claim_file_handler): Clear lto_file. Replace get_symtab/translate\n+\tcalls with call to process_symtab.\n+\n 2010-07-22  Richard Guenther  <rguenther@suse.de>\n \n \t* Makefile.am: New copy_lto_plugin rule to install the plugin"}, {"sha": "314759bc4621d6913ce0aa146f25973c175dfc69", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ce4d1ed68a2f4e36c27be604ce35c242048f9d/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=73ce4d1ed68a2f4e36c27be604ce35c242048f9d", "patch": "@@ -55,11 +55,18 @@ along with this program; see the file COPYING3.  If not see\n    must keep SYMS until all_symbols_read is called to give the linker time to\n    copy the symbol information. */\n \n+struct sym_aux\n+{\n+  uint32_t slot;\n+  unsigned id;\n+};\n+\n struct plugin_symtab\n {\n   int nsyms;\n-  uint32_t *slots;\n+  struct sym_aux *aux;\n   struct ld_plugin_symbol *syms;\n+  unsigned id;\n };\n \n /* All that we have to remember about a file. */\n@@ -120,7 +127,8 @@ check (bool gate, enum ld_plugin_level level, const char *text)\n    Returns the address of the next entry. */\n \n static char *\n-parse_table_entry (char *p, struct ld_plugin_symbol *entry, uint32_t *slot)\n+parse_table_entry (char *p, struct ld_plugin_symbol *entry, \n+\t\t   struct sym_aux *aux)\n {\n   unsigned char t;\n   enum ld_plugin_symbol_kind translate_kind[] =\n@@ -170,24 +178,59 @@ parse_table_entry (char *p, struct ld_plugin_symbol *entry, uint32_t *slot)\n   entry->size = *(uint64_t *) p;\n   p += 8;\n \n-  *slot = *(uint32_t *) p;\n+  aux->slot = *(uint32_t *) p;\n   p += 4;\n \n   entry->resolution = LDPR_UNKNOWN;\n \n   return p;\n }\n \n-/* Return the section in ELF that is named NAME. */\n+#define LTO_SECTION_PREFIX \".gnu.lto_.symtab\"\n+\n+/* Translate the IL symbol table SYMTAB. Append the slots and symbols to OUT. */\n+\n+static void\n+translate (Elf_Data *symtab, struct plugin_symtab *out)\n+{\n+  struct sym_aux *aux;\n+  char *data = symtab->d_buf;\n+  char *end = data + symtab->d_size;\n+  struct ld_plugin_symbol *syms = NULL;\n+  int n, len;\n+\n+  /* This overestimates the output buffer sizes, but at least \n+     the algorithm is O(1) now. */\n+\n+  len = (end - data)/8 + out->nsyms + 1;\n+  syms = xrealloc (out->syms, len * sizeof (struct ld_plugin_symbol));\n+  aux = xrealloc (out->aux, len * sizeof (struct sym_aux));\n+  \n+  for (n = out->nsyms; data < end; n++) \n+    { \n+      aux[n].id = out->id; \n+      data = parse_table_entry (data, &syms[n], &aux[n]);\n+    }\n+\n+  fprintf (stderr, \"n = %d len = %d end-data=%lu\\n\", n, len, end-data);\n+  assert(n < len);\n+\n+  out->nsyms = n;\n+  out->syms = syms;\n+  out->aux = aux;\n+}\n+\n+/* Process all lto symtabs of file ELF. */\n \n-static Elf_Scn *\n-get_section (Elf *elf, const char *name)\n+static int\n+process_symtab (Elf *elf, struct plugin_symtab *out)\n {\n+  int found = 0;\n   Elf_Scn *section = 0;\n   GElf_Ehdr header;\n   GElf_Ehdr *t = gelf_getehdr (elf, &header);\n   if (t == NULL)\n-    return NULL;\n+    return 0;\n   assert (t == &header);\n \n   while ((section = elf_nextscn(elf, section)) != 0)\n@@ -198,51 +241,16 @@ get_section (Elf *elf, const char *name)\n       assert (tshdr == &shdr);\n       t = elf_strptr (elf, header.e_shstrndx, shdr.sh_name);\n       assert (t != NULL);\n-      if (strcmp (t, name) == 0)\n-\treturn section;\n-    }\n-  return NULL;\n-}\n-\n-/* Returns the IL symbol table of file ELF. */\n-\n-static Elf_Data *\n-get_symtab (Elf *elf)\n-{\n-  Elf_Data *data = 0;\n-  Elf_Scn *section = get_section (elf, \".gnu.lto_.symtab\");\n-  if (!section)\n-    return NULL;\n-\n-  data = elf_getdata (section, data);\n-  assert (data);\n-  return data;\n-}\n-\n-/* Translate the IL symbol table SYMTAB. Write the slots and symbols in OUT. */\n-\n-static void\n-translate (Elf_Data *symtab, struct plugin_symtab *out)\n-{\n-  uint32_t *slots = NULL;\n-  char *data = symtab->d_buf;\n-  char *end = data + symtab->d_size;\n-  struct ld_plugin_symbol *syms = NULL;\n-  int n = 0;\n-\n-  while (data < end)\n-    {\n-      n++;\n-      syms = xrealloc (syms, n * sizeof (struct ld_plugin_symbol));\n-      check (syms, LDPL_FATAL, \"could not allocate memory\");\n-      slots = xrealloc (slots, n * sizeof (uint32_t));\n-      check (slots, LDPL_FATAL, \"could not allocate memory\");\n-      data = parse_table_entry (data, &syms[n - 1], &slots[n - 1]);\n+      if (strncmp (t, LTO_SECTION_PREFIX, strlen (LTO_SECTION_PREFIX)) == 0) \n+\t{\n+\t  char *s = strrchr (t, '.');\n+\t  if (s)\n+\t      sscanf (s, \".%x\", &out->id);\n+\t  translate (elf_getdata (section, NULL), out);\n+\t  found = 1;\n+\t}\n     }\n-\n-  out->nsyms = n;\n-  out->syms = syms;\n-  out->slots = slots;\n+  return found;\n }\n \n /* Free all memory that is no longer needed after writing the symbol\n@@ -279,7 +287,7 @@ free_2 (void)\n     {\n       struct plugin_file_info *info = &claimed_files[i];\n       struct plugin_symtab *symtab = &info->symtab;\n-      free (symtab->slots);\n+      free (symtab->aux);\n       free (info->name);\n     }\n \n@@ -323,9 +331,10 @@ write_resolution (void)\n \n       for (j = 0; j < info->symtab.nsyms; j++)\n \t{\n-\t  uint32_t slot = symtab->slots[j];\n+\t  uint32_t slot = symtab->aux[j].slot;\n \t  unsigned int resolution = syms[j].resolution;\n-\t  fprintf (f, \"%d %s %s\\n\", slot, lto_resolution_str[resolution], syms[j].name);\n+\t  fprintf (f, \"%d %x %s %s\\n\", slot, symtab->aux[j].id,\n+\t\t   lto_resolution_str[resolution], syms[j].name);\n \t}\n     }\n   fclose (f);\n@@ -551,7 +560,8 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   enum ld_plugin_status status;\n   Elf *elf;\n   struct plugin_file_info lto_file;\n-  Elf_Data *symtab;\n+\n+  memset (&lto_file, 0, sizeof (struct plugin_file_info));\n \n   if (file->offset != 0)\n     {\n@@ -588,15 +598,9 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n \n   *claimed = 0;\n \n-  if (!elf)\n+  if (!elf || !process_symtab (elf, &lto_file.symtab))\n     goto err;\n \n-  symtab = get_symtab (elf);\n-  if (!symtab)\n-    goto err;\n-\n-  translate (symtab, &lto_file.symtab);\n-\n   status = add_symbols (file->handle, lto_file.symtab.nsyms,\n \t\t\tlto_file.symtab.syms);\n   check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");"}]}