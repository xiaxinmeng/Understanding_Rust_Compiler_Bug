{"sha": "8a8b05f4639ed1680cee23958376fbda5b5ac512", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4YjA1ZjQ2MzllZDE2ODBjZWUyMzk1ODM3NmZiZGE1YjVhYzUxMg==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2007-05-13T07:49:47Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-05-13T07:49:47Z"}, "message": "Extend dse\n\nFrom-SVN: r124651", "tree": {"sha": "a35c51188a1feed4b0d86678b6b364b8e196f787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a35c51188a1feed4b0d86678b6b364b8e196f787"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a8b05f4639ed1680cee23958376fbda5b5ac512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8b05f4639ed1680cee23958376fbda5b5ac512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8b05f4639ed1680cee23958376fbda5b5ac512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8b05f4639ed1680cee23958376fbda5b5ac512/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd2d8c70db3e977ff4c6b83c541c77866bc807aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd2d8c70db3e977ff4c6b83c541c77866bc807aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd2d8c70db3e977ff4c6b83c541c77866bc807aa"}], "stats": {"total": 122, "additions": 118, "deletions": 4}, "files": [{"sha": "f454c193240a6bd509deb24cec05081091d901e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a8b05f4639ed1680cee23958376fbda5b5ac512", "patch": "@@ -1,3 +1,9 @@\n+2007-05-13  Revital Eres  <eres@il.ibm.com>\n+\n+\t* tree-ssa-dse.c (get_use_of_stmt_lhs): New function\n+\twhich walks virtual def-use chains to find redundant stores.\n+\t(dse_optimize_stmt): Call it.\n+\n 2007-05-12  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gcse.c (gcse_main): Do jump bypassing in CPROP2."}, {"sha": "586fc11de3856fbd05458c2de433469ee0a2afb0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a8b05f4639ed1680cee23958376fbda5b5ac512", "patch": "@@ -1,3 +1,7 @@\n+2007-05-13  Revital Eres  <eres@il.ibm.com>\n+\n+\t* gcc.dg/dse.c: New test.\n+\n 2007-05-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/31797"}, {"sha": "4a859ae03e7f18fd886f5beee24d456b9941812f", "filename": "gcc/testsuite/gcc.dg/dse.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftestsuite%2Fgcc.dg%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftestsuite%2Fgcc.dg%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdse.c?ref=8a8b05f4639ed1680cee23958376fbda5b5ac512", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse-details\" } */\n+\n+#define N 256\n+\n+struct\n+{\n+  int x;\n+  int y;\n+} S[100];\n+\n+int z[100];\n+\n+int\n+foo (void)\n+{\n+  int i;\n+  int x, y;\n+\n+  S[5].x = 0;\n+  S[5].y = 0;\n+\n+  x = 5 + z[0];\n+  y = z[0];\n+\n+  S[5].x = x;\n+  S[5].y = y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 2 \"dse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dse*\" } } */\n+"}, {"sha": "596d4a8ee6bc819bca218891dcb69dbeef4e6ee7", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a8b05f4639ed1680cee23958376fbda5b5ac512/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=8a8b05f4639ed1680cee23958376fbda5b5ac512", "patch": "@@ -237,6 +237,59 @@ memory_address_same (tree store1, tree store2)\n \t  == NULL);\n }\n \n+/* Return the use stmt for the lhs of STMT following the virtual\n+   def-use chains.  Returns the MODIFY_EXPR stmt which lhs is equal to\n+   the lhs of STMT or NULL_TREE if no such stmt can be found.  */\n+static tree \n+get_use_of_stmt_lhs (tree stmt,\n+\t\t     use_operand_p * first_use_p,\n+\t\t     use_operand_p * use_p, tree * use_stmt)\n+{\n+  tree usevar, lhs;\n+  def_operand_p def_p;\n+\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL_TREE;\n+\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+  /* The stmt must have a single VDEF.  */\n+  def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_VDEF);\n+  if (def_p == NULL_DEF_OPERAND_P)\n+    return NULL_TREE;\n+\n+  if (!has_single_use (DEF_FROM_PTR (def_p)))\n+    return NULL_TREE;\n+  /* Get the immediate use of the def.  */\n+  single_imm_use (DEF_FROM_PTR (def_p), use_p, use_stmt);\n+  gcc_assert (*use_p != NULL_USE_OPERAND_P);\n+  first_use_p = use_p;\n+  if (TREE_CODE (*use_stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL_TREE;\n+\n+  do\n+    {\n+      /* Look at the use stmt and see if it's LHS matches\n+         stmt's lhs SSA_NAME.  */\n+      def_p = SINGLE_SSA_DEF_OPERAND (*use_stmt, SSA_OP_VDEF);\n+      if (def_p == NULL_DEF_OPERAND_P)\n+\treturn NULL_TREE;\n+\n+      usevar = GIMPLE_STMT_OPERAND (*use_stmt, 0);\n+      if (operand_equal_p (usevar, lhs, 0))\n+\treturn *use_stmt;\n+\n+      if (!has_single_use (DEF_FROM_PTR (def_p)))\n+\treturn NULL_TREE;\n+      single_imm_use (DEF_FROM_PTR (def_p), use_p, use_stmt);\n+      gcc_assert (*use_p != NULL_USE_OPERAND_P);\n+      if (TREE_CODE (*use_stmt) != GIMPLE_MODIFY_STMT)\n+\treturn NULL_TREE;\n+    }\n+  while (1);\n+\n+  return NULL_TREE;\n+}\n \n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_MODIFY_STMT in STMT, check that each VDEF has one\n@@ -593,10 +646,29 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n       /* If this is a partial store into an aggregate, record it.  */\n       dse_record_partial_aggregate_store (stmt, dse_gd);\n \n-      /* If we have precisely one immediate use at this point, then we may\n-\t have found redundant store.  Make sure that the stores are to\n-\t the same memory location.  This includes checking that any\n-\t SSA-form variables in the address will have the same values.  */\n+      if (use_p != NULL_USE_OPERAND_P\n+          && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt))\n+          && (!operand_equal_p (GIMPLE_STMT_OPERAND (stmt, 0),\n+                                GIMPLE_STMT_OPERAND (use_stmt, 0), 0)\n+              && !dse_partial_kill_p (stmt, dse_gd))\n+          && memory_address_same (stmt, use_stmt))\n+        {\n+          /* If we have precisely one immediate use at this point, but\n+             the stores are not to the same memory location then walk the\n+             virtual def-use chain to get the stmt which stores to that same\n+             memory location.  */\n+          if (get_use_of_stmt_lhs (stmt, &first_use_p, &use_p, &use_stmt) ==\n+              NULL_TREE)\n+            {\n+              record_voperand_set (dse_gd->stores, &bd->stores, ann->uid);\n+              return;\n+            }\n+        }\n+\n+      /* If we have precisely one immediate use at this point and the\n+\t stores are to the same memory location or there is a chain of\n+\t virtual uses from stmt and the stmt which stores to that same\n+\t memory location, then we may have found redundant store.  */\n       if (use_p != NULL_USE_OPERAND_P\n \t  && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt))\n \t  && (operand_equal_p (GIMPLE_STMT_OPERAND (stmt, 0),"}]}