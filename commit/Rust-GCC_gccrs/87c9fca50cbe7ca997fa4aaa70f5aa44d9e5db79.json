{"sha": "87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjOWZjYTUwY2JlN2NhOTk3ZmE0YWFhNzBmNWFhNDRkOWU1ZGI3OQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2016-10-23T18:12:28Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2016-10-23T18:12:28Z"}, "message": "re PR fortran/54730 (ICE in gfc_typenode_for_spec, at fortran/trans-types.c:1066)\n\n2016-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/54730\n\tPR fortran/78033\n\t* array.c (gfc_match_array_constructor): Remove checkpointing\n\tintroduced in r196416 (original fix for PR fortran/54730).  Move\n\tinitialization to top of function.\n\t* match.c (gfc_match_type_spec): Special case matching for REAL.\n\n2016-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/54730\n\tPR fortran/78033\n\t* gfortran.dg/pr78033.f90: New test.\n\nFrom-SVN: r241451", "tree": {"sha": "d047cbbb70ee6dfd0c528751dfc9446fd5e07cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d047cbbb70ee6dfd0c528751dfc9446fd5e07cb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/comments", "author": null, "committer": null, "parents": [{"sha": "dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd6231ea3621d57a2bf75f675fc8931ce5dec28"}], "stats": {"total": 181, "additions": 147, "deletions": 34}, "files": [{"sha": "0931104b740247f0a1ad707e4f1a83f2f1fbf35c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "patch": "@@ -1,3 +1,12 @@\n+2016-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/54730\n+\tPR fortran/78033\n+\t* array.c (gfc_match_array_constructor): Remove checkpointing\n+\tintroduced in r196416 (original fix for PR fortran/54730).  Move\n+\tinitialization to top of function.\n+\t* match.c (gfc_match_type_spec): Special case matching for REAL.\n+\n 2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69834"}, {"sha": "e6917a53850814f55af1d430595f0a1919201d1e", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "patch": "@@ -1091,14 +1091,16 @@ gfc_match_array_constructor (gfc_expr **result)\n {\n   gfc_constructor *c;\n   gfc_constructor_base head;\n-  gfc_undo_change_set changed_syms;\n   gfc_expr *expr;\n   gfc_typespec ts;\n   locus where;\n   match m;\n   const char *end_delim;\n   bool seen_ts;\n \n+  head = NULL;\n+  seen_ts = false;\n+\n   if (gfc_match (\" (/\") == MATCH_NO)\n     {\n       if (gfc_match (\" [\") == MATCH_NO)\n@@ -1115,12 +1117,9 @@ gfc_match_array_constructor (gfc_expr **result)\n     end_delim = \" /)\";\n \n   where = gfc_current_locus;\n-  head = NULL;\n-  seen_ts = false;\n \n   /* Try to match an optional \"type-spec ::\"  */\n   gfc_clear_ts (&ts);\n-  gfc_new_undo_checkpoint (changed_syms);\n   m = gfc_match_type_spec (&ts);\n   if (m == MATCH_YES)\n     {\n@@ -1130,16 +1129,12 @@ gfc_match_array_constructor (gfc_expr **result)\n \t{\n \t  if (!gfc_notify_std (GFC_STD_F2003, \"Array constructor \"\n \t\t\t       \"including type specification at %C\"))\n-\t    {\n-\t      gfc_restore_last_undo_checkpoint ();\n-\t      goto cleanup;\n-\t    }\n+\t    goto cleanup;\n \n \t  if (ts.deferred)\n \t    {\n \t      gfc_error (\"Type-spec at %L cannot contain a deferred \"\n \t\t\t \"type parameter\", &where);\n-\t      gfc_restore_last_undo_checkpoint ();\n \t      goto cleanup;\n \t    }\n \n@@ -1148,24 +1143,15 @@ gfc_match_array_constructor (gfc_expr **result)\n \t    {\n \t      gfc_error (\"Type-spec at %L cannot contain an asterisk for a \"\n \t\t\t \"type parameter\", &where);\n-\t      gfc_restore_last_undo_checkpoint ();\n \t      goto cleanup;\n \t    }\n \t}\n     }\n   else if (m == MATCH_ERROR)\n-    {\n-      gfc_restore_last_undo_checkpoint ();\n-      goto cleanup;\n-    }\n+    goto cleanup;\n \n-  if (seen_ts)\n-    gfc_drop_last_undo_checkpoint ();\n-  else\n-    {\n-      gfc_restore_last_undo_checkpoint ();\n-      gfc_current_locus = where;\n-    }\n+  if (!seen_ts)\n+    gfc_current_locus = where;\n \n   if (gfc_match (end_delim) == MATCH_YES)\n     {"}, {"sha": "ae9e1d0ce8301ae4f08ca51a2b9ddb875166e046", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "patch": "@@ -1989,6 +1989,7 @@ gfc_match_type_spec (gfc_typespec *ts)\n {\n   match m;\n   locus old_locus;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n \n   gfc_clear_ts (ts);\n   gfc_gobble_whitespace ();\n@@ -2013,13 +2014,6 @@ gfc_match_type_spec (gfc_typespec *ts)\n       goto kind_selector;\n     }\n \n-  if (gfc_match (\"real\") == MATCH_YES)\n-    {\n-      ts->type = BT_REAL;\n-      ts->kind = gfc_default_real_kind;\n-      goto kind_selector;\n-    }\n-\n   if (gfc_match (\"double precision\") == MATCH_YES)\n     {\n       ts->type = BT_REAL;\n@@ -2053,13 +2047,112 @@ gfc_match_type_spec (gfc_typespec *ts)\n       goto kind_selector;\n     }\n \n+  /* REAL is a real pain because it can be a type, intrinsic subprogram,\n+     or list item in a type-list of an OpenMP reduction clause.  Need to\n+     differentiate REAL([KIND]=scalar-int-initialization-expr) from\n+     REAL(A,[KIND]) and REAL(KIND,A).  */\n+\n+  m = gfc_match (\" %n\", name);\n+  if (m == MATCH_YES && strcmp (name, \"real\") == 0)\n+    {\n+      char c;\n+      gfc_expr *e;\n+      locus where;\n+\n+      ts->type = BT_REAL;\n+      ts->kind = gfc_default_real_kind;\n+\n+      gfc_gobble_whitespace ();\n+\n+      /* Prevent REAL*4, etc.  */\n+      c = gfc_peek_ascii_char ();\n+      if (c == '*')\n+\t{\n+\t  gfc_error (\"Invalid type-spec at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      /* Found leading colon in REAL::, a trailing ')' in for example\n+\t TYPE IS (REAL), or REAL, for an OpenMP list-item.  */\n+      if (c == ':' || c == ')' || (flag_openmp && c == ','))\n+\treturn MATCH_YES;\n+\n+      /* Found something other than the opening '(' in REAL(...  */\n+      if (c != '(')\n+\treturn MATCH_NO;\n+      else\n+\tgfc_next_char (); /* Burn the '('. */\n+\n+      /* Look for the optional KIND=. */\n+      where = gfc_current_locus;\n+      m = gfc_match (\"%n\", name);\n+      if (m == MATCH_YES)\n+\t{\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\t  if (c == '=')\n+\t    {\n+\t      if (strcmp(name, \"a\") == 0)\n+\t\treturn MATCH_NO;\n+\t      else if (strcmp(name, \"kind\") == 0)\n+\t\tgoto found;\n+\t      else\n+\t\treturn MATCH_ERROR;\n+\t    }\n+\t  else\n+\t    gfc_current_locus = where;\n+\t}\n+      else\n+\tgfc_current_locus = where;\n+\n+found:\n+\n+      m = gfc_match_init_expr (&e);\n+      if (m == MATCH_NO || m == MATCH_ERROR)\n+\treturn MATCH_NO;\n+\n+      /* If a comma appears, it is an intrinsic subprogram. */\n+      gfc_gobble_whitespace ();\n+      c = gfc_peek_ascii_char ();\n+      if (c == ',')\n+\t{\n+\t  gfc_free_expr (e);\n+\t  return MATCH_NO;\n+\t}\n+\n+      /* If ')' appears, we have REAL(initialization-expr), here check for\n+\t a scalar integer initialization-expr and valid kind parameter. */\n+      if (c == ')')\n+\t{\n+\t  if (e->ts.type != BT_INTEGER || e->rank > 0)\n+\t    {\n+\t      gfc_free_expr (e);\n+\t      return MATCH_NO;\n+\t    }\n+\n+\t  gfc_next_char (); /* Burn the ')'. */\n+\t  ts->kind = (int) mpz_get_si (e->value.integer);\n+\t  if (gfc_validate_kind (BT_REAL, ts->kind , true) == -1)\n+\t    {\n+\t      gfc_error (\"Invalid type-spec at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  gfc_free_expr (e);\n+\n+\t  return MATCH_YES;\n+\t}\n+    }\n+\n   /* If a type is not matched, simply return MATCH_NO.  */\n   gfc_current_locus = old_locus;\n   return MATCH_NO;\n \n kind_selector:\n \n   gfc_gobble_whitespace ();\n+\n+  /* This prevents INTEGER*4, etc.  */\n   if (gfc_peek_ascii_char () == '*')\n     {\n       gfc_error (\"Invalid type-spec at %C\");\n@@ -2068,13 +2161,9 @@ gfc_match_type_spec (gfc_typespec *ts)\n \n   m = gfc_match_kind_spec (ts, false);\n \n+  /* No kind specifier found.  */\n   if (m == MATCH_NO)\n-    m = MATCH_YES;\t\t/* No kind specifier found.  */\n-\n-  /* gfortran may have matched REAL(a=1), which is the keyword form of the\n-     intrinsic procedure.  */\n-  if (ts->type == BT_REAL && m == MATCH_ERROR)\n-    m = MATCH_NO;\n+    m = MATCH_YES;\n \n   return m;\n }"}, {"sha": "6d2c80f372bae668da6cfa3f8eee7d2b2f7451d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "patch": "@@ -1,3 +1,9 @@\n+2016-10-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/54730\n+\tPR fortran/78033\n+\t* gfortran.dg/pr78033.f90: New test.\n+\n 2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69834"}, {"sha": "ce794b33c06c679f8cd195c110b78bc1b20c1bdf", "filename": "gcc/testsuite/gfortran.dg/pr78033.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78033.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78033.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr78033.f90?ref=87c9fca50cbe7ca997fa4aaa70f5aa44d9e5db79", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+subroutine f(n, x, y)\n+\n+   implicit none\n+\n+   integer, parameter :: knd = kind(1.e0)\n+\n+   integer, intent(in) :: n\n+   complex(knd), intent(in) :: x(1:n)\n+\n+   integer i\n+   real(knd) y(2*n)\n+   \n+   y = [real(x), aimag(x)]\n+   y = [real(x(1:n)), aimag(x(1:n))]\n+   y = [real(knd) :: 1] \n+   y = [real(kind=42) :: 1] { dg-error \"Invalid type-spec\" }\n+   y = [real(kind=knd) :: 1]\n+   y = [real(kind=knd, a=1.)]\n+   y = [real(a=1.)]\n+   y = [real(a=1, kind=knd)]\n+\n+end subroutine f"}]}