{"sha": "29e0ad452cdf001bccd12c1cb5f4797df1114a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllMGFkNDUyY2RmMDAxYmNjZDEyYzFjYjVmNDc5N2RmMTExNGEzYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-04T08:53:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-04T08:53:07Z"}, "message": "openmp: Compute number of collapsed loop iterations more efficiently for some non-rectangular loops\n\n2020-08-04  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-expand.c (expand_omp_for_init_counts): For triangular loops\n\tcompute number of iterations at runtime more efficiently.\n\t(expand_omp_for_init_vars): Adjust immediate dominators.\n\t(extract_omp_for_update_vars): Likewise.", "tree": {"sha": "b9b1b2f5799e469aa89a4dd0c19996eb47bd2a6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9b1b2f5799e469aa89a4dd0c19996eb47bd2a6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29e0ad452cdf001bccd12c1cb5f4797df1114a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e0ad452cdf001bccd12c1cb5f4797df1114a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e0ad452cdf001bccd12c1cb5f4797df1114a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e0ad452cdf001bccd12c1cb5f4797df1114a3a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3fda119036f46bfa70e06e7c69e04e78040079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3fda119036f46bfa70e06e7c69e04e78040079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3fda119036f46bfa70e06e7c69e04e78040079"}], "stats": {"total": 452, "additions": 352, "deletions": 100}, "files": [{"sha": "f73cdc9c89c43233701bdcbb8b5dd50cd2078ff0", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 352, "deletions": 100, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e0ad452cdf001bccd12c1cb5f4797df1114a3a/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e0ad452cdf001bccd12c1cb5f4797df1114a3a/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=29e0ad452cdf001bccd12c1cb5f4797df1114a3a", "patch": "@@ -1934,139 +1934,390 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n     {\n       gcc_assert (fd->last_nonrect != -1);\n \n-      /* Fallback implementation.  Evaluate the loops with m1/m2\n-\t non-NULL as well as their outer loops at runtime using temporaries\n-\t instead of the original iteration variables, and in the\n-\t body just bump the counter.  */\n       counts[fd->last_nonrect] = create_tmp_reg (type, \".count\");\n       expand_omp_build_assign (gsi, counts[fd->last_nonrect],\n \t\t\t       build_zero_cst (type));\n-      gimple_stmt_iterator gsi2 = *gsi;\n-      gsi_prev (&gsi2);\n-      e = split_block (entry_bb, gsi_stmt (gsi2));\n-      e = split_block (e->dest, (gimple *) NULL);\n-      basic_block cur_bb = e->src;\n-      basic_block next_bb = e->dest;\n-      entry_bb = e->dest;\n-      *gsi = gsi_after_labels (entry_bb);\n-\n-      tree *vs = XALLOCAVEC (tree, fd->last_nonrect);\n-      memset (vs, 0, fd->last_nonrect * sizeof (tree));\n-\n-      for (i = 0; i <= fd->last_nonrect; i++)\n-\t{\n-\t  if (fd->loops[i].m1 == NULL_TREE\n-\t      && fd->loops[i].m2 == NULL_TREE\n-\t      && !fd->loops[i].non_rect_referenced)\n-\t    continue;\n+      for (i = fd->first_nonrect + 1; i < fd->last_nonrect; i++)\n+\tif (fd->loops[i].m1\n+\t    || fd->loops[i].m2\n+\t    || fd->loops[i].non_rect_referenced)\n+\t  break;\n+      if (i == fd->last_nonrect\n+\t  && fd->loops[i].outer == fd->last_nonrect - fd->first_nonrect\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (fd->loops[i].v)))\n+\t{\n+\t  int o = fd->first_nonrect;\n+\t  tree itype = TREE_TYPE (fd->loops[o].v);\n+\t  tree n1o = create_tmp_reg (itype, \".n1o\");\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[o].n1));\n+\t  expand_omp_build_assign (gsi, n1o, t);\n+\t  tree n2o = create_tmp_reg (itype, \".n2o\");\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[o].n2));\n+\t  expand_omp_build_assign (gsi, n2o, t);\n+\t  if (fd->loops[i].m1 && fd->loops[i].m2)\n+\t    t = fold_build2 (MINUS_EXPR, itype, unshare_expr (fd->loops[i].m2),\n+\t\t\t     unshare_expr (fd->loops[i].m1));\n+\t  else if (fd->loops[i].m1)\n+\t    t = fold_unary (NEGATE_EXPR, itype,\n+\t\t\t    unshare_expr (fd->loops[i].m1));\n+\t  else\n+\t    t = unshare_expr (fd->loops[i].m2);\n+\t  tree m2minusm1\n+\t    = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n \n-\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+\t  gimple_stmt_iterator gsi2 = *gsi;\n+\t  gsi_prev (&gsi2);\n+\t  e = split_block (entry_bb, gsi_stmt (gsi2));\n+\t  e = split_block (e->dest, (gimple *) NULL);\n+\t  basic_block bb1 = e->src;\n+\t  entry_bb = e->dest;\n+\t  *gsi = gsi_after_labels (entry_bb);\n \n-\t  gsi2 = gsi_after_labels (cur_bb);\n-\t  tree n1, n2;\n+\t  gsi2 = gsi_after_labels (bb1);\n+\t  tree ostep = fold_convert (itype, fd->loops[o].step);\n+\t  t = build_int_cst (itype, (fd->loops[o].cond_code\n+\t\t\t\t     == LT_EXPR ? -1 : 1));\n+\t  t = fold_build2 (PLUS_EXPR, itype, ostep, t);\n+\t  t = fold_build2 (PLUS_EXPR, itype, t, n2o);\n+\t  t = fold_build2 (MINUS_EXPR, itype, t, n1o);\n+\t  if (TYPE_UNSIGNED (itype)\n+\t      && fd->loops[o].cond_code == GT_EXPR)\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, ostep));\n+\t  else\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, ostep);\n+\t  tree outer_niters\n+\t    = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  t = fold_build2 (MINUS_EXPR, itype, outer_niters,\n+\t\t\t   build_one_cst (itype));\n+\t  t = fold_build2 (MULT_EXPR, itype, t, ostep);\n+\t  t = fold_build2 (PLUS_EXPR, itype, n1o, t);\n+\t  tree last = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  tree n1, n2, n1e, n2e;\n \t  t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n \t  if (fd->loops[i].m1)\n \t    {\n \t      n1 = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n-\t      n1 = fold_build2 (MULT_EXPR, itype, vs[i - fd->loops[i].outer],\n-\t\t\t\tn1);\n+\t      n1 = fold_build2 (MULT_EXPR, itype, n1o, n1);\n \t      n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n \t    }\n \t  else\n \t    n1 = t;\n \t  n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n-\t  if (i < fd->last_nonrect)\n-\t    {\n-\t      vs[i] = create_tmp_reg (itype, \".it\");\n-\t      expand_omp_build_assign (&gsi2, vs[i], n1);\n-\t    }\n \t  t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n \t  if (fd->loops[i].m2)\n \t    {\n \t      n2 = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n-\t      n2 = fold_build2 (MULT_EXPR, itype, vs[i - fd->loops[i].outer],\n-\t\t\t\tn2);\n+\t      n2 = fold_build2 (MULT_EXPR, itype, n1o, n2);\n \t      n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n \t    }\n \t  else\n \t    n2 = t;\n \t  n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n-\t  if (i == fd->last_nonrect)\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t  if (fd->loops[i].m1)\n \t    {\n-\t      gcond *cond_stmt\n-\t\t= gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n-\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      n1e = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n+\t      n1e = fold_build2 (MULT_EXPR, itype, last, n1e);\n+\t      n1e = fold_build2 (PLUS_EXPR, itype, n1e, t);\n+\t    }\n+\t  else\n+\t    n1e = t;\n+\t  n1e = force_gimple_operand_gsi (&gsi2, n1e, true, NULL_TREE,\n+\t\t\t\t\t  true, GSI_SAME_STMT);\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t  if (fd->loops[i].m2)\n+\t    {\n+\t      n2e = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t      n2e = fold_build2 (MULT_EXPR, itype, last, n2e);\n+\t      n2e = fold_build2 (PLUS_EXPR, itype, n2e, t);\n+\t    }\n+\t  else\n+\t    n2e = t;\n+\t  n2e = force_gimple_operand_gsi (&gsi2, n2e, true, NULL_TREE,\n+\t\t\t\t\t  true, GSI_SAME_STMT);\n+\t  gcond *cond_stmt\n+\t    = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t  e = split_block (bb1, cond_stmt);\n+\t  e->flags = EDGE_TRUE_VALUE;\n+\t  e->probability = profile_probability::likely ().guessed ();\n+\t  basic_block bb2 = e->dest;\n+\t  gsi2 = gsi_after_labels (bb2);\n+\n+\t  cond_stmt = gimple_build_cond (fd->loops[i].cond_code, n1e, n2e,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t  e = split_block (bb2, cond_stmt);\n+\t  e->flags = EDGE_TRUE_VALUE;\n+\t  e->probability = profile_probability::likely ().guessed ();\n+\t  gsi2 = gsi_after_labels (e->dest);\n+\n+\t  tree step = fold_convert (itype, fd->loops[i].step);\n+\t  t = build_int_cst (itype, (fd->loops[i].cond_code\n+\t\t\t\t     == LT_EXPR ? -1 : 1));\n+\t  t = fold_build2 (PLUS_EXPR, itype, step, t);\n+\t  t = fold_build2 (PLUS_EXPR, itype, t, n2);\n+\t  t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t  if (TYPE_UNSIGNED (itype)\n+\t      && fd->loops[i].cond_code == GT_EXPR)\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, step));\n+\t  else\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t  tree first_inner_iterations\n+\t    = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  t = fold_build2 (MULT_EXPR, itype, m2minusm1, ostep);\n+\t  if (TYPE_UNSIGNED (itype)\n+\t      && fd->loops[i].cond_code == GT_EXPR)\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t     fold_build1 (NEGATE_EXPR, itype, step));\n+\t  else\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t  tree factor\n+\t    = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  t = fold_build2 (MINUS_EXPR, itype, outer_niters,\n+\t\t\t   build_one_cst (itype));\n+\t  t = fold_build2 (MULT_EXPR, itype, t, outer_niters);\n+\t  t = fold_build2 (RSHIFT_EXPR, itype, t, integer_one_node);\n+\t  t = fold_build2 (MULT_EXPR, itype, factor, t);\n+\t  t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t   fold_build2 (MULT_EXPR, itype, outer_niters,\n+\t\t\t\t\tfirst_inner_iterations), t);\n+\t  expand_omp_build_assign (&gsi2, counts[fd->last_nonrect],\n+\t\t\t\t   fold_convert (type, t));\n+\n+\t  basic_block bb3 = create_empty_bb (bb1);\n+\t  add_bb_to_loop (bb3, bb1->loop_father);\n+\n+\t  e = make_edge (bb1, bb3, EDGE_FALSE_VALUE);\n+\t  e->probability = profile_probability::unlikely ().guessed ();\n+\n+\t  gsi2 = gsi_after_labels (bb3);\n+\t  cond_stmt = gimple_build_cond (fd->loops[i].cond_code, n1e, n2e,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t  e = split_block (bb3, cond_stmt);\n+\t  e->flags = EDGE_TRUE_VALUE;\n+\t  e->probability = profile_probability::likely ().guessed ();\n+\t  basic_block bb4 = e->dest;\n+\n+\t  ne = make_edge (bb3, entry_bb, EDGE_FALSE_VALUE);\n+\t  ne->probability = e->probability.invert ();\n+\n+\t  basic_block bb5 = create_empty_bb (bb2);\n+\t  add_bb_to_loop (bb5, bb2->loop_father);\n+\n+\t  ne = make_edge (bb2, bb5, EDGE_FALSE_VALUE);\n+\t  ne->probability = profile_probability::unlikely ().guessed ();\n+\n+\t  for (int j = 0; j < 2; j++)\n+\t    {\n+\t      gsi2 = gsi_after_labels (j ? bb5 : bb4);\n+\t      t = fold_build2 (MINUS_EXPR, itype,\n+\t\t\t       unshare_expr (fd->loops[i].n1),\n+\t\t\t       unshare_expr (fd->loops[i].n2));\n+\t      t = fold_build2 (TRUNC_DIV_EXPR, itype, t, m2minusm1);\n+\t      tree tem\n+\t\t= force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t      t = fold_build2 (MINUS_EXPR, itype, tem, n1o);\n+\t      t = fold_build2 (TRUNC_MOD_EXPR, itype, t, ostep);\n+\t      t = fold_build2 (MINUS_EXPR, itype, tem, t);\n+\t      tem = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t      true, GSI_SAME_STMT);\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t      if (fd->loops[i].m1)\n+\t\t{\n+\t\t  n1 = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n+\t\t  n1 = fold_build2 (MULT_EXPR, itype, tem, n1);\n+\t\t  n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t\t}\n+\t      else\n+\t\tn1 = t;\n+\t      n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t      if (fd->loops[i].m2)\n+\t\t{\n+\t\t  n2 = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t\t  n2 = fold_build2 (MULT_EXPR, itype, tem, n2);\n+\t\t  n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n+\t\t}\n+\t      else\n+\t\tn2 = t;\n+\t      n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      expand_omp_build_assign (&gsi2, j ? n2o : n1o, tem);\n+\n+\t      cond_stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t\t     NULL_TREE, NULL_TREE);\n \t      gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n-\t      e = split_block (cur_bb, cond_stmt);\n-\t      e->flags = EDGE_TRUE_VALUE;\n-\t      ne = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n-\t      e->probability = profile_probability::likely ().guessed ();\n+\t      e = split_block (gsi_bb (gsi2), cond_stmt);\n+\t      e->flags = j ? EDGE_TRUE_VALUE : EDGE_FALSE_VALUE;\n+\t      e->probability = profile_probability::unlikely ().guessed ();\n+\t      ne = make_edge (e->src, bb1,\n+\t\t\t      j ? EDGE_FALSE_VALUE : EDGE_TRUE_VALUE);\n \t      ne->probability = e->probability.invert ();\n \t      gsi2 = gsi_after_labels (e->dest);\n \n-\t      t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n-\t\t\t\t\t ? -1 : 1));\n-\t      t = fold_build2 (PLUS_EXPR, itype,\n-\t\t\t       fold_convert (itype, fd->loops[i].step), t);\n-\t      t = fold_build2 (PLUS_EXPR, itype, t, n2);\n-\t      t = fold_build2 (MINUS_EXPR, itype, t, n1);\n-\t      tree step = fold_convert (itype, fd->loops[i].step);\n-\t      if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n-\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n-\t\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n-\t\t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n-\t      else\n-\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n-\t      t = fold_convert (type, t);\n-\t      t = fold_build2 (PLUS_EXPR, type, counts[fd->last_nonrect], t);\n-\t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n-\t\t\t\t\t    true, GSI_SAME_STMT);\n-\t      expand_omp_build_assign (&gsi2, counts[fd->last_nonrect], t);\n-\t      e = make_edge (e->dest, next_bb, EDGE_FALLTHRU);\n-\t      set_immediate_dominator (CDI_DOMINATORS, next_bb, cur_bb);\n-\t      break;\n-\t    }\n-\t  e = split_block (cur_bb, last_stmt (cur_bb));\n+\t      t = fold_build2 (PLUS_EXPR, itype, tem, ostep);\n+\t      expand_omp_build_assign (&gsi2, j ? n2o : n1o, t);\n \n-\t  basic_block new_cur_bb = create_empty_bb (cur_bb);\n-\t  add_bb_to_loop (new_cur_bb, cur_bb->loop_father);\n+\t      make_edge (e->dest, bb1, EDGE_FALLTHRU);\n+\t    }\n \n-\t  gsi2 = gsi_after_labels (e->dest);\n-\t  tree step = fold_convert (itype, unshare_expr (fd->loops[i].step));\n-\t  t = fold_build2 (PLUS_EXPR, itype, vs[i], step);\n-\t  t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n-\t\t\t\t\ttrue, GSI_SAME_STMT);\n-\t  expand_omp_build_assign (&gsi2, vs[i], t);\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb3, bb1);\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb5, bb2);\n+\t  set_immediate_dominator (CDI_DOMINATORS, entry_bb, bb1);\n+\t}\n+      else\n+\t{\n+\t  /* Fallback implementation.  Evaluate the loops with m1/m2\n+\t     non-NULL as well as their outer loops at runtime using temporaries\n+\t     instead of the original iteration variables, and in the\n+\t     body just bump the counter.  */\n+\t  gimple_stmt_iterator gsi2 = *gsi;\n+\t  gsi_prev (&gsi2);\n+\t  e = split_block (entry_bb, gsi_stmt (gsi2));\n+\t  e = split_block (e->dest, (gimple *) NULL);\n+\t  basic_block cur_bb = e->src;\n+\t  basic_block next_bb = e->dest;\n+\t  entry_bb = e->dest;\n+\t  *gsi = gsi_after_labels (entry_bb);\n \n-\t  ne = split_block (e->dest, last_stmt (e->dest));\n-\t  gsi2 = gsi_after_labels (ne->dest);\n+\t  tree *vs = XALLOCAVEC (tree, fd->last_nonrect);\n+\t  memset (vs, 0, fd->last_nonrect * sizeof (tree));\n \n-\t  gcond *cond_stmt\n-\t    = gimple_build_cond (fd->loops[i].cond_code, vs[i], n2,\n-\t\t\t\t NULL_TREE, NULL_TREE);\n-\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n-\t  edge e3, e4;\n-\t  if (next_bb == entry_bb)\n+\t  for (i = 0; i <= fd->last_nonrect; i++)\n \t    {\n-\t      e3 = find_edge (ne->dest, next_bb);\n-\t      e3->flags = EDGE_FALSE_VALUE;\n+\t      if (fd->loops[i].m1 == NULL_TREE\n+\t\t  && fd->loops[i].m2 == NULL_TREE\n+\t\t  && !fd->loops[i].non_rect_referenced)\n+\t\tcontinue;\n+\n+\t      tree itype = TREE_TYPE (fd->loops[i].v);\n+\n+\t      gsi2 = gsi_after_labels (cur_bb);\n+\t      tree n1, n2;\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t      if (fd->loops[i].m1)\n+\t\t{\n+\t\t  n1 = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n+\t\t  n1 = fold_build2 (MULT_EXPR, itype,\n+\t\t\t\t    vs[i - fd->loops[i].outer], n1);\n+\t\t  n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t\t}\n+\t      else\n+\t\tn1 = t;\n+\t      n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (i < fd->last_nonrect)\n+\t\t{\n+\t\t  vs[i] = create_tmp_reg (itype, \".it\");\n+\t\t  expand_omp_build_assign (&gsi2, vs[i], n1);\n+\t\t}\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t      if (fd->loops[i].m2)\n+\t\t{\n+\t\t  n2 = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t\t  n2 = fold_build2 (MULT_EXPR, itype,\n+\t\t\t\t    vs[i - fd->loops[i].outer], n2);\n+\t\t  n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n+\t\t}\n+\t      else\n+\t\tn2 = t;\n+\t      n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (i == fd->last_nonrect)\n+\t\t{\n+\t\t  gcond *cond_stmt\n+\t\t    = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t\t  e = split_block (cur_bb, cond_stmt);\n+\t\t  e->flags = EDGE_TRUE_VALUE;\n+\t\t  ne = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n+\t\t  e->probability = profile_probability::likely ().guessed ();\n+\t\t  ne->probability = e->probability.invert ();\n+\t\t  gsi2 = gsi_after_labels (e->dest);\n+\n+\t\t  t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n+\t\t\t\t\t     ? -1 : 1));\n+\t\t  t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t\t   fold_convert (itype, fd->loops[i].step), t);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, t, n2);\n+\t\t  t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t\t  tree step = fold_convert (itype, fd->loops[i].step);\n+\t\t  if (TYPE_UNSIGNED (itype)\n+\t\t      && fd->loops[i].cond_code == GT_EXPR)\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, step));\n+\t\t  else\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t\t  t = fold_convert (type, t);\n+\t\t  t = fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t   counts[fd->last_nonrect], t);\n+\t\t  t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t\t  expand_omp_build_assign (&gsi2, counts[fd->last_nonrect], t);\n+\t\t  e = make_edge (e->dest, next_bb, EDGE_FALLTHRU);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, next_bb, cur_bb);\n+\t\t  break;\n+\t\t}\n+\t      e = split_block (cur_bb, last_stmt (cur_bb));\n+\n+\t      basic_block new_cur_bb = create_empty_bb (cur_bb);\n+\t      add_bb_to_loop (new_cur_bb, cur_bb->loop_father);\n+\n+\t      gsi2 = gsi_after_labels (e->dest);\n+\t      tree step = fold_convert (itype,\n+\t\t\t\t\tunshare_expr (fd->loops[i].step));\n+\t      t = fold_build2 (PLUS_EXPR, itype, vs[i], step);\n+\t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t      expand_omp_build_assign (&gsi2, vs[i], t);\n+\n+\t      ne = split_block (e->dest, last_stmt (e->dest));\n+\t      gsi2 = gsi_after_labels (ne->dest);\n+\n+\t      gcond *cond_stmt\n+\t\t= gimple_build_cond (fd->loops[i].cond_code, vs[i], n2,\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t      edge e3, e4;\n+\t      if (next_bb == entry_bb)\n+\t\t{\n+\t\t  e3 = find_edge (ne->dest, next_bb);\n+\t\t  e3->flags = EDGE_FALSE_VALUE;\n+\t\t}\n+\t      else\n+\t\te3 = make_edge (ne->dest, next_bb, EDGE_FALSE_VALUE);\n+\t      e4 = make_edge (ne->dest, new_cur_bb, EDGE_TRUE_VALUE);\n+\t      e4->probability = profile_probability::likely ().guessed ();\n+\t      e3->probability = e4->probability.invert ();\n+\t      basic_block esrc = e->src;\n+\t      make_edge (e->src, ne->dest, EDGE_FALLTHRU);\n+\t      cur_bb = new_cur_bb;\n+\t      basic_block latch_bb = next_bb;\n+\t      next_bb = e->dest;\n+\t      remove_edge (e);\n+\t      set_immediate_dominator (CDI_DOMINATORS, ne->dest, esrc);\n+\t      set_immediate_dominator (CDI_DOMINATORS, latch_bb, ne->dest);\n+\t      set_immediate_dominator (CDI_DOMINATORS, cur_bb, ne->dest);\n \t    }\n-\t  else\n-\t    e3 = make_edge (ne->dest, next_bb, EDGE_FALSE_VALUE);\n-\t  e4 = make_edge (ne->dest, new_cur_bb, EDGE_TRUE_VALUE);\n-\t  e4->probability = profile_probability::likely ().guessed ();\n-\t  e3->probability = e4->probability.invert ();\n-\t  basic_block esrc = e->src;\n-\t  make_edge (e->src, ne->dest, EDGE_FALLTHRU);\n-\t  cur_bb = new_cur_bb;\n-\t  basic_block latch_bb = next_bb;\n-\t  next_bb = e->dest;\n-\t  remove_edge (e);\n-\t  set_immediate_dominator (CDI_DOMINATORS, ne->dest, esrc);\n-\t  set_immediate_dominator (CDI_DOMINATORS, latch_bb, ne->dest);\n-\t  set_immediate_dominator (CDI_DOMINATORS, cur_bb, ne->dest);\n \t}\n       t = NULL_TREE;\n       for (i = fd->first_nonrect; i < fd->last_nonrect; i++)\n@@ -2216,7 +2467,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  tree idx = create_tmp_reg (type, \".count\");\n \t  expand_omp_build_assign (gsi, idx,\n \t\t\t\t   build_zero_cst (type), true);\n-\t  basic_block bb_triang = NULL;\n+\t  basic_block bb_triang = NULL, bb_triang_dom = NULL;\n \t  if (fd->first_nonrect + 1 == fd->last_nonrect\n \t      /* For now.  */\n \t      && TREE_CODE (fd->loop.n2) == INTEGER_CST\n@@ -2236,6 +2487,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      basic_block bb0 = e->src;\n \t      e->flags = EDGE_TRUE_VALUE;\n \t      e->probability = profile_probability::likely ();\n+\t      bb_triang_dom = bb0;\n \t      *gsi = gsi_after_labels (e->dest);\n \t      tree slltype = long_long_integer_type_node;\n \t      tree ulltype = long_long_unsigned_type_node;\n@@ -2615,6 +2867,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      *gsi = gsi_after_labels (e->dest);\n \t      if (!gsi_end_p (*gsi))\n \t\tgsi_insert_before (gsi, gimple_build_nop (), GSI_NEW_STMT);\n+\t      set_immediate_dominator (CDI_DOMINATORS, e->dest, bb_triang_dom);\n \t    }\n \t}\n       else\n@@ -2786,7 +3039,6 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t\t      = profile_probability::guessed_always ().apply_scale (7,\n \t\t\t\t\t\t\t\t\t    8);\n \t\t    set_immediate_dominator (CDI_DOMINATORS, this_bb, prev_bb);\n-\n \t\t  }\n \t\tif (l->m1)\n \t\t  {\n@@ -2831,7 +3083,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t\te->probability\n \t\t  = profile_probability::guessed_always ().apply_scale (1, 8);\n \t\tif (prev_bb == NULL)\n-\t\t  set_immediate_dominator (CDI_DOMINATORS, this_bb, last_bb);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, this_bb, bb);\n \t\tprev_bb = this_bb;\n \t      }\n \t  e = make_edge (prev_bb, body_bb, EDGE_TRUE_VALUE);"}]}