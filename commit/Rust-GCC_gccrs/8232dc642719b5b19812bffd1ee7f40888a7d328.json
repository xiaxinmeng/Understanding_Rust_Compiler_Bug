{"sha": "8232dc642719b5b19812bffd1ee7f40888a7d328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzMmRjNjQyNzE5YjViMTk4MTJiZmZkMWVlN2Y0MDg4OGE3ZDMyOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-01-17T13:29:41Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-01-17T13:29:41Z"}, "message": "functional (_Bind<_Functor(_Bound_args...)>::__call): Rename const version to __call_c and remove _Sfinae template parameter.\n\n2010-01-16  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/functional (_Bind<_Functor(_Bound_args...)>::__call):\n\tRename const version to __call_c and remove _Sfinae template\n\tparameter.\n\t(_Bind<_Functor(_Bound_args...)>::operator()): Adjust.\n\n\t* include/std/functional: Pass everywhere temporary tuple<_Args...>\n\targuments by rvalue reference. \n\n\t* testsuite/20_util/bind/cv_quals.cc: New.\n\n\t* testsuite/20_util/bind/ref2.cc: Add missing test variables.\n\nFrom-SVN: r155978", "tree": {"sha": "a32a0d8e7e63427f86be807f284c3f5b32f9c5fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a32a0d8e7e63427f86be807f284c3f5b32f9c5fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8232dc642719b5b19812bffd1ee7f40888a7d328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8232dc642719b5b19812bffd1ee7f40888a7d328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8232dc642719b5b19812bffd1ee7f40888a7d328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8232dc642719b5b19812bffd1ee7f40888a7d328/comments", "author": null, "committer": null, "parents": [{"sha": "fc35a90d1fe6d3f7a45bedaf24dac177f87e41c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc35a90d1fe6d3f7a45bedaf24dac177f87e41c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc35a90d1fe6d3f7a45bedaf24dac177f87e41c6"}], "stats": {"total": 232, "additions": 137, "deletions": 95}, "files": [{"sha": "0e25c9e2ae58865c106f27699418e57552f0ddf8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8232dc642719b5b19812bffd1ee7f40888a7d328", "patch": "@@ -1,3 +1,17 @@\n+2010-01-16  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/functional (_Bind<_Functor(_Bound_args...)>::__call):\n+\tRename const version to __call_c and remove _Sfinae template\n+\tparameter.\n+\t(_Bind<_Functor(_Bound_args...)>::operator()): Adjust.\n+\n+\t* include/std/functional: Pass everywhere temporary tuple<_Args...>\n+\targuments by rvalue reference.\n+\n+\t* testsuite/20_util/bind/cv_quals.cc: New.\n+\n+\t* testsuite/20_util/bind/ref2.cc: Add missing test variables.\n+\n 2010-01-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR libstdc++/35942"}, {"sha": "5444f3d1f1ce4cef74656eadd094b13242d5cac9", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 65, "deletions": 95, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=8232dc642719b5b19812bffd1ee7f40888a7d328", "patch": "@@ -1,6 +1,6 @@\n // <functional> -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -112,8 +112,7 @@ namespace std\n   template<typename _Functor>\n     struct _Weak_result_type_impl\n     : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n-    {\n-    };\n+    { };\n \n   /// Retrieve the result type for a function type.\n   template<typename _Res, typename... _ArgTypes> \n@@ -171,8 +170,7 @@ namespace std\n   template<typename _Functor>\n     struct _Weak_result_type\n     : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n-    {\n-    };\n+    { };\n \n   template<typename _Signature>\n     class result_of;\n@@ -859,8 +857,7 @@ namespace std\n     struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n     : _Build_index_tuple<_Num - 1, \n                          _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n-    {\n-    };\n+    { };\n \n   template<int... _Indexes>\n     struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n@@ -902,8 +899,7 @@ namespace std\n    struct _Safe_tuple_element\n    : _Safe_tuple_element_impl<__i, _Tuple, \n                               (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n-   {\n-   };\n+   { };\n \n   /**\n    *  Maps an argument to bind() into an actual argument to the bound\n@@ -937,7 +933,7 @@ namespace std\n        */\n       template<typename _CVRef, typename _Tuple>\n         result_type\n-        operator()(_CVRef& __arg, const _Tuple&) const volatile\n+        operator()(_CVRef& __arg, _Tuple&&) const volatile\n         { return __arg.get(); }\n     };\n \n@@ -962,20 +958,20 @@ namespace std\n       template<typename _CVArg, typename... _Args>\n         typename result_of<_CVArg(_Args...)>::type\n         operator()(_CVArg& __arg,\n-\t\t   tuple<_Args...>& __tuple) const volatile\n+\t\t   tuple<_Args...>&& __tuple) const volatile\n         {\n \t  // Construct an index tuple and forward to __call\n \t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n \t    _Indexes;\n-\t  return this->__call(__arg, __tuple, _Indexes());\n+\t  return this->__call(__arg, std::move(__tuple), _Indexes());\n \t}\n \n     private:\n       // Invokes the underlying function object __arg by unpacking all\n       // of the arguments in the tuple. \n       template<typename _CVArg, typename... _Args, int... _Indexes>\n         typename result_of<_CVArg(_Args...)>::type\n-        __call(_CVArg& __arg, tuple<_Args...>& __tuple,\n+        __call(_CVArg& __arg, tuple<_Args...>&& __tuple,\n \t       const _Index_tuple<_Indexes...>&) const volatile\n         {\n \t  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);\n@@ -1009,7 +1005,7 @@ namespace std\n \n       template<typename _Tuple>\n         typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n+        operator()(const volatile _Arg&, _Tuple&& __tuple) const volatile\n         {\n \t  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(\n               ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n@@ -1036,7 +1032,7 @@ namespace std\n       // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n         _CVArg&&\n-        operator()(_CVArg&& __arg, const _Tuple&) const volatile\n+        operator()(_CVArg&& __arg, _Tuple&&) const volatile\n         { return std::forward<_CVArg>(__arg); }\n     };\n \n@@ -1096,137 +1092,114 @@ namespace std\n       tuple<_Bound_args...> _M_bound_args;\n \n       // Call unqualified\n-      template<typename... _Args, int... _Indexes, typename _Sfinae\n-        = decltype( std::declval<_Functor>()(\n-              _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n+      template<typename... _Args, int... _Indexes>\n         typename result_of<\n                    _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args&, tuple<_Args...>&)>::type...)\n+                            (_Bound_args&, tuple<_Args...>&&)>::type...)\n                  >::type\n         __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const\n-      template<typename... _Args, int... _Indexes, typename _Sfinae\n-        = decltype( std::declval<const _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n+      template<typename... _Args, int... _Indexes>\n         typename result_of<\n                    const _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const _Bound_args&, tuple<_Args...>&)\n+                                    (const _Bound_args&, tuple<_Args...>&&)\n                                   >::type...)>::type\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n+        __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n #if 0\n       // Call as volatile\n-      template<typename... _Args, int... _Indexes, typename _Sfinae\n-        = decltype( std::declval<volatile _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n+      template<typename... _Args, int... _Indexes>\n         typename result_of<\n                    volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (volatile _Bound_args&, tuple<_Args...>&)\n+                                    (volatile _Bound_args&, tuple<_Args...>&&)\n                                   >::type...)>::type\n-        __call(tuple<_Args...>&& __args, \n-               _Index_tuple<_Indexes...>) volatile\n+        __call_v(tuple<_Args...>&& __args, \n+\t\t _Index_tuple<_Indexes...>) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const volatile\n-      template<typename... _Args, int... _Indexes, typename _Sfinae\n-        = decltype( std::declval<const volatile _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n+      template<typename... _Args, int... _Indexes>\n         typename result_of<\n                    const volatile _Functor(typename result_of<_Mu<_Bound_args> \n                                     (const volatile _Bound_args&, \n-                                     tuple<_Args...>&)\n+                                     tuple<_Args...>&&)\n                                   >::type...)>::type\n-        __call(tuple<_Args...>&& __args, \n-               _Index_tuple<_Indexes...>) const volatile\n+        __call_c_v(tuple<_Args...>&& __args, \n+\t\t   _Index_tuple<_Indexes...>) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n #endif\n \n      public:\n       explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n       : _M_f(std::forward<_Functor>(__f)),\n-      _M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+\t_M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n       { }\n \n       // Call unqualified\n-      template<typename... _Args, typename _Sfinae\n+      template<typename... _Args, typename _Result\n         = decltype( std::declval<_Functor>()(\n               _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        typename result_of<\n-                   _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args&, tuple<_Args...>&)>::type...)\n-                 >::type\n+\t\t\t\t  std::declval<tuple<_Args...>&&>() )... ) )>\n+        _Result\n         operator()(_Args&&... __args)\n         {\n           return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n-                              _Bound_indexes());\n+\t\t\t      _Bound_indexes());\n         }\n \n       // Call as const\n-      template<typename... _Args, typename _Sfinae\n+      template<typename... _Args, typename _Result\n         = decltype( std::declval<const _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        typename result_of<\n-                   const _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const _Bound_args&, tuple<_Args...>&)>::type...)\n-                 >::type\n+\t      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n+\t\t\t\t  std::declval<tuple<_Args...>&&>() )... ) )>\n+        _Result\n         operator()(_Args&&... __args) const\n         {\n-          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n-                              _Bound_indexes());\n+          return this->__call_c(tuple<_Args...>\n+\t\t\t\t(std::forward<_Args>(__args)...),\n+\t\t\t\t_Bound_indexes());\n         }\n \n #if 0\n       // Call as volatile\n-      template<typename... _Args, typename _Sfinae\n+      template<typename... _Args, typename _Result\n         = decltype( std::declval<volatile _Functor>()(\n               _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        typename result_of<\n-                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (volatile _Bound_args&, tuple<_Args...>&)>::type...)\n-                 >::type\n+                                  std::declval<tuple<_Args...>&&>() )... ) )>\n+        _Result\n         operator()(_Args&&... __args) volatile\n         {\n-          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n-                              _Bound_indexes());\n+          return this->__call_v(tuple<_Args...>\n+\t\t\t\t(std::forward<_Args>(__args)...),\n+\t\t\t\t_Bound_indexes());\n         }\n \n-\n       // Call as const volatile\n-      template<typename... _Args, typename _Sfinae\n+      template<typename... _Args, typename _Result\n         = decltype( std::declval<const volatile _Functor>()(\n               _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        typename result_of<\n-                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const volatile _Bound_args&, \n-                             tuple<_Args...>&)>::type...)\n-                 >::type\n+                                  std::declval<tuple<_Args...>&&>() )... ) )>\n+        _Result\n         operator()(_Args&&... __args) const volatile\n         {\n-          return this->__call(tuple<_Args...>(std::forward<_Args>(__args)...),\n-                              _Bound_indexes());\n+          return this->__call_c_v(tuple<_Args...>\n+\t\t\t\t  (std::forward<_Args>(__args)...),\n+\t\t\t\t  _Bound_indexes());\n         }\n #endif\n     };\n@@ -1258,7 +1231,7 @@ namespace std\n             typename __disable_if_void<_Res>::type = 0)\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call unqualified, return void\n@@ -1268,7 +1241,7 @@ namespace std\n             typename __enable_if_void<_Res>::type = 0)\n         {\n           _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const\n@@ -1278,7 +1251,7 @@ namespace std\n             typename __disable_if_void<_Res>::type = 0) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const, return void\n@@ -1288,7 +1261,7 @@ namespace std\n             typename __enable_if_void<_Res>::type = 0) const\n         {\n           _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+\t       (get<_Indexes>(_M_bound_args),  std::move(__args))...);\n         }\n \n       // Call as volatile\n@@ -1298,7 +1271,7 @@ namespace std\n             typename __disable_if_void<_Res>::type = 0) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as volatile, return void\n@@ -1308,7 +1281,7 @@ namespace std\n             typename __enable_if_void<_Res>::type = 0) volatile\n         {\n           _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const volatile\n@@ -1318,7 +1291,7 @@ namespace std\n             typename __disable_if_void<_Res>::type = 0) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n       // Call as const volatile, return void\n@@ -1329,7 +1302,7 @@ namespace std\n             typename __enable_if_void<_Res>::type = 0) const volatile\n         {\n           _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n+\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n         }\n \n     public:\n@@ -1338,7 +1311,7 @@ namespace std\n       explicit\n       _Bind_result(_Functor __f, _Bound_args... __bound_args)\n       : _M_f(std::forward<_Functor>(__f)),\n-      _M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+\t_M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n       { }\n \n       // Call unqualified\n@@ -1447,11 +1420,9 @@ namespace std\n    */\n   template<typename _Tp>\n     struct __is_location_invariant\n-    : integral_constant<bool,\n-                        (is_pointer<_Tp>::value\n-                         || is_member_pointer<_Tp>::value)>\n-    {\n-    };\n+    : integral_constant<bool, (is_pointer<_Tp>::value\n+\t\t\t       || is_member_pointer<_Tp>::value)>\n+    { };\n \n   class _Undefined_class;\n \n@@ -1503,8 +1474,7 @@ namespace std\n   template<typename _Tp>\n     struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n     : __is_location_invariant<_Tp>\n-    {\n-    };\n+    { };\n \n   // Converts a reference to a function object into a callable\n   // function object."}, {"sha": "b42fe9a6159b4cec342b0148c74e16346ab9cd87", "filename": "libstdc++-v3/testsuite/20_util/bind/cv_quals.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc?ref=8232dc642719b5b19812bffd1ee7f40888a7d328", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.11 Function template bind\n+\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  int operator()() { return 0; }\n+  int operator()() const { return 1; }\n+  // int operator()() volatile { return 2; }\n+  // int operator()() const volatile { return 3; }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b0 = std::bind(X());\n+  VERIFY( b0() == 0 );\n+\n+  const auto b1 = std::bind(X());\n+  VERIFY( b1() == 1 );\n+\n+  // volatile auto b2 = std::bind(X());\n+  // VERIFY( b2() == 2 );\n+\n+  // const volatile auto b3 = std::bind(X());\n+  // VERIFY( b3() == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "614943157565eef0fd1b38e06d8e5b8474fb8e8f", "filename": "libstdc++-v3/testsuite/20_util/bind/ref2.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8232dc642719b5b19812bffd1ee7f40888a7d328/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref2.cc?ref=8232dc642719b5b19812bffd1ee7f40888a7d328", "patch": "@@ -28,6 +28,8 @@ int inc(int& i) { return ++i; }\n \n void test01()\n {\n+  bool test __attribute__((unused)) = true;\n+\n   int counter = 0;\n   std::bind(&inc, _1)(counter);\n   VERIFY(counter == 1 );\n@@ -45,6 +47,8 @@ struct Inc\n \n void test02()\n {\n+  bool test __attribute__((unused)) = true;\n+\n   int counter = 0;\n   std::bind(Inc(), _1)(counter);\n   VERIFY(counter == 1 );"}]}