{"sha": "1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZiNDljZTc3YjI4OGU2NWNiNGYwY2Q0MTdjNTIxY2M4OWVjM2Y0Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-23T15:15:34Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-01-23T15:15:34Z"}, "message": "r110125@banpei: zack | 2006-01-22 14:46:46 -0800\n\n r110125@banpei:  zack | 2006-01-22 14:46:46 -0800\n \t* genautomata.c:  Include vec.h, not varray.h.\n \tDelete vla_ptr_t, all of the VLA_PTR_ macros, and all of the\n \tVLA_HWINT_ macros.  Change vla_hwint_t to a typedef for\n \tVEC(vect_el_t,heap) *.  Convert all uses of VLA_* macros to\n \tVEC_* macros operating on appropriately typed vectors, or to\n \tmalloced arrays when the size is known in advance.  Const-ify\n \tmany char* variables and function arguments.  No functional changes.\n \t* Makefile.in (build/varray.o): Delete rule.\n \t(build/genattrtab): Depend on build/vec.o instead of build/varray.o.\n \t(build/genautomata.o): Depend on vec.h instead of $(VARRAY_H).\n\nFrom-SVN: r110121", "tree": {"sha": "ba82f26baf1666af04f5b28cd471b1fea2affe86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba82f26baf1666af04f5b28cd471b1fea2affe86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0458fe77b852f0dc55fd301376ff2a60c52b2ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0458fe77b852f0dc55fd301376ff2a60c52b2ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0458fe77b852f0dc55fd301376ff2a60c52b2ec4"}], "stats": {"total": 1389, "additions": 641, "deletions": 748}, "files": [{"sha": "3224426efbff875dd2fca1ddb681313af3efb078", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "patch": "@@ -1,3 +1,16 @@\n+2006-01-22  Zack Weinberg  <zackw@panix.com>\n+\n+\t* genautomata.c:  Include vec.h, not varray.h.\n+\tDelete vla_ptr_t, all of the VLA_PTR_ macros, and all of the\n+\tVLA_HWINT_ macros.  Change vla_hwint_t to a typedef for\n+\tVEC(vect_el_t,heap) *.  Convert all uses of VLA_* macros to\n+\tVEC_* macros operating on appropriately typed vectors, or to\n+\tmalloced arrays when the size is known in advance.  Const-ify\n+\tmany char* variables and function arguments.  No functional changes.\n+\t* Makefile.in (build/varray.o): Delete rule.\n+\t(build/genattrtab): Depend on build/vec.o instead of build/varray.o.\n+\t(build/genautomata.o): Depend on vec.h instead of $(VARRAY_H).\n+\n 2006-01-22  Zack Weinberg  <zackw@panix.com>\n \n \t* gensupport.c: Define get_insn_name and record_insn_name here."}, {"sha": "f9e85d211921211164367b3eb67ba59fa4253215", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "patch": "@@ -2894,8 +2894,6 @@ build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) gensupport.h\n build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) real.h $(GGC_H) errors.h\n-build/varray.o: varray.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n-  $(VARRAY_H) $(RTL_BASE_H) $(GGC_H) $(TREE_H) bitmap.h errors.h\n build/vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h \\\n    $(GGC_H) toplev.h\n build/gencondmd.o : build/gencondmd.c $(CONFIG_H) $(SYSTEM_H) $(GTM_H)\t\\\n@@ -2910,7 +2908,7 @@ build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n   gensupport.h genattrtab.h\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n-  $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VARRAY_H)\t\\\n+  $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h vec.h\t\t\\\n   genattrtab.h $(HASHTAB_H)\n build/gencheck.o : gencheck.c gencheck.h tree.def $(BCONFIG_H) $(GTM_H)\t\\\n \t$(SYSTEM_H) coretypes.h $(lang_tree_files)\n@@ -2968,7 +2966,7 @@ $(genprogmd:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_ERRORS)\n \n # These programs need files over and above what they get from the above list.\n build/genextract$(build_exeext) : build/vec.o\n-build/genattrtab$(build_exeext) : build/genautomata.o build/varray.o\n+build/genattrtab$(build_exeext) : build/genautomata.o build/vec.o\n build/genattrtab$(build_exeext) : BUILD_LIBS += -lm\n \n # These programs are not linked with the MD reader."}, {"sha": "987d1e78275e41b0b9f2ee663847e7105f3e321d", "filename": "gcc/genautomata.c", "status": "modified", "additions": 626, "deletions": 744, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb49ce77b288e65cb4f0cd417c521cc89ec3f42/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=1fb49ce77b288e65cb4f0cd417c521cc89ec3f42", "patch": "@@ -113,6 +113,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include <math.h>\n #include \"hashtab.h\"\n #include \"varray.h\"\n+#include \"vec.h\"\n \n #ifndef CHAR_BIT\n #define CHAR_BIT 8\n@@ -132,17 +133,6 @@ typedef unsigned HOST_WIDE_INT set_el_t;\n    type.  */\n typedef set_el_t *reserv_sets_t;\n \n-/* The following structure represents variable length array (vla) of\n-   pointers and HOST WIDE INTs.  We could be use only varray.  But we\n-   add new lay because we add elements very frequently and this could\n-   stress OS allocator when varray is used only.  */\n-typedef struct {\n-  size_t length;      /* current size of vla.  */\n-  varray_type varray; /* container for vla.  */\n-} vla_ptr_t;\n-\n-typedef vla_ptr_t vla_hwint_t;\n-\n /* The following structure describes a ticker.  */\n struct ticker\n {\n@@ -218,40 +208,40 @@ typedef struct state_ainsn_table *state_ainsn_table_t;\n \n static void *create_node             (size_t);\n static void *copy_node               (const void *, size_t);\n-static char *check_name              (char *, pos_t);\n-static char *next_sep_el             (char **, int, int);\n-static int n_sep_els                 (char *, int, int);\n-static char **get_str_vect           (char *, int *, int, int);\n+static const char *check_name        (const char *, pos_t);\n+static char *next_sep_el             (const char **, int, int);\n+static int n_sep_els                 (const char *, int, int);\n+static char **get_str_vect           (const char *, int *, int, int);\n static void gen_presence_absence_set (rtx, int, int);\n-static regexp_t gen_regexp_el        (char *);\n-static regexp_t gen_regexp_repeat    (char *);\n-static regexp_t gen_regexp_allof     (char *);\n-static regexp_t gen_regexp_oneof     (char *);\n-static regexp_t gen_regexp_sequence  (char *);\n-static regexp_t gen_regexp           (char *);\n+static regexp_t gen_regexp_el        (const char *);\n+static regexp_t gen_regexp_repeat    (const char *);\n+static regexp_t gen_regexp_allof     (const char *);\n+static regexp_t gen_regexp_oneof     (const char *);\n+static regexp_t gen_regexp_sequence  (const char *);\n+static regexp_t gen_regexp           (const char *);\n \n static unsigned string_hash          (const char *);\n static unsigned automaton_decl_hash  (const void *);\n static int automaton_decl_eq_p       (const void *,\n \t\t\t\t      const void *);\n static decl_t insert_automaton_decl       (decl_t);\n-static decl_t find_automaton_decl         (char *);\n+static decl_t find_automaton_decl         (const char *);\n static void initiate_automaton_decl_table (void);\n static void finish_automaton_decl_table   (void);\n \n static hashval_t insn_decl_hash           (const void *);\n static int insn_decl_eq_p                 (const void *,\n \t\t\t\t\t   const void *);\n static decl_t insert_insn_decl            (decl_t);\n-static decl_t find_insn_decl              (char *);\n+static decl_t find_insn_decl              (const char *);\n static void initiate_insn_decl_table      (void);\n static void finish_insn_decl_table        (void);\n \n static hashval_t decl_hash                (const void *);\n static int decl_eq_p                      (const void *,\n \t\t\t\t\t   const void *);\n static decl_t insert_decl                 (decl_t);\n-static decl_t find_decl                   (char *);\n+static decl_t find_decl                   (const char *);\n static void initiate_decl_table           (void);\n static void finish_decl_table             (void);\n \n@@ -385,7 +375,6 @@ static void form_ainsn_with_same_reservs    (automaton_t);\n static reserv_sets_t form_reservs_matter (automaton_t);\n static void make_automaton           (automaton_t);\n static void form_arcs_marked_by_insn (state_t);\n-static int create_composed_state     (state_t, arc_t, vla_ptr_t *);\n static void NDFA_to_DFA              (automaton_t);\n static void pass_state_graph         (state_t, void (*) (state_t));\n static void pass_states              (automaton_t,\n@@ -394,15 +383,8 @@ static void initiate_pass_states       (void);\n static void add_achieved_state         (state_t);\n static int set_out_arc_insns_equiv_num (state_t, int);\n static void clear_arc_insns_equiv_num  (state_t);\n-static void copy_equiv_class           (vla_ptr_t *to,\n-\t\t\t\t\tconst vla_ptr_t *from);\n static int first_cycle_unit_presence   (state_t, int);\n static int state_is_differed           (state_t, state_t, int, int);\n-static state_t init_equiv_class        (state_t *states, int);\n-static int partition_equiv_class       (state_t *, int,\n-\t\t\t\t\tvla_ptr_t *, int *);\n-static void evaluate_equiv_classes     (automaton_t, vla_ptr_t *);\n-static void merge_states               (automaton_t, vla_ptr_t *);\n static void set_new_cycle_flags        (state_t);\n static void minimize_DFA               (automaton_t);\n static void incr_states_and_arcs_nums  (state_t);\n@@ -434,7 +416,6 @@ static void output_range_type            (FILE *, long int, long int);\n static int longest_path_length           (state_t);\n static void process_state_longest_path_length (state_t);\n static void output_dfa_max_issue_rate    (void);\n-static void output_vect                  (vect_el_t *, int);\n static void output_chip_member_name      (FILE *, automaton_t);\n static void output_temp_chip_member_name (FILE *, automaton_t);\n static void output_translate_vect_name   (FILE *, automaton_t);\n@@ -455,15 +436,11 @@ static void output_translate_vect        (automaton_t);\n static int comb_vect_p                   (state_ainsn_table_t);\n static state_ainsn_table_t create_state_ainsn_table (automaton_t);\n static void output_state_ainsn_table\n-   (state_ainsn_table_t, char *, void (*) (FILE *, automaton_t),\n+   (state_ainsn_table_t, const char *, void (*) (FILE *, automaton_t),\n     void (*) (FILE *, automaton_t), void (*) (FILE *, automaton_t),\n     void (*) (FILE *, automaton_t));\n-static void add_vect                     (state_ainsn_table_t,\n-\t\t\t\t\t  int, vect_el_t *, int);\n static int out_state_arcs_num            (state_t);\n static int compare_transition_els_num    (const void *, const void *);\n-static void add_vect_el\t         (vla_hwint_t *,\n-\t\t\t\t\t  ainsn_t, int);\n static void add_states_vect_el           (state_t);\n static void output_trans_table           (automaton_t);\n static void output_state_alts_table      (automaton_t);\n@@ -539,110 +516,22 @@ static pos_t no_pos = 0;\n static struct obstack irp;\n \n \f\n-\n-/* This page contains code for work with variable length array (vla)\n-   of pointers.  We could be use only varray.  But we add new lay\n-   because we add elements very frequently and this could stress OS\n-   allocator when varray is used only.  */\n-\n-/* Start work with vla.  */\n-#define VLA_PTR_CREATE(vla, allocated_length, name)\t \\\n-  do\t\t\t\t\t\t\t\t\t \\\n-    {\t \\\n-      vla_ptr_t *const _vla_ptr = &(vla);                                \\\n-\t \\\n-      VARRAY_GENERIC_PTR_INIT (_vla_ptr->varray, allocated_length, name);\\\n-      _vla_ptr->length = 0;                                              \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  while (0)\n-\n-/* Finish work with the vla.  */\n-#define VLA_PTR_DELETE(vla) VARRAY_FREE ((vla).varray)\n-\n-/* Return start address of the vla.  */\n-#define VLA_PTR_BEGIN(vla) ((void *) &VARRAY_GENERIC_PTR ((vla).varray, 0))\n-\n-/* Address of the last element of the vla.  Do not use side effects in\n-   the macro argument.  */\n-#define VLA_PTR_LAST(vla) (&VARRAY_GENERIC_PTR ((vla).varray,         \\\n-                                                (vla).length - 1))\n-/* Nullify the vla.  */\n-#define VLA_PTR_NULLIFY(vla)  ((vla).length = 0)\n-\n-/* Shorten the vla on given number bytes.  */\n-#define VLA_PTR_SHORTEN(vla, n)  ((vla).length -= (n))\n-\n-/* Expand the vla on N elements.  The values of new elements are\n-   undefined.  */\n-#define VLA_PTR_EXPAND(vla, n)                                        \\\n-  do {                                                                \\\n-    vla_ptr_t *const _expand_vla_ptr = &(vla);                        \\\n-    const size_t _new_length = (n) + _expand_vla_ptr->length;         \\\n-                                                                      \\\n-    if (VARRAY_SIZE (_expand_vla_ptr->varray) < _new_length)          \\\n-      VARRAY_GROW (_expand_vla_ptr->varray,                           \\\n-                   (_new_length - _expand_vla_ptr->length < 128       \\\n-                    ? _expand_vla_ptr->length + 128 : _new_length));  \\\n-    _expand_vla_ptr->length = _new_length;                            \\\n-  } while (0)\n-\n-/* Add element to the end of the vla.  */\n-#define VLA_PTR_ADD(vla, ptr)                                           \\\n-  do {                                                                  \\\n-    vla_ptr_t *const _vla_ptr = &(vla);                                 \\\n-                                                                        \\\n-    VLA_PTR_EXPAND (*_vla_ptr, 1);                                      \\\n-    VARRAY_GENERIC_PTR (_vla_ptr->varray, _vla_ptr->length - 1) = (ptr);\\\n-  } while (0)\n-\n-/* Length of the vla in elements.  */\n-#define VLA_PTR_LENGTH(vla) ((vla).length)\n-\n-/* N-th element of the vla.  */\n-#define VLA_PTR(vla, n) VARRAY_GENERIC_PTR ((vla).varray, n)\n-\n-\n-/* The following macros are analogous to the previous ones but for\n-   VLAs of HOST WIDE INTs.  */\n-\n-#define VLA_HWINT_CREATE(vla, allocated_length, name)                 \\\n-  do {                                                                \\\n-    vla_hwint_t *const _vla_ptr = &(vla);                             \\\n-                                                                      \\\n-    VARRAY_WIDE_INT_INIT (_vla_ptr->varray, allocated_length, name);  \\\n-    _vla_ptr->length = 0;                                             \\\n-  } while (0)\n-\n-#define VLA_HWINT_DELETE(vla) VARRAY_FREE ((vla).varray)\n-\n-#define VLA_HWINT_BEGIN(vla) (&VARRAY_WIDE_INT ((vla).varray, 0))\n-\n-#define VLA_HWINT_NULLIFY(vla)  ((vla).length = 0)\n-\n-#define VLA_HWINT_EXPAND(vla, n)                                      \\\n-  do {                                                                \\\n-    vla_hwint_t *const _expand_vla_ptr = &(vla);                      \\\n-    const size_t _new_length = (n) + _expand_vla_ptr->length;         \\\n-                                                                      \\\n-    if (VARRAY_SIZE (_expand_vla_ptr->varray) < _new_length)          \\\n-      VARRAY_GROW (_expand_vla_ptr->varray,                           \\\n-                   (_new_length - _expand_vla_ptr->length < 128       \\\n-                    ? _expand_vla_ptr->length + 128 : _new_length));  \\\n-    _expand_vla_ptr->length = _new_length;                            \\\n-  } while (0)\n-\n-#define VLA_HWINT_ADD(vla, ptr)                                       \\\n-  do {                                                                \\\n-    vla_hwint_t *const _vla_ptr = &(vla);                             \\\n-                                                                      \\\n-    VLA_HWINT_EXPAND (*_vla_ptr, 1);                                  \\\n-    VARRAY_WIDE_INT (_vla_ptr->varray, _vla_ptr->length - 1) = (ptr); \\\n-  } while (0)\n-\n-#define VLA_HWINT_LENGTH(vla) ((vla).length)\n-\n-#define VLA_HWINT(vla, n) VARRAY_WIDE_INT ((vla).varray, n)\n-\n+/* Declare vector types for various data structures: */\n+\n+DEF_VEC_P(alt_state_t);\n+DEF_VEC_ALLOC_P(alt_state_t,heap);\n+DEF_VEC_P(ainsn_t);\n+DEF_VEC_ALLOC_P(ainsn_t,heap);\n+DEF_VEC_P(state_t);\n+DEF_VEC_ALLOC_P(state_t,heap);\n+DEF_VEC_P(decl_t);\n+DEF_VEC_ALLOC_P(decl_t,heap);\n+DEF_VEC_P(reserv_sets_t);\n+DEF_VEC_ALLOC_P(reserv_sets_t,heap);\n+\n+DEF_VEC_I(vect_el_t);\n+DEF_VEC_ALLOC_I(vect_el_t, heap);\n+typedef VEC(vect_el_t,heap) *vla_hwint_t;\n \f\n \n /* Options with the following names can be set up in automata_option\n@@ -727,9 +616,9 @@ enum decl_mode\n    rtl.def).  */\n struct unit_decl\n {\n-  char *name;\n+  const char *name;\n   /* NULL if the automaton name is absent.  */\n-  char *automaton_name;\n+  const char *automaton_name;\n   /* If the following value is not zero, the cpu unit reservation is\n      described in define_query_cpu_unit.  */\n   char query_p;\n@@ -789,9 +678,9 @@ struct unit_decl\n struct bypass_decl\n {\n   int latency;\n-  char *out_insn_name;\n-  char *in_insn_name;\n-  char *bypass_guard_name;\n+  const char *out_insn_name;\n+  const char *in_insn_name;\n+  const char *bypass_guard_name;\n \n   /* The following fields are defined by checker.  */\n \n@@ -805,7 +694,7 @@ struct bypass_decl\n /* This describes define_automaton (see file rtl.def).  */\n struct automaton_decl\n {\n-  char *name;\n+  const char *name;\n \n   /* The following fields are defined by automaton generator.  */\n \n@@ -845,7 +734,7 @@ struct unit_pattern_rel_decl\n /* This describes define_reservation (see file rtl.def).  */\n struct reserv_decl\n {\n-  char *name;\n+  const char *name;\n   regexp_t regexp;\n \n   /* The following fields are defined by checker.  */\n@@ -864,7 +753,7 @@ struct insn_reserv_decl\n   rtx condexp;\n   int default_latency;\n   regexp_t regexp;\n-  char *name;\n+  const char *name;\n \n   /* The following fields are defined by checker.  */\n \n@@ -938,14 +827,14 @@ enum regexp_mode\n /* Cpu unit in reservation.  */\n struct unit_regexp\n {\n-  char *name;\n+  const char *name;\n   unit_decl_t unit_decl;\n };\n \n /* Define_reservation in a reservation.  */\n struct reserv_regexp\n {\n-  char *name;\n+  const char *name;\n   struct reserv_decl *reserv_decl;\n };\n \n@@ -1532,8 +1421,8 @@ copy_node (const void *from, size_t size)\n }\n \n /* The function checks that NAME does not contain quotes (`\"').  */\n-static char *\n-check_name (char * name, pos_t pos ATTRIBUTE_UNUSED)\n+static const char *\n+check_name (const char * name, pos_t pos ATTRIBUTE_UNUSED)\n {\n   const char *str;\n \n@@ -1545,18 +1434,18 @@ check_name (char * name, pos_t pos ATTRIBUTE_UNUSED)\n \n /* Pointers to all declarations during IR generation are stored in the\n    following.  */\n-static vla_ptr_t decls;\n+static VEC(decl_t,heap) *decls;\n \n /* Given a pointer to a (char *) and a separator, return an alloc'ed\n    string containing the next separated element, taking parentheses\n    into account if PAR_FLAG has nonzero value.  Advance the pointer to\n    after the string scanned, or the end-of-string.  Return NULL if at\n    end of string.  */\n static char *\n-next_sep_el (char **pstr, int sep, int par_flag)\n+next_sep_el (const char **pstr, int sep, int par_flag)\n {\n   char *out_str;\n-  char *p;\n+  const char *p;\n   int pars_num;\n   int n_spaces;\n \n@@ -1601,7 +1490,7 @@ next_sep_el (char **pstr, int sep, int par_flag)\n    nonzero value.  Return 0 for the null string, -1 if parentheses is\n    not balanced.  */\n static int\n-n_sep_els (char *s, int sep, int par_flag)\n+n_sep_els (const char *s, int sep, int par_flag)\n {\n   int n;\n   int pars_num;\n@@ -1626,11 +1515,11 @@ n_sep_els (char *s, int sep, int par_flag)\n    function also inserts the end marker NULL at the end of vector.\n    Return 0 for the null string, -1 if parentheses are not balanced.  */\n static char **\n-get_str_vect (char *str, int *els_num, int sep, int paren_p)\n+get_str_vect (const char *str, int *els_num, int sep, int paren_p)\n {\n   int i;\n   char **vect;\n-  char **pstr;\n+  const char **pstr;\n   char *trail;\n \n   *els_num = n_sep_els (str, sep, paren_p);\n@@ -1660,8 +1549,7 @@ gen_cpu_unit (rtx def)\n   int vect_length;\n   int i;\n \n-  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n-\t\t\t\tFALSE);\n+  str_cpu_units = get_str_vect (XSTR (def, 0), &vect_length, ',', FALSE);\n   if (str_cpu_units == NULL)\n     fatal (\"invalid string `%s' in define_cpu_unit\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n@@ -1670,11 +1558,11 @@ gen_cpu_unit (rtx def)\n       decl->mode = dm_unit;\n       decl->pos = 0;\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n-      DECL_UNIT (decl)->automaton_name = (char *) XSTR (def, 1);\n+      DECL_UNIT (decl)->automaton_name = XSTR (def, 1);\n       DECL_UNIT (decl)->query_p = 0;\n       DECL_UNIT (decl)->min_occ_cycle_num = -1;\n       DECL_UNIT (decl)->in_set_p = 0;\n-      VLA_PTR_ADD (decls, decl);\n+      VEC_safe_push (decl_t,heap, decls, decl);\n       num_dfa_decls++;\n     }\n }\n@@ -1691,7 +1579,7 @@ gen_query_cpu_unit (rtx def)\n   int vect_length;\n   int i;\n \n-  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n+  str_cpu_units = get_str_vect (XSTR (def, 0), &vect_length, ',',\n \t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n     fatal (\"invalid string `%s' in define_query_cpu_unit\", XSTR (def, 0));\n@@ -1701,9 +1589,9 @@ gen_query_cpu_unit (rtx def)\n       decl->mode = dm_unit;\n       decl->pos = 0;\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n-      DECL_UNIT (decl)->automaton_name = (char *) XSTR (def, 1);\n+      DECL_UNIT (decl)->automaton_name = XSTR (def, 1);\n       DECL_UNIT (decl)->query_p = 1;\n-      VLA_PTR_ADD (decls, decl);\n+      VEC_safe_push (decl_t,heap, decls, decl);\n       num_dfa_decls++;\n     }\n }\n@@ -1723,10 +1611,10 @@ gen_bypass (rtx def)\n   int in_length;\n   int i, j;\n \n-  out_insns = get_str_vect ((char *) XSTR (def, 1), &out_length, ',', FALSE);\n+  out_insns = get_str_vect (XSTR (def, 1), &out_length, ',', FALSE);\n   if (out_insns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 1));\n-  in_insns = get_str_vect ((char *) XSTR (def, 2), &in_length, ',', FALSE);\n+  in_insns = get_str_vect (XSTR (def, 2), &in_length, ',', FALSE);\n   if (in_insns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 2));\n   for (i = 0; i < out_length; i++)\n@@ -1738,8 +1626,8 @@ gen_bypass (rtx def)\n \tDECL_BYPASS (decl)->latency = XINT (def, 0);\n \tDECL_BYPASS (decl)->out_insn_name = out_insns [i];\n \tDECL_BYPASS (decl)->in_insn_name = in_insns [j];\n-\tDECL_BYPASS (decl)->bypass_guard_name = (char *) XSTR (def, 3);\n-\tVLA_PTR_ADD (decls, decl);\n+\tDECL_BYPASS (decl)->bypass_guard_name = XSTR (def, 3);\n+\tVEC_safe_push (decl_t,heap, decls, decl);\n \tnum_dfa_decls++;\n       }\n }\n@@ -1760,10 +1648,10 @@ gen_excl_set (rtx def)\n   int i;\n \n   first_str_cpu_units\n-    = get_str_vect ((char *) XSTR (def, 0), &first_vect_length, ',', FALSE);\n+    = get_str_vect (XSTR (def, 0), &first_vect_length, ',', FALSE);\n   if (first_str_cpu_units == NULL)\n     fatal (\"invalid first string `%s' in exclusion_set\", XSTR (def, 0));\n-  second_str_cpu_units = get_str_vect ((char *) XSTR (def, 1), &length, ',',\n+  second_str_cpu_units = get_str_vect (XSTR (def, 1), &length, ',',\n \t\t\t\t       FALSE);\n   if (second_str_cpu_units == NULL)\n     fatal (\"invalid second string `%s' in exclusion_set\", XSTR (def, 1));\n@@ -1779,7 +1667,7 @@ gen_excl_set (rtx def)\n     else\n       DECL_EXCL (decl)->names [i]\n \t= second_str_cpu_units [i - first_vect_length];\n-  VLA_PTR_ADD (decls, decl);\n+  VEC_safe_push (decl_t,heap, decls, decl);\n   num_dfa_decls++;\n }\n \n@@ -1794,13 +1682,14 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n {\n   decl_t decl;\n   char **str_cpu_units;\n+  char **str_pattern_lists;\n   char ***str_patterns;\n   int cpu_units_length;\n   int length;\n   int patterns_length;\n   int i;\n \n-  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &cpu_units_length, ',',\n+  str_cpu_units = get_str_vect (XSTR (def, 0), &cpu_units_length, ',',\n \t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n     fatal ((presence_p\n@@ -1811,20 +1700,21 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n \t       ? \"invalid first string `%s' in final_absence_set\"\n \t       : \"invalid first string `%s' in absence_set\")),\n \t   XSTR (def, 0));\n-  str_patterns = (char ***) get_str_vect ((char *) XSTR (def, 1),\n-\t\t\t\t\t  &patterns_length, ',', FALSE);\n-  if (str_patterns == NULL)\n+  str_pattern_lists = get_str_vect (XSTR (def, 1),\n+\t\t\t\t    &patterns_length, ',', FALSE);\n+  if (str_pattern_lists == NULL)\n     fatal ((presence_p\n \t    ? (final_p\n \t       ? \"invalid second string `%s' in final_presence_set\"\n \t       : \"invalid second string `%s' in presence_set\")\n \t    : (final_p\n \t       ? \"invalid second string `%s' in final_absence_set\"\n \t       : \"invalid second string `%s' in absence_set\")), XSTR (def, 1));\n+  str_patterns = obstack_alloc (&irp, patterns_length * sizeof (char **));\n   for (i = 0; i < patterns_length; i++)\n     {\n-      str_patterns [i] = get_str_vect ((char *) str_patterns [i], &length, ' ',\n-\t\t\t\t       FALSE);\n+      str_patterns [i] = get_str_vect (str_pattern_lists [i],\n+\t\t\t\t       &length, ' ', FALSE);\n       gcc_assert (str_patterns [i]);\n     }\n   decl = create_node (sizeof (struct decl));\n@@ -1847,7 +1737,7 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n       DECL_ABSENCE (decl)->patterns_num = patterns_length;\n       DECL_ABSENCE (decl)->final_p = final_p;\n     }\n-  VLA_PTR_ADD (decls, decl);\n+  VEC_safe_push (decl_t,heap, decls, decl);\n   num_dfa_decls++;\n }\n \n@@ -1908,8 +1798,7 @@ gen_automaton (rtx def)\n   int vect_length;\n   int i;\n \n-  str_automata = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n-\t\t\t       FALSE);\n+  str_automata = get_str_vect (XSTR (def, 0), &vect_length, ',', FALSE);\n   if (str_automata == NULL)\n     fatal (\"invalid string `%s' in define_automaton\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n@@ -1918,7 +1807,7 @@ gen_automaton (rtx def)\n       decl->mode = dm_automaton;\n       decl->pos = 0;\n       DECL_AUTOMATON (decl)->name = check_name (str_automata [i], decl->pos);\n-      VLA_PTR_ADD (decls, decl);\n+      VEC_safe_push (decl_t,heap, decls, decl);\n       num_dfa_decls++;\n     }\n }\n@@ -1951,22 +1840,25 @@ gen_automata_option (rtx def)\n \n /* The following string contains original reservation string being\n    parsed.  */\n-static char *reserv_str;\n+static const char *reserv_str;\n \n /* Parse an element in STR.  */\n static regexp_t\n-gen_regexp_el (char *str)\n+gen_regexp_el (const char *str)\n {\n   regexp_t regexp;\n+  char *dstr;\n   int len;\n \n   if (*str == '(')\n     {\n       len = strlen (str);\n       if (str [len - 1] != ')')\n \tfatal (\"garbage after ) in reservation `%s'\", reserv_str);\n-      str [len - 1] = '\\0';\n-      regexp = gen_regexp_sequence (str + 1);\n+      dstr = alloca (len - 1);\n+      memcpy (dstr, str + 1, len - 2);\n+      dstr [len-2] = '\\0';\n+      regexp = gen_regexp_sequence (dstr);\n     }\n   else if (strcmp (str, NOTHING_NAME) == 0)\n     {\n@@ -1984,7 +1876,7 @@ gen_regexp_el (char *str)\n \n /* Parse construction `repeat' in STR.  */\n static regexp_t\n-gen_regexp_repeat (char *str)\n+gen_regexp_repeat (const char *str)\n {\n   regexp_t regexp;\n   regexp_t repeat;\n@@ -2017,7 +1909,7 @@ gen_regexp_repeat (char *str)\n \n /* Parse reservation STR which possibly contains separator '+'.  */\n static regexp_t\n-gen_regexp_allof (char *str)\n+gen_regexp_allof (const char *str)\n {\n   regexp_t allof;\n   char **allof_vect;\n@@ -2043,7 +1935,7 @@ gen_regexp_allof (char *str)\n \n /* Parse reservation STR which possibly contains separator '|'.  */\n static regexp_t\n-gen_regexp_oneof (char *str)\n+gen_regexp_oneof (const char *str)\n {\n   regexp_t oneof;\n   char **oneof_vect;\n@@ -2069,7 +1961,7 @@ gen_regexp_oneof (char *str)\n \n /* Parse reservation STR which possibly contains separator ','.  */\n static regexp_t\n-gen_regexp_sequence (char *str)\n+gen_regexp_sequence (const char *str)\n {\n   regexp_t sequence;\n   char **sequence_vect;\n@@ -2094,7 +1986,7 @@ gen_regexp_sequence (char *str)\n \n /* Parse construction reservation STR.  */\n static regexp_t\n-gen_regexp (char *str)\n+gen_regexp (const char *str)\n {\n   reserv_str = str;\n   return gen_regexp_sequence (str);;\n@@ -2113,9 +2005,9 @@ gen_reserv (rtx def)\n   decl = create_node (sizeof (struct decl));\n   decl->mode = dm_reserv;\n   decl->pos = 0;\n-  DECL_RESERV (decl)->name = check_name ((char *) XSTR (def, 0), decl->pos);\n-  DECL_RESERV (decl)->regexp = gen_regexp ((char *) XSTR (def, 1));\n-  VLA_PTR_ADD (decls, decl);\n+  DECL_RESERV (decl)->name = check_name (XSTR (def, 0), decl->pos);\n+  DECL_RESERV (decl)->regexp = gen_regexp (XSTR (def, 1));\n+  VEC_safe_push (decl_t,heap, decls, decl);\n   num_dfa_decls++;\n }\n \n@@ -2133,11 +2025,11 @@ gen_insn_reserv (rtx def)\n   decl->mode = dm_insn_reserv;\n   decl->pos = 0;\n   DECL_INSN_RESERV (decl)->name\n-    = check_name ((char *) XSTR (def, 0), decl->pos);\n+    = check_name (XSTR (def, 0), decl->pos);\n   DECL_INSN_RESERV (decl)->default_latency = XINT (def, 1);\n   DECL_INSN_RESERV (decl)->condexp = XEXP (def, 2);\n-  DECL_INSN_RESERV (decl)->regexp = gen_regexp ((char *) XSTR (def, 3));\n-  VLA_PTR_ADD (decls, decl);\n+  DECL_INSN_RESERV (decl)->regexp = gen_regexp (XSTR (def, 3));\n+  VEC_safe_push (decl_t,heap, decls, decl);\n   num_dfa_decls++;\n }\n \n@@ -2223,7 +2115,7 @@ static struct decl work_automaton_decl;\n    declaration.  The function returns node found in the table, NULL if\n    such node does not exist in the table.  */\n static decl_t\n-find_automaton_decl (char *name)\n+find_automaton_decl (const char *name)\n {\n   void *entry;\n \n@@ -2322,7 +2214,7 @@ static struct decl work_insn_decl;\n    declaration.  The function returns node found in the table, NULL if\n    such node does not exist in the table.  */\n static decl_t\n-find_insn_decl (char *name)\n+find_insn_decl (const char *name)\n {\n   void *entry;\n \n@@ -2422,7 +2314,7 @@ static struct decl work_decl;\n    returns node found in the table, NULL if such node does not exist\n    in the table.  */\n static decl_t\n-find_decl (char *name)\n+find_decl (const char *name)\n {\n   void *entry;\n \n@@ -3537,7 +3429,7 @@ add_advance_cycle_insn_decl (void)\n   advance_cycle_insn_decl->mode = dm_insn_reserv;\n   advance_cycle_insn_decl->pos = no_pos;\n   DECL_INSN_RESERV (advance_cycle_insn_decl)->regexp = NULL;\n-  DECL_INSN_RESERV (advance_cycle_insn_decl)->name = (char *) \"$advance_cycle\";\n+  DECL_INSN_RESERV (advance_cycle_insn_decl)->name = \"$advance_cycle\";\n   DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num\n     = description->insns_num;\n   description->decls [description->decls_num] = advance_cycle_insn_decl;\n@@ -3628,47 +3520,50 @@ alt_state_cmp (const void *alt_state_ptr_1, const void *alt_state_ptr_2)\n /* The function sorts ALT_STATES_LIST and removes duplicated alt\n    states from the list.  The comparison key is alt state unique\n    number.  */\n+\n static alt_state_t\n uniq_sort_alt_states (alt_state_t alt_states_list)\n {\n   alt_state_t curr_alt_state;\n-  vla_ptr_t alt_states;\n+  VEC(alt_state_t,heap) *alt_states;\n   size_t i;\n   size_t prev_unique_state_ind;\n   alt_state_t result;\n-  alt_state_t *result_ptr;\n \n-  VLA_PTR_CREATE (alt_states, 150, \"alt_states\");\n+  if (alt_states_list == 0)\n+    return 0;\n+  if (alt_states_list->next_alt_state == 0)\n+    return alt_states_list;\n+\n+  alt_states = VEC_alloc (alt_state_t,heap, 150);\n   for (curr_alt_state = alt_states_list;\n        curr_alt_state != NULL;\n        curr_alt_state = curr_alt_state->next_alt_state)\n-    VLA_PTR_ADD (alt_states, curr_alt_state);\n-  qsort (VLA_PTR_BEGIN (alt_states), VLA_PTR_LENGTH (alt_states),\n+    VEC_safe_push (alt_state_t,heap, alt_states, curr_alt_state);\n+\n+  qsort (VEC_address (alt_state_t, alt_states),\n+\t VEC_length  (alt_state_t, alt_states),\n \t sizeof (alt_state_t), alt_state_cmp);\n-  if (VLA_PTR_LENGTH (alt_states) == 0)\n-    result = NULL;\n-  else\n-    {\n-      result_ptr = VLA_PTR_BEGIN (alt_states);\n-      prev_unique_state_ind = 0;\n-      for (i = 1; i < VLA_PTR_LENGTH (alt_states); i++)\n-        if (result_ptr [prev_unique_state_ind]->state != result_ptr [i]->state)\n-          {\n-            prev_unique_state_ind++;\n-            result_ptr [prev_unique_state_ind] = result_ptr [i];\n-          }\n-#if 0\n-      for (i = prev_unique_state_ind + 1; i < VLA_PTR_LENGTH (alt_states); i++)\n-        free_alt_state (result_ptr [i]);\n-#endif\n-      VLA_PTR_SHORTEN (alt_states, i - prev_unique_state_ind - 1);\n-      result_ptr = VLA_PTR_BEGIN (alt_states);\n-      for (i = 1; i < VLA_PTR_LENGTH (alt_states); i++)\n-        result_ptr [i - 1]->next_sorted_alt_state = result_ptr [i];\n-      result_ptr [i - 1]->next_sorted_alt_state = NULL;\n-      result = *result_ptr;\n-    }\n-  VLA_PTR_DELETE (alt_states);\n+\n+  prev_unique_state_ind = 0;\n+  for (i = 1; i < VEC_length (alt_state_t, alt_states); i++)\n+    if (VEC_index (alt_state_t, alt_states, prev_unique_state_ind)->state\n+\t!= VEC_index (alt_state_t, alt_states, i)->state)\n+      {\n+\tprev_unique_state_ind++;\n+\tVEC_replace (alt_state_t, alt_states, prev_unique_state_ind,\n+\t\t     VEC_index (alt_state_t, alt_states, i));\n+      }\n+  VEC_truncate (alt_state_t, alt_states, prev_unique_state_ind + 1);\n+\n+  for (i = 1; i < VEC_length (alt_state_t, alt_states); i++)\n+    VEC_index (alt_state_t, alt_states, i-1)->next_sorted_alt_state\n+      = VEC_index (alt_state_t, alt_states, i);\n+  VEC_last (alt_state_t, alt_states)->next_sorted_alt_state = 0;\n+\n+  result = VEC_index (alt_state_t, alt_states, 0);\n+\n+  VEC_free (alt_state_t,heap, alt_states);\n   return result;\n }\n \n@@ -3736,11 +3631,7 @@ static int els_in_cycle_reserv;\n    variable value * number of bits in set_el_t.  */\n static int els_in_reservs;\n \n-/* VLA for representation of array of pointers to unit\n-   declarations.  */\n-static vla_ptr_t units_container;\n-\n-/* The start address of the array.  */\n+/* Array of pointers to unit declarations.  */\n static unit_decl_t *units_array;\n \n /* Temporary reservation of maximal length.  */\n@@ -3749,9 +3640,9 @@ static reserv_sets_t temp_reserv;\n /* The state table itself is represented by the following variable.  */\n static htab_t state_table;\n \n-/* VLA for representation of array of pointers to free nodes\n-   `state'.  */\n-static vla_ptr_t free_states;\n+/* Linked list of free 'state' structures to be recycled.  The\n+   next_equiv_class_state pointer is borrowed for a free list.  */\n+static state_t first_free_state;\n \n static int curr_unique_state_num;\n \n@@ -4053,10 +3944,12 @@ get_free_state (int with_reservs, automaton_t automaton)\n   state_t result;\n \n   gcc_assert (max_cycles_num > 0 && automaton);\n-  if (VLA_PTR_LENGTH (free_states) != 0)\n+  if (first_free_state)\n     {\n-      result = VLA_PTR (free_states, VLA_PTR_LENGTH (free_states) - 1);\n-      VLA_PTR_SHORTEN (free_states, 1);\n+      result = first_free_state;\n+      first_free_state = result->next_equiv_class_state;\n+\n+      result->next_equiv_class_state = NULL;\n       result->automaton = automaton;\n       result->first_out_arc = NULL;\n       result->it_was_placed_in_stack_for_NDFA_forming = 0;\n@@ -4091,7 +3984,8 @@ static void\n free_state (state_t state)\n {\n   free_alt_states (state->component_states);\n-  VLA_PTR_ADD (free_states, state);\n+  state->next_equiv_class_state = first_free_state;\n+  first_free_state = state;\n }\n \n /* Hash value of STATE.  If STATE represents deterministic state it is\n@@ -4232,10 +4126,11 @@ initiate_states (void)\n   decl_t decl;\n   int i;\n \n-  VLA_PTR_CREATE (units_container, description->units_num, \"units_container\");\n-  units_array\n-    = (description->decls_num && description->units_num\n-       ? VLA_PTR_BEGIN (units_container) : NULL);\n+  if (description->units_num)\n+    units_array = xmalloc (description->units_num * sizeof (unit_decl_t));\n+  else\n+    units_array = 0;\n+\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n@@ -4249,7 +4144,6 @@ initiate_states (void)\n   els_in_reservs = els_in_cycle_reserv * max_cycles_num;\n   curr_unique_state_num = 0;\n   initiate_alt_states ();\n-  VLA_PTR_CREATE (free_states, 1500, \"free states\");\n   state_table = htab_create (1500, state_hash, state_eq_p, (htab_del) 0);\n   temp_reserv = alloc_empty_reserv_sets ();\n }\n@@ -4258,9 +4152,10 @@ initiate_states (void)\n static void\n finish_states (void)\n {\n-  VLA_PTR_DELETE (units_container);\n+  free (units_array);\n+  units_array = 0;\n   htab_delete (state_table);\n-  VLA_PTR_DELETE (free_states);\n+  first_free_state = NULL;\n   finish_alt_states ();\n }\n \n@@ -5337,6 +5232,10 @@ struct unit_usage\n      same alternative.  */\n   struct unit_usage *next;\n };\n+typedef struct unit_usage *unit_usage_t;\n+\n+DEF_VEC_P(unit_usage_t);\n+DEF_VEC_ALLOC_P(unit_usage_t,heap);\n \n /* Obstack for unit_usage structures.  */\n static struct obstack unit_usages;\n@@ -5347,7 +5246,7 @@ static struct obstack unit_usages;\n    alternative with given number are referred through element with\n    index equals to the cycle * number of all alternatives in the regexp\n    + the alternative number.  */\n-static vla_ptr_t cycle_alt_unit_usages;\n+static VEC(unit_usage_t,heap) *cycle_alt_unit_usages;\n \n /* The following function creates the structure unit_usage for UNIT on\n    CYCLE in REGEXP alternative with ALT_NUM.  The structure is made\n@@ -5356,29 +5255,26 @@ static void\n store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n \t\t      int alt_num)\n {\n-  size_t i, length, old_length;\n+  size_t length;\n   unit_decl_t unit_decl;\n-  struct unit_usage *unit_usage_ptr;\n+  unit_usage_t unit_usage_ptr;\n   int index;\n \n   gcc_assert (regexp && regexp->mode == rm_oneof\n \t      && alt_num < REGEXP_ONEOF (regexp)->regexps_num);\n   unit_decl = REGEXP_UNIT (unit)->unit_decl;\n-  old_length = VLA_PTR_LENGTH (cycle_alt_unit_usages);\n+\n   length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n-  if (old_length < length)\n-    {\n-      VLA_PTR_EXPAND (cycle_alt_unit_usages, length - old_length);\n-      for (i = old_length; i < length; i++)\n-\tVLA_PTR (cycle_alt_unit_usages, i) = NULL;\n-    }\n+  while (VEC_length (unit_usage_t, cycle_alt_unit_usages) < length)\n+    VEC_safe_push (unit_usage_t,heap, cycle_alt_unit_usages, 0);\n+  \n   obstack_blank (&unit_usages, sizeof (struct unit_usage));\n   unit_usage_ptr = (struct unit_usage *) obstack_base (&unit_usages);\n   obstack_finish (&unit_usages);\n   unit_usage_ptr->unit_decl = unit_decl;\n   index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n-  unit_usage_ptr->next = VLA_PTR (cycle_alt_unit_usages, index);\n-  VLA_PTR (cycle_alt_unit_usages, index) = unit_usage_ptr;\n+  unit_usage_ptr->next = VEC_index (unit_usage_t, cycle_alt_unit_usages, index);\n+  VEC_replace (unit_usage_t, cycle_alt_unit_usages, index, unit_usage_ptr);\n   unit_decl->last_distribution_check_cycle = -1; /* undefined */\n }\n \n@@ -5396,7 +5292,8 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n     return;\n   /* Store all unit usages in the regexp:  */\n   obstack_init (&unit_usages);\n-  VLA_PTR_CREATE (cycle_alt_unit_usages, 100, \"unit usages on cycles\");\n+  cycle_alt_unit_usages = 0;\n+\n   for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n       seq = REGEXP_ONEOF (regexp)->regexps [i];\n@@ -5463,31 +5360,33 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t}\n     }\n   /* Check distribution:  */\n-  for (i = 0; i < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages); i++)\n+  for (i = 0; i < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages); i++)\n     {\n       cycle = i / REGEXP_ONEOF (regexp)->regexps_num;\n-      for (unit_usage_ptr = VLA_PTR (cycle_alt_unit_usages, i);\n+      for (unit_usage_ptr = VEC_index (unit_usage_t, cycle_alt_unit_usages, i);\n \t   unit_usage_ptr != NULL;\n \t   unit_usage_ptr = unit_usage_ptr->next)\n \tif (cycle != unit_usage_ptr->unit_decl->last_distribution_check_cycle)\n \t  {\n \t    unit_usage_ptr->unit_decl->last_distribution_check_cycle = cycle;\n \t    for (k = cycle * REGEXP_ONEOF (regexp)->regexps_num;\n-\t\t k < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages)\n+\t\t k < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages)\n \t\t   && k == cycle * REGEXP_ONEOF (regexp)->regexps_num;\n \t\t k++)\n \t      {\n-\t\tfor (other_unit_usage_ptr = VLA_PTR (cycle_alt_unit_usages, k);\n+\t\tfor (other_unit_usage_ptr\n+\t\t       = VEC_index (unit_usage_t, cycle_alt_unit_usages, k);\n \t\t     other_unit_usage_ptr != NULL;\n \t\t     other_unit_usage_ptr = other_unit_usage_ptr->next)\n \t\t  if (unit_usage_ptr->unit_decl->automaton_decl\n \t\t      == other_unit_usage_ptr->unit_decl->automaton_decl)\n \t\t    break;\n \t\tif (other_unit_usage_ptr == NULL\n-\t\t    && VLA_PTR (cycle_alt_unit_usages, k) != NULL)\n+\t\t    && (VEC_index (unit_usage_t, cycle_alt_unit_usages, k)\n+\t\t\t!= NULL))\n \t\t  break;\n \t      }\n-\t    if (k < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages)\n+\t    if (k < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages)\n \t\t&& k == cycle * REGEXP_ONEOF (regexp)->regexps_num)\n \t      {\n \t\tif (!annotation_message_reported_p)\n@@ -5503,7 +5402,7 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t      }\n \t  }\n     }\n-  VLA_PTR_DELETE (cycle_alt_unit_usages);\n+  VEC_free (unit_usage_t,heap, cycle_alt_unit_usages);\n   obstack_free (&unit_usages, NULL);\n }\n \n@@ -5679,16 +5578,14 @@ create_alt_states (automaton_t automaton)\n \n /* The function forms list of ainsns of AUTOMATON with the same\n    reservation.  */\n+\n static void\n form_ainsn_with_same_reservs (automaton_t automaton)\n {\n   ainsn_t curr_ainsn;\n   size_t i;\n-  vla_ptr_t first_insns;\n-  vla_ptr_t last_insns;\n+  VEC(ainsn_t,heap) *last_insns = VEC_alloc (ainsn_t,heap, 150);\n \n-  VLA_PTR_CREATE (first_insns, 150, \"first insns with the same reservs\");\n-  VLA_PTR_CREATE (last_insns, 150, \"last insns with the same reservs\");\n   for (curr_ainsn = automaton->ainsn_list;\n        curr_ainsn != NULL;\n        curr_ainsn = curr_ainsn->next_ainsn)\n@@ -5700,28 +5597,26 @@ form_ainsn_with_same_reservs (automaton_t automaton)\n       }\n     else\n       {\n-        for (i = 0; i < VLA_PTR_LENGTH (first_insns); i++)\n+        for (i = 0; i < VEC_length (ainsn_t, last_insns); i++)\n           if (alt_states_eq\n               (curr_ainsn->sorted_alt_states,\n-               ((ainsn_t) VLA_PTR (first_insns, i))->sorted_alt_states))\n+               VEC_index (ainsn_t, last_insns, i)->sorted_alt_states))\n             break;\n         curr_ainsn->next_same_reservs_insn = NULL;\n-        if (i < VLA_PTR_LENGTH (first_insns))\n+        if (i < VEC_length (ainsn_t, last_insns))\n           {\n             curr_ainsn->first_insn_with_same_reservs = 0;\n-\t    ((ainsn_t) VLA_PTR (last_insns, i))->next_same_reservs_insn\n+\t    VEC_index (ainsn_t, last_insns, i)->next_same_reservs_insn\n \t      = curr_ainsn;\n-            VLA_PTR (last_insns, i) = curr_ainsn;\n+            VEC_replace (ainsn_t, last_insns, i, curr_ainsn);\n           }\n         else\n           {\n-            VLA_PTR_ADD (first_insns, curr_ainsn);\n-            VLA_PTR_ADD (last_insns, curr_ainsn);\n+            VEC_safe_push (ainsn_t, heap, last_insns, curr_ainsn);\n             curr_ainsn->first_insn_with_same_reservs = 1;\n           }\n       }\n-  VLA_PTR_DELETE (first_insns);\n-  VLA_PTR_DELETE (last_insns);\n+  VEC_free (ainsn_t,heap, last_insns);\n }\n \n /* Forming unit reservations which can affect creating the automaton\n@@ -5753,8 +5648,7 @@ form_reservs_matter (automaton_t automaton)\n   return reservs_matter;\n }\n \n-/* The following function creates all states of nondeterministic (if\n-   NDFA_FLAG has nonzero value) or deterministic AUTOMATON.  */\n+/* The following function creates all states of nondeterministic AUTOMATON.  */\n static void\n make_automaton (automaton_t automaton)\n {\n@@ -5766,21 +5660,19 @@ make_automaton (automaton_t automaton)\n   state_t state2;\n   ainsn_t advance_cycle_ainsn;\n   arc_t added_arc;\n-  vla_ptr_t state_stack;\n+  VEC(state_t,heap) *state_stack = VEC_alloc(state_t,heap, 150);\n   int states_n;\n   reserv_sets_t reservs_matter = form_reservs_matter (automaton);\n \n-  VLA_PTR_CREATE (state_stack, 150, \"state stack\");\n   /* Create the start state (empty state).  */\n   start_state = insert_state (get_free_state (1, automaton));\n   automaton->start_state = start_state;\n   start_state->it_was_placed_in_stack_for_NDFA_forming = 1;\n-  VLA_PTR_ADD (state_stack, start_state);\n+  VEC_safe_push (state_t,heap, state_stack, start_state);\n   states_n = 1;\n-  while (VLA_PTR_LENGTH (state_stack) != 0)\n+  while (VEC_length (state_t, state_stack) != 0)\n     {\n-      state = VLA_PTR (state_stack, VLA_PTR_LENGTH (state_stack) - 1);\n-      VLA_PTR_SHORTEN (state_stack, 1);\n+      state = VEC_pop (state_t, state_stack);\n       advance_cycle_ainsn = NULL;\n       for (ainsn = automaton->ainsn_list;\n \t   ainsn != NULL;\n@@ -5805,7 +5697,7 @@ make_automaton (automaton_t automaton)\n                           {\n                             state2->it_was_placed_in_stack_for_NDFA_forming\n \t\t\t      = 1;\n-                            VLA_PTR_ADD (state_stack, state2);\n+                            VEC_safe_push (state_t,heap, state_stack, state2);\n \t\t\t    states_n++;\n \t\t\t    if (progress_flag && states_n % 100 == 0)\n \t\t\t      fprintf (stderr, \".\");\n@@ -5836,15 +5728,15 @@ make_automaton (automaton_t automaton)\n       if (!state2->it_was_placed_in_stack_for_NDFA_forming)\n         {\n           state2->it_was_placed_in_stack_for_NDFA_forming = 1;\n-          VLA_PTR_ADD (state_stack, state2);\n+          VEC_safe_push (state_t,heap, state_stack, state2);\n \t  states_n++;\n \t  if (progress_flag && states_n % 100 == 0)\n \t    fprintf (stderr, \".\");\n         }\n       gcc_assert (advance_cycle_ainsn);\n       add_arc (state, state2, advance_cycle_ainsn, 1);\n     }\n-  VLA_PTR_DELETE (state_stack);\n+  VEC_free (state_t,heap, state_stack);\n }\n \n /* Foms lists of all arcs of STATE marked by the same ainsn.  */\n@@ -5874,9 +5766,10 @@ form_arcs_marked_by_insn (state_t state)\n    ORIGINAL_STATE and list of arcs ARCS_MARKED_BY_INSN marked by the\n    same insn.  If the composed state is not in STATE_STACK yet, it is\n    pushed into STATE_STACK.  */\n+\n static int\n create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n-\t\t       vla_ptr_t *state_stack)\n+\t\t       VEC(state_t,heap) **state_stack)\n {\n   state_t state;\n   alt_state_t alt_state, curr_alt_state;\n@@ -5967,33 +5860,34 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n   if (!state->it_was_placed_in_stack_for_DFA_forming)\n     {\n       state->it_was_placed_in_stack_for_DFA_forming = 1;\n-      VLA_PTR_ADD (*state_stack, state);\n+      VEC_safe_push (state_t,heap, *state_stack, state);\n     }\n   return new_state_p;\n }\n \n /* The function transforms nondeterministic AUTOMATON into\n    deterministic.  */\n+\n static void\n NDFA_to_DFA (automaton_t automaton)\n {\n   state_t start_state;\n   state_t state;\n   decl_t decl;\n-  vla_ptr_t state_stack;\n+  VEC(state_t,heap) *state_stack;\n   int i;\n   int states_n;\n \n-  VLA_PTR_CREATE (state_stack, 150, \"state stack\");\n+  state_stack = VEC_alloc (state_t,heap, 0);\n+\n   /* Create the start state (empty state).  */\n   start_state = automaton->start_state;\n   start_state->it_was_placed_in_stack_for_DFA_forming = 1;\n-  VLA_PTR_ADD (state_stack, start_state);\n+  VEC_safe_push (state_t,heap, state_stack, start_state);\n   states_n = 1;\n-  while (VLA_PTR_LENGTH (state_stack) != 0)\n+  while (VEC_length (state_t, state_stack) != 0)\n     {\n-      state = VLA_PTR (state_stack, VLA_PTR_LENGTH (state_stack) - 1);\n-      VLA_PTR_SHORTEN (state_stack, 1);\n+      state = VEC_pop (state_t, state_stack);\n       form_arcs_marked_by_insn (state);\n       for (i = 0; i < description->decls_num; i++)\n \t{\n@@ -6009,7 +5903,7 @@ NDFA_to_DFA (automaton_t automaton)\n \t    }\n \t}\n     }\n-  VLA_PTR_DELETE (state_stack);\n+  VEC_free (state_t,heap, state_stack);\n }\n \n /* The following variable value is current number (1, 2, ...) of passing\n@@ -6051,14 +5945,14 @@ initiate_pass_states (void)\n \n /* The following vla is used for storing pointers to all achieved\n    states.  */\n-static vla_ptr_t all_achieved_states;\n+static VEC(state_t,heap) *all_achieved_states;\n \n /* This function is called by function pass_states to add an achieved\n    STATE.  */\n static void\n add_achieved_state (state_t state)\n {\n-  VLA_PTR_ADD (all_achieved_states, state);\n+  VEC_safe_push (state_t,heap, all_achieved_states, state);\n }\n \n /* The function sets up equivalence numbers of insns which mark all\n@@ -6102,19 +5996,6 @@ clear_arc_insns_equiv_num (state_t state)\n     }\n }\n \n-/* The function copies pointers to equivalent states from vla FROM\n-   into vla TO.  */\n-static void\n-copy_equiv_class (vla_ptr_t *to, const vla_ptr_t *from)\n-{\n-  state_t *class_ptr;\n-\n-  VLA_PTR_NULLIFY (*to);\n-  for (class_ptr = VLA_PTR_BEGIN (*from);\n-       class_ptr <= (state_t *) VLA_PTR_LAST (*from);\n-       class_ptr++)\n-    VLA_PTR_ADD (*to, *class_ptr);\n-}\n \n /* The following function returns TRUE if STATE reserves the unit with\n    UNIT_NUM on the first cycle.  */\n@@ -6178,46 +6059,50 @@ state_is_differed (state_t state, state_t another_state,\n /* The function makes initial partition of STATES on equivalent\n    classes.  */\n static state_t\n-init_equiv_class (state_t *states, int states_num)\n+init_equiv_class (VEC(state_t,heap) *states)\n {\n-  state_t *state_ptr;\n-  state_t result_equiv_class;\n+  size_t i;\n+  state_t prev = 0;\n \n-  result_equiv_class = NULL;\n-  for (state_ptr = states; state_ptr < states + states_num; state_ptr++)\n+  for (i = 0; i < VEC_length (state_t, states); i++)\n     {\n-      (*state_ptr)->equiv_class_num_1 = 1;\n-      (*state_ptr)->next_equiv_class_state = result_equiv_class;\n-      result_equiv_class = *state_ptr;\n+      VEC_index (state_t, states, i)->equiv_class_num_1 = 1;\n+      VEC_index (state_t, states, i)->next_equiv_class_state = prev;\n+      prev = VEC_index (state_t, states, i);\n     }\n-  return result_equiv_class;\n+  return prev;\n }\n \n-/* The function processes equivalence class given by its pointer\n-   EQUIV_CLASS_PTR on odd iteration if ODD_ITERATION_FLAG.  If there\n+/* The function copies pointers to equivalent states from vla FROM\n+   into vla TO.  */\n+static void\n+copy_equiv_class (VEC(state_t,heap) **to, VEC(state_t,heap) *from)\n+{\n+  VEC_free (state_t,heap, *to);\n+  *to = VEC_copy (state_t,heap, from);\n+}\n+/* The function processes equivalence class given by its first state,\n+   FIRST_STATE, on odd iteration if ODD_ITERATION_FLAG.  If there\n    are not equivalent states, the function partitions the class\n    removing nonequivalent states and placing them in\n    *NEXT_ITERATION_CLASSES, increments *NEW_EQUIV_CLASS_NUM_PTR ans\n    assigns it to the state equivalence number.  If the class has been\n    partitioned, the function returns nonzero value.  */\n static int\n-partition_equiv_class (state_t *equiv_class_ptr, int odd_iteration_flag,\n-\t\t       vla_ptr_t *next_iteration_classes,\n+partition_equiv_class (state_t first_state, int odd_iteration_flag,\n+\t\t       VEC(state_t,heap) **next_iteration_classes,\n \t\t       int *new_equiv_class_num_ptr)\n {\n   state_t new_equiv_class;\n   int partition_p;\n-  state_t first_state;\n   state_t curr_state;\n   state_t prev_state;\n   state_t next_state;\n   int out_arcs_num;\n \n   partition_p = 0;\n-  gcc_assert (*equiv_class_ptr);\n-  for (first_state = *equiv_class_ptr;\n-       first_state != NULL;\n-       first_state = new_equiv_class)\n+\n+  while (first_state != NULL)\n     {\n       new_equiv_class = NULL;\n       if (first_state->next_equiv_class_state != NULL)\n@@ -6253,151 +6138,157 @@ partition_equiv_class (state_t *equiv_class_ptr, int odd_iteration_flag,\n \t  clear_arc_insns_equiv_num (first_state);\n \t}\n       if (new_equiv_class != NULL)\n-\tVLA_PTR_ADD  (*next_iteration_classes, new_equiv_class);\n+\tVEC_safe_push (state_t,heap, *next_iteration_classes, new_equiv_class);\n+      first_state = new_equiv_class;\n     }\n   return partition_p;\n }\n \n /* The function finds equivalent states of AUTOMATON.  */\n static void\n-evaluate_equiv_classes (automaton_t automaton, vla_ptr_t *equiv_classes)\n+evaluate_equiv_classes (automaton_t automaton,\n+\t\t\tVEC(state_t,heap) **equiv_classes)\n {\n   state_t new_equiv_class;\n   int new_equiv_class_num;\n   int odd_iteration_flag;\n   int finish_flag;\n-  vla_ptr_t next_iteration_classes;\n-  state_t *equiv_class_ptr;\n-  state_t *state_ptr;\n+  VEC (state_t,heap) *next_iteration_classes;\n+  size_t i;\n \n-  VLA_PTR_CREATE (all_achieved_states, 1500, \"all achieved states\");\n+  all_achieved_states = VEC_alloc (state_t,heap, 1500);\n   pass_states (automaton, add_achieved_state);\n-  new_equiv_class = init_equiv_class (VLA_PTR_BEGIN (all_achieved_states),\n-                                      VLA_PTR_LENGTH (all_achieved_states));\n+  new_equiv_class = init_equiv_class (all_achieved_states);\n   odd_iteration_flag = 0;\n   new_equiv_class_num = 1;\n-  VLA_PTR_CREATE (next_iteration_classes, 150, \"next iteration classes\");\n-  VLA_PTR_ADD (next_iteration_classes, new_equiv_class);\n+\n+  next_iteration_classes = VEC_alloc (state_t,heap, 150);\n+  VEC_quick_push (state_t, next_iteration_classes, new_equiv_class);\n+\n   do\n     {\n       odd_iteration_flag = !odd_iteration_flag;\n       finish_flag = 1;\n-      copy_equiv_class (equiv_classes, &next_iteration_classes);\n+      copy_equiv_class (equiv_classes, next_iteration_classes);\n+\n       /* Transfer equiv numbers for the next iteration.  */\n-      for (state_ptr = VLA_PTR_BEGIN (all_achieved_states);\n-\t   state_ptr <= (state_t *) VLA_PTR_LAST (all_achieved_states);\n-           state_ptr++)\n+      for (i = 0; i < VEC_length (state_t, all_achieved_states); i++)\n \tif (odd_iteration_flag)\n-\t  (*state_ptr)->equiv_class_num_2 = (*state_ptr)->equiv_class_num_1;\n+\t  VEC_index (state_t, all_achieved_states, i)->equiv_class_num_2\n+\t    = VEC_index (state_t, all_achieved_states, i)->equiv_class_num_1;\n \telse\n-\t  (*state_ptr)->equiv_class_num_1 = (*state_ptr)->equiv_class_num_2;\n-      for (equiv_class_ptr = VLA_PTR_BEGIN (*equiv_classes);\n-           equiv_class_ptr <= (state_t *) VLA_PTR_LAST (*equiv_classes);\n-           equiv_class_ptr++)\n-\tif (partition_equiv_class (equiv_class_ptr, odd_iteration_flag,\n+\t  VEC_index (state_t, all_achieved_states, i)->equiv_class_num_1\n+\t    = VEC_index (state_t, all_achieved_states, i)->equiv_class_num_2;\n+\n+      for (i = 0; i < VEC_length (state_t, *equiv_classes); i++)\n+\tif (partition_equiv_class (VEC_index (state_t, *equiv_classes, i),\n+\t\t\t\t   odd_iteration_flag,\n \t\t\t\t   &next_iteration_classes,\n \t\t\t\t   &new_equiv_class_num))\n \t  finish_flag = 0;\n     }\n   while (!finish_flag);\n-  VLA_PTR_DELETE (next_iteration_classes);\n-  VLA_PTR_DELETE (all_achieved_states);\n+  VEC_free (state_t,heap, next_iteration_classes);\n+  VEC_free (state_t,heap, all_achieved_states);\n }\n \n /* The function merges equivalent states of AUTOMATON.  */\n static void\n-merge_states (automaton_t automaton, vla_ptr_t *equiv_classes)\n+merge_states (automaton_t automaton, VEC(state_t,heap) *equiv_classes)\n {\n-  state_t *equiv_class_ptr;\n   state_t curr_state;\n   state_t new_state;\n   state_t first_class_state;\n   alt_state_t alt_states;\n   alt_state_t alt_state, new_alt_state;\n   arc_t curr_arc;\n   arc_t next_arc;\n+  size_t i;\n \n   /* Create states corresponding to equivalence classes containing two\n      or more states.  */\n-  for (equiv_class_ptr = VLA_PTR_BEGIN (*equiv_classes);\n-       equiv_class_ptr <= (state_t *) VLA_PTR_LAST (*equiv_classes);\n-       equiv_class_ptr++)\n-    if ((*equiv_class_ptr)->next_equiv_class_state != NULL)\n-      {\n-        /* There are more one states in the class equivalence.  */\n-        /* Create new compound state.  */\n-        new_state = get_free_state (0, automaton);\n-        alt_states = NULL;\n-        first_class_state = *equiv_class_ptr;\n-        for (curr_state = first_class_state;\n-             curr_state != NULL;\n-             curr_state = curr_state->next_equiv_class_state)\n-          {\n-            curr_state->equiv_class_state = new_state;\n-\t    if (curr_state->component_states == NULL)\n-\t      {\n-\t\tnew_alt_state = get_free_alt_state ();\n-\t\tnew_alt_state->state = curr_state;\n-\t\tnew_alt_state->next_alt_state = alt_states;\n-\t\talt_states = new_alt_state;\n-\t      }\n-\t    else\n-\t      for (alt_state = curr_state->component_states;\n-\t\t   alt_state != NULL;\n-\t\t   alt_state = alt_state->next_sorted_alt_state)\n+  for (i = 0; i < VEC_length (state_t, equiv_classes); i++)\n+    {\n+      curr_state = VEC_index (state_t, equiv_classes, i);\n+      if (curr_state->next_equiv_class_state != NULL)\n+\t{\n+\t  /* There are more one states in the class equivalence.  */\n+\t  /* Create new compound state.  */\n+\t  new_state = get_free_state (0, automaton);\n+\t  alt_states = NULL;\n+\t  first_class_state = curr_state;\n+\t  for (curr_state = first_class_state;\n+\t       curr_state != NULL;\n+\t       curr_state = curr_state->next_equiv_class_state)\n+\t    {\n+\t      curr_state->equiv_class_state = new_state;\n+\t      if (curr_state->component_states == NULL)\n \t\t{\n \t\t  new_alt_state = get_free_alt_state ();\n-\t\t  new_alt_state->state = alt_state->state;\n+\t\t  new_alt_state->state = curr_state;\n \t\t  new_alt_state->next_alt_state = alt_states;\n \t\t  alt_states = new_alt_state;\n \t\t}\n-          }\n-\t/* Its is important that alt states were sorted before and\n-           after merging to have the same querying results.  */\n-        new_state->component_states = uniq_sort_alt_states (alt_states);\n-      }\n-    else\n-      (*equiv_class_ptr)->equiv_class_state = *equiv_class_ptr;\n-  for (equiv_class_ptr = VLA_PTR_BEGIN (*equiv_classes);\n-       equiv_class_ptr <= (state_t *) VLA_PTR_LAST (*equiv_classes);\n-       equiv_class_ptr++)\n-    if ((*equiv_class_ptr)->next_equiv_class_state != NULL)\n-      {\n-        first_class_state = *equiv_class_ptr;\n-        /* Create new arcs output from the state corresponding to\n-           equiv class.  */\n-        for (curr_arc = first_out_arc (first_class_state);\n-             curr_arc != NULL;\n-             curr_arc = next_out_arc (curr_arc))\n-          add_arc (first_class_state->equiv_class_state,\n-                   curr_arc->to_state->equiv_class_state,\n-\t\t   curr_arc->insn, curr_arc->state_alts);\n-        /* Delete output arcs from states of given class equivalence.  */\n-        for (curr_state = first_class_state;\n-             curr_state != NULL;\n-             curr_state = curr_state->next_equiv_class_state)\n-          {\n-            if (automaton->start_state == curr_state)\n-              automaton->start_state = curr_state->equiv_class_state;\n-            /* Delete the state and its output arcs.  */\n-            for (curr_arc = first_out_arc (curr_state);\n-                 curr_arc != NULL;\n-                 curr_arc = next_arc)\n-              {\n-                next_arc = next_out_arc (curr_arc);\n-                free_arc (curr_arc);\n-              }\n-          }\n-      }\n-    else\n-      {\n-        /* Change `to_state' of arcs output from the state of given\n-           equivalence class.  */\n-        for (curr_arc = first_out_arc (*equiv_class_ptr);\n-             curr_arc != NULL;\n-             curr_arc = next_out_arc (curr_arc))\n-          curr_arc->to_state = curr_arc->to_state->equiv_class_state;\n-      }\n+\t      else\n+\t\tfor (alt_state = curr_state->component_states;\n+\t\t     alt_state != NULL;\n+\t\t     alt_state = alt_state->next_sorted_alt_state)\n+\t\t  {\n+\t\t    new_alt_state = get_free_alt_state ();\n+\t\t    new_alt_state->state = alt_state->state;\n+\t\t    new_alt_state->next_alt_state = alt_states;\n+\t\t    alt_states = new_alt_state;\n+\t\t  }\n+\t    }\n+\t  /* Its is important that alt states were sorted before and\n+\t     after merging to have the same querying results.  */\n+\t  new_state->component_states = uniq_sort_alt_states (alt_states);\n+\t}\n+      else\n+\tcurr_state->equiv_class_state = curr_state;\n+    }\n+\n+  for (i = 0; i < VEC_length (state_t, equiv_classes); i++)\n+    {\n+      curr_state = VEC_index (state_t, equiv_classes, i);\n+      if (curr_state->next_equiv_class_state != NULL)\n+\t{\n+\t  first_class_state = curr_state;\n+\t  /* Create new arcs output from the state corresponding to\n+\t     equiv class.  */\n+\t  for (curr_arc = first_out_arc (first_class_state);\n+\t       curr_arc != NULL;\n+\t       curr_arc = next_out_arc (curr_arc))\n+\t    add_arc (first_class_state->equiv_class_state,\n+\t\t     curr_arc->to_state->equiv_class_state,\n+\t\t     curr_arc->insn, curr_arc->state_alts);\n+\t  /* Delete output arcs from states of given class equivalence.  */\n+\t  for (curr_state = first_class_state;\n+\t       curr_state != NULL;\n+\t       curr_state = curr_state->next_equiv_class_state)\n+\t    {\n+\t      if (automaton->start_state == curr_state)\n+\t\tautomaton->start_state = curr_state->equiv_class_state;\n+\t      /* Delete the state and its output arcs.  */\n+\t      for (curr_arc = first_out_arc (curr_state);\n+\t\t   curr_arc != NULL;\n+\t\t   curr_arc = next_arc)\n+\t\t{\n+\t\t  next_arc = next_out_arc (curr_arc);\n+\t\t  free_arc (curr_arc);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Change `to_state' of arcs output from the state of given\n+\t     equivalence class.  */\n+\t  for (curr_arc = first_out_arc (curr_state);\n+\t       curr_arc != NULL;\n+\t       curr_arc = next_out_arc (curr_arc))\n+\t    curr_arc->to_state = curr_arc->to_state->equiv_class_state;\n+\t}\n+    }\n }\n \n /* The function sets up new_cycle_p for states if there is arc to the\n@@ -6418,13 +6309,13 @@ set_new_cycle_flags (state_t state)\n static void\n minimize_DFA (automaton_t automaton)\n {\n-  vla_ptr_t equiv_classes;\n+  VEC(state_t,heap) *equiv_classes = 0;\n \n-  VLA_PTR_CREATE (equiv_classes, 1500, \"equivalence classes\");\n   evaluate_equiv_classes (automaton, &equiv_classes);\n-  merge_states (automaton, &equiv_classes);\n+  merge_states (automaton, equiv_classes);\n   pass_states (automaton, set_new_cycle_flags);\n-  VLA_PTR_DELETE (equiv_classes);\n+\n+  VEC_free (state_t,heap, equiv_classes);\n }\n \n /* Values of two variables are counted number of states and arcs in an\n@@ -6623,21 +6514,15 @@ static void\n process_state_for_insn_equiv_partition (state_t state)\n {\n   arc_t arc;\n-  arc_t *insn_arcs_array;\n-  int i;\n-  vla_ptr_t insn_arcs_vect;\n+  arc_t *insn_arcs_array = xmalloc (description->insns_num * sizeof(arc_t));\n \n-  VLA_PTR_CREATE (insn_arcs_vect, 500, \"insn arcs vector\");\n-  VLA_PTR_EXPAND (insn_arcs_vect, description->insns_num);\n-  insn_arcs_array = VLA_PTR_BEGIN (insn_arcs_vect);\n   /* Process insns of the arcs.  */\n-  for (i = 0; i < description->insns_num; i++)\n-    insn_arcs_array [i] = NULL;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     insn_arcs_array [arc->insn->insn_reserv_decl->insn_num] = arc;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     process_insn_equiv_class (arc->insn, insn_arcs_array);\n-  VLA_PTR_DELETE (insn_arcs_vect);\n+\n+  free (insn_arcs_array);\n }\n \n /* The function searches for equivalent ainsns of AUTOMATON.  */\n@@ -6745,56 +6630,53 @@ compare_max_occ_cycle_nums (const void *unit_decl_1,\n \n /* The function makes heuristic assigning automata to units.  Actually\n    efficacy of the algorithm has been checked yet??? */\n+\n static void\n units_to_automata_heuristic_distr (void)\n {\n   double estimation_bound;\n-  decl_t decl;\n-  decl_t *unit_decl_ptr;\n   int automaton_num;\n   int rest_units_num;\n   double bound_value;\n-  vla_ptr_t unit_decls;\n-  int i;\n+  unit_decl_t *unit_decls;\n+  int i, j;\n \n   if (description->units_num == 0)\n     return;\n   estimation_bound = estimate_one_automaton_bound ();\n-  VLA_PTR_CREATE (unit_decls, 150, \"unit decls\");\n-  for (i = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_unit)\n-\tVLA_PTR_ADD (unit_decls, decl);\n-    }\n-  qsort (VLA_PTR_BEGIN (unit_decls), VLA_PTR_LENGTH (unit_decls),\n-         sizeof (decl_t), compare_max_occ_cycle_nums);\n+  unit_decls = xmalloc (description->units_num * sizeof (unit_decl_t));\n+\n+  for (i = 0, j = 0; i < description->decls_num; i++)\n+    if (description->decls[i]->mode == dm_unit)\n+      unit_decls[j++] = DECL_UNIT (description->decls[i]);\n+  gcc_assert (j == description->units_num);\n+\n+  qsort (unit_decls, description->units_num,\n+         sizeof (unit_decl_t), compare_max_occ_cycle_nums);\n+\n   automaton_num = 0;\n-  unit_decl_ptr = VLA_PTR_BEGIN (unit_decls);\n-  bound_value = DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n-  DECL_UNIT (*unit_decl_ptr)->corresponding_automaton_num = automaton_num;\n-  for (unit_decl_ptr++;\n-       unit_decl_ptr <= (decl_t *) VLA_PTR_LAST (unit_decls);\n-       unit_decl_ptr++)\n-    {\n-      rest_units_num\n-\t= ((decl_t *) VLA_PTR_LAST (unit_decls) - unit_decl_ptr + 1);\n+  bound_value = unit_decls[0]->max_occ_cycle_num;\n+  unit_decls[0]->corresponding_automaton_num = automaton_num;\n+\n+  for (i = 1; i < description->units_num; i++)\n+    {\n+      rest_units_num = description->units_num - i + 1;\n       gcc_assert (automata_num - automaton_num - 1 <= rest_units_num);\n       if (automaton_num < automata_num - 1\n           && ((automata_num - automaton_num - 1 == rest_units_num)\n               || (bound_value\n                   > (estimation_bound\n-\t\t     / (DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num)))))\n+\t\t     / unit_decls[i]->max_occ_cycle_num))))\n         {\n-          bound_value = DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n+          bound_value = unit_decls[i]->max_occ_cycle_num;\n           automaton_num++;\n         }\n       else\n-        bound_value *= DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n-      DECL_UNIT (*unit_decl_ptr)->corresponding_automaton_num = automaton_num;\n+        bound_value *= unit_decls[i]->max_occ_cycle_num;\n+      unit_decls[i]->corresponding_automaton_num = automaton_num;\n     }\n   gcc_assert (automaton_num == automata_num - 1);\n-  VLA_PTR_DELETE (unit_decls);\n+  free (unit_decls);\n }\n \n /* The functions creates automaton insns for each automata.  Automaton\n@@ -7174,35 +7056,30 @@ output_dfa_max_issue_rate (void)\n \t   MAX_DFA_ISSUE_RATE_VAR_NAME, max_dfa_issue_rate);\n }\n \n-/* The function outputs all initialization values of VECT with length\n-   vect_length.  */\n+/* The function outputs all initialization values of VECT.  */\n static void\n-output_vect (vect_el_t *vect, int vect_length)\n+output_vect (vla_hwint_t vect)\n {\n   int els_on_line;\n+  size_t vect_length = VEC_length (vect_el_t, vect);\n+  size_t i;\n \n   els_on_line = 1;\n   if (vect_length == 0)\n-    fprintf (output_file,\n-             \"0 /* This is dummy el because the vect is empty */\");\n+    fputs (\"0 /* This is dummy el because the vect is empty */\", output_file);\n   else\n-    {\n-      do\n-        {\n-          fprintf (output_file, \"%5ld\", (long) *vect);\n-          vect_length--;\n-          if (els_on_line == 10)\n-\t    {\n-\t      els_on_line = 0;\n-\t      fprintf (output_file, \",\\n\");\n-\t    }\n-          else if (vect_length != 0)\n-            fprintf (output_file, \", \");\n-          els_on_line++;\n-          vect++;\n-        }\n-      while (vect_length != 0);\n-    }\n+    for (i = 0; i < vect_length; i++)\n+      {\n+\tfprintf (output_file, \"%5ld\", (long) VEC_index (vect_el_t, vect, i));\n+\tif (els_on_line == 10)\n+\t  {\n+\t    els_on_line = 0;\n+\t    fputs (\",\\n\", output_file);\n+\t  }\n+\telse if (i < vect_length-1)\n+\t  fputs (\", \", output_file);\n+\tels_on_line++;\n+      }\n }\n \n /* The following is name of the structure which represents DFA(s) for\n@@ -7514,25 +7391,28 @@ output_translate_vect (automaton_t automaton)\n   int insn_value;\n   vla_hwint_t translate_vect;\n \n-  VLA_HWINT_CREATE (translate_vect, 250, \"translate vector\");\n-  VLA_HWINT_EXPAND (translate_vect, description->insns_num);\n+  translate_vect = VEC_alloc (vect_el_t,heap, description->insns_num);\n+\n   for (insn_value = 0; insn_value < description->insns_num; insn_value++)\n     /* Undefined value */\n-    VLA_HWINT (translate_vect, insn_value) = automaton->insn_equiv_classes_num;\n+    VEC_quick_push (vect_el_t, translate_vect,\n+\t\t    automaton->insn_equiv_classes_num);\n+\n   for (ainsn = automaton->ainsn_list; ainsn != NULL; ainsn = ainsn->next_ainsn)\n-    VLA_HWINT (translate_vect, ainsn->insn_reserv_decl->insn_num)\n-      = ainsn->insn_equiv_class_num;\n+    VEC_replace (vect_el_t, translate_vect,\n+\t\t ainsn->insn_reserv_decl->insn_num,\n+\t\t ainsn->insn_equiv_class_num);\n+\n   fprintf (output_file,\n            \"/* Vector translating external insn codes to internal ones.*/\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, automaton->insn_equiv_classes_num);\n   fprintf (output_file, \" \");\n   output_translate_vect_name (output_file, automaton);\n   fprintf (output_file, \"[] ATTRIBUTE_UNUSED = {\\n\");\n-  output_vect (VLA_HWINT_BEGIN (translate_vect),\n-\t       VLA_HWINT_LENGTH (translate_vect));\n+  output_vect (translate_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VLA_HWINT_DELETE (translate_vect);\n+  VEC_free (vect_el_t,heap, translate_vect);\n }\n \n /* The value in a table state x ainsn -> something which represents\n@@ -7544,8 +7424,8 @@ static int undefined_vect_el_value;\n static int\n comb_vect_p (state_ainsn_table_t tab)\n {\n-  return  (2 * VLA_HWINT_LENGTH (tab->full_vect)\n-           > 5 * VLA_HWINT_LENGTH (tab->comb_vect));\n+  return  (2 * VEC_length (vect_el_t, tab->full_vect)\n+           > 5 * VEC_length (vect_el_t, tab->comb_vect));\n }\n \n /* The following function creates new table for AUTOMATON.  */\n@@ -7558,16 +7438,20 @@ create_state_ainsn_table (automaton_t automaton)\n \n   tab = create_node (sizeof (struct state_ainsn_table));\n   tab->automaton = automaton;\n-  VLA_HWINT_CREATE (tab->comb_vect, 10000, \"comb vector\");\n-  VLA_HWINT_CREATE (tab->check_vect, 10000, \"check vector\");\n-  VLA_HWINT_CREATE (tab->base_vect, 1000, \"base vector\");\n-  VLA_HWINT_EXPAND (tab->base_vect, automaton->achieved_states_num);\n-  VLA_HWINT_CREATE (tab->full_vect, 10000, \"full vector\");\n+\n+  tab->comb_vect  = VEC_alloc (vect_el_t,heap, 10000);\n+  tab->check_vect = VEC_alloc (vect_el_t,heap, 10000);\n+\n+  tab->base_vect  = 0;\n+  VEC_safe_grow (vect_el_t,heap, tab->base_vect,\n+\t\t automaton->achieved_states_num);\n+\n   full_vect_length = (automaton->insn_equiv_classes_num\n                       * automaton->achieved_states_num);\n-  VLA_HWINT_EXPAND (tab->full_vect, full_vect_length);\n+  tab->full_vect  = VEC_alloc (vect_el_t,heap, full_vect_length);\n   for (i = 0; i < full_vect_length; i++)\n-    VLA_HWINT (tab->full_vect, i) = undefined_vect_el_value;\n+    VEC_quick_push (vect_el_t, tab->full_vect, undefined_vect_el_value);\n+\n   tab->min_base_vect_el_value = 0;\n   tab->max_base_vect_el_value = 0;\n   tab->min_comb_vect_el_value = 0;\n@@ -7578,7 +7462,7 @@ create_state_ainsn_table (automaton_t automaton)\n /* The following function outputs the best C representation of the\n    table TAB of given TABLE_NAME.  */\n static void\n-output_state_ainsn_table (state_ainsn_table_t tab, char *table_name,\n+output_state_ainsn_table (state_ainsn_table_t tab, const char *table_name,\n \t\t\t  void (*output_full_vect_name_func) (FILE *, automaton_t),\n \t\t\t  void (*output_comb_vect_name_func) (FILE *, automaton_t),\n \t\t\t  void (*output_check_vect_name_func) (FILE *, automaton_t),\n@@ -7593,8 +7477,7 @@ output_state_ainsn_table (state_ainsn_table_t tab, char *table_name,\n       fprintf (output_file, \" \");\n       (*output_full_vect_name_func) (output_file, tab->automaton);\n       fprintf (output_file, \"[] ATTRIBUTE_UNUSED = {\\n\");\n-      output_vect (VLA_HWINT_BEGIN (tab->full_vect),\n-                   VLA_HWINT_LENGTH (tab->full_vect));\n+      output_vect (tab->full_vect);\n       fprintf (output_file, \"};\\n\\n\");\n     }\n   else\n@@ -7606,17 +7489,15 @@ output_state_ainsn_table (state_ainsn_table_t tab, char *table_name,\n       fprintf (output_file, \" \");\n       (*output_comb_vect_name_func) (output_file, tab->automaton);\n       fprintf (output_file, \"[] ATTRIBUTE_UNUSED = {\\n\");\n-      output_vect (VLA_HWINT_BEGIN (tab->comb_vect),\n-                   VLA_HWINT_LENGTH (tab->comb_vect));\n+      output_vect (tab->comb_vect);\n       fprintf (output_file, \"};\\n\\n\");\n       fprintf (output_file, \"/* Check vector for %s.  */\\n\", table_name);\n       fprintf (output_file, \"static const \");\n       output_range_type (output_file, 0, tab->automaton->achieved_states_num);\n       fprintf (output_file, \" \");\n       (*output_check_vect_name_func) (output_file, tab->automaton);\n       fprintf (output_file, \"[] = {\\n\");\n-      output_vect (VLA_HWINT_BEGIN (tab->check_vect),\n-                   VLA_HWINT_LENGTH (tab->check_vect));\n+      output_vect (tab->check_vect);\n       fprintf (output_file, \"};\\n\\n\");\n       fprintf (output_file, \"/* Base vector for %s.  */\\n\", table_name);\n       fprintf (output_file, \"static const \");\n@@ -7625,22 +7506,18 @@ output_state_ainsn_table (state_ainsn_table_t tab, char *table_name,\n       fprintf (output_file, \" \");\n       (*output_base_vect_name_func) (output_file, tab->automaton);\n       fprintf (output_file, \"[] = {\\n\");\n-      output_vect (VLA_HWINT_BEGIN (tab->base_vect),\n-                   VLA_HWINT_LENGTH (tab->base_vect));\n+      output_vect (tab->base_vect);\n       fprintf (output_file, \"};\\n\\n\");\n     }\n }\n \n-/* The following function adds vector with length VECT_LENGTH and\n-   elements pointed to by VECT to table TAB as its line with number\n-   VECT_NUM.  */\n+/* The following function adds vector VECT to table TAB as its line\n+   with number VECT_NUM.  */\n static void\n-add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n-\t  int vect_length)\n+add_vect (state_ainsn_table_t tab, int vect_num, vla_hwint_t vect)\n {\n-  int real_vect_length;\n-  vect_el_t *comb_vect_start;\n-  vect_el_t *check_vect_start;\n+  int vect_length;\n+  size_t real_vect_length;\n   int comb_vect_index;\n   int comb_vect_els_num;\n   int vect_index;\n@@ -7651,23 +7528,30 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n   int i;\n   unsigned long vect_mask, comb_vect_mask;\n \n+  vect_length = VEC_length (vect_el_t, vect);\n   gcc_assert (vect_length);\n+  gcc_assert (VEC_last (vect_el_t, vect) != undefined_vect_el_value);\n   real_vect_length = tab->automaton->insn_equiv_classes_num;\n-  gcc_assert (vect [vect_length - 1] != undefined_vect_el_value);\n   /* Form full vector in the table: */\n-  for (i = 0; i < vect_length; i++)\n-    VLA_HWINT (tab->full_vect,\n-               i + tab->automaton->insn_equiv_classes_num * vect_num)\n-      = vect [i];\n+  {\n+    size_t full_base = tab->automaton->insn_equiv_classes_num * vect_num;\n+    if (VEC_length (vect_el_t, tab->full_vect) < full_base + vect_length)\n+      VEC_safe_grow (vect_el_t,heap, tab->full_vect,\n+\t\t     full_base + vect_length);\n+    for (i = 0; i < vect_length; i++)\n+      VEC_replace (vect_el_t, tab->full_vect, full_base + i,\n+\t\t   VEC_index (vect_el_t, vect, i));\n+  }\n   /* Form comb vector in the table: */\n-  gcc_assert (VLA_HWINT_LENGTH (tab->comb_vect)\n-\t      == VLA_HWINT_LENGTH (tab->check_vect));\n-  comb_vect_start = VLA_HWINT_BEGIN (tab->comb_vect);\n-  comb_vect_els_num = VLA_HWINT_LENGTH (tab->comb_vect);\n+  gcc_assert (VEC_length (vect_el_t, tab->comb_vect)\n+\t      == VEC_length (vect_el_t, tab->check_vect));\n+\n+  comb_vect_els_num = VEC_length (vect_el_t, tab->comb_vect);\n   for (first_unempty_vect_index = 0;\n        first_unempty_vect_index < vect_length;\n        first_unempty_vect_index++)\n-    if (vect [first_unempty_vect_index] != undefined_vect_el_value)\n+    if (VEC_index (vect_el_t, vect, first_unempty_vect_index)\n+\t!= undefined_vect_el_value)\n       break;\n \n   /* Search for the place in comb vect for the inserted vect.  */\n@@ -7683,8 +7567,10 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n                vect_index < vect_length\n                && vect_index + comb_vect_index < comb_vect_els_num;\n                vect_index++)\n-            if (vect [vect_index] != undefined_vect_el_value\n-                && (comb_vect_start [vect_index + comb_vect_index]\n+            if (VEC_index (vect_el_t, vect, vect_index)\n+\t\t!= undefined_vect_el_value\n+                && (VEC_index (vect_el_t, tab->comb_vect,\n+\t\t\t       vect_index + comb_vect_index)\n \t\t    != undefined_vect_el_value))\n               break;\n           if (vect_index >= vect_length\n@@ -7701,7 +7587,7 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n        vect_index++)\n     {\n       vect_mask = vect_mask << 1;\n-      if (vect [vect_index] != undefined_vect_el_value)\n+      if (VEC_index (vect_el_t, vect, vect_index) != undefined_vect_el_value)\n \tvect_mask |= 1;\n     }\n \n@@ -7717,7 +7603,7 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n     {\n       comb_vect_mask <<= 1;\n       if (vect_index + comb_vect_index < comb_vect_els_num\n-\t  && comb_vect_start [vect_index + comb_vect_index]\n+\t  && VEC_index (vect_el_t, tab->comb_vect, vect_index + comb_vect_index)\n \t     != undefined_vect_el_value)\n \tcomb_vect_mask |= 1;\n     }\n@@ -7728,7 +7614,8 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n        comb_vect_index++, i++)\n     {\n       comb_vect_mask = (comb_vect_mask << 1) | 1;\n-      comb_vect_mask ^= comb_vect_start [i] == undefined_vect_el_value;\n+      comb_vect_mask ^= (VEC_index (vect_el_t, tab->comb_vect, i)\n+\t\t\t == undefined_vect_el_value);\n       if ((vect_mask & comb_vect_mask) == 0)\n \tgoto found;\n     }\n@@ -7749,27 +7636,29 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n   no_state_value = tab->automaton->achieved_states_num;\n   while (additional_els_num > 0)\n     {\n-      VLA_HWINT_ADD (tab->comb_vect, vect_el);\n-      VLA_HWINT_ADD (tab->check_vect, no_state_value);\n+      VEC_safe_push (vect_el_t,heap, tab->comb_vect, vect_el);\n+      VEC_safe_push (vect_el_t,heap, tab->check_vect, no_state_value);\n       additional_els_num--;\n     }\n-  comb_vect_start = VLA_HWINT_BEGIN (tab->comb_vect);\n-  check_vect_start = VLA_HWINT_BEGIN (tab->check_vect);\n-  gcc_assert (VLA_HWINT_LENGTH (tab->comb_vect)\n-\t      >= (size_t) (comb_vect_index + real_vect_length));\n+  gcc_assert (VEC_length (vect_el_t, tab->comb_vect)\n+\t      >= comb_vect_index + real_vect_length);\n   /* Fill comb and check vectors.  */\n   for (vect_index = 0; vect_index < vect_length; vect_index++)\n-    if (vect [vect_index] != undefined_vect_el_value)\n+    if (VEC_index (vect_el_t, vect, vect_index) != undefined_vect_el_value)\n       {\n-        gcc_assert (comb_vect_start [comb_vect_index + vect_index]\n+\tvect_el_t x = VEC_index (vect_el_t, vect, vect_index);\n+        gcc_assert (VEC_index (vect_el_t, tab->comb_vect,\n+\t\t\t       comb_vect_index + vect_index)\n \t\t    == undefined_vect_el_value);\n-        comb_vect_start [comb_vect_index + vect_index] = vect [vect_index];\n-        gcc_assert (vect [vect_index] >= 0);\n-        if (tab->max_comb_vect_el_value < vect [vect_index])\n-          tab->max_comb_vect_el_value = vect [vect_index];\n-        if (tab->min_comb_vect_el_value > vect [vect_index])\n-          tab->min_comb_vect_el_value = vect [vect_index];\n-        check_vect_start [comb_vect_index + vect_index] = vect_num;\n+        gcc_assert (x >= 0);\n+        if (tab->max_comb_vect_el_value < x)\n+          tab->max_comb_vect_el_value = x;\n+        if (tab->min_comb_vect_el_value > x)\n+          tab->min_comb_vect_el_value = x;\n+\tVEC_replace (vect_el_t, tab->comb_vect,\n+\t\t     comb_vect_index + vect_index, x);\n+\tVEC_replace (vect_el_t, tab->check_vect,\n+\t\t     comb_vect_index + vect_index, vect_num);\n       }\n   if (tab->max_comb_vect_el_value < undefined_vect_el_value)\n     tab->max_comb_vect_el_value = undefined_vect_el_value;\n@@ -7779,7 +7668,8 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n     tab->max_base_vect_el_value = comb_vect_index;\n   if (tab->min_base_vect_el_value > comb_vect_index)\n     tab->min_base_vect_el_value = comb_vect_index;\n-  VLA_HWINT (tab->base_vect, vect_num) = comb_vect_index;\n+\n+  VEC_replace (vect_el_t, tab->base_vect, vect_num, comb_vect_index);\n }\n \n /* Return number of out arcs of STATE.  */\n@@ -7827,49 +7717,47 @@ add_vect_el (vla_hwint_t *vect, ainsn_t ainsn, int el_value)\n \n   gcc_assert (ainsn);\n   equiv_class_num = ainsn->insn_equiv_class_num;\n-  for (vect_index = VLA_HWINT_LENGTH (*vect);\n+  for (vect_index = VEC_length (vect_el_t, *vect);\n        vect_index <= equiv_class_num;\n        vect_index++)\n-    VLA_HWINT_ADD (*vect, undefined_vect_el_value);\n-  VLA_HWINT (*vect, equiv_class_num) = el_value;\n+    VEC_safe_push (vect_el_t,heap, *vect, undefined_vect_el_value);\n+  VEC_replace (vect_el_t, *vect, equiv_class_num, el_value);\n }\n \n /* This is for forming vector of states of an automaton.  */\n-static vla_ptr_t output_states_vect;\n+static VEC(state_t,heap) *output_states_vect;\n \n /* The function is called by function pass_states.  The function adds\n    STATE to `output_states_vect'.  */\n static void\n add_states_vect_el (state_t state)\n {\n-  VLA_PTR_ADD (output_states_vect, state);\n+  VEC_safe_push (state_t,heap, output_states_vect, state);\n }\n \n /* Form and output vectors (comb, check, base or full vector)\n    representing transition table of AUTOMATON.  */\n static void\n output_trans_table (automaton_t automaton)\n {\n-  state_t *state_ptr;\n+  size_t i;\n   arc_t arc;\n-  vla_hwint_t transition_vect;\n+  vla_hwint_t transition_vect = 0;\n \n   undefined_vect_el_value = automaton->achieved_states_num;\n   automaton->trans_table = create_state_ainsn_table (automaton);\n   /* Create vect of pointers to states ordered by num of transitions\n      from the state (state with the maximum num is the first).  */\n-  VLA_PTR_CREATE (output_states_vect, 1500, \"output states vector\");\n+  output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n-  qsort (VLA_PTR_BEGIN (output_states_vect),\n-         VLA_PTR_LENGTH (output_states_vect),\n+  qsort (VEC_address (state_t, output_states_vect),\n+\t VEC_length (state_t, output_states_vect),\n          sizeof (state_t), compare_transition_els_num);\n-  VLA_HWINT_CREATE (transition_vect, 500, \"transition vector\");\n-  for (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-       state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-       state_ptr++)\n+\n+  for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n     {\n-      VLA_HWINT_NULLIFY (transition_vect);\n-      for (arc = first_out_arc (*state_ptr);\n+      VEC_truncate (vect_el_t, transition_vect, 0);\n+      for (arc = first_out_arc (VEC_index (state_t, output_states_vect, i));\n \t   arc != NULL;\n \t   arc = next_out_arc (arc))\n         {\n@@ -7878,16 +7766,17 @@ output_trans_table (automaton_t automaton)\n             add_vect_el (&transition_vect, arc->insn,\n                          arc->to_state->order_state_num);\n         }\n-      add_vect (automaton->trans_table, (*state_ptr)->order_state_num,\n-                VLA_HWINT_BEGIN (transition_vect),\n-                VLA_HWINT_LENGTH (transition_vect));\n+      add_vect (automaton->trans_table,\n+\t\tVEC_index (state_t, output_states_vect, i)->order_state_num,\n+\t\ttransition_vect);\n     }\n   output_state_ainsn_table\n-    (automaton->trans_table, (char *) \"state transitions\",\n+    (automaton->trans_table, \"state transitions\",\n      output_trans_full_vect_name, output_trans_comb_vect_name,\n      output_trans_check_vect_name, output_trans_base_vect_name);\n-  VLA_PTR_DELETE (output_states_vect);\n-  VLA_HWINT_DELETE (transition_vect);\n+\n+  VEC_free (state_t,heap, output_states_vect);\n+  VEC_free (vect_el_t,heap, transition_vect);\n }\n \n /* Form and output vectors (comb, check, base or simple vect)\n@@ -7897,44 +7786,45 @@ output_trans_table (automaton_t automaton)\n static void\n output_state_alts_table (automaton_t automaton)\n {\n-  state_t *state_ptr;\n+  size_t i;\n   arc_t arc;\n   vla_hwint_t state_alts_vect;\n \n   undefined_vect_el_value = 0; /* no alts when transition is not possible */\n   automaton->state_alts_table = create_state_ainsn_table (automaton);\n   /* Create vect of pointers to states ordered by num of transitions\n      from the state (state with the maximum num is the first).  */\n-  VLA_PTR_CREATE (output_states_vect, 1500, \"output states vector\");\n+  output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n-  qsort (VLA_PTR_BEGIN (output_states_vect),\n-         VLA_PTR_LENGTH (output_states_vect),\n+  qsort (VEC_address (state_t, output_states_vect),\n+\t VEC_length (state_t, output_states_vect),\n          sizeof (state_t), compare_transition_els_num);\n+\n   /* Create base, comb, and check vectors.  */\n-  VLA_HWINT_CREATE (state_alts_vect, 500, \"state alts vector\");\n-  for (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-       state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-       state_ptr++)\n+  state_alts_vect = 0;\n+\n+  for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n     {\n-      VLA_HWINT_NULLIFY (state_alts_vect);\n-      for (arc = first_out_arc (*state_ptr);\n+      VEC_truncate (vect_el_t, state_alts_vect, 0);\n+      for (arc = first_out_arc (VEC_index (state_t, output_states_vect, i));\n \t   arc != NULL;\n \t   arc = next_out_arc (arc))\n         {\n           gcc_assert (arc->insn);\n           if (arc->insn->first_ainsn_with_given_equivalence_num)\n             add_vect_el (&state_alts_vect, arc->insn, arc->state_alts);\n         }\n-      add_vect (automaton->state_alts_table, (*state_ptr)->order_state_num,\n-                VLA_HWINT_BEGIN (state_alts_vect),\n-                VLA_HWINT_LENGTH (state_alts_vect));\n+      add_vect (automaton->state_alts_table,\n+\t\tVEC_index (state_t, output_states_vect, i)->order_state_num,\n+                state_alts_vect);\n     }\n   output_state_ainsn_table\n-    (automaton->state_alts_table, (char *) \"state insn alternatives\",\n+    (automaton->state_alts_table, \"state insn alternatives\",\n      output_state_alts_full_vect_name, output_state_alts_comb_vect_name,\n      output_state_alts_check_vect_name, output_state_alts_base_vect_name);\n-  VLA_PTR_DELETE (output_states_vect);\n-  VLA_HWINT_DELETE (state_alts_vect);\n+\n+  VEC_free (state_t,heap, output_states_vect);\n+  VEC_free (vect_el_t,heap, state_alts_vect);\n }\n \n /* The current number of passing states to find minimal issue delay\n@@ -8013,41 +7903,38 @@ output_min_issue_delay_table (automaton_t automaton)\n   vla_hwint_t compressed_min_issue_delay_vect;\n   vect_el_t min_delay;\n   ainsn_t ainsn;\n-  state_t *state_ptr;\n-  int i;\n+  size_t i, min_issue_delay_len;\n+  size_t compressed_min_issue_delay_len;\n+  size_t cfactor;\n \n   /* Create vect of pointers to states ordered by num of transitions\n      from the state (state with the maximum num is the first).  */\n-  VLA_PTR_CREATE (output_states_vect, 1500, \"output states vector\");\n+  output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n-  VLA_HWINT_CREATE (min_issue_delay_vect, 1500, \"min issue delay vector\");\n-  VLA_HWINT_EXPAND (min_issue_delay_vect,\n-\t\t    VLA_HWINT_LENGTH (output_states_vect)\n-\t\t    * automaton->insn_equiv_classes_num);\n-  for (i = 0;\n-       i < ((int) VLA_HWINT_LENGTH (output_states_vect)\n-\t    * automaton->insn_equiv_classes_num);\n-       i++)\n-    VLA_HWINT (min_issue_delay_vect, i) = 0;\n+\n+  min_issue_delay_len = (VEC_length (state_t, output_states_vect)\n+\t\t\t * automaton->insn_equiv_classes_num);\n+  min_issue_delay_vect = VEC_alloc (vect_el_t,heap, min_issue_delay_len);\n+  for (i = 0; i < min_issue_delay_len; i++)\n+    VEC_quick_push (vect_el_t, min_issue_delay_vect, 0);\n+\n   automaton->max_min_delay = 0;\n   for (ainsn = automaton->ainsn_list; ainsn != NULL; ainsn = ainsn->next_ainsn)\n     if (ainsn->first_ainsn_with_given_equivalence_num)\n       {\n-\tfor (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-\t     state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-\t     state_ptr++)\n-\t  (*state_ptr)->min_insn_issue_delay = -1;\n-\tfor (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-\t     state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-\t     state_ptr++)\n+\tfor (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n+\t  VEC_index (state_t, output_states_vect, i)->min_insn_issue_delay = -1;\n+\tfor (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n \t  {\n-            min_delay = min_issue_delay (*state_ptr, ainsn);\n+\t    state_t s = VEC_index (state_t, output_states_vect, i);\n+            min_delay = min_issue_delay (s, ainsn);\n \t    if (automaton->max_min_delay < min_delay)\n \t      automaton->max_min_delay = min_delay;\n-\t    VLA_HWINT (min_issue_delay_vect,\n-\t\t       (*state_ptr)->order_state_num\n-\t\t       * automaton->insn_equiv_classes_num\n-\t\t       + ainsn->insn_equiv_class_num) = min_delay;\n+\t    VEC_replace (vect_el_t, min_issue_delay_vect,\n+\t\t\t s->order_state_num\n+\t\t\t * automaton->insn_equiv_classes_num\n+\t\t\t + ainsn->insn_equiv_class_num,\n+\t\t\t min_delay);\n \t  }\n       }\n   fprintf (output_file, \"/* Vector of min issue delay of insns.  */\\n\");\n@@ -8058,37 +7945,36 @@ output_min_issue_delay_table (automaton_t automaton)\n   fprintf (output_file, \"[] ATTRIBUTE_UNUSED = {\\n\");\n   /* Compress the vector.  */\n   if (automaton->max_min_delay < 2)\n-    automaton->min_issue_delay_table_compression_factor = 8;\n+    cfactor = 8;\n   else if (automaton->max_min_delay < 4)\n-    automaton->min_issue_delay_table_compression_factor = 4;\n+    cfactor = 4;\n   else if (automaton->max_min_delay < 16)\n-    automaton->min_issue_delay_table_compression_factor = 2;\n+    cfactor = 2;\n   else\n-    automaton->min_issue_delay_table_compression_factor = 1;\n-  VLA_HWINT_CREATE (compressed_min_issue_delay_vect, 1500,\n-\t\t    \"compressed min issue delay vector\");\n-  VLA_HWINT_EXPAND (compressed_min_issue_delay_vect,\n-\t\t    (VLA_HWINT_LENGTH (min_issue_delay_vect)\n-\t\t     + automaton->min_issue_delay_table_compression_factor\n-\t\t     - 1)\n-\t\t    / automaton->min_issue_delay_table_compression_factor);\n-  for (i = 0;\n-       i < (int) VLA_HWINT_LENGTH (compressed_min_issue_delay_vect);\n-       i++)\n-    VLA_HWINT (compressed_min_issue_delay_vect, i) = 0;\n-  for (i = 0; i < (int) VLA_HWINT_LENGTH (min_issue_delay_vect); i++)\n-    VLA_HWINT (compressed_min_issue_delay_vect,\n-\t       i / automaton->min_issue_delay_table_compression_factor)\n-      |= (VLA_HWINT (min_issue_delay_vect, i)\n-\t  << (8 - (i % automaton->min_issue_delay_table_compression_factor\n-\t\t   + 1)\n-\t      * (8 / automaton->min_issue_delay_table_compression_factor)));\n-  output_vect (VLA_HWINT_BEGIN (compressed_min_issue_delay_vect),\n-               VLA_HWINT_LENGTH (compressed_min_issue_delay_vect));\n+    cfactor = 1;\n+  automaton->min_issue_delay_table_compression_factor = cfactor;\n+\n+  compressed_min_issue_delay_len = (min_issue_delay_len+cfactor-1) / cfactor;\n+  compressed_min_issue_delay_vect\n+    = VEC_alloc (vect_el_t,heap, compressed_min_issue_delay_len);\n+\n+  for (i = 0; i < compressed_min_issue_delay_len; i++)\n+    VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect, 0);\n+\n+  for (i = 0; i < min_issue_delay_len; i++)\n+    {\n+      size_t ci = i / cfactor;\n+      vect_el_t x = VEC_index (vect_el_t, min_issue_delay_vect, i);\n+      vect_el_t cx = VEC_index (vect_el_t, compressed_min_issue_delay_vect, ci);\n+\n+      cx |= x << (8 - (i % cfactor + 1) * (8 / cfactor));\n+      VEC_replace (vect_el_t, compressed_min_issue_delay_vect, ci, cx);\n+    }\n+  output_vect (compressed_min_issue_delay_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VLA_PTR_DELETE (output_states_vect);\n-  VLA_HWINT_DELETE (min_issue_delay_vect);\n-  VLA_HWINT_DELETE (compressed_min_issue_delay_vect);\n+  VEC_free (state_t,heap, output_states_vect);\n+  VEC_free (vect_el_t,heap, min_issue_delay_vect);\n+  VEC_free (vect_el_t,heap, compressed_min_issue_delay_vect);\n }\n \n #ifndef NDEBUG\n@@ -8102,29 +7988,30 @@ static int locked_states_num;\n static void\n output_dead_lock_vect (automaton_t automaton)\n {\n-  state_t *state_ptr;\n+  size_t i;\n   arc_t arc;\n-  vla_hwint_t dead_lock_vect;\n+  vla_hwint_t dead_lock_vect = 0;\n \n   /* Create vect of pointers to states ordered by num of\n      transitions from the state (state with the maximum num is the\n      first).  */\n-  VLA_PTR_CREATE (output_states_vect, 1500, \"output states vector\");\n+  output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n-  VLA_HWINT_CREATE (dead_lock_vect, 1500, \"is dead locked vector\");\n-  VLA_HWINT_EXPAND (dead_lock_vect, VLA_HWINT_LENGTH (output_states_vect));\n-  for (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-       state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-       state_ptr++)\n+\n+  VEC_safe_grow (vect_el_t,heap, dead_lock_vect, \n+\t\t VEC_length (state_t, output_states_vect));\n+  for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n     {\n-      arc = first_out_arc (*state_ptr);\n+      state_t s = VEC_index (state_t, output_states_vect, i);\n+      arc = first_out_arc (s);\n       gcc_assert (arc);\n-      VLA_HWINT (dead_lock_vect, (*state_ptr)->order_state_num)\n-        = (next_out_arc (arc) == NULL\n-           && (arc->insn->insn_reserv_decl\n-               == DECL_INSN_RESERV (advance_cycle_insn_decl)) ? 1 : 0);\n+      VEC_replace (vect_el_t, dead_lock_vect, s->order_state_num,\n+\t\t   (next_out_arc (arc) == NULL\n+\t\t    && (arc->insn->insn_reserv_decl\n+\t\t\t== DECL_INSN_RESERV (advance_cycle_insn_decl))\n+\t\t    ? 1 : 0));\n #ifndef NDEBUG\n-      if (VLA_HWINT (dead_lock_vect, (*state_ptr)->order_state_num))\n+      if (VEC_index (vect_el_t,dead_lock_vect, s->order_state_num))\n         locked_states_num++;\n #endif\n     }\n@@ -8134,58 +8021,61 @@ output_dead_lock_vect (automaton_t automaton)\n   fprintf (output_file, \" \");\n   output_dead_lock_vect_name (output_file, automaton);\n   fprintf (output_file, \"[] = {\\n\");\n-  output_vect (VLA_HWINT_BEGIN (dead_lock_vect),\n-\t       VLA_HWINT_LENGTH (dead_lock_vect));\n+  output_vect (dead_lock_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VLA_HWINT_DELETE (dead_lock_vect);\n-  VLA_PTR_DELETE (output_states_vect);\n+  VEC_free (state_t,heap, output_states_vect);\n+  VEC_free (vect_el_t,heap, dead_lock_vect);\n }\n \n /* Form and output vector representing reserved units of the states of\n    AUTOMATON.  */\n static void\n output_reserved_units_table (automaton_t automaton)\n {\n-  state_t *curr_state_ptr;\n-  vla_hwint_t reserved_units_table;\n-  size_t state_byte_size;\n+  vla_hwint_t reserved_units_table = 0;\n+  int state_byte_size;\n+  int reserved_units_size;\n+  size_t n;\n   int i;\n \n   /* Create vect of pointers to states.  */\n-  VLA_PTR_CREATE (output_states_vect, 1500, \"output states vector\");\n+  output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n   /* Create vector.  */\n-  VLA_HWINT_CREATE (reserved_units_table, 1500, \"reserved units vector\");\n   state_byte_size = (description->query_units_num + 7) / 8;\n-  VLA_HWINT_EXPAND (reserved_units_table,\n-\t\t    VLA_HWINT_LENGTH (output_states_vect) * state_byte_size);\n-  for (i = 0;\n-       i < (int) (VLA_HWINT_LENGTH (output_states_vect) * state_byte_size);\n-       i++)\n-    VLA_HWINT (reserved_units_table, i) = 0;\n-  for (curr_state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-       curr_state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-       curr_state_ptr++)\n+  reserved_units_size = (VEC_length (state_t, output_states_vect)\n+\t\t\t * state_byte_size);\n+\n+  reserved_units_table = VEC_alloc (vect_el_t,heap, reserved_units_size);\n+\t\t \n+  for (i = 0; i < reserved_units_size; i++)\n+    VEC_quick_push (vect_el_t, reserved_units_table, 0);\n+  for (n = 0; n < VEC_length (state_t, output_states_vect); n++)\n     {\n+      state_t s = VEC_index (state_t, output_states_vect, n);\n       for (i = 0; i < description->units_num; i++)\n \tif (units_array [i]->query_p\n-\t    && first_cycle_unit_presence (*curr_state_ptr, i))\n-\t  VLA_HWINT (reserved_units_table,\n-\t\t     (*curr_state_ptr)->order_state_num * state_byte_size\n-\t\t     + units_array [i]->query_num / 8)\n-\t    += (1 << (units_array [i]->query_num % 8));\n+\t    && first_cycle_unit_presence (s, i))\n+\t  {\n+\t    int ri = (s->order_state_num * state_byte_size\n+\t\t      + units_array [i]->query_num / 8);\n+\t    vect_el_t x = VEC_index (vect_el_t, reserved_units_table, ri);\n+\n+\t    x += 1 << (units_array [i]->query_num % 8);\n+\t    VEC_replace (vect_el_t, reserved_units_table, ri, x);\n+\t  }\n     }\n   fprintf (output_file, \"/* Vector for reserved units of states.  */\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, 255);\n   fprintf (output_file, \" \");\n   output_reserved_units_table_name (output_file, automaton);\n   fprintf (output_file, \"[] = {\\n\");\n-  output_vect (VLA_HWINT_BEGIN (reserved_units_table),\n-               VLA_HWINT_LENGTH (reserved_units_table));\n+  output_vect (reserved_units_table);\n   fprintf (output_file, \"};\\n\\n\");\n-  VLA_HWINT_DELETE (reserved_units_table);\n-  VLA_PTR_DELETE (output_states_vect);\n+\n+  VEC_free (state_t,heap, output_states_vect);\n+  VEC_free (vect_el_t,heap, reserved_units_table);\n }\n \n /* The function outputs all tables representing DFA(s) used for fast\n@@ -9225,7 +9115,7 @@ static void\n output_automaton_units (automaton_t automaton)\n {\n   decl_t decl;\n-  char *name;\n+  const char *name;\n   int curr_line_length;\n   int there_is_an_automaton_unit;\n   int i;\n@@ -9263,25 +9153,21 @@ output_automaton_units (automaton_t automaton)\n \n /* The following variable is used for forming array of all possible cpu unit\n    reservations described by the current DFA state.  */\n-static vla_ptr_t state_reservs;\n+static VEC(reserv_sets_t,heap) *state_reservs;\n \n /* The function forms `state_reservs' for STATE.  */\n static void\n add_state_reservs (state_t state)\n {\n   alt_state_t curr_alt_state;\n-  reserv_sets_t reservs;\n \n   if (state->component_states != NULL)\n     for (curr_alt_state = state->component_states;\n          curr_alt_state != NULL;\n          curr_alt_state = curr_alt_state->next_sorted_alt_state)\n       add_state_reservs (curr_alt_state->state);\n   else\n-    {\n-      reservs = state->reservs;\n-      VLA_PTR_ADD (state_reservs, reservs);\n-    }\n+    VEC_safe_push (reserv_sets_t,heap, state_reservs, state->reservs);\n }\n \n /* The function outputs readable representation of all out arcs of\n@@ -9291,7 +9177,7 @@ output_state_arcs (state_t state)\n {\n   arc_t arc;\n   ainsn_t ainsn;\n-  char *insn_name;\n+  const char *insn_name;\n   int curr_line_length;\n \n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n@@ -9347,21 +9233,17 @@ state_reservs_cmp (const void *reservs_ptr_1, const void *reservs_ptr_2)\n static void\n remove_state_duplicate_reservs (void)\n {\n-  reserv_sets_t *reservs_ptr;\n-  reserv_sets_t *last_formed_reservs_ptr;\n+  size_t i, j;\n \n-  last_formed_reservs_ptr = NULL;\n-  for (reservs_ptr = VLA_PTR_BEGIN (state_reservs);\n-       reservs_ptr <= (reserv_sets_t *) VLA_PTR_LAST (state_reservs);\n-       reservs_ptr++)\n-    if (last_formed_reservs_ptr == NULL)\n-      last_formed_reservs_ptr = reservs_ptr;\n-    else if (reserv_sets_cmp (*last_formed_reservs_ptr, *reservs_ptr) != 0)\n+  for (i = 1, j = 0; i < VEC_length (reserv_sets_t, state_reservs); i++)\n+    if (reserv_sets_cmp (VEC_index (reserv_sets_t, state_reservs, j),\n+\t\t\t VEC_index (reserv_sets_t, state_reservs, i)))\n       {\n-        ++last_formed_reservs_ptr;\n-        *last_formed_reservs_ptr = *reservs_ptr;\n+\tj++;\n+\tVEC_replace (reserv_sets_t, state_reservs, j,\n+\t\t     VEC_index (reserv_sets_t, state_reservs, i));\n       }\n-  VLA_PTR_SHORTEN (state_reservs, reservs_ptr - last_formed_reservs_ptr - 1);\n+  VEC_truncate (reserv_sets_t, state_reservs, j + 1);\n }\n \n /* The following function output readable representation of DFA(s)\n@@ -9371,27 +9253,28 @@ remove_state_duplicate_reservs (void)\n static void\n output_state (state_t state)\n {\n-  reserv_sets_t *reservs_ptr;\n+  size_t i;\n+\n+  state_reservs = 0;\n \n-  VLA_PTR_CREATE (state_reservs, 150, \"state reservations\");\n   fprintf (output_description_file, \"  State #%d\", state->order_state_num);\n   fprintf (output_description_file,\n \t   state->new_cycle_p ? \" (new cycle)\\n\" : \"\\n\");\n   add_state_reservs (state);\n-  qsort (VLA_PTR_BEGIN (state_reservs), VLA_PTR_LENGTH (state_reservs),\n+  qsort (VEC_address (reserv_sets_t, state_reservs),\n+\t VEC_length (reserv_sets_t, state_reservs),\n          sizeof (reserv_sets_t), state_reservs_cmp);\n   remove_state_duplicate_reservs ();\n-  for (reservs_ptr = VLA_PTR_BEGIN (state_reservs);\n-       reservs_ptr <= (reserv_sets_t *) VLA_PTR_LAST (state_reservs);\n-       reservs_ptr++)\n+  for (i = 1; i < VEC_length (reserv_sets_t, state_reservs); i++)\n     {\n       fprintf (output_description_file, \"    \");\n-      output_reserv_sets (output_description_file, *reservs_ptr);\n+      output_reserv_sets (output_description_file,\n+\t\t\t  VEC_index (reserv_sets_t, state_reservs, i));\n       fprintf (output_description_file, \"\\n\");\n     }\n   fprintf (output_description_file, \"\\n\");\n   output_state_arcs (state);\n-  VLA_PTR_DELETE (state_reservs);\n+  VEC_free (reserv_sets_t,heap, state_reservs);\n }\n \n /* The following function output readable representation of\n@@ -9456,28 +9339,28 @@ output_statistics (FILE *f)\n #ifndef NDEBUG\n       fprintf\n \t(f, \"%5ld transition comb vector els, %5ld trans table els: %s\\n\",\n-\t (long) VLA_HWINT_LENGTH (automaton->trans_table->comb_vect),\n-\t (long) VLA_HWINT_LENGTH (automaton->trans_table->full_vect),\n+\t (long) VEC_length (vect_el_t, automaton->trans_table->comb_vect),\n+\t (long) VEC_length (vect_el_t, automaton->trans_table->full_vect),\n \t (comb_vect_p (automaton->trans_table)\n \t  ? \"use comb vect\" : \"use simple vect\"));\n       fprintf\n         (f, \"%5ld state alts comb vector els, %5ld state alts table els: %s\\n\",\n-         (long) VLA_HWINT_LENGTH (automaton->state_alts_table->comb_vect),\n-         (long) VLA_HWINT_LENGTH (automaton->state_alts_table->full_vect),\n+         (long) VEC_length (vect_el_t, automaton->state_alts_table->comb_vect),\n+         (long) VEC_length (vect_el_t, automaton->state_alts_table->full_vect),\n          (comb_vect_p (automaton->state_alts_table)\n           ? \"use comb vect\" : \"use simple vect\"));\n       fprintf\n         (f, \"%5ld min delay table els, compression factor %d\\n\",\n          (long) states_num * automaton->insn_equiv_classes_num,\n \t automaton->min_issue_delay_table_compression_factor);\n       transition_comb_vect_els\n-\t+= VLA_HWINT_LENGTH (automaton->trans_table->comb_vect);\n+\t+= VEC_length (vect_el_t, automaton->trans_table->comb_vect);\n       transition_full_vect_els\n-        += VLA_HWINT_LENGTH (automaton->trans_table->full_vect);\n+        += VEC_length (vect_el_t, automaton->trans_table->full_vect);\n       state_alts_comb_vect_els\n-        += VLA_HWINT_LENGTH (automaton->state_alts_table->comb_vect);\n+        += VEC_length (vect_el_t, automaton->state_alts_table->comb_vect);\n       state_alts_full_vect_els\n-        += VLA_HWINT_LENGTH (automaton->state_alts_table->full_vect);\n+        += VEC_length (vect_el_t, automaton->state_alts_table->full_vect);\n       min_issue_delay_vect_els\n \t+= states_num * automaton->insn_equiv_classes_num;\n #endif\n@@ -9773,7 +9656,7 @@ initiate_automaton_gen (int argc, char **argv)\n \tfatal (\"option `-split' has not been implemented yet\\n\");\n \t/* split_argument = atoi (argument_vect [i + 1]); */\n       }\n-  VLA_PTR_CREATE (decls, 150, \"decls\");\n+\n   /* Initialize IR storage.  */\n   obstack_init (&irp);\n   initiate_automaton_decl_table ();\n@@ -9838,14 +9721,14 @@ check_automata_insn_issues (void)\n \n /* The following vla is used for storing pointers to all achieved\n    states.  */\n-static vla_ptr_t automaton_states;\n+static VEC(state_t,heap) *automaton_states;\n \n /* This function is called by function pass_states to add an achieved\n    STATE.  */\n static void\n add_automaton_state (state_t state)\n {\n-  VLA_PTR_ADD (automaton_states, state);\n+  VEC_safe_push (state_t,heap, automaton_states, state);\n }\n \n /* The following function forms list of important automata (whose\n@@ -9854,29 +9737,27 @@ static void\n form_important_insn_automata_lists (void)\n {\n   automaton_t automaton;\n-  state_t *state_ptr;\n   decl_t decl;\n   ainsn_t ainsn;\n   arc_t arc;\n   int i;\n+  size_t n;\n \n-  VLA_PTR_CREATE (automaton_states, 1500,\n-\t\t  \"automaton states for forming important insn automata sets\");\n+  automaton_states = 0;\n   /* Mark important ainsns.  */\n   for (automaton = description->first_automaton;\n        automaton != NULL;\n        automaton = automaton->next_automaton)\n     {\n-      VLA_PTR_NULLIFY (automaton_states);\n+      VEC_truncate (state_t, automaton_states, 0);\n       pass_states (automaton, add_automaton_state);\n-      for (state_ptr = VLA_PTR_BEGIN (automaton_states);\n-\t   state_ptr <= (state_t *) VLA_PTR_LAST (automaton_states);\n-\t   state_ptr++)\n+      for (n = 0; n < VEC_length (state_t, automaton_states); n++)\n \t{\n-\t  for (arc = first_out_arc (*state_ptr);\n+\t  state_t s = VEC_index (state_t, automaton_states, n);\n+\t  for (arc = first_out_arc (s);\n \t       arc != NULL;\n \t       arc = next_out_arc (arc))\n-\t    if (arc->to_state != *state_ptr)\n+\t    if (arc->to_state != s)\n \t      {\n \t\tgcc_assert (arc->insn->first_insn_with_same_reservs);\n \t\tfor (ainsn = arc->insn;\n@@ -9886,7 +9767,8 @@ form_important_insn_automata_lists (void)\n \t      }\n \t}\n     }\n-  VLA_PTR_DELETE (automaton_states);\n+  VEC_free (state_t,heap, automaton_states);\n+\n   /* Create automata sets for the insns.  */\n   for (i = 0; i < description->decls_num; i++)\n     {\n@@ -9922,12 +9804,12 @@ expand_automata (void)\n \n   description = create_node (sizeof (struct description)\n \t\t\t     /* One entry for cycle advancing insn.  */\n-\t\t\t     + sizeof (decl_t) * VLA_PTR_LENGTH (decls));\n-  description->decls_num = VLA_PTR_LENGTH (decls);\n+\t\t\t     + sizeof (decl_t) * VEC_length (decl_t, decls));\n+  description->decls_num = VEC_length (decl_t, decls);\n   description->query_units_num = 0;\n   for (i = 0; i < description->decls_num; i++)\n     {\n-      description->decls [i] = VLA_PTR (decls, i);\n+      description->decls [i] = VEC_index (decl_t, decls, i);\n       if (description->decls [i]->mode == dm_unit\n \t  && DECL_UNIT (description->decls [i])->query_p)\n         DECL_UNIT (description->decls [i])->query_num"}]}