{"sha": "f387ff788f63c1974479644edae728047f843ec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4N2ZmNzg4ZjYzYzE5NzQ0Nzk2NDRlZGFlNzI4MDQ3Zjg0M2VjNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-07T08:35:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-07T09:14:17Z"}, "message": "tree-optimization/101555 - avoid redundant alias queries in PRE\n\nThis avoids doing redundant work during PHI translation to invalidate\nmems when translating their corresponding VUSE through the blocks\nvirtual PHI node.  All the invalidation work is already done by\nprune_clobbered_mems.\n\nThis speeds up the compile of the testcase from 275s with PRE\ntaking 91% of the compile-time down to 43s with PRE taking 16%\nof the compile-time.\n\n2021-09-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101555\n\t* tree-ssa-pre.c (translate_vuse_through_block): Do not\n\tperform an alias walk to determine the validity of the\n\tmem at the start of the block which is already guaranteed\n\tby means of prune_clobbered_mems.\n\t(phi_translate_1): Pass edge to translate_vuse_through_block.", "tree": {"sha": "4b83403ef0c883508e7d554fb39a3d1bba4c7ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b83403ef0c883508e7d554fb39a3d1bba4c7ba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f387ff788f63c1974479644edae728047f843ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f387ff788f63c1974479644edae728047f843ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f387ff788f63c1974479644edae728047f843ec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f387ff788f63c1974479644edae728047f843ec4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff72ef4e2ff8d5775470a8a01a6d9760d2c70be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff72ef4e2ff8d5775470a8a01a6d9760d2c70be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff72ef4e2ff8d5775470a8a01a6d9760d2c70be"}], "stats": {"total": 97, "additions": 37, "deletions": 60}, "files": [{"sha": "08755847f66c3044a4ea0a72f4c83c1dbaa782c9", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 37, "deletions": 60, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387ff788f63c1974479644edae728047f843ec4/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387ff788f63c1974479644edae728047f843ec4/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f387ff788f63c1974479644edae728047f843ec4", "patch": "@@ -1237,81 +1237,59 @@ fully_constant_expression (pre_expr e)\n   return e;\n }\n \n-/* Translate the VUSE backwards through phi nodes in PHIBLOCK, so that\n-   it has the value it would have in BLOCK.  Set *SAME_VALID to true\n+/* Translate the VUSE backwards through phi nodes in E->dest, so that\n+   it has the value it would have in E->src.  Set *SAME_VALID to true\n    in case the new vuse doesn't change the value id of the OPERANDS.  */\n \n static tree\n translate_vuse_through_block (vec<vn_reference_op_s> operands,\n \t\t\t      alias_set_type set, alias_set_type base_set,\n-\t\t\t      tree type, tree vuse,\n-\t\t\t      basic_block phiblock,\n-\t\t\t      basic_block block, bool *same_valid)\n+\t\t\t      tree type, tree vuse, edge e, bool *same_valid)\n {\n+  basic_block phiblock = e->dest;\n   gimple *phi = SSA_NAME_DEF_STMT (vuse);\n   ao_ref ref;\n-  edge e = NULL;\n-  bool use_oracle;\n \n   if (same_valid)\n     *same_valid = true;\n \n   if (gimple_bb (phi) != phiblock)\n     return vuse;\n \n-  unsigned int cnt = param_sccvn_max_alias_queries_per_access;\n-  use_oracle = ao_ref_init_from_vn_reference (&ref, set, base_set,\n-\t\t\t\t\t      type, operands);\n-\n-  /* Use the alias-oracle to find either the PHI node in this block,\n-     the first VUSE used in this block that is equivalent to vuse or\n-     the first VUSE which definition in this block kills the value.  */\n-  if (gimple_code (phi) == GIMPLE_PHI)\n-    e = find_edge (block, phiblock);\n-  else if (use_oracle)\n-    while (cnt > 0\n-\t   && !stmt_may_clobber_ref_p_1 (phi, &ref))\n-      {\n-\t--cnt;\n-\tvuse = gimple_vuse (phi);\n-\tphi = SSA_NAME_DEF_STMT (vuse);\n-\tif (gimple_bb (phi) != phiblock)\n-\t  return vuse;\n-\tif (gimple_code (phi) == GIMPLE_PHI)\n-\t  {\n-\t    e = find_edge (block, phiblock);\n-\t    break;\n-\t  }\n-      }\n-  else\n-    return NULL_TREE;\n-\n-  if (e)\n+  /* We have pruned expressions that are killed in PHIBLOCK via\n+     prune_clobbered_mems but we have not rewritten the VUSE to the one\n+     live at the start of the block.  If there is no virtual PHI to translate\n+     through return the VUSE live at entry.  Otherwise the VUSE to translate\n+     is the def of the virtual PHI node.  */\n+  phi = get_virtual_phi (phiblock);\n+  if (!phi)\n+    return BB_LIVE_VOP_ON_EXIT\n+\t     (get_immediate_dominator (CDI_DOMINATORS, phiblock));\n+\n+  if (same_valid\n+      && ao_ref_init_from_vn_reference (&ref, set, base_set, type, operands))\n     {\n-      if (use_oracle && same_valid)\n-\t{\n-\t  bitmap visited = NULL;\n-\t  /* Try to find a vuse that dominates this phi node by skipping\n-\t     non-clobbering statements.  */\n-\t  vuse = get_continuation_for_phi (phi, &ref, true,\n-\t\t\t\t\t   cnt, &visited, false, NULL, NULL);\n-\t  if (visited)\n-\t    BITMAP_FREE (visited);\n-\t}\n-      else\n-\tvuse = NULL_TREE;\n-      /* If we didn't find any, the value ID can't stay the same.  */\n-      if (!vuse && same_valid)\n-\t*same_valid = false;\n-      /* ??? We would like to return vuse here as this is the canonical\n-         upmost vdef that this reference is associated with.  But during\n-\t insertion of the references into the hash tables we only ever\n-\t directly insert with their direct gimple_vuse, hence returning\n-\t something else would make us not find the other expression.  */\n-      return PHI_ARG_DEF (phi, e->dest_idx);\n+      bitmap visited = NULL;\n+      /* Try to find a vuse that dominates this phi node by skipping\n+\t non-clobbering statements.  */\n+      unsigned int cnt = param_sccvn_max_alias_queries_per_access;\n+      vuse = get_continuation_for_phi (phi, &ref, true,\n+\t\t\t\t       cnt, &visited, false, NULL, NULL);\n+      if (visited)\n+\tBITMAP_FREE (visited);\n     }\n-\n-  return NULL_TREE;\n+  else\n+    vuse = NULL_TREE;\n+  /* If we didn't find any, the value ID can't stay the same.  */\n+  if (!vuse && same_valid)\n+    *same_valid = false;\n+\n+  /* ??? We would like to return vuse here as this is the canonical\n+     upmost vdef that this reference is associated with.  But during\n+     insertion of the references into the hash tables we only ever\n+     directly insert with their direct gimple_vuse, hence returning\n+     something else would make us not find the other expression.  */\n+  return PHI_ARG_DEF (phi, e->dest_idx);\n }\n \n /* Like bitmap_find_leader, but checks for the value existing in SET1 *or*\n@@ -1630,8 +1608,7 @@ phi_translate_1 (bitmap_set_t dest,\n \t    newvuse = translate_vuse_through_block (newoperands.exists ()\n \t\t\t\t\t\t    ? newoperands : operands,\n \t\t\t\t\t\t    ref->set, ref->base_set,\n-\t\t\t\t\t\t    ref->type,\n-\t\t\t\t\t\t    vuse, phiblock, pred,\n+\t\t\t\t\t\t    ref->type, vuse, e,\n \t\t\t\t\t\t    changed\n \t\t\t\t\t\t    ? NULL : &same_valid);\n \t    if (newvuse == NULL_TREE)"}]}