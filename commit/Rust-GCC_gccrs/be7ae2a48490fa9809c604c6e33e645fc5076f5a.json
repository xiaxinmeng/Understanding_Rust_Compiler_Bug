{"sha": "be7ae2a48490fa9809c604c6e33e645fc5076f5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU3YWUyYTQ4NDkwZmE5ODA5YzYwNGM2ZTMzZTY0NWZjNTA3NmY1YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-02T23:43:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-02T23:43:16Z"}, "message": "(reload_reg_used_for_inherit): New variable.\n\n(clear_reload_reg_in_use): New function.\n(allocate_reload_reg): Don't consider an inherited register as one that we\nshould share in the first pass.\nDon't mark a register in use until we are sure it will fit.\n(choose_reload_regs): Mark spill regs used for inheriting.\nWhen we decide we can no longer use a register, show it isn't being used.\n\nFrom-SVN: r3991", "tree": {"sha": "65aeb576ecc7a6dd79dddc7f9cfc4bcfd09b79ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65aeb576ecc7a6dd79dddc7f9cfc4bcfd09b79ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be7ae2a48490fa9809c604c6e33e645fc5076f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7ae2a48490fa9809c604c6e33e645fc5076f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7ae2a48490fa9809c604c6e33e645fc5076f5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7ae2a48490fa9809c604c6e33e645fc5076f5a/comments", "author": null, "committer": null, "parents": [{"sha": "8e15629f5251138b61200166bf08d13c3b7c2f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e15629f5251138b61200166bf08d13c3b7c2f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e15629f5251138b61200166bf08d13c3b7c2f59"}], "stats": {"total": 126, "additions": 105, "deletions": 21}, "files": [{"sha": "e6302c211cd45f7aac8459ce78afc07d208c2012", "filename": "gcc/reload1.c", "status": "modified", "additions": 105, "deletions": 21, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7ae2a48490fa9809c604c6e33e645fc5076f5a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7ae2a48490fa9809c604c6e33e645fc5076f5a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=be7ae2a48490fa9809c604c6e33e645fc5076f5a", "patch": "@@ -343,6 +343,8 @@ static void forget_old_reloads_1\tPROTO((rtx));\n static int reload_reg_class_lower\tPROTO((short *, short *));\n static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n+static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n+\t\t\t\t\t       enum machine_mode));\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n@@ -3828,6 +3830,10 @@ static HARD_REG_SET reload_reg_used_in_other_addr;\n /* If reg is in use as a reload reg for any sort of reload.  */\n static HARD_REG_SET reload_reg_used_at_all;\n \n+/* If reg is use as an inherited reload.  We just mark the first register\n+   in the group.  */\n+static HARD_REG_SET reload_reg_used_for_inherit;\n+\n /* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and\n    TYPE. MODE is used to indicate how many consecutive regs are\n    actually used.  */\n@@ -3883,6 +3889,57 @@ mark_reload_reg_in_use (regno, opnum, type, mode)\n     }\n }\n \n+/* Similarly, but show REGNO is no longer in use for a reload.  */\n+\n+static void\n+clear_reload_reg_in_use (regno, opnum, type, mode)\n+     int regno;\n+     int opnum;\n+     enum reload_type type;\n+     enum machine_mode mode;\n+{\n+  int nregs = HARD_REGNO_NREGS (regno, mode);\n+  int i;\n+\n+  for (i = regno; i < nregs + regno; i++)\n+    {\n+      switch (type)\n+\t{\n+\tcase RELOAD_OTHER:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used, i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_INPUT_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_OPERAND_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_OTHER_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_INPUT:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_input[opnum], i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_OUTPUT:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_output[opnum], i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_INSN:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_insn, i);\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* 1 if reg REGNO is free as a reload reg for a reload of the sort\n    specified by OPNUM and TYPE.  */\n \n@@ -4300,9 +4357,14 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \t\t\t\t reload_when_needed[r])\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], spill_regs[i])\n \t      && HARD_REGNO_MODE_OK (spill_regs[i], reload_mode[r])\n-\t      /* Look first for regs to share, then for unshared.  */\n-\t      && (pass || TEST_HARD_REG_BIT (reload_reg_used_at_all,\n-\t\t\t\t\t     spill_regs[i])))\n+\t      /* Look first for regs to share, then for unshared.  But\n+\t\t don't share regs used for inherited reloads; they are\n+\t\t the ones we want to preserve.  */\n+\t      && (pass\n+\t\t  || (TEST_HARD_REG_BIT (reload_reg_used_at_all,\n+\t\t\t\t\t spill_regs[i])\n+\t\t      && ! TEST_HARD_REG_BIT (reload_reg_used_for_inherit,\n+\t\t\t\t\t      spill_regs[i]))))\n \t    {\n \t      int nr = HARD_REGNO_NREGS (spill_regs[i], reload_mode[r]);\n \t      /* Avoid the problem where spilling a GENERAL_OR_FP_REG\n@@ -4353,19 +4415,15 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n       goto failure;\n     }\n \n-  last_spill_reg = i;\n-\n-  /* Mark as in use for this insn the reload regs we use for this.  */\n-  mark_reload_reg_in_use (spill_regs[i], reload_opnum[r],\n-\t\t\t  reload_when_needed[r], reload_mode[r]);\n+  /* I is the index in SPILL_REG_RTX of the reload register we are to\n+     allocate.  Get an rtx for it and find its register number.  */\n \n   new = spill_reg_rtx[i];\n \n   if (new == 0 || GET_MODE (new) != reload_mode[r])\n-    spill_reg_rtx[i] = new = gen_rtx (REG, reload_mode[r], spill_regs[i]);\n-\n-  reload_reg_rtx[r] = new;\n-  reload_spill_index[r] = i;\n+    spill_reg_rtx[i] = new\n+      = gen_rtx (REG, reload_mode[r], spill_regs[i]);\n+\t    \n   regno = true_regnum (new);\n \n   /* Detect when the reload reg can't hold the reload mode.\n@@ -4385,8 +4443,19 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \t     && ! HARD_REGNO_MODE_OK (regno, test_mode)))\n \tif (! (reload_out[r] != 0\n \t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (reload_out[r]))))\n-\t  /* The reg is OK.  */\n-\t  return 1;\n+\t  {\n+\t    /* The reg is OK.  */\n+\t    last_spill_reg = i;\n+\n+\t    /* Mark as in use for this insn the reload regs we use\n+\t       for this.  */\n+\t    mark_reload_reg_in_use (spill_regs[i], reload_opnum[r],\n+\t\t\t\t    reload_when_needed[r], reload_mode[r]);\n+\n+\t    reload_reg_rtx[r] = new;\n+\t    reload_spill_index[r] = i;\n+\t    return 1;\n+\t  }\n     }\n \n   /* The reg is not OK.  */\n@@ -4620,6 +4689,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t Then make a second pass over the reloads to allocate any reloads\n \t that haven't been given registers yet.  */\n \n+      CLEAR_HARD_REG_SET (reload_reg_used_for_inherit);\n+\n       for (j = 0; j < n_reloads; j++)\n \t{\n \t  register int r = reload_order[j];\n@@ -4734,6 +4805,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t  reload_inherited[r] = 1;\n \t\t\t  reload_inheritance_insn[r] = reg_reloaded_insn[i];\n \t\t\t  reload_spill_index[r] = i;\n+\t\t\t  SET_HARD_REG_BIT (reload_reg_used_for_inherit,\n+\t\t\t\t\t    spill_regs[i]);\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -4820,9 +4893,12 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t     mark the spill reg as in use for this insn.  */\n \t\t  i = spill_reg_order[regno];\n \t\t  if (i >= 0)\n-\t\t    mark_reload_reg_in_use (regno, reload_opnum[r],\n-\t\t\t\t\t    reload_when_needed[r],\n-\t\t\t\t\t    reload_mode[r]);\n+\t\t    {\n+\t\t      mark_reload_reg_in_use (regno, reload_opnum[r],\n+\t\t\t\t\t      reload_when_needed[r],\n+\t\t\t\t\t      reload_mode[r]);\n+\t\t      SET_HARD_REG_BIT (reload_reg_used_for_inherit, regno);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -4961,10 +5037,18 @@ choose_reload_regs (insn, avoid_return_reg)\n      optional and not inherited, clear reload_reg_rtx so other\n      routines (such as subst_reloads) don't get confused.  */\n   for (j = 0; j < n_reloads; j++)\n-    if ((reload_optional[j] && ! reload_inherited[j])\n-\t|| (reload_in[j] == 0 && reload_out[j] == 0\n-\t    && ! reload_secondary_p[j]))\n-      reload_reg_rtx[j] = 0;\n+    if (reload_reg_rtx[j] != 0\n+\t&& ((reload_optional[j] && ! reload_inherited[j])\n+\t    || (reload_in[j] == 0 && reload_out[j] == 0\n+\t\t&& ! reload_secondary_p[j])))\n+      {\n+\tint regno = true_regnum (reload_reg_rtx[j]);\n+\n+\tif (spill_reg_order[regno] >= 0)\n+\t  clear_reload_reg_in_use (regno, reload_opnum[j],\n+\t\t\t\t   reload_when_needed[j], reload_mode[j]);\n+\treload_reg_rtx[j] = 0;\n+      }\n \n   /* Record which pseudos and which spill regs have output reloads.  */\n   for (j = 0; j < n_reloads; j++)"}]}