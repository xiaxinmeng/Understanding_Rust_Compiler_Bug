{"sha": "efe05dfc95b60b57abb6c57055982e25dc09c91e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlMDVkZmM5NWI2MGI1N2FiYjZjNTcwNTU5ODJlMjVkYzA5YzkxZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:27:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:27:16Z"}, "message": "[multiple changes]\n\n2011-08-05  Sergey Rybin  <rybin@adacore.com>\n\n\t* tree_io.ads: Update ASIS_Version_Number because of the change of the\n\torder of calling Tree_Write/Tree_Read routines made for aspects.\n\n2011-08-05  Bob Duff  <duff@adacore.com>\n\n\t* a-fihema.adb (Finalize): Fix race condition.\n\nFrom-SVN: r177445", "tree": {"sha": "69e7b440cee9f2941de4b5697c615e4689436ac6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69e7b440cee9f2941de4b5697c615e4689436ac6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efe05dfc95b60b57abb6c57055982e25dc09c91e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe05dfc95b60b57abb6c57055982e25dc09c91e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe05dfc95b60b57abb6c57055982e25dc09c91e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe05dfc95b60b57abb6c57055982e25dc09c91e/comments", "author": null, "committer": null, "parents": [{"sha": "5f9cdefe6b406caec538bb764c4da78751037bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9cdefe6b406caec538bb764c4da78751037bed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9cdefe6b406caec538bb764c4da78751037bed"}], "stats": {"total": 183, "additions": 128, "deletions": 55}, "files": [{"sha": "7b8561bff94a34963509fa0c1be32fa2979003f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=efe05dfc95b60b57abb6c57055982e25dc09c91e", "patch": "@@ -1,3 +1,12 @@\n+2011-08-05  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* tree_io.ads: Update ASIS_Version_Number because of the change of the\n+\torder of calling Tree_Write/Tree_Read routines made for aspects.\n+\n+2011-08-05  Bob Duff  <duff@adacore.com>\n+\n+\t* a-fihema.adb (Finalize): Fix race condition.\n+\n 2011-08-05  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch12.adb (Analyze_Package_Instantiation,"}, {"sha": "1b8cd78a2425a6102fb851a9dd52e633582951dd", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 118, "deletions": 54, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=efe05dfc95b60b57abb6c57055982e25dc09c91e", "patch": "@@ -35,12 +35,16 @@ with Ada.Unchecked_Conversion;\n with System;                  use System;\n with System.Address_Image;\n with System.IO;               use System.IO;\n+with System.OS_Lib;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n with System.Storage_Pools;    use System.Storage_Pools;\n \n package body Ada.Finalization.Heap_Management is\n \n+   Debug : constant Boolean := False;\n+   --  True for debugging printouts.\n+\n    Header_Size : constant Storage_Count  := Node'Size / Storage_Unit;\n    --  Size of the header in bytes. Added to Storage_Size requested by\n    --  Allocate/Deallocate to determine the Storage_Size passed to the\n@@ -59,6 +63,42 @@ package body Ada.Finalization.Heap_Management is\n    procedure Detach (N : Node_Ptr);\n    --  Unhook a node from an arbitrary list\n \n+   procedure Fin_Assert (Condition : Boolean; Message : String);\n+   --  Asserts that the condition is True. Used instead of pragma Assert in\n+   --  delicate places where raising an exception would cause re-invocation of\n+   --  finalization. Instead of raising an exception, aborts the whole\n+   --  process.\n+\n+   function Is_Empty (Objects : Node_Ptr) return Boolean;\n+   --  True if the Objects list is empty.\n+\n+   ----------------\n+   -- Fin_Assert --\n+   ----------------\n+\n+   procedure Fin_Assert (Condition : Boolean; Message : String) is\n+\n+      procedure Fail;\n+      --  Use a separate procedure to make it easy to set a breakpoint here.\n+\n+      ----------\n+      -- Fail --\n+      ----------\n+\n+      procedure Fail is\n+      begin\n+         Put_Line (\"Heap_Management: Fin_Assert failed: \" & Message);\n+         OS_Lib.OS_Abort;\n+      end Fail;\n+\n+   --  Start of processing for Fin_Assert\n+\n+   begin\n+      if not Condition then\n+         Fail;\n+      end if;\n+   end Fin_Assert;\n+\n    ---------------------------\n    -- Add_Offset_To_Address --\n    ---------------------------\n@@ -221,40 +261,24 @@ package body Ada.Finalization.Heap_Management is\n    ------------\n \n    procedure Detach (N : Node_Ptr) is\n+   begin\n+      pragma Debug (Fin_Assert (N /= null, \"Detach null\"));\n \n-      --  N must be attached to some list\n-\n-      pragma Assert (N.Next /= null and then N.Prev /= null);\n+      Lock_Task.all;\n \n-      procedure Null_Out_Pointers;\n-      --  Set Next/Prev pointer of N to null (for debugging)\n+      if N.Next = null then\n+         pragma Assert (N.Prev = null);\n \n-      ----------\n-      -- Head --\n-      ----------\n-\n-      procedure Null_Out_Pointers is\n-      begin\n+      else\n+         N.Prev.Next := N.Next;\n+         N.Next.Prev := N.Prev;\n          N.Next := null;\n          N.Prev := null;\n-      end Null_Out_Pointers;\n-\n-   --  Start of processing for Detach\n-\n-   begin\n-      Lock_Task.all;\n-\n-      N.Prev.Next := N.Next;\n-      N.Next.Prev := N.Prev;\n+      end if;\n \n       Unlock_Task.all;\n       --  Note: no need to unlock in case of exceptions; the above code cannot\n       --  raise any.\n-\n-      --  No need to null out the pointers, except that it makes pcol easier to\n-      --  understand.\n-\n-      pragma Debug (Null_Out_Pointers);\n    end Detach;\n \n    --------------\n@@ -264,54 +288,81 @@ package body Ada.Finalization.Heap_Management is\n    overriding procedure Finalize\n      (Collection : in out Finalization_Collection)\n    is\n-      Curr_Ptr : Node_Ptr := Collection.Objects.Next; -- skip dummy head\n       Ex_Occur : Exception_Occurrence;\n       Raised   : Boolean := False;\n \n-   --  Start of processing for Finalize\n-\n    begin\n+      if Debug then\n+         Put_Line (\"-->Heap_Management: \");\n+         pcol (Collection);\n+      end if;\n+\n       --  Set Finalization_Started to prevent any allocations of objects with\n       --  controlled parts during finalization. The associated access type is\n       --  about to go out of scope; Finalization_Started is never again\n       --  modified.\n \n+      if Collection.Finalization_Started then\n+         --  ???Needed for shared libraries.\n+         return;\n+      end if;\n+      pragma Debug (Fin_Assert (not Collection.Finalization_Started,\n+                                \"Finalize: already started\"));\n       Collection.Finalization_Started := True;\n \n-      --  Go through the Objects list, and finalize each one. There is no need\n-      --  to detach items from the list, because the whole collection is about\n-      --  to go away.\n-\n-      while Curr_Ptr /= Collection.Objects'Unchecked_Access loop\n+      --  For each object in the Objects list, detach it, and finalize it. Note\n+      --  that other tasks can be doing Unchecked_Deallocations at the same\n+      --  time, so we need to beware of race conditions.\n \n-         --  ??? Kludge: Don't do anything until the proper place to set\n-         --  primitive Finalize_Address has been determined.\n+      while not Is_Empty (Collection.Objects'Unchecked_Access) loop\n \n-         if Collection.Finalize_Address /= null then\n-            declare\n-               Object_Address : constant Address :=\n-                                  Curr_Ptr.all'Address + Header_Offset;\n-               --  Get address of object from address of header\n-\n-            begin\n-               Collection.Finalize_Address (Object_Address);\n-\n-            exception\n-               when Fin_Except : others =>\n-                  if not Raised then\n-                     Raised := True;\n-                     Save_Occurrence (Ex_Occur, Fin_Except);\n-                  end if;\n-            end;\n-         end if;\n-\n-         Curr_Ptr := Curr_Ptr.Next;\n+         declare\n+            Node : constant Node_Ptr := Collection.Objects.Next;\n+         begin\n+            --  Remove the current node from the list first, in case some other\n+            --  task is simultaneously doing Unchecked_Deallocation on this\n+            --  object. Detach does Lock_Task. Note that we can't Lock_Task\n+            --  during Finalize_Address, because finalization can do pretty\n+            --  much anything.\n+\n+            Detach (Node);\n+\n+            --  ??? Kludge: Don't do anything until the proper place to set\n+            --  primitive Finalize_Address has been determined.\n+\n+            if Collection.Finalize_Address /= null then\n+               declare\n+                  Object_Address : constant Address :=\n+                                     Node.all'Address + Header_Offset;\n+                  --  Get address of object from address of header\n+\n+               begin\n+                  Collection.Finalize_Address (Object_Address);\n+\n+               exception\n+                  when Fin_Except : others =>\n+                     if not Raised then\n+                        Raised := True;\n+                        Save_Occurrence (Ex_Occur, Fin_Except);\n+                     end if;\n+               end;\n+            end if;\n+         end;\n       end loop;\n \n+      if Debug then\n+         Put_Line (\"<--Heap_Management: \");\n+         pcol (Collection);\n+      end if;\n+\n       --  If the finalization of a particular node raised an exception, reraise\n       --  it after the remainder of the list has been finalized.\n \n       if Raised then\n+         if Debug then\n+            Put_Line (\"Heap_Management: reraised\");\n+         end if;\n+\n          Reraise_Occurrence (Ex_Occur);\n       end if;\n    end Finalize;\n@@ -328,8 +379,21 @@ package body Ada.Finalization.Heap_Management is\n \n       Collection.Objects.Next := Collection.Objects'Unchecked_Access;\n       Collection.Objects.Prev := Collection.Objects'Unchecked_Access;\n+      pragma Assert (Is_Empty (Collection.Objects'Unchecked_Access));\n    end Initialize;\n \n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Objects : Node_Ptr) return Boolean is\n+   begin\n+      pragma Debug\n+        (Fin_Assert ((Objects.Next = Objects) = (Objects.Prev = Objects),\n+                     \"Is_Empty\"));\n+      return Objects.Next = Objects;\n+   end Is_Empty;\n+\n    ----------\n    -- pcol --\n    ----------"}, {"sha": "bdc6f5d1b023185154d7abb6b2bc20daba1fd5a4", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe05dfc95b60b57abb6c57055982e25dc09c91e/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=efe05dfc95b60b57abb6c57055982e25dc09c91e", "patch": "@@ -47,7 +47,7 @@ package Tree_IO is\n    Tree_Format_Error : exception;\n    --  Raised if a format error is detected in the input file\n \n-   ASIS_Version_Number : constant := 25;\n+   ASIS_Version_Number : constant := 26;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees and an ASIS application that is reading the\n    --  trees. It must be incremented whenever a change is made to the tree"}]}