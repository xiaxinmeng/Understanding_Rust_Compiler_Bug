{"sha": "a84dbde7fc88361e23609be162ba138f96ef18e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg0ZGJkZTdmYzg4MzYxZTIzNjA5YmUxNjJiYTEzOGY5NmVmMThlNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-27T21:34:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-27T21:34:24Z"}, "message": "reflect: Implement MakeFunc for 386.\n\nFrom-SVN: r202993", "tree": {"sha": "5739741126da531c10676b0207ba687b63462abc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5739741126da531c10676b0207ba687b63462abc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a84dbde7fc88361e23609be162ba138f96ef18e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84dbde7fc88361e23609be162ba138f96ef18e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84dbde7fc88361e23609be162ba138f96ef18e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84dbde7fc88361e23609be162ba138f96ef18e4/comments", "author": null, "committer": null, "parents": [{"sha": "ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64"}], "stats": {"total": 269, "additions": 264, "deletions": 5}, "files": [{"sha": "c81c66cb07f18e9966f16898b4d764d2bc735e92", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -901,10 +901,17 @@ go_reflect_makefunc_file = \\\n go_reflect_makefunc_s_file = \\\n \tgo/reflect/makefunc_amd64.S\n else\n+if LIBGO_IS_386\n+go_reflect_makefunc_file = \\\n+\tgo/reflect/makefuncgo_386.go\n+go_reflect_makefunc_s_file = \\\n+\tgo/reflect/makefunc_386.S\n+else\n go_reflect_makefunc_file =\n go_reflect_makefunc_s_file = \\\n \tgo/reflect/makefunc_dummy.c\n endif\n+endif\n \n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\"}, {"sha": "9e31e8ca28ec9806764905a06f0299ff59ff6ba7", "filename": "libgo/Makefile.in", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -1087,12 +1087,18 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n-@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n+@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n+@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_386.go\n+\n @LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_file = \\\n @LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefuncgo_amd64.go\n \n-@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n+\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_386.S\n \n @LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_s_file = \\\n @LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefunc_amd64.S"}, {"sha": "1fed58570f27219466c870fb871ff1c092416263", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -1432,7 +1432,7 @@ func TestFunc(t *testing.T) {\n \n func TestMakeFunc(t *testing.T) {\n \tswitch runtime.GOARCH {\n-\tcase \"amd64\":\n+\tcase \"amd64\", \"386\":\n \tdefault:\n \t\tt.Skip(\"MakeFunc not implemented for \" + runtime.GOARCH)\n \t}"}, {"sha": "3e0a79258e6b7698d6c741532397740127599e37", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -47,7 +47,7 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \t}\n \n \tswitch runtime.GOARCH {\n-\tcase \"amd64\":\n+\tcase \"amd64\", \"386\":\n \tdefault:\n \t\tpanic(\"reflect.MakeFunc not implemented for \" + runtime.GOARCH)\n \t}"}, {"sha": "f2f2fbe1a95b1cc6a18ba64326d1e9860005609a", "filename": "libgo/go/reflect/makefunc_386.S", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefunc_386.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefunc_386.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_386.S?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -0,0 +1,111 @@\n+# Copyright 2013 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# MakeFunc 386 assembly code.\n+\n+\t.global reflect.makeFuncStub\n+\n+#ifdef __ELF__\n+\t.type reflect.makeFuncStub,@function\n+#endif\n+\n+reflect.makeFuncStub:\n+\t.cfi_startproc\n+\n+\t# Go does not provide any equivalent to the regparm function\n+\t# attribute, so on Go we do not need to worry about passing\n+\t# parameters in registers.  We just pass a pointer to the\n+\t# arguments on the stack.\n+\t#\n+\t# We do need to pick up the return values, though, so we pass\n+\t# a pointer to a struct that looks like this.\n+\t# struct {\n+\t#   esp uint32\t\t// 0x0\n+\t#   eax uint32\t\t// 0x4\n+\t#   st0 uint64\t\t// 0x8\n+\t# }\n+\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset %ebp, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register %ebp\n+\n+\tpushl\t%ebx\t\t# In case this is PIC.\n+\n+\tsubl\t$36, %esp\t# Enough for args and to align stack.\n+\t.cfi_offset %ebx, -12\n+\n+#ifdef __PIC__\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+#endif\n+\n+\tleal\t8(%ebp), %eax\t# Set esp field in struct.\n+\tmovl\t%eax, -24(%ebp)\n+\n+#ifdef __PIC__\n+\tcall\t__go_get_closure@PLT\n+#else\n+\tcall\t__go_get_closure\n+#endif\n+\n+\tmovl\t%eax, 4(%esp)\n+\n+\tleal\t-24(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\n+#ifdef __PIC__\n+\tcall\treflect.MakeFuncStubGo@PLT\n+#else\n+\tcall\treflect.MakeFuncStubGo\n+#endif\n+\n+\t# Set return registers.\n+\n+\tmovl\t-20(%ebp), %eax\n+\tfldl\t-16(%ebp)\n+\n+#ifdef __SSE2__\n+\t# In case we are compiling with -msseregparm.  This won't work\n+\t# correctly if only SSE1 is supported, but that seems unlikely.\n+\tmovsd\t-16(%ebp), %xmm0\n+#endif\n+\n+\taddl\t$36, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore %ebx\n+\tpopl\t%ebp\n+\t.cfi_restore %ebp\n+\t.cfi_def_cfa %esp, 4\n+\n+\tret\n+\t.cfi_endproc\n+\n+#ifdef __ELF__\n+\t.size\treflect.makeFuncStub, . - reflect.makeFuncStub\n+#endif\n+\n+#ifdef __PIC__\n+\t.section\t.text.__x86.get_pc_thunk.bx,\"axG\",@progbits,__x86.get_pc_thunk.bx,comdat\n+\t.globl\t__x86.get_pc_thunk.bx\n+\t.hidden\t__x86.get_pc_thunk.bx\n+#ifdef __ELF__\n+\t.type\t__x86.get_pc_thunk.bx, @function\n+#endif\n+__x86.get_pc_thunk.bx:\n+\t.cfi_startproc\n+\tmovl\t(%esp), %ebx\n+\tret\n+\t.cfi_endproc\n+#ifdef __ELF__\n+\t.size\t__x86.get_pc_thunk.bx, . - __x86.get_pc_thunk.bx\n+#endif\n+#endif\n+\n+#ifdef __ELF__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.section\t.note.GNU-no-split-stack,\"\",@progbits\n+#endif"}, {"sha": "0fac1f488a46765b636ee5736f27ba95986a3726", "filename": "libgo/go/reflect/makefuncgo_386.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84dbde7fc88361e23609be162ba138f96ef18e4/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go?ref=a84dbde7fc88361e23609be162ba138f96ef18e4", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// MakeFunc 386 implementation.\n+\n+package reflect\n+\n+import \"unsafe\"\n+\n+// The assembler stub will pass a pointer to this structure.  We\n+// assume that no parameters are passed in registers--that is, we do\n+// not support the -mregparm option.  On return we will set the\n+// registers that might hold result values.\n+type i386Regs struct {\n+\tesp uint32\n+\teax uint32 // Value to return in %eax.\n+\tst0 uint64 // Value to return in %st(0).\n+}\n+\n+// MakeFuncStubGo implements the 386 calling convention for MakeFunc.\n+// This should not be called.  It is exported so that assembly code\n+// can call it.\n+\n+func MakeFuncStubGo(regs *i386Regs, c *makeFuncImpl) {\n+\tftyp := c.typ\n+\n+\t// See if the result requires a struct.  If it does, the first\n+\t// parameter is a pointer to the struct.\n+\tretStruct := false\n+\tretEmpty := false\n+\tswitch len(ftyp.out) {\n+\tcase 0:\n+\t\tretEmpty = true\n+\tcase 1:\n+\t\tif ftyp.out[0].size == 0 {\n+\t\t\tretEmpty = true\n+\t\t} else {\n+\t\t\tswitch ftyp.out[0].Kind() {\n+\t\t\tcase Complex64, Complex128, Array, Interface, Slice, String, Struct:\n+\t\t\t\tretStruct = true\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\tsize := uintptr(0)\n+\t\tfor _, typ := range ftyp.out {\n+\t\t\tsize += typ.size\n+\t\t}\n+\t\tif size == 0 {\n+\t\t\tretEmpty = true\n+\t\t} else {\n+\t\t\tretStruct = true\n+\t\t}\n+\t}\n+\n+\tin := make([]Value, 0, len(ftyp.in))\n+\tap := uintptr(regs.esp)\n+\n+\tvar retPtr unsafe.Pointer\n+\tif retStruct {\n+\t\tretPtr = *(*unsafe.Pointer)(unsafe.Pointer(ap))\n+\t\tap += ptrSize\n+\t}\n+\n+\tfor _, rt := range ftyp.in {\n+\t\tap = align(ap, ptrSize)\n+\n+\t\t// We have to copy the argument onto the heap in case\n+\t\t// the function hangs on the reflect.Value we pass it.\n+\t\tp := unsafe_New(rt)\n+\t\tmemmove(p, unsafe.Pointer(ap), rt.size)\n+\n+\t\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\t\tin = append(in, v)\n+\t\tap += rt.size\n+\t}\n+\n+\t// Call the real function.\n+\n+\tout := c.fn(in)\n+\n+\tif len(out) != len(ftyp.out) {\n+\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n+\t}\n+\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\tif v.typ != typ {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n+\t\t\t\t\" returned wrong type: have \" +\n+\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n+\t\t}\n+\t\tif v.flag&flagRO != 0 {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n+\t\t\t\t\" returned value obtained from unexported field\")\n+\t\t}\n+\t}\n+\n+\tif retEmpty {\n+\t\treturn\n+\t}\n+\n+\tif retStruct {\n+\t\toff := uintptr(0)\n+\t\tfor i, typ := range ftyp.out {\n+\t\t\tv := out[i]\n+\t\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\t\taddr := unsafe.Pointer(uintptr(retPtr) + off)\n+\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\t\tstoreIword(addr, iword(v.val), typ.size)\n+\t\t\t} else {\n+\t\t\t\tmemmove(addr, v.val, typ.size)\n+\t\t\t}\n+\t\t\toff += typ.size\n+\t\t}\n+\t\tregs.eax = uint32(uintptr(retPtr))\n+\t\treturn\n+\t}\n+\n+\tif len(ftyp.out) != 1 {\n+\t\tpanic(\"inconsistency\")\n+\t}\n+\n+\tv := out[0]\n+\tw := v.iword()\n+\tif v.Kind() != Ptr && v.Kind() != UnsafePointer {\n+\t\tw = loadIword(unsafe.Pointer(w), v.typ.size)\n+\t}\n+\tswitch v.Kind() {\n+\tcase Float32, Float64:\n+\t\tregs.st0 = uint64(uintptr(w))\n+\tdefault:\n+\t\tregs.eax = uint32(uintptr(w))\n+\t}\n+}"}]}