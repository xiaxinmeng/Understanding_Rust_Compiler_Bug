{"sha": "fc60a41612bad379060969b6ed3a78eb160aae8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2MGE0MTYxMmJhZDM3OTA2MDk2OWI2ZWQzYTc4ZWIxNjBhYWU4YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:53:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:53:52Z"}, "message": "poly_int: extract_bit_field bitrange\n\nSimilar to the previous store_bit_field patch, but for extractions\nrather than insertions.  The patch splits out the extraction-as-subreg\nhandling into a new function (extract_bit_field_as_subreg), both for\nease of writing and because a later patch will add another caller.\n\nThe simplify_gen_subreg overload is temporary; it goes away\nin a later patch.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (simplify_gen_subreg): Add a temporary overload that\n\taccepts poly_uint64 offsets.\n\t* expmed.h (extract_bit_field): Take bitsize and bitnum as\n\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.\n\t* expmed.c (lowpart_bit_field_p): Likewise.\n\t(extract_bit_field_as_subreg): New function, split out from...\n\t(extract_bit_field_1): ...here.  Take bitsize and bitnum as\n\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.  For vector\n\textractions, check that BITSIZE matches the size of the extracted\n\tvalue and that BITNUM is an exact multiple of that size.\n\tIf all else fails, try forcing the value into memory if\n\tBITNUM is variable, and adjusting the address so that the\n\toffset is constant.  Split the part that can only handle constant\n\tbitsize and bitnum out into...\n\t(extract_integral_bit_field): ...this new function.\n\t(extract_bit_field): Take bitsize and bitnum as poly_uint64s\n\trather than unsigned HOST_WIDE_INTs.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255878", "tree": {"sha": "c5ad67c91160778f85d53cd9d8e5203871279310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5ad67c91160778f85d53cd9d8e5203871279310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc60a41612bad379060969b6ed3a78eb160aae8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc60a41612bad379060969b6ed3a78eb160aae8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc60a41612bad379060969b6ed3a78eb160aae8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc60a41612bad379060969b6ed3a78eb160aae8a/comments", "author": null, "committer": null, "parents": [{"sha": "2d7b38df8e50a2c29bbc778a34c6ab6349178994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7b38df8e50a2c29bbc778a34c6ab6349178994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7b38df8e50a2c29bbc778a34c6ab6349178994"}], "stats": {"total": 177, "additions": 130, "deletions": 47}, "files": [{"sha": "0aa14a20465937c18c99ae996b1dac5ffd62fa43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc60a41612bad379060969b6ed3a78eb160aae8a", "patch": "@@ -1,3 +1,25 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (simplify_gen_subreg): Add a temporary overload that\n+\taccepts poly_uint64 offsets.\n+\t* expmed.h (extract_bit_field): Take bitsize and bitnum as\n+\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.\n+\t* expmed.c (lowpart_bit_field_p): Likewise.\n+\t(extract_bit_field_as_subreg): New function, split out from...\n+\t(extract_bit_field_1): ...here.  Take bitsize and bitnum as\n+\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.  For vector\n+\textractions, check that BITSIZE matches the size of the extracted\n+\tvalue and that BITNUM is an exact multiple of that size.\n+\tIf all else fails, try forcing the value into memory if\n+\tBITNUM is variable, and adjusting the address so that the\n+\toffset is constant.  Split the part that can only handle constant\n+\tbitsize and bitnum out into...\n+\t(extract_integral_bit_field): ...this new function.\n+\t(extract_bit_field): Take bitsize and bitnum as poly_uint64s\n+\trather than unsigned HOST_WIDE_INTs.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3b75be41d9ee72a747aa57f98162fda03cf822aa", "filename": "gcc/expmed.c", "status": "modified", "additions": 101, "deletions": 45, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fc60a41612bad379060969b6ed3a78eb160aae8a", "patch": "@@ -69,6 +69,10 @@ static void store_split_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   rtx, scalar_int_mode, bool);\n+static rtx extract_integral_bit_field (rtx, opt_scalar_int_mode,\n+\t\t\t\t       unsigned HOST_WIDE_INT,\n+\t\t\t\t       unsigned HOST_WIDE_INT, int, rtx,\n+\t\t\t\t       machine_mode, machine_mode, bool, bool);\n static rtx extract_fixed_bit_field (machine_mode, rtx, opt_scalar_int_mode,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n@@ -510,17 +514,17 @@ adjust_bit_field_mem_for_reg (enum extraction_pattern pattern,\n    offset is then BITNUM / BITS_PER_UNIT.  */\n \n static bool\n-lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n-\t\t     unsigned HOST_WIDE_INT bitsize,\n+lowpart_bit_field_p (poly_uint64 bitnum, poly_uint64 bitsize,\n \t\t     machine_mode struct_mode)\n {\n-  unsigned HOST_WIDE_INT regsize = REGMODE_NATURAL_SIZE (struct_mode);\n+  poly_uint64 regsize = REGMODE_NATURAL_SIZE (struct_mode);\n   if (BYTES_BIG_ENDIAN)\n-    return (bitnum % BITS_PER_UNIT == 0\n-\t    && (bitnum + bitsize == GET_MODE_BITSIZE (struct_mode)\n-\t\t|| (bitnum + bitsize) % (regsize * BITS_PER_UNIT) == 0));\n+    return (multiple_p (bitnum, BITS_PER_UNIT)\n+\t    && (known_eq (bitnum + bitsize, GET_MODE_BITSIZE (struct_mode))\n+\t\t|| multiple_p (bitnum + bitsize,\n+\t\t\t       regsize * BITS_PER_UNIT)));\n   else\n-    return bitnum % (regsize * BITS_PER_UNIT) == 0;\n+    return multiple_p (bitnum, regsize * BITS_PER_UNIT);\n }\n \n /* Return true if -fstrict-volatile-bitfields applies to an access of OP0\n@@ -1575,16 +1579,33 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n   return NULL_RTX;\n }\n \n+/* See whether it would be valid to extract the part of OP0 described\n+   by BITNUM and BITSIZE into a value of mode MODE using a subreg\n+   operation.  Return the subreg if so, otherwise return null.  */\n+\n+static rtx\n+extract_bit_field_as_subreg (machine_mode mode, rtx op0,\n+\t\t\t     poly_uint64 bitsize, poly_uint64 bitnum)\n+{\n+  poly_uint64 bytenum;\n+  if (multiple_p (bitnum, BITS_PER_UNIT, &bytenum)\n+      && known_eq (bitsize, GET_MODE_BITSIZE (mode))\n+      && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n+      && TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op0)))\n+    return simplify_gen_subreg (mode, op0, GET_MODE (op0), bytenum);\n+  return NULL_RTX;\n+}\n+\n /* A subroutine of extract_bit_field, with the same arguments.\n    If FALLBACK_P is true, fall back to extract_fixed_bit_field\n    if we can find no other means of implementing the operation.\n    if FALLBACK_P is false, return NULL instead.  */\n \n static rtx\n-extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t     machine_mode mode, machine_mode tmode,\n-\t\t     bool reverse, bool fallback_p, rtx *alt_rtl)\n+extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n+\t\t     int unsignedp, rtx target, machine_mode mode,\n+\t\t     machine_mode tmode, bool reverse, bool fallback_p,\n+\t\t     rtx *alt_rtl)\n {\n   rtx op0 = str_rtx;\n   machine_mode mode1;\n@@ -1601,13 +1622,13 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* If we have an out-of-bounds access to a register, just return an\n      uninitialized register of the required mode.  This can occur if the\n      source code contains an out-of-bounds access to a small array.  */\n-  if (REG_P (op0) && bitnum >= GET_MODE_BITSIZE (GET_MODE (op0)))\n+  if (REG_P (op0) && known_ge (bitnum, GET_MODE_BITSIZE (GET_MODE (op0))))\n     return gen_reg_rtx (tmode);\n \n   if (REG_P (op0)\n       && mode == GET_MODE (op0)\n-      && bitnum == 0\n-      && bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n+      && known_eq (bitnum, 0U)\n+      && known_eq (bitsize, GET_MODE_BITSIZE (GET_MODE (op0))))\n     {\n       if (reverse)\n \top0 = flip_storage_order (mode, op0);\n@@ -1619,6 +1640,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n       && VECTOR_MODE_P (tmode)\n+      && known_eq (bitsize, GET_MODE_SIZE (tmode))\n       && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (tmode))\n     {\n       machine_mode new_mode = GET_MODE (op0);\n@@ -1634,18 +1656,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      || !targetm.vector_mode_supported_p (new_mode))\n \t    new_mode = VOIDmode;\n \t}\n+      poly_uint64 pos;\n       if (new_mode != VOIDmode\n \t  && (convert_optab_handler (vec_extract_optab, new_mode, tmode)\n \t      != CODE_FOR_nothing)\n-\t  && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (tmode)\n-\t      == bitnum / GET_MODE_BITSIZE (tmode)))\n+\t  && multiple_p (bitnum, GET_MODE_BITSIZE (tmode), &pos))\n \t{\n \t  struct expand_operand ops[3];\n \t  machine_mode outermode = new_mode;\n \t  machine_mode innermode = tmode;\n \t  enum insn_code icode\n \t    = convert_optab_handler (vec_extract_optab, outermode, innermode);\n-\t  unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n \n \t  if (new_mode != GET_MODE (op0))\n \t    op0 = gen_lowpart (new_mode, op0);\n@@ -1698,17 +1719,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   machine_mode outermode = GET_MODE (op0);\n   scalar_mode innermode = GET_MODE_INNER (outermode);\n+  poly_uint64 pos;\n   if (VECTOR_MODE_P (outermode)\n       && !MEM_P (op0)\n       && (convert_optab_handler (vec_extract_optab, outermode, innermode)\n \t  != CODE_FOR_nothing)\n-      && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (innermode)\n-\t  == bitnum / GET_MODE_BITSIZE (innermode)))\n+      && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n+      && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n     {\n       struct expand_operand ops[3];\n       enum insn_code icode\n \t= convert_optab_handler (vec_extract_optab, outermode, innermode);\n-      unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n \n       create_output_operand (&ops[0], target, innermode);\n       ops[0].target = 1;\n@@ -1766,14 +1787,9 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* Extraction of a full MODE1 value can be done with a subreg as long\n      as the least significant bit of the value is the least significant\n      bit of either OP0 or a word of OP0.  */\n-  if (!MEM_P (op0)\n-      && !reverse\n-      && lowpart_bit_field_p (bitnum, bitsize, op0_mode.require ())\n-      && bitsize == GET_MODE_BITSIZE (mode1)\n-      && TRULY_NOOP_TRUNCATION_MODES_P (mode1, op0_mode.require ()))\n+  if (!MEM_P (op0) && !reverse)\n     {\n-      rtx sub = simplify_gen_subreg (mode1, op0, op0_mode.require (),\n-\t\t\t\t     bitnum / BITS_PER_UNIT);\n+      rtx sub = extract_bit_field_as_subreg (mode1, op0, bitsize, bitnum);\n       if (sub)\n \treturn convert_extracted_bit_field (sub, mode, tmode, unsignedp);\n     }\n@@ -1789,6 +1805,39 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return convert_extracted_bit_field (op0, mode, tmode, unsignedp);\n     }\n \n+  /* If we have a memory source and a non-constant bit offset, restrict\n+     the memory to the referenced bytes.  This is a worst-case fallback\n+     but is useful for things like vector booleans.  */\n+  if (MEM_P (op0) && !bitnum.is_constant ())\n+    {\n+      bytenum = bits_to_bytes_round_down (bitnum);\n+      bitnum = num_trailing_bits (bitnum);\n+      poly_uint64 bytesize = bits_to_bytes_round_up (bitnum + bitsize);\n+      op0 = adjust_bitfield_address_size (op0, BLKmode, bytenum, bytesize);\n+      op0_mode = opt_scalar_int_mode ();\n+    }\n+\n+  /* It's possible we'll need to handle other cases here for\n+     polynomial bitnum and bitsize.  */\n+\n+  /* From here on we need to be looking at a fixed-size insertion.  */\n+  return extract_integral_bit_field (op0, op0_mode, bitsize.to_constant (),\n+\t\t\t\t     bitnum.to_constant (), unsignedp,\n+\t\t\t\t     target, mode, tmode, reverse, fallback_p);\n+}\n+\n+/* Subroutine of extract_bit_field_1, with the same arguments, except\n+   that BITSIZE and BITNUM are constant.  Handle cases specific to\n+   integral modes.  If OP0_MODE is defined, it is the mode of OP0,\n+   otherwise OP0 is a BLKmode MEM.  */\n+\n+static rtx\n+extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n+\t\t\t    unsigned HOST_WIDE_INT bitsize,\n+\t\t\t    unsigned HOST_WIDE_INT bitnum, int unsignedp,\n+\t\t\t    rtx target, machine_mode mode, machine_mode tmode,\n+\t\t\t    bool reverse, bool fallback_p)\n+{\n   /* Handle fields bigger than a word.  */\n \n   if (bitsize > BITS_PER_WORD)\n@@ -1808,22 +1857,24 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       /* In case we're about to clobber a base register or something \n \t (see gcc.c-torture/execute/20040625-1.c).   */\n-      if (reg_mentioned_p (target, str_rtx))\n+      if (reg_mentioned_p (target, op0))\n \ttarget = gen_reg_rtx (mode);\n \n       /* Indicate for flow that the entire target reg is being set.  */\n       emit_clobber (target);\n \n+      /* The mode must be fixed-size, since extract_bit_field_1 handles\n+\t extractions from variable-sized objects before calling this\n+\t function.  */\n+      unsigned int target_size = GET_MODE_SIZE (GET_MODE (target));\n       last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n \t{\n \t  /* If I is 0, use the low-order word in both field and target;\n \t     if I is 1, use the next to lowest word; and so on.  */\n \t  /* Word number in TARGET to use.  */\n \t  unsigned int wordnum\n-\t    = (backwards\n-\t       ? GET_MODE_SIZE (GET_MODE (target)) / UNITS_PER_WORD - i - 1\n-\t       : i);\n+\t    = (backwards ? target_size / UNITS_PER_WORD - i - 1 : i);\n \t  /* Offset from start of field in OP0.  */\n \t  unsigned int bit_offset = (backwards ^ reverse\n \t\t\t\t     ? MAX ((int) bitsize - ((int) i + 1)\n@@ -1852,11 +1903,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  /* Unless we've filled TARGET, the upper regs in a multi-reg value\n \t     need to be zero'd out.  */\n-\t  if (GET_MODE_SIZE (GET_MODE (target)) > nwords * UNITS_PER_WORD)\n+\t  if (target_size > nwords * UNITS_PER_WORD)\n \t    {\n \t      unsigned int i, total_words;\n \n-\t      total_words = GET_MODE_SIZE (GET_MODE (target)) / UNITS_PER_WORD;\n+\t      total_words = target_size / UNITS_PER_WORD;\n \t      for (i = nwords; i < total_words; i++)\n \t\temit_move_insn\n \t\t  (operand_subword (target,\n@@ -1994,10 +2045,9 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n    if they are equally easy.  */\n \n rtx\n-extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   machine_mode mode, machine_mode tmode, bool reverse,\n-\t\t   rtx *alt_rtl)\n+extract_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n+\t\t   int unsignedp, rtx target, machine_mode mode,\n+\t\t   machine_mode tmode, bool reverse, rtx *alt_rtl)\n {\n   machine_mode mode1;\n \n@@ -2009,28 +2059,34 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   else\n     mode1 = tmode;\n \n+  unsigned HOST_WIDE_INT ibitsize, ibitnum;\n   scalar_int_mode int_mode;\n-  if (is_a <scalar_int_mode> (mode1, &int_mode)\n-      && strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, int_mode, 0, 0))\n+  if (bitsize.is_constant (&ibitsize)\n+      && bitnum.is_constant (&ibitnum)\n+      && is_a <scalar_int_mode> (mode1, &int_mode)\n+      && strict_volatile_bitfield_p (str_rtx, ibitsize, ibitnum,\n+\t\t\t\t     int_mode, 0, 0))\n     {\n       /* Extraction of a full INT_MODE value can be done with a simple load.\n \t We know here that the field can be accessed with one single\n \t instruction.  For targets that support unaligned memory,\n \t an unaligned access may be necessary.  */\n-      if (bitsize == GET_MODE_BITSIZE (int_mode))\n+      if (ibitsize == GET_MODE_BITSIZE (int_mode))\n \t{\n \t  rtx result = adjust_bitfield_address (str_rtx, int_mode,\n-\t\t\t\t\t\tbitnum / BITS_PER_UNIT);\n+\t\t\t\t\t\tibitnum / BITS_PER_UNIT);\n \t  if (reverse)\n \t    result = flip_storage_order (int_mode, result);\n-\t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n+\t  gcc_assert (ibitnum % BITS_PER_UNIT == 0);\n \t  return convert_extracted_bit_field (result, mode, tmode, unsignedp);\n \t}\n \n-      str_rtx = narrow_bit_field_mem (str_rtx, int_mode, bitsize, bitnum,\n-\t\t\t\t      &bitnum);\n-      gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (int_mode));\n+      str_rtx = narrow_bit_field_mem (str_rtx, int_mode, ibitsize, ibitnum,\n+\t\t\t\t      &ibitnum);\n+      gcc_assert (ibitnum + ibitsize <= GET_MODE_BITSIZE (int_mode));\n       str_rtx = copy_to_reg (str_rtx);\n+      return extract_bit_field_1 (str_rtx, ibitsize, ibitnum, unsignedp,\n+\t\t\t\t  target, mode, tmode, reverse, true, alt_rtl);\n     }\n \n   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,"}, {"sha": "82383a6bbb9ffb446fc5965e6513c9ad60a2c34e", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=fc60a41612bad379060969b6ed3a78eb160aae8a", "patch": "@@ -722,8 +722,7 @@ extern void store_bit_field (rtx, poly_uint64, poly_uint64,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     machine_mode, rtx, bool);\n-extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n+extern rtx extract_bit_field (rtx, poly_uint64, poly_uint64, int, rtx,\n \t\t\t      machine_mode, machine_mode, bool, rtx *);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);\n extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int, bool = false);"}, {"sha": "f09a9f468755382538dbc88b238c3dcda8fa100d", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc60a41612bad379060969b6ed3a78eb160aae8a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=fc60a41612bad379060969b6ed3a78eb160aae8a", "patch": "@@ -3293,6 +3293,12 @@ extern rtx simplify_subreg (machine_mode, rtx, machine_mode,\n \t\t\t    unsigned int);\n extern rtx simplify_gen_subreg (machine_mode, rtx, machine_mode,\n \t\t\t\tunsigned int);\n+inline rtx\n+simplify_gen_subreg (machine_mode omode, rtx x, machine_mode imode,\n+\t\t     poly_uint64 offset)\n+{\n+  return simplify_gen_subreg (omode, x, imode, offset.to_constant ());\n+}\n extern rtx lowpart_subreg (machine_mode, rtx, machine_mode);\n extern rtx simplify_replace_fn_rtx (rtx, const_rtx,\n \t\t\t\t    rtx (*fn) (rtx, const_rtx, void *), void *);"}]}