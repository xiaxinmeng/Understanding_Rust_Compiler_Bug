{"sha": "4b2b493f86452d7941bf591b91bd348166f8ad1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyYjQ5M2Y4NjQ1MmQ3OTQxYmY1OTFiOTFiZDM0ODE2NmY4YWQxZA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2017-12-07T18:47:20Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2017-12-07T18:47:20Z"}, "message": "Allow _Alignas in compound literals (C11 DR#444).\n\nC11 DR#444 dealt with how C11 intended to allow alignment specifiers\non struct and union members, but failed to include that in the syntax.\nThe final resolution of that DR also allows alignment specifiers in\ntype names in compound literals (in order to apply an increased\nalignment to the unnamed object created by the compound literal), but\nnot other cases of type names.\n\nThis patch implements allowing alignment specifiers in compound\nliterals and adds tests for the resolution of the DR (including that\nthey are allowed on struct and union members, which GCC already\nimplemented).  Because the parser has to parse the parenthesized type\nname of a compound literal before it can tell that it's a compound\nliteral (rather than, depending on the context, a cast expression or\nsizeof (type-name) or _Alignof (type-name)), this means _Alignas\nspecifiers are allowed syntactically in those contexts and then an\nerror is given once it's known to be an invalid use (whereas _Alignas\nspecifiers are disallowed syntactically in other contexts where type\nnames can occur and a compound literal is not possible).\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\ngcc/c:\n\t* c-decl.c (build_compound_literal): Add parameter alignas_align\n\tand set alignment of decl if nonzero.\n\t* c-parser.c (c_keyword_starts_typename): Allow RID_ALIGNAS.\n\t(c_parser_declspecs): Allow RID_ALIGNAS to follow a type, like a\n\tqualifier.\n\t(c_parser_struct_declaration): Update syntax comment.\n\t(c_parser_type_name): Add alignas_ok argument and pass it to\n\tc_parser_declspecs.\n\t(c_parser_cast_expression): Pass true to c_parser_type_name and\n\tgive error if a cast used an _Alignas specifier.\n\t(c_parser_sizeof_expression): Pass true to c_parser_type_name and\n\tgive error if sizeof (type-name) used an _Alignas specifier.\n\t(c_parser_alignof_expression): Pass true to c_parser_type_name and\n\tgive error if _Alignof (type-name) used an _Alignas specifier.\n\t(c_parser_postfix_expression_after_paren_type): Check specified\n\talignment for a compound literal and pass it to\n\tbuild_compound_literal.\n\t* c-parser.h (c_parser_type_name): Update prototype.\n\t* c-tree.h (build_compound_literal): Update prototype.\n\ngcc/testsuite:\n\t* gcc.dg/c11-align-7.c, gcc.dg/c11-align-8.c,\n\tgcc.dg/c11-align-9.c, gcc.dg/gnu11-align-1.c: New tests.\n\t* gcc.dg/c11-align-5.c (test): Update expected error for sizeof\n\tcase.\n\nFrom-SVN: r255482", "tree": {"sha": "1c5ec854c5192aac243178dd75fcfda1fbb8e618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c5ec854c5192aac243178dd75fcfda1fbb8e618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b2b493f86452d7941bf591b91bd348166f8ad1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2b493f86452d7941bf591b91bd348166f8ad1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b2b493f86452d7941bf591b91bd348166f8ad1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2b493f86452d7941bf591b91bd348166f8ad1d/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c348cab062adf3946fdadff884b7f43774d72d8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c348cab062adf3946fdadff884b7f43774d72d8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c348cab062adf3946fdadff884b7f43774d72d8f"}], "stats": {"total": 148, "additions": 135, "deletions": 13}, "files": [{"sha": "14d7f63bf4e3fe3bdd3c4c2274f661ae6f1d4c88", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -1,3 +1,25 @@\n+2017-12-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-decl.c (build_compound_literal): Add parameter alignas_align\n+\tand set alignment of decl if nonzero.\n+\t* c-parser.c (c_keyword_starts_typename): Allow RID_ALIGNAS.\n+\t(c_parser_declspecs): Allow RID_ALIGNAS to follow a type, like a\n+\tqualifier.\n+\t(c_parser_struct_declaration): Update syntax comment.\n+\t(c_parser_type_name): Add alignas_ok argument and pass it to\n+\tc_parser_declspecs.\n+\t(c_parser_cast_expression): Pass true to c_parser_type_name and\n+\tgive error if a cast used an _Alignas specifier.\n+\t(c_parser_sizeof_expression): Pass true to c_parser_type_name and\n+\tgive error if sizeof (type-name) used an _Alignas specifier.\n+\t(c_parser_alignof_expression): Pass true to c_parser_type_name and\n+\tgive error if _Alignof (type-name) used an _Alignas specifier.\n+\t(c_parser_postfix_expression_after_paren_type): Check specified\n+\talignment for a compound literal and pass it to\n+\tbuild_compound_literal.\n+\t* c-parser.h (c_parser_type_name): Update prototype.\n+\t* c-tree.h (build_compound_literal): Update prototype.\n+\n 2017-12-07  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81544"}, {"sha": "4a36c54d21e91440f2b324b1167872d52de0b28c", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -5272,10 +5272,13 @@ mark_forward_parm_decls (void)\n    literal, which may be an incomplete array type completed by the\n    initializer; INIT is a CONSTRUCTOR at LOC that initializes the compound\n    literal.  NON_CONST is true if the initializers contain something\n-   that cannot occur in a constant expression.  */\n+   that cannot occur in a constant expression.  If ALIGNAS_ALIGN is nonzero,\n+   it is the (valid) alignment for this compound literal, as specified\n+   with _Alignas.  */\n \n tree\n-build_compound_literal (location_t loc, tree type, tree init, bool non_const)\n+build_compound_literal (location_t loc, tree type, tree init, bool non_const,\n+\t\t\tunsigned int alignas_align)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n@@ -5299,6 +5302,11 @@ build_compound_literal (location_t loc, tree type, tree init, bool non_const)\n   DECL_IGNORED_P (decl) = 1;\n   TREE_TYPE (decl) = type;\n   c_apply_type_quals_to_decl (TYPE_QUALS (strip_array_types (type)), decl);\n+  if (alignas_align)\n+    {\n+      SET_DECL_ALIGN (decl, alignas_align * BITS_PER_UNIT);\n+      DECL_USER_ALIGN (decl) = 1;\n+    }\n   store_init_value (loc, decl, init, NULL_TREE);\n \n   if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))"}, {"sha": "d39854805048166d34d4f3293b7db345e0b31ffe", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -504,6 +504,7 @@ c_keyword_starts_typename (enum rid keyword)\n     case RID_ACCUM:\n     case RID_SAT:\n     case RID_AUTO_TYPE:\n+    case RID_ALIGNAS:\n       return true;\n     default:\n       if (keyword >= RID_FIRST_INT_N\n@@ -2594,7 +2595,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t has simply forgotten a semicolon, so we exit.  */\n       if ((!typespec_ok || specs->typespec_kind == ctsk_tagdef)\n \t  && c_parser_next_tokens_start_typename (parser, la)\n-\t  && !c_parser_next_token_is_qualifier (parser))\n+\t  && !c_parser_next_token_is_qualifier (parser)\n+\t  && !c_parser_next_token_is_keyword (parser, RID_ALIGNAS))\n \tbreak;\n \n       if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -3225,6 +3227,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n    specifier-qualifier-list:\n      type-specifier specifier-qualifier-list[opt]\n      type-qualifier specifier-qualifier-list[opt]\n+     alignment-specifier specifier-qualifier-list[opt]\n      attributes specifier-qualifier-list[opt]\n \n    struct-declarator-list:\n@@ -4410,20 +4413,22 @@ c_parser_attributes (c_parser *parser)\n   return attrs;\n }\n \n-/* Parse a type name (C90 6.5.5, C99 6.7.6, C11 6.7.7).\n+/* Parse a type name (C90 6.5.5, C99 6.7.6, C11 6.7.7).  ALIGNAS_OK\n+   says whether alignment specifiers are OK (only in cases that might\n+   be the type name of a compound literal).\n \n    type-name:\n      specifier-qualifier-list abstract-declarator[opt]\n */\n \n struct c_type_name *\n-c_parser_type_name (c_parser *parser)\n+c_parser_type_name (c_parser *parser, bool alignas_ok)\n {\n   struct c_declspecs *specs = build_null_declspecs ();\n   struct c_declarator *declarator;\n   struct c_type_name *ret;\n   bool dummy = false;\n-  c_parser_declspecs (parser, specs, false, true, true, false, false,\n+  c_parser_declspecs (parser, specs, false, true, true, alignas_ok, false,\n \t\t      cla_prefer_type);\n   if (!specs->declspecs_seen_p)\n     {\n@@ -7019,7 +7024,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       struct c_expr expr;\n       matching_parens parens;\n       parens.consume_open (parser);\n-      type_name = c_parser_type_name (parser);\n+      type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n \t{\n@@ -7035,6 +7040,9 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \treturn c_parser_postfix_expression_after_paren_type (parser, type_name,\n \t\t\t\t\t\t\t     cast_loc);\n+      if (type_name->specs->alignas_p)\n+\terror_at (type_name->specs->locations[cdw_alignas],\n+\t\t  \"alignment specified for type name in cast\");\n       {\n \tlocation_t expr_loc = c_parser_peek_token (parser)->location;\n \texpr = c_parser_cast_expression (parser, NULL);\n@@ -7238,7 +7246,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       matching_parens parens;\n       parens.consume_open (parser);\n       expr_loc = c_parser_peek_token (parser)->location;\n-      type_name = c_parser_type_name (parser);\n+      type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       finish = parser->tokens_buf[0].location;\n       if (type_name == NULL)\n@@ -7260,6 +7268,9 @@ c_parser_sizeof_expression (c_parser *parser)\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n+      if (type_name->specs->alignas_p)\n+\terror_at (type_name->specs->locations[cdw_alignas],\n+\t\t  \"alignment specified for type name in %<sizeof%>\");\n       c_inhibit_evaluation_warnings--;\n       in_sizeof--;\n       result = c_expr_sizeof_type (expr_loc, type_name);\n@@ -7321,7 +7332,7 @@ c_parser_alignof_expression (c_parser *parser)\n       matching_parens parens;\n       parens.consume_open (parser);\n       loc = c_parser_peek_token (parser)->location;\n-      type_name = c_parser_type_name (parser);\n+      type_name = c_parser_type_name (parser, true);\n       end_loc = c_parser_peek_token (parser)->location;\n       parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n@@ -7342,6 +7353,10 @@ c_parser_alignof_expression (c_parser *parser)\n \t  goto alignof_expr;\n \t}\n       /* alignof ( type-name ).  */\n+      if (type_name->specs->alignas_p)\n+\terror_at (type_name->specs->locations[cdw_alignas],\n+\t\t  \"alignment specified for type name in %qE\",\n+\t\t  alignof_spelling);\n       c_inhibit_evaluation_warnings--;\n       in_alignof--;\n       ret.value = c_sizeof_or_alignof_type (loc, groktypename (type_name,\n@@ -8969,7 +8984,21 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t       ? CONSTRUCTOR_NON_CONST (init.value)\n \t       : init.original_code == C_MAYBE_CONST_EXPR);\n   non_const |= !type_expr_const;\n-  expr.value = build_compound_literal (start_loc, type, init.value, non_const);\n+  unsigned int alignas_align = 0;\n+  if (type != error_mark_node\n+      && type_name->specs->align_log != -1)\n+    {\n+      alignas_align = 1U << type_name->specs->align_log;\n+      if (alignas_align < min_align_of_type (type))\n+\t{\n+\t  error_at (type_name->specs->locations[cdw_alignas],\n+\t\t    \"%<_Alignas%> specifiers cannot reduce \"\n+\t\t    \"alignment of compound literal\");\n+\t  alignas_align = 0;\n+\t}\n+    }\n+  expr.value = build_compound_literal (start_loc, type, init.value, non_const,\n+\t\t\t\t       alignas_align);\n   set_c_expr_source_range (&expr, init.src_range);\n   expr.original_code = ERROR_MARK;\n   expr.original_type = NULL;"}, {"sha": "ff8cdda69174650a078d6584e365b54466678e0e", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -187,6 +187,6 @@ c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n \t\t     bool *seen_id);\n extern void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n \t\t\t\tbool, bool, bool, enum c_lookahead_kind);\n-extern struct c_type_name *c_parser_type_name (c_parser *);\n+extern struct c_type_name *c_parser_type_name (c_parser *, bool = false);\n \n #endif"}, {"sha": "c542d682f3eee7e96884619fcba1a811e7fa3cac", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -672,7 +672,8 @@ extern void set_init_index (location_t, tree, tree, struct obstack *);\n extern void set_init_label (location_t, tree, location_t, struct obstack *);\n extern void process_init_element (location_t, struct c_expr, bool,\n \t\t\t\t  struct obstack *);\n-extern tree build_compound_literal (location_t, tree, tree, bool);\n+extern tree build_compound_literal (location_t, tree, tree, bool,\n+\t\t\t\t    unsigned int);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_case (location_t, location_t, tree, bool);\n extern void c_finish_case (tree, tree);"}, {"sha": "dab24f424388e8e06e5c3aea7b0351c6ed438afb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -1,3 +1,10 @@\n+2017-12-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/c11-align-7.c, gcc.dg/c11-align-8.c,\n+\tgcc.dg/c11-align-9.c, gcc.dg/gnu11-align-1.c: New tests.\n+\t* gcc.dg/c11-align-5.c (test): Update expected error for sizeof\n+\tcase.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/asm-2.c: New test."}, {"sha": "08ec65a8b9fbfb84ad363473806533dd4905721d", "filename": "gcc/testsuite/gcc.dg/c11-align-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-5.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -19,7 +19,7 @@ test (void)\n   struct s { int n; };\n   __builtin_offsetof (struct s _Alignas (int), n); /* { dg-error \"expected\" } */\n   __typeof (long double _Alignas (0)) e; /* { dg-error \"expected\" } */\n-  sizeof (int _Alignas (int)); /* { dg-error \"expected\" } */\n+  sizeof (int _Alignas (int)); /* { dg-error \"specified for type name\" } */\n   _Alignas (int _Alignas (float)) int t; /* { dg-error \"expected\" } */\n   __builtin_types_compatible_p (signed _Alignas (0), unsigned); /* { dg-error \"expected\" } */\n   int a[_Alignas (int) 10]; /* { dg-error \"expected expression before\" } */"}, {"sha": "631986ac30fdcda8b8fd2261e67bd1f8a91d635b", "filename": "gcc/testsuite/gcc.dg/c11-align-7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-7.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -0,0 +1,20 @@\n+/* Test C11 alignment support.  Test code valid after the resolution\n+   of DR#444: alignment specifiers for struct and union members and\n+   compound literals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stddef.h>\n+\n+struct s\n+{\n+  _Alignas (_Alignof (max_align_t)) char c;\n+};\n+\n+union u\n+{\n+  _Alignas (_Alignof (max_align_t)) char c;\n+};\n+\n+char *p = &(_Alignas (_Alignof (max_align_t)) char) { 1 };\n+size_t size = sizeof (_Alignas (_Alignof (max_align_t)) char) { 1 };"}, {"sha": "a201674cf955a15242febd5c8b5accefc71696e7", "filename": "gcc/testsuite/gcc.dg/c11-align-8.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-8.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -0,0 +1,18 @@\n+/* Test C11 alignment support.  Test invalid use of alignment\n+   specifiers in type names in cases not permitted by the resolution\n+   of DR#444.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stddef.h>\n+\n+void\n+f (void)\n+{\n+  _Generic (1, int: 1, _Alignas (8) long: 2); /* { dg-error \"expected\" } */\n+  sizeof (_Alignas (8) long); /* { dg-error \"specified for type name\" } */\n+  _Alignof (_Alignas (8) long); /* { dg-error \"specified for type name\" } */\n+  (_Alignas (8) long) 0; /* { dg-error \"specified for type name\" } */\n+  _Atomic (_Alignas (8) long) x; /* { dg-error \"expected\" } */\n+  _Alignas (_Alignas (8) long) long y; /* { dg-error \"expected\" } */\n+}"}, {"sha": "3c9cf55756ef33be830708eab8de1fc63b9ef9a7", "filename": "gcc/testsuite/gcc.dg/c11-align-9.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-9.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -0,0 +1,9 @@\n+/* Test C11 alignment support.  Test reducing alignment (assumes there\n+   are at least some alignment constraints), case of compound literals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+/* { dg-skip-if \"no alignment constraints\" { \"avr-*-*\" } } */\n+\n+#include <stddef.h>\n+\n+max_align_t *p = &(_Alignas (_Alignof (char)) max_align_t) { 1 }; /* { dg-error \"reduce alignment\" } */"}, {"sha": "50522d7bed50d1c9cde76fa8e43e39bc45d6d4ce", "filename": "gcc/testsuite/gcc.dg/gnu11-align-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu11-align-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2b493f86452d7941bf591b91bd348166f8ad1d/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu11-align-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu11-align-1.c?ref=4b2b493f86452d7941bf591b91bd348166f8ad1d", "patch": "@@ -0,0 +1,8 @@\n+/* Test C11 alignment support.  Test code valid after the resolution\n+   of DR#444: alignment specifiers for compound literals in _Alignof.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu11\" } */\n+\n+#include <stddef.h>\n+\n+size_t align = _Alignof (_Alignas (_Alignof (max_align_t)) char) { 1 };"}]}