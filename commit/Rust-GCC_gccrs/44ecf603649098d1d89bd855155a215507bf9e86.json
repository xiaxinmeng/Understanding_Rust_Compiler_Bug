{"sha": "44ecf603649098d1d89bd855155a215507bf9e86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRlY2Y2MDM2NDkwOThkMWQ4OWJkODU1MTU1YTIxNTUwN2JmOWU4Ng==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-04-26T09:31:07Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-04-26T09:31:07Z"}, "message": "re PR libstdc++/21209 (signed integer overflow in num_get<>::_M_extract_int)\n\n2005-04-26  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/21209\n\t* include/bits/locale_facets.tcc (_M_extract_int): Avoid signed\n\tinteger overflow, always use a suited unsigned type in the main\n\tparsing loop.\n\t(struct __to_unsigned_type): New.\n\t* testsuite/22_locale/num_get/get/char/16.cc: New.\n\t* testsuite/22_locale/num_get/get/wchar_t/16.cc: Likewise.\n\nFrom-SVN: r98768", "tree": {"sha": "90e9886d6ee581f71733aa43b16029cbbf1fb27a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90e9886d6ee581f71733aa43b16029cbbf1fb27a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44ecf603649098d1d89bd855155a215507bf9e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44ecf603649098d1d89bd855155a215507bf9e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44ecf603649098d1d89bd855155a215507bf9e86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44ecf603649098d1d89bd855155a215507bf9e86/comments", "author": null, "committer": null, "parents": [{"sha": "c579626684c724b226892b0869316fd1ed7ad350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c579626684c724b226892b0869316fd1ed7ad350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c579626684c724b226892b0869316fd1ed7ad350"}], "stats": {"total": 556, "additions": 469, "deletions": 87}, "files": [{"sha": "87a5cc6b9cbf31451acaf76f66270930243f9498", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=44ecf603649098d1d89bd855155a215507bf9e86", "patch": "@@ -1,3 +1,13 @@\n+2005-04-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/21209\n+\t* include/bits/locale_facets.tcc (_M_extract_int): Avoid signed\n+\tinteger overflow, always use a suited unsigned type in the main\n+\tparsing loop.\n+\t(struct __to_unsigned_type): New.\n+\t* testsuite/22_locale/num_get/get/char/16.cc: New.\n+\t* testsuite/22_locale/num_get/get/wchar_t/16.cc: Likewise.\n+\n 2005-04-25  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/21035"}, {"sha": "436fe9d5b3122547be2b699deb79b8ccecaa807e", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 55, "deletions": 87, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=44ecf603649098d1d89bd855155a215507bf9e86", "patch": "@@ -440,15 +440,30 @@ namespace std\n       return __beg;\n     }\n \n+  template<typename _ValueT>\n+    struct __to_unsigned_type\n+    { typedef _ValueT __type; };\n+\n+  template<>\n+    struct __to_unsigned_type<long>\n+    { typedef unsigned long __type; };\n+\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  template<>\n+    struct __to_unsigned_type<long long>\n+    { typedef unsigned long long __type; };\n+#endif\n+\n   template<typename _CharT, typename _InIter>\n     template<typename _ValueT>\n       _InIter\n       num_get<_CharT, _InIter>::\n       _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t     ios_base::iostate& __err, _ValueT& __v) const\n       {\n-        typedef char_traits<_CharT>\t\t\t__traits_type;\n-\ttypedef typename numpunct<_CharT>::__cache_type __cache_type;\n+        typedef char_traits<_CharT>\t\t\t     __traits_type;\n+\ttypedef typename __to_unsigned_type<_ValueT>::__type __unsigned_type;\t\n+\ttypedef typename numpunct<_CharT>::__cache_type      __cache_type;\n \t__use_cache<__cache_type> __uc;\n \tconst locale& __loc = __io._M_getloc();\n \tconst __cache_type* __lc = __uc(__loc);\n@@ -536,103 +551,56 @@ namespace std\n \t  __found_grouping.reserve(32);\n \tint __sep_pos = 0;\n \tbool __overflow = false;\n-\t_ValueT __result = 0;\n+\tconst __unsigned_type __max = __negative ?\n+\t  -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();\n+\tconst __unsigned_type __smax = __max / __base;\n+\t__unsigned_type __result = 0;\n \tconst char_type* __q;\n \tconst char_type* __lit_zero = __lit + __num_base::_S_izero;\n-\tif (__negative)\n+\twhile (!__testeof)\n \t  {\n-\t    const _ValueT __min = numeric_limits<_ValueT>::min() / __base;\n-\t    while (!__testeof)\n+\t    // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n+\t    // and decimal_point.\n+\t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t      {\n-\t\t// According to 22.2.2.1.2, p8-9, first look for thousands_sep\n-\t\t// and decimal_point.\n-\t\tif (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n+\t\t// NB: Thousands separator at the beginning of a string\n+\t\t// is a no-no, as is two consecutive thousands separators.\n+\t\tif (__sep_pos)\n \t\t  {\n-\t\t    // NB: Thousands separator at the beginning of a string\n-\t\t    // is a no-no, as is two consecutive thousands separators.\n-\t\t    if (__sep_pos)\n-\t\t      {\n-\t\t\t__found_grouping += static_cast<char>(__sep_pos);\n-\t\t\t__sep_pos = 0;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\t__err |= ios_base::failbit;\n-\t\t\tbreak;\n-\t\t      }\n+\t\t    __found_grouping += static_cast<char>(__sep_pos);\n+\t\t    __sep_pos = 0;\n \t\t  }\n-\t\telse if (__c == __lc->_M_decimal_point)\n-\t\t  break;\n-\t\telse if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n+\t\telse\n \t\t  {\n-\t\t    int __digit = __q - __lit_zero;\n-\t\t    if (__digit > 15)\n-\t\t      __digit -= 6;\n-\t\t    if (__result < __min)\n-\t\t      __overflow = true;\n-\t\t    else\n-\t\t      {\n-\t\t\tconst _ValueT __new_result = (__result * __base\n-\t\t\t\t\t\t      - __digit);\n-\t\t\t__overflow |= __new_result > __result;\n-\t\t\t__result = __new_result;\n-\t\t\t++__sep_pos;\n-\t\t      }\n+\t\t    __err |= ios_base::failbit;\n+\t\t    break;\n \t\t  }\n-\t\telse\n-\t\t  // Not a valid input item.\n-\t\t  break;\n-\n-\t\tif (++__beg != __end)\n-\t\t  __c = *__beg;\n-\t\telse\n-\t\t  __testeof = true;\n \t      }\n-\t  }\n-\telse\n-\t  {\n-\t    const _ValueT __max = numeric_limits<_ValueT>::max() / __base;\n-\t    while (!__testeof)\n+\t    else if (__c == __lc->_M_decimal_point)\n+\t      break;\n+\t    else if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n \t      {\n-\t\tif (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n-\t\t  {\n-\t\t    if (__sep_pos)\n-\t\t      {\n-\t\t\t__found_grouping += static_cast<char>(__sep_pos);\n-\t\t\t__sep_pos = 0;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\t__err |= ios_base::failbit;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\telse if (__c == __lc->_M_decimal_point)\n-\t\t  break;\n-\t\telse if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n+\t\tint __digit = __q - __lit_zero;\n+\t\tif (__digit > 15)\n+\t\t  __digit -= 6;\n+\t\tif (__result > __smax)\n+\t\t  __overflow = true;\n+\t\telse\n \t\t  {\n-\t\t    int __digit = __q - __lit_zero;\n-\t\t    if (__digit > 15)\n-\t\t      __digit -= 6;\n-\t\t    if (__result > __max)\n-\t\t      __overflow = true;\n-\t\t    else\n-\t\t      {\n-\t\t\tconst _ValueT __new_result = (__result * __base\n-\t\t\t\t\t\t      + __digit);\n-\t\t\t__overflow |= __new_result < __result;\n-\t\t\t__result = __new_result;\n-\t\t\t++__sep_pos;\n-\t\t      }\n+\t\t    __result *= __base;\n+\t\t    __overflow |= __result > __max - __digit;\n+\t\t    __result += __digit;\n+\t\t    ++__sep_pos;\n \t\t  }\n-\t\telse\n-\t\t  break;\n-\n-\t\tif (++__beg != __end)\n-\t\t  __c = *__beg;\n-\t\telse\n-\t\t  __testeof = true;\n \t      }\n+\t    else\n+\t      // Not a valid input item.\t      \n+\t      break;\n+\t    \n+\t    if (++__beg != __end)\n+\t      __c = *__beg;\n+\t    else\n+\t      __testeof = true;\n \t  }\n \n \t// Digit grouping is checked. If grouping and found_grouping don't\n@@ -650,7 +618,7 @@ namespace std\n \n \tif (!(__err & ios_base::failbit) && !__overflow\n \t    && (__sep_pos || __found_zero || __found_grouping.size()))\n-\t  __v = __result;\n+\t  __v = __negative ? -__result : __result;\n \telse\n \t  __err |= ios_base::failbit;\n "}, {"sha": "03512714da897b5f6100ee265810b8fd69cb9c75", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/char/16.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F16.cc?ref=44ecf603649098d1d89bd855155a215507bf9e86", "patch": "@@ -0,0 +1,202 @@\n+// 2005-04-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  stringstream ss;\n+  const num_get<char>& ng = use_facet<num_get<char> >(ss.getloc()); \n+  ios_base::iostate err;\n+  iterator_type end;\n+\n+  unsigned short us0, us1 = numeric_limits<unsigned short>::max();\n+  unsigned int ui0, ui1 = numeric_limits<unsigned int>::max();\n+  unsigned long ul0, ul1 = numeric_limits<unsigned long>::max();\n+  long l01, l1 = numeric_limits<long>::max();\n+  long l02, l2 = numeric_limits<long>::min();\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  unsigned long long ull0, ull1 = numeric_limits<unsigned long long>::max();\n+  long long ll01, ll1 = numeric_limits<long long>::max();\n+  long long ll02, ll2 = numeric_limits<long long>::min();\n+#endif\n+\n+  const string empty;\n+\n+  us0 = 0;\n+  ss << us1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, us0);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( us0 == us1 );\n+\n+  us0 = 0;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << us1 << '0';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, us0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( us0 == 0 );\n+\n+  ui0 = 0U;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ui1 << ' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ui0);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ui0 == ui1 );\n+\n+  ui0 = 0U;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ui1 << '1';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ui0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ui0 == 0U );\n+\n+  ul0 = 0UL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ul1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ul0 == ul1 );\n+\n+  ul0 = 0UL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ul1 << '2';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ul0 == 0UL );\n+\n+  l01 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l1 << ' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l01);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( l01 == l1 );\n+\n+  l01 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l1 << '3';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l01);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( l01 == 0L );\n+\n+  l02 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l2;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l02);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( l02 == l2 );\n+\n+  l02 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l2 << '4';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l02);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( l02 == 0L );\n+\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  ull0 = 0ULL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ull1 << ' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ull0);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ull0 == ull1 );\n+\n+  ull0 = 0ULL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ull1 << '5';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ull0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ull0 == 0ULL );\n+\n+  ll01 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll01);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ll01 == ll1 );\n+\n+  ll01 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll1 << '6';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll01);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ll01 == 0LL );\n+\n+  ll02 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll2 << ' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll02);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ll02 == ll2 );\n+\n+  ll02 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll2 << '7';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll02);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ll02 == 0LL );\n+#endif\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ca774da4778d35334f99f6dbcb071a27beea7064", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/16.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44ecf603649098d1d89bd855155a215507bf9e86/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F16.cc?ref=44ecf603649098d1d89bd855155a215507bf9e86", "patch": "@@ -0,0 +1,202 @@\n+// 2005-04-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  wstringstream ss;\n+  const num_get<wchar_t>& ng = use_facet<num_get<wchar_t> >(ss.getloc()); \n+  ios_base::iostate err;\n+  iterator_type end;\n+\n+  unsigned short us0, us1 = numeric_limits<unsigned short>::max();\n+  unsigned int ui0, ui1 = numeric_limits<unsigned int>::max();\n+  unsigned long ul0, ul1 = numeric_limits<unsigned long>::max();\n+  long l01, l1 = numeric_limits<long>::max();\n+  long l02, l2 = numeric_limits<long>::min();\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  unsigned long long ull0, ull1 = numeric_limits<unsigned long long>::max();\n+  long long ll01, ll1 = numeric_limits<long long>::max();\n+  long long ll02, ll2 = numeric_limits<long long>::min();\n+#endif\n+\n+  const wstring empty;\n+\n+  us0 = 0;\n+  ss << us1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, us0);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( us0 == us1 );\n+\n+  us0 = 0;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << us1 << L'0';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, us0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( us0 == 0 );\n+\n+  ui0 = 0U;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ui1 << ' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ui0);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ui0 == ui1 );\n+\n+  ui0 = 0U;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ui1 << L'1';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ui0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ui0 == 0U );\n+\n+  ul0 = 0UL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ul1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ul0 == ul1 );\n+\n+  ul0 = 0UL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ul1 << L'2';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ul0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ul0 == 0UL );\n+\n+  l01 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l1 << L' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l01);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( l01 == l1 );\n+\n+  l01 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l1 << L'3';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l01);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( l01 == 0L );\n+\n+  l02 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l2;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l02);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( l02 == l2 );\n+\n+  l02 = 0L;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << l2 << L'4';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, l02);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( l02 == 0L );\n+\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+  ull0 = 0ULL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ull1 << L' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ull0);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ull0 == ull1 );\n+\n+  ull0 = 0ULL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ull1 << L'5';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ull0);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ull0 == 0ULL );\n+\n+  ll01 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll1;\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll01);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ll01 == ll1 );\n+\n+  ll01 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll1 << L'6';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll01);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ll01 == 0LL );\n+\n+  ll02 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll2 << L' ';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll02);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ll02 == ll2 );\n+\n+  ll02 = 0LL;\n+  ss.clear();\n+  ss.str(empty);\n+  ss << ll2 << L'7';\n+  err = ios_base::goodbit;\n+  end = ng.get(ss.rdbuf(), 0, ss, err, ll02);\n+  VERIFY( err == (ios_base::failbit | ios_base::eofbit) );\n+  VERIFY( ll02 == 0LL );\n+#endif\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}