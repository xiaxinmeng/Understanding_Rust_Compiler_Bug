{"sha": "9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZDc4NWRjYjAyYzYwZWE3MGE2YjAxYzRkY2RlM2Y2Yzc3NmU0Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-06-30T15:55:35Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-30T15:55:35Z"}, "message": "c4x-protos.h: Remove the prototypes for those functions removed from c4x.c.\n\n\t* config/c4x/c4x-protos.h: Remove the prototypes for those\n\tfunctions removed from c4x.c.  Add prototypes for those\n\tfunctions exported in c4x.c.\n\t* config/c4x/c4x.c (any_operand, fp_zero_operand,\n\tconst_operand, stik_const_operand, not_const_operand,\n\treg_operand, r0r1_reg_operand, r2r3_reg_operand,\n\text_low_reg_operand, ext_reg_operand, std_reg_operand,\n\tstd_or_reg_operand, addr_reg_operand, index_reg_operand,\n\tdp_reg_operand, sp_reg_operand, st_reg_operand,\n\trc_reg_operand, call_address_operand,\n\tsymbolic_address_operand, dst_operand, src_operand,\n\tsrc_hi_operand, lsrc_operand, tsrc_operand,\n\tnonimmediate_src_operand, nonimmediate_lsrc_operand,\n\treg_or_const_operand, par_ind_operand, parallel_operand):\n\tRemove.\n\t(c4x_immed_float_p, c4x_a_register, c4x_x_register,\n\tc4x_K_constant, c4x_N_constant, c4x_O_constant,\n\tc4x_S_indirect): Export.\n\t* config/c4x/c4x.h (PREDICATE_CODES): Remove.\n\t* config/c4x/c4x.md: Include predicates.md.\n\t* config/c4x/predicates.md: New.\n\nFrom-SVN: r101469", "tree": {"sha": "b20c583c841591f0e1128a16516e72fe36b4077e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b20c583c841591f0e1128a16516e72fe36b4077e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/comments", "author": null, "committer": null, "parents": [{"sha": "3aebbe5f49f9b9ccda66fc1eb907603e84813878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aebbe5f49f9b9ccda66fc1eb907603e84813878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aebbe5f49f9b9ccda66fc1eb907603e84813878"}], "stats": {"total": 962, "additions": 452, "deletions": 510}, "files": [{"sha": "e4f3e8a2cafe2c80e8cbda1ed7fc5832a053a182", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -1,3 +1,27 @@\n+2005-06-30  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/c4x/c4x-protos.h: Remove the prototypes for those\n+\tfunctions removed from c4x.c.  Add prototypes for those\n+\tfunctions exported in c4x.c.\n+\t* config/c4x/c4x.c (any_operand, fp_zero_operand,\n+\tconst_operand, stik_const_operand, not_const_operand,\n+\treg_operand, r0r1_reg_operand, r2r3_reg_operand,\n+\text_low_reg_operand, ext_reg_operand, std_reg_operand,\n+\tstd_or_reg_operand, addr_reg_operand, index_reg_operand,\n+\tdp_reg_operand, sp_reg_operand, st_reg_operand,\n+\trc_reg_operand, call_address_operand,\n+\tsymbolic_address_operand, dst_operand, src_operand,\n+\tsrc_hi_operand, lsrc_operand, tsrc_operand,\n+\tnonimmediate_src_operand, nonimmediate_lsrc_operand,\n+\treg_or_const_operand, par_ind_operand, parallel_operand):\n+\tRemove.\n+\t(c4x_immed_float_p, c4x_a_register, c4x_x_register,\n+\tc4x_K_constant, c4x_N_constant, c4x_O_constant,\n+\tc4x_S_indirect): Export.\n+\t* config/c4x/c4x.h (PREDICATE_CODES): Remove.\n+\t* config/c4x/c4x.md: Include predicates.md.\n+\t* config/c4x/predicates.md: New.\n+\n 2005-06-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* function.c (stack_protect_epilogue): Pass label to"}, {"sha": "059e25ba49593abda0040887b2c6c4cf09f439c4", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 15, "deletions": 59, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2003, 2004\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n@@ -98,66 +98,12 @@ extern int c4x_check_laj_p (rtx);\n \n extern int c4x_autoinc_operand (rtx, enum machine_mode);\n \n-extern int any_operand (rtx, enum machine_mode);\n-\n-extern int fp_zero_operand (rtx, enum machine_mode);\n-\n-extern int const_operand (rtx, enum machine_mode);\n-\n-extern int stik_const_operand (rtx, enum machine_mode);\n-\n-extern int not_const_operand (rtx, enum machine_mode);\n-\n-extern int parallel_operand (rtx, enum machine_mode);\n-\n extern int reg_or_const_operand (rtx, enum machine_mode);\n \n-extern int reg_operand (rtx, enum machine_mode);\n-\n extern int mixed_subreg_operand (rtx, enum machine_mode);\n \n extern int reg_imm_operand (rtx, enum machine_mode);\n \n-extern int r0r1_reg_operand (rtx, enum machine_mode);\n-\n-extern int r2r3_reg_operand (rtx, enum machine_mode);\n-\n-extern int ext_low_reg_operand (rtx, enum machine_mode);\n-\n-extern int ext_reg_operand (rtx, enum machine_mode);\n-\n-extern int std_reg_operand (rtx, enum machine_mode);\n-\n-extern int std_or_reg_operand (rtx, enum machine_mode);\n-\n-extern int dst_operand (rtx, enum machine_mode);\n-\n-extern int src_operand (rtx, enum machine_mode);\n-\n-extern int src_hi_operand (rtx, enum machine_mode);\n-\n-extern int lsrc_operand (rtx, enum machine_mode);\n-\n-extern int tsrc_operand (rtx, enum machine_mode);\n-\n-extern int nonimmediate_src_operand (rtx, enum machine_mode);\n-\n-extern int nonimmediate_lsrc_operand (rtx, enum machine_mode);\n-\n-extern int addr_reg_operand (rtx, enum machine_mode);\n-\n-extern int index_reg_operand (rtx, enum machine_mode);\n-\n-extern int dp_reg_operand (rtx, enum machine_mode);\n-\n-extern int sp_reg_operand (rtx, enum machine_mode);\n-\n-extern int rc_reg_operand (rtx, enum machine_mode);\n-\n-extern int st_reg_operand (rtx, enum machine_mode);\n-\n-extern int symbolic_address_operand (rtx, enum machine_mode);\n-\n extern int ar0_reg_operand (rtx, enum machine_mode);\n \n extern int ar0_mem_operand (rtx, enum machine_mode);\n@@ -204,28 +150,38 @@ extern int group1_mem_operand (rtx, enum machine_mode);\n \n extern int arx_reg_operand (rtx, enum machine_mode);\n \n-extern int call_address_operand (rtx, enum machine_mode);\n-\n-extern int par_ind_operand (rtx, enum machine_mode);\n-\n extern int not_rc_reg (rtx, enum machine_mode);\n \n extern int not_modify_reg (rtx, enum machine_mode);\n \n extern int c4x_shiftable_constant (rtx);\n \n+extern int c4x_immed_float_p (rtx);\n+\n+extern int c4x_a_register (rtx);\n+\n+extern int c4x_x_register (rtx);\n+\n extern int c4x_H_constant (rtx);\n \n extern int c4x_I_constant (rtx);\n \n extern int c4x_J_constant (rtx);\n \n+extern int c4x_K_constant (rtx);\n+\n extern int c4x_L_constant (rtx);\n \n+extern int c4x_N_constant (rtx);\n+\n+extern int c4x_O_constant (rtx);\n+\n extern int c4x_Q_constraint (rtx);\n \n extern int c4x_R_constraint (rtx);\n \n+extern int c4x_S_indirect (rtx);\n+\n extern int c4x_S_constraint (rtx);\n \n extern int c4x_T_constraint (rtx);"}, {"sha": "bc9d3969921727f05c168c70035c9013fb24d2b6", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 7, "deletions": 415, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -169,16 +169,9 @@ static bool c4x_handle_option (size_t, const char *, int);\n static int c4x_isr_reg_used_p (unsigned int);\n static int c4x_leaf_function_p (void);\n static int c4x_naked_function_p (void);\n-static int c4x_immed_float_p (rtx);\n-static int c4x_a_register (rtx);\n-static int c4x_x_register (rtx);\n static int c4x_immed_int_constant (rtx);\n static int c4x_immed_float_constant (rtx);\n-static int c4x_K_constant (rtx);\n-static int c4x_N_constant (rtx);\n-static int c4x_O_constant (rtx);\n static int c4x_R_indirect (rtx);\n-static int c4x_S_indirect (rtx);\n static void c4x_S_address_parse (rtx , int *, int *, int *, int *);\n static int c4x_valid_operands (enum rtx_code, rtx *, enum machine_mode, int);\n static int c4x_arn_reg_operand (rtx, enum machine_mode, unsigned int);\n@@ -2150,7 +2143,7 @@ c4x_print_operand_address (FILE *file, rtx addr)\n /* Return nonzero if the floating point operand will fit\n    in the immediate field.  */\n \n-static int\n+int\n c4x_immed_float_p (rtx op)\n {\n   long convval[2];\n@@ -2460,14 +2453,14 @@ c4x_reorg (void)\n }\n \n \n-static int\n+int\n c4x_a_register (rtx op)\n {\n   return REG_P (op) && IS_ADDR_OR_PSEUDO_REG (op);\n }\n \n \n-static int\n+int\n c4x_x_register (rtx op)\n {\n   return REG_P (op) && IS_INDEX_OR_PSEUDO_REG (op);\n@@ -2543,7 +2536,7 @@ c4x_J_constant (rtx op)\n }\n \n \n-static int\n+int\n c4x_K_constant (rtx op)\n {\n   if (TARGET_C3X || ! c4x_immed_int_constant (op))\n@@ -2559,14 +2552,14 @@ c4x_L_constant (rtx op)\n }\n \n \n-static int\n+int\n c4x_N_constant (rtx op)\n {\n   return c4x_immed_int_constant (op) && IS_NOT_UINT16_CONST (INTVAL (op));\n }\n \n \n-static int\n+int\n c4x_O_constant (rtx op)\n {\n   return c4x_immed_int_constant (op) && IS_HIGH_CONST (INTVAL (op));\n@@ -2771,7 +2764,7 @@ c4x_S_constraint (rtx op)\n }\n \n \n-static int\n+int\n c4x_S_indirect (rtx op)\n {\n   enum machine_mode mode = GET_MODE (op);\n@@ -2907,88 +2900,6 @@ c4x_autoinc_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n \n-/* Match any operand.  */\n-\n-int\n-any_operand (register rtx op ATTRIBUTE_UNUSED,\n-\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return 1;\n-}\n-\n-\n-/* Nonzero if OP is a floating point value with value 0.0.  */\n-\n-int\n-fp_zero_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  REAL_VALUE_TYPE r;\n-\n-  if (GET_CODE (op) != CONST_DOUBLE)\n-    return 0;\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-  return REAL_VALUES_EQUAL (r, dconst0);\n-}\n-\n-\n-int\n-const_operand (register rtx op, register enum machine_mode mode)\n-{\n-  switch (mode)\n-    {\n-    case QFmode:\n-    case HFmode:\n-      if (GET_CODE (op) != CONST_DOUBLE\n-\t  || GET_MODE (op) != mode\n-\t  || GET_MODE_CLASS (mode) != MODE_FLOAT)\n-\treturn 0;\n-\n-      return c4x_immed_float_p (op);\n-\n-#if Pmode != QImode\n-    case Pmode:\n-#endif\n-    case QImode:\n-      if (GET_CODE (op) != CONST_INT\n-\t  || (GET_MODE (op) != VOIDmode && GET_MODE (op) != mode)\n-\t  || GET_MODE_CLASS (mode) != MODE_INT)\n-\treturn 0;\n-\n-      return IS_HIGH_CONST (INTVAL (op)) || IS_INT16_CONST (INTVAL (op));\n-\n-    case HImode:\n-      return 0;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-\n-int\n-stik_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return c4x_K_constant (op);\n-}\n-\n-\n-int\n-not_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return c4x_N_constant (op);\n-}\n-\n-\n-int\n-reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && GET_MODE (op) == QFmode)\n-    return 0;\n-  return register_operand (op, mode);\n-}\n-\n-\n int\n mixed_subreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -3067,325 +2978,6 @@ not_rc_reg (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n \n-/* Extended precision register R0-R1.  */\n-\n-int\n-r0r1_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R0R1_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* Extended precision register R2-R3.  */\n-\n-int\n-r2r3_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R2R3_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* Low extended precision register R0-R7.  */\n-\n-int\n-ext_low_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_EXT_LOW_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* Extended precision register.  */\n-\n-int\n-ext_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (! REG_P (op))\n-    return 0;\n-  return IS_EXT_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* Standard precision register.  */\n-\n-int\n-std_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_STD_OR_PSEUDO_REG (op);\n-}\n-\n-/* Standard precision or normal register.  */\n-\n-int\n-std_or_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (reload_in_progress)\n-    return std_reg_operand (op, mode);\n-  return reg_operand (op, mode);\n-}\n-\n-/* Address register.  */\n-\n-int\n-addr_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  return c4x_a_register (op);\n-}\n-\n-\n-/* Index register.  */\n-\n-int\n-index_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return c4x_x_register (op);\n-}\n-\n-\n-/* DP register.  */\n-\n-int\n-dp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && IS_DP_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* SP register.  */\n-\n-int\n-sp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && IS_SP_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* ST register.  */\n-\n-int\n-st_reg_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && IS_ST_OR_PSEUDO_REG (op);\n-}\n-\n-\n-/* RC register.  */\n-\n-int\n-rc_reg_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && IS_RC_OR_PSEUDO_REG (op);\n-}\n-\n-\n-int\n-call_address_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (REG_P (op) || symbolic_address_operand (op, mode));\n-}\n-\n-\n-/* Symbolic address operand.  */\n-\n-int\n-symbolic_address_operand (register rtx op,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-\n-/* Check dst operand of a move instruction.  */\n-\n-int\n-dst_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && mixed_subreg_operand (op, mode))\n-    return 0;\n-\n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n-  return nonimmediate_operand (op, mode);\n-}\n-\n-\n-/* Check src operand of two operand arithmetic instructions.  */\n-\n-int\n-src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && mixed_subreg_operand (op, mode))\n-    return 0;\n-\n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return (mode == QImode || mode == Pmode || mode == HImode)\n-      && c4x_I_constant (op);\n-\n-  /* We don't like CONST_DOUBLE integers.  */\n-  if (GET_CODE (op) == CONST_DOUBLE)\n-    return c4x_H_constant (op);\n-\n-  /* Disallow symbolic addresses.  Only the predicate\n-     symbolic_address_operand will match these.  */\n-  if (GET_CODE (op) == SYMBOL_REF\n-      || GET_CODE (op) == LABEL_REF\n-      || GET_CODE (op) == CONST)\n-    return 0;\n-\n-  /* If TARGET_LOAD_DIRECT_MEMS is nonzero, disallow direct memory\n-     access to symbolic addresses.  These operands will get forced\n-     into a register and the movqi expander will generate a\n-     HIGH/LO_SUM pair if TARGET_EXPOSE_LDP is nonzero.  */\n-  if (GET_CODE (op) == MEM\n-      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t   || GET_CODE (XEXP (op, 0)) == CONST)))\n-    return !TARGET_EXPOSE_LDP && \n-      ! TARGET_LOAD_DIRECT_MEMS && GET_MODE (op) == mode;\n-\n-  return general_operand (op, mode);\n-}\n-\n-\n-int\n-src_hi_operand (rtx op, enum machine_mode mode)\n-{\n-  if (c4x_O_constant (op))\n-    return 1;\n-  return src_operand (op, mode);\n-}\n-\n-\n-/* Check src operand of two operand logical instructions.  */\n-\n-int\n-lsrc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode != QImode && mode != Pmode)\n-    fatal_insn (\"mode not QImode\", op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return c4x_L_constant (op) || c4x_J_constant (op);\n-\n-  return src_operand (op, mode);\n-}\n-\n-\n-/* Check src operand of two operand tricky instructions.  */\n-\n-int\n-tsrc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode != QImode && mode != Pmode)\n-    fatal_insn (\"mode not QImode\", op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return c4x_L_constant (op) || c4x_N_constant (op) || c4x_J_constant (op);\n-\n-  return src_operand (op, mode);\n-}\n-\n-\n-/* Check src operand of two operand non immediate instructions.  */\n-\n-int\n-nonimmediate_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n-    return 0;\n-\n-  return src_operand (op, mode);\n-}\n-\n-\n-/* Check logical src operand of two operand non immediate instructions.  */\n-\n-int\n-nonimmediate_lsrc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n-    return 0;\n-\n-  return lsrc_operand (op, mode);\n-}\n-\n-\n-int\n-reg_or_const_operand (rtx op, enum machine_mode mode)\n-{\n-  return reg_operand (op, mode) || const_operand (op, mode);\n-}\n-\n-\n-/* Check for indirect operands allowable in parallel instruction.  */\n-\n-int\n-par_ind_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  return c4x_S_indirect (op);\n-}\n-\n-\n-/* Check for operands allowable in parallel instruction.  */\n-\n-int\n-parallel_operand (rtx op, enum machine_mode mode)\n-{\n-  return ext_low_reg_operand (op, mode) || par_ind_operand (op, mode);\n-}\n-\n-\n static void \n c4x_S_address_parse (rtx op, int *base, int *incdec, int *index, int *disp)\n {"}, {"sha": "e36fe43e2822e5f6da337b0d600ac8e00c3cb8d5", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -1667,41 +1667,6 @@ if (final_sequence != NULL_RTX)\t\t\t\t\\\n \n #define ASM_OUTPUT_ASM(FILE, STRING) fprintf (FILE, \"%s\\n\", STRING)\n \n-/* Define the codes that are matched by predicates in c4x.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\\\n-  {\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\\\n-  {\"const_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n-  {\"stik_const_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"not_const_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"reg_or_const_operand\", {REG, SUBREG, CONST_INT, CONST_DOUBLE}},\\\n-  {\"r0r1_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"r2r3_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"ext_low_reg_operand\", {REG, SUBREG}},\t\t\t\\\n-  {\"ext_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"std_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"std_or_reg_operand\", {REG, SUBREG}},\t\t\t\\\n-  {\"addr_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"index_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n-  {\"dp_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"sp_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"st_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"rc_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"call_address_operand\", {REG, SYMBOL_REF, LABEL_REF, CONST}}, \\\n-  {\"dst_operand\", {SUBREG, REG, MEM}}, \\\n-  {\"src_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"src_hi_operand\", {SUBREG, REG, MEM, CONST_DOUBLE}}, \t\\\n-  {\"lsrc_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"tsrc_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"nonimmediate_src_operand\", {SUBREG, REG, MEM}}, \t\t\\\n-  {\"nonimmediate_lsrc_operand\", {SUBREG, REG, MEM}}, \t\t\\\n-  {\"any_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"par_ind_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"parallel_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"symbolic_address_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\n-\n-\n /* Define the intrinsic functions for the c3x/c4x.  */\n \n enum c4x_builtins"}, {"sha": "f37a49bc36fcdeefe1571b18393e2dfaa1bb99f2", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description for the TMS320C[34]x for GCC\n ;; Copyright (C) 1994, 1995, 1996, 1997, 1998,\n-;; 1999, 2000, 2002, 2004 Free Software Foundation, Inc.\n+;; 1999, 2000, 2002, 2004, 2005 Free Software Foundation, Inc.\n \n ;; Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n ;;            and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl)\n@@ -907,6 +907,7 @@\n                             (const_int 1) (const_int 0))]\n              (const_int 0)))\n \n+(include \"predicates.md\")\n \n ;\n ; C4x INSN PATTERNS:"}, {"sha": "b36e349c3f44b5130deb30d9def99590fea456d2", "filename": "gcc/config/c4x/predicates.md", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47/gcc%2Fconfig%2Fc4x%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fpredicates.md?ref=9e9d785dcb02c60ea70a6b01c4dcde3f6c776e47", "patch": "@@ -0,0 +1,404 @@\n+;; Predicate definitions for TMS320C[34]x.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Nonzero if OP is a floating point value with value 0.0.\n+\n+(define_predicate \"fp_zero_operand\"\n+  (match_code \"const_double\")\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  if (GET_CODE (op) != CONST_DOUBLE)\n+    return 0;\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+  return REAL_VALUES_EQUAL (r, dconst0);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"const_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+  switch (mode)\n+    {\n+    case QFmode:\n+    case HFmode:\n+      if (GET_CODE (op) != CONST_DOUBLE\n+\t  || GET_MODE (op) != mode\n+\t  || GET_MODE_CLASS (mode) != MODE_FLOAT)\n+\treturn 0;\n+\n+      return c4x_immed_float_p (op);\n+\n+#if Pmode != QImode\n+    case Pmode:\n+#endif\n+    case QImode:\n+      if (GET_CODE (op) != CONST_INT\n+\t  || (GET_MODE (op) != VOIDmode && GET_MODE (op) != mode)\n+\t  || GET_MODE_CLASS (mode) != MODE_INT)\n+\treturn 0;\n+\n+      return IS_HIGH_CONST (INTVAL (op)) || IS_INT16_CONST (INTVAL (op));\n+\n+    case HImode:\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"stik_const_operand\"\n+  (match_code \"const_int\")\n+{\n+  return c4x_K_constant (op);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"not_const_operand\"\n+  (match_code \"const_int\")\n+{\n+  return c4x_N_constant (op);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG\n+      && GET_MODE (op) == QFmode)\n+    return 0;\n+  return register_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"reg_or_const_operand\"\n+  (match_code \"reg,subreg,const_int,const_double\")\n+{\n+  return reg_operand (op, mode) || const_operand (op, mode);\n+})\n+\n+;; Extended precision register R0-R1.\n+\n+(define_predicate \"r0r1_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_P (op) && IS_R0R1_OR_PSEUDO_REG (op);\n+})\n+\n+;; Extended precision register R2-R3.\n+\n+(define_predicate \"r2r3_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_P (op) && IS_R2R3_OR_PSEUDO_REG (op);\n+})\n+\n+;; Low extended precision register R0-R7.\n+\n+(define_predicate \"ext_low_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_P (op) && IS_EXT_LOW_OR_PSEUDO_REG (op);\n+})\n+\n+;; Extended precision register.\n+\n+(define_predicate \"ext_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (! REG_P (op))\n+    return 0;\n+  return IS_EXT_OR_PSEUDO_REG (op);\n+})\n+\n+;; Standard precision register.\n+\n+(define_predicate \"std_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_P (op) && IS_STD_OR_PSEUDO_REG (op);\n+})\n+\n+;; Standard precision or normal register.\n+\n+(define_predicate \"std_or_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (reload_in_progress)\n+    return std_reg_operand (op, mode);\n+  return reg_operand (op, mode);\n+})\n+\n+;; Address register.\n+\n+(define_predicate \"addr_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  return c4x_a_register (op);\n+})\n+\n+;; Index register.\n+\n+(define_predicate \"index_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (! reg_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return c4x_x_register (op);\n+})\n+\n+;; DP register.\n+\n+(define_predicate \"dp_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return REG_P (op) && IS_DP_OR_PSEUDO_REG (op);\n+})\n+\n+;; SP register.\n+\n+(define_predicate \"sp_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return REG_P (op) && IS_SP_OR_PSEUDO_REG (op);\n+})\n+\n+;; ST register.\n+\n+(define_predicate \"st_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return REG_P (op) && IS_ST_OR_PSEUDO_REG (op);\n+})\n+\n+;; RC register.\n+\n+(define_predicate \"rc_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return REG_P (op) && IS_RC_OR_PSEUDO_REG (op);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"call_address_operand\"\n+  (match_code \"reg,symbol_ref,label_ref,const\")\n+{\n+  return (REG_P (op) || symbolic_address_operand (op, mode));\n+})\n+\n+;; Check dst operand of a move instruction.\n+\n+(define_predicate \"dst_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_CODE (op) == SUBREG\n+      && mixed_subreg_operand (op, mode))\n+    return 0;\n+\n+  if (REG_P (op))\n+    return reg_operand (op, mode);\n+\n+  return nonimmediate_operand (op, mode);\n+})\n+\n+;; Check src operand of two operand arithmetic instructions.\n+\n+(define_predicate \"src_operand\"\n+  (match_code \"subreg,reg,mem,const_int,const_double\")\n+{\n+  if (GET_CODE (op) == SUBREG\n+      && mixed_subreg_operand (op, mode))\n+    return 0;\n+\n+  if (REG_P (op))\n+    return reg_operand (op, mode);\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return (mode == QImode || mode == Pmode || mode == HImode)\n+      && c4x_I_constant (op);\n+\n+  /* We don't like CONST_DOUBLE integers.  */\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return c4x_H_constant (op);\n+\n+  /* Disallow symbolic addresses.  Only the predicate\n+     symbolic_address_operand will match these.  */\n+  if (GET_CODE (op) == SYMBOL_REF\n+      || GET_CODE (op) == LABEL_REF\n+      || GET_CODE (op) == CONST)\n+    return 0;\n+\n+  /* If TARGET_LOAD_DIRECT_MEMS is nonzero, disallow direct memory\n+     access to symbolic addresses.  These operands will get forced\n+     into a register and the movqi expander will generate a\n+     HIGH/LO_SUM pair if TARGET_EXPOSE_LDP is nonzero.  */\n+  if (GET_CODE (op) == MEM\n+      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t   || GET_CODE (XEXP (op, 0)) == CONST)))\n+    return !TARGET_EXPOSE_LDP &&\n+      ! TARGET_LOAD_DIRECT_MEMS && GET_MODE (op) == mode;\n+\n+  return general_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"src_hi_operand\"\n+  (match_code \"subreg,reg,mem,const_double\")\n+{\n+  if (c4x_O_constant (op))\n+    return 1;\n+  return src_operand (op, mode);\n+})\n+\n+;; Check src operand of two operand logical instructions.\n+\n+(define_predicate \"lsrc_operand\"\n+  (match_code \"subreg,reg,mem,const_int,const_double\")\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (mode != QImode && mode != Pmode)\n+    fatal_insn (\"mode not QImode\", op);\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return c4x_L_constant (op) || c4x_J_constant (op);\n+\n+  return src_operand (op, mode);\n+})\n+\n+;; Check src operand of two operand tricky instructions.\n+\n+(define_predicate \"tsrc_operand\"\n+  (match_code \"subreg,reg,mem,const_int,const_double\")\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (mode != QImode && mode != Pmode)\n+    fatal_insn (\"mode not QImode\", op);\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return c4x_L_constant (op) || c4x_N_constant (op) || c4x_J_constant (op);\n+\n+  return src_operand (op, mode);\n+})\n+\n+;; Check src operand of two operand non immediate instructions.\n+\n+(define_predicate \"nonimmediate_src_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n+    return 0;\n+\n+  return src_operand (op, mode);\n+})\n+\n+;; Check logical src operand of two operand non immediate instructions.\n+\n+(define_predicate \"nonimmediate_lsrc_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n+    return 0;\n+\n+  return lsrc_operand (op, mode);\n+})\n+\n+;; Match any operand.\n+\n+(define_predicate \"any_operand\"\n+  (match_code \"subreg,reg,mem,const_int,const_double\")\n+{\n+  return 1;\n+})\n+\n+;; Check for indirect operands allowable in parallel instruction.\n+\n+(define_predicate \"par_ind_operand\"\n+  (match_code \"mem\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  return c4x_S_indirect (op);\n+})\n+\n+;; Check for operands allowable in parallel instruction.\n+\n+(define_predicate \"parallel_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  return ext_low_reg_operand (op, mode) || par_ind_operand (op, mode);\n+})\n+\n+;; Symbolic address operand.\n+\n+(define_predicate \"symbolic_address_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})"}]}