{"sha": "5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyNmFlMGM2ZWFmZDJiYmEwOWZjNjBhMjNjZDljMGIyOTI4NDZjNA==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2018-06-16T21:39:31Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2018-06-16T21:39:31Z"}, "message": "re PR middle-end/82479 (missing popcount builtin detection)\n\ngcc/ChangeLog:\n\n2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\tPR middle-end/82479\n\t* ipa-fnsummary.c (will_be_nonconstant_expr_predicate): Handle CALL_EXPR.\n\t* tree-scalar-evolution.c (interpret_expr): Likewise.\n\t(expression_expensive_p): Likewise.\n\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Likewise.\n\t* tree-ssa-loop-niter.c (number_of_iterations_popcount): New.\n\t(number_of_iterations_exit_assumptions): Use number_of_iterations_popcount.\n\t(ssa_defined_by_minus_one_stmt_p): New.\n\ngcc/testsuite/ChangeLog:\n\n2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\tPR middle-end/82479\n\t* gcc.dg/tree-ssa/popcount.c: New test.\n\t* gcc.dg/tree-ssa/popcount2.c: New test.\n\nFrom-SVN: r261682", "tree": {"sha": "e7ade1440d60638b78b1ca38cf5a18a29153c582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7ade1440d60638b78b1ca38cf5a18a29153c582"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/comments", "author": null, "committer": null, "parents": [{"sha": "e197e64ee8ab8e46de9069a8d951bed720a0fd67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e197e64ee8ab8e46de9069a8d951bed720a0fd67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e197e64ee8ab8e46de9069a8d951bed720a0fd67"}], "stats": {"total": 289, "additions": 288, "deletions": 1}, "files": [{"sha": "792200974e0ff8a42fbac7117c1652dbddb772fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -1,3 +1,14 @@\n+2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\tPR middle-end/82479\n+\t* ipa-fnsummary.c (will_be_nonconstant_expr_predicate): Handle CALL_EXPR.\n+\t* tree-scalar-evolution.c (interpret_expr): Likewise.\n+\t(expression_expensive_p): Likewise.\n+\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Likewise.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_popcount): New.\n+\t(number_of_iterations_exit_assumptions): Use number_of_iterations_popcount.\n+\t(ssa_defined_by_minus_one_stmt_p): New.\n+\n 2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/64946"}, {"sha": "504a2d1ce55a32c254cf96ebabe5266e6ce59a44", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -1487,6 +1487,8 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n \t\t\t\t\t       nonconstant_names);\n       return p2.or_with (summary->conds, p1);\n     }\n+  else if (TREE_CODE (expr) == CALL_EXPR)\n+    return true;\n   else\n     {\n       debug_tree (expr);"}, {"sha": "1b6e062db5069e286296f6b55ea4dfac708797a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -1,3 +1,9 @@\n+2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\tPR middle-end/82479\n+\t* gcc.dg/tree-ssa/popcount.c: New test.\n+\t* gcc.dg/tree-ssa/popcount2.c: New test.\n+\n 2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/64946"}, {"sha": "a5ec3b34f962de8b5658e41082559d68c1101320", "filename": "gcc/testsuite/gcc.dg/tree-ssa/popcount.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized -fno-tree-ch\" } */\n+\n+extern int foo (int);\n+\n+int PopCount (long b) {\n+    int c = 0;\n+    b++;\n+\n+    while (b) {\n+\tb &= b - 1;\n+\tc++;\n+    }\n+    return c;\n+}\n+int PopCount2 (long b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb &= b - 1;\n+\tc++;\n+    }\n+    foo (c);\n+    return foo (c);\n+}\n+\n+void PopCount3 (long b1) {\n+\n+    for (long i = 0; i < b1; ++i)\n+      {\n+\tlong b = i;\n+\tint c = 0;\n+\twhile (b) {\n+\t    b &= b - 1;\n+\t    c++;\n+\t}\n+\tfoo (c);\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_popcount\" 3 \"optimized\" } } */"}, {"sha": "9096c6bee04e27b6ec7e23fb86bc6b9a3e1f4406", "filename": "gcc/testsuite/gcc.dg/tree-ssa/popcount2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount2.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-ch -fdump-tree-optimized\" } */\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (long b)\n+{\n+    int c = 0;\n+\n+    while (b) {\n+\tb &= b - 1;\n+\tc++;\n+    }\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo (7) != 3)\n+   __builtin_abort ();\n+  if (foo (0) != 0)\n+   __builtin_abort ();\n+  if (foo (0xff) != 8)\n+   __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_popcount\" 1 \"optimized\" } } */"}, {"sha": "4b0ec02b4de5e397ae57c442896e65d156fd38ab", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -281,6 +281,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"gimple-fold.h\"\n #include \"tree-into-ssa.h\"\n+#include \"builtins.h\"\n \n static tree analyze_scalar_evolution_1 (struct loop *, tree);\n static tree analyze_scalar_evolution_for_address_of (struct loop *loop,\n@@ -1984,6 +1985,7 @@ interpret_expr (struct loop *loop, gimple *at_stmt, tree expr)\n     return expr;\n \n   if (TREE_CODE (expr) == POLYNOMIAL_CHREC\n+      || TREE_CODE (expr) == CALL_EXPR\n       || get_gimple_rhs_class (TREE_CODE (expr)) == GIMPLE_TERNARY_RHS)\n     return chrec_dont_know;\n \n@@ -3493,6 +3495,19 @@ expression_expensive_p (tree expr)\n \treturn true;\n     }\n \n+  if (code == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+\n+      if (!is_inexpensive_builtin (get_callee_fndecl (expr)))\n+\treturn true;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n+\tif (expression_expensive_p (arg))\n+\t  return true;\n+      return false;\n+    }\n+\n   switch (TREE_CODE_CLASS (code))\n     {\n     case tcc_binary:"}, {"sha": "519649a3a978d83ff1654d71850ef4e614230c22", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -985,6 +985,16 @@ contains_abnormal_ssa_name_p (tree expr)\n   code = TREE_CODE (expr);\n   codeclass = TREE_CODE_CLASS (code);\n \n+  if (code == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n+\tif (contains_abnormal_ssa_name_p (arg))\n+\t  return true;\n+      return false;\n+    }\n+\n   if (code == SSA_NAME)\n     return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (expr) != 0;\n "}, {"sha": "936591502d0b3f7232f9500175e8311a61895c59", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 175, "deletions": 1, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5126ae0c6eafd2bba09fc60a23cd9c0b292846c4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=5126ae0c6eafd2bba09fc60a23cd9c0b292846c4", "patch": "@@ -63,6 +63,10 @@ struct bounds\n   mpz_t below, up;\n };\n \n+static bool number_of_iterations_popcount (loop_p loop, edge exit,\n+\t\t\t\t\t   enum tree_code code,\n+\t\t\t\t\t   struct tree_niter_desc *niter);\n+\n \n /* Splits expression EXPR to a variable part VAR and constant OFFSET.  */\n \n@@ -2357,7 +2361,7 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n   tree iv0_niters = NULL_TREE;\n   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n \t\t\t      op0, &iv0, safe ? &iv0_niters : NULL, false))\n-    return false;\n+    return number_of_iterations_popcount (loop, exit, code, niter);\n   tree iv1_niters = NULL_TREE;\n   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n \t\t\t      op1, &iv1, safe ? &iv1_niters : NULL, false))\n@@ -2430,6 +2434,176 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n   return (!integer_zerop (niter->assumptions));\n }\n \n+\n+/* Utility function to check if OP is defined by a stmt\n+   that is a val - 1.  */\n+\n+static bool\n+ssa_defined_by_minus_one_stmt_p (tree op, tree val)\n+{\n+  gimple *stmt;\n+  return (TREE_CODE (op) == SSA_NAME\n+\t  && (stmt = SSA_NAME_DEF_STMT (op))\n+\t  && is_gimple_assign (stmt)\n+\t  && (gimple_assign_rhs_code (stmt) == PLUS_EXPR)\n+\t  && val == gimple_assign_rhs1 (stmt)\n+\t  && integer_minus_onep (gimple_assign_rhs2 (stmt)));\n+}\n+\n+\n+/* See if LOOP is a popcout implementation, determine NITER for the loop\n+\n+   We match:\n+   <bb 2>\n+   goto <bb 4>\n+\n+   <bb 3>\n+   _1 = b_11 + -1\n+   b_6 = _1 & b_11\n+\n+   <bb 4>\n+   b_11 = PHI <b_5(D)(2), b_6(3)>\n+\n+   exit block\n+   if (b_11 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 5>\n+\n+   OR we match copy-header version:\n+   if (b_5 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 4>\n+\n+   <bb 3>\n+   b_11 = PHI <b_5(2), b_6(3)>\n+   _1 = b_11 + -1\n+   b_6 = _1 & b_11\n+\n+   exit block\n+   if (b_6 != 0)\n+\tgoto <bb 3>\n+   else\n+\tgoto <bb 4>\n+\n+   If popcount pattern, update NITER accordingly.\n+   i.e., set NITER to  __builtin_popcount (b)\n+   return true if we did, false otherwise.\n+\n+ */\n+\n+static bool\n+number_of_iterations_popcount (loop_p loop, edge exit,\n+\t\t\t       enum tree_code code,\n+\t\t\t       struct tree_niter_desc *niter)\n+{\n+  bool adjust = true;\n+  tree iter;\n+  HOST_WIDE_INT max;\n+  adjust = true;\n+  tree fn = NULL_TREE;\n+\n+  /* Check loop terminating branch is like\n+     if (b != 0).  */\n+  gimple *stmt = last_stmt (exit->src);\n+  if (!stmt\n+      || gimple_code (stmt) != GIMPLE_COND\n+      || code != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (stmt))\n+      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME)\n+    return false;\n+\n+  gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n+\n+  /* Depending on copy-header is performed, feeding PHI stmts might be in\n+     the loop header or loop latch, handle this.  */\n+  if (gimple_code (and_stmt) == GIMPLE_PHI\n+      && gimple_bb (and_stmt) == loop->header\n+      && gimple_phi_num_args (and_stmt) == 2\n+      && (TREE_CODE (gimple_phi_arg_def (and_stmt,\n+\t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n+\t  == SSA_NAME))\n+    {\n+      /* SSA used in exit condition is defined by PHI stmt\n+\tb_11 = PHI <b_5(D)(2), b_6(3)>\n+\tfrom the PHI stmt, get the and_stmt\n+\tb_6 = _1 & b_11.  */\n+      tree t = gimple_phi_arg_def (and_stmt, loop_latch_edge (loop)->dest_idx);\n+      and_stmt = SSA_NAME_DEF_STMT (t);\n+      adjust = false;\n+    }\n+\n+  /* Make sure it is indeed an and stmt (b_6 = _1 & b_11).  */\n+  if (!is_gimple_assign (and_stmt)\n+      || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR)\n+    return false;\n+\n+  tree b_11 = gimple_assign_rhs1 (and_stmt);\n+  tree _1 = gimple_assign_rhs2 (and_stmt);\n+\n+  /* Check that _1 is defined by _b11 + -1 (_1 = b_11 + -1).\n+     Also make sure that b_11 is the same in and_stmt and _1 defining stmt.\n+     Also canonicalize if _1 and _b11 are revrsed.  */\n+  if (ssa_defined_by_minus_one_stmt_p (b_11, _1))\n+    std::swap (b_11, _1);\n+  else if (ssa_defined_by_minus_one_stmt_p (_1, b_11))\n+    ;\n+  else\n+    return false;\n+  /* Check the recurrence:\n+   ... = PHI <b_5(2), b_6(3)>.  */\n+  gimple *phi = SSA_NAME_DEF_STMT (b_11);\n+  if (gimple_code (phi) != GIMPLE_PHI\n+      || (gimple_assign_lhs (and_stmt)\n+\t  != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n+    return false;\n+\n+  /* We found a match. Get the corresponding popcount builtin.  */\n+  tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n+  if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION (integer_type_node))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n+  else if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION\n+\t   (long_integer_type_node))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n+  else if (TYPE_PRECISION (TREE_TYPE (src)) == TYPE_PRECISION\n+\t   (long_long_integer_type_node))\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n+\n+  /* ??? Support promoting char/short to int.  */\n+  if (!fn)\n+    return false;\n+\n+  /* Update NITER params accordingly  */\n+  max = TYPE_PRECISION (TREE_TYPE (src));\n+  if (adjust)\n+    max = max - 1;\n+  tree utype = unsigned_type_for (TREE_TYPE (src));\n+  src = fold_convert (utype, src);\n+  tree call = fold_convert (utype, build_call_expr (fn, 1, src));\n+  if (adjust)\n+    iter = fold_build2 (MINUS_EXPR, utype,\n+\t\t\tcall,\n+\t\t\tbuild_int_cst (utype, 1));\n+  else\n+    iter = call;\n+\n+  niter->niter = iter;\n+  niter->assumptions = boolean_true_node;\n+  if (adjust)\n+    niter->may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst\n+\t\t\t\t      (TREE_TYPE (src)));\n+  else\n+    niter->may_be_zero = boolean_false_node;\n+\n+  niter->max = max;\n+  niter->bound = NULL_TREE;\n+  niter->cmp = ERROR_MARK;\n+  return true;\n+}\n+\n+\n /* Like number_of_iterations_exit_assumptions, but return TRUE only if\n    the niter information holds unconditionally.  */\n "}]}