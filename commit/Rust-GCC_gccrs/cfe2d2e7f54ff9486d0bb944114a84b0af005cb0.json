{"sha": "cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlMmQyZTdmNTRmZjk0ODZkMGJiOTQ0MTE0YTg0YjBhZjAwNWNiMA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-08-06T20:55:42Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "1999-08-06T20:55:42Z"}, "message": "jump.c (delete_prior_computation): New function, broken out of delete_computation.\n\n\t* jump.c (delete_prior_computation): New function, broken\n\tout of delete_computation.  Check for side effects with\n\tside_effects_p instead of FIND_REG_INC_NOTE.  Handle\n\tmulti-word hard registers.\n\t(delete_computation): Use it.  Check for side effects with\n\tside_effects_p instead of FIND_REG_INC_NOTE.  Synthesize a\n\tmissing REG_DEAD note for a register which is both set and\n\tused by an insn.\n\nFrom-SVN: r28558", "tree": {"sha": "c9e49ce0e35126f96b71b54e488a5dd288c21414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9e49ce0e35126f96b71b54e488a5dd288c21414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fabe028e0bf93a4a13b02c67e8a30565ee84ce3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fabe028e0bf93a4a13b02c67e8a30565ee84ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fabe028e0bf93a4a13b02c67e8a30565ee84ce3"}], "stats": {"total": 191, "additions": 133, "deletions": 58}, "files": [{"sha": "39868c765ec360d173f151574b8f7d6a5e544ea2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "patch": "@@ -1,3 +1,14 @@\n+Fri Aug  6 16:53:55 EDT 1999  John Wehle  (john@feith.com)\n+\n+\t* jump.c (delete_prior_computation): New function, broken\n+\tout of delete_computation.  Check for side effects with\n+\tside_effects_p instead of FIND_REG_INC_NOTE.  Handle\n+\tmulti-word hard registers.\n+\t(delete_computation): Use it.  Check for side effects with\n+\tside_effects_p instead of FIND_REG_INC_NOTE.  Synthesize a\n+\tmissing REG_DEAD note for a register which is both set and\n+\tused by an insn.\n+\n Fri Aug  6 11:05:29 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* elf.h (TEXT_SPACE_P, FUNCTION_NAME_P): Delete."}, {"sha": "37298f038b3a5854833de0eff93a38b4d3798889", "filename": "gcc/jump.c", "status": "modified", "additions": 122, "deletions": 58, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe2d2e7f54ff9486d0bb944114a84b0af005cb0/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=cfe2d2e7f54ff9486d0bb944114a84b0af005cb0", "patch": "@@ -3811,6 +3811,112 @@ delete_jump (insn)\n     delete_computation (insn);\n }\n \n+/* Recursively delete prior insns that compute the value (used only by INSN\n+   which the caller is deleting) stored in the register mentioned by NOTE\n+   which is a REG_DEAD note associated with INSN.  */\n+\n+static void\n+delete_prior_computation (note, insn)\n+     rtx note;\n+     rtx insn;\n+{\n+  rtx our_prev;\n+  rtx reg = XEXP (note, 0);\n+\n+  for (our_prev = prev_nonnote_insn (insn);\n+       our_prev && GET_CODE (our_prev) == INSN;\n+       our_prev = prev_nonnote_insn (our_prev))\n+    {\n+      rtx pat = PATTERN (our_prev);\n+\n+      /* If we reach a SEQUENCE, it is too complex to try to\n+\t do anything with it, so give up.  */\n+      if (GET_CODE (pat) == SEQUENCE)\n+\tbreak;\n+\n+      if (GET_CODE (pat) == USE\n+\t  && GET_CODE (XEXP (pat, 0)) == INSN)\n+\t/* reorg creates USEs that look like this.  We leave them\n+\t   alone because reorg needs them for its own purposes.  */\n+\tbreak;\n+\n+      if (reg_set_p (reg, pat))\n+\t{\n+\t  if (side_effects_p (pat))\n+\t    break;\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* If we find a SET of something else, we can't\n+\t\t delete the insn.  */\n+\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t\t{\n+\t\t  rtx part = XVECEXP (pat, 0, i);\n+\n+\t\t  if (GET_CODE (part) == SET\n+\t\t      && SET_DEST (part) != reg)\n+\t\t    break;\n+\t\t}\n+\n+\t      if (i == XVECLEN (pat, 0))\n+\t\tdelete_computation (our_prev);\n+\t    }\n+\t  else if (GET_CODE (pat) == SET\n+\t\t   && GET_CODE (SET_DEST (pat)) == REG)\n+\t    {\n+\t      int dest_regno = REGNO (SET_DEST (pat));\n+\t      int dest_endregno\n+\t\t    = dest_regno + (dest_regno < FIRST_PSEUDO_REGISTER \n+\t\t      ? HARD_REGNO_NREGS (dest_regno,\n+\t\t\t\tGET_MODE (SET_DEST (pat))) : 1);\n+\t      int regno = REGNO (reg);\n+\t      int endregno = regno + (regno < FIRST_PSEUDO_REGISTER \n+\t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (reg)) : 1);\n+\n+\t      if (dest_regno >= regno\n+\t\t  && dest_endregno <= endregno)\n+\t\tdelete_computation (our_prev);\n+\n+\t      /* We may have a multi-word hard register and some, but not\n+\t\t all, of the words of the register are needed in subsequent\n+\t\t insns.  Write REG_UNUSED notes for those parts that were not\n+\t\t needed.  */\n+\t      else if (dest_regno <= regno\n+\t\t       && dest_endregno >= endregno\n+\t\t       && ! find_regno_note (our_prev, REG_UNUSED, REGNO(reg)))\n+\t\t{\n+\t\t  int i;\n+\n+\t\t  REG_NOTES (our_prev)\n+\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (our_prev));\n+\n+\t\t  for (i = dest_regno; i < dest_endregno; i++)\n+\t\t    if (! find_regno_note (our_prev, REG_UNUSED, i))\n+\t\t      break;\n+\n+\t\t  if (i == dest_endregno)\n+\t\t    delete_computation (our_prev);\n+\t\t}\n+\t    }\n+\n+\t  break;\n+\t}\n+\n+      /* If PAT references the register that dies here, it is an\n+\t additional use.  Hence any prior SET isn't dead.  However, this\n+\t insn becomes the new place for the REG_DEAD note.  */\n+      if (reg_overlap_mentioned_p (reg, pat))\n+\t{\n+\t  XEXP (note, 1) = REG_NOTES (our_prev);\n+\t  REG_NOTES (our_prev) = note;\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Delete INSN and recursively delete insns that compute values used only\n    by INSN.  This uses the REG_DEAD notes computed during flow analysis.\n    If we are running before flow.c, we need do nothing since flow.c will\n@@ -3829,6 +3935,7 @@ delete_computation (insn)\n      rtx insn;\n {\n   rtx note, next;\n+  rtx set;\n \n #ifdef HAVE_cc0\n   if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n@@ -3844,7 +3951,7 @@ delete_computation (insn)\n \t  && sets_cc0_p (PATTERN (prev)))\n \t{\n \t  if (sets_cc0_p (PATTERN (prev)) > 0\n-\t      && !FIND_REG_INC_NOTE (prev, NULL_RTX))\n+\t      && ! side_effects_p (PATTERN (prev)))\n \t    delete_computation (prev);\n \t  else\n \t    /* Otherwise, show that cc0 won't be used.  */\n@@ -3865,74 +3972,31 @@ delete_computation (insn)\n     }\n #endif\n \n+  set = single_set (insn);\n+\n   for (note = REG_NOTES (insn); note; note = next)\n     {\n-      rtx our_prev;\n-\n       next = XEXP (note, 1);\n \n       if (REG_NOTE_KIND (note) != REG_DEAD\n \t  /* Verify that the REG_NOTE is legitimate.  */\n \t  || GET_CODE (XEXP (note, 0)) != REG)\n \tcontinue;\n \n-      for (our_prev = prev_nonnote_insn (insn);\n-\t   our_prev && GET_CODE (our_prev) == INSN;\n-\t   our_prev = prev_nonnote_insn (our_prev))\n-\t{\n-\t  /* If we reach a SEQUENCE, it is too complex to try to\n-\t     do anything with it, so give up.  */\n-\t  if (GET_CODE (PATTERN (our_prev)) == SEQUENCE)\n-\t    break;\n-\n-\t  if (GET_CODE (PATTERN (our_prev)) == USE\n-\t      && GET_CODE (XEXP (PATTERN (our_prev), 0)) == INSN)\n-\t    /* reorg creates USEs that look like this.  We leave them\n-\t       alone because reorg needs them for its own purposes.  */\n-\t    break;\n-\n-\t  if (reg_set_p (XEXP (note, 0), PATTERN (our_prev)))\n-\t    {\n-\t      if (FIND_REG_INC_NOTE (our_prev, NULL_RTX))\n-\t\tbreak;\n-\n-\t      if (GET_CODE (PATTERN (our_prev)) == PARALLEL)\n-\t\t{\n-\t\t  /* If we find a SET of something else, we can't\n-\t\t     delete the insn.  */\n-\n-\t\t  int i;\n-\n-\t\t  for (i = 0; i < XVECLEN (PATTERN (our_prev), 0); i++)\n-\t\t    {\n-\t\t      rtx part = XVECEXP (PATTERN (our_prev), 0, i);\n-\n-\t\t      if (GET_CODE (part) == SET\n-\t\t\t  && SET_DEST (part) != XEXP (note, 0))\n-\t\t\tbreak;\n-\t\t    }\n+      if (set && reg_overlap_mentioned_p (SET_DEST (set), XEXP (note, 0)))\n+\tset = NULL_RTX;\n \n-\t\t  if (i == XVECLEN (PATTERN (our_prev), 0))\n-\t\t    delete_computation (our_prev);\n-\t\t}\n-\t      else if (GET_CODE (PATTERN (our_prev)) == SET\n-\t\t       && SET_DEST (PATTERN (our_prev)) == XEXP (note, 0))\n-\t\tdelete_computation (our_prev);\n-\n-\t      break;\n-\t    }\n+      delete_prior_computation (note, insn);\n+    }\n \n-\t  /* If OUR_PREV references the register that dies here, it is an\n-\t     additional use.  Hence any prior SET isn't dead.  However, this\n-\t     insn becomes the new place for the REG_DEAD note.  */\n-\t  if (reg_overlap_mentioned_p (XEXP (note, 0),\n-\t\t\t\t       PATTERN (our_prev)))\n-\t    {\n-\t      XEXP (note, 1) = REG_NOTES (our_prev);\n-\t      REG_NOTES (our_prev) = note;\n-\t      break;\n-\t    }\n-\t}\n+  /* The REG_DEAD note may have been omitted for a register\n+     which is both set and used by the insn.  */\n+  if (set\n+      && GET_CODE (SET_DEST (set)) == REG\n+      && reg_mentioned_p (SET_DEST (set), SET_SRC (set)))\n+    {\n+      note = gen_rtx_EXPR_LIST (REG_DEAD, SET_DEST (set), NULL_RTX);\n+      delete_prior_computation (note, insn);\n     }\n \n   delete_insn (insn);"}]}