{"sha": "9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZkMWVjMzM3MTBhZGQ4MGZiOGVmYmU3ZWYzMWEwYWI5MmQwNTQwZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T17:49:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T17:49:07Z"}, "message": "compiler: implement //go:nowritebarrierrec\n    \n    Reviewed-on: https://go-review.googlesource.com/134228\n\nFrom-SVN: r264283", "tree": {"sha": "4209f3db4df15a319a10803731dc95a5fdb863ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4209f3db4df15a319a10803731dc95a5fdb863ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/comments", "author": null, "committer": null, "parents": [{"sha": "f0d89c7759e7be18895868e0c4e7f9e120f7890f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d89c7759e7be18895868e0c4e7f9e120f7890f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d89c7759e7be18895868e0c4e7f9e120f7890f"}], "stats": {"total": 182, "additions": 168, "deletions": 14}, "files": [{"sha": "3d640b2dc088e76519cc5b54d5edfea26695c507", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -1,4 +1,4 @@\n-baf07c40960dc4f8df9da97281870d80d4245b18\n+f68c03e509b26e7f483f2800eb70a5fbf3f74d0b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0864ee1d72a8d41fee3a851ba4e073bad8595b75", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -941,6 +941,9 @@ class Gogo\n                    std::vector<Bstatement*>&,\n                    Bfunction* init_bfunction);\n \n+  void\n+  propagate_writebarrierrec();\n+\n   Named_object*\n   write_barrier_variable();\n "}, {"sha": "3965f30d80810d556630817966840ac043a2e945", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -1922,9 +1922,15 @@ Lex::skip_cpp_comment()\n       // function that it calls, needs to use any write barriers, it\n       // should emit an error instead.\n       // FIXME: Should only work when compiling the runtime package.\n-      // FIXME: currently treated the same as go:nowritebarrier\n       this->pragmas_ |= GOPRAGMA_NOWRITEBARRIERREC;\n     }\n+  else if (verb == \"go:yeswritebarrierrec\")\n+    {\n+      // Applies to the next function.  Disables go:nowritebarrierrec\n+      // when looking at callees; write barriers are permitted here.\n+      // FIXME: Should only work when compiling the runtime package.\n+      this->pragmas_ |= GOPRAGMA_YESWRITEBARRIERREC;\n+    }\n   else if (verb == \"go:cgo_unsafe_args\")\n     {\n       // Applies to the next function.  Taking the address of any"}, {"sha": "70f752b7326d298048ffd452cbe9939fad031be1", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -63,9 +63,11 @@ enum GoPragma\n   GOPRAGMA_SYSTEMSTACK = 1 << 5,\t// Must run on system stack.\n   GOPRAGMA_NOWRITEBARRIER = 1 << 6,\t// No write barriers.\n   GOPRAGMA_NOWRITEBARRIERREC = 1 << 7,\t// No write barriers here or callees.\n-  GOPRAGMA_CGOUNSAFEARGS = 1 << 8,\t// Pointer to arg is pointer to all.\n-  GOPRAGMA_UINTPTRESCAPES = 1 << 9,\t// uintptr(p) escapes.\n-  GOPRAGMA_NOTINHEAP = 1 << 10\t\t// type is not in heap.\n+  GOPRAGMA_YESWRITEBARRIERREC = 1 << 8,\t// Stops nowritebarrierrec.\n+  GOPRAGMA_MARK = 1 << 9,\t\t// Marker for nowritebarrierrec.\n+  GOPRAGMA_CGOUNSAFEARGS = 1 << 10,\t// Pointer to arg is pointer to all.\n+  GOPRAGMA_UINTPTRESCAPES = 1 << 11,\t// uintptr(p) escapes.\n+  GOPRAGMA_NOTINHEAP = 1 << 12\t\t// type is not in heap.\n };\n \n // A token returned from the lexer."}, {"sha": "cc901dbfc8435160702b2b479e58d7bc5abb25fd", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -2360,7 +2360,10 @@ Parse::function_decl(unsigned int pragmas)\n \t{ GOPRAGMA_NOINLINE, \"noinline\", false, true, true },\n \t{ GOPRAGMA_SYSTEMSTACK, \"systemstack\", false, true, true },\n \t{ GOPRAGMA_NOWRITEBARRIER, \"nowritebarrier\", false, true, true },\n-\t{ GOPRAGMA_NOWRITEBARRIERREC, \"nowritebarrierrec\", false, true, true },\n+\t{ GOPRAGMA_NOWRITEBARRIERREC, \"nowritebarrierrec\", false, true,\n+\t  true },\n+\t{ GOPRAGMA_YESWRITEBARRIERREC, \"yeswritebarrierrec\", false, true,\n+\t  true },\n \t{ GOPRAGMA_CGOUNSAFEARGS, \"cgo_unsafe_args\", false, true, true },\n \t{ GOPRAGMA_UINTPTRESCAPES, \"uintptrescapes\", true, true, true },\n       };"}, {"sha": "4944b68fccf7d741003d7be9dc02923bc455544a", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 148, "deletions": 8, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd1ec33710add80fb8efbe7ef31a0ab92d0540f/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=9fd1ec33710add80fb8efbe7ef31a0ab92d0540f", "patch": "@@ -231,6 +231,133 @@ Check_escape::expression(Expression** pexpr)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Collect all writebarrierrec functions.  This is used when compiling\n+// the runtime package, to propagate //go:nowritebarrierrec.\n+\n+class Collect_writebarrierrec_functions : public Traverse\n+{\n+ public:\n+  Collect_writebarrierrec_functions(std::vector<Named_object*>* worklist)\n+    : Traverse(traverse_functions),\n+      worklist_(worklist)\n+  { }\n+\n+ private:\n+  int\n+  function(Named_object*);\n+\n+  // The collected functions are put here.\n+  std::vector<Named_object*>* worklist_;\n+};\n+\n+int\n+Collect_writebarrierrec_functions::function(Named_object* no)\n+{\n+  if (no->is_function()\n+      && no->func_value()->enclosing() == NULL\n+      && (no->func_value()->pragmas() & GOPRAGMA_NOWRITEBARRIERREC) != 0)\n+    {\n+      go_assert((no->func_value()->pragmas() & GOPRAGMA_MARK) == 0);\n+      this->worklist_->push_back(no);\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Collect all callees of this function.  We only care about locally\n+// defined, known, functions.\n+\n+class Collect_callees : public Traverse\n+{\n+ public:\n+  Collect_callees(std::vector<Named_object*>* worklist)\n+    : Traverse(traverse_expressions),\n+      worklist_(worklist)\n+  { }\n+\n+ private:\n+  int\n+  expression(Expression**);\n+\n+  // The collected callees are put here.\n+  std::vector<Named_object*>* worklist_;\n+};\n+\n+int\n+Collect_callees::expression(Expression** pexpr)\n+{\n+  Call_expression* ce = (*pexpr)->call_expression();\n+  if (ce != NULL)\n+    {\n+      Func_expression* fe = ce->fn()->func_expression();\n+      if (fe != NULL)\n+\t{\n+\t  Named_object* no = fe->named_object();\n+\t  if (no->package() == NULL && no->is_function())\n+\t    {\n+\t      // The function runtime.systemstack is special, in that\n+\t      // it is a common way to call a function in the runtime:\n+\t      // mark its argument if we can.\n+\t      if (Gogo::unpack_hidden_name(no->name()) != \"systemstack\")\n+\t\tthis->worklist_->push_back(no);\n+\t      else if (ce->args()->size() > 0)\n+\t\t{\n+\t\t  fe = ce->args()->front()->func_expression();\n+\t\t  if (fe != NULL)\n+\t\t    {\n+\t\t      no = fe->named_object();\n+\t\t      if (no->package() == NULL && no->is_function())\n+\t\t\tthis->worklist_->push_back(no);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// When compiling the runtime package, propagate //go:nowritebarrierrec\n+// annotations.  A function marked as //go:nowritebarrierrec does not\n+// permit write barriers, and also all the functions that it calls,\n+// recursively, do not permit write barriers.  Except that a\n+// //go:yeswritebarrierrec annotation permits write barriers even if\n+// called by a //go:nowritebarrierrec function.  Here we turn\n+// //go:nowritebarrierrec into //go:nowritebarrier, as appropriate.\n+\n+void\n+Gogo::propagate_writebarrierrec()\n+{\n+  std::vector<Named_object*> worklist;\n+  Collect_writebarrierrec_functions cwf(&worklist);\n+  this->traverse(&cwf);\n+\n+  Collect_callees cc(&worklist);\n+\n+  while (!worklist.empty())\n+    {\n+      Named_object* no = worklist.back();\n+      worklist.pop_back();\n+\n+      unsigned int pragmas = no->func_value()->pragmas();\n+      if ((pragmas & GOPRAGMA_MARK) != 0)\n+\t{\n+\t  // We've already seen this function.\n+\t  continue;\n+\t}\n+      if ((pragmas & GOPRAGMA_YESWRITEBARRIERREC) != 0)\n+\t{\n+\t  // We don't want to propagate //go:nowritebarrierrec into\n+\t  // this function or it's callees.\n+\t  continue;\n+\t}\n+\n+      no->func_value()->set_pragmas(pragmas\n+\t\t\t\t    | GOPRAGMA_NOWRITEBARRIER\n+\t\t\t\t    | GOPRAGMA_MARK);\n+\n+      no->func_value()->traverse(&cc);\n+    }\n+}\n+\n // Add write barriers to the IR.  This are required by the concurrent\n // garbage collector.  A write barrier is needed for any write of a\n // pointer into memory controlled by the garbage collector.  Write\n@@ -492,6 +619,8 @@ Gogo::add_write_barriers()\n \n   if (this->compiling_runtime() && this->package_name() == \"runtime\")\n     {\n+      this->propagate_writebarrierrec();\n+\n       Check_escape chk(this);\n       this->traverse(&chk);\n     }\n@@ -536,8 +665,8 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n   if (!lhs->type()->has_pointer())\n     return false;\n \n-  // An assignment to a field is handled like an assignment to the\n-  // struct.\n+  // An assignment to a field or an array index is handled like an\n+  // assignment to the struct.\n   while (true)\n     {\n       // Nothing to do for a type that can not be in the heap, or a\n@@ -550,9 +679,22 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n \treturn false;\n \n       Field_reference_expression* fre = lhs->field_reference_expression();\n-      if (fre == NULL)\n-\tbreak;\n-      lhs = fre->expr();\n+      if (fre != NULL)\n+\t{\n+\t  lhs = fre->expr();\n+\t  continue;\n+\t}\n+\n+      Array_index_expression* aie = lhs->array_index_expression();\n+      if (aie != NULL\n+\t  && aie->end() == NULL\n+\t  && !aie->array()->type()->is_slice_type())\n+\t{\n+\t  lhs = aie->array();\n+\t  continue;\n+\t}\n+\n+      break;\n     }\n \n   // Nothing to do for an assignment to a temporary.\n@@ -620,9 +762,7 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n \t\t\t\tStatement_inserter* inserter, Expression* lhs,\n \t\t\t\tExpression* rhs, Location loc)\n {\n-  if (function != NULL\n-      && ((function->pragmas() & GOPRAGMA_NOWRITEBARRIER) != 0\n-\t  || (function->pragmas() & GOPRAGMA_NOWRITEBARRIERREC) != 0))\n+  if (function != NULL && (function->pragmas() & GOPRAGMA_NOWRITEBARRIER) != 0)\n     go_error_at(loc, \"write barrier prohibited\");\n \n   Type* type = lhs->type();"}]}