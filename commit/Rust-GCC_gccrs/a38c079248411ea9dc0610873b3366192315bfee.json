{"sha": "a38c079248411ea9dc0610873b3366192315bfee", "node_id": "C_kwDOANBUbNoAKGEzOGMwNzkyNDg0MTFlYTlkYzA2MTA4NzNiMzM2NjE5MjMxNWJmZWU", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2023-01-16T17:48:25Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2023-01-19T14:18:14Z"}, "message": "aarch64: fix ICE in aarch64_layout_arg [PR108411]\n\nThe previous patch added an assert which should not be applied to PST\ntypes (Pure Scalable Types) because alignment does not matter in this\ncase.  This patch moves the assert after the PST case is handled to\navoid the ICE.\n\n\tPR target/108411\n\tgcc/\n\t* config/aarch64/aarch64.cc (aarch64_layout_arg): Improve\n\tcomment. Move assert about alignment a bit later.", "tree": {"sha": "b3305f8615a6718963d45b366e17738a328408d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3305f8615a6718963d45b366e17738a328408d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a38c079248411ea9dc0610873b3366192315bfee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38c079248411ea9dc0610873b3366192315bfee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38c079248411ea9dc0610873b3366192315bfee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38c079248411ea9dc0610873b3366192315bfee/comments", "author": null, "committer": null, "parents": [{"sha": "1cfaaa42296298ea2d2b22a93d3c8c17104e6cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfaaa42296298ea2d2b22a93d3c8c17104e6cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfaaa42296298ea2d2b22a93d3c8c17104e6cd3"}], "stats": {"total": 27, "additions": 20, "deletions": 7}, "files": [{"sha": "d55c250870ad161af72f70f63b22ab471fca3a86", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38c079248411ea9dc0610873b3366192315bfee/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38c079248411ea9dc0610873b3366192315bfee/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=a38c079248411ea9dc0610873b3366192315bfee", "patch": "@@ -7659,7 +7659,18 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n        && (currently_expanding_function_start\n \t   || currently_expanding_gimple_stmt));\n \n-  /* There are several things to note here:\n+  /* HFAs and HVAs can have an alignment greater than 16 bytes.  For example:\n+\n+       typedef struct foo {\n+         __Int8x16_t foo[2] __attribute__((aligned(32)));\n+       } foo;\n+\n+     is still a HVA despite its larger-than-normal alignment.\n+     However, such over-aligned HFAs and HVAs are guaranteed to have\n+     no padding.\n+\n+     If we exclude HFAs and HVAs from the discussion below, then there\n+     are several things to note:\n \n      - Both the C and AAPCS64 interpretations of a type's alignment should\n        give a value that is no greater than the type's size.\n@@ -7704,12 +7715,6 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n        would treat the alignment as though it was *equal to* 16 bytes.\n \n      Both behaviors were wrong, but in different cases.  */\n-  unsigned int alignment\n-    = aarch64_function_arg_alignment (mode, type, &abi_break,\n-\t\t\t\t      &abi_break_packed);\n-  gcc_assert (alignment <= 16 * BITS_PER_UNIT\n-\t      && (!alignment || abi_break < alignment)\n-\t      && (!abi_break_packed || alignment < abi_break_packed));\n \n   pcum->aapcs_arg_processed = true;\n \n@@ -7780,6 +7785,14 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n \t\t\t\t\t\t &nregs);\n   gcc_assert (!sve_p || !allocate_nvrn);\n \n+  unsigned int alignment\n+    = aarch64_function_arg_alignment (mode, type, &abi_break,\n+\t\t\t\t      &abi_break_packed);\n+\n+  gcc_assert ((allocate_nvrn || alignment <= 16 * BITS_PER_UNIT)\n+\t      && (!alignment || abi_break < alignment)\n+\t      && (!abi_break_packed || alignment < abi_break_packed));\n+\n   /* allocate_ncrn may be false-positive, but allocate_nvrn is quite reliable.\n      The following code thus handles passing by SIMD/FP registers first.  */\n "}]}