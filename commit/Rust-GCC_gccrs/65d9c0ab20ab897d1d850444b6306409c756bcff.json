{"sha": "65d9c0ab20ab897d1d850444b6306409c756bcff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkOWMwYWIyMGFiODk3ZDFkODUwNDQ0YjYzMDY0MDljNzU2YmNmZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-09T18:45:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-09T18:45:59Z"}, "message": "i386.h (LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Set to 128bit for x86_64 (BOOL_TYPE_SIZE...\n\n\t* i386.h (LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Set to 128bit for x86_64\n\t(BOOL_TYPE_SIZE, SHORT_TYPE_SIZE, INT_TYPE_SIZE,\n\t FLOAT_TYPE_SIZE, LONG_TYPE_SIZE, MAX_LONG_TYPE_SIZE,\n\t DOUBLE_TYPE_SIZE, LONG_LONG_TYPE_SIZE): New constants.\n\t(BITS_PER_WORD, UNITS_PER_WORD, POINTER_SIZE, PARM_BOUNDARY,\n\t STACK_BOUNDARY): Set properly for 64bits.\n\t(MAX_BITS_PER_WORD, MIN_UNITS_PER_WORD): New constants.\n\t(EMPTY_FIELD_BOUNDARY): Define using BITS_PER_WORD.\n\t(BIGGEST_FIELD_ALIGNMENT): Set to 128 for 64bits.\n\t(MOVE_MAX): Set to 16.\n\t(MOVE_MAX_PIECES): 8 for 64bit.\n\t(Pmode): Set to SImode.\n\nFrom-SVN: r40347", "tree": {"sha": "5a76548424b5177632c318e1a8af23b879cd678a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a76548424b5177632c318e1a8af23b879cd678a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d9c0ab20ab897d1d850444b6306409c756bcff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d9c0ab20ab897d1d850444b6306409c756bcff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d9c0ab20ab897d1d850444b6306409c756bcff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d9c0ab20ab897d1d850444b6306409c756bcff/comments", "author": null, "committer": null, "parents": [{"sha": "dc647e999c54d025c07c5b4f5a674a6f271676a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc647e999c54d025c07c5b4f5a674a6f271676a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc647e999c54d025c07c5b4f5a674a6f271676a0"}], "stats": {"total": 53, "additions": 44, "deletions": 9}, "files": [{"sha": "87be137f5dcb7844a264042c8340d758074f5acc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d9c0ab20ab897d1d850444b6306409c756bcff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d9c0ab20ab897d1d850444b6306409c756bcff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65d9c0ab20ab897d1d850444b6306409c756bcff", "patch": "@@ -1,3 +1,18 @@\n+Fri Mar  9 19:37:46 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Set to 128bit for x86_64\n+\t(BOOL_TYPE_SIZE, SHORT_TYPE_SIZE, INT_TYPE_SIZE,\n+\t FLOAT_TYPE_SIZE, LONG_TYPE_SIZE, MAX_LONG_TYPE_SIZE,\n+\t DOUBLE_TYPE_SIZE, LONG_LONG_TYPE_SIZE): New constants.\n+\t(BITS_PER_WORD, UNITS_PER_WORD, POINTER_SIZE, PARM_BOUNDARY,\n+\t STACK_BOUNDARY): Set properly for 64bits.\n+\t(MAX_BITS_PER_WORD, MIN_UNITS_PER_WORD): New constants.\n+\t(EMPTY_FIELD_BOUNDARY): Define using BITS_PER_WORD.\n+\t(BIGGEST_FIELD_ALIGNMENT): Set to 128 for 64bits.\n+\t(MOVE_MAX): Set to 16.\n+\t(MOVE_MAX_PIECES): 8 for 64bit.\n+\t(Pmode): Set to SImode.\n+\n Fri Mar  9 09:00:36 2001  Mike Stump  <mrs@wrs.com>\n \n \t* cselib.c (hash_rtx): Ensure that hash isn't zero upon return."}, {"sha": "92c7518432b53f319041f6886e62a2b018b4734c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d9c0ab20ab897d1d850444b6306409c756bcff/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d9c0ab20ab897d1d850444b6306409c756bcff/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=65d9c0ab20ab897d1d850444b6306409c756bcff", "patch": "@@ -511,11 +511,24 @@ extern int ix86_arch;\n  */\n #define LONG_DOUBLE_TYPE_SIZE (TARGET_128BIT_LONG_DOUBLE ? 128 : 96)\n #define MAX_LONG_DOUBLE_TYPE_SIZE 128\n+#ifdef __x86_64__\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n+#else\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 96\n+#endif\n /* Tell real.c that this is the 80-bit Intel extended float format\n    packaged in a 128-bit or 96bit entity.  */\n #define INTEL_EXTENDED_IEEE_FORMAT\n \n \n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define FLOAT_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#define MAX_LONG_TYPE_SIZE 64\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_LONG_TYPE_SIZE 64\n+\n /* Define if you don't want extended real, but do want to use the\n    software floating point emulator for REAL_ARITHMETIC and\n    decimal <-> binary conversion. */\n@@ -542,20 +555,22 @@ extern int ix86_arch;\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 80386, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n+#define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n+#define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define MIN_UNITS_PER_WORD 4\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n+#define POINTER_SIZE BITS_PER_WORD\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n+#define PARM_BOUNDARY BITS_PER_WORD\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n+#define STACK_BOUNDARY BITS_PER_WORD\n \n /* Boundary (in *bits*) on which the stack pointer preferrs to be\n    aligned; the compiler cannot rely on having this alignment.  */\n@@ -567,7 +582,7 @@ extern int ix86_arch;\n \n /* Alignment of field after `int : 0' in a structure. */\n \n-#define EMPTY_FIELD_BOUNDARY 32\n+#define EMPTY_FIELD_BOUNDARY BITS_PER_WORD\n \n /* Minimum size in bits of the largest boundary to which any\n    and all fundamental data types supported by the hardware\n@@ -590,7 +605,7 @@ extern int ix86_arch;\n /* BIGGEST_FIELD_ALIGNMENT is also used in libobjc, where it must be\n    constant.  Use the smaller value in that context.  */\n #ifndef IN_TARGET_LIBS\n-#define BIGGEST_FIELD_ALIGNMENT (TARGET_ALIGN_DOUBLE ? 64 : 32)\n+#define BIGGEST_FIELD_ALIGNMENT (TARGET_64BIT ? 128 : (TARGET_ALIGN_DOUBLE ? 64 : 32))\n #else\n #define BIGGEST_FIELD_ALIGNMENT 32\n #endif\n@@ -2127,7 +2142,12 @@ while (0)\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n+#define MOVE_MAX 16\n+\n+/* MOVE_MAX_PIECES is the number of bytes at a time which we can\n+   move efficiently, as opposed to  MOVE_MAX which is the maximum\n+   number of bytes we can move with a single instruction. */\n+#define MOVE_MAX_PIECES (TARGET_64BIT ? 8 : 4)\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n    move-instruction pairs, we will do a movstr or libcall instead.\n@@ -2175,7 +2195,7 @@ while (0)\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n+#define Pmode (TARGET_64BIT ? DImode : SImode)\n \n /* A function address in a call instruction\n    is a byte address (for indexing purposes)"}]}