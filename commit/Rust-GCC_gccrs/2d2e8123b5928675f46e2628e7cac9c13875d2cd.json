{"sha": "2d2e8123b5928675f46e2628e7cac9c13875d2cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQyZTgxMjNiNTkyODY3NWY0NmUyNjI4ZTdjYWM5YzEzODc1ZDJjZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-11-20T09:00:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-11-20T09:00:33Z"}, "message": "re PR c++/3637 (Internal compiler error in finish_member_declaration)\n\n\tPR c++/3637\n\t* call.c (non_reference): Add documentation.\n\t(convert_class_to_reference): Do not strip reference types\n\tfrom conversion operators.\n\t(maybe_handle_ref_bind): Simplify.\n\t(compare_ics): Correct handling of references.\n\nFrom-SVN: r47209", "tree": {"sha": "1e1d99f1028a63612d6994e142289a8582f99940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e1d99f1028a63612d6994e142289a8582f99940"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d2e8123b5928675f46e2628e7cac9c13875d2cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2e8123b5928675f46e2628e7cac9c13875d2cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d2e8123b5928675f46e2628e7cac9c13875d2cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2e8123b5928675f46e2628e7cac9c13875d2cd/comments", "author": null, "committer": null, "parents": [{"sha": "30cfa1bb50d8470fa8ce0aa0db01a333385c46ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30cfa1bb50d8470fa8ce0aa0db01a333385c46ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30cfa1bb50d8470fa8ce0aa0db01a333385c46ee"}], "stats": {"total": 107, "additions": 83, "deletions": 24}, "files": [{"sha": "9d78cbe43df3fd10c13e8288a314bc8c43e2c6e0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2d2e8123b5928675f46e2628e7cac9c13875d2cd", "patch": "@@ -1,3 +1,12 @@\n+2001-11-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/3637\n+\t* call.c (non_reference): Add documentation.\n+\t(convert_class_to_reference): Do not strip reference types \n+\tfrom conversion operators.\n+\t(maybe_handle_ref_bind): Simplify.\n+\t(compare_ics): Correct handling of references.\n+\n 2001-11-19  John Wilkinson <johnw@research.att.com>\n \n \t* dump.c (dump_op): New function."}, {"sha": "4d06dc5dcd6d984093d98204c675d2c7c3953525", "filename": "gcc/cp/call.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2d2e8123b5928675f46e2628e7cac9c13875d2cd", "patch": "@@ -88,7 +88,7 @@ static tree reference_binding PARAMS ((tree, tree, tree, int));\n static tree non_reference PARAMS ((tree));\n static tree build_conv PARAMS ((enum tree_code, tree, tree));\n static int is_subseq PARAMS ((tree, tree));\n-static int maybe_handle_ref_bind PARAMS ((tree*, tree*));\n+static tree maybe_handle_ref_bind PARAMS ((tree*));\n static void maybe_handle_implicit_object PARAMS ((tree*));\n static struct z_candidate * add_candidate PARAMS ((struct z_candidate *,\n \t\t\t\t\t\t   tree, tree, int));\n@@ -648,6 +648,9 @@ build_conv (code, type, from)\n   return t;\n }\n \n+/* If T is a REFERENCE_TYPE return the type to which T refers.\n+   Otherwise, return T itself.  */\n+\n static tree\n non_reference (t)\n      tree t;\n@@ -1024,8 +1027,7 @@ convert_class_to_reference (t, s, expr)\n     return NULL_TREE;\n \n   conv = build1 (IDENTITY_CONV, s, expr);\n-  conv = build_conv (USER_CONV,\n-\t\t     non_reference (TREE_TYPE (TREE_TYPE (cand->fn))),\n+  conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n \t\t     conv);\n   TREE_OPERAND (conv, 1) = build_ptr_wrapper (cand);\n   ICS_USER_FLAG (conv) = 1;\n@@ -4764,26 +4766,25 @@ maybe_handle_implicit_object (ics)\n     }\n }\n \n-/* If ICS is a REF_BIND, modify it appropriately, set TARGET_TYPE\n-   to the type the reference originally referred to, and return 1.\n-   Otherwise, return 0.  */\n+/* If *ICS is a REF_BIND set *ICS to the remainder of the conversion,\n+   and return the type to which the reference refers.  Otherwise,\n+   leave *ICS unchanged and return NULL_TREE.  */\n \n-static int\n-maybe_handle_ref_bind (ics, target_type)\n+static tree\n+maybe_handle_ref_bind (ics)\n      tree* ics;\n-     tree* target_type;\n {\n   if (TREE_CODE (*ics) == REF_BIND)\n     {\n       tree old_ics = *ics;\n-      *target_type = TREE_TYPE (TREE_TYPE (*ics));\n-      *ics = TREE_OPERAND (*ics, 0);\n+      tree type = TREE_TYPE (TREE_TYPE (old_ics));\n+      *ics = TREE_OPERAND (old_ics, 0);\n       ICS_USER_FLAG (*ics) = ICS_USER_FLAG (old_ics);\n       ICS_BAD_FLAG (*ics) = ICS_BAD_FLAG (old_ics);\n-      return 1;\n+      return type;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Compare two implicit conversion sequences according to the rules set out in\n@@ -4810,8 +4811,6 @@ compare_ics (ics1, ics2)\n   /* REF_BINDING is non-zero if the result of the conversion sequence\n      is a reference type.   In that case TARGET_TYPE is the\n      type referred to by the reference.  */\n-  int ref_binding1;\n-  int ref_binding2;\n   tree target_type1;\n   tree target_type2;\n \n@@ -4820,8 +4819,8 @@ compare_ics (ics1, ics2)\n   maybe_handle_implicit_object (&ics2);\n \n   /* Handle reference parameters.  */\n-  ref_binding1 = maybe_handle_ref_bind (&ics1, &target_type1);\n-  ref_binding2 = maybe_handle_ref_bind (&ics2, &target_type2);\n+  target_type1 = maybe_handle_ref_bind (&ics1);\n+  target_type2 = maybe_handle_ref_bind (&ics2);\n \n   /* [over.ics.rank]\n \n@@ -5060,37 +5059,41 @@ compare_ics (ics1, ics2)\n \t    }\n \t}\n     }\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (from_type1))\n+  else if (CLASS_TYPE_P (non_reference (from_type1))\n \t   && same_type_p (from_type1, from_type2))\n     {\n+      tree from = non_reference (from_type1);\n+\n       /* [over.ics.rank]\n \t \n \t --binding of an expression of type C to a reference of type\n \t   B& is better than binding an expression of type C to a\n \t   reference of type A&\n \n \t --conversion of C to B is better than conversion of C to A,  */\n-      if (is_properly_derived_from (from_type1, to_type1)\n-\t  && is_properly_derived_from (from_type1, to_type2))\n+      if (is_properly_derived_from (from, to_type1)\n+\t  && is_properly_derived_from (from, to_type2))\n \t{\n \t  if (is_properly_derived_from (to_type1, to_type2))\n \t    return 1;\n \t  else if (is_properly_derived_from (to_type2, to_type1))\n \t    return -1;\n \t}\n     }\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (to_type1))\n+  else if (CLASS_TYPE_P (non_reference (to_type1))\n \t   && same_type_p (to_type1, to_type2))\n     {\n+      tree to = non_reference (to_type1);\n+\n       /* [over.ics.rank]\n \n \t --binding of an expression of type B to a reference of type\n \t   A& is better than binding an expression of type C to a\n \t   reference of type A&, \n \n \t --onversion of B to A is better than conversion of C to A  */\n-      if (is_properly_derived_from (from_type1, to_type1)\n-\t  && is_properly_derived_from (from_type2, to_type1))\n+      if (is_properly_derived_from (from_type1, to)\n+\t  && is_properly_derived_from (from_type2, to))\n \t{\n \t  if (is_properly_derived_from (from_type2, from_type1))\n \t    return 1;\n@@ -5118,7 +5121,7 @@ compare_ics (ics1, ics2)\n      initialized by S2 refers is more cv-qualified than the type to\n      which the reference initialized by S1 refers */\n       \n-  if (ref_binding1 && ref_binding2\n+  if (target_type1 && target_type2\n       && same_type_ignoring_top_level_qualifiers_p (to_type1, to_type2))\n     return comp_cv_qualification (target_type2, target_type1);\n "}, {"sha": "aaf04cff6848d2ac6c8d8880dac322b5ce53ac49", "filename": "gcc/testsuite/g++.dg/ref1.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fref1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e8123b5928675f46e2628e7cac9c13875d2cd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fref1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fref1.C?ref=2d2e8123b5928675f46e2628e7cac9c13875d2cd", "patch": "@@ -0,0 +1,47 @@\n+// Origin: Peter Schmid <schmid@snake.iap.physik.tu-darmstadt.de>\n+\n+// { dg-do link }\n+\n+template <class T>\n+class Ptr {\n+protected:\n+  T * ptr;\n+\n+public:\n+  \n+  Ptr(void) : ptr(0) { };\n+  Ptr(T * p) : ptr(p) { };\n+  \n+  ~Ptr(void) { delete ptr; }\n+  \n+  operator T & () { return *ptr; }\n+};\n+\n+class base {\n+public: \n+  base(void) { }\n+  ~base(void) { }\n+};\n+\n+\n+class foo : public base {\n+private:\n+  foo(const foo & rv);\n+  \n+public:\n+  \n+  foo(void) { }\n+  ~foo(void) { }\n+};\n+\n+void func2(base & b) {\n+  // ...\n+}\n+\n+int main () {\n+  Ptr<foo> f = new foo;\n+  /* This should not result in a copy; the result of the conversion\n+     operator should be bound directly to the reference argument to\n+     `func2'.  */\n+  func2(f);\n+}"}]}