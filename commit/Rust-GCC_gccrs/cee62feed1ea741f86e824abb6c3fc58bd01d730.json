{"sha": "cee62feed1ea741f86e824abb6c3fc58bd01d730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlNjJmZWVkMWVhNzQxZjg2ZTgyNGFiYjZjM2ZjNThiZDAxZDczMA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2015-05-26T16:00:32Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2015-05-26T16:00:32Z"}, "message": "re PR middle-end/66251 (ICE in vect_get_vec_def_for_operand, at tree-vect-stmts.c:1484)\n\n\tPR middle-end/66251\n\n\t* tree-vect-stmts.c (vect_model_store_cost): Handled strided group\n\tstores.\n\t(vect_create_vectorized_demotion_stmts): Always set\n\tSTMT_VINFO_VEC_STMT, also with SLP.\n\t(vectorizable_store): Handle strided group stores.\n\ntestsuite/:\n\tPR middle-end/66251\n\t* gcc.dg/vect/pr66251.c: New test.\n\nFrom-SVN: r223704", "tree": {"sha": "bf971b228b61898c75c72be10a5a5aa3b7364758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf971b228b61898c75c72be10a5a5aa3b7364758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee62feed1ea741f86e824abb6c3fc58bd01d730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee62feed1ea741f86e824abb6c3fc58bd01d730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee62feed1ea741f86e824abb6c3fc58bd01d730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee62feed1ea741f86e824abb6c3fc58bd01d730/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd1bdce4183a38fe030154fdf7b86a9b397e6ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd1bdce4183a38fe030154fdf7b86a9b397e6ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd1bdce4183a38fe030154fdf7b86a9b397e6ae2"}], "stats": {"total": 161, "additions": 141, "deletions": 20}, "files": [{"sha": "69289e6a8df83503439eabaf531fda2e74036a74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cee62feed1ea741f86e824abb6c3fc58bd01d730", "patch": "@@ -1,3 +1,13 @@\n+2015-05-26  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/66251\n+\n+\t* tree-vect-stmts.c (vect_model_store_cost): Handled strided group\n+\tstores.\n+\t(vect_create_vectorized_demotion_stmts): Always set\n+\tSTMT_VINFO_VEC_STMT, also with SLP.\n+\t(vectorizable_store): Handle strided group stores.\n+\n 2015-05-26  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n \n \tPR target/66049"}, {"sha": "7ed1c92d27e396652267bd1ad2b3b602cd0782a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cee62feed1ea741f86e824abb6c3fc58bd01d730", "patch": "@@ -1,3 +1,8 @@\n+2015-05-26  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/66251\n+\t* gcc.dg/vect/pr66251.c: New test.\n+\n 2015-05-26  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66142"}, {"sha": "e39f700df9af96bfabfeeeb28cc890a92e47cdf2", "filename": "gcc/testsuite/gcc.dg/vect/pr66251.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66251.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66251.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66251.c?ref=cee62feed1ea741f86e824abb6c3fc58bd01d730", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_floatint_cvt } */\n+/* { dg-require-effective-target vect_intfloat_cvt } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+/* { dg-require-effective-target vect_hw_misalign } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noinline,noclone))\n+test1(_Complex double *a, _Complex int *b, int stride, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i*stride] = b[i*stride];\n+    }\n+}\n+\n+void __attribute__((noinline,noclone))\n+test2(_Complex int *a, _Complex double *b, int stride, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i*stride] = b[i*stride];\n+    }\n+}\n+\n+_Complex int ia[256];\n+_Complex double da[256];\n+\n+extern void abort (void);\n+\n+int main ()\n+{\n+  int i;\n+  int stride;\n+\n+  check_vect ();\n+\n+  for (stride = 1; stride < 15; stride++)\n+    {\n+      for (i = 0; i < 256; i++)\n+\t{\n+\t  __real__ ia[i] = (i + stride) % 19;\n+\t  __imag__ ia[i] = (i + stride) % 23;\n+\t  __asm__ volatile (\"\");\n+\t}\n+\n+      test1(da, ia, stride, 256/stride);\n+\n+      for (i = 0; i < 256/stride; i++)\n+\t{\n+\t  if (da[i*stride] != ia[i*stride])\n+\t    abort ();\n+\t}\n+\n+      for (i = 0; i < 256; i++)\n+\t{\n+\t  __real__ da[i] = (i + stride + 1) % 29;\n+\t  __imag__ da[i] = (i + stride + 1) % 31;\n+\t  __asm__ volatile (\"\");\n+\t}\n+\n+      test2(ia, da, stride, 256/stride);\n+\n+      for (i = 0; i < 256/stride; i++)\n+\t{\n+\t  if (da[i*stride] != ia[i*stride])\n+\t    abort ();\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "83039f1ad39474c268cfe08df964a25a31f5b965", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee62feed1ea741f86e824abb6c3fc58bd01d730/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=cee62feed1ea741f86e824abb6c3fc58bd01d730", "patch": "@@ -1000,7 +1000,8 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n      equivalent to the cost of GROUP_SIZE separate stores.  If a grouped\n      access is instead being provided by a permute-and-store operation,\n      include the cost of the permutes.  */\n-  if (!store_lanes_p && group_size > 1)\n+  if (!store_lanes_p && group_size > 1\n+      && !STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       /* Uses a high and low interleave or shuffle operations for each\n \t needed permute.  */\n@@ -1014,21 +1015,24 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n                          group_size);\n     }\n \n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   /* Costs of the stores.  */\n-  if (STMT_VINFO_STRIDED_P (stmt_info))\n+  if (STMT_VINFO_STRIDED_P (stmt_info)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       /* N scalar stores plus extracting the elements.  */\n-      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       inside_cost += record_stmt_cost (body_cost_vec,\n \t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n \t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n-      inside_cost += record_stmt_cost (body_cost_vec,\n-\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t       vec_to_scalar, stmt_info, 0, vect_body);\n     }\n   else\n     vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n \n+  if (STMT_VINFO_STRIDED_P (stmt_info))\n+    inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t     ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t     vec_to_scalar, stmt_info, 0, vect_body);\n+\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_store_cost: inside_cost = %d, \"\n@@ -3377,15 +3381,13 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n \t     (or in STMT_VINFO_RELATED_STMT chain).  */\n \t  if (slp_node)\n \t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\n+\t  if (!*prev_stmt_info)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n \t  else\n-\t    {\n-\t      if (!*prev_stmt_info)\n-\t\tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n-\t      else\n-\t\tSTMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt;\n+\t    STMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt;\n \n-\t      *prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\t    }\n+\t  *prev_stmt_info = vinfo_for_stmt (new_stmt);\n \t}\n     }\n \n@@ -5155,15 +5157,27 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       grouped_store = true;\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      if (!slp && !PURE_SLP_STMT (stmt_info))\n+      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      if (!slp\n+\t  && !PURE_SLP_STMT (stmt_info)\n+\t  && !STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n-\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \t  if (vect_store_lanes_supported (vectype, group_size))\n \t    store_lanes_p = true;\n \t  else if (!vect_grouped_store_supported (vectype, group_size))\n \t    return false;\n \t}\n \n+      if (STMT_VINFO_STRIDED_P (stmt_info)\n+\t  && (slp || PURE_SLP_STMT (stmt_info))\n+\t  && (group_size > nunits\n+\t      || nunits % group_size != 0))\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"unhandled strided group store\\n\");\n+\t  return false;\n+\t}\n+\n       if (first_stmt == stmt)\n \t{\n           /* STMT is the leader of the group. Check the operands of all the\n@@ -5286,10 +5300,23 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t     ...\n          */\n \n+      unsigned nstores = nunits;\n+      tree ltype = elem_type;\n+      if (slp)\n+\t{\n+\t  nstores = nunits / group_size;\n+\t  if (group_size < nunits)\n+\t    ltype = build_vector_type (elem_type, group_size);\n+\t  else\n+\t    ltype = vectype;\n+\t  ltype = build_aligned_type (ltype, TYPE_ALIGN (elem_type));\n+\t  ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\t}\n+\n       ivstep = stride_step;\n       ivstep = fold_build2 (MULT_EXPR, TREE_TYPE (ivstep), ivstep,\n \t\t\t    build_int_cst (TREE_TYPE (ivstep),\n-\t\t\t\t\t   ncopies * nunits));\n+\t\t\t\t\t   ncopies * nstores));\n \n       standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n \n@@ -5315,22 +5342,22 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  else\n \t    vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n \n-\t  for (i = 0; i < nunits; i++)\n+\t  for (i = 0; i < nstores; i++)\n \t    {\n \t      tree newref, newoff;\n \t      gimple incr, assign;\n-\t      tree size = TYPE_SIZE (elem_type);\n+\t      tree size = TYPE_SIZE (ltype);\n \t      /* Extract the i'th component.  */\n \t      tree pos = fold_build2 (MULT_EXPR, bitsizetype, bitsize_int (i),\n \t\t\t\t      size);\n-\t      tree elem = fold_build3 (BIT_FIELD_REF, elem_type, vec_oprnd,\n+\t      tree elem = fold_build3 (BIT_FIELD_REF, ltype, vec_oprnd,\n \t\t\t\t       size, pos);\n \n \t      elem = force_gimple_operand_gsi (gsi, elem, true,\n \t\t\t\t\t       NULL_TREE, true,\n \t\t\t\t\t       GSI_SAME_STMT);\n \n-\t      newref = build2 (MEM_REF, TREE_TYPE (vectype),\n+\t      newref = build2 (MEM_REF, ltype,\n \t\t\t       running_off, alias_off);\n \n \t      /* And store it to *running_off.  */"}]}