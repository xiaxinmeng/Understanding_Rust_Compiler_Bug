{"sha": "150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwY2RjOWUxNmU4NjE3M2ZlNzExNmUxMmRiY2M0Y2M4ZmI2Yjc4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-11-03T01:40:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-11-03T01:40:33Z"}, "message": "re PR target/9350 (-fomit-frame-pointer does not work for main)\n\n        PR target/9350\n        PR target/24374\n        * dwarf2out.c (dwarf2out_reg_save_reg): New.\n        (dwarf2out_frame_debug_expr): Return after dwarf_handle_frame_unspec.\n        * function.c (assign_parms): Use calls.internal_arg_pointer.\n        (expand_main_function): Remove FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n        code.\n        * target-def.h (TARGET_INTERNAL_ARG_POINTER): New.\n        (TARGET_CALLS): Add it.\n        * target.h (struct gcc_target): Add calls.internal_arg_pointer.\n        * targhooks.c (default_internal_arg_pointer): New.\n        * targhooks.h (default_internal_arg_pointer): Declare.\n        * tree.h (dwarf2out_reg_save_reg): Declare.\n        * doc/tm.texi (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN): Remove.\n        * config/i386/i386.c (dbx_register_map): Add return column.\n        (dbx64_register_map, svr4_dbx_register_map): Likewise.\n        (TARGET_INTERNAL_ARG_POINTER, ix86_internal_arg_pointer): New.\n        (TARGET_DWARF_HANDLE_FRAME_UNSPEC, ix86_dwarf_handle_frame_unspec): New.        (ix86_function_ok_for_sibcall): Disable if force_align_arg_pointer.\n        (ix86_save_reg): Save force_align_arg_pointer.\n        (ix86_emit_save_regs): Make regno unsigned.\n        (ix86_emit_save_regs_using_mov): Likewise.\n        (ix86_expand_prologue): Handle force_align_arg_pointer.\n        (ix86_expand_epilogue): Likewise.\n        * config/i386/i386.h: (dbx_register_map): Update.\n        (dbx64_register_map, svr4_dbx_register_map): Update.\n        (struct machine_function): Add force_align_arg_pointer.\n        * config/i386/i386.md (UNSPEC_REG_SAVE, UNSPEC_DEF_CFA): New.\n        (UNSPEC_TP, UNSPEC_TLS_GD, UNSPEC_TLS_LD_BASE): Renumber.\n        (TARGET_PUSH_MEMORY peepholes): Disable if RTX_FRAME_RELATED_P.\n\nFrom-SVN: r106420", "tree": {"sha": "6cea9b2ad7c60bdcd1ca27428519046f1cb9729f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cea9b2ad7c60bdcd1ca27428519046f1cb9729f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/comments", "author": null, "committer": null, "parents": [{"sha": "3a0588c4e01a7cbeaf3a54360ffaba27fc8caf25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0588c4e01a7cbeaf3a54360ffaba27fc8caf25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0588c4e01a7cbeaf3a54360ffaba27fc8caf25"}], "stats": {"total": 293, "additions": 216, "deletions": 77}, "files": [{"sha": "a2e518a14f53495b5a17a2d4f774a3d0553eabdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -1,3 +1,36 @@\n+2005-11-02  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/9350\n+\tPR target/24374\n+\t* dwarf2out.c (dwarf2out_reg_save_reg): New.\n+\t(dwarf2out_frame_debug_expr): Return after dwarf_handle_frame_unspec.\n+\t* function.c (assign_parms): Use calls.internal_arg_pointer.\n+\t(expand_main_function): Remove FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n+\tcode.\n+\t* target-def.h (TARGET_INTERNAL_ARG_POINTER): New.\n+\t(TARGET_CALLS): Add it.\n+\t* target.h (struct gcc_target): Add calls.internal_arg_pointer.\n+\t* targhooks.c (default_internal_arg_pointer): New.\n+\t* targhooks.h (default_internal_arg_pointer): Declare.\n+\t* tree.h (dwarf2out_reg_save_reg): Declare.\n+\t* doc/tm.texi (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN): Remove.\n+\t* config/i386/i386.c (dbx_register_map): Add return column.\n+\t(dbx64_register_map, svr4_dbx_register_map): Likewise.\n+\t(TARGET_INTERNAL_ARG_POINTER, ix86_internal_arg_pointer): New.\n+\t(TARGET_DWARF_HANDLE_FRAME_UNSPEC, ix86_dwarf_handle_frame_unspec): New.\n+\t(ix86_function_ok_for_sibcall): Disable if force_align_arg_pointer.\n+\t(ix86_save_reg): Save force_align_arg_pointer.\n+\t(ix86_emit_save_regs): Make regno unsigned.\n+\t(ix86_emit_save_regs_using_mov): Likewise.\n+\t(ix86_expand_prologue): Handle force_align_arg_pointer.\n+\t(ix86_expand_epilogue): Likewise.\n+\t* config/i386/i386.h: (dbx_register_map): Update.\n+\t(dbx64_register_map, svr4_dbx_register_map): Update.\n+\t(struct machine_function): Add force_align_arg_pointer.\n+\t* config/i386/i386.md (UNSPEC_REG_SAVE, UNSPEC_DEF_CFA): New.\n+\t(UNSPEC_TP, UNSPEC_TLS_GD, UNSPEC_TLS_LD_BASE): Renumber.\n+\t(TARGET_PUSH_MEMORY peepholes): Disable if RTX_FRAME_RELATED_P.\n+\n 2005-11-02  Jan Hubicka  <jh@suse.cz>\n \n \tPR target/23303"}, {"sha": "26f0299b52bcfe4b52deda803dda428461d81a8c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -913,6 +913,8 @@ static void ix86_init_builtins (void);\n static rtx ix86_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static const char *ix86_mangle_fundamental_type (tree);\n static tree ix86_stack_protect_fail (void);\n+static rtx ix86_internal_arg_pointer (void);\n+static void ix86_dwarf_handle_frame_unspec (const char *, rtx, int);\n \n /* This function is only used on Solaris.  */\n static void i386_solaris_elf_named_section (const char *, unsigned int, tree)\n@@ -1081,6 +1083,10 @@ static void x86_64_elf_select_section (tree decl, int reloc,\n #define TARGET_MUST_PASS_IN_STACK ix86_must_pass_in_stack\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE ix86_pass_by_reference\n+#undef TARGET_INTERNAL_ARG_POINTER\n+#define TARGET_INTERNAL_ARG_POINTER ix86_internal_arg_pointer\n+#undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n+#define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg\n@@ -1987,6 +1993,11 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n     return false;\n #endif\n \n+  /* If we forced aligned the stack, then sibcalling would unalign the\n+     stack, which may break the called function.  */\n+  if (cfun->machine->force_align_arg_pointer)\n+    return false;\n+\n   /* Otherwise okay.  That also includes certain types of indirect calls.  */\n   return true;\n }\n@@ -4508,6 +4519,10 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n \t}\n     }\n \n+  if (cfun->machine->force_align_arg_pointer\n+      && regno == REGNO (cfun->machine->force_align_arg_pointer))\n+    return 1;\n+\n   return (regs_ever_live[regno]\n \t  && !call_used_regs[regno]\n \t  && !fixed_regs[regno]\n@@ -4719,10 +4734,10 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n static void\n ix86_emit_save_regs (void)\n {\n-  int regno;\n+  unsigned int regno;\n   rtx insn;\n \n-  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n+  for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0; )\n     if (ix86_save_reg (regno, true))\n       {\n \tinsn = emit_insn (gen_push (gen_rtx_REG (Pmode, regno)));\n@@ -4735,7 +4750,7 @@ ix86_emit_save_regs (void)\n static void\n ix86_emit_save_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n {\n-  int regno;\n+  unsigned int regno;\n   rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -4783,6 +4798,47 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n+/* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */\n+\n+static rtx\n+ix86_internal_arg_pointer (void)\n+{\n+  if (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n+      && DECL_NAME (current_function_decl)\n+      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n+      && DECL_FILE_SCOPE_P (current_function_decl))\n+    {\n+      cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);\n+      return copy_to_reg (cfun->machine->force_align_arg_pointer);\n+    }\n+  else\n+    return virtual_incoming_args_rtx;\n+}\n+\n+/* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.\n+   This is called from dwarf2out.c to emit call frame instructions\n+   for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */\n+static void\n+ix86_dwarf_handle_frame_unspec (const char *label, rtx pattern, int index)\n+{\n+  rtx unspec = SET_SRC (pattern);\n+  gcc_assert (GET_CODE (unspec) == UNSPEC);\n+\n+  switch (index)\n+    {\n+    case UNSPEC_REG_SAVE:\n+      dwarf2out_reg_save_reg (label, XVECEXP (unspec, 0, 0),\n+\t\t\t      SET_DEST (pattern));\n+      break;\n+    case UNSPEC_DEF_CFA:\n+      dwarf2out_def_cfa (label, REGNO (SET_DEST (pattern)),\n+\t\t\t INTVAL (XVECEXP (unspec, 0, 0)));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -4795,6 +4851,52 @@ ix86_expand_prologue (void)\n \n   ix86_compute_frame_layout (&frame);\n \n+  if (cfun->machine->force_align_arg_pointer)\n+    {\n+      rtx x, y;\n+\n+      /* Grab the argument pointer.  */\n+      x = plus_constant (stack_pointer_rtx, 4);\n+      y = cfun->machine->force_align_arg_pointer;\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* The unwind info consists of two parts: install the fafp as the cfa,\n+\t and record the fafp as the \"save register\" of the stack pointer.\n+\t The later is there in order that the unwinder can see where it\n+\t should restore the stack pointer across the and insn.  */\n+      x = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, const0_rtx), UNSPEC_DEF_CFA);\n+      x = gen_rtx_SET (VOIDmode, y, x);\n+      RTX_FRAME_RELATED_P (x) = 1;\n+      y = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, stack_pointer_rtx),\n+\t\t\t  UNSPEC_REG_SAVE);\n+      y = gen_rtx_SET (VOIDmode, cfun->machine->force_align_arg_pointer, y);\n+      RTX_FRAME_RELATED_P (y) = 1;\n+      x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x, y));\n+      x = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);\n+      REG_NOTES (insn) = x;\n+\n+      /* Align the stack.  */\n+      emit_insn (gen_andsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (-16)));\n+\n+      /* And here we cheat like madmen with the unwind info.  We force the\n+\t cfa register back to sp+4, which is exactly what it was at the\n+\t start of the function.  Re-pushing the return address results in\n+\t the return at the same spot relative to the cfa, and thus is \n+\t correct wrt the unwind info.  */\n+      x = cfun->machine->force_align_arg_pointer;\n+      x = gen_frame_mem (Pmode, plus_constant (x, -4));\n+      insn = emit_insn (gen_push (x));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      x = GEN_INT (4);\n+      x = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, x), UNSPEC_DEF_CFA);\n+      x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n+      x = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);\n+      REG_NOTES (insn) = x;\n+    }\n+\n   /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n      slower on all targets.  Also sdb doesn't like it.  */\n \n@@ -5072,6 +5174,13 @@ ix86_expand_epilogue (int style)\n \t}\n     }\n \n+  if (cfun->machine->force_align_arg_pointer)\n+    {\n+      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t     cfun->machine->force_align_arg_pointer,\n+\t\t\t     GEN_INT (-4)));\n+    }\n+\n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)\n     return;"}, {"sha": "256c0e49e20963866125d2287985e96a11accd7a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -2263,6 +2263,7 @@ struct machine_function GTY(())\n {\n   struct stack_local_entry *stack_locals;\n   const char *some_ld_name;\n+  rtx force_align_arg_pointer;\n   int save_varrargs_registers;\n   int accesses_prev_frame;\n   int optimize_mode_switching[MAX_386_ENTITIES];"}, {"sha": "b739e5004971ae9c36d992e63b08a50bd5b4790d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -66,11 +66,13 @@\n    (UNSPEC_STACK_ALLOC\t\t11)\n    (UNSPEC_SET_GOT\t\t12)\n    (UNSPEC_SSE_PROLOGUE_SAVE\t13)\n+   (UNSPEC_REG_SAVE\t\t14)\n+   (UNSPEC_DEF_CFA\t\t15)\n \n    ; TLS support\n-   (UNSPEC_TP\t\t\t15)\n-   (UNSPEC_TLS_GD\t\t16)\n-   (UNSPEC_TLS_LD_BASE\t\t17)\n+   (UNSPEC_TP\t\t\t16)\n+   (UNSPEC_TLS_GD\t\t17)\n+   (UNSPEC_TLS_LD_BASE\t\t18)\n \n    ; Other random patterns\n    (UNSPEC_SCAS\t\t\t20)\n@@ -18934,7 +18936,8 @@\n   [(set (match_operand:SI 0 \"push_operand\" \"\")\n \t(match_operand:SI 1 \"memory_operand\" \"\"))\n    (match_scratch:SI 2 \"r\")]\n-  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  \"!optimize_size && !TARGET_PUSH_MEMORY\n+   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n@@ -18943,7 +18946,8 @@\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n \t(match_operand:DI 1 \"memory_operand\" \"\"))\n    (match_scratch:DI 2 \"r\")]\n-  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  \"!optimize_size && !TARGET_PUSH_MEMORY\n+   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n@@ -18954,7 +18958,8 @@\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"memory_operand\" \"\"))\n    (match_scratch:SF 2 \"r\")]\n-  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  \"!optimize_size && !TARGET_PUSH_MEMORY\n+   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n@@ -18963,7 +18968,8 @@\n   [(set (match_operand:HI 0 \"push_operand\" \"\")\n \t(match_operand:HI 1 \"memory_operand\" \"\"))\n    (match_scratch:HI 2 \"r\")]\n-  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  \"!optimize_size && !TARGET_PUSH_MEMORY\n+   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n@@ -18972,7 +18978,8 @@\n   [(set (match_operand:QI 0 \"push_operand\" \"\")\n \t(match_operand:QI 1 \"memory_operand\" \"\"))\n    (match_scratch:QI 2 \"q\")]\n-  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  \"!optimize_size && !TARGET_PUSH_MEMORY\n+   && !RTX_FRAME_RELATED_P (peep2_next_insn (0))\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")"}, {"sha": "b339c4ccdc0554eee591015489e9148621f42d09", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -1033,18 +1033,6 @@ macro must evaluate to a value equal to or larger than\n @code{STACK_BOUNDARY}.\n @end defmac\n \n-@defmac FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n-A C expression that evaluates true if @code{PREFERRED_STACK_BOUNDARY} is\n-not guaranteed by the runtime and we should emit code to align the stack\n-at the beginning of @code{main}.\n-\n-@cindex @code{PUSH_ROUNDING}, interaction with @code{PREFERRED_STACK_BOUNDARY}\n-If @code{PUSH_ROUNDING} is not defined, the stack will always be aligned\n-to the specified boundary.  If @code{PUSH_ROUNDING} is defined and specifies\n-a less strict alignment than @code{PREFERRED_STACK_BOUNDARY}, the stack may\n-be momentarily unaligned while pushing arguments.\n-@end defmac\n-\n @defmac FUNCTION_BOUNDARY\n Alignment required for a function entry point, in bits.\n @end defmac"}, {"sha": "314652b15470133fabd603cb8d2581343e5f936f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -1271,6 +1271,30 @@ clobbers_queued_reg_save (rtx insn)\n   return false;\n }\n \n+/* Entry point for saving the first register into the second.  */\n+\n+void\n+dwarf2out_reg_save_reg (const char *label, rtx reg, rtx sreg)\n+{\n+  size_t i;\n+  unsigned int regno, sregno;\n+\n+  for (i = 0; i < num_regs_saved_in_regs; i++)\n+    if (REGNO (regs_saved_in_regs[i].orig_reg) == REGNO (reg))\n+      break;\n+  if (i == num_regs_saved_in_regs)\n+    {\n+      gcc_assert (i != ARRAY_SIZE (regs_saved_in_regs));\n+      num_regs_saved_in_regs++;\n+    }\n+  regs_saved_in_regs[i].orig_reg = reg;\n+  regs_saved_in_regs[i].saved_in_reg = sreg;\n+\n+  regno = DWARF_FRAME_REGNUM (REGNO (reg));\n+  sregno = DWARF_FRAME_REGNUM (REGNO (sreg));\n+  reg_save (label, regno, sregno, 0);\n+}\n+\n /* What register, if any, is currently saved in REG?  */\n \n static rtx\n@@ -1659,7 +1683,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tcase UNSPEC_VOLATILE:\n \t  gcc_assert (targetm.dwarf_handle_frame_unspec);\n \t  targetm.dwarf_handle_frame_unspec (label, expr, XINT (src, 1));\n-\t  break;\n+\t  return;\n \n \tdefault:\n \t  gcc_unreachable ();"}, {"sha": "9e36af74d72344d9cb3c33eae0a3285e5c44d13a", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -2894,22 +2894,9 @@ assign_parms (tree fndecl)\n {\n   struct assign_parm_data_all all;\n   tree fnargs, parm;\n-  rtx internal_arg_pointer;\n \n-  /* If the reg that the virtual arg pointer will be translated into is\n-     not a fixed reg or is the stack pointer, make a copy of the virtual\n-     arg pointer, and address parms via the copy.  The frame pointer is\n-     considered fixed even though it is not marked as such.\n-\n-     The second time through, simply use ap to avoid generating rtx.  */\n-\n-  if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM\n-       || ! (fixed_regs[ARG_POINTER_REGNUM]\n-\t     || ARG_POINTER_REGNUM == FRAME_POINTER_REGNUM)))\n-    internal_arg_pointer = copy_to_reg (virtual_incoming_args_rtx);\n-  else\n-    internal_arg_pointer = virtual_incoming_args_rtx;\n-  current_function_internal_arg_pointer = internal_arg_pointer;\n+  current_function_internal_arg_pointer\n+    = targetm.calls.internal_arg_pointer ();\n \n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n@@ -3916,42 +3903,6 @@ struct tree_opt_pass pass_init_function =\n void\n expand_main_function (void)\n {\n-#ifdef FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n-  if (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN)\n-    {\n-      int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-      rtx tmp, seq;\n-\n-      start_sequence ();\n-      /* Forcibly align the stack.  */\n-#ifdef STACK_GROWS_DOWNWARD\n-      tmp = expand_simple_binop (Pmode, AND, stack_pointer_rtx, GEN_INT(-align),\n-\t\t\t\t stack_pointer_rtx, 1, OPTAB_WIDEN);\n-#else\n-      tmp = expand_simple_binop (Pmode, PLUS, stack_pointer_rtx,\n-\t\t\t\t GEN_INT (align - 1), NULL_RTX, 1, OPTAB_WIDEN);\n-      tmp = expand_simple_binop (Pmode, AND, tmp, GEN_INT (-align),\n-\t\t\t\t stack_pointer_rtx, 1, OPTAB_WIDEN);\n-#endif\n-      if (tmp != stack_pointer_rtx)\n-\temit_move_insn (stack_pointer_rtx, tmp);\n-\n-      /* Enlist allocate_dynamic_stack_space to pick up the pieces.  */\n-      tmp = force_reg (Pmode, const0_rtx);\n-      allocate_dynamic_stack_space (tmp, NULL_RTX, BIGGEST_ALIGNMENT);\n-      seq = get_insns ();\n-      end_sequence ();\n-\n-      for (tmp = get_last_insn (); tmp; tmp = PREV_INSN (tmp))\n-\tif (NOTE_P (tmp) && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_FUNCTION_BEG)\n-\t  break;\n-      if (tmp)\n-\temit_insn_before (seq, tmp);\n-      else\n-\temit_insn (seq);\n-    }\n-#endif\n-\n #if (defined(INVOKE__main)\t\t\t\t\\\n      || (!defined(HAS_INIT_SECTION)\t\t\t\\\n \t && !defined(INIT_SECTION_ASM_OP)\t\t\\"}, {"sha": "7e8837451f3c2e8249fe0886ebc79d7fbbe062ab", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -445,6 +445,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n \n #define TARGET_FUNCTION_VALUE default_function_value\n+#define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n@@ -463,7 +464,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    TARGET_CALLEE_COPIES,\t\t\t\t\t\\\n    TARGET_ARG_PARTIAL_BYTES,\t\t\t\t\t\\\n    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,\t\t\t\\\n-   TARGET_FUNCTION_VALUE\t\t\t\t\t\\\n+   TARGET_FUNCTION_VALUE,\t\t\t\t\t\\\n+   TARGET_INTERNAL_ARG_POINTER\t\t\t\t\t\\\n    }\n \n #ifndef TARGET_UNWIND_TABLES_DEFAULT"}, {"sha": "0f775f1de157291e20f4f85f6424f74c39e923b9", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -613,6 +613,10 @@ struct gcc_target\n        specified by FN_DECL_OR_TYPE with a return type of RET_TYPE.  */\n     rtx (*function_value) (tree ret_type, tree fn_decl_or_type,\n \t\t\t   bool outgoing);\n+\n+    /* Return an rtx for the argument pointer incoming to the\n+       current function.  */\n+    rtx (*internal_arg_pointer) (void);\n   } calls;\n \n   /* Return the diagnostic message string if conversion from FROMTYPE"}, {"sha": "94469a76b0fb9b33158d3aed889a7728d933a3e0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm_p.h\"\n #include \"target-def.h\"\n #include \"ggc.h\"\n+#include \"hard-reg-set.h\"\n \n \n void\n@@ -439,4 +440,19 @@ default_function_value (tree ret_type ATTRIBUTE_UNUSED,\n #endif\n }\n \n+rtx\n+default_internal_arg_pointer (void)\n+{\n+  /* If the reg that the virtual arg pointer will be translated into is\n+     not a fixed reg or is the stack pointer, make a copy of the virtual\n+     arg pointer, and address parms via the copy.  The frame pointer is\n+     considered fixed even though it is not marked as such.  */\n+  if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM\n+       || ! (fixed_regs[ARG_POINTER_REGNUM]\n+\t     || ARG_POINTER_REGNUM == FRAME_POINTER_REGNUM)))\n+    return copy_to_reg (virtual_incoming_args_rtx);\n+  else\n+    return virtual_incoming_args_rtx;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "24e3b6d38be27a162f5c1811be20b45d6b229947", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -68,4 +68,4 @@ extern const char *hook_invalid_arg_for_unprototyped_fn\n   (tree, tree, tree);\n extern bool hook_bool_rtx_commutative_p (rtx, int);\n extern rtx default_function_value (tree, tree, bool);\n-\n+extern rtx default_internal_arg_pointer (void);"}, {"sha": "4705bb12b83fdaa8d482179551eab2d764a4b377", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150cdc9e16e86173fe7116e12dbcc4cc8fb6b789/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=150cdc9e16e86173fe7116e12dbcc4cc8fb6b789", "patch": "@@ -4119,6 +4119,10 @@ extern void dwarf2out_return_save (const char *, HOST_WIDE_INT);\n \n extern void dwarf2out_return_reg (const char *, unsigned);\n \n+/* Entry point for saving the first register into the second.  */\n+\n+extern void dwarf2out_reg_save_reg (const char *, rtx, rtx);\n+\n /* In tree-inline.c  */\n \n /* The type of a set of already-visited pointers.  Functions for creating"}]}