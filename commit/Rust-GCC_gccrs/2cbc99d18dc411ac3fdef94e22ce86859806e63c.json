{"sha": "2cbc99d18dc411ac3fdef94e22ce86859806e63c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNiYzk5ZDE4ZGM0MTFhYzNmZGVmOTRlMjJjZTg2ODU5ODA2ZTYzYw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-04T20:36:26Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-04T21:27:12Z"}, "message": "d: Merge upstream dmd 48d704f08\n\nUpdates the Array interface in dmd/root/array.h to use a DArray<TYPE>\ninternally.  Splits out BitArray into a separate header.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11219\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 48d704f08.\n\t* d-attribs.cc (build_attributes): Use new field name.\n\t* d-builtins.cc (build_frontend_type): Likewise.\n\t(maybe_set_builtin_1): Likewise.\n\t(d_maybe_set_builtin): Likewise.\n\t* d-codegen.cc (build_interface_binfo): Likewise.\n\t(identity_compare_p): Likewise.\n\t(lower_struct_comparison): Likewise.\n\t(build_struct_comparison): Likewise.\n\t(d_build_call): Likewise.\n\t(build_frame_type): Likewise.\n\t(build_closure): Likewise.\n\t* d-compiler.cc (Compiler::paintAsType): Likewise.\n\t(Compiler::loadModule): Likewise.\n\t* d-incpath.cc (add_globalpaths): Likewise.\n\t(add_filepaths): Likewise.\n\t(add_import_paths): Likewise.\n\t* d-lang.cc (deps_write): Likewise.\n\t(d_parse_file): Likewise.\n\t* decl.cc (gcc_attribute_p): Likewise.\n\t(base_vtable_offset): Likewise.\n\t(get_vtable_decl): Likewise.\n\t(build_class_instance): Likewise.\n\t* expr.cc (class ExprVisitor): Likewise.\n\t* modules.cc (layout_moduleinfo_fields): Likewise.\n\t(layout_moduleinfo): Likewise.\n\t(build_module_tree): Likewise.\n\t* toir.cc (class IRVisitor): Likewise.\n\t* typeinfo.cc (class TypeInfoVisitor): Likewise.\n\t(layout_classinfo_interfaces): Likewise.\n\t* types.cc (layout_aggregate_members): Likewise.\n\t(layout_aggregate_type): Likewise.", "tree": {"sha": "82939940413c5e726889ccd97fa2afd33e0b06be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82939940413c5e726889ccd97fa2afd33e0b06be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cbc99d18dc411ac3fdef94e22ce86859806e63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbc99d18dc411ac3fdef94e22ce86859806e63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbc99d18dc411ac3fdef94e22ce86859806e63c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbc99d18dc411ac3fdef94e22ce86859806e63c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e05c918d28e3fa66f5baaf556f6886447c68c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e05c918d28e3fa66f5baaf556f6886447c68c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e05c918d28e3fa66f5baaf556f6886447c68c9a"}], "stats": {"total": 2979, "additions": 1503, "deletions": 1476}, "files": [{"sha": "b83db95e2a7aaabb1baf48964bb4cee58f5ccb6e", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -245,7 +245,7 @@ build_attributes (Expressions *eattrs)\n \n   tree attribs = NULL_TREE;\n \n-  for (size_t i = 0; i < eattrs->dim; i++)\n+  for (size_t i = 0; i < eattrs->length; i++)\n     {\n       Expression *attr = (*eattrs)[i];\n       Dsymbol *sym = attr->type->toDsymbol (0);\n@@ -297,7 +297,7 @@ build_attributes (Expressions *eattrs)\n       /* Chain all attribute arguments together.  */\n       tree args = NULL_TREE;\n \n-      for (size_t j = 1; j < elems->dim; j++)\n+      for (size_t j = 1; j < elems->length; j++)\n \t{\n \t  Expression *e = (*elems)[j];\n \t  tree t;"}, {"sha": "c18287a202587ab7c2de594121ce6689c1759b7e", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -315,7 +315,7 @@ build_frontend_type (tree type)\n \n \t  /* GCC generic and placeholder built-ins are marked as variadic, yet\n \t     have no named parameters, and so can't be represented in D.  */\n-\t  if (args->dim != 0 || !varargs_p)\n+\t  if (args->length != 0 || !varargs_p)\n \t    {\n \t      dtype = TypeFunction::create (args, dtype, varargs_p, LINKc);\n \t      return dtype->addMod (mod);\n@@ -669,9 +669,9 @@ maybe_set_builtin_1 (Dsymbol *d)\n     {\n       /* Recursively search through attribute decls.  */\n       Dsymbols *decls = ad->include (NULL, NULL);\n-      if (decls && decls->dim)\n+      if (decls && decls->length)\n \t{\n-\t  for (size_t i = 0; i < decls->dim; i++)\n+\t  for (size_t i = 0; i < decls->length; i++)\n \t    {\n \t      Dsymbol *sym = (*decls)[i];\n \t      maybe_set_builtin_1 (sym);\n@@ -708,7 +708,7 @@ d_maybe_set_builtin (Module *m)\n   if (!m || !m->members)\n     return;\n \n-  for (size_t i = 0; i < m->members->dim; i++)\n+  for (size_t i = 0; i < m->members->length; i++)\n     {\n       Dsymbol *sym = (*m->members)[i];\n       maybe_set_builtin_1 (sym);"}, {"sha": "2337c1dfa3dbe4e6253bf7538aa0e194fc25eedc", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -356,7 +356,7 @@ build_class_binfo (tree super, ClassDeclaration *cd)\n tree\n build_interface_binfo (tree super, ClassDeclaration *cd, unsigned& offset)\n {\n-  tree binfo = make_tree_binfo (cd->baseclasses->dim);\n+  tree binfo = make_tree_binfo (cd->baseclasses->length);\n   tree ctype = build_ctype (cd->type);\n \n   /* Want RECORD_TYPE, not POINTER_TYPE.  */\n@@ -365,7 +365,7 @@ build_interface_binfo (tree super, ClassDeclaration *cd, unsigned& offset)\n   BINFO_OFFSET (binfo) = size_int (offset * Target::ptrsize);\n   BINFO_VIRTUAL_P (binfo) = 1;\n \n-  for (size_t i = 0; i < cd->baseclasses->dim; i++, offset++)\n+  for (size_t i = 0; i < cd->baseclasses->length; i++, offset++)\n     {\n       BaseClass *bc = (*cd->baseclasses)[i];\n       BINFO_BASE_APPEND (binfo, build_interface_binfo (binfo, bc->sym, offset));\n@@ -804,7 +804,7 @@ identity_compare_p (StructDeclaration *sd)\n \n   unsigned offset = 0;\n \n-  for (size_t i = 0; i < sd->fields.dim; i++)\n+  for (size_t i = 0; i < sd->fields.length; i++)\n     {\n       VarDeclaration *vd = sd->fields[i];\n       Type *tb = vd->type->toBasetype ();\n@@ -864,7 +864,7 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n   tree tmemcmp = NULL_TREE;\n \n   /* We can skip the compare if the structs are empty.  */\n-  if (sd->fields.dim == 0)\n+  if (sd->fields.length == 0)\n     {\n       tmemcmp = build_boolop (code, integer_zero_node, integer_zero_node);\n       if (TREE_SIDE_EFFECTS (t2))\n@@ -885,7 +885,7 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n       return build_boolop (code, tmemcmp, integer_zero_node);\n     }\n \n-  for (size_t i = 0; i < sd->fields.dim; i++)\n+  for (size_t i = 0; i < sd->fields.length; i++)\n     {\n       VarDeclaration *vd = sd->fields[i];\n       Type *type = vd->type->toBasetype ();\n@@ -968,7 +968,7 @@ build_struct_comparison (tree_code code, StructDeclaration *sd,\n \t\t\t tree t1, tree t2)\n {\n   /* We can skip the compare if the structs are empty.  */\n-  if (sd->fields.dim == 0)\n+  if (sd->fields.length == 0)\n     {\n       tree exp = build_boolop (code, integer_zero_node, integer_zero_node);\n       if (TREE_SIDE_EFFECTS (t2))\n@@ -1869,7 +1869,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n   if (arguments)\n     {\n       /* First pass, evaluated expanded tuples in function arguments.  */\n-      for (size_t i = 0; i < arguments->dim; ++i)\n+      for (size_t i = 0; i < arguments->length; ++i)\n \t{\n \tLagain:\n \t  Expression *arg = (*arguments)[i];\n@@ -1889,8 +1889,8 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n       /* if _arguments[] is the first argument.  */\n       size_t varargs = (tf->linkage == LINKd && tf->varargs == 1);\n \n-      /* Assumes arguments->dim <= formal_args->dim if (!tf->varargs).  */\n-      for (size_t i = 0; i < arguments->dim; ++i)\n+      /* Assumes arguments->length <= formal_args->length if (!tf->varargs).  */\n+      for (size_t i = 0; i < arguments->length; ++i)\n \t{\n \t  Expression *arg = (*arguments)[i];\n \t  tree targ = build_expr (arg);\n@@ -2381,11 +2381,11 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n     {\n       if (fd->parameters)\n \t{\n-\t  for (size_t i = 0; fd->parameters && i < fd->parameters->dim; i++)\n+\t  for (size_t i = 0; fd->parameters && i < fd->parameters->length; i++)\n \t    {\n \t      VarDeclaration *v = (*fd->parameters)[i];\n \t      /* Remove if already in closureVars so can push to front.  */\n-\t      for (size_t j = i; j < fd->closureVars.dim; j++)\n+\t      for (size_t j = i; j < fd->closureVars.length; j++)\n \t\t{\n \t\t  Dsymbol *s = fd->closureVars[j];\n \t\t  if (s == v)\n@@ -2401,7 +2401,7 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n       /* Also add hidden 'this' to outer context.  */\n       if (fd->vthis)\n \t{\n-\t  for (size_t i = 0; i < fd->closureVars.dim; i++)\n+\t  for (size_t i = 0; i < fd->closureVars.length; i++)\n \t    {\n \t      Dsymbol *s = fd->closureVars[i];\n \t      if (s == fd->vthis)\n@@ -2414,7 +2414,7 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n \t}\n     }\n \n-  for (size_t i = 0; i < fd->closureVars.dim; i++)\n+  for (size_t i = 0; i < fd->closureVars.length; i++)\n     {\n       VarDeclaration *v = fd->closureVars[i];\n       tree vsym = get_symbol_decl (v);\n@@ -2507,7 +2507,7 @@ build_closure (FuncDeclaration *fd)\n     }\n \n   /* Copy parameters that are referenced nonlocally.  */\n-  for (size_t i = 0; i < fd->closureVars.dim; i++)\n+  for (size_t i = 0; i < fd->closureVars.length; i++)\n     {\n       VarDeclaration *v = fd->closureVars[i];\n "}, {"sha": "a8adb983d0632fc4ec346a5af73ae627422f9576", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -91,8 +91,8 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n       Expressions *elements = ((ArrayLiteralExp *) expr)->elements;\n       vec<constructor_elt, va_gc> *elms = NULL;\n \n-      vec_safe_reserve (elms, elements->dim);\n-      for (size_t i = 0; i < elements->dim; i++)\n+      vec_safe_reserve (elms, elements->length);\n+      for (size_t i = 0; i < elements->length; i++)\n \t{\n \t  Expression *e = (*elements)[i];\n \t  if (e->type->isintegral ())\n@@ -167,13 +167,13 @@ Compiler::loadModule (Module *m)\n       if (!strcmp (id->toChars (), \"object\"))\n \tcreate_tinfo_types (m);\n     }\n-  else if (md->packages->dim == 1)\n+  else if (md->packages->length == 1)\n     {\n       if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n \t  && !strcmp (md->id->toChars (), \"builtins\"))\n \td_build_builtins_module (m);\n     }\n-  else if (md->packages->dim == 2)\n+  else if (md->packages->length == 2)\n     {\n       if (!strcmp ((*md->packages)[0]->toChars (), \"core\")\n \t  && !strcmp ((*md->packages)[1]->toChars (), \"stdc\"))"}, {"sha": "c0dd065d2cab913d575604d5f2952feea9b283e0", "filename": "gcc/d/d-incpath.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-incpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-incpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-incpath.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -75,7 +75,7 @@ add_globalpaths (Strings *paths)\n       if (!global.path)\n \tglobal.path = new Strings ();\n \n-      for (size_t i = 0; i < paths->dim; i++)\n+      for (size_t i = 0; i < paths->length; i++)\n \t{\n \t  const char *path = (*paths)[i];\n \t  const char *target = lrealpath (path);\n@@ -102,7 +102,7 @@ add_filepaths (Strings *paths)\n       if (!global.filePath)\n \tglobal.filePath = new Strings ();\n \n-      for (size_t i = 0; i < paths->dim; i++)\n+      for (size_t i = 0; i < paths->length; i++)\n \t{\n \t  const char *path = (*paths)[i];\n \t  const char *target = lrealpath (path);\n@@ -144,7 +144,7 @@ add_import_paths (const char *iprefix, const char *imultilib, bool stdinc)\n \n \t  /* Ignore duplicate entries.  */\n \t  bool found = false;\n-\t  for (size_t i = 0; i < global.params.imppath->dim; i++)\n+\t  for (size_t i = 0; i < global.params.imppath->length; i++)\n \t    {\n \t      if (strcmp (path, (*global.params.imppath)[i]) == 0)\n \t\t{\n@@ -173,7 +173,7 @@ add_import_paths (const char *iprefix, const char *imultilib, bool stdinc)\n   /* Add import search paths.  */\n   if (global.params.imppath)\n     {\n-      for (size_t i = 0; i < global.params.imppath->dim; i++)\n+      for (size_t i = 0; i < global.params.imppath->length; i++)\n \t{\n \t  const char *path = (*global.params.imppath)[i];\n \t  if (path)\n@@ -184,7 +184,7 @@ add_import_paths (const char *iprefix, const char *imultilib, bool stdinc)\n   /* Add string import search paths.  */\n   if (global.params.fileImppath)\n     {\n-      for (size_t i = 0; i < global.params.fileImppath->dim; i++)\n+      for (size_t i = 0; i < global.params.fileImppath->length; i++)\n \t{\n \t  const char *path = (*global.params.fileImppath)[i];\n \t  if (path)"}, {"sha": "35197e97a4cd1de6ebb0dffc6bd87046d8ef14bf", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -176,7 +176,7 @@ deps_write (Module *module, OutBuffer *buffer, unsigned colmax = 72)\n   column++;\n \n   /* Search all modules for file dependencies.  */\n-  while (modlist.dim > 0)\n+  while (modlist.length > 0)\n     {\n       Module *depmod = modlist.pop ();\n \n@@ -193,15 +193,15 @@ deps_write (Module *module, OutBuffer *buffer, unsigned colmax = 72)\n \tphonylist.safe_push (modstr);\n \n       /* Add imported files to dependency list.  */\n-      for (size_t i = 0; i < depmod->contentImportedFiles.dim; i++)\n+      for (size_t i = 0; i < depmod->contentImportedFiles.length; i++)\n \t{\n \t  const char *impstr = depmod->contentImportedFiles[i];\n \t  dependencies.safe_push (impstr);\n \t  phonylist.safe_push (impstr);\n \t}\n \n       /* Search all imports of the module.  */\n-      for (size_t i = 0; i < depmod->aimports.dim; i++)\n+      for (size_t i = 0; i < depmod->aimports.length; i++)\n \t{\n \t  Module *m = depmod->aimports[i];\n \n@@ -998,7 +998,7 @@ d_parse_file (void)\n \t{\n \t  OutBuffer buf;\n \t  buf.writestring (\"predefs  \");\n-\t  for (size_t i = 0; i < global.params.versionids->dim; i++)\n+\t  for (size_t i = 0; i < global.params.versionids->length; i++)\n \t    {\n \t      const char *s = (*global.params.versionids)[i];\n \t      buf.writestring (\" \");\n@@ -1068,14 +1068,14 @@ d_parse_file (void)\n     }\n \n   /* Read all D source files.  */\n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n       m->read (Loc ());\n     }\n \n   /* Parse all D source files.  */\n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n \n@@ -1119,7 +1119,7 @@ d_parse_file (void)\n       /* Generate 'header' import files.  Since 'header' import files must be\n \t independent of command line switches and what else is imported, they\n \t are generated before any semantic analysis.  */\n-      for (size_t i = 0; i < modules.dim; i++)\n+      for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n \t  if (d_option.fonly && m != Module::rootModule)\n@@ -1136,7 +1136,7 @@ d_parse_file (void)\n     goto had_errors;\n \n   /* Load all unconditional imports for better symbol resolving.  */\n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n \n@@ -1152,7 +1152,7 @@ d_parse_file (void)\n   /* Do semantic analysis.  */\n   doing_semantic_analysis_p = true;\n \n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n \n@@ -1166,9 +1166,9 @@ d_parse_file (void)\n   Module::dprogress = 1;\n   Module::runDeferredSemantic ();\n \n-  if (Module::deferred.dim)\n+  if (Module::deferred.length)\n     {\n-      for (size_t i = 0; i < Module::deferred.dim; i++)\n+      for (size_t i = 0; i < Module::deferred.length; i++)\n \t{\n \t  Dsymbol *sd = Module::deferred[i];\n \t  error_at (make_location_t (sd->loc),\n@@ -1177,14 +1177,14 @@ d_parse_file (void)\n     }\n \n   /* Process all built-in modules or functions now for CTFE.  */\n-  while (builtin_modules.dim != 0)\n+  while (builtin_modules.length != 0)\n     {\n       Module *m = builtin_modules.pop ();\n       d_maybe_set_builtin (m);\n     }\n \n   /* Do pass 2 semantic analysis.  */\n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n \n@@ -1200,7 +1200,7 @@ d_parse_file (void)\n     goto had_errors;\n \n   /* Do pass 3 semantic analysis.  */\n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n \n@@ -1213,7 +1213,7 @@ d_parse_file (void)\n   Module::runDeferredSemantic3 ();\n \n   /* Check again, incase semantic3 pass loaded any more modules.  */\n-  while (builtin_modules.dim != 0)\n+  while (builtin_modules.length != 0)\n     {\n       Module *m = builtin_modules.pop ();\n       d_maybe_set_builtin (m);\n@@ -1240,7 +1240,7 @@ d_parse_file (void)\n     {\n       OutBuffer buf;\n \n-      for (size_t i = 0; i < modules.dim; i++)\n+      for (size_t i = 0; i < modules.length; i++)\n \tdeps_write (modules[i], &buf);\n \n       /* -MF <arg> overrides -M[M]D.  */\n@@ -1281,7 +1281,7 @@ d_parse_file (void)\n   /* Generate Ddoc files.  */\n   if (global.params.doDocComments && !global.errors && !errorcount)\n     {\n-      for (size_t i = 0; i < modules.dim; i++)\n+      for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n \t  gendocfile (m);\n@@ -1291,7 +1291,7 @@ d_parse_file (void)\n   /* Handle -fdump-d-original.  */\n   if (global.params.vcg_ast)\n     {\n-      for (size_t i = 0; i < modules.dim; i++)\n+      for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n \t  OutBuffer buf;\n@@ -1302,7 +1302,7 @@ d_parse_file (void)\n \t}\n     }\n \n-  for (size_t i = 0; i < modules.dim; i++)\n+  for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n       if (d_option.fonly && m != Module::rootModule)"}, {"sha": "11e66483b8fd83d377c9ac0897bd016de05cb823", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -101,7 +101,7 @@ gcc_attribute_p (Dsymbol *decl)\n {\n   ModuleDeclaration *md = decl->getModule ()->md;\n \n-  if (md && md->packages && md->packages->dim == 1)\n+  if (md && md->packages && md->packages->length == 1)\n     {\n       if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n \t  && !strcmp (md->id->toChars (), \"attribute\"))\n@@ -179,7 +179,7 @@ class DeclVisitor : public Visitor\n     if (d->ident == NULL)\n       {\n \t/* Importing declaration list.  */\n-\tfor (size_t i = 0; i < d->names.dim; i++)\n+\tfor (size_t i = 0; i < d->names.length; i++)\n \t  {\n \t    AliasDeclaration *aliasdecl = d->aliasdecls[i];\n \t    tree decl = build_import_decl (aliasdecl);\n@@ -215,7 +215,7 @@ class DeclVisitor : public Visitor\n \n   void visit (TupleDeclaration *d)\n   {\n-    for (size_t i = 0; i < d->objects->dim; i++)\n+    for (size_t i = 0; i < d->objects->length; i++)\n       {\n \tRootObject *o = (*d->objects)[i];\n \tif ((o->dyncast () == DYNCAST_EXPRESSION)\n@@ -237,7 +237,7 @@ class DeclVisitor : public Visitor\n     if (!ds)\n       return;\n \n-    for (size_t i = 0; i < ds->dim; i++)\n+    for (size_t i = 0; i < ds->length; i++)\n       this->build_dsymbol ((*ds)[i]);\n   }\n \n@@ -285,7 +285,7 @@ class DeclVisitor : public Visitor\n     if (isError (d) || !d->members)\n       return;\n \n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n   }\n \n@@ -333,7 +333,7 @@ class DeclVisitor : public Visitor\n     if (!d->needsCodegen ())\n       return;\n \n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n   }\n \n@@ -344,7 +344,7 @@ class DeclVisitor : public Visitor\n     if (isError (d)|| !d->members)\n       return;\n \n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n   }\n \n@@ -392,7 +392,7 @@ class DeclVisitor : public Visitor\n \n     /* Put out the members.  There might be static constructors in the members\n        list, and they cannot be put in separate object files.  */\n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n \n     /* Put out xopEquals, xopCmp and xopHash.  */\n@@ -415,7 +415,7 @@ class DeclVisitor : public Visitor\n     bool has_errors = false;\n \n     /* Finish semantic analysis of functions in vtbl[].  */\n-    for (size_t i = d->vtblOffset (); i < d->vtbl.dim; i++)\n+    for (size_t i = d->vtblOffset (); i < d->vtbl.length; i++)\n       {\n \tFuncDeclaration *fd = d->vtbl[i]->isFuncDeclaration ();\n \n@@ -433,7 +433,7 @@ class DeclVisitor : public Visitor\n \t/* The function fd is hidden from the view of the class.\n \t   If it overlaps with any function in the vtbl[], then\n \t   issue an error.  */\n-\tfor (size_t j = 1; j < d->vtbl.dim; j++)\n+\tfor (size_t j = 1; j < d->vtbl.length; j++)\n \t  {\n \t    if (j == i)\n \t      continue;\n@@ -497,7 +497,7 @@ class DeclVisitor : public Visitor\n       return;\n \n     /* Put out the members.  */\n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n \n     /* If something goes wrong during final semantic pass, don't bother with\n@@ -530,7 +530,7 @@ class DeclVisitor : public Visitor\n     if (d->vtblOffset ())\n       CONSTRUCTOR_APPEND_ELT (elms, size_zero_node, build_address (d->csym));\n \n-    for (size_t i = d->vtblOffset (); i < d->vtbl.dim; i++)\n+    for (size_t i = d->vtblOffset (); i < d->vtbl.length; i++)\n       {\n \tFuncDeclaration *fd = d->vtbl[i]->isFuncDeclaration ();\n \n@@ -573,7 +573,7 @@ class DeclVisitor : public Visitor\n       return;\n \n     /* Put out the members.  */\n-    for (size_t i = 0; i < d->members->dim; i++)\n+    for (size_t i = 0; i < d->members->length; i++)\n       this->build_dsymbol ((*d->members)[i]);\n \n     /* Generate C symbols.  */\n@@ -906,7 +906,7 @@ class DeclVisitor : public Visitor\n       }\n \n     /* formal function parameters.  */\n-    size_t n_parameters = d->parameters ? d->parameters->dim : 0;\n+    size_t n_parameters = d->parameters ? d->parameters->length : 0;\n \n     for (size_t i = 0; i < n_parameters; i++)\n       {\n@@ -2013,27 +2013,27 @@ base_vtable_offset (ClassDeclaration *cd, BaseClass *bc)\n {\n   unsigned csymoffset = Target::classinfosize;\n   unsigned interfacesize = int_size_in_bytes (vtbl_interface_type_node);\n-  csymoffset += cd->vtblInterfaces->dim * interfacesize;\n+  csymoffset += cd->vtblInterfaces->length * interfacesize;\n \n-  for (size_t i = 0; i < cd->vtblInterfaces->dim; i++)\n+  for (size_t i = 0; i < cd->vtblInterfaces->length; i++)\n     {\n       BaseClass *b = (*cd->vtblInterfaces)[i];\n       if (b == bc)\n \treturn csymoffset;\n-      csymoffset += b->sym->vtbl.dim * Target::ptrsize;\n+      csymoffset += b->sym->vtbl.length * Target::ptrsize;\n     }\n \n   /* Check all overriding interface vtbl[]s.  */\n   for (ClassDeclaration *cd2 = cd->baseClass; cd2; cd2 = cd2->baseClass)\n     {\n-      for (size_t k = 0; k < cd2->vtblInterfaces->dim; k++)\n+      for (size_t k = 0; k < cd2->vtblInterfaces->length; k++)\n \t{\n \t  BaseClass *bs = (*cd2->vtblInterfaces)[k];\n \t  if (bs->fillVtbl (cd, NULL, 0))\n \t    {\n \t      if (bc == bs)\n \t\treturn csymoffset;\n-\t      csymoffset += bs->sym->vtbl.dim * Target::ptrsize;\n+\t      csymoffset += bs->sym->vtbl.length * Target::ptrsize;\n \t    }\n \t}\n     }\n@@ -2054,7 +2054,7 @@ get_vtable_decl (ClassDeclaration *decl)\n   tree ident = mangle_internal_decl (decl, \"__vtbl\", \"Z\");\n   /* Note: Using a static array type for the VAR_DECL, the DECL_INITIAL value\n      will have a different type.  However the back-end seems to accept this.  */\n-  tree type = build_ctype (Type::tvoidptr->sarrayOf (decl->vtbl.dim));\n+  tree type = build_ctype (Type::tvoidptr->sarrayOf (decl->vtbl.length));\n \n   decl->vtblsym = declare_extern_var (ident, type);\n   DECL_LANG_SPECIFIC (decl->vtblsym) = build_lang_decl (NULL);\n@@ -2124,7 +2124,7 @@ build_class_instance (ClassReferenceExp *exp)\n       /* Anonymous vtable interface fields are laid out before the fields of\n \t each class.  The interface offset is used to determine where to put\n \t the classinfo offset reference.  */\n-      for (size_t i = 0; i < bcd->vtblInterfaces->dim; i++)\n+      for (size_t i = 0; i < bcd->vtblInterfaces->length; i++)\n \t{\n \t  BaseClass *bc = (*bcd->vtblInterfaces)[i];\n \n@@ -2151,7 +2151,7 @@ build_class_instance (ClassReferenceExp *exp)\n \n       /* Generate initial values of all fields owned by current class.\n \t Use both the name and offset to find the right field.  */\n-      for (size_t i = 0; i < bcd->fields.dim; i++)\n+      for (size_t i = 0; i < bcd->fields.length; i++)\n \t{\n \t  VarDeclaration *vfield = bcd->fields[i];\n \t  int index = exp->findFieldIndexByName (vfield);"}, {"sha": "a742bd096fa662d473a6f4703435245b4d7196a4", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -1,4 +1,4 @@\n-47ed0330f877897233bcaffd4e206e5f5ab66c98\n+48d704f082ebe8b199a9ef7712c223216cd70d3a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "89ea487b106bfe04da537c3d2a87ffbee143d5e2", "filename": "gcc/d/dmd/access.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Faccess.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Faccess.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -52,7 +52,7 @@ Prot getAccess(AggregateDeclaration *ad, Dsymbol *smember)\n     }\n     if (ClassDeclaration *cd = ad->isClassDeclaration())\n     {\n-        for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+        for (size_t i = 0; i < cd->baseclasses->length; i++)\n         {\n             BaseClass *b = (*cd->baseclasses)[i];\n \n@@ -110,7 +110,7 @@ static bool isAccessible(\n \n         if (ClassDeclaration *cdthis = dthis->isClassDeclaration())\n         {\n-            for (size_t i = 0; i < cdthis->baseclasses->dim; i++)\n+            for (size_t i = 0; i < cdthis->baseclasses->length; i++)\n             {\n                 BaseClass *b = (*cdthis->baseclasses)[i];\n                 Prot access = getAccess(b->sym, smember);\n@@ -128,7 +128,7 @@ static bool isAccessible(\n         {\n             if (ClassDeclaration *cdthis = dthis->isClassDeclaration())\n             {\n-                for (size_t i = 0; i < cdthis->baseclasses->dim; i++)\n+                for (size_t i = 0; i < cdthis->baseclasses->length; i++)\n                 {\n                     BaseClass *b = (*cdthis->baseclasses)[i];\n                     if (isAccessible(smember, sfunc, b->sym, cdscope))"}, {"sha": "6f3301ed1dfd5a0de972dea4a26d4fedcc2b89b3", "filename": "gcc/d/dmd/apply.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -43,7 +43,7 @@ class PostorderExpressionVisitor : public StoppableVisitor\n     {\n         if (!e)\n             return false;\n-        for (size_t i = 0; i < e->dim && !stop; i++)\n+        for (size_t i = 0; i < e->length && !stop; i++)\n             doCond((*e)[i]);\n         return stop;\n     }"}, {"sha": "16ce3a90f373966ff38fd3e408dce0a629b7502a", "filename": "gcc/d/dmd/arrayop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Farrayop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Farrayop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -421,7 +421,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n \n         void visit(Expression *e)\n         {\n-            Identifier *id = Identifier::generateId(\"c\", fparams->dim);\n+            Identifier *id = Identifier::generateId(\"c\", fparams->length);\n             Parameter *param = new Parameter(0, e->type, id, NULL);\n             fparams->shift(param);\n             result = new IdentifierExp(Loc(), id);\n@@ -440,7 +440,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n \n         void visit(ArrayLiteralExp *e)\n         {\n-            Identifier *id = Identifier::generateId(\"p\", fparams->dim);\n+            Identifier *id = Identifier::generateId(\"p\", fparams->length);\n             Parameter *param = new Parameter(STCconst, e->type, id, NULL);\n             fparams->shift(param);\n             Expression *ie = new IdentifierExp(Loc(), id);\n@@ -450,7 +450,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n \n         void visit(SliceExp *e)\n         {\n-            Identifier *id = Identifier::generateId(\"p\", fparams->dim);\n+            Identifier *id = Identifier::generateId(\"p\", fparams->length);\n             Parameter *param = new Parameter(STCconst, e->type, id, NULL);\n             fparams->shift(param);\n             Expression *ie = new IdentifierExp(Loc(), id);"}, {"sha": "ea57214f734b8850bbfb01703caf13ee26deddca", "filename": "gcc/d/dmd/arraytypes.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Farraytypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Farraytypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -10,7 +10,8 @@\n \n #pragma once\n \n-#include \"root/root.h\"\n+#include \"root/array.h\"\n+#include \"root/bitarray.h\"\n \n typedef Array<class TemplateParameter *> TemplateParameters;\n "}, {"sha": "6f176ef096dd4a2f24653835fa3554b99eb9a367", "filename": "gcc/d/dmd/attrib.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -55,7 +55,7 @@ int AttribDeclaration::apply(Dsymbol_apply_ft_t fp, void *param)\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             if (s)\n@@ -117,7 +117,7 @@ void AttribDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             //printf(\"\\taddMember %s to %s\\n\", s->toChars(), sds->toChars());\n@@ -138,7 +138,7 @@ void AttribDeclaration::setScope(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->setScope(sc2);\n@@ -158,7 +158,7 @@ void AttribDeclaration::importAll(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->importAll(sc2);\n@@ -181,7 +181,7 @@ void AttribDeclaration::semantic(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->semantic(sc2);\n@@ -201,7 +201,7 @@ void AttribDeclaration::semantic2(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->semantic2(sc2);\n@@ -220,7 +220,7 @@ void AttribDeclaration::semantic3(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->semantic3(sc2);\n@@ -240,7 +240,7 @@ void AttribDeclaration::addComment(const utf8_t *comment)\n \n         if (d)\n         {\n-            for (size_t i = 0; i < d->dim; i++)\n+            for (size_t i = 0; i < d->length; i++)\n             {\n                 Dsymbol *s = (*d)[i];\n                 //printf(\"AttribDeclaration::addComment %s\\n\", s->toChars());\n@@ -256,7 +256,7 @@ void AttribDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffs\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->setFieldOffset(ad, poffset, isunion);\n@@ -270,7 +270,7 @@ bool AttribDeclaration::hasPointers()\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             if (s->hasPointers())\n@@ -286,7 +286,7 @@ bool AttribDeclaration::hasStaticCtorOrDtor()\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             if (s->hasStaticCtorOrDtor())\n@@ -314,7 +314,7 @@ void AttribDeclaration::checkCtorConstInit()\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->checkCtorConstInit();\n@@ -331,7 +331,7 @@ void AttribDeclaration::addLocalClass(ClassDeclarations *aclasses)\n \n     if (d)\n     {\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->addLocalClass(aclasses);\n@@ -387,7 +387,7 @@ void StorageClassDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n     if (d)\n     {\n         Scope *sc2 = newScope(sc);\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             //printf(\"\\taddMember %s to %s\\n\", s->toChars(), sds->toChars());\n@@ -767,7 +767,7 @@ void AnonDeclaration::semantic(Scope *sc)\n         sc->inunion = isunion;\n         sc->flags = 0;\n \n-        for (size_t i = 0; i < decl->dim; i++)\n+        for (size_t i = 0; i < decl->length; i++)\n         {\n             Dsymbol *s = (*decl)[i];\n             s->semantic(sc);\n@@ -787,7 +787,7 @@ void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset\n          * size and alignment.\n          */\n \n-        size_t fieldstart = ad->fields.dim;\n+        size_t fieldstart = ad->fields.length;\n \n         /* Hackishly hijack ad's structsize and alignsize fields\n          * for use in our fake anon aggregate member.\n@@ -798,7 +798,7 @@ void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset\n         ad->alignsize = 0;\n \n         unsigned offset = 0;\n-        for (size_t i = 0; i < decl->dim; i++)\n+        for (size_t i = 0; i < decl->length; i++)\n         {\n             Dsymbol *s = (*decl)[i];\n             s->setFieldOffset(ad, &offset, this->isunion);\n@@ -810,7 +810,7 @@ void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset\n          * added in ad->fields, just update *poffset for the subsequent\n          * field offset calculation.\n          */\n-        if (fieldstart == ad->fields.dim)\n+        if (fieldstart == ad->fields.length)\n         {\n             ad->structsize = savestructsize;\n             ad->alignsize  = savealignsize;\n@@ -845,7 +845,7 @@ void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset\n \n         // Add to the anon fields the base offset of this anonymous aggregate\n         //printf(\"anon fields, anonoffset = %d\\n\", anonoffset);\n-        for (size_t i = fieldstart; i < ad->fields.dim; i++)\n+        for (size_t i = fieldstart; i < ad->fields.length; i++)\n         {\n             VarDeclaration *v = ad->fields[i];\n             //printf(\"\\t[%d] %s %d\\n\", i, v->toChars(), v->offset);\n@@ -883,11 +883,11 @@ Scope *PragmaDeclaration::newScope(Scope *sc)\n     if (ident == Id::Pinline)\n     {\n         PINLINE inlining = PINLINEdefault;\n-        if (!args || args->dim == 0)\n+        if (!args || args->length == 0)\n             inlining = PINLINEdefault;\n-        else if (args->dim != 1)\n+        else if (args->length != 1)\n         {\n-            error(\"one boolean expression expected for pragma(inline), not %d\", args->dim);\n+            error(\"one boolean expression expected for pragma(inline), not %d\", args->length);\n             args->setDim(1);\n             (*args)[0] = new ErrorExp();\n         }\n@@ -925,8 +925,8 @@ static unsigned setMangleOverride(Dsymbol *s, char *sym)\n         Dsymbols *decls = ad->include(NULL, NULL);\n         unsigned nestedCount = 0;\n \n-        if (decls && decls->dim)\n-            for (size_t i = 0; i < decls->dim; ++i)\n+        if (decls && decls->length)\n+            for (size_t i = 0; i < decls->length; ++i)\n                 nestedCount += setMangleOverride((*decls)[i], sym);\n \n         return nestedCount;\n@@ -949,7 +949,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n     {\n         if (args)\n         {\n-            for (size_t i = 0; i < args->dim; i++)\n+            for (size_t i = 0; i < args->length; i++)\n             {\n                 Expression *e = (*args)[i];\n \n@@ -980,7 +980,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n     }\n     else if (ident == Id::lib)\n     {\n-        if (!args || args->dim != 1)\n+        if (!args || args->length != 1)\n             error(\"string expected for library name\");\n         else\n         {\n@@ -1012,7 +1012,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n     }\n     else if (ident == Id::startaddress)\n     {\n-        if (!args || args->dim != 1)\n+        if (!args || args->length != 1)\n             error(\"function name expected for start address\");\n         else\n         {\n@@ -1040,7 +1040,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n     {\n         if (!args)\n             args = new Expressions();\n-        if (args->dim != 1)\n+        if (args->length != 1)\n         {\n             error(\"string expected for mangled name\");\n             args->setDim(1);\n@@ -1113,7 +1113,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n             buf.writestring(ident->toChars());\n             if (args)\n             {\n-                for (size_t i = 0; i < args->dim; i++)\n+                for (size_t i = 0; i < args->length; i++)\n                 {\n                     Expression *e = (*args)[i];\n \n@@ -1129,7 +1129,7 @@ void PragmaDeclaration::semantic(Scope *sc)\n                         buf.writeByte(',');\n                     buf.writestring(e->toChars());\n                 }\n-                if (args->dim)\n+                if (args->length)\n                     buf.writeByte(')');\n             }\n             message(\"pragma    %s\", buf.peekString());\n@@ -1144,15 +1144,15 @@ void PragmaDeclaration::semantic(Scope *sc)\n     {\n         Scope *sc2 = newScope(sc);\n \n-        for (size_t i = 0; i < decl->dim; i++)\n+        for (size_t i = 0; i < decl->length; i++)\n         {\n             Dsymbol *s = (*decl)[i];\n \n             s->semantic(sc2);\n \n             if (ident == Id::mangle)\n             {\n-                assert(args && args->dim == 1);\n+                assert(args && args->length == 1);\n                 if (StringExp *se = (*args)[0]->toStringExp())\n                 {\n                     char *name = (char *)mem.xmalloc(se->len + 1);\n@@ -1239,7 +1239,7 @@ void ConditionalDeclaration::setScope(Scope *sc)\n     //printf(\"\\tConditionalDeclaration::setScope '%s', d = %p\\n\",toChars(), d);\n     if (d)\n     {\n-       for (size_t i = 0; i < d->dim; i++)\n+       for (size_t i = 0; i < d->length; i++)\n        {\n            Dsymbol *s = (*d)[i];\n            s->setScope(sc);\n@@ -1263,7 +1263,7 @@ void ConditionalDeclaration::addComment(const utf8_t *comment)\n         {\n             if (d)\n             {\n-                for (size_t i = 0; i < d->dim; i++)\n+                for (size_t i = 0; i < d->length; i++)\n                 {\n                     Dsymbol *s = (*d)[i];\n                     //printf(\"ConditionalDeclaration::addComment %s\\n\", s->toChars());\n@@ -1318,14 +1318,14 @@ Dsymbols *StaticIfDeclaration::include(Scope *sc, ScopeDsymbol *)\n         if (d && !addisdone)\n         {\n             // Add members lazily.\n-            for (size_t i = 0; i < d->dim; i++)\n+            for (size_t i = 0; i < d->length; i++)\n             {\n                 Dsymbol *s = (*d)[i];\n                 s->addMember(_scope, scopesym);\n             }\n \n             // Set the member scopes lazily.\n-            for (size_t i = 0; i < d->dim; i++)\n+            for (size_t i = 0; i < d->length; i++)\n             {\n                 Dsymbol *s = (*d)[i];\n                 s->setScope(_scope);\n@@ -1449,13 +1449,13 @@ Dsymbols *StaticForeachDeclaration::include(Scope *, ScopeDsymbol *)\n     if (d) // process generated declarations\n     {\n         // Add members lazily.\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->addMember(_scope, scopesym);\n         }\n         // Set the member scopes lazily.\n-        for (size_t i = 0; i < d->dim; i++)\n+        for (size_t i = 0; i < d->length; i++)\n         {\n             Dsymbol *s = (*d)[i];\n             s->setScope(_scope);\n@@ -1616,7 +1616,7 @@ void CompileDeclaration::semantic(Scope *sc)\n \n         if (_scope && decl)\n         {\n-            for (size_t i = 0; i < decl->dim; i++)\n+            for (size_t i = 0; i < decl->length; i++)\n             {\n                 Dsymbol *s = (*decl)[i];\n                 s->setScope(_scope);\n@@ -1652,7 +1652,7 @@ Dsymbol *UserAttributeDeclaration::syntaxCopy(Dsymbol *s)\n Scope *UserAttributeDeclaration::newScope(Scope *sc)\n {\n     Scope *sc2 = sc;\n-    if (atts && atts->dim)\n+    if (atts && atts->length)\n     {\n         // create new one for changes\n         sc2 = sc->copy();\n@@ -1681,7 +1681,7 @@ void UserAttributeDeclaration::semantic(Scope *sc)\n \n static void udaExpressionEval(Scope *sc, Expressions *exps)\n {\n-    for (size_t i = 0; i < exps->dim; i++)\n+    for (size_t i = 0; i < exps->length; i++)\n     {\n         Expression *e = (*exps)[i];\n         if (e)\n@@ -1701,7 +1701,7 @@ static void udaExpressionEval(Scope *sc, Expressions *exps)\n \n void UserAttributeDeclaration::semantic2(Scope *sc)\n {\n-    if (decl && atts && atts->dim && _scope)\n+    if (decl && atts && atts->length && _scope)\n     {\n         _scope = NULL;\n         udaExpressionEval(sc, atts);\n@@ -1713,9 +1713,9 @@ void UserAttributeDeclaration::semantic2(Scope *sc)\n Expressions *UserAttributeDeclaration::concat(Expressions *udas1, Expressions *udas2)\n {\n     Expressions *udas;\n-    if (!udas1 || udas1->dim == 0)\n+    if (!udas1 || udas1->length == 0)\n         udas = udas2;\n-    else if (!udas2 || udas2->dim == 0)\n+    else if (!udas2 || udas2->length == 0)\n         udas = udas1;\n     else\n     {\n@@ -1740,7 +1740,7 @@ Expressions *UserAttributeDeclaration::getAttributes()\n     Expressions *exps = new Expressions();\n     if (userAttribDecl)\n         exps->push(new TupleExp(Loc(), userAttribDecl->getAttributes()));\n-    if (atts && atts->dim)\n+    if (atts && atts->length)\n         exps->push(new TupleExp(Loc(), atts));\n \n     return exps;"}, {"sha": "d4088f5c69161575bae6ab8a4a24dade754bf6e2", "filename": "gcc/d/dmd/blockexit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fblockexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fblockexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -75,10 +75,10 @@ int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n \n         void visit(CompoundStatement *cs)\n         {\n-            //printf(\"CompoundStatement::blockExit(%p) %d result = x%X\\n\", cs, cs->statements->dim, result);\n+            //printf(\"CompoundStatement::blockExit(%p) %d result = x%X\\n\", cs, cs->statements->length, result);\n             result = BEfallthru;\n             Statement *slast = NULL;\n-            for (size_t i = 0; i < cs->statements->dim; i++)\n+            for (size_t i = 0; i < cs->statements->length; i++)\n             {\n                 Statement *s = (*cs->statements)[i];\n                 if (s)\n@@ -124,7 +124,7 @@ int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n         void visit(UnrolledLoopStatement *uls)\n         {\n             result = BEfallthru;\n-            for (size_t i = 0; i < uls->statements->dim; i++)\n+            for (size_t i = 0; i < uls->statements->length; i++)\n             {\n                 Statement *s = (*uls->statements)[i];\n                 if (s)\n@@ -356,7 +356,7 @@ int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n             result = blockExit(s->_body, func, false);\n \n             int catchresult = 0;\n-            for (size_t i = 0; i < s->catches->dim; i++)\n+            for (size_t i = 0; i < s->catches->length; i++)\n             {\n                 Catch *c = (*s->catches)[i];\n                 if (c->type == Type::terror)"}, {"sha": "1e1fa58703dcec53a2dcd1dae704481ac7c856e9", "filename": "gcc/d/dmd/canthrow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcanthrow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcanthrow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -251,9 +251,9 @@ bool Dsymbol_canThrow(Dsymbol *s, FuncDeclaration *func, bool mustNotThrow)\n     if (ad)\n     {\n         Dsymbols *decl = ad->include(NULL, NULL);\n-        if (decl && decl->dim)\n+        if (decl && decl->length)\n         {\n-            for (size_t i = 0; i < decl->dim; i++)\n+            for (size_t i = 0; i < decl->length; i++)\n             {\n                 s = (*decl)[i];\n                 if (Dsymbol_canThrow(s, func, mustNotThrow))\n@@ -287,7 +287,7 @@ bool Dsymbol_canThrow(Dsymbol *s, FuncDeclaration *func, bool mustNotThrow)\n         //printf(\"%s\\n\", tm->toChars());\n         if (tm->members)\n         {\n-            for (size_t i = 0; i < tm->members->dim; i++)\n+            for (size_t i = 0; i < tm->members->length; i++)\n             {\n                 Dsymbol *sm = (*tm->members)[i];\n                 if (Dsymbol_canThrow(sm, func, mustNotThrow))\n@@ -297,7 +297,7 @@ bool Dsymbol_canThrow(Dsymbol *s, FuncDeclaration *func, bool mustNotThrow)\n     }\n     else if ((td = s->isTupleDeclaration()) != NULL)\n     {\n-        for (size_t i = 0; i < td->objects->dim; i++)\n+        for (size_t i = 0; i < td->objects->length; i++)\n         {\n             RootObject *o = (*td->objects)[i];\n             if (o->dyncast() == DYNCAST_EXPRESSION)"}, {"sha": "7f91a10bbaa6094fdc851e350214a8d2dd263c2f", "filename": "gcc/d/dmd/clone.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fclone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fclone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -119,7 +119,7 @@ FuncDeclaration *hasIdentityOpAssign(AggregateDeclaration *ad, Scope *sc)\n                 return NULL;\n             int varargs;\n             Parameters *fparams = f->getParameters(&varargs);\n-            if (fparams->dim >= 1)\n+            if (fparams->length >= 1)\n             {\n                 Parameter *fparam0 = Parameter::getNth(fparams, 0);\n                 if (fparam0->type->toDsymbol(NULL) != ad)\n@@ -153,7 +153,7 @@ bool needOpAssign(StructDeclaration *sd)\n     /* If any of the fields need an opAssign, then we\n      * need it too.\n      */\n-    for (size_t i = 0; i < sd->fields.dim; i++)\n+    for (size_t i = 0; i < sd->fields.length; i++)\n     {\n         VarDeclaration *v = sd->fields[i];\n         if (v->storage_class & STCref)\n@@ -220,7 +220,7 @@ FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n     // check for it.\n     // In this event, it will be reflected by having `stc` (opAssign's\n     // storage class) include `STCdisabled`.\n-    for (size_t i = 0; i < sd->fields.dim; i++)\n+    for (size_t i = 0; i < sd->fields.length; i++)\n     {\n         VarDeclaration *v = sd->fields[i];\n         if (v->storage_class & STCref)\n@@ -294,7 +294,7 @@ FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n          * In both cases, it will change the parent context.\n          */\n         //printf(\"\\tmemberwise copy\\n\");\n-        for (size_t i = 0; i < sd->fields.dim; i++)\n+        for (size_t i = 0; i < sd->fields.length; i++)\n         {\n             VarDeclaration *v = sd->fields[i];\n             // this.v = s.v;\n@@ -361,7 +361,7 @@ bool needOpEquals(StructDeclaration *sd)\n     /* If any of the fields has an opEquals, then we\n      * need it too.\n      */\n-    for (size_t i = 0; i < sd->fields.dim; i++)\n+    for (size_t i = 0; i < sd->fields.length; i++)\n     {\n         VarDeclaration *v = sd->fields[i];\n         if (v->storage_class & STCref)\n@@ -666,7 +666,7 @@ bool needToHash(StructDeclaration *sd)\n     /* If any of the fields has an opEquals, then we\n      * need it too.\n      */\n-    for (size_t i = 0; i < sd->fields.dim; i++)\n+    for (size_t i = 0; i < sd->fields.length; i++)\n     {\n         VarDeclaration *v = sd->fields[i];\n         if (v->storage_class & STCref)\n@@ -785,16 +785,16 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n         return NULL;\n \n     StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = sd->postblits.dim ? sd->postblits[0]->loc : sd->loc;\n+    Loc declLoc = sd->postblits.length ? sd->postblits[0]->loc : sd->loc;\n     Loc loc = Loc();    // internal code should have no loc to prevent coverage\n \n-    for (size_t i = 0; i < sd->postblits.dim; i++)\n+    for (size_t i = 0; i < sd->postblits.length; i++)\n     {\n         stc |= sd->postblits[i]->storage_class & STCdisable;\n     }\n \n     Statements *a = new Statements();\n-    for (size_t i = 0; i < sd->fields.dim && !(stc & STCdisable); i++)\n+    for (size_t i = 0; i < sd->fields.length && !(stc & STCdisable); i++)\n     {\n         VarDeclaration *v = sd->fields[i];\n         if (v->storage_class & STCref)\n@@ -918,7 +918,7 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n     }\n \n     // Build our own \"postblit\" which executes a, but only if needed.\n-    if (a->dim || (stc & STCdisable))\n+    if (a->length || (stc & STCdisable))\n     {\n         //printf(\"Building __fieldPostBlit()\\n\");\n         PostBlitDeclaration *dd = new PostBlitDeclaration(declLoc, Loc(), stc, Id::__fieldPostblit);\n@@ -931,7 +931,7 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n     }\n \n     FuncDeclaration *xpostblit = NULL;\n-    switch (sd->postblits.dim)\n+    switch (sd->postblits.length)\n     {\n         case 0:\n             break;\n@@ -943,7 +943,7 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n         default:\n             Expression *e = NULL;\n             stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-            for (size_t i = 0; i < sd->postblits.dim; i++)\n+            for (size_t i = 0; i < sd->postblits.length; i++)\n             {\n                 FuncDeclaration *fd = sd->postblits[i];\n                 stc = mergeFuncAttrs(stc, fd);\n@@ -990,11 +990,11 @@ FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n         return NULL;\n \n     StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = ad->dtors.dim ? ad->dtors[0]->loc : ad->loc;\n+    Loc declLoc = ad->dtors.length ? ad->dtors[0]->loc : ad->loc;\n     Loc loc = Loc();    // internal code should have no loc to prevent coverage\n \n     Expression *e = NULL;\n-    for (size_t i = 0; i < ad->fields.dim; i++)\n+    for (size_t i = 0; i < ad->fields.length; i++)\n     {\n         VarDeclaration *v = ad->fields[i];\n         if (v->storage_class & STCref)\n@@ -1078,7 +1078,7 @@ FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n     }\n \n     FuncDeclaration *xdtor = NULL;\n-    switch (ad->dtors.dim)\n+    switch (ad->dtors.length)\n     {\n         case 0:\n             break;\n@@ -1090,7 +1090,7 @@ FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n         default:\n             e = NULL;\n             stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-            for (size_t i = 0; i < ad->dtors.dim; i++)\n+            for (size_t i = 0; i < ad->dtors.length; i++)\n             {\n                 FuncDeclaration *fd = ad->dtors[i];\n                 stc = mergeFuncAttrs(stc, fd);\n@@ -1138,7 +1138,7 @@ FuncDeclaration *buildInv(AggregateDeclaration *ad, Scope *sc)\n     Loc declLoc = ad->loc;\n     Loc loc = Loc();    // internal code should have no loc to prevent coverage\n \n-    switch (ad->invs.dim)\n+    switch (ad->invs.length)\n     {\n         case 0:\n             return NULL;\n@@ -1150,7 +1150,7 @@ FuncDeclaration *buildInv(AggregateDeclaration *ad, Scope *sc)\n         default:\n             Expression *e = NULL;\n             StorageClass stcx = 0;\n-            for (size_t i = 0; i < ad->invs.dim; i++)\n+            for (size_t i = 0; i < ad->invs.length; i++)\n             {\n                 stc = mergeFuncAttrs(stc, ad->invs[i]);\n                 if (stc & STCdisable)"}, {"sha": "124829b297dd22d6de315afef7be5482d2742f34", "filename": "gcc/d/dmd/compiler.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -11,6 +11,7 @@\n #pragma once\n \n #include \"root/array.h\"\n+#include \"root/bitarray.h\"\n \n // This file contains a data structure that describes a back-end compiler\n // and implements compiler-specific actions."}, {"sha": "8c97b2a1b4fbe00257e65da41cd3a26b4c83eaf5", "filename": "gcc/d/dmd/cond.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -33,7 +33,7 @@ int findCondition(Strings *ids, Identifier *ident)\n {\n     if (ids)\n     {\n-        for (size_t i = 0; i < ids->dim; i++)\n+        for (size_t i = 0; i < ids->length; i++)\n         {\n             const char *id = (*ids)[i];\n \n@@ -152,7 +152,7 @@ static Statement *createForeach(StaticForeach *sfe, Loc loc, Parameters *paramet\n     }\n     else\n     {\n-        assert(sfe->rangefe && parameters->dim == 1);\n+        assert(sfe->rangefe && parameters->length == 1);\n         return new ForeachRangeStatement(loc, sfe->rangefe->op, (*parameters)[0],\n                                          sfe->rangefe->lwr->syntaxCopy(),\n                                          sfe->rangefe->upr->syntaxCopy(), s, loc);\n@@ -236,7 +236,7 @@ static Expression *createTuple(Loc loc, TypeStruct *type, Expressions *e)\n \n static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n {\n-    size_t nvars = sfe->aggrfe ? sfe->aggrfe->parameters->dim : 1;\n+    size_t nvars = sfe->aggrfe ? sfe->aggrfe->parameters->length : 1;\n     Loc aloc = sfe->aggrfe ? sfe->aggrfe->aggr->loc : sfe->rangefe->lwr->loc;\n     // We need three sets of foreach loop variables because the\n     // lowering contains three foreach loops.\n@@ -264,7 +264,7 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n         for (size_t i = 0; i < 2; i++)\n         {\n             Expressions *e = new Expressions();\n-            for (size_t j = 0; j < pparams[0]->dim; j++)\n+            for (size_t j = 0; j < pparams[0]->length; j++)\n             {\n                 Parameter *p = (*pparams[i])[j];\n                 e->push(new IdentifierExp(aloc, p->ident));"}, {"sha": "a0364ef8c9001c5c6370ebf40e4c5d7e1d6fc57e", "filename": "gcc/d/dmd/constfold.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -787,7 +787,7 @@ UnionExp Equal(TOK op, Loc loc, Type *type, Expression *e1, Expression *e2)\n         else if (e2->op == TOKarrayliteral)\n         {\n             ArrayLiteralExp *es2 = (ArrayLiteralExp *)e2;\n-            cmp = !es2->elements || (0 == es2->elements->dim);\n+            cmp = !es2->elements || (0 == es2->elements->length);\n         }\n         else\n         {\n@@ -805,7 +805,7 @@ UnionExp Equal(TOK op, Loc loc, Type *type, Expression *e1, Expression *e2)\n         else if (e1->op == TOKarrayliteral)\n         {\n             ArrayLiteralExp *es1 = (ArrayLiteralExp *)e1;\n-            cmp = !es1->elements || (0 == es1->elements->dim);\n+            cmp = !es1->elements || (0 == es1->elements->length);\n         }\n         else\n         {\n@@ -835,16 +835,16 @@ UnionExp Equal(TOK op, Loc loc, Type *type, Expression *e1, Expression *e2)\n         ArrayLiteralExp *es1 = (ArrayLiteralExp *)e1;\n         ArrayLiteralExp *es2 = (ArrayLiteralExp *)e2;\n \n-        if ((!es1->elements || !es1->elements->dim) &&\n-            (!es2->elements || !es2->elements->dim))\n+        if ((!es1->elements || !es1->elements->length) &&\n+            (!es2->elements || !es2->elements->length))\n             cmp = 1;            // both arrays are empty\n         else if (!es1->elements || !es2->elements)\n             cmp = 0;\n-        else if (es1->elements->dim != es2->elements->dim)\n+        else if (es1->elements->length != es2->elements->length)\n             cmp = 0;\n         else\n         {\n-            for (size_t i = 0; i < es1->elements->dim; i++)\n+            for (size_t i = 0; i < es1->elements->length; i++)\n             {\n                 Expression *ee1 = es1->getElement(i);\n                 Expression *ee2 = es2->getElement(i);\n@@ -871,7 +871,7 @@ UnionExp Equal(TOK op, Loc loc, Type *type, Expression *e1, Expression *e2)\n         StringExp *es1 = (StringExp *)e1;\n         ArrayLiteralExp *es2 = (ArrayLiteralExp *)e2;\n         size_t dim1 = es1->len;\n-        size_t dim2 = es2->elements ? es2->elements->dim : 0;\n+        size_t dim2 = es2->elements ? es2->elements->length : 0;\n         if (dim1 != dim2)\n             cmp = 0;\n         else\n@@ -899,17 +899,17 @@ UnionExp Equal(TOK op, Loc loc, Type *type, Expression *e1, Expression *e2)\n \n         if (es1->sd != es2->sd)\n             cmp = 0;\n-        else if ((!es1->elements || !es1->elements->dim) &&\n-            (!es2->elements || !es2->elements->dim))\n+        else if ((!es1->elements || !es1->elements->length) &&\n+            (!es2->elements || !es2->elements->length))\n             cmp = 1;            // both arrays are empty\n         else if (!es1->elements || !es2->elements)\n             cmp = 0;\n-        else if (es1->elements->dim != es2->elements->dim)\n+        else if (es1->elements->length != es2->elements->length)\n             cmp = 0;\n         else\n         {\n             cmp = 1;\n-            for (size_t i = 0; i < es1->elements->dim; i++)\n+            for (size_t i = 0; i < es1->elements->length; i++)\n             {\n                 Expression *ee1 = (*es1->elements)[i];\n                 Expression *ee2 = (*es2->elements)[i];\n@@ -1235,7 +1235,7 @@ UnionExp Cast(Loc loc, Type *type, Type *to, Expression *e1)\n         StructDeclaration *sd = tb->toDsymbol(NULL)->isStructDeclaration();\n         assert(sd);\n         Expressions *elements = new Expressions;\n-        for (size_t i = 0; i < sd->fields.dim; i++)\n+        for (size_t i = 0; i < sd->fields.length; i++)\n         {\n             VarDeclaration *v = sd->fields[i];\n             UnionExp zero;\n@@ -1276,14 +1276,14 @@ UnionExp ArrayLength(Type *type, Expression *e1)\n     else if (e1->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e1;\n-        size_t dim = ale->elements ? ale->elements->dim : 0;\n+        size_t dim = ale->elements ? ale->elements->length : 0;\n \n         new(&ue) IntegerExp(loc, dim, type);\n     }\n     else if (e1->op == TOKassocarrayliteral)\n     {\n         AssocArrayLiteralExp *ale = (AssocArrayLiteralExp *)e1;\n-        size_t dim = ale->keys->dim;\n+        size_t dim = ale->keys->length;\n \n         new(&ue) IntegerExp(loc, dim, type);\n     }\n@@ -1353,9 +1353,9 @@ UnionExp Index(Type *type, Expression *e1, Expression *e2)\n         if (e1->op == TOKarrayliteral)\n         {\n             ArrayLiteralExp *ale = (ArrayLiteralExp *)e1;\n-            if (i >= ale->elements->dim)\n+            if (i >= ale->elements->length)\n             {\n-                e1->error(\"array index %llu is out of bounds %s[0 .. %u]\", i, e1->toChars(), ale->elements->dim);\n+                e1->error(\"array index %llu is out of bounds %s[0 .. %u]\", i, e1->toChars(), ale->elements->length);\n                 new(&ue) ErrorExp();\n             }\n             else\n@@ -1377,7 +1377,7 @@ UnionExp Index(Type *type, Expression *e1, Expression *e2)\n         AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)e1;\n         /* Search the keys backwards, in case there are duplicate keys\n          */\n-        for (size_t i = ae->keys->dim; i;)\n+        for (size_t i = ae->keys->length; i;)\n         {\n             i--;\n             Expression *ekey = (*ae->keys)[i];\n@@ -1445,7 +1445,7 @@ UnionExp Slice(Type *type, Expression *e1, Expression *lwr, Expression *upr)\n         uinteger_t ilwr = lwr->toInteger();\n         uinteger_t iupr = upr->toInteger();\n \n-        if (iupr > es1->elements->dim || ilwr > iupr)\n+        if (iupr > es1->elements->length || ilwr > iupr)\n         {\n             e1->error(\"array slice [%llu .. %llu] is out of bounds\", ilwr, iupr);\n             new(&ue) ErrorExp();\n@@ -1496,7 +1496,7 @@ void sliceAssignArrayLiteralFromString(ArrayLiteralExp *existingAE, StringExp *n\n void sliceAssignStringFromArrayLiteral(StringExp *existingSE, ArrayLiteralExp *newae, size_t firstIndex)\n {\n     void *s = existingSE->string;\n-    for (size_t j = 0; j < newae->elements->dim; j++)\n+    for (size_t j = 0; j < newae->elements->length; j++)\n     {\n         unsigned val = (unsigned)newae->getElement(j)->toInteger();\n         switch (existingSE->sz)\n@@ -1686,16 +1686,16 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         // [chars] ~ string --> [chars]\n         StringExp *es = (StringExp *)e2;\n         ArrayLiteralExp *ea = (ArrayLiteralExp *)e1;\n-        size_t len = es->len + ea->elements->dim;\n+        size_t len = es->len + ea->elements->length;\n         Expressions * elems = new Expressions;\n         elems->setDim(len);\n-        for (size_t i= 0; i < ea->elements->dim; ++i)\n+        for (size_t i= 0; i < ea->elements->length; ++i)\n         {\n             (*elems)[i] = ea->getElement(i);\n         }\n         new(&ue) ArrayLiteralExp(e1->loc, type, elems);\n         ArrayLiteralExp *dest = (ArrayLiteralExp *)ue.exp();\n-        sliceAssignArrayLiteralFromString(dest, es, ea->elements->dim);\n+        sliceAssignArrayLiteralFromString(dest, es, ea->elements->length);\n         assert(ue.exp()->type);\n         return ue;\n     }\n@@ -1705,10 +1705,10 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         // string ~ [chars] --> [chars]\n         StringExp *es = (StringExp *)e1;\n         ArrayLiteralExp *ea = (ArrayLiteralExp *)e2;\n-        size_t len = es->len + ea->elements->dim;\n+        size_t len = es->len + ea->elements->length;\n         Expressions * elems = new Expressions;\n         elems->setDim(len);\n-        for (size_t i= 0; i < ea->elements->dim; ++i)\n+        for (size_t i= 0; i < ea->elements->length; ++i)\n         {\n             (*elems)[es->len + i] = ea->getElement(i);\n         }\n@@ -1786,7 +1786,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n         {\n-            e->type = t1->nextOf()->sarrayOf(elems->dim);\n+            e->type = t1->nextOf()->sarrayOf(elems->length);\n         }\n         else\n             e->type = type;\n@@ -1812,7 +1812,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n         {\n-            e->type = t1->nextOf()->sarrayOf(elems->dim);\n+            e->type = t1->nextOf()->sarrayOf(elems->length);\n         }\n         else\n             e->type = type;\n@@ -1832,7 +1832,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n         {\n-            e->type = e2->type->sarrayOf(elems->dim);\n+            e->type = e2->type->sarrayOf(elems->length);\n         }\n         else\n             e->type = type;\n@@ -1849,7 +1849,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n         {\n-            e->type = e1->type->sarrayOf(elems->dim);\n+            e->type = e1->type->sarrayOf(elems->length);\n         }\n         else\n             e->type = type;"}, {"sha": "a50802225aa3c3d1654cb207cd7ec022f4ce03d4", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -88,7 +88,7 @@ class CppMangleVisitor : public Visitor\n     int find(RootObject *p)\n     {\n         //printf(\"find %p %d %s\\n\", p, p.dyncast(), p ? p.toChars() : NULL);\n-        for (size_t i = 0; i < components.dim; i++)\n+        for (size_t i = 0; i < components.length; i++)\n         {\n             if (p == components[i])\n                 return (int)i;\n@@ -166,7 +166,7 @@ class CppMangleVisitor : public Visitor\n         if (!ti)                // could happen if std::basic_string is not a template\n             return;\n         buf->writeByte('I');\n-        for (size_t i = 0; i < ti->tiargs->dim; i++)\n+        for (size_t i = 0; i < ti->tiargs->length; i++)\n         {\n             RootObject *o = (*ti->tiargs)[i];\n             TemplateDeclaration *td = ti->tempdecl->isTemplateDeclaration();\n@@ -184,7 +184,7 @@ class CppMangleVisitor : public Visitor\n                 buf->writeByte('I');     // argument pack\n \n                 // mangle the rest of the arguments as types\n-                for (size_t j = i; j < ti->tiargs->dim; j++)\n+                for (size_t j = i; j < ti->tiargs->length; j++)\n                 {\n                     Type *t = isType((*ti->tiargs)[j]);\n                     assert(t);\n@@ -365,7 +365,7 @@ class CppMangleVisitor : public Visitor\n         if (!ti)\n             return false;\n         Dsymbol *q = getQualifier(ti);\n-        return isStd(q) && ti->tiargs->dim == 1 && isChar((*ti->tiargs)[0]);\n+        return isStd(q) && ti->tiargs->length == 1 && isChar((*ti->tiargs)[0]);\n     }\n \n     /***\n@@ -376,7 +376,7 @@ class CppMangleVisitor : public Visitor\n      */\n     bool char_std_char_traits_char(TemplateInstance *ti, const char *st)\n     {\n-        if (ti->tiargs->dim == 2 &&\n+        if (ti->tiargs->length == 2 &&\n             isChar((*ti->tiargs)[0]) &&\n             isChar_traits_char((*ti->tiargs)[1]))\n         {\n@@ -411,7 +411,7 @@ class CppMangleVisitor : public Visitor\n                         if (s->ident == Id::basic_string)\n                         {\n                             // ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>\n-                            if (ti->tiargs->dim == 3 &&\n+                            if (ti->tiargs->length == 3 &&\n                                 isChar((*ti->tiargs)[0]) &&\n                                 isChar_traits_char((*ti->tiargs)[1]) &&\n                                 isAllocator_char((*ti->tiargs)[2]))\n@@ -491,7 +491,7 @@ class CppMangleVisitor : public Visitor\n                 else if (s->ident == Id::basic_string)\n                 {\n                     // ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>\n-                    if (ti->tiargs->dim == 3 &&\n+                    if (ti->tiargs->length == 3 &&\n                         isChar((*ti->tiargs)[0]) &&\n                         isChar_traits_char((*ti->tiargs)[1]) &&\n                         isAllocator_char((*ti->tiargs)[2]))"}, {"sha": "16ffede488291bb30f66ba1a9596632e7620561a", "filename": "gcc/d/dmd/ctfeexpr.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -43,18 +43,18 @@ int ClassReferenceExp::getFieldIndex(Type *fieldtype, unsigned fieldoffset)\n {\n     ClassDeclaration *cd = originalClass();\n     unsigned fieldsSoFar = 0;\n-    for (size_t j = 0; j < value->elements->dim; j++)\n+    for (size_t j = 0; j < value->elements->length; j++)\n     {\n-        while (j - fieldsSoFar >= cd->fields.dim)\n+        while (j - fieldsSoFar >= cd->fields.length)\n         {\n-            fieldsSoFar += cd->fields.dim;\n+            fieldsSoFar += cd->fields.length;\n             cd = cd->baseClass;\n         }\n         VarDeclaration *v2 = cd->fields[j - fieldsSoFar];\n         if (fieldoffset == v2->offset &&\n             fieldtype->size() == v2->type->size())\n         {\n-            return (int)(value->elements->dim - fieldsSoFar - cd->fields.dim + (j-fieldsSoFar));\n+            return (int)(value->elements->length - fieldsSoFar - cd->fields.length + (j-fieldsSoFar));\n         }\n     }\n     return -1;\n@@ -66,17 +66,17 @@ int ClassReferenceExp::findFieldIndexByName(VarDeclaration *v)\n {\n     ClassDeclaration *cd = originalClass();\n     size_t fieldsSoFar = 0;\n-    for (size_t j = 0; j < value->elements->dim; j++)\n+    for (size_t j = 0; j < value->elements->length; j++)\n     {\n-        while (j - fieldsSoFar >= cd->fields.dim)\n+        while (j - fieldsSoFar >= cd->fields.length)\n         {\n-            fieldsSoFar += cd->fields.dim;\n+            fieldsSoFar += cd->fields.length;\n             cd = cd->baseClass;\n         }\n         VarDeclaration *v2 = cd->fields[j - fieldsSoFar];\n         if (v == v2)\n         {\n-            return (int)(value->elements->dim - fieldsSoFar - cd->fields.dim + (j-fieldsSoFar));\n+            return (int)(value->elements->length - fieldsSoFar - cd->fields.length + (j-fieldsSoFar));\n         }\n     }\n     return -1;\n@@ -100,7 +100,7 @@ const char *VoidInitExp::toChars()\n // Same as getFieldIndex, but checks for a direct match with the VarDeclaration\n int findFieldIndexByName(StructDeclaration *sd, VarDeclaration *v)\n {\n-    for (size_t i = 0; i < sd->fields.dim; ++i)\n+    for (size_t i = 0; i < sd->fields.length; ++i)\n     {\n         if (sd->fields[i] == v)\n             return (int)i;\n@@ -229,8 +229,8 @@ Expressions *copyLiteralArray(Expressions *oldelems, Expression *basis = NULL)\n         return oldelems;\n     CtfeStatus::numArrayAllocs++;\n     Expressions *newelems = new Expressions();\n-    newelems->setDim(oldelems->dim);\n-    for (size_t i = 0; i < oldelems->dim; i++)\n+    newelems->setDim(oldelems->length);\n+    for (size_t i = 0; i < oldelems->length; i++)\n     {\n         Expression *el = (*oldelems)[i];\n         if (!el)\n@@ -288,8 +288,8 @@ UnionExp copyLiteral(Expression *e)\n         StructLiteralExp *sle = (StructLiteralExp *)e;\n         Expressions *oldelems = sle->elements;\n         Expressions * newelems = new Expressions();\n-        newelems->setDim(oldelems->dim);\n-        for (size_t i = 0; i < newelems->dim; i++)\n+        newelems->setDim(oldelems->length);\n+        for (size_t i = 0; i < newelems->length; i++)\n         {\n             // We need the struct definition to detect block assignment\n             VarDeclaration *v = sle->sd->fields[i];\n@@ -534,12 +534,12 @@ uinteger_t resolveArrayLength(Expression *e)\n     if (e->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n-        return ale->elements ? ale->elements->dim : 0;\n+        return ale->elements ? ale->elements->length : 0;\n     }\n     if (e->op == TOKassocarrayliteral)\n     {\n         AssocArrayLiteralExp *ale = (AssocArrayLiteralExp *)e;\n-        return ale->keys->dim;\n+        return ale->keys->length;\n     }\n     assert(0);\n     return 0;\n@@ -1314,16 +1314,16 @@ int ctfeRawCmp(Loc loc, Expression *e1, Expression *e2)\n \n         if (es1->sd != es2->sd)\n             return 1;\n-        else if ((!es1->elements || !es1->elements->dim) &&\n-            (!es2->elements || !es2->elements->dim))\n+        else if ((!es1->elements || !es1->elements->length) &&\n+            (!es2->elements || !es2->elements->length))\n             return 0;            // both arrays are empty\n         else if (!es1->elements || !es2->elements)\n             return 1;\n-        else if (es1->elements->dim != es2->elements->dim)\n+        else if (es1->elements->length != es2->elements->length)\n             return 1;\n         else\n         {\n-            for (size_t i = 0; i < es1->elements->dim; i++)\n+            for (size_t i = 0; i < es1->elements->length; i++)\n             {\n                 Expression *ee1 = (*es1->elements)[i];\n                 Expression *ee2 = (*es2->elements)[i];\n@@ -1344,8 +1344,8 @@ int ctfeRawCmp(Loc loc, Expression *e1, Expression *e2)\n         AssocArrayLiteralExp *es1 = (AssocArrayLiteralExp *)e1;\n         AssocArrayLiteralExp *es2 = (AssocArrayLiteralExp *)e2;\n \n-        size_t dim = es1->keys->dim;\n-        if (es2->keys->dim != dim)\n+        size_t dim = es1->keys->length;\n+        if (es2->keys->length != dim)\n             return 1;\n \n         bool *used = (bool *)mem.xmalloc(sizeof(bool) * dim);\n@@ -1459,12 +1459,12 @@ UnionExp ctfeCat(Loc loc, Type *type, Expression *e1, Expression *e2)\n         // [chars] ~ string => string (only valid for CTFE)\n         StringExp *es1 = (StringExp *)e2;\n         ArrayLiteralExp *es2 = (ArrayLiteralExp *)e1;\n-        size_t len = es1->len + es2->elements->dim;\n+        size_t len = es1->len + es2->elements->length;\n         unsigned char sz = es1->sz;\n \n         void *s = mem.xmalloc((len + 1) * sz);\n-        memcpy((char *)s + sz * es2->elements->dim, es1->string, es1->len * sz);\n-        for (size_t i = 0; i < es2->elements->dim; i++)\n+        memcpy((char *)s + sz * es2->elements->length, es1->string, es1->len * sz);\n+        for (size_t i = 0; i < es2->elements->length; i++)\n         {\n             Expression *es2e = (*es2->elements)[i];\n             if (es2e->op != TOKint64)\n@@ -1493,12 +1493,12 @@ UnionExp ctfeCat(Loc loc, Type *type, Expression *e1, Expression *e2)\n         // Concatenate the strings\n         StringExp *es1 = (StringExp *)e1;\n         ArrayLiteralExp *es2 = (ArrayLiteralExp *)e2;\n-        size_t len = es1->len + es2->elements->dim;\n+        size_t len = es1->len + es2->elements->length;\n         unsigned char sz = es1->sz;\n \n         void *s = mem.xmalloc((len + 1) * sz);\n         memcpy(s, es1->string, es1->len * sz);\n-        for (size_t i = 0; i < es2->elements->dim; i++)\n+        for (size_t i = 0; i < es2->elements->length; i++)\n         {\n             Expression *es2e = (*es2->elements)[i];\n             if (es2e->op != TOKint64)\n@@ -1529,7 +1529,7 @@ UnionExp ctfeCat(Loc loc, Type *type, Expression *e1, Expression *e2)\n \n         new(&ue) ArrayLiteralExp(es1->loc, type, copyLiteralArray(es1->elements));\n         es1 = (ArrayLiteralExp *)ue.exp();\n-        es1->elements->insert(es1->elements->dim, copyLiteralArray(es2->elements));\n+        es1->elements->insert(es1->elements->length, copyLiteralArray(es2->elements));\n         return ue;\n     }\n     if (e1->op == TOKarrayliteral && e2->op == TOKnull &&\n@@ -1557,7 +1557,7 @@ Expression *findKeyInAA(Loc loc, AssocArrayLiteralExp *ae, Expression *e2)\n {\n     /* Search the keys backwards, in case there are duplicate keys\n      */\n-    for (size_t i = ae->keys->dim; i;)\n+    for (size_t i = ae->keys->length; i;)\n     {\n         i--;\n         Expression *ekey = (*ae->keys)[i];\n@@ -1591,9 +1591,9 @@ Expression *ctfeIndex(Loc loc, Type *type, Expression *e1, uinteger_t indx)\n     assert(e1->op == TOKarrayliteral);\n     {\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e1;\n-        if (indx >= ale->elements->dim)\n+        if (indx >= ale->elements->length)\n         {\n-            error(loc, \"array index %llu is out of bounds %s[0 .. %llu]\", (ulonglong)indx, e1->toChars(), (ulonglong)ale->elements->dim);\n+            error(loc, \"array index %llu is out of bounds %s[0 .. %llu]\", (ulonglong)indx, e1->toChars(), (ulonglong)ale->elements->length);\n             return CTFEExp::cantexp;\n         }\n         Expression *e = (*ale->elements)[(size_t)indx];\n@@ -1680,7 +1680,7 @@ void assignInPlace(Expression *dest, Expression *src)\n         assert(dest->op == src->op);\n         oldelems = ((StructLiteralExp *)dest)->elements;\n         newelems = ((StructLiteralExp *)src)->elements;\n-        if (((StructLiteralExp *)dest)->sd->isNested() && oldelems->dim == newelems->dim - 1)\n+        if (((StructLiteralExp *)dest)->sd->isNested() && oldelems->length == newelems->length - 1)\n             oldelems->push(NULL);\n     }\n     else if (dest->op == TOKarrayliteral && src->op==TOKarrayliteral)\n@@ -1706,9 +1706,9 @@ void assignInPlace(Expression *dest, Expression *src)\n     else\n         assert(0);\n \n-    assert(oldelems->dim == newelems->dim);\n+    assert(oldelems->length == newelems->length);\n \n-    for (size_t i= 0; i < oldelems->dim; ++i)\n+    for (size_t i= 0; i < oldelems->length; ++i)\n     {\n         Expression *e = (*newelems)[i];\n         Expression *o = (*oldelems)[i];\n@@ -1734,8 +1734,8 @@ Expressions *changeOneElement(Expressions *oldelems, size_t indexToChange, Expre\n {\n     Expressions *expsx = new Expressions();\n     ++CtfeStatus::numArrayAllocs;\n-    expsx->setDim(oldelems->dim);\n-    for (size_t j = 0; j < expsx->dim; j++)\n+    expsx->setDim(oldelems->length);\n+    for (size_t j = 0; j < expsx->length; j++)\n     {\n         if (j == indexToChange)\n             (*expsx)[j] = newelem;\n@@ -1754,7 +1754,7 @@ Expression *assignAssocArrayElement(Loc loc, AssocArrayLiteralExp *aae,\n     Expressions *keysx = aae->keys;\n     Expressions *valuesx = aae->values;\n     int updated = 0;\n-    for (size_t j = valuesx->dim; j; )\n+    for (size_t j = valuesx->length; j; )\n     {\n         j--;\n         Expression *ekey = (*aae->keys)[j];\n@@ -2027,13 +2027,13 @@ void showCtfeExpr(Expression *e, int level)\n     if (elements)\n     {\n         size_t fieldsSoFar = 0;\n-        for (size_t i = 0; i < elements->dim; i++)\n+        for (size_t i = 0; i < elements->length; i++)\n         {\n             Expression *z = NULL;\n             VarDeclaration *v = NULL;\n             if (i > 15)\n             {\n-                printf(\"...(total %d elements)\\n\", (int)elements->dim);\n+                printf(\"...(total %d elements)\\n\", (int)elements->length);\n                 return;\n             }\n             if (sd)\n@@ -2043,17 +2043,17 @@ void showCtfeExpr(Expression *e, int level)\n             }\n             else if (cd)\n             {\n-                while (i - fieldsSoFar >= cd->fields.dim)\n+                while (i - fieldsSoFar >= cd->fields.length)\n                 {\n-                    fieldsSoFar += cd->fields.dim;\n+                    fieldsSoFar += cd->fields.length;\n                     cd = cd->baseClass;\n                     for (int j = level; j > 0; --j) printf(\" \");\n                     printf(\" BASE CLASS: %s\\n\", cd->toChars());\n                 }\n                 v = cd->fields[i - fieldsSoFar];\n-                assert((elements->dim + i) >= (fieldsSoFar + cd->fields.dim));\n-                size_t indx = (elements->dim - fieldsSoFar)- cd->fields.dim + i;\n-                assert(indx < elements->dim);\n+                assert((elements->length + i) >= (fieldsSoFar + cd->fields.length));\n+                size_t indx = (elements->length - fieldsSoFar)- cd->fields.length + i;\n+                assert(indx < elements->length);\n                 z = (*elements)[indx];\n             }\n             if (!z)\n@@ -2109,8 +2109,8 @@ UnionExp voidInitLiteral(Type *t, VarDeclaration *var)\n     {\n         TypeStruct *ts = (TypeStruct *)t;\n         Expressions *exps = new Expressions();\n-        exps->setDim(ts->sym->fields.dim);\n-        for (size_t i = 0; i < ts->sym->fields.dim; i++)\n+        exps->setDim(ts->sym->fields.length);\n+        for (size_t i = 0; i < ts->sym->fields.length; i++)\n         {\n             (*exps)[i] = voidInitLiteral(ts->sym->fields[i]->type, ts->sym->fields[i]).copy();\n         }"}, {"sha": "20e8dc61438d2e60a2e3387f0096408b69b2e094", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -148,7 +148,7 @@ Expression *implicitCastTo(Expression *e, Scope *sc, Type *t)\n                 Type *tb = t->toBasetype();\n                 Type *tx;\n                 if (tb->ty == Tsarray)\n-                    tx = tb->nextOf()->sarrayOf(ale->elements ? ale->elements->dim : 0);\n+                    tx = tb->nextOf()->sarrayOf(ale->elements ? ale->elements->length : 0);\n                 else\n                     tx = tb->nextOf()->arrayOf();\n                 e->e1 = ale->implicitCastTo(sc, tx);\n@@ -515,7 +515,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                 ((TypeStruct *)e->type)->sym == ((TypeStruct *)t)->sym)\n             {\n                 result = MATCHconst;\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     Expression *el = (*e->elements)[i];\n                     if (!el)\n@@ -658,12 +658,12 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                 if (tb->ty == Tsarray)\n                 {\n                     TypeSArray *tsa = (TypeSArray *)tb;\n-                    if (e->elements->dim != tsa->dim->toInteger())\n+                    if (e->elements->length != tsa->dim->toInteger())\n                         result = MATCHnomatch;\n                 }\n \n                 Type *telement = tb->nextOf();\n-                if (!e->elements->dim)\n+                if (!e->elements->length)\n                 {\n                     if (typen->ty != Tvoid)\n                         result = typen->implicitConvTo(telement);\n@@ -676,7 +676,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                         if (m < result)\n                             result = m;\n                     }\n-                    for (size_t i = 0; i < e->elements->dim; i++)\n+                    for (size_t i = 0; i < e->elements->length; i++)\n                     {\n                         Expression *el = (*e->elements)[i];\n                         if (result == MATCHnomatch)\n@@ -702,7 +702,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                 TypeVector *tv = (TypeVector *)tb;\n                 TypeSArray *tbase = (TypeSArray *)tv->basetype;\n                 assert(tbase->ty == Tsarray);\n-                const size_t edim = e->elements->dim;\n+                const size_t edim = e->elements->length;\n                 const size_t tbasedim = tbase->dim->toInteger();\n                 if (edim > tbasedim)\n                 {\n@@ -740,7 +740,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n             if (tb->ty == Taarray && typeb->ty == Taarray)\n             {\n                 result = MATCHexact;\n-                for (size_t i = 0; i < e->keys->dim; i++)\n+                for (size_t i = 0; i < e->keys->length; i++)\n                 {\n                     Expression *el = (*e->keys)[i];\n                     MATCH m = el->implicitConvTo(((TypeAArray *)tb)->index);\n@@ -849,7 +849,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                 if (targ->constConv(targ->castMod(mod)) == MATCHnomatch)\n                     return;\n             }\n-            for (size_t i = j; i < e->arguments->dim; ++i)\n+            for (size_t i = j; i < e->arguments->length; ++i)\n             {\n                 Expression *earg = (*e->arguments)[i];\n                 Type *targ = earg->type->toBasetype();\n@@ -895,7 +895,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n             {\n                 OverExp *eo = (OverExp *)e->e1;\n                 FuncDeclaration *f = NULL;\n-                for (size_t i = 0; i < eo->vars->a.dim; i++)\n+                for (size_t i = 0; i < eo->vars->a.length; i++)\n                 {\n                     Dsymbol *s = eo->vars->a[i];\n                     FuncDeclaration *f2 = s->isFuncDeclaration();\n@@ -1126,7 +1126,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n \n                 size_t nparams = Parameter::dim(tf->parameters);\n                 size_t j = (tf->linkage == LINKd && tf->varargs == 1); // if TypeInfoArray was prepended\n-                for (size_t i = j; i < e->arguments->dim; ++i)\n+                for (size_t i = j; i < e->arguments->length; ++i)\n                 {\n                     Expression *earg = (*args)[i];\n                     Type *targ = earg->type->toBasetype();\n@@ -1156,7 +1156,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n              */\n             if (!e->member && e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; ++i)\n+                for (size_t i = 0; i < e->arguments->length; ++i)\n                 {\n                     Expression *earg = (*e->arguments)[i];\n                     if (!earg)  // Bugzilla 14853: if it's on overlapped field\n@@ -1201,7 +1201,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                     {\n                         static bool convertible(Loc loc, ClassDeclaration *cd, MOD mod)\n                         {\n-                            for (size_t i = 0; i < cd->fields.dim; i++)\n+                            for (size_t i = 0; i < cd->fields.length; i++)\n                             {\n                                 VarDeclaration *v = cd->fields[i];\n                                 Initializer *init = v->_init;\n@@ -1902,7 +1902,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                 {\n                     OverExp *eo = (OverExp *)e->e1;\n                     FuncDeclaration *f = NULL;\n-                    for (size_t i = 0; i < eo->vars->a.dim; i++)\n+                    for (size_t i = 0; i < eo->vars->a.length; i++)\n                     {\n                         Dsymbol *s = eo->vars->a[i];\n                         FuncDeclaration *f2 = s->isFuncDeclaration();\n@@ -1976,7 +1976,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n             TupleExp *te = (TupleExp *)e->copy();\n             te->e0 = e->e0 ? e->e0->copy() : NULL;\n             te->exps = (Expressions *)e->exps->copy();\n-            for (size_t i = 0; i < te->exps->dim; i++)\n+            for (size_t i = 0; i < te->exps->length; i++)\n             {\n                 Expression *ex = (*te->exps)[i];\n                 ex = ex->castTo(sc, t);\n@@ -2022,15 +2022,15 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                     if (tb->ty == Tsarray)\n                     {\n                         TypeSArray *tsa = (TypeSArray *)tb;\n-                        if (e->elements->dim != tsa->dim->toInteger())\n+                        if (e->elements->length != tsa->dim->toInteger())\n                             goto L1;\n                     }\n \n                     ae = (ArrayLiteralExp *)e->copy();\n                     if (e->basis)\n                         ae->basis = e->basis->castTo(sc, tb->nextOf());\n                     ae->elements = e->elements->copy();\n-                    for (size_t i = 0; i < e->elements->dim; i++)\n+                    for (size_t i = 0; i < e->elements->length; i++)\n                     {\n                         Expression *ex = (*e->elements)[i];\n                         if (!ex)\n@@ -2059,7 +2059,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                 TypeVector *tv = (TypeVector *)tb;\n                 TypeSArray *tbase = (TypeSArray *)tv->basetype;\n                 assert(tbase->ty == Tsarray);\n-                const size_t edim = e->elements->dim;\n+                const size_t edim = e->elements->length;\n                 const size_t tbasedim = tbase->dim->toInteger();\n                 if (edim > tbasedim)\n                     goto L1;\n@@ -2106,8 +2106,8 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                 AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)e->copy();\n                 ae->keys = e->keys->copy();\n                 ae->values = e->values->copy();\n-                assert(e->keys->dim == e->values->dim);\n-                for (size_t i = 0; i < e->keys->dim; i++)\n+                assert(e->keys->length == e->values->length);\n+                for (size_t i = 0; i < e->keys->length; i++)\n                 {\n                     Expression *ex = (*e->values)[i];\n                     ex = ex->castTo(sc, tb->nextOf());\n@@ -2408,7 +2408,7 @@ Expression *inferType(Expression *e, Type *t, int flag)\n                 Type *tn = tb->nextOf();\n                 if (ale->basis)\n                     ale->basis = inferType(ale->basis, tn, flag);\n-                for (size_t i = 0; i < ale->elements->dim; i++)\n+                for (size_t i = 0; i < ale->elements->length; i++)\n                 {\n                     Expression *e = (*ale->elements)[i];\n                     if (e)\n@@ -2429,7 +2429,7 @@ Expression *inferType(Expression *e, Type *t, int flag)\n                 TypeAArray *taa = (TypeAArray *)tb;\n                 Type *ti = taa->index;\n                 Type *tv = taa->nextOf();\n-                for (size_t i = 0; i < aale->keys->dim; i++)\n+                for (size_t i = 0; i < aale->keys->length; i++)\n                 {\n                     Expression *e = (*aale->keys)[i];\n                     if (e)\n@@ -2438,7 +2438,7 @@ Expression *inferType(Expression *e, Type *t, int flag)\n                         (*aale->keys)[i] = e;\n                     }\n                 }\n-                for (size_t i = 0; i < aale->values->dim; i++)\n+                for (size_t i = 0; i < aale->values->length; i++)\n                 {\n                     Expression *e = (*aale->values)[i];\n                     if (e)\n@@ -2552,7 +2552,7 @@ Expression *scaleFactor(BinExp *be, Scope *sc)\n bool isVoidArrayLiteral(Expression *e, Type *other)\n {\n     while (e->op == TOKarrayliteral && e->type->ty == Tarray\n-        && (((ArrayLiteralExp *)e)->elements->dim == 1))\n+        && (((ArrayLiteralExp *)e)->elements->length == 1))\n     {\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n         e = ale->getElement(0);\n@@ -2566,7 +2566,7 @@ bool isVoidArrayLiteral(Expression *e, Type *other)\n     Type *t = e->type;\n     return (e->op == TOKarrayliteral && t->ty == Tarray &&\n         t->nextOf()->ty == Tvoid &&\n-        ((ArrayLiteralExp *)e)->elements->dim == 0);\n+        ((ArrayLiteralExp *)e)->elements->length == 0);\n }\n \n // used by deduceType()"}, {"sha": "754a996ff50987c15023e0172292e6ddf42c90eb", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -62,7 +62,7 @@ ClassDeclaration::ClassDeclaration(Loc loc, Identifier *id, BaseClasses *basecla\n \n     vtblInterfaces = NULL;\n \n-    //printf(\"ClassDeclaration(%s), dim = %d\\n\", id->toChars(), this->baseclasses->dim);\n+    //printf(\"ClassDeclaration(%s), dim = %d\\n\", id->toChars(), this->baseclasses->length);\n \n     // For forward references\n     type = new TypeClass(this);\n@@ -261,8 +261,8 @@ Dsymbol *ClassDeclaration::syntaxCopy(Dsymbol *s)\n \n     cd->storage_class |= storage_class;\n \n-    cd->baseclasses->setDim(this->baseclasses->dim);\n-    for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+    cd->baseclasses->setDim(this->baseclasses->length);\n+    for (size_t i = 0; i < cd->baseclasses->length; i++)\n     {\n         BaseClass *b = (*this->baseclasses)[i];\n         BaseClass *b2 = new BaseClass(b->type->syntaxCopy());\n@@ -402,7 +402,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         baseok = BASEOKin;\n \n         // Expand any tuples in baseclasses[]\n-        for (size_t i = 0; i < baseclasses->dim; )\n+        for (size_t i = 0; i < baseclasses->length; )\n         {\n             BaseClass *b = (*baseclasses)[i];\n             b->type = resolveBase(this, sc, scx, b->type);\n@@ -433,7 +433,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         }\n \n         // See if there's a base class as first in baseclasses[]\n-        if (baseclasses->dim)\n+        if (baseclasses->length)\n         {\n             BaseClass *b = (*baseclasses)[0];\n             Type *tb = b->type->toBasetype();\n@@ -492,7 +492,7 @@ void ClassDeclaration::semantic(Scope *sc)\n \n         // Treat the remaining entries in baseclasses as interfaces\n         // Check for errors, handle forward references\n-        for (size_t i = (baseClass ? 1 : 0); i < baseclasses->dim; )\n+        for (size_t i = (baseClass ? 1 : 0); i < baseclasses->length; )\n         {\n             BaseClass *b = (*baseclasses)[i];\n             Type *tb = b->type->toBasetype();\n@@ -588,7 +588,7 @@ void ClassDeclaration::semantic(Scope *sc)\n             storage_class |= baseClass->storage_class & STC_TYPECTOR;\n         }\n \n-        interfaces.length = baseclasses->dim - (baseClass ? 1 : 0);\n+        interfaces.length = baseclasses->length - (baseClass ? 1 : 0);\n         interfaces.ptr = baseclasses->tdata() + (baseClass ? 1 : 0);\n \n         for (size_t i = 0; i < interfaces.length; i++)\n@@ -625,7 +625,7 @@ void ClassDeclaration::semantic(Scope *sc)\n          * it can be resolved as a normal forward reference.\n          * Call addMember() and setScope() to make this class members visible from the base classes.\n          */\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->addMember(sc, this);\n@@ -636,7 +636,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         /* Set scope so if there are forward references, we still might be able to\n          * resolve individual members like enums.\n          */\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\"[%d] setScope %s %s, sc2 = %p\\n\", i, s->kind(), s->toChars(), sc2);\n@@ -646,7 +646,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         sc2->pop();\n     }\n \n-    for (size_t i = 0; i < baseclasses->dim; i++)\n+    for (size_t i = 0; i < baseclasses->length; i++)\n     {\n         BaseClass *b = (*baseclasses)[i];\n         Type *tb = b->type->toBasetype();\n@@ -673,14 +673,14 @@ void ClassDeclaration::semantic(Scope *sc)\n         // initialize vtbl\n         if (baseClass)\n         {\n-            if (isCPPclass() && baseClass->vtbl.dim == 0)\n+            if (isCPPclass() && baseClass->vtbl.length == 0)\n             {\n                 error(\"C++ base class %s needs at least one virtual function\", baseClass->toChars());\n             }\n \n             // Copy vtbl[] from base class\n-            vtbl.setDim(baseClass->vtbl.dim);\n-            memcpy(vtbl.tdata(), baseClass->vtbl.tdata(), sizeof(void *) * vtbl.dim);\n+            vtbl.setDim(baseClass->vtbl.length);\n+            memcpy(vtbl.tdata(), baseClass->vtbl.tdata(), sizeof(void *) * vtbl.length);\n \n             vthis = baseClass->vthis;\n         }\n@@ -727,14 +727,14 @@ void ClassDeclaration::semantic(Scope *sc)\n \n     Scope *sc2 = newScope(sc);\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc2);\n     }\n \n-    // Note that members.dim can grow due to tuple expansion during semantic()\n-    for (size_t i = 0; i < members->dim; i++)\n+    // Note that members.length can grow due to tuple expansion during semantic()\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic(sc2);\n@@ -750,7 +750,7 @@ void ClassDeclaration::semantic(Scope *sc)\n     /* Following special member functions creation needs semantic analysis\n      * completion of sub-structs in each field types.\n      */\n-    for (size_t i = 0; i < fields.dim; i++)\n+    for (size_t i = 0; i < fields.length; i++)\n     {\n         VarDeclaration *v = fields[i];\n         Type *tb = v->type->baseElemOf();\n@@ -783,7 +783,7 @@ void ClassDeclaration::semantic(Scope *sc)\n     if (!ctor && noDefaultCtor)\n     {\n         // A class object is always created by constructor, so this check is legitimate.\n-        for (size_t i = 0; i < fields.dim; i++)\n+        for (size_t i = 0; i < fields.length; i++)\n         {\n             VarDeclaration *v = fields[i];\n             if (v->storage_class & STCnodefaultctor)\n@@ -863,7 +863,7 @@ void ClassDeclaration::semantic(Scope *sc)\n     // Verify fields of a synchronized class are not public\n     if (storage_class & STCsynchronized)\n     {\n-        for (size_t i = 0; i < fields.dim; i++)\n+        for (size_t i = 0; i < fields.length; i++)\n         {\n             VarDeclaration *vd = fields[i];\n             if (!vd->isThisDeclaration() &&\n@@ -893,7 +893,7 @@ bool ClassDeclaration::isBaseOf2(ClassDeclaration *cd)\n     if (!cd)\n         return false;\n     //printf(\"ClassDeclaration::isBaseOf2(this = '%s', cd = '%s')\\n\", toChars(), cd->toChars());\n-    for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+    for (size_t i = 0; i < cd->baseclasses->length; i++)\n     {\n         BaseClass *b = (*cd->baseclasses)[i];\n         if (b->sym == this || isBaseOf2(b->sym))\n@@ -973,7 +973,7 @@ Dsymbol *ClassDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n     {\n         // Search bases classes in depth-first, left to right order\n \n-        for (size_t i = 0; i < baseclasses->dim; i++)\n+        for (size_t i = 0; i < baseclasses->length; i++)\n         {\n             BaseClass *b = (*baseclasses)[i];\n \n@@ -1010,7 +1010,7 @@ Dsymbol *ClassDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n  */\n ClassDeclaration *ClassDeclaration::searchBase(Identifier *ident)\n {\n-    for (size_t i = 0; i < baseclasses->dim; i++)\n+    for (size_t i = 0; i < baseclasses->length; i++)\n     {\n         BaseClass *b = (*baseclasses)[i];\n         ClassDeclaration *cdb = b->type->isClassHandle();\n@@ -1050,7 +1050,7 @@ static unsigned membersPlace(BaseClasses *vtblInterfaces, size_t &bi, ClassDecla\n         if (!b->sym->alignsize)\n             b->sym->alignsize = Target::ptrsize;\n         cd->alignmember(b->sym->alignsize, b->sym->alignsize, &offset);\n-        assert(bi < vtblInterfaces->dim);\n+        assert(bi < vtblInterfaces->length);\n         BaseClass *bv = (*vtblInterfaces)[bi];\n         if (b->sym->interfaces.length == 0)\n         {\n@@ -1121,7 +1121,7 @@ void ClassDeclaration::finalizeSize()\n     fields.setDim(0);\n \n     unsigned offset = structsize;\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->setFieldOffset(this, &offset, false);\n@@ -1163,7 +1163,7 @@ bool ClassDeclaration::isFuncHidden(FuncDeclaration *fd)\n     OverloadSet *os = s->isOverloadSet();\n     if (os)\n     {\n-        for (size_t i = 0; i < os->a.dim; i++)\n+        for (size_t i = 0; i < os->a.length; i++)\n         {\n             Dsymbol *s2 = os->a[i];\n             FuncDeclaration *f2 = s2->isFuncDeclaration();\n@@ -1198,7 +1198,7 @@ FuncDeclaration *ClassDeclaration::findFunc(Identifier *ident, TypeFunction *tf)\n     Dsymbols *vtbl = &cd->vtbl;\n     while (1)\n     {\n-        for (size_t i = 0; i < vtbl->dim; i++)\n+        for (size_t i = 0; i < vtbl->length; i++)\n         {\n             FuncDeclaration *fd = (*vtbl)[i]->isFuncDeclaration();\n             if (!fd)\n@@ -1336,7 +1336,7 @@ bool ClassDeclaration::isAbstract()\n         }\n     };\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         if (s->apply(&SearchAbstract::fp, this))\n@@ -1348,7 +1348,7 @@ bool ClassDeclaration::isAbstract()\n \n     /* Iterate inherited member functions and check their abstract attribute.\n      */\n-    for (size_t i = 1; i < vtbl.dim; i++)\n+    for (size_t i = 1; i < vtbl.length; i++)\n     {\n         FuncDeclaration *fd = vtbl[i]->isFuncDeclaration();\n         //if (fd) printf(\"\\tvtbl[%d] = [%s] %s\\n\", i, fd->loc.toChars(), fd->toChars());\n@@ -1490,7 +1490,7 @@ void InterfaceDeclaration::semantic(Scope *sc)\n         baseok = BASEOKin;\n \n         // Expand any tuples in baseclasses[]\n-        for (size_t i = 0; i < baseclasses->dim; )\n+        for (size_t i = 0; i < baseclasses->length; )\n         {\n             BaseClass *b = (*baseclasses)[i];\n             b->type = resolveBase(this, sc, scx, b->type);\n@@ -1520,13 +1520,13 @@ void InterfaceDeclaration::semantic(Scope *sc)\n             goto Lancestorsdone;\n         }\n \n-        if (!baseclasses->dim && sc->linkage == LINKcpp)\n+        if (!baseclasses->length && sc->linkage == LINKcpp)\n             classKind = ClassKind::cpp;\n         if (sc->linkage == LINKobjc)\n             objc()->setObjc(this);\n \n         // Check for errors, handle forward references\n-        for (size_t i = 0; i < baseclasses->dim; )\n+        for (size_t i = 0; i < baseclasses->length; )\n         {\n             BaseClass *b = (*baseclasses)[i];\n             Type *tb = b->type->toBasetype();\n@@ -1592,7 +1592,7 @@ void InterfaceDeclaration::semantic(Scope *sc)\n         }\n         baseok = BASEOKdone;\n \n-        interfaces.length = baseclasses->dim;\n+        interfaces.length = baseclasses->length;\n         interfaces.ptr = baseclasses->tdata();\n \n         for (size_t i = 0; i < interfaces.length; i++)\n@@ -1618,7 +1618,7 @@ void InterfaceDeclaration::semantic(Scope *sc)\n     if (!symtab)\n         symtab = new DsymbolTable();\n \n-    for (size_t i = 0; i < baseclasses->dim; i++)\n+    for (size_t i = 0; i < baseclasses->length; i++)\n     {\n         BaseClass *b = (*baseclasses)[i];\n         Type *tb = b->type->toBasetype();\n@@ -1660,7 +1660,7 @@ void InterfaceDeclaration::semantic(Scope *sc)\n             // Copy vtbl[] from base class\n             if (b->sym->vtblOffset())\n             {\n-                size_t d = b->sym->vtbl.dim;\n+                size_t d = b->sym->vtbl.length;\n                 if (d > 1)\n                 {\n                     vtbl.reserve(d - 1);\n@@ -1678,7 +1678,7 @@ void InterfaceDeclaration::semantic(Scope *sc)\n         }\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->addMember(sc, this);\n@@ -1689,20 +1689,20 @@ void InterfaceDeclaration::semantic(Scope *sc)\n     /* Set scope so if there are forward references, we still might be able to\n      * resolve individual members like enums.\n      */\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         //printf(\"setScope %s %s\\n\", s->kind(), s->toChars());\n         s->setScope(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic(sc2);\n@@ -1867,10 +1867,10 @@ bool BaseClass::fillVtbl(ClassDeclaration *cd, FuncDeclarations *vtbl, int newin\n \n     //printf(\"BaseClass::fillVtbl(this='%s', cd='%s')\\n\", sym->toChars(), cd->toChars());\n     if (vtbl)\n-        vtbl->setDim(sym->vtbl.dim);\n+        vtbl->setDim(sym->vtbl.length);\n \n     // first entry is ClassInfo reference\n-    for (size_t j = sym->vtblOffset(); j < sym->vtbl.dim; j++)\n+    for (size_t j = sym->vtblOffset(); j < sym->vtbl.length; j++)\n     {\n         FuncDeclaration *ifd = sym->vtbl[j]->isFuncDeclaration();\n         FuncDeclaration *fd;\n@@ -1929,7 +1929,7 @@ void BaseClass::copyBaseInterfaces(BaseClasses *vtblInterfaces)\n         void *pb = &baseInterfaces.ptr[i];\n         BaseClass *b2 = sym->interfaces.ptr[i];\n \n-        assert(b2->vtbl.dim == 0);      // should not be filled yet\n+        assert(b2->vtbl.length == 0);      // should not be filled yet\n         BaseClass *b = (BaseClass *)memcpy(pb, b2, sizeof(BaseClass));\n \n         if (i)                          // single inheritance is i==0"}, {"sha": "5ae8c06e7ec05baf8a89493747649acaed05285a", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 24, "deletions": 38, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -55,7 +55,7 @@ bool checkFrameAccess(Loc loc, Scope *sc, AggregateDeclaration *ad, size_t iStar\n     }\n \n     bool result = false;\n-    for (size_t i = iStart; i < ad->fields.dim; i++)\n+    for (size_t i = iStart; i < ad->fields.length; i++)\n     {\n         VarDeclaration *vd = ad->fields[i];\n         Type *tb = vd->type->baseElemOf();\n@@ -203,7 +203,7 @@ Type *TupleDeclaration::getType()\n     {\n         /* It's only a type tuple if all the Object's are types\n          */\n-        for (size_t i = 0; i < objects->dim; i++)\n+        for (size_t i = 0; i < objects->length; i++)\n         {\n             RootObject *o = (*objects)[i];\n             if (o->dyncast() != DYNCAST_TYPE)\n@@ -217,10 +217,10 @@ Type *TupleDeclaration::getType()\n          */\n         Types *types = (Types *)objects;\n         Parameters *args = new Parameters();\n-        args->setDim(objects->dim);\n+        args->setDim(objects->length);\n         OutBuffer buf;\n         int hasdeco = 1;\n-        for (size_t i = 0; i < types->dim; i++)\n+        for (size_t i = 0; i < types->length; i++)\n         {\n             Type *t = (*types)[i];\n             //printf(\"type = %s\\n\", t->toChars());\n@@ -242,7 +242,7 @@ Dsymbol *TupleDeclaration::toAlias2()\n {\n     //printf(\"TupleDeclaration::toAlias2() '%s' objects = %s\\n\", toChars(), objects->toChars());\n \n-    for (size_t i = 0; i < objects->dim; i++)\n+    for (size_t i = 0; i < objects->length; i++)\n     {\n         RootObject *o = (*objects)[i];\n         if (Dsymbol *s = isDsymbol(o))\n@@ -257,7 +257,7 @@ Dsymbol *TupleDeclaration::toAlias2()\n bool TupleDeclaration::needThis()\n {\n     //printf(\"TupleDeclaration::needThis(%s)\\n\", toChars());\n-    for (size_t i = 0; i < objects->dim; i++)\n+    for (size_t i = 0; i < objects->length; i++)\n     {\n         RootObject *o = (*objects)[i];\n         if (o->dyncast() == DYNCAST_EXPRESSION)\n@@ -1020,19 +1020,19 @@ void VarDeclaration::semantic(Scope *sc)\n \n             Expressions *exps = new Expressions();\n \n-            for (size_t pos = 0; pos < iexps->dim; pos++)\n+            for (size_t pos = 0; pos < iexps->length; pos++)\n             {\n             Lexpand1:\n                 Expression *e = (*iexps)[pos];\n                 Parameter *arg = Parameter::getNth(tt->arguments, pos);\n                 arg->type = arg->type->semantic(loc, sc);\n-                //printf(\"[%d] iexps->dim = %d, \", pos, iexps->dim);\n+                //printf(\"[%d] iexps->length = %d, \", pos, iexps->length);\n                 //printf(\"e = (%s %s, %s), \", Token::tochars[e->op], e->toChars(), e->type->toChars());\n                 //printf(\"arg = (%s, %s)\\n\", arg->toChars(), arg->type->toChars());\n \n                 if (e != ie)\n                 {\n-                if (iexps->dim > nelems)\n+                if (iexps->length > nelems)\n                     goto Lnomatch;\n                 if (e->type->implicitConvTo(arg->type))\n                     continue;\n@@ -1041,7 +1041,7 @@ void VarDeclaration::semantic(Scope *sc)\n                 if (e->op == TOKtuple)\n                 {\n                     TupleExp *te = (TupleExp *)e;\n-                    if (iexps->dim - 1 + te->exps->dim > nelems)\n+                    if (iexps->length - 1 + te->exps->length > nelems)\n                         goto Lnomatch;\n \n                     iexps->remove(pos);\n@@ -1060,17 +1060,17 @@ void VarDeclaration::semantic(Scope *sc)\n                     (*exps)[0] = ve;\n                     expandAliasThisTuples(exps, 0);\n \n-                    for (size_t u = 0; u < exps->dim ; u++)\n+                    for (size_t u = 0; u < exps->length ; u++)\n                     {\n                     Lexpand2:\n                         Expression *ee = (*exps)[u];\n                         arg = Parameter::getNth(tt->arguments, pos + u);\n                         arg->type = arg->type->semantic(loc, sc);\n-                        //printf(\"[%d+%d] exps->dim = %d, \", pos, u, exps->dim);\n+                        //printf(\"[%d+%d] exps->length = %d, \", pos, u, exps->length);\n                         //printf(\"ee = (%s %s, %s), \", Token::tochars[ee->op], ee->toChars(), ee->type->toChars());\n                         //printf(\"arg = (%s, %s)\\n\", arg->toChars(), arg->type->toChars());\n \n-                        size_t iexps_dim = iexps->dim - 1 + exps->dim;\n+                        size_t iexps_dim = iexps->length - 1 + exps->length;\n                         if (iexps_dim > nelems)\n                             goto Lnomatch;\n                         if (ee->type->implicitConvTo(arg->type))\n@@ -1092,7 +1092,7 @@ void VarDeclaration::semantic(Scope *sc)\n                     }\n                 }\n             }\n-            if (iexps->dim < nelems)\n+            if (iexps->length < nelems)\n                 goto Lnomatch;\n \n             ie = new TupleExp(_init->loc, iexps);\n@@ -1102,7 +1102,7 @@ void VarDeclaration::semantic(Scope *sc)\n         if (ie && ie->op == TOKtuple)\n         {\n             TupleExp *te = (TupleExp *)ie;\n-            size_t tedim = te->exps->dim;\n+            size_t tedim = te->exps->length;\n             if (tedim != nelems)\n             {\n                 ::error(loc, \"tuple of %d elements cannot be assigned to tuple of %d elements\", (int)tedim, (int)nelems);\n@@ -1493,7 +1493,7 @@ void VarDeclaration::semantic(Scope *sc)\n                         NewExp *ne = (NewExp *)ex;\n                         if (type->toBasetype()->ty == Tclass)\n                         {\n-                            if (ne->newargs && ne->newargs->dim > 1)\n+                            if (ne->newargs && ne->newargs->length > 1)\n                             {\n                                 mynew = true;\n                             }\n@@ -1650,7 +1650,7 @@ void VarDeclaration::semantic2(Scope *sc)\n             {\n                 static bool arrayHasInvalidEnumInitializer(Expressions *elems)\n                 {\n-                    for (size_t i = 0; i < elems->dim; i++)\n+                    for (size_t i = 0; i < elems->length; i++)\n                     {\n                         Expression *e = (*elems)[i];\n                         if (e && hasInvalidEnumInitializer(e))\n@@ -1711,7 +1711,7 @@ void VarDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset,\n         // If this variable was really a tuple, set the offsets for the tuple fields\n         TupleDeclaration *v2 = aliassym->isTupleDeclaration();\n         assert(v2);\n-        for (size_t i = 0; i < v2->objects->dim; i++)\n+        for (size_t i = 0; i < v2->objects->length; i++)\n         {\n             RootObject *o = (*v2->objects)[i];\n             assert(o->dyncast() == DYNCAST_EXPRESSION);\n@@ -1738,7 +1738,7 @@ void VarDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset,\n         *poffset = ad->structsize;  // Bugzilla 13613\n         return;\n     }\n-    for (size_t i = 0; i < ad->fields.dim; i++)\n+    for (size_t i = 0; i < ad->fields.length; i++)\n     {\n         if (ad->fields[i] == this)\n         {\n@@ -1901,16 +1901,8 @@ bool VarDeclaration::checkNestedReference(Scope *sc, Loc loc)\n         return false;\n \n     // Add fdthis to nestedrefs[] if not already there\n-    for (size_t i = 0; 1; i++)\n-    {\n-        if (i == nestedrefs.dim)\n-        {\n-            nestedrefs.push(fdthis);\n-            break;\n-        }\n-        if (nestedrefs[i] == fdthis)\n-            break;\n-    }\n+    if (!nestedrefs.contains(fdthis))\n+        nestedrefs.push(fdthis);\n \n     /* __require and __ensure will always get called directly,\n      * so they never make outer functions closure.\n@@ -1928,16 +1920,10 @@ bool VarDeclaration::checkNestedReference(Scope *sc, Loc loc)\n     }\n \n     // Add this to fdv->closureVars[] if not already there\n-    for (size_t i = 0; 1; i++)\n+    if (!sc->intypeof && !(sc->flags & SCOPEcompile))\n     {\n-        if (i == fdv->closureVars.dim)\n-        {\n-            if (!sc->intypeof && !(sc->flags & SCOPEcompile))\n-                fdv->closureVars.push(this);\n-            break;\n-        }\n-        if (fdv->closureVars[i] == this)\n-            break;\n+        if (!fdv->closureVars.contains(this))\n+            fdv->closureVars.push(this);\n     }\n \n     //printf(\"fdthis is %s\\n\", fdthis->toChars());"}, {"sha": "f96380f572ae4f6863628cffe670f81b5be9a4e3", "filename": "gcc/d/dmd/denum.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdenum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdenum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -74,7 +74,7 @@ void EnumDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n \n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             EnumMember *em = (*members)[i]->isEnumMember();\n             em->ed = this;\n@@ -172,7 +172,7 @@ void EnumDeclaration::semantic(Scope *sc)\n             errors = true;\n             if (members)\n             {\n-                for (size_t i = 0; i < members->dim; i++)\n+                for (size_t i = 0; i < members->length; i++)\n                 {\n                     Dsymbol *s = (*members)[i];\n                     s->errors = true;               // poison all the members\n@@ -188,7 +188,7 @@ void EnumDeclaration::semantic(Scope *sc)\n     if (!members)               // enum ident : memtype;\n         return;\n \n-    if (members->dim == 0)\n+    if (members->length == 0)\n     {\n         error(\"enum %s must have at least one member\", toChars());\n         errors = true;\n@@ -210,7 +210,7 @@ void EnumDeclaration::semantic(Scope *sc)\n \n     /* Each enum member gets the sce scope\n      */\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         EnumMember *em = (*members)[i]->isEnumMember();\n         if (em)\n@@ -246,7 +246,7 @@ void EnumDeclaration::semantic(Scope *sc)\n             scopesym = this;\n         }\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             EnumMember *em = (*members)[i]->isEnumMember();\n             if (em)\n@@ -257,7 +257,7 @@ void EnumDeclaration::semantic(Scope *sc)\n         }\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         EnumMember *em = (*members)[i]->isEnumMember();\n         if (em)\n@@ -314,7 +314,7 @@ Expression *EnumDeclaration::getMaxMinValue(Loc loc, Identifier *id)\n         goto Lerrors;\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         EnumMember *em = (*members)[i]->isEnumMember();\n         if (!em)\n@@ -402,7 +402,7 @@ Expression *EnumDeclaration::getDefaultValue(Loc loc)\n         goto Lerrors;\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         EnumMember *em = (*members)[i]->isEnumMember();\n         if (em)\n@@ -588,7 +588,7 @@ void EnumMember::semantic(Scope *sc)\n                  * with the first member. If the following members were referenced\n                  * during the first member semantic, their types should be unified.\n                  */\n-                for (size_t i = 0; i < ed->members->dim; i++)\n+                for (size_t i = 0; i < ed->members->length; i++)\n                 {\n                     EnumMember *em = (*ed->members)[i]->isEnumMember();\n                     if (!em || em == this || em->semanticRun < PASSsemanticdone || em->origType)\n@@ -667,7 +667,7 @@ void EnumMember::semantic(Scope *sc)\n          * and set this to be the previous value + 1\n          */\n         EnumMember *emprev = NULL;\n-        for (size_t i = 0; i < ed->members->dim; i++)\n+        for (size_t i = 0; i < ed->members->length; i++)\n         {\n             EnumMember *em = (*ed->members)[i]->isEnumMember();\n             if (em)"}, {"sha": "b176d8cadd05ec48ef85294609217c8c1e87561d", "filename": "gcc/d/dmd/dimport.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdimport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdimport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -45,7 +45,7 @@ Import::Import(Loc loc, Identifiers *packages, Identifier *id, Identifier *alias\n         // import [cstdio] = std.stdio;\n         this->ident = aliasId;\n     }\n-    else if (packages && packages->dim)\n+    else if (packages && packages->length)\n     {\n         // import [std].stdio;\n         this->ident = (*packages)[0];\n@@ -85,7 +85,7 @@ Dsymbol *Import::syntaxCopy(Dsymbol *s)\n \n     Import *si = new Import(loc, packages, id, aliasId, isstatic);\n \n-    for (size_t i = 0; i < names.dim; i++)\n+    for (size_t i = 0; i < names.length; i++)\n     {\n         si->addAlias(names[i], aliases[i]);\n     }\n@@ -186,7 +186,7 @@ void Import::importAll(Scope *sc)\n \n             if (sc->explicitProtection)\n                 protection = sc->protection;\n-            if (!isstatic && !aliasId && !names.dim)\n+            if (!isstatic && !aliasId && !names.length)\n             {\n                 sc->scopesym->importScope(mod, protection);\n             }\n@@ -227,7 +227,7 @@ void Import::semantic(Scope *sc)\n         if (sc->explicitProtection)\n             protection = sc->protection;\n \n-        if (!aliasId && !names.dim) // neither a selective nor a renamed import\n+        if (!aliasId && !names.length) // neither a selective nor a renamed import\n         {\n             ScopeDsymbol *scopesym = NULL;\n             if (sc->explicitProtection)\n@@ -253,7 +253,7 @@ void Import::semantic(Scope *sc)\n                 // import a.b.c.d;\n                 Package *p = pkg; // a\n                 scopesym->addAccessiblePackage(p, protection);\n-                for (size_t i = 1; i < packages->dim; i++) // [b, c]\n+                for (size_t i = 1; i < packages->length; i++) // [b, c]\n                 {\n                     Identifier *id = (*packages)[i];\n                     p = (Package *) p->symtab->lookup(id);\n@@ -273,7 +273,7 @@ void Import::semantic(Scope *sc)\n \n         sc = sc->push(mod);\n         sc->protection = protection;\n-        for (size_t i = 0; i < aliasdecls.dim; i++)\n+        for (size_t i = 0; i < aliasdecls.length; i++)\n         {\n             AliasDeclaration *ad = aliasdecls[i];\n             //printf(\"\\tImport %s alias %s = %s, scope = %p\\n\", toPrettyChars(), aliases[i]->toChars(), names[i]->toChars(), ad->_scope);\n@@ -341,7 +341,7 @@ void Import::semantic(Scope *sc)\n \n         if (packages)\n         {\n-            for (size_t i = 0; i < packages->dim; i++)\n+            for (size_t i = 0; i < packages->length; i++)\n             {\n                 Identifier *pid = (*packages)[i];\n                 ob->printf(\"%s.\", pid->toChars());\n@@ -356,7 +356,7 @@ void Import::semantic(Scope *sc)\n             ob->writestring(\"???\");\n         ob->writeByte(')');\n \n-        for (size_t i = 0; i < names.dim; i++)\n+        for (size_t i = 0; i < names.length; i++)\n         {\n             if (i == 0)\n                 ob->writeByte(':');\n@@ -413,7 +413,7 @@ Dsymbol *Import::toAlias()\n void Import::addMember(Scope *sc, ScopeDsymbol *sd)\n {\n     //printf(\"Import::addMember(this=%s, sd=%s, sc=%p)\\n\", toChars(), sd->toChars(), sc);\n-    if (names.dim == 0)\n+    if (names.length == 0)\n         return Dsymbol::addMember(sc, sd);\n \n     if (aliasId)\n@@ -422,7 +422,7 @@ void Import::addMember(Scope *sc, ScopeDsymbol *sd)\n     /* Instead of adding the import to sd's symbol table,\n      * add each of the alias=name pairs\n      */\n-    for (size_t i = 0; i < names.dim; i++)\n+    for (size_t i = 0; i < names.length; i++)\n     {\n         Identifier *name = names[i];\n         Identifier *alias = aliases[i];\n@@ -442,14 +442,14 @@ void Import::addMember(Scope *sc, ScopeDsymbol *sd)\n void Import::setScope(Scope *sc)\n {\n     Dsymbol::setScope(sc);\n-    if (aliasdecls.dim)\n+    if (aliasdecls.length)\n     {\n         if (!mod)\n             importAll(sc);\n \n         sc = sc->push(mod);\n         sc->protection = protection;\n-        for (size_t i = 0; i < aliasdecls.dim; i++)\n+        for (size_t i = 0; i < aliasdecls.length; i++)\n         {\n             AliasDeclaration *ad = aliasdecls[i];\n             ad->setScope(sc);"}, {"sha": "7c7238d6b8d510fd53ce8f5ffad1e8111160ea04", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -129,7 +129,7 @@ CtfeStack::CtfeStack() : framepointer(0), maxStackPointer(0)\n \n size_t CtfeStack::stackPointer()\n {\n-    return values.dim;\n+    return values.length;\n }\n \n Expression *CtfeStack::getThis()\n@@ -153,12 +153,12 @@ void CtfeStack::startFrame(Expression *thisexp)\n \n void CtfeStack::endFrame()\n {\n-    size_t oldframe = (size_t)(frames[frames.dim-1]);\n-    localThis = savedThis[savedThis.dim-1];\n+    size_t oldframe = (size_t)(frames[frames.length-1]);\n+    localThis = savedThis[savedThis.length-1];\n     popAll(framepointer);\n     framepointer = oldframe;\n-    frames.setDim(frames.dim - 1);\n-    savedThis.setDim(savedThis.dim -1);\n+    frames.setDim(frames.length - 1);\n+    savedThis.setDim(savedThis.length -1);\n }\n \n bool CtfeStack::isInCurrentFrame(VarDeclaration *v)\n@@ -173,7 +173,7 @@ Expression *CtfeStack::getValue(VarDeclaration *v)\n     if ((v->isDataseg() || v->storage_class & STCmanifest) && !v->isCTFE())\n     {\n         assert(v->ctfeAdrOnStack >= 0 &&\n-        v->ctfeAdrOnStack < (int)globalValues.dim);\n+        v->ctfeAdrOnStack < (int)globalValues.length);\n         return globalValues[v->ctfeAdrOnStack];\n     }\n     assert(v->ctfeAdrOnStack >= 0 && v->ctfeAdrOnStack < (int)stackPointer());\n@@ -198,7 +198,7 @@ void CtfeStack::push(VarDeclaration *v)\n         return;\n     }\n     savedId.push((void *)(size_t)(v->ctfeAdrOnStack));\n-    v->ctfeAdrOnStack = (int)values.dim;\n+    v->ctfeAdrOnStack = (int)values.length;\n     vars.push(v);\n     values.push(NULL);\n }\n@@ -209,7 +209,7 @@ void CtfeStack::pop(VarDeclaration *v)\n     assert(!(v->storage_class & (STCref | STCout)));\n     int oldid = v->ctfeAdrOnStack;\n     v->ctfeAdrOnStack = (int)(size_t)(savedId[oldid]);\n-    if (v->ctfeAdrOnStack == (int)values.dim - 1)\n+    if (v->ctfeAdrOnStack == (int)values.length - 1)\n     {\n         values.pop();\n         vars.pop();\n@@ -221,8 +221,8 @@ void CtfeStack::popAll(size_t stackpointer)\n {\n     if (stackPointer() > maxStackPointer)\n         maxStackPointer = stackPointer();\n-    assert(values.dim >= stackpointer);\n-    for (size_t i = stackpointer; i < values.dim; ++i)\n+    assert(values.length >= stackpointer);\n+    for (size_t i = stackpointer; i < values.length; ++i)\n     {\n         VarDeclaration *v = vars[i];\n         v->ctfeAdrOnStack = (int)(size_t)(savedId[i]);\n@@ -235,7 +235,7 @@ void CtfeStack::popAll(size_t stackpointer)\n void CtfeStack::saveGlobalConstant(VarDeclaration *v, Expression *e)\n {\n      assert(v->_init && (v->isConst() || v->isImmutable() || v->storage_class & STCmanifest) && !v->isCTFE());\n-     v->ctfeAdrOnStack = (int)globalValues.dim;\n+     v->ctfeAdrOnStack = (int)globalValues.length;\n      globalValues.push(e);\n }\n \n@@ -342,7 +342,7 @@ struct CompiledCtfeFunction\n                 {\n                     if (!td->objects)\n                         return;\n-                    for (size_t i= 0; i < td->objects->dim; ++i)\n+                    for (size_t i= 0; i < td->objects->length; ++i)\n                     {\n                         RootObject *o = td->objects->tdata()[i];\n                         Expression *ex = isExpression(o);\n@@ -406,7 +406,7 @@ class CtfeCompiler : public Visitor\n \n     void visit(CompoundStatement *s)\n     {\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n             if (sx)\n@@ -416,7 +416,7 @@ class CtfeCompiler : public Visitor\n \n     void visit(UnrolledLoopStatement *s)\n     {\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n             if (sx)\n@@ -481,7 +481,7 @@ class CtfeCompiler : public Visitor\n         ccf->onExpression(s->condition);\n         // Note that the body contains the the Case and Default\n         // statements, so we only need to compile the expressions\n-        for (size_t i = 0; i < s->cases->dim; i++)\n+        for (size_t i = 0; i < s->cases->length; i++)\n         {\n             ccf->onExpression((*s->cases)[i]->exp);\n         }\n@@ -546,7 +546,7 @@ class CtfeCompiler : public Visitor\n     {\n         if (s->_body)\n             ctfeCompile(s->_body);\n-        for (size_t i = 0; i < s->catches->dim; i++)\n+        for (size_t i = 0; i < s->catches->length; i++)\n         {\n             Catch *ca = (*s->catches)[i];\n             if (ca->var)\n@@ -616,7 +616,7 @@ void ctfeCompile(FuncDeclaration *fd)\n     {\n         Type *tb = fd->type->toBasetype();\n         assert(tb->ty == Tfunction);\n-        for (size_t i = 0; i < fd->parameters->dim; i++)\n+        for (size_t i = 0; i < fd->parameters->length; i++)\n         {\n             VarDeclaration *v = (*fd->parameters)[i];\n             fd->ctfeCode->onDeclaration(v);\n@@ -700,7 +700,7 @@ Expression *ctfeInterpretForPragmaMsg(Expression *e)\n \n     TupleExp *tup = (TupleExp *)e;\n     Expressions *expsx = NULL;\n-    for (size_t i = 0; i < tup->exps->dim; ++i)\n+    for (size_t i = 0; i < tup->exps->length; ++i)\n     {\n         Expression *g = (*tup->exps)[i];\n         Expression *h = g;\n@@ -710,8 +710,8 @@ Expression *ctfeInterpretForPragmaMsg(Expression *e)\n             if (!expsx)\n             {\n                 expsx = new Expressions();\n-                expsx->setDim(tup->exps->dim);\n-                for (size_t j = 0; j < tup->exps->dim; j++)\n+                expsx->setDim(tup->exps->length);\n+                for (size_t j = 0; j < tup->exps->length; j++)\n                     (*expsx)[j] = (*tup->exps)[j];\n             }\n             (*expsx)[i] = h;\n@@ -761,7 +761,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     assert(tb->ty == Tfunction);\n     TypeFunction *tf = (TypeFunction *)tb;\n     if (tf->varargs && arguments &&\n-        ((fd->parameters && arguments->dim != fd->parameters->dim) || (!fd->parameters && arguments->dim)))\n+        ((fd->parameters && arguments->length != fd->parameters->length) || (!fd->parameters && arguments->length)))\n     {\n         fd->error(\"C-style variadic functions are not yet implemented in CTFE\");\n         return CTFEExp::cantexp;\n@@ -785,8 +785,8 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     // Place to hold all the arguments to the function while\n     // we are evaluating them.\n     Expressions eargs;\n-    size_t dim = arguments ? arguments->dim : 0;\n-    assert((fd->parameters ? fd->parameters->dim : 0) == dim);\n+    size_t dim = arguments ? arguments->length : 0;\n+    assert((fd->parameters ? fd->parameters->length : 0) == dim);\n \n     /* Evaluate all the arguments to the function,\n      * store the results in eargs[]\n@@ -1045,7 +1045,7 @@ class Interpreter : public Visitor\n         if (istate->start == s)\n             istate->start = NULL;\n \n-        const size_t dim = s->statements ? s->statements->dim : 0;\n+        const size_t dim = s->statements ? s->statements->length : 0;\n         for (size_t i = 0; i < dim; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n@@ -1060,7 +1060,7 @@ class Interpreter : public Visitor\n         if (istate->start == s)\n             istate->start = NULL;\n \n-        const size_t dim = s->statements ? s->statements->dim : 0;\n+        const size_t dim = s->statements ? s->statements->length : 0;\n         for (size_t i = 0; i < dim; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n@@ -1200,7 +1200,7 @@ class Interpreter : public Visitor\n     // Check all members of an array for escaping local variables. Return false if error\n     static bool stopPointersEscapingFromArray(Loc loc, Expressions *elems)\n     {\n-        for (size_t i = 0; i < elems->dim; i++)\n+        for (size_t i = 0; i < elems->length; i++)\n         {\n             Expression *m = (*elems)[i];\n             if (!m)\n@@ -1237,7 +1237,7 @@ class Interpreter : public Visitor\n             result = interpret(pue, s->exp, istate, ctfeNeedLvalue);\n             return;\n         }\n-        if (tf->next && tf->next->ty == Tdelegate && istate->fd->closureVars.dim > 0)\n+        if (tf->next && tf->next->ty == Tdelegate && istate->fd->closureVars.length > 0)\n         {\n             // To support this, we need to copy all the closure vars\n             // into the delegate literal.\n@@ -1470,7 +1470,7 @@ class Interpreter : public Visitor\n             return;\n \n         Statement *scase = NULL;\n-        size_t dim = s->cases ? s->cases->dim : 0;\n+        size_t dim = s->cases ? s->cases->length : 0;\n         for (size_t i = 0; i < dim; i++)\n         {\n             CaseStatement *cs = (*s->cases)[i];\n@@ -1585,7 +1585,7 @@ class Interpreter : public Visitor\n         {\n             Expression *e = NULL;\n             e = interpret(pue, s->_body, istate);\n-            for (size_t i = 0; i < s->catches->dim; i++)\n+            for (size_t i = 0; i < s->catches->length; i++)\n             {\n                 if (e || !istate->start)    // goto target was found\n                     break;\n@@ -1605,7 +1605,7 @@ class Interpreter : public Visitor\n             Type *extype = ex->thrown->originalClass()->type;\n \n             // Search for an appropriate catch clause.\n-            for (size_t i = 0; i < s->catches->dim; i++)\n+            for (size_t i = 0; i < s->catches->length; i++)\n             {\n                 Catch *ca = (*s->catches)[i];\n                 Type *catype = ca->type;\n@@ -2286,7 +2286,7 @@ class Interpreter : public Visitor\n                 // Reserve stack space for all tuple members\n                 if (!td->objects)\n                     return;\n-                for (size_t i = 0; i < td->objects->dim; ++i)\n+                for (size_t i = 0; i < td->objects->length; ++i)\n                 {\n                     RootObject * o = (*td->objects)[i];\n                     Expression *ex = isExpression(o);\n@@ -2366,7 +2366,7 @@ class Interpreter : public Visitor\n         {\n             // Check for static struct declarations, which aren't executable\n             AttribDeclaration *ad = e->declaration->isAttribDeclaration();\n-            if (ad && ad->decl && ad->decl->dim == 1)\n+            if (ad && ad->decl && ad->decl->length == 1)\n             {\n                 Dsymbol *sparent = (*ad->decl)[0];\n                 if (sparent->isAggregateDeclaration() ||\n@@ -2431,7 +2431,7 @@ class Interpreter : public Visitor\n             return;\n \n         Expressions *expsx = e->exps;\n-        for (size_t i = 0; i < expsx->dim; i++)\n+        for (size_t i = 0; i < expsx->length; i++)\n         {\n             Expression *exp = (*expsx)[i];\n             Expression *ex = interpret(exp, istate);\n@@ -2482,7 +2482,7 @@ class Interpreter : public Visitor\n             return;\n \n         Expressions *expsx = e->elements;\n-        size_t dim = expsx ? expsx->dim : 0;\n+        size_t dim = expsx ? expsx->length : 0;\n         for (size_t i = 0; i < dim; i++)\n         {\n             Expression *exp = (*expsx)[i];\n@@ -2521,7 +2521,7 @@ class Interpreter : public Visitor\n         {\n             // todo: all tuple expansions should go in semantic phase.\n             expandTuples(expsx);\n-            if (expsx->dim != dim)\n+            if (expsx->length != dim)\n             {\n                 e->error(\"CTFE internal error: invalid array literal\");\n                 result = CTFEExp::cantexp;\n@@ -2554,7 +2554,7 @@ class Interpreter : public Visitor\n \n         Expressions *keysx = e->keys;\n         Expressions *valuesx = e->values;\n-        for (size_t i = 0; i < keysx->dim; i++)\n+        for (size_t i = 0; i < keysx->length; i++)\n         {\n             Expression *ekey = (*keysx)[i];\n             Expression *evalue = (*valuesx)[i];\n@@ -2581,7 +2581,7 @@ class Interpreter : public Visitor\n             expandTuples(keysx);\n         if (valuesx != e->values)\n             expandTuples(valuesx);\n-        if (keysx->dim != valuesx->dim)\n+        if (keysx->length != valuesx->length)\n         {\n             e->error(\"CTFE internal error: invalid AA\");\n             result = CTFEExp::cantexp;\n@@ -2590,10 +2590,10 @@ class Interpreter : public Visitor\n \n         /* Remove duplicate keys\n          */\n-        for (size_t i = 1; i < keysx->dim; i++)\n+        for (size_t i = 1; i < keysx->length; i++)\n         {\n             Expression *ekey = (*keysx)[i - 1];\n-            for (size_t j = i; j < keysx->dim; j++)\n+            for (size_t j = i; j < keysx->length; j++)\n             {\n                 Expression *ekey2 = (*keysx)[j];\n                 if (!ctfeEqual(e->loc, TOKequal, ekey, ekey2))\n@@ -2635,13 +2635,13 @@ class Interpreter : public Visitor\n             return;\n         }\n \n-        size_t dim = e->elements ? e->elements->dim : 0;\n+        size_t dim = e->elements ? e->elements->length : 0;\n         Expressions *expsx = e->elements;\n \n-        if (dim != e->sd->fields.dim)\n+        if (dim != e->sd->fields.length)\n         {\n             // guaranteed by AggregateDeclaration.fill and TypeStruct.defaultInitLiteral\n-            assert(e->sd->isNested() && dim == e->sd->fields.dim - 1);\n+            assert(e->sd->isNested() && dim == e->sd->fields.length - 1);\n \n             /* If a nested struct has no initialized hidden pointer,\n                 * set it to null to match the runtime behaviour.\n@@ -2653,7 +2653,7 @@ class Interpreter : public Visitor\n             expsx->push(ne);\n             ++dim;\n         }\n-        assert(dim == e->sd->fields.dim);\n+        assert(dim == e->sd->fields.length);\n \n         for (size_t i = 0; i < dim; i++)\n         {\n@@ -2693,7 +2693,7 @@ class Interpreter : public Visitor\n         if (expsx != e->elements)\n         {\n             expandTuples(expsx);\n-            if (expsx->dim != e->sd->fields.dim)\n+            if (expsx->length != e->sd->fields.length)\n             {\n                 e->error(\"CTFE internal error: invalid struct literal\");\n                 result = CTFEExp::cantexp;\n@@ -2723,7 +2723,7 @@ class Interpreter : public Visitor\n             return lenExpr;\n         size_t len = (size_t)(lenExpr->toInteger());\n         Type *elemType = ((TypeArray *)newtype)->next;\n-        if (elemType->ty == Tarray && argnum < (int)arguments->dim - 1)\n+        if (elemType->ty == Tarray && argnum < (int)arguments->length - 1)\n         {\n             Expression *elem = recursivelyCreateArrayLiteral(pue, loc, elemType, istate,\n                 arguments, argnum + 1);\n@@ -2739,7 +2739,7 @@ class Interpreter : public Visitor\n             ae->ownedByCtfe = OWNEDctfe;\n             return ae;\n         }\n-        assert(argnum == (int)arguments->dim - 1);\n+        assert(argnum == (int)arguments->length - 1);\n         if (elemType->ty == Tchar || elemType->ty == Twchar || elemType->ty == Tdchar)\n         {\n             const unsigned ch = (unsigned)elemType->defaultInitLiteral(loc)->toInteger();\n@@ -2788,11 +2788,11 @@ class Interpreter : public Visitor\n             {\n                 StructDeclaration *sd = ((TypeStruct *)e->newtype->toBasetype())->sym;\n                 Expressions *exps = new Expressions();\n-                exps->reserve(sd->fields.dim);\n+                exps->reserve(sd->fields.length);\n                 if (e->arguments)\n                 {\n-                    exps->setDim(e->arguments->dim);\n-                    for (size_t i = 0; i < exps->dim; i++)\n+                    exps->setDim(e->arguments->length);\n+                    for (size_t i = 0; i < exps->length; i++)\n                     {\n                         Expression *ex = (*e->arguments)[i];\n                         ex = interpret(ex, istate);\n@@ -2820,14 +2820,14 @@ class Interpreter : public Visitor\n             ClassDeclaration *cd = ((TypeClass *)e->newtype->toBasetype())->sym;\n             size_t totalFieldCount = 0;\n             for (ClassDeclaration *c = cd; c; c = c->baseClass)\n-                totalFieldCount += c->fields.dim;\n+                totalFieldCount += c->fields.length;\n             Expressions *elems = new Expressions;\n             elems->setDim(totalFieldCount);\n             size_t fieldsSoFar = totalFieldCount;\n             for (ClassDeclaration *c = cd; c; c = c->baseClass)\n             {\n-                fieldsSoFar -= c->fields.dim;\n-                for (size_t i = 0; i < c->fields.dim; i++)\n+                fieldsSoFar -= c->fields.length;\n+                for (size_t i = 0; i < c->fields.length; i++)\n                 {\n                     VarDeclaration *v = c->fields[i];\n                     if (v->inuse)\n@@ -2891,7 +2891,7 @@ class Interpreter : public Visitor\n         if (e->newtype->toBasetype()->isscalar())\n         {\n             Expression *newval;\n-            if (e->arguments && e->arguments->dim)\n+            if (e->arguments && e->arguments->length)\n                 newval = (*e->arguments)[0];\n             else\n                 newval = e->newtype->defaultInitLiteral(e->loc);\n@@ -3634,7 +3634,7 @@ class Interpreter : public Visitor\n         if (!v->overlapped)\n             return;\n \n-        for (size_t i = 0; i < sle->sd->fields.dim; i++)\n+        for (size_t i = 0; i < sle->sd->fields.length; i++)\n         {\n             VarDeclaration *v2 = sle->sd->fields[i];\n             if (v == v2 || !v->isOverlappedWith(v2))\n@@ -3686,7 +3686,7 @@ class Interpreter : public Visitor\n                 e->error(\"CTFE internal error: cannot find field %s in %s\", v->toChars(), ex->toChars());\n                 return CTFEExp::cantexp;\n             }\n-            assert(0 <= fieldi && fieldi < (int)sle->elements->dim);\n+            assert(0 <= fieldi && fieldi < (int)sle->elements->length);\n \n             // If it's a union, set all other members of this union to void\n             stompOverlappedFields(sle, v);\n@@ -3776,10 +3776,10 @@ class Interpreter : public Visitor\n \n             Expressions *oldelems = ((ArrayLiteralExp *)oldval)->elements;\n             Expressions *newelems = ((ArrayLiteralExp *)newval)->elements;\n-            assert(oldelems->dim == newelems->dim);\n+            assert(oldelems->length == newelems->length);\n \n             Type *elemtype = oldval->type->nextOf();\n-            for (size_t i = 0; i < newelems->dim; i++)\n+            for (size_t i = 0; i < newelems->length; i++)\n             {\n                 Expression *oldelem = (*oldelems)[i];\n                 Expression *newelem = paintTypeOntoLiteral(elemtype, (*newelems)[i]);\n@@ -3915,7 +3915,7 @@ class Interpreter : public Visitor\n             if (e1->op == TOKarrayliteral)\n             {\n                 lowerbound = 0;\n-                upperbound = ((ArrayLiteralExp *)e1)->elements->dim;\n+                upperbound = ((ArrayLiteralExp *)e1)->elements->length;\n             }\n             else if (e1->op == TOKstring)\n             {\n@@ -4126,7 +4126,7 @@ class Interpreter : public Visitor\n                 Expressions *newelems = ((ArrayLiteralExp *)newval)->elements;\n                 Type *elemtype = existingAE->type->nextOf();\n                 bool needsPostblit = e->op != TOKblit && e->e2->isLvalue();\n-                for (size_t j = 0; j < newelems->dim; j++)\n+                for (size_t j = 0; j < newelems->length; j++)\n                 {\n                     Expression *newelem = (*newelems)[j];\n                     newelem = paintTypeOntoLiteral(elemtype, newelem);\n@@ -4156,7 +4156,7 @@ class Interpreter : public Visitor\n \n                 Expression *assignTo(ArrayLiteralExp *ae)\n                 {\n-                    return assignTo(ae, 0, ae->elements->dim);\n+                    return assignTo(ae, 0, ae->elements->length);\n                 }\n \n                 Expression *assignTo(ArrayLiteralExp *ae, size_t lwr, size_t upr)\n@@ -4643,7 +4643,7 @@ class Interpreter : public Visitor\n             if (fd->ident == Id::__ArrayPostblit ||\n                 fd->ident == Id::__ArrayDtor)\n             {\n-                assert(e->arguments->dim == 1);\n+                assert(e->arguments->length == 1);\n                 Expression *ea = (*e->arguments)[0];\n                 //printf(\"1 ea = %s %s\\n\", ea->type->toChars(), ea->toChars());\n                 if (ea->op == TOKslice)\n@@ -4918,7 +4918,7 @@ class Interpreter : public Visitor\n             // Convert literal __vector(int) -> __vector([array])\n             Expressions *elements = new Expressions();\n             elements->setDim(e->dim);\n-            for (size_t i = 0; i < elements->dim; i++)\n+            for (size_t i = 0; i < elements->length; i++)\n                 (*elements)[i] = copyLiteral(e->e1).copy();\n             TypeSArray *type = NULL;\n             if (e->type->ty == Tvector)\n@@ -5506,7 +5506,7 @@ class Interpreter : public Visitor\n             ale->ownedByCtfe = OWNEDctfe;\n \n             // Bugzilla 14686\n-            for (size_t i = 0; i < ale->elements->dim; i++)\n+            for (size_t i = 0; i < ale->elements->length; i++)\n             {\n                 Expression *ex = evaluatePostblit(istate, (*ale->elements)[i]);\n                 if (exceptionOrCant(ex))\n@@ -5614,7 +5614,7 @@ class Interpreter : public Visitor\n                 if (sd->dtor)\n                 {\n                     ArrayLiteralExp *ale = (ArrayLiteralExp *)result;\n-                    for (size_t i = 0; i < ale->elements->dim; i++)\n+                    for (size_t i = 0; i < ale->elements->length; i++)\n                     {\n                         Expression *el = (*ale->elements)[i];\n                         result = interpretFunction(pue, sd->dtor, istate, NULL, el);\n@@ -5728,7 +5728,7 @@ class Interpreter : public Visitor\n                     {\n                         ArrayLiteralExp *ale = (ArrayLiteralExp *)ie->e1;\n                         const size_t indx = (size_t)ie->e2->toInteger();\n-                        if (indx < ale->elements->dim)\n+                        if (indx < ale->elements->length)\n                         {\n                             Expression *xx = (*ale->elements)[indx];\n                             if (xx)\n@@ -6121,7 +6121,7 @@ class Interpreter : public Visitor\n         Expressions *keysx = aae->keys;\n         Expressions *valuesx = aae->values;\n         size_t removed = 0;\n-        for (size_t j = 0; j < valuesx->dim; ++j)\n+        for (size_t j = 0; j < valuesx->length; ++j)\n         {\n             Expression *ekey = (*keysx)[j];\n             int eq = ctfeEqual(e->loc, TOKequal, ekey, index);\n@@ -6133,8 +6133,8 @@ class Interpreter : public Visitor\n                 (*valuesx)[j - removed] = (*valuesx)[j];\n             }\n         }\n-        valuesx->dim = valuesx->dim - removed;\n-        keysx->dim = keysx->dim - removed;\n+        valuesx->length = valuesx->length - removed;\n+        keysx->length = keysx->length - removed;\n         new(pue) IntegerExp(e->loc, removed ? 1 : 0, Type::tbool);\n         result = pue->exp();\n     }\n@@ -6311,7 +6311,7 @@ static bool isVoid(Expression *e, bool checkArray = false)\n // or is an array literal or struct literal of void elements.\n bool isEntirelyVoid(Expressions *elems)\n {\n-    for (size_t i = 0; i < elems->dim; i++)\n+    for (size_t i = 0; i < elems->length; i++)\n     {\n         Expression *e = (*elems)[i];\n         // It can be NULL for performance reasons,\n@@ -6325,7 +6325,7 @@ bool isEntirelyVoid(Expressions *elems)\n // Scrub all members of an array. Return false if error\n Expression *scrubArray(Loc loc, Expressions *elems, bool structlit)\n {\n-    for (size_t i = 0; i < elems->dim; i++)\n+    for (size_t i = 0; i < elems->length; i++)\n     {\n         Expression *e = (*elems)[i];\n         // It can be NULL for performance reasons,\n@@ -6421,7 +6421,7 @@ Expression *scrubCacheValue(Expression *e)\n \n Expression *scrubArrayCache(Expressions *elems)\n {\n-    for (size_t i = 0; i < elems->dim; i++)\n+    for (size_t i = 0; i < elems->length; i++)\n     {\n         Expression *e = (*elems)[i];\n         (*elems)[i] = scrubCacheValue(e);\n@@ -6453,7 +6453,7 @@ static Expression *interpret_length(UnionExp *pue, InterState *istate, Expressio\n         return earg;\n     dinteger_t len = 0;\n     if (earg->op == TOKassocarrayliteral)\n-        len = ((AssocArrayLiteralExp *)earg)->keys->dim;\n+        len = ((AssocArrayLiteralExp *)earg)->keys->length;\n     else\n         assert(earg->op == TOKnull);\n     new(pue) IntegerExp(earg->loc, len, Type::tsize_t);\n@@ -6515,7 +6515,7 @@ Expression *interpret_dup(UnionExp *pue, InterState *istate, Expression *earg)\n         return NULL;\n     assert(earg->op == TOKassocarrayliteral);\n     AssocArrayLiteralExp *aae = (AssocArrayLiteralExp *)copyLiteral(earg).copy();\n-    for (size_t i = 0; i < aae->keys->dim; i++)\n+    for (size_t i = 0; i < aae->keys->length; i++)\n     {\n         if (Expression *e = evaluatePostblit(istate, (*aae->keys)[i]))\n             return e;\n@@ -6551,7 +6551,7 @@ Expression *interpret_aaApply(UnionExp *pue, InterState *istate, Expression *aa,\n \n     assert(fd && fd->fbody);\n     assert(fd->parameters);\n-    size_t numParams = fd->parameters->dim;\n+    size_t numParams = fd->parameters->length;\n     assert(numParams == 1 || numParams == 2);\n \n     Parameter *fparam = Parameter::getNth(((TypeFunction *)fd->type)->parameters, numParams - 1);\n@@ -6561,11 +6561,11 @@ Expression *interpret_aaApply(UnionExp *pue, InterState *istate, Expression *aa,\n     args.setDim(numParams);\n \n     AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)aa;\n-    if (!ae->keys || ae->keys->dim == 0)\n+    if (!ae->keys || ae->keys->length == 0)\n         return new IntegerExp(deleg->loc, 0, Type::tsize_t);\n     Expression *eresult;\n \n-    for (size_t i = 0; i < ae->keys->dim; ++i)\n+    for (size_t i = 0; i < ae->keys->length; ++i)\n     {\n         Expression *ekey = (*ae->keys)[i];\n         Expression *evalue = (*ae->values)[i];\n@@ -6610,7 +6610,7 @@ static Expression *foreachApplyUtf(UnionExp *pue, InterState *istate, Expression\n \n     assert(fd && fd->fbody);\n     assert(fd->parameters);\n-    size_t numParams = fd->parameters->dim;\n+    size_t numParams = fd->parameters->length;\n     assert(numParams == 1 || numParams == 2);\n     Type *charType = (*fd->parameters)[numParams-1]->type;\n     Type *indexType = numParams == 2 ? (*fd->parameters)[0]->type\n@@ -6856,14 +6856,14 @@ Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n     FuncDeclaration *fd, Expressions *arguments, Expression *pthis)\n {\n     Expression *e = NULL;\n-    size_t nargs = arguments ? arguments->dim : 0;\n+    size_t nargs = arguments ? arguments->length : 0;\n     if (!pthis)\n     {\n         if (isBuiltin(fd) == BUILTINyes)\n         {\n             Expressions args;\n             args.setDim(nargs);\n-            for (size_t i = 0; i < args.dim; i++)\n+            for (size_t i = 0; i < args.length; i++)\n             {\n                 Expression *earg = (*arguments)[i];\n                 earg = interpret(earg, istate);\n@@ -6906,9 +6906,9 @@ Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n             else // (nargs == 3)\n             {\n                 if (id == Id::_aaApply)\n-                    return interpret_aaApply(pue, istate, firstarg, (Expression *)(arguments->data[2]));\n+                    return interpret_aaApply(pue, istate, firstarg, (*arguments)[2]);\n                 if (id == Id::_aaApply2)\n-                    return interpret_aaApply(pue, istate, firstarg, (Expression *)(arguments->data[2]));\n+                    return interpret_aaApply(pue, istate, firstarg, (*arguments)[2]);\n             }\n         }\n     }\n@@ -6919,8 +6919,8 @@ Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n             // At present, the constructors just copy their arguments into the struct.\n             // But we might need some magic if stack tracing gets added to druntime.\n             StructLiteralExp *se = ((ClassReferenceExp *)pthis)->value;\n-            assert(arguments->dim <= se->elements->dim);\n-            for (size_t i = 0; i < arguments->dim; ++i)\n+            assert(arguments->length <= se->elements->length);\n+            for (size_t i = 0; i < arguments->length; ++i)\n             {\n                 e = interpret((*arguments)[i], istate);\n                 if (exceptionOrCantInterpret(e))\n@@ -6976,7 +6976,7 @@ Expression *evaluatePostblit(InterState *istate, Expression *e)\n     if (e->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n-        for (size_t i = 0; i < ale->elements->dim; i++)\n+        for (size_t i = 0; i < ale->elements->length; i++)\n         {\n             e = evaluatePostblit(istate, (*ale->elements)[i]);\n             if (e)\n@@ -7012,7 +7012,7 @@ Expression *evaluateDtor(InterState *istate, Expression *e)\n     if (e->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *alex = (ArrayLiteralExp *)e;\n-        for (size_t i = alex->elements->dim; 0 < i--; )\n+        for (size_t i = alex->elements->length; 0 < i--; )\n             e = evaluateDtor(istate, (*alex->elements)[i]);\n     }\n     else if (e->op == TOKstructliteral)"}, {"sha": "18bdf27de56603ab3d73cc14ef89bd6b108060b9", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -754,7 +754,7 @@ class Mangler : public Visitor\n \n     void visit(ArrayLiteralExp *e)\n     {\n-        size_t dim = e->elements ? e->elements->dim : 0;\n+        size_t dim = e->elements ? e->elements->length : 0;\n         buf->printf(\"A%u\", dim);\n         for (size_t i = 0; i < dim; i++)\n         {\n@@ -764,7 +764,7 @@ class Mangler : public Visitor\n \n     void visit(AssocArrayLiteralExp *e)\n     {\n-        size_t dim = e->keys->dim;\n+        size_t dim = e->keys->length;\n         buf->printf(\"A%u\", dim);\n         for (size_t i = 0; i < dim; i++)\n         {\n@@ -775,7 +775,7 @@ class Mangler : public Visitor\n \n     void visit(StructLiteralExp *e)\n     {\n-        size_t dim = e->elements ? e->elements->dim : 0;\n+        size_t dim = e->elements ? e->elements->length : 0;\n         buf->printf(\"S%u\", dim);\n         for (size_t i = 0; i < dim; i++)\n         {"}, {"sha": "ba7885e8c760dba90dd3b8960fa65be91aca118d", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -224,14 +224,14 @@ Module *Module::load(Loc loc, Identifiers *packages, Identifier *ident)\n     // into:\n     //  foo\\bar\\baz\n     const char *filename = ident->toChars();\n-    if (packages && packages->dim)\n+    if (packages && packages->length)\n     {\n         OutBuffer buf;\n         OutBuffer dotmods;\n         Array<const char *> *ms = global.params.modFileAliasStrings;\n-        const size_t msdim = ms ? ms->dim : 0;\n+        const size_t msdim = ms ? ms->length : 0;\n \n-        for (size_t i = 0; i < packages->dim; i++)\n+        for (size_t i = 0; i < packages->length; i++)\n         {\n             Identifier *pid = (*packages)[i];\n             const char *p = pid->toChars();\n@@ -275,7 +275,7 @@ Module *Module::load(Loc loc, Identifiers *packages, Identifier *ident)\n         OutBuffer buf;\n         if (packages)\n         {\n-            for (size_t i = 0; i < packages->dim; i++)\n+            for (size_t i = 0; i < packages->length; i++)\n             {\n                 Identifier *pid = (*packages)[i];\n                 buf.writestring(pid->toChars());\n@@ -324,7 +324,7 @@ bool Module::read(Loc loc)\n              */\n             if (global.path)\n             {\n-                for (size_t i = 0; i < global.path->dim; i++)\n+                for (size_t i = 0; i < global.path->length; i++)\n                 {\n                     const char *p = (*global.path)[i];\n                     fprintf(stderr, \"import path[%llu] = %s\\n\", (ulonglong)i, p);\n@@ -679,7 +679,7 @@ void Module::importAll(Scope *)\n     // If it isn't there, some compiler rewrites, like\n     //    classinst == classinst -> .object.opEquals(classinst, classinst)\n     // would fail inside object.d.\n-    if (members->dim == 0 || ((*members)[0])->ident != Id::object ||\n+    if (members->length == 0 || ((*members)[0])->ident != Id::object ||\n         (*members)[0]->isImport() == NULL)\n     {\n         Import *im = new Import(Loc(), NULL, Id::object, NULL, 0);\n@@ -690,7 +690,7 @@ void Module::importAll(Scope *)\n     {\n         // Add all symbols into module's symbol table\n         symtab = new DsymbolTable();\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->addMember(sc, sc->scopesym);\n@@ -704,13 +704,13 @@ void Module::importAll(Scope *)\n      * before any semantic() on any of them.\n      */\n     setScope(sc);               // remember module scope for semantic\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->setScope(sc);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc);\n@@ -740,7 +740,7 @@ void Module::semantic(Scope *)\n     //printf(\"Module = %p, linkage = %d\\n\", sc->scopesym, sc->linkage);\n \n     // Pass 1 semantic routines: do public side of the definition\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n \n@@ -777,7 +777,7 @@ void Module::semantic2(Scope*)\n     //printf(\"Module = %p\\n\", sc.scopesym);\n \n     // Pass 2 semantic routines: do initializers and function bodies\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic2(sc);\n@@ -808,7 +808,7 @@ void Module::semantic3(Scope*)\n     //printf(\"Module = %p\\n\", sc.scopesym);\n \n     // Pass 3 semantic routines: do initializers and function bodies\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         //printf(\"Module %s: %s.semantic3()\\n\", toChars(), s->toChars());\n@@ -899,7 +899,7 @@ Dsymbol *Module::symtabInsert(Dsymbol *s)\n \n void Module::clearCache()\n {\n-    for (size_t i = 0; i < amodules.dim; i++)\n+    for (size_t i = 0; i < amodules.length; i++)\n     {\n         Module *m = amodules[i];\n         m->searchCacheIdent = NULL;\n@@ -913,7 +913,7 @@ void Module::clearCache()\n void Module::addDeferredSemantic(Dsymbol *s)\n {\n     // Don't add it if it is already there\n-    for (size_t i = 0; i < deferred.dim; i++)\n+    for (size_t i = 0; i < deferred.length; i++)\n     {\n         Dsymbol *sd = deferred[i];\n \n@@ -949,14 +949,14 @@ void Module::runDeferredSemantic()\n     static int nested;\n     if (nested)\n         return;\n-    //if (deferred.dim) printf(\"+Module::runDeferredSemantic(), len = %d\\n\", deferred.dim);\n+    //if (deferred.length) printf(\"+Module::runDeferredSemantic(), len = %d\\n\", deferred.length);\n     nested++;\n \n     size_t len;\n     do\n     {\n         dprogress = 0;\n-        len = deferred.dim;\n+        len = deferred.length;\n         if (!len)\n             break;\n \n@@ -982,20 +982,20 @@ void Module::runDeferredSemantic()\n             s->semantic(NULL);\n             //printf(\"deferred: %s, parent = %s\\n\", s->toChars(), s->parent->toChars());\n         }\n-        //printf(\"\\tdeferred.dim = %d, len = %d, dprogress = %d\\n\", deferred.dim, len, dprogress);\n+        //printf(\"\\tdeferred.length = %d, len = %d, dprogress = %d\\n\", deferred.length, len, dprogress);\n         if (todoalloc)\n             free(todoalloc);\n-    } while (deferred.dim < len || dprogress);  // while making progress\n+    } while (deferred.length < len || dprogress);  // while making progress\n     nested--;\n-    //printf(\"-Module::runDeferredSemantic(), len = %d\\n\", deferred.dim);\n+    //printf(\"-Module::runDeferredSemantic(), len = %d\\n\", deferred.length);\n }\n \n void Module::runDeferredSemantic2()\n {\n     Module::runDeferredSemantic();\n \n     Dsymbols *a = &Module::deferred2;\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Dsymbol *s = (*a)[i];\n         //printf(\"[%d] %s semantic2a\\n\", i, s->toPrettyChars());\n@@ -1012,7 +1012,7 @@ void Module::runDeferredSemantic3()\n     Module::runDeferredSemantic2();\n \n     Dsymbols *a = &Module::deferred3;\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Dsymbol *s = (*a)[i];\n         //printf(\"[%d] %s semantic3a\\n\", i, s->toPrettyChars());\n@@ -1034,7 +1034,7 @@ void Module::runDeferredSemantic3()\n int Module::imports(Module *m)\n {\n     //printf(\"%s Module::imports(%s)\\n\", toChars(), m->toChars());\n-    for (size_t i = 0; i < aimports.dim; i++)\n+    for (size_t i = 0; i < aimports.length; i++)\n     {\n         Module *mi = aimports[i];\n         if (mi == m)\n@@ -1059,12 +1059,12 @@ bool Module::selfImports()\n     //printf(\"Module::selfImports() %s\\n\", toChars());\n     if (selfimports == 0)\n     {\n-        for (size_t i = 0; i < amodules.dim; i++)\n+        for (size_t i = 0; i < amodules.length; i++)\n             amodules[i]->insearch = 0;\n \n         selfimports = imports(this) + 1;\n \n-        for (size_t i = 0; i < amodules.dim; i++)\n+        for (size_t i = 0; i < amodules.length; i++)\n             amodules[i]->insearch = 0;\n     }\n     return selfimports == 2;\n@@ -1079,11 +1079,11 @@ bool Module::rootImports()\n     //printf(\"Module::rootImports() %s\\n\", toChars());\n     if (rootimports == 0)\n     {\n-        for (size_t i = 0; i < amodules.dim; i++)\n+        for (size_t i = 0; i < amodules.length; i++)\n             amodules[i]->insearch = 0;\n \n         rootimports = 1;\n-        for (size_t i = 0; i < amodules.dim; ++i)\n+        for (size_t i = 0; i < amodules.length; ++i)\n         {\n             Module *m = amodules[i];\n             if (m->isRoot() && imports(m))\n@@ -1093,7 +1093,7 @@ bool Module::rootImports()\n             }\n         }\n \n-        for (size_t i = 0; i < amodules.dim; i++)\n+        for (size_t i = 0; i < amodules.length; i++)\n             amodules[i]->insearch = 0;\n     }\n     return rootimports == 2;\n@@ -1119,9 +1119,9 @@ const char *ModuleDeclaration::toChars()\n {\n     OutBuffer buf;\n \n-    if (packages && packages->dim)\n+    if (packages && packages->length)\n     {\n-        for (size_t i = 0; i < packages->dim; i++)\n+        for (size_t i = 0; i < packages->length; i++)\n         {\n             Identifier *pid = (*packages)[i];\n             buf.writestring(pid->toChars());\n@@ -1207,7 +1207,7 @@ DsymbolTable *Package::resolve(Identifiers *packages, Dsymbol **pparent, Package\n \n     if (packages)\n     {\n-        for (size_t i = 0; i < packages->dim; i++)\n+        for (size_t i = 0; i < packages->length; i++)\n         {\n             Identifier *pid = (*packages)[i];\n             Package *pkg;\n@@ -1318,7 +1318,7 @@ const char *lookForSourceFile(const char **path, const char *filename)\n     if (!global.path)\n         return NULL;\n \n-    for (size_t i = 0; i < global.path->dim; i++)\n+    for (size_t i = 0; i < global.path->length; i++)\n     {\n         const char *p = (*global.path)[i];\n "}, {"sha": "a448e342a82b262b32e87583352f5f44c2528308", "filename": "gcc/d/dmd/doc.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -124,7 +124,7 @@ int utfStride(const utf8_t *p);\n // Workaround for missing Parameter instance for variadic params. (it's unnecessary to instantiate one).\n bool isCVariadicParameter(Dsymbols *a, const utf8_t *p, size_t len)\n {\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         TypeFunction *tf = isTypeFunction((*a)[i]);\n         if (tf && tf->varargs == 1 && cmp(\"...\", p, len) == 0)\n@@ -140,7 +140,7 @@ static Parameter *isFunctionParameter(Dsymbol *s, const utf8_t *p, size_t len)\n     TypeFunction *tf = isTypeFunction(s);\n     if (tf && tf->parameters)\n     {\n-        for (size_t k = 0; k < tf->parameters->dim; k++)\n+        for (size_t k = 0; k < tf->parameters->length; k++)\n         {\n             Parameter *fparam = (*tf->parameters)[k];\n             if (fparam->ident && cmp(fparam->ident->toChars(), p, len) == 0)\n@@ -173,7 +173,7 @@ static Dsymbol *getEponymousMember(TemplateDeclaration *td)\n  */\n static Parameter *isEponymousFunctionParameter(Dsymbols *a, const utf8_t *p, size_t len)\n {\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         TemplateDeclaration *td = (*a)[i]->isTemplateDeclaration();\n         if (td && td->onemember)\n@@ -354,7 +354,7 @@ void gendocfile(Module *m)\n             global.params.ddocfiles->shift(p);\n \n         // Override with the ddoc macro files from the command line\n-        for (size_t i = 0; i < global.params.ddocfiles->dim; i++)\n+        for (size_t i = 0; i < global.params.ddocfiles->length; i++)\n         {\n             FileName f((*global.params.ddocfiles)[i]);\n             File file(&f);\n@@ -668,7 +668,7 @@ static void expandTemplateMixinComments(TemplateMixin *tm, OutBuffer *buf, Scope\n         tm->tempdecl->isTemplateDeclaration() : NULL;\n     if (td && td->members)\n     {\n-        for (size_t i = 0; i < td->members->dim; i++)\n+        for (size_t i = 0; i < td->members->length; i++)\n         {\n             Dsymbol *sm = (*td->members)[i];\n             TemplateMixin *tmc = sm->isTemplateMixin();\n@@ -705,7 +705,7 @@ void emitMemberComments(ScopeDsymbol *sds, OutBuffer *buf, Scope *sc)\n \n     sc = sc->push(sds);\n \n-    for (size_t i = 0; i < sds->members->dim; i++)\n+    for (size_t i = 0; i < sds->members->length; i++)\n     {\n         Dsymbol *s = (*sds->members)[i];\n         //printf(\"\\ts = '%s'\\n\", s->toChars());\n@@ -774,7 +774,7 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n             {\n                 // Put the declaration signatures as the document 'title'\n                 buf->writestring(ddoc_decl_s);\n-                for (size_t i = 0; i < dc->a.dim; i++)\n+                for (size_t i = 0; i < dc->a.length; i++)\n                 {\n                     Dsymbol *sx = dc->a[i];\n \n@@ -888,7 +888,7 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n                 return;\n             if (ed->isAnonymous() && ed->members)\n             {\n-                for (size_t i = 0; i < ed->members->dim; i++)\n+                for (size_t i = 0; i < ed->members->length; i++)\n                 {\n                     Dsymbol *s = (*ed->members)[i];\n                     emitComment(s, buf, sc);\n@@ -930,7 +930,7 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n \n             if (d)\n             {\n-                for (size_t i = 0; i < d->dim; i++)\n+                for (size_t i = 0; i < d->length; i++)\n                 {\n                     Dsymbol *s = (*d)[i];\n                     //printf(\"AttribDeclaration::emitComment %s\\n\", s->toChars());\n@@ -965,7 +965,7 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n              * a template, then include(NULL, NULL) will fail.\n              */\n             Dsymbols *d = cd->decl ? cd->decl : cd->elsedecl;\n-            for (size_t i = 0; i < d->dim; i++)\n+            for (size_t i = 0; i < d->length; i++)\n             {\n                 Dsymbol *s = (*d)[i];\n                 emitComment(s, buf, sc);\n@@ -1067,9 +1067,9 @@ void toDocBuffer(Dsymbol *s, OutBuffer *buf, Scope *sc)\n             if (d->isVarDeclaration() && td)\n             {\n                 buf->writeByte('(');\n-                if (td->origParameters && td->origParameters->dim)\n+                if (td->origParameters && td->origParameters->length)\n                 {\n-                    for (size_t i = 0; i < td->origParameters->dim; i++)\n+                    for (size_t i = 0; i < td->origParameters->length; i++)\n                     {\n                         if (i)\n                             buf->writestring(\", \");\n@@ -1219,7 +1219,7 @@ void toDocBuffer(Dsymbol *s, OutBuffer *buf, Scope *sc)\n                 buf->printf(\"%s %s\", cd->kind(), cd->toChars());\n             }\n             int any = 0;\n-            for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+            for (size_t i = 0; i < cd->baseclasses->length; i++)\n             {\n                 BaseClass *bc = (*cd->baseclasses)[i];\n \n@@ -1288,7 +1288,7 @@ DocComment *DocComment::parse(Dsymbol *s, const utf8_t *comment)\n \n     dc->parseSections(comment);\n \n-    for (size_t i = 0; i < dc->sections.dim; i++)\n+    for (size_t i = 0; i < dc->sections.length; i++)\n     {\n         Section *sec = dc->sections[i];\n \n@@ -1444,7 +1444,7 @@ void DocComment::parseSections(const utf8_t *comment)\n \n void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n {\n-    assert(a->dim);\n+    assert(a->length);\n \n     //printf(\"DocComment::writeSections()\\n\");\n     Loc loc = (*a)[0]->loc;\n@@ -1458,7 +1458,7 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n     buf->writestring(\"$(DDOC_SECTIONS \");\n     size_t offset2 = buf->offset;\n \n-    for (size_t i = 0; i < sections.dim; i++)\n+    for (size_t i = 0; i < sections.length; i++)\n     {\n         Section *sec = sections[i];\n         if (sec->nooutput)\n@@ -1478,7 +1478,7 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n             sec->write(loc, this, sc, a, buf);\n     }\n \n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Dsymbol *s = (*a)[i];\n         if (Dsymbol *td = getEponymousParent(s))\n@@ -1528,7 +1528,7 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n \n void Section::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffer *buf)\n {\n-    assert(a->dim);\n+    assert(a->length);\n \n     if (namelen)\n     {\n@@ -1579,7 +1579,7 @@ void Section::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffer *bu\n \n void ParamSection::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffer *buf)\n {\n-    assert(a->dim);\n+    assert(a->length);\n     Dsymbol *s = (*a)[0];   // test\n \n     const utf8_t *p = body;\n@@ -1730,10 +1730,10 @@ void ParamSection::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffe\n         goto L1;                // write out last one\n     buf->writestring(\")\\n\");\n \n-    TypeFunction *tf = a->dim == 1 ? isTypeFunction(s) : NULL;\n+    TypeFunction *tf = a->length == 1 ? isTypeFunction(s) : NULL;\n     if (tf)\n     {\n-        size_t pcount = (tf->parameters ? tf->parameters->dim : 0) + (int)(tf->varargs == 1);\n+        size_t pcount = (tf->parameters ? tf->parameters->length : 0) + (int)(tf->varargs == 1);\n         if (pcount != paramcount)\n         {\n             warning(s->loc, \"Ddoc: parameter count mismatch\");\n@@ -2109,7 +2109,7 @@ size_t skippastURL(OutBuffer *buf, size_t i)\n \n bool isIdentifier(Dsymbols *a, const utf8_t *p, size_t len)\n {\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         const char *s = (*a)[i]->ident->toChars();\n         if (cmp(s, p, len) == 0)\n@@ -2156,7 +2156,7 @@ TypeFunction *isTypeFunction(Dsymbol *s)\n \n Parameter *isFunctionParameter(Dsymbols *a, const utf8_t *p, size_t len)\n {\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Parameter *fparam = isFunctionParameter((*a)[i], p, len);\n         if (fparam)\n@@ -2172,15 +2172,15 @@ Parameter *isFunctionParameter(Dsymbols *a, const utf8_t *p, size_t len)\n \n TemplateParameter *isTemplateParameter(Dsymbols *a, const utf8_t *p, size_t len)\n {\n-    for (size_t i = 0; i < a->dim; i++)\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         TemplateDeclaration *td = (*a)[i]->isTemplateDeclaration();\n         // Check for the parent, if the current symbol is not a template declaration.\n         if (!td)\n             td = getEponymousParent((*a)[i]);\n         if (td && td->origParameters)\n         {\n-            for (size_t k = 0; k < td->origParameters->dim; k++)\n+            for (size_t k = 0; k < td->origParameters->length; k++)\n             {\n                 TemplateParameter *tp = (*td->origParameters)[k];\n                 if (tp->ident && cmp(tp->ident->toChars(), p, len) == 0)\n@@ -2222,7 +2222,7 @@ bool isReservedName(utf8_t *str, size_t len)\n \n void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n {\n-    Dsymbol *s = a->dim ? (*a)[0] : NULL;   // test\n+    Dsymbol *s = a->length ? (*a)[0] : NULL;   // test\n \n     //printf(\"highlightText()\\n\");\n "}, {"sha": "f1b7f2d9a65206e63195411e7cffa043fb8c97db", "filename": "gcc/d/dmd/dscope.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdscope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdscope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -352,7 +352,7 @@ void Scope::mergeFieldInit(Loc loc, unsigned *fies)\n         AggregateDeclaration *ad = f->isMember2();\n         assert(ad);\n \n-        for (size_t i = 0; i < ad->fields.dim; i++)\n+        for (size_t i = 0; i < ad->fields.length; i++)\n         {\n             VarDeclaration *v = ad->fields[i];\n             bool mustInit = (v->storage_class & STCnodefaultctor ||\n@@ -644,20 +644,20 @@ void Scope::deprecation10378(Loc loc, Dsymbol *sold, Dsymbol *snew)\n     OverloadSet *osnew = NULL;\n     if (sold && (osold = sold->isOverloadSet()) != NULL &&\n         snew && (osnew = snew->isOverloadSet()) != NULL &&\n-        osold->a.dim == osnew->a.dim)\n+        osold->a.length == osnew->a.length)\n         return;\n \n     OutBuffer buf;\n     buf.writestring(\"local import search method found \");\n     if (osold)\n-        buf.printf(\"%s %s (%d overloads)\", sold->kind(), sold->toPrettyChars(), (int)osold->a.dim);\n+        buf.printf(\"%s %s (%d overloads)\", sold->kind(), sold->toPrettyChars(), (int)osold->a.length);\n     else if (sold)\n         buf.printf(\"%s %s\", sold->kind(), sold->toPrettyChars());\n     else\n         buf.writestring(\"nothing\");\n     buf.writestring(\" instead of \");\n     if (osnew)\n-        buf.printf(\"%s %s (%d overloads)\", snew->kind(), snew->toPrettyChars(), (int)osnew->a.dim);\n+        buf.printf(\"%s %s (%d overloads)\", snew->kind(), snew->toPrettyChars(), (int)osnew->a.length);\n     else if (snew)\n         buf.printf(\"%s %s\", snew->kind(), snew->toPrettyChars());\n     else"}, {"sha": "5af2745572441c7db17736f775564cd46e8591c2", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -154,7 +154,7 @@ void semanticTypeInfo(Scope *sc, Type *t)\n         {\n             if (t->arguments)\n             {\n-                for (size_t i = 0; i < t->arguments->dim; i++)\n+                for (size_t i = 0; i < t->arguments->length; i++)\n                 {\n                     Type *tprm = (*t->arguments)[i]->type;\n                     if (tprm)\n@@ -261,7 +261,7 @@ void AggregateDeclaration::semantic2(Scope *sc)\n \n     determineSize(loc);\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         //printf(\"\\t[%d] %s\\n\", i, s->toChars());\n@@ -287,7 +287,7 @@ void AggregateDeclaration::semantic3(Scope *sc)\n \n     Scope *sc2 = newScope(sc);\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic3(sc2);\n@@ -344,7 +344,7 @@ bool AggregateDeclaration::determineFields()\n     if (sizeok != SIZEOKnone)\n         return true;\n \n-    //printf(\"determineFields() %s, fields.dim = %d\\n\", toChars(), fields.dim);\n+    //printf(\"determineFields() %s, fields.length = %d\\n\", toChars(), fields.length);\n     fields.setDim(0);\n \n     struct SV\n@@ -396,7 +396,7 @@ bool AggregateDeclaration::determineFields()\n     SV sv;\n     sv.agg = this;\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         if (s->apply(&SV::func, &sv))\n@@ -557,7 +557,7 @@ bool AggregateDeclaration::checkOverlappedFields()\n {\n     //printf(\"AggregateDeclaration::checkOverlappedFields() %s\\n\", toChars());\n     assert(sizeok == SIZEOKdone);\n-    size_t nfields = fields.dim;\n+    size_t nfields = fields.length;\n     if (isNested())\n     {\n         ClassDeclaration *cd = isClassDeclaration();\n@@ -633,10 +633,10 @@ bool AggregateDeclaration::fill(Loc loc, Expressions *elements, bool ctorinit)\n     //printf(\"AggregateDeclaration::fill() %s\\n\", toChars());\n     assert(sizeok == SIZEOKdone);\n     assert(elements);\n-    size_t nfields = fields.dim - isNested();\n+    size_t nfields = fields.length - isNested();\n     bool errors = false;\n \n-    size_t dim = elements->dim;\n+    size_t dim = elements->length;\n     elements->setDim(nfields);\n     for (size_t i = dim; i < nfields; i++)\n         (*elements)[i] = NULL;\n@@ -768,7 +768,7 @@ bool AggregateDeclaration::fill(Loc loc, Expressions *elements, bool ctorinit)\n         }\n     }\n \n-    for (size_t i = 0; i < elements->dim; i++)\n+    for (size_t i = 0; i < elements->length; i++)\n     {\n         Expression *e = (*elements)[i];\n         if (e && e->op == TOKerror)\n@@ -967,7 +967,7 @@ Dsymbol *AggregateDeclaration::searchCtor()\n             }\n         };\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *sm = (*members)[i];\n             sm->apply(&SearchCtor::fp, NULL);\n@@ -1091,7 +1091,7 @@ void StructDeclaration::semantic(Scope *sc)\n     {\n         symtab = new DsymbolTable();\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\"adding member '%s' to '%s'\\n\", s->toChars(), this->toChars());\n@@ -1104,20 +1104,20 @@ void StructDeclaration::semantic(Scope *sc)\n     /* Set scope so if there are forward references, we still might be able to\n      * resolve individual members like enums.\n      */\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         //printf(\"struct: setScope %s %s\\n\", s->kind(), s->toChars());\n         s->setScope(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic(sc2);\n@@ -1136,7 +1136,7 @@ void StructDeclaration::semantic(Scope *sc)\n      * needs to check existence of elaborate dtor in type of each fields.\n      * See the case in compilable/test14838.d\n      */\n-    for (size_t i = 0; i < fields.dim; i++)\n+    for (size_t i = 0; i < fields.length; i++)\n     {\n         VarDeclaration *v = fields[i];\n         Type *tb = v->type->baseElemOf();\n@@ -1245,14 +1245,14 @@ void StructDeclaration::finalizeSize()\n     //printf(\"StructDeclaration::finalizeSize() %s, sizeok = %d\\n\", toChars(), sizeok);\n     assert(sizeok != SIZEOKdone);\n \n-    //printf(\"+StructDeclaration::finalizeSize() %s, fields.dim = %d, sizeok = %d\\n\", toChars(), fields.dim, sizeok);\n+    //printf(\"+StructDeclaration::finalizeSize() %s, fields.length = %d, sizeok = %d\\n\", toChars(), fields.length, sizeok);\n \n     fields.setDim(0);   // workaround\n \n     // Set the offsets of the fields and determine the size of the struct\n     unsigned offset = 0;\n     bool isunion = isUnionDeclaration() != NULL;\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->setFieldOffset(this, &offset, isunion);\n@@ -1277,7 +1277,7 @@ void StructDeclaration::finalizeSize()\n \n     sizeok = SIZEOKdone;\n \n-    //printf(\"-StructDeclaration::finalizeSize() %s, fields.dim = %d, structsize = %d\\n\", toChars(), fields.dim, structsize);\n+    //printf(\"-StructDeclaration::finalizeSize() %s, fields.length = %d, structsize = %d\\n\", toChars(), fields.length, structsize);\n \n     if (errors)\n         return;\n@@ -1291,7 +1291,7 @@ void StructDeclaration::finalizeSize()\n \n     // Determine if struct is all zeros or not\n     zeroInit = 1;\n-    for (size_t i = 0; i < fields.dim; i++)\n+    for (size_t i = 0; i < fields.length; i++)\n     {\n         VarDeclaration *vd = fields[i];\n         if (vd->_init)\n@@ -1308,7 +1308,7 @@ void StructDeclaration::finalizeSize()\n     }\n \n     TypeTuple *tt = Target::toArgTypes(type);\n-    size_t dim = tt ? tt->arguments->dim : 0;\n+    size_t dim = tt ? tt->arguments->length : 0;\n     if (dim >= 1)\n     {\n         assert(dim <= 2);\n@@ -1333,9 +1333,9 @@ bool StructDeclaration::fit(Loc loc, Scope *sc, Expressions *elements, Type *sty\n     if (!elements)\n         return true;\n \n-    size_t nfields = fields.dim - isNested();\n+    size_t nfields = fields.length - isNested();\n     size_t offset = 0;\n-    for (size_t i = 0; i < elements->dim; i++)\n+    for (size_t i = 0; i < elements->length; i++)\n     {\n         Expression *e = (*elements)[i];\n         if (!e)\n@@ -1344,7 +1344,7 @@ bool StructDeclaration::fit(Loc loc, Scope *sc, Expressions *elements, Type *sty\n         e = resolveProperties(sc, e);\n         if (i >= nfields)\n         {\n-            if (i == fields.dim - 1 && isNested() && e->op == TOKnull)\n+            if (i == fields.length - 1 && isNested() && e->op == TOKnull)\n             {\n                 // CTFE sometimes creates null as hidden pointer; we'll allow this.\n                 continue;\n@@ -1428,7 +1428,7 @@ bool StructDeclaration::isPOD()\n         ispod = ISPODno;\n \n     // Recursively check all fields are POD.\n-    for (size_t i = 0; i < fields.dim; i++)\n+    for (size_t i = 0; i < fields.length; i++)\n     {\n         VarDeclaration *v = fields[i];\n         if (v->storage_class & STCref)"}, {"sha": "f8b063f0318565a4cca00ab2f2a8d94970f8dc38", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -127,12 +127,12 @@ bool Dsymbol::oneMember(Dsymbol **ps, Identifier *)\n \n bool Dsymbol::oneMembers(Dsymbols *members, Dsymbol **ps, Identifier *ident)\n {\n-    //printf(\"Dsymbol::oneMembers() %d\\n\", members ? members->dim : 0);\n+    //printf(\"Dsymbol::oneMembers() %d\\n\", members ? members->length : 0);\n     Dsymbol *s = NULL;\n \n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *sx = (*members)[i];\n             bool x = sx->oneMember(ps, ident);\n@@ -881,7 +881,7 @@ Dsymbols *Dsymbol::arraySyntaxCopy(Dsymbols *a)\n     if (a)\n     {\n         b = a->copy();\n-        for (size_t i = 0; i < b->dim; i++)\n+        for (size_t i = 0; i < b->length; i++)\n         {\n             (*b)[i] = (*b)[i]->syntaxCopy(NULL);\n         }\n@@ -936,7 +936,7 @@ OverloadSet::OverloadSet(Identifier *ident, OverloadSet *os)\n {\n     if (os)\n     {\n-        for (size_t i = 0; i < os->a.dim; i++)\n+        for (size_t i = 0; i < os->a.length; i++)\n         {\n             a.push(os->a[i]);\n         }\n@@ -1097,7 +1097,7 @@ Dsymbol *ScopeDsymbol::search(const Loc &loc, Identifier *ident, int flags)\n         OverloadSet *a = NULL;\n \n         // Look in imported modules\n-        for (size_t i = 0; i < importedScopes->dim; i++)\n+        for (size_t i = 0; i < importedScopes->length; i++)\n         {\n             // If private import, don't search it\n             if ((flags & IgnorePrivateImports) && prots[i] == PROTprivate)\n@@ -1231,14 +1231,14 @@ OverloadSet *ScopeDsymbol::mergeOverloadSet(Identifier *ident, OverloadSet *os,\n     if (OverloadSet *os2 = s->isOverloadSet())\n     {\n         // Merge the cross-module overload set 'os2' into 'os'\n-        if (os->a.dim == 0)\n+        if (os->a.length == 0)\n         {\n-            os->a.setDim(os2->a.dim);\n-            memcpy(os->a.tdata(), os2->a.tdata(), sizeof(os->a[0]) * os2->a.dim);\n+            os->a.setDim(os2->a.length);\n+            memcpy(os->a.tdata(), os2->a.tdata(), sizeof(os->a[0]) * os2->a.length);\n         }\n         else\n         {\n-            for (size_t i = 0; i < os2->a.dim; i++)\n+            for (size_t i = 0; i < os2->a.length; i++)\n             {\n                 os = mergeOverloadSet(ident, os, os2->a[i]);\n             }\n@@ -1250,7 +1250,7 @@ OverloadSet *ScopeDsymbol::mergeOverloadSet(Identifier *ident, OverloadSet *os,\n \n         /* Don't add to os[] if s is alias of previous sym\n          */\n-        for (size_t j = 0; j < os->a.dim; j++)\n+        for (size_t j = 0; j < os->a.length; j++)\n         {\n             Dsymbol *s2 = os->a[j];\n             if (s->toAlias() == s2->toAlias())\n@@ -1282,7 +1282,7 @@ void ScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n             importedScopes = new Dsymbols();\n         else\n         {\n-            for (size_t i = 0; i < importedScopes->dim; i++)\n+            for (size_t i = 0; i < importedScopes->length; i++)\n             {\n                 Dsymbol *ss = (*importedScopes)[i];\n                 if (ss == s)                    // if already imported\n@@ -1294,8 +1294,8 @@ void ScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n             }\n         }\n         importedScopes->push(s);\n-        prots = (PROTKIND *)mem.xrealloc(prots, importedScopes->dim * sizeof(prots[0]));\n-        prots[importedScopes->dim - 1] = protection.kind;\n+        prots = (PROTKIND *)mem.xrealloc(prots, importedScopes->length * sizeof(prots[0]));\n+        prots[importedScopes->length - 1] = protection.kind;\n     }\n }\n \n@@ -1346,7 +1346,7 @@ bool ScopeDsymbol::isPackageAccessible(Package *p, Prot protection, int)\n         return true;\n     if (importedScopes)\n     {\n-        for (size_t i = 0; i < importedScopes->dim; i++)\n+        for (size_t i = 0; i < importedScopes->length; i++)\n         {\n             // only search visible scopes && imported modules should ignore private imports\n             Dsymbol *ss = (*importedScopes)[i];\n@@ -1409,7 +1409,7 @@ bool ScopeDsymbol::hasStaticCtorOrDtor()\n {\n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {   Dsymbol *member = (*members)[i];\n \n             if (member->hasStaticCtorOrDtor())\n@@ -1484,7 +1484,7 @@ int ScopeDsymbol_foreach(Scope *sc, Dsymbols *members, ForeachDg dg, void *ctx,\n \n     size_t n = pn ? *pn : 0; // take over index\n     int result = 0;\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {   Dsymbol *s = (*members)[i];\n \n         if (AttribDeclaration *a = s->isAttribDeclaration())\n@@ -1612,7 +1612,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n             /* $ gives the number of elements in the tuple\n              */\n             VarDeclaration *v = new VarDeclaration(loc, Type::tsize_t, Id::dollar, NULL);\n-            Expression *e = new IntegerExp(Loc(), td->objects->dim, Type::tsize_t);\n+            Expression *e = new IntegerExp(Loc(), td->objects->length, Type::tsize_t);\n             v->_init = new ExpInitializer(Loc(), e);\n             v->storage_class |= STCtemp | STCstatic | STCconst;\n             v->semantic(sc);\n@@ -1624,7 +1624,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n             /* $ gives the number of type entries in the type tuple\n              */\n             VarDeclaration *v = new VarDeclaration(loc, Type::tsize_t, Id::dollar, NULL);\n-            Expression *e = new IntegerExp(Loc(), type->arguments->dim, Type::tsize_t);\n+            Expression *e = new IntegerExp(Loc(), type->arguments->length, Type::tsize_t);\n             v->_init = new ExpInitializer(Loc(), e);\n             v->storage_class |= STCtemp | STCstatic | STCconst;\n             v->semantic(sc);\n@@ -1694,7 +1694,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n                 /* It is for an expression tuple, so the\n                  * length will be a const.\n                  */\n-                Expression *e = new IntegerExp(Loc(), ((TupleExp *)ce)->exps->dim, Type::tsize_t);\n+                Expression *e = new IntegerExp(Loc(), ((TupleExp *)ce)->exps->length, Type::tsize_t);\n                 v = new VarDeclaration(loc, Type::tsize_t, Id::dollar, new ExpInitializer(Loc(), e));\n                 v->storage_class |= STCtemp | STCstatic | STCconst;\n             }\n@@ -1742,7 +1742,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n                      * Note that it's impossible to have both template & function opDollar,\n                      * because both take no arguments.\n                      */\n-                    if (exp->op == TOKarray && ((ArrayExp *)exp)->arguments->dim != 1)\n+                    if (exp->op == TOKarray && ((ArrayExp *)exp)->arguments->length != 1)\n                     {\n                         exp->error(\"%s only defines opDollar for one dimension\", ad->toChars());\n                         return NULL;"}, {"sha": "b126295f07e7eed134be2d993156909e5702f8bb", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 205, "deletions": 205, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -121,7 +121,7 @@ bool isError(RootObject *o)\n  */\n bool arrayObjectIsError(Objects *args)\n {\n-    for (size_t i = 0; i < args->dim; i++)\n+    for (size_t i = 0; i < args->length; i++)\n     {\n         RootObject *o = (*args)[i];\n         if (isError(o))\n@@ -370,9 +370,9 @@ int arrayObjectMatch(Objects *oa1, Objects *oa2)\n {\n     if (oa1 == oa2)\n         return 1;\n-    if (oa1->dim != oa2->dim)\n+    if (oa1->length != oa2->length)\n         return 0;\n-    for (size_t j = 0; j < oa1->dim; j++)\n+    for (size_t j = 0; j < oa1->length; j++)\n     {\n         RootObject *o1 = (*oa1)[j];\n         RootObject *o2 = (*oa2)[j];\n@@ -423,7 +423,7 @@ static hash_t expressionHash(Expression *e)\n         TupleExp *te = (TupleExp *)e;\n         size_t hash = 0;\n         hash += te->e0 ? expressionHash(te->e0) : 0;\n-        for (size_t i = 0; i < te->exps->dim; i++)\n+        for (size_t i = 0; i < te->exps->length; i++)\n         {\n             Expression *elem = (*te->exps)[i];\n             hash = mixHash(hash, expressionHash(elem));\n@@ -435,7 +435,7 @@ static hash_t expressionHash(Expression *e)\n     {\n         ArrayLiteralExp *ae = (ArrayLiteralExp *)e;\n         size_t hash = 0;\n-        for (size_t i = 0; i < ae->elements->dim; i++)\n+        for (size_t i = 0; i < ae->elements->length; i++)\n             hash = mixHash(hash, expressionHash(ae->getElement(i)));\n         return hash;\n     }\n@@ -444,7 +444,7 @@ static hash_t expressionHash(Expression *e)\n     {\n         AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)e;\n         size_t hash = 0;\n-        for (size_t i = 0; i < ae->keys->dim; i++)\n+        for (size_t i = 0; i < ae->keys->length; i++)\n             // reduction needs associative op as keys are unsorted (use XOR)\n             hash ^= mixHash(expressionHash((*ae->keys)[i]), expressionHash((*ae->values)[i]));\n         return hash;\n@@ -454,7 +454,7 @@ static hash_t expressionHash(Expression *e)\n     {\n         StructLiteralExp *se = (StructLiteralExp *)e;\n         size_t hash = 0;\n-        for (size_t i = 0; i < se->elements->dim; i++)\n+        for (size_t i = 0; i < se->elements->length; i++)\n         {\n             Expression *elem = (*se->elements)[i];\n             hash = mixHash(hash, elem ? expressionHash(elem) : 0);\n@@ -482,7 +482,7 @@ static hash_t expressionHash(Expression *e)\n static hash_t arrayObjectHash(Objects *oa1)\n {\n     hash_t hash = 0;\n-    for (size_t j = 0; j < oa1->dim; j++)\n+    for (size_t j = 0; j < oa1->length; j++)\n     {\n         /* Must follow the logic of match()\n          */\n@@ -558,8 +558,8 @@ Dsymbol *TemplateDeclaration::syntaxCopy(Dsymbol *)\n     if (parameters)\n     {\n         p = new TemplateParameters();\n-        p->setDim(parameters->dim);\n-        for (size_t i = 0; i < p->dim; i++)\n+        p->setDim(parameters->length);\n+        for (size_t i = 0; i < p->length; i++)\n             (*p)[i] = (*parameters)[i]->syntaxCopy();\n     }\n     return new TemplateDeclaration(loc, ident, p,\n@@ -609,15 +609,15 @@ void TemplateDeclaration::semantic(Scope *sc)\n     if (global.params.doDocComments)\n     {\n         origParameters = new TemplateParameters();\n-        origParameters->setDim(parameters->dim);\n-        for (size_t i = 0; i < parameters->dim; i++)\n+        origParameters->setDim(parameters->length);\n+        for (size_t i = 0; i < parameters->length; i++)\n         {\n             TemplateParameter *tp = (*parameters)[i];\n             (*origParameters)[i] = tp->syntaxCopy();\n         }\n     }\n \n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         TemplateParameter *tp = (*parameters)[i];\n \n@@ -630,7 +630,7 @@ void TemplateDeclaration::semantic(Scope *sc)\n         {\n             errors = true;\n         }\n-        if (i + 1 != parameters->dim && tp->isTemplateTupleParameter())\n+        if (i + 1 != parameters->length && tp->isTemplateTupleParameter())\n         {\n             error(\"template tuple parameter must be last one\");\n             errors = true;\n@@ -641,12 +641,12 @@ void TemplateDeclaration::semantic(Scope *sc)\n      */\n     TemplateParameters tparams;\n     tparams.setDim(1);\n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         TemplateParameter *tp = (*parameters)[i];\n         tparams[0] = tp;\n \n-        for (size_t j = 0; j < parameters->dim; j++)\n+        for (size_t j = 0; j < parameters->length; j++)\n         {\n             // Skip cases like: X(T : T)\n             if (i == j)\n@@ -798,7 +798,7 @@ bool TemplateDeclaration::evaluateConstraint(\n             if (fvarargs == 2 && i + 1 == nfparams)\n                 fparam->storageClass |= STCvariadic;\n         }\n-        for (size_t i = 0; i < fparameters->dim; i++)\n+        for (size_t i = 0; i < fparameters->length; i++)\n         {\n             Parameter *fparam = (*fparameters)[i];\n             if (!fparam->ident)\n@@ -852,24 +852,24 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n         Objects *dedtypes, Expressions *fargs, int flag)\n {\n     MATCH m;\n-    size_t dedtypes_dim = dedtypes->dim;\n+    size_t dedtypes_dim = dedtypes->length;\n \n     dedtypes->zero();\n \n     if (errors)\n         return MATCHnomatch;\n \n-    size_t parameters_dim = parameters->dim;\n+    size_t parameters_dim = parameters->length;\n     int variadic = isVariadic() != NULL;\n \n     // If more arguments than parameters, no match\n-    if (ti->tiargs->dim > parameters_dim && !variadic)\n+    if (ti->tiargs->length > parameters_dim && !variadic)\n     {\n         return MATCHnomatch;\n     }\n \n     assert(dedtypes_dim == parameters_dim);\n-    assert(dedtypes_dim >= ti->tiargs->dim || variadic);\n+    assert(dedtypes_dim >= ti->tiargs->length || variadic);\n \n     assert(_scope);\n \n@@ -918,7 +918,7 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n         {\n             if (!(*dedtypes)[i])\n             {\n-                assert(i < ti->tiargs->dim);\n+                assert(i < ti->tiargs->length);\n                 (*dedtypes)[i] = (Type *)(*ti->tiargs)[i];\n             }\n         }\n@@ -943,7 +943,7 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n             fd->inferRetType = true;\n \n             // Shouldn't run semantic on default arguments and return type.\n-            for (size_t i = 0; i < tf->parameters->dim; i++)\n+            for (size_t i = 0; i < tf->parameters->length; i++)\n                 (*tf->parameters)[i]->defaultArg = NULL;\n             tf->next = NULL;\n \n@@ -995,8 +995,8 @@ MATCH TemplateDeclaration::leastAsSpecialized(Scope *sc, TemplateDeclaration *td\n     // Set type arguments to dummy template instance to be types\n     // generated from the parameters to this template declaration\n     ti.tiargs = new Objects();\n-    ti.tiargs->reserve(parameters->dim);\n-    for (size_t i = 0; i < parameters->dim; i++)\n+    ti.tiargs->reserve(parameters->length);\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         TemplateParameter *tp = (*parameters)[i];\n         if (tp->dependent)\n@@ -1010,7 +1010,7 @@ MATCH TemplateDeclaration::leastAsSpecialized(Scope *sc, TemplateDeclaration *td\n \n     // Temporary Array to hold deduced types\n     Objects dedtypes;\n-    dedtypes.setDim(td2->parameters->dim);\n+    dedtypes.setDim(td2->parameters->length);\n \n     // Attempt a type deduction\n     MATCH m = td2->matchWithInstance(sc, &ti, &dedtypes, fargs, 1);\n@@ -1064,7 +1064,7 @@ class TypeDeduced : public Type\n     MATCH matchAll(Type *tt)\n     {\n         MATCH match = MATCHexact;\n-        for (size_t j = 0; j < argexps.dim; j++)\n+        for (size_t j = 0; j < argexps.length; j++)\n         {\n             Expression *e = argexps[j];\n             assert(e);\n@@ -1122,10 +1122,10 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n \n     assert(_scope);\n \n-    dedargs->setDim(parameters->dim);\n+    dedargs->setDim(parameters->length);\n     dedargs->zero();\n \n-    dedtypes->setDim(parameters->dim);\n+    dedtypes->setDim(parameters->length);\n     dedtypes->zero();\n \n     if (errors || fd->errors)\n@@ -1147,8 +1147,8 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n     if (tiargs)\n     {\n         // Set initial template arguments\n-        ntargs = tiargs->dim;\n-        size_t n = parameters->dim;\n+        ntargs = tiargs->length;\n+        size_t n = parameters->length;\n         if (tp)\n             n--;\n         if (ntargs > n)\n@@ -1160,11 +1160,11 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n              * now form the tuple argument.\n              */\n             Tuple *t = new Tuple();\n-            assert(parameters->dim);\n-            (*dedargs)[parameters->dim - 1] = t;\n+            assert(parameters->length);\n+            (*dedargs)[parameters->length - 1] = t;\n \n             t->objects.setDim(ntargs - n);\n-            for (size_t i = 0; i < t->objects.dim; i++)\n+            for (size_t i = 0; i < t->objects.length; i++)\n             {\n                 t->objects[i] = (*tiargs)[n + i];\n             }\n@@ -1178,7 +1178,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n \n         for (size_t i = 0; i < n; i++)\n         {\n-            assert(i < parameters->dim);\n+            assert(i < parameters->length);\n             Declaration *sparam = NULL;\n             MATCH m = (*parameters)[i]->matchArg(instLoc, paramscope, dedargs, i, parameters, dedtypes, &sparam);\n             //printf(\"\\tdeduceType m = %d\\n\", m);\n@@ -1191,18 +1191,18 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             if (!paramscope->insert(sparam))\n                 goto Lnomatch;\n         }\n-        if (n < parameters->dim && !declaredTuple)\n+        if (n < parameters->length && !declaredTuple)\n         {\n             inferStart = n;\n         }\n         else\n-            inferStart = parameters->dim;\n+            inferStart = parameters->length;\n         //printf(\"tiargs matchTiargs = %d\\n\", matchTiargs);\n     }\n \n     fparameters = fd->getParameters(&fvarargs);\n     nfparams = Parameter::dim(fparameters);     // number of function parameters\n-    nfargs = fargs ? fargs->dim : 0;            // number of function arguments\n+    nfargs = fargs ? fargs->length : 0;            // number of function arguments\n \n     /* Check for match of function arguments with variadic template\n      * parameter, such as:\n@@ -1221,7 +1221,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             {\n                 Tuple *t = new Tuple();\n                 //printf(\"t = %p\\n\", t);\n-                (*dedargs)[parameters->dim - 1] = t;\n+                (*dedargs)[parameters->length - 1] = t;\n                 declareParameter(paramscope, tp, t);\n                 declaredTuple = t;\n             }\n@@ -1239,7 +1239,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 if (fparam->type->ty != Tident)\n                     continue;\n                 TypeIdentifier *tid = (TypeIdentifier *)fparam->type;\n-                if (!tp->ident->equals(tid->ident) || tid->idents.dim)\n+                if (!tp->ident->equals(tid->ident) || tid->idents.length)\n                     continue;\n \n                 if (fvarargs)           // variadic function doesn't\n@@ -1260,7 +1260,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n         bool hasttp = false;\n \n         // Match 'tthis' to any TemplateThisParameter's\n-        for (size_t i = 0; i < parameters->dim; i++)\n+        for (size_t i = 0; i < parameters->length; i++)\n         {\n             TemplateThisParameter *ttp = (*parameters)[i]->isTemplateThisParameter();\n             if (ttp)\n@@ -1314,7 +1314,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n \n     // Loop through the function parameters\n     {\n-    //printf(\"%s\\n\\tnfargs = %d, nfparams = %d, tuple_dim = %d\\n\", toChars(), nfargs, nfparams, declaredTuple ? declaredTuple->objects.dim : 0);\n+    //printf(\"%s\\n\\tnfargs = %d, nfparams = %d, tuple_dim = %d\\n\", toChars(), nfargs, nfparams, declaredTuple ? declaredTuple->objects.length : 0);\n     //printf(\"\\ttp = %p, fptupindex = %d, found = %d, declaredTuple = %s\\n\", tp, fptupindex, fptupindex != IDX_NOTFOUND, declaredTuple ? declaredTuple->toChars() : NULL);\n     size_t argi = 0;\n     size_t nfargs2 = nfargs;    // nfargs + supplied defaultArgs\n@@ -1340,7 +1340,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                  * now form the tuple argument.\n                  */\n                 declaredTuple = new Tuple();\n-                (*dedargs)[parameters->dim - 1] = declaredTuple;\n+                (*dedargs)[parameters->length - 1] = declaredTuple;\n \n                 /* Count function parameters following a tuple parameter.\n                  * void foo(U, T...)(int y, T, U, int) {}  // rem == 2 (U, int)\n@@ -1352,7 +1352,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                     if (!reliesOnTident(p->type, parameters, inferStart))\n                     {\n                         Type *pt = p->type->syntaxCopy()->semantic(fd->loc, paramscope);\n-                        rem += pt->ty == Ttuple ? ((TypeTuple *)pt)->arguments->dim : 1;\n+                        rem += pt->ty == Ttuple ? ((TypeTuple *)pt)->arguments->length : 1;\n                     }\n                     else\n                     {\n@@ -1363,7 +1363,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 if (nfargs2 - argi < rem)\n                     goto Lnomatch;\n                 declaredTuple->objects.setDim(nfargs2 - argi - rem);\n-                for (size_t i = 0; i < declaredTuple->objects.dim; i++)\n+                for (size_t i = 0; i < declaredTuple->objects.length; i++)\n                 {\n                     farg = (*fargs)[argi + i];\n \n@@ -1407,14 +1407,14 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             {\n                 // Bugzilla 6810: If declared tuple is not a type tuple,\n                 // it cannot be function parameter types.\n-                for (size_t i = 0; i < declaredTuple->objects.dim; i++)\n+                for (size_t i = 0; i < declaredTuple->objects.length; i++)\n                 {\n                     if (!isType(declaredTuple->objects[i]))\n                         goto Lnomatch;\n                 }\n             }\n             assert(declaredTuple);\n-            argi += declaredTuple->objects.dim;\n+            argi += declaredTuple->objects.length;\n             continue;\n         }\n \n@@ -1428,7 +1428,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             if (prmtype->ty == Ttuple)\n             {\n                 TypeTuple *tt = (TypeTuple *)prmtype;\n-                size_t tt_dim = tt->arguments->dim;\n+                size_t tt_dim = tt->arguments->length;\n                 for (size_t j = 0; j < tt_dim; j++, ++argi)\n                 {\n                     Parameter *p = (*tt->arguments)[j];\n@@ -1474,7 +1474,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n              */\n             if (argi == nfargs)\n             {\n-                for (size_t i = 0; i < dedtypes->dim; i++)\n+                for (size_t i = 0; i < dedtypes->length; i++)\n                 {\n                     Type *at = isType((*dedtypes)[i]);\n                     if (at && at->ty == Tnone)\n@@ -1484,7 +1484,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                         delete xt;\n                     }\n                 }\n-                for (size_t i = ntargs; i < dedargs->dim; i++)\n+                for (size_t i = ntargs; i < dedargs->length; i++)\n                 {\n                     TemplateParameter *tparam = (*parameters)[i];\n \n@@ -1583,7 +1583,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 if (argtype->ty == Tarray &&\n                     (prmtype->ty == Tsarray ||\n                      (prmtype->ty == Taarray && (taai = ((TypeAArray *)prmtype)->index)->ty == Tident &&\n-                      ((TypeIdentifier *)taai)->idents.dim == 0)))\n+                      ((TypeIdentifier *)taai)->idents.length == 0)))\n                 {\n                     if (farg->op == TOKstring)\n                     {\n@@ -1593,7 +1593,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                     else if (farg->op == TOKarrayliteral)\n                     {\n                         ArrayLiteralExp *ae = (ArrayLiteralExp *)farg;\n-                        argtype = ae->type->nextOf()->sarrayOf(ae->elements->dim);\n+                        argtype = ae->type->nextOf()->sarrayOf(ae->elements->length);\n                     }\n                     else if (farg->op == TOKslice)\n                     {\n@@ -1608,7 +1608,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             else if ((fparam->storageClass & STCout) == 0 &&\n                      (argtype->ty == Tarray || argtype->ty == Tpointer) &&\n                      templateParameterLookup(prmtype, parameters) != IDX_NOTFOUND &&\n-                     ((TypeIdentifier *)prmtype)->idents.dim == 0)\n+                     ((TypeIdentifier *)prmtype)->idents.length == 0)\n             {\n                 /* The farg passing to the prmtype always make a copy. Therefore,\n                  * we can shrink the set of the deduced type arguments for prmtype\n@@ -1839,7 +1839,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n \n Lmatch:\n \n-    for (size_t i = 0; i < dedtypes->dim; i++)\n+    for (size_t i = 0; i < dedtypes->length; i++)\n     {\n         Type *at = isType((*dedtypes)[i]);\n         if (at)\n@@ -1853,7 +1853,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             (*dedtypes)[i] = at->merge2();\n         }\n     }\n-    for (size_t i = ntargs; i < dedargs->dim; i++)\n+    for (size_t i = ntargs; i < dedargs->length; i++)\n     {\n         TemplateParameter *tparam = (*parameters)[i];\n         //printf(\"tparam[%d] = %s\\n\", i, tparam->ident->toChars());\n@@ -1900,7 +1900,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                     // we're one or more arguments short (i.e. no tuple argument)\n                     if (tparam == tp &&\n                         fptupindex == IDX_NOTFOUND &&\n-                        ntargs <= dedargs->dim - 1)\n+                        ntargs <= dedargs->length - 1)\n                     {\n                         // make tuple argument an empty tuple\n                         oded = (RootObject *)new Tuple();\n@@ -1939,11 +1939,11 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n     /* Bugzilla 7469: As same as the code for 7469 in findBestMatch,\n      * expand a Tuple in dedargs to normalize template arguments.\n      */\n-    if (size_t d = dedargs->dim)\n+    if (size_t d = dedargs->length)\n     {\n         if (Tuple *va = isTuple((*dedargs)[d - 1]))\n         {\n-            if (va->objects.dim)\n+            if (va->objects.length)\n             {\n                 dedargs->setDim(d - 1);\n                 dedargs->insert(d - 1, &va->objects);\n@@ -2093,7 +2093,7 @@ RootObject *TemplateDeclaration::declareParameter(Scope *sc, TemplateParameter *\n \n TemplateTupleParameter *isVariadic(TemplateParameters *parameters)\n {\n-    size_t dim = parameters->dim;\n+    size_t dim = parameters->length;\n     TemplateTupleParameter *tp = NULL;\n \n     if (dim)\n@@ -2167,7 +2167,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n             if (fd == m->lastf)\n                 return 0;\n             // explicitly specified tiargs never match to non template function\n-            if (tiargs && tiargs->dim > 0)\n+            if (tiargs && tiargs->length > 0)\n                 return 0;\n \n             // constructors need a valid scope in order to detect semantic errors\n@@ -2333,7 +2333,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n                     tiargs = new Objects();\n                 TemplateInstance *ti = new TemplateInstance(loc, td, tiargs);\n                 Objects dedtypes;\n-                dedtypes.setDim(td->parameters->dim);\n+                dedtypes.setDim(td->parameters->length);\n                 assert(td->semanticRun != PASSinit);\n                 MATCH mta = td->matchWithInstance(sc, ti, &dedtypes, fargs, 0);\n                 //printf(\"matchWithInstance = %d\\n\", mta);\n@@ -2664,7 +2664,7 @@ FuncDeclaration *TemplateDeclaration::doHeaderInstantiation(\n     {\n         // Match 'tthis' to any TemplateThisParameter's\n         bool hasttp = false;\n-        for (size_t i = 0; i < parameters->dim; i++)\n+        for (size_t i = 0; i < parameters->length; i++)\n         {\n             TemplateParameter *tp = (*parameters)[i];\n             TemplateThisParameter *ttp = tp->isTemplateThisParameter();\n@@ -2681,7 +2681,7 @@ FuncDeclaration *TemplateDeclaration::doHeaderInstantiation(\n     Scope *scx = sc2->push();\n \n     // Shouldn't run semantic on default arguments and return type.\n-    for (size_t i = 0; i < tf->parameters->dim; i++)\n+    for (size_t i = 0; i < tf->parameters->length; i++)\n         (*tf->parameters)[i]->defaultArg = NULL;\n     if (fd->isCtorDeclaration())\n     {\n@@ -2740,7 +2740,7 @@ const char *TemplateDeclaration::toChars()\n \n     buf.writestring(ident->toChars());\n     buf.writeByte('(');\n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         TemplateParameter *tp = (*parameters)[i];\n         if (i)\n@@ -2786,7 +2786,7 @@ TemplateInstance *TemplateDeclaration::findExistingInstance(TemplateInstance *ti\n     TemplateInstances *tinstances = (TemplateInstances *)dmd_aaGetRvalue((AA *)instances, (void *)tithis->toHash());\n     if (tinstances)\n     {\n-        for (size_t i = 0; i < tinstances->dim; i++)\n+        for (size_t i = 0; i < tinstances->length; i++)\n         {\n             TemplateInstance *ti = (*tinstances)[i];\n             if (tithis->compare(ti) == 0)\n@@ -2823,7 +2823,7 @@ void TemplateDeclaration::removeInstance(TemplateInstance *handle)\n     TemplateInstances *tinstances = (TemplateInstances *)dmd_aaGetRvalue((AA *)instances, (void *)handle->toHash());\n     if (tinstances)\n     {\n-        for (size_t i = 0; i < tinstances->dim; i++)\n+        for (size_t i = 0; i < tinstances->length; i++)\n         {\n             TemplateInstance *ti = (*tinstances)[i];\n             if (handle == ti)\n@@ -2844,7 +2844,7 @@ void TemplateDeclaration::removeInstance(TemplateInstance *handle)\n \n static size_t templateIdentifierLookup(Identifier *id, TemplateParameters *parameters)\n {\n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         TemplateParameter *tp = (*parameters)[i];\n         if (tp->ident->equals(id))\n@@ -3189,7 +3189,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     /* Need a loc to go with the semantic routine.\n                      */\n                     Loc loc;\n-                    if (parameters->dim)\n+                    if (parameters->length)\n                     {\n                         TemplateParameter *tp = (*parameters)[0];\n                         loc = tp->loc;\n@@ -3207,11 +3207,11 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 TemplateParameter *tp = (*parameters)[i];\n \n                 TypeIdentifier *tident = (TypeIdentifier *)tparam;\n-                if (tident->idents.dim > 0)\n+                if (tident->idents.length > 0)\n                 {\n                     //printf(\"matching %s to %s\\n\", tparam->toChars(), t->toChars());\n                     Dsymbol *s = t->toDsymbol(sc);\n-                    for (size_t j = tident->idents.dim; j-- > 0; )\n+                    for (size_t j = tident->idents.length; j-- > 0; )\n                     {\n                         RootObject *id = tident->idents[j];\n                         if (id->dyncast() == DYNCAST_IDENTIFIER)\n@@ -3364,7 +3364,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 /* Need a loc to go with the semantic routine.\n                  */\n                 Loc loc;\n-                if (parameters->dim)\n+                if (parameters->length)\n                 {\n                     TemplateParameter *tp = (*parameters)[0];\n                     loc = tp->loc;\n@@ -3570,15 +3570,15 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     if (fparam->type->ty != Tident)\n                         goto L1;\n                     TypeIdentifier *tid = (TypeIdentifier *)fparam->type;\n-                    if (tid->idents.dim)\n+                    if (tid->idents.length)\n                         goto L1;\n \n                     /* Look through parameters to find tuple matching tid->ident\n                      */\n                     size_t tupi = 0;\n                     for (; 1; tupi++)\n                     {\n-                        if (tupi == parameters->dim)\n+                        if (tupi == parameters->length)\n                             goto L1;\n                         TemplateParameter *tx = (*parameters)[tupi];\n                         TemplateTupleParameter *tup = tx->isTemplateTupleParameter();\n@@ -3598,7 +3598,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     {\n                         // Existing deduced argument must be a tuple, and must match\n                         Tuple *tup = isTuple(o);\n-                        if (!tup || tup->objects.dim != tuple_dim)\n+                        if (!tup || tup->objects.length != tuple_dim)\n                         {\n                             result = MATCHnomatch;\n                             return;\n@@ -3659,7 +3659,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             {\n                 TypeIdentifier *tp = (TypeIdentifier *)tparam;\n \n-                for (size_t i = 0; i < t->idents.dim; i++)\n+                for (size_t i = 0; i < t->idents.length; i++)\n                 {\n                     RootObject *id1 = t->idents[i];\n                     RootObject *id2 = tp->idents[i];\n@@ -3748,19 +3748,19 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 {\n                     //printf(\"\\ttest: tempinst->tiargs[%d]\\n\", i);\n                     RootObject *o1 = NULL;\n-                    if (i < t->tempinst->tiargs->dim)\n+                    if (i < t->tempinst->tiargs->length)\n                         o1 = (*t->tempinst->tiargs)[i];\n-                    else if (i < t->tempinst->tdtypes.dim && i < tp->tempinst->tiargs->dim)\n+                    else if (i < t->tempinst->tdtypes.length && i < tp->tempinst->tiargs->length)\n                     {\n                         // Pick up default arg\n                         o1 = t->tempinst->tdtypes[i];\n                     }\n-                    else if (i >= tp->tempinst->tiargs->dim)\n+                    else if (i >= tp->tempinst->tiargs->length)\n                         break;\n \n-                    if (i >= tp->tempinst->tiargs->dim)\n+                    if (i >= tp->tempinst->tiargs->length)\n                     {\n-                        size_t dim = tempdecl->parameters->dim - (tempdecl->isVariadic() ? 1 : 0);\n+                        size_t dim = tempdecl->parameters->length - (tempdecl->isVariadic() ? 1 : 0);\n                         while (i < dim && ((*tempdecl->parameters)[i]->dependent ||\n                                            (*tempdecl->parameters)[i]->hasDefaultArg()))\n                         {\n@@ -3774,9 +3774,9 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     RootObject *o2 = (*tp->tempinst->tiargs)[i];\n                     Type *t2 = isType(o2);\n \n-                    size_t j = (t2 && t2->ty == Tident && i == tp->tempinst->tiargs->dim - 1)\n+                    size_t j = (t2 && t2->ty == Tident && i == tp->tempinst->tiargs->length - 1)\n                         ? templateParameterLookup(t2, parameters) : IDX_NOTFOUND;\n-                    if (j != IDX_NOTFOUND && j == parameters->dim - 1 &&\n+                    if (j != IDX_NOTFOUND && j == parameters->length - 1 &&\n                         (*parameters)[j]->isTemplateTupleParameter())\n                     {\n                         /* Given:\n@@ -3790,12 +3790,12 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                          */\n                         Tuple *vt = new Tuple();\n                         size_t vtdim = (tempdecl->isVariadic()\n-                                        ? t->tempinst->tiargs->dim : t->tempinst->tdtypes.dim) - i;\n+                                        ? t->tempinst->tiargs->length : t->tempinst->tdtypes.length) - i;\n                         vt->objects.setDim(vtdim);\n                         for (size_t k = 0; k < vtdim; k++)\n                         {\n                             RootObject *o;\n-                            if (k < t->tempinst->tiargs->dim)\n+                            if (k < t->tempinst->tiargs->length)\n                                 o = (*t->tempinst->tiargs)[i + k];\n                             else    // Pick up default arg\n                                 o = t->tempinst->tdtypes[i + k];\n@@ -3929,19 +3929,19 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                  *  S!(T).foo\n                  */\n                 TypeInstance *tpi = (TypeInstance *)tparam;\n-                if (tpi->idents.dim)\n+                if (tpi->idents.length)\n                 {\n-                    RootObject *id = tpi->idents[tpi->idents.dim - 1];\n+                    RootObject *id = tpi->idents[tpi->idents.length - 1];\n                     if (id->dyncast() == DYNCAST_IDENTIFIER && t->sym->ident->equals((Identifier *)id))\n                     {\n                         Type *tparent = t->sym->parent->getType();\n                         if (tparent)\n                         {\n                             /* Slice off the .foo in S!(T).foo\n                              */\n-                            tpi->idents.dim--;\n+                            tpi->idents.length--;\n                             result = deduceType(tparent, sc, tpi, parameters, dedtypes, wm);\n-                            tpi->idents.dim++;\n+                            tpi->idents.length++;\n                             return;\n                         }\n                     }\n@@ -4014,17 +4014,17 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             {\n                 // Make a temporary copy of dedtypes so we don't destroy it\n                 Objects *tmpdedtypes = new Objects();\n-                tmpdedtypes->setDim(dedtypes->dim);\n-                memcpy(tmpdedtypes->tdata(), dedtypes->tdata(), dedtypes->dim * sizeof(void *));\n+                tmpdedtypes->setDim(dedtypes->length);\n+                memcpy(tmpdedtypes->tdata(), dedtypes->tdata(), dedtypes->length * sizeof(void *));\n \n                 TypeInstance *t = new TypeInstance(Loc(), parti);\n                 MATCH m = deduceType(t, sc, tparam, parameters, tmpdedtypes);\n                 if (m > MATCHnomatch)\n                 {\n                     // If this is the first ever match, it becomes our best estimate\n                     if (numBaseClassMatches==0)\n-                        memcpy(best->tdata(), tmpdedtypes->tdata(), tmpdedtypes->dim * sizeof(void *));\n-                    else for (size_t k = 0; k < tmpdedtypes->dim; ++k)\n+                        memcpy(best->tdata(), tmpdedtypes->tdata(), tmpdedtypes->length * sizeof(void *));\n+                    else for (size_t k = 0; k < tmpdedtypes->length; ++k)\n                     {\n                         // If we've found more than one possible type for a parameter,\n                         // mark it as unknown.\n@@ -4074,19 +4074,19 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                  *  S!(T).foo\n                  */\n                 TypeInstance *tpi = (TypeInstance *)tparam;\n-                if (tpi->idents.dim)\n+                if (tpi->idents.length)\n                 {\n-                    RootObject *id = tpi->idents[tpi->idents.dim - 1];\n+                    RootObject *id = tpi->idents[tpi->idents.length - 1];\n                     if (id->dyncast() == DYNCAST_IDENTIFIER && t->sym->ident->equals((Identifier *)id))\n                     {\n                         Type *tparent = t->sym->parent->getType();\n                         if (tparent)\n                         {\n                             /* Slice off the .foo in S!(T).foo\n                              */\n-                            tpi->idents.dim--;\n+                            tpi->idents.length--;\n                             result = deduceType(tparent, sc, tpi, parameters, dedtypes, wm);\n-                            tpi->idents.dim++;\n+                            tpi->idents.length++;\n                             return;\n                         }\n                     }\n@@ -4106,10 +4106,10 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n \n                 // Our best guess at dedtypes\n                 Objects *best = new Objects();\n-                best->setDim(dedtypes->dim);\n+                best->setDim(dedtypes->length);\n \n                 ClassDeclaration *s = t->sym;\n-                while (s && s->baseclasses->dim > 0)\n+                while (s && s->baseclasses->length > 0)\n                 {\n                     // Test the base class\n                     deduceBaseClassParameters((*s->baseclasses)[0],\n@@ -4133,7 +4133,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 }\n \n                 // If we got at least one match, copy the known types into dedtypes\n-                memcpy(dedtypes->tdata(), best->tdata(), best->dim * sizeof(void *));\n+                memcpy(dedtypes->tdata(), best->tdata(), best->length * sizeof(void *));\n                 result = MATCHconvert;\n                 return;\n             }\n@@ -4159,7 +4159,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n         {\n             //printf(\"Expression::deduceType(e = %s)\\n\", e->toChars());\n             size_t i = templateParameterLookup(tparam, parameters);\n-            if (i == IDX_NOTFOUND || ((TypeIdentifier *)tparam)->idents.dim > 0)\n+            if (i == IDX_NOTFOUND || ((TypeIdentifier *)tparam)->idents.length > 0)\n             {\n                 if (e == emptyArrayElement && tparam->ty == Tarray)\n                 {\n@@ -4326,7 +4326,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             if (e->type->ty == Tarray &&\n                 (tparam->ty == Tsarray ||\n                  (tparam->ty == Taarray && (taai = ((TypeAArray *)tparam)->index)->ty == Tident &&\n-                  ((TypeIdentifier *)taai)->idents.dim == 0)))\n+                  ((TypeIdentifier *)taai)->idents.length == 0)))\n             {\n                 // Consider compile-time known boundaries\n                 e->type->nextOf()->sarrayOf(e->len)->accept(this);\n@@ -4337,7 +4337,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n \n         void visit(ArrayLiteralExp *e)\n         {\n-            if ((!e->elements || !e->elements->dim) &&\n+            if ((!e->elements || !e->elements->length) &&\n                 e->type->toBasetype()->nextOf()->ty == Tvoid &&\n                 tparam->ty == Tarray)\n             {\n@@ -4346,7 +4346,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 return;\n             }\n \n-            if (tparam->ty == Tarray && e->elements && e->elements->dim)\n+            if (tparam->ty == Tarray && e->elements && e->elements->length)\n             {\n                 Type *tn = ((TypeDArray *)tparam)->next;\n                 result = MATCHexact;\n@@ -4356,7 +4356,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     if (m < result)\n                         result = m;\n                 }\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     if (result <= MATCHnomatch)\n                         break;\n@@ -4374,22 +4374,22 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             if (e->type->ty == Tarray &&\n                 (tparam->ty == Tsarray ||\n                  (tparam->ty == Taarray && (taai = ((TypeAArray *)tparam)->index)->ty == Tident &&\n-                  ((TypeIdentifier *)taai)->idents.dim == 0)))\n+                  ((TypeIdentifier *)taai)->idents.length == 0)))\n             {\n                 // Consider compile-time known boundaries\n-                e->type->nextOf()->sarrayOf(e->elements->dim)->accept(this);\n+                e->type->nextOf()->sarrayOf(e->elements->length)->accept(this);\n                 return;\n             }\n             visit((Expression *)e);\n         }\n \n         void visit(AssocArrayLiteralExp *e)\n         {\n-            if (tparam->ty == Taarray && e->keys && e->keys->dim)\n+            if (tparam->ty == Taarray && e->keys && e->keys->length)\n             {\n                 TypeAArray *taa = (TypeAArray *)tparam;\n                 result = MATCHexact;\n-                for (size_t i = 0; i < e->keys->dim; i++)\n+                for (size_t i = 0; i < e->keys->length; i++)\n                 {\n                     MATCH m1 = deduceType((*e->keys)[i], sc, taa->index, parameters, dedtypes, wm);\n                     if (m1 < result)\n@@ -4429,9 +4429,9 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     return;\n \n                 Objects *tiargs = new Objects();\n-                tiargs->reserve(e->td->parameters->dim);\n+                tiargs->reserve(e->td->parameters->length);\n \n-                for (size_t i = 0; i < e->td->parameters->dim; i++)\n+                for (size_t i = 0; i < e->td->parameters->length; i++)\n                 {\n                     TemplateParameter *tp = (*e->td->parameters)[i];\n                     size_t u = 0;\n@@ -4498,7 +4498,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             if (e->type->ty == Tarray &&\n                 (tparam->ty == Tsarray ||\n                  (tparam->ty == Taarray && (taai = ((TypeAArray *)tparam)->index)->ty == Tident &&\n-                  ((TypeIdentifier *)taai)->idents.dim == 0)))\n+                  ((TypeIdentifier *)taai)->idents.length == 0)))\n             {\n                 // Consider compile-time known boundaries\n                 if (Type *tsa = toStaticArrayType(e))\n@@ -4597,7 +4597,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n                 return;\n             }\n \n-            for (size_t i = iStart; i < tparams->dim; i++)\n+            for (size_t i = iStart; i < tparams->length; i++)\n             {\n                 TemplateParameter *tp = (*tparams)[i];\n                 if (tp->ident->equals(t->ident))\n@@ -4613,7 +4613,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             if (!tparams)\n                 return;\n \n-            for (size_t i = iStart; i < tparams->dim; i++)\n+            for (size_t i = iStart; i < tparams->length; i++)\n             {\n                 TemplateParameter *tp = (*tparams)[i];\n                 if (t->tempinst->name == tp->ident)\n@@ -4624,7 +4624,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             }\n             if (!t->tempinst->tiargs)\n                 return;\n-            for (size_t i = 0; i < t->tempinst->tiargs->dim; i++)\n+            for (size_t i = 0; i < t->tempinst->tiargs->length; i++)\n             {\n                 Type *ta = isType((*t->tempinst->tiargs)[i]);\n                 if (ta)\n@@ -4646,7 +4646,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n         {\n             if (t->arguments)\n             {\n-                for (size_t i = 0; i < t->arguments->dim; i++)\n+                for (size_t i = 0; i < t->arguments->length; i++)\n                 {\n                     Parameter *arg = (*t->arguments)[i];\n                     arg->type->accept(this);\n@@ -4664,7 +4664,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n         void visit(IdentifierExp *e)\n         {\n             //printf(\"IdentifierExp::reliesOnTident('%s')\\n\", e->toChars());\n-            for (size_t i = iStart; i < tparams->dim; i++)\n+            for (size_t i = iStart; i < tparams->length; i++)\n             {\n                 TemplateParameter *tp = (*tparams)[i];\n                 if (e->ident == tp->ident)\n@@ -4680,7 +4680,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             //printf(\"TupleExp::reliesOnTident('%s')\\n\", e->toChars());\n             if (e->exps)\n             {\n-                for (size_t i = 0; i < e->exps->dim; i++)\n+                for (size_t i = 0; i < e->exps->length; i++)\n                 {\n                     Expression *ea = (*e->exps)[i];\n                     ea->accept(this);\n@@ -4695,7 +4695,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             //printf(\"ArrayLiteralExp::reliesOnTident('%s')\\n\", e->toChars());\n             if (e->elements)\n             {\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     Expression *el = (*e->elements)[i];\n                     el->accept(this);\n@@ -4708,14 +4708,14 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n         void visit(AssocArrayLiteralExp *e)\n         {\n             //printf(\"AssocArrayLiteralExp::reliesOnTident('%s')\\n\", e->toChars());\n-            for (size_t i = 0; i < e->keys->dim; i++)\n+            for (size_t i = 0; i < e->keys->length; i++)\n             {\n                 Expression *ek = (*e->keys)[i];\n                 ek->accept(this);\n                 if (result)\n                     return;\n             }\n-            for (size_t i = 0; i < e->values->dim; i++)\n+            for (size_t i = 0; i < e->values->length; i++)\n             {\n                 Expression *ev = (*e->values)[i];\n                 ev->accept(this);\n@@ -4729,7 +4729,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             //printf(\"StructLiteralExp::reliesOnTident('%s')\\n\", e->toChars());\n             if (e->elements)\n             {\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     Expression *ea = (*e->elements)[i];\n                     ea->accept(this);\n@@ -4752,7 +4752,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n                 e->thisexp->accept(this);\n             if (!result && e->newargs)\n             {\n-                for (size_t i = 0; i < e->newargs->dim; i++)\n+                for (size_t i = 0; i < e->newargs->length; i++)\n                 {\n                     Expression *ea = (*e->newargs)[i];\n                     ea->accept(this);\n@@ -4763,7 +4763,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             e->newtype->accept(this);\n             if (!result && e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     Expression *ea = (*e->arguments)[i];\n                     ea->accept(this);\n@@ -4799,7 +4799,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             //printf(\"TraitsExp::reliesOnTident('%s')\\n\", e->toChars());\n             if (e->args)\n             {\n-                for (size_t i = 0; i < e->args->dim; i++)\n+                for (size_t i = 0; i < e->args->length; i++)\n                 {\n                     RootObject *oa = (*e->args)[i];\n                     if (Expression *ea = isExpression(oa))\n@@ -4830,7 +4830,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             visit((UnaExp *)e);\n             if (!result && e->ti->tiargs)\n             {\n-                for (size_t i = 0; i < e->ti->tiargs->dim; i++)\n+                for (size_t i = 0; i < e->ti->tiargs->length; i++)\n                 {\n                     RootObject *oa = (*e->ti->tiargs)[i];\n                     if (Expression *ea = isExpression(oa))\n@@ -4849,7 +4849,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             visit((UnaExp *)e);\n             if (!result && e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     Expression *ea = (*e->arguments)[i];\n                     ea->accept(this);\n@@ -4892,7 +4892,7 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n             visit((UnaExp *)e);\n             if (!result && e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     Expression *ea = (*e->arguments)[i];\n                     ea->accept(this);\n@@ -4975,15 +4975,15 @@ MATCH TemplateParameter::matchArg(Loc instLoc, Scope *sc, Objects *tiargs,\n {\n     RootObject *oarg;\n \n-    if (i < tiargs->dim)\n+    if (i < tiargs->length)\n         oarg = (*tiargs)[i];\n     else\n     {\n         // Get default argument instead\n         oarg = defaultArg(instLoc, sc);\n         if (!oarg)\n         {\n-            assert(i < dedtypes->dim);\n+            assert(i < dedtypes->length);\n             // It might have already been deduced\n             oarg = (*dedtypes)[i];\n             if (!oarg)\n@@ -5706,25 +5706,25 @@ MATCH TemplateTupleParameter::matchArg(Loc, Scope *sc, Objects *tiargs,\n     /* The rest of the actual arguments (tiargs[]) form the match\n      * for the variadic parameter.\n      */\n-    assert(i + 1 == dedtypes->dim);     // must be the last one\n+    assert(i + 1 == dedtypes->length);     // must be the last one\n     Tuple *ovar;\n \n     if (Tuple *u = isTuple((*dedtypes)[i]))\n     {\n         // It has already been deduced\n         ovar = u;\n     }\n-    else if (i + 1 == tiargs->dim && isTuple((*tiargs)[i]))\n+    else if (i + 1 == tiargs->length && isTuple((*tiargs)[i]))\n         ovar = isTuple((*tiargs)[i]);\n     else\n     {\n         ovar = new Tuple();\n         //printf(\"ovar = %p\\n\", ovar);\n-        if (i < tiargs->dim)\n+        if (i < tiargs->length)\n         {\n-            //printf(\"i = %d, tiargs->dim = %d\\n\", i, tiargs->dim);\n-            ovar->objects.setDim(tiargs->dim - i);\n-            for (size_t j = 0; j < ovar->objects.dim; j++)\n+            //printf(\"i = %d, tiargs->length = %d\\n\", i, tiargs->length);\n+            ovar->objects.setDim(tiargs->length - i);\n+            for (size_t j = 0; j < ovar->objects.length; j++)\n                 ovar->objects[j] = (*tiargs)[i + j];\n         }\n     }\n@@ -5760,8 +5760,8 @@ void TemplateTupleParameter::print(RootObject *, RootObject *oded)\n     Tuple *v = isTuple(oded);\n     assert(v);\n \n-    //printf(\"|%d| \", v->objects.dim);\n-    for (size_t i = 0; i < v->objects.dim; i++)\n+    //printf(\"|%d| \", v->objects.length);\n+    for (size_t i = 0; i < v->objects.length; i++)\n     {\n         if (i)\n             printf(\", \");\n@@ -5873,8 +5873,8 @@ Objects *TemplateInstance::arraySyntaxCopy(Objects *objs)\n     if (objs)\n     {\n         a = new Objects();\n-        a->setDim(objs->dim);\n-        for (size_t i = 0; i < objs->dim; i++)\n+        a->setDim(objs->length);\n+        for (size_t i = 0; i < objs->length; i++)\n             (*a)[i] = objectSyntaxCopy((*objs)[i]);\n     }\n     return a;\n@@ -5901,19 +5901,19 @@ void TemplateInstance::semantic(Scope *sc)\n \n void TemplateInstance::expandMembers(Scope *sc2)\n {\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->setScope(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         //printf(\"\\t[%d] semantic on '%s' %p kind %s in '%s'\\n\", i, s->toChars(), s, s->kind(), this->toChars());\n@@ -6124,13 +6124,13 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n     // Store the place we added it to in target_symbol_list(_idx) so we can\n     // remove it later if we encounter an error.\n     Dsymbols *target_symbol_list = appendToModuleMember();\n-    size_t target_symbol_list_idx = target_symbol_list ? target_symbol_list->dim - 1 : 0;\n+    size_t target_symbol_list_idx = target_symbol_list ? target_symbol_list->length - 1 : 0;\n \n     // Copy the syntax trees from the TemplateDeclaration\n     members = Dsymbol::arraySyntaxCopy(tempdecl->members);\n \n     // resolve TemplateThisParameter\n-    for (size_t i = 0; i < tempdecl->parameters->dim; i++)\n+    for (size_t i = 0; i < tempdecl->parameters->length; i++)\n     {\n         if ((*tempdecl->parameters)[i]->isTemplateThisParameter() == NULL)\n             continue;\n@@ -6171,7 +6171,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n     // Add members of template instance to template instance symbol table\n //    parent = scope->scopesym;\n     symtab = new DsymbolTable();\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->addMember(scope, this);\n@@ -6181,8 +6181,8 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n      * member has the same name as the template instance.\n      * If so, this template instance becomes an alias for that member.\n      */\n-    //printf(\"members->dim = %d\\n\", members->dim);\n-    if (members->dim)\n+    //printf(\"members->length = %d\\n\", members->length);\n+    if (members->length)\n     {\n         Dsymbol *s;\n         if (Dsymbol::oneMembers(members, &s, tempdecl->ident) && s)\n@@ -6224,7 +6224,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n     /* ConditionalDeclaration may introduce eponymous declaration,\n      * so we should find it once again after semantic.\n      */\n-    if (members->dim)\n+    if (members->length)\n     {\n         Dsymbol *s;\n         if (Dsymbol::oneMembers(members, &s, tempdecl->ident) && s)\n@@ -6247,7 +6247,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n      */\n     {\n     bool found_deferred_ad = false;\n-    for (size_t i = 0; i < Module::deferred.dim; i++)\n+    for (size_t i = 0; i < Module::deferred.length; i++)\n     {\n         Dsymbol *sd = Module::deferred[i];\n         AggregateDeclaration *ad = sd->isAggregateDeclaration();\n@@ -6263,7 +6263,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n             }\n         }\n     }\n-    if (found_deferred_ad || Module::deferred.dim)\n+    if (found_deferred_ad || Module::deferred.length)\n         goto Laftersemantic;\n     }\n \n@@ -6295,7 +6295,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n         //printf(\"Run semantic3 on %s\\n\", toChars());\n         trySemantic3(sc2);\n \n-        for (size_t i = 0; i < deferred.dim; i++)\n+        for (size_t i = 0; i < deferred.length; i++)\n         {\n             //printf(\"+ run deferred semantic3 on %s\\n\", deferred[i]->toChars());\n             deferred[i]->semantic3(NULL);\n@@ -6320,7 +6320,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n              * all instantiated functions should run the semantic3 immediately.\n              * See also compilable/test14973.d\n              */\n-            for (size_t i = 0; i < tdtypes.dim; i++)\n+            for (size_t i = 0; i < tdtypes.length; i++)\n             {\n                 RootObject *oarg = tdtypes[i];\n                 Dsymbol *s = getDsymbol(oarg);\n@@ -6331,7 +6331,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n                 {\n                     if (!td->literal)\n                         continue;\n-                    assert(td->members && td->members->dim == 1);\n+                    assert(td->members && td->members->length == 1);\n                     s = (*td->members)[0];\n                 }\n                 if (FuncLiteralDeclaration *fld = s->isFuncLiteralDeclaration())\n@@ -6365,7 +6365,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n             //printf(\"deferred semantic3 of %p %s, ti = %s, ti->deferred = %p\\n\", this, toChars(), ti->toChars());\n             for (size_t i = 0; ; i++)\n             {\n-                if (i == ti->deferred->dim)\n+                if (i == ti->deferred->length)\n                 {\n                     ti->deferred->push(this);\n                     break;\n@@ -6436,7 +6436,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n         //printf(\"replaceInstance()\\n\");\n         TemplateInstances *tinstances = (TemplateInstances *)dmd_aaGetRvalue((AA *)tempdecl->instances, (void *)hash);\n         assert(tinstances);\n-        for (size_t i = 0; i < tinstances->dim; i++)\n+        for (size_t i = 0; i < tinstances->length; i++)\n         {\n             TemplateInstance *ti = (*tinstances)[i];\n             if (ti == errinst)\n@@ -6547,7 +6547,7 @@ bool TemplateInstance::findTempDecl(Scope *sc, WithScopeSymbol **pwithsym)\n   };\n     // Look for forward references\n     OverloadSet *tovers = tempdecl->isOverloadSet();\n-    size_t overs_dim = tovers ? tovers->a.dim : 1;\n+    size_t overs_dim = tovers ? tovers->a.length : 1;\n     for (size_t oi = 0; oi < overs_dim; oi++)\n     {\n         if (overloadApply(tovers ? tovers->a[oi] : tempdecl, (void *)this, &ParamFwdTi::fp))\n@@ -6581,7 +6581,7 @@ bool TemplateInstance::updateTempDecl(Scope *sc, Dsymbol *s)\n         if (os)\n         {\n             s = NULL;\n-            for (size_t i = 0; i < os->a.dim; i++)\n+            for (size_t i = 0; i < os->a.length; i++)\n             {\n                 Dsymbol *s2 = os->a[i];\n                 if (FuncDeclaration *f = s2->isFuncDeclaration())\n@@ -6704,7 +6704,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n     if (!tiargs)\n         return true;\n     bool err = false;\n-    for (size_t j = 0; j < tiargs->dim; j++)\n+    for (size_t j = 0; j < tiargs->length; j++)\n     {\n         RootObject *o = (*tiargs)[j];\n         Type *ta = isType(o);\n@@ -6730,7 +6730,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n             {\n                 // Expand tuple\n                 TypeTuple *tt = (TypeTuple *)ta;\n-                size_t dim = tt->arguments->dim;\n+                size_t dim = tt->arguments->length;\n                 tiargs->remove(j);\n                 if (dim)\n                 {\n@@ -6798,7 +6798,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n             {\n                 // Expand tuple\n                 TupleExp *te = (TupleExp *)ea;\n-                size_t dim = te->exps->dim;\n+                size_t dim = te->exps->length;\n                 tiargs->remove(j);\n                 if (dim)\n                 {\n@@ -6925,7 +6925,7 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n         assert(tempdecl);\n         assert(tempdecl->_scope);\n         // Deduce tdtypes\n-        tdtypes.setDim(tempdecl->parameters->dim);\n+        tdtypes.setDim(tempdecl->parameters->length);\n         if (!tempdecl->matchWithInstance(sc, this, &tdtypes, fargs, 2))\n         {\n             error(\"incompatible arguments for template instantiation\");\n@@ -6965,13 +6965,13 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n \n         // If more arguments than parameters,\n         // then this is no match.\n-        if (td->parameters->dim < ti->tiargs->dim)\n+        if (td->parameters->length < ti->tiargs->length)\n         {\n             if (!td->isVariadic())\n                 return 0;\n         }\n \n-        dedtypes.setDim(td->parameters->dim);\n+        dedtypes.setDim(td->parameters->length);\n         dedtypes.zero();\n         assert(td->semanticRun != PASSinit);\n         MATCH m = td->matchWithInstance(sc, ti, &dedtypes, ti->fargs, 0);\n@@ -7002,8 +7002,8 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n         td_ambig = NULL;\n         td_best = td;\n         m_best = m;\n-        ti->tdtypes.setDim(dedtypes.dim);\n-        memcpy(ti->tdtypes.tdata(), dedtypes.tdata(), ti->tdtypes.dim * sizeof(void *));\n+        ti->tdtypes.setDim(dedtypes.length);\n+        memcpy(ti->tdtypes.tdata(), dedtypes.tdata(), ti->tdtypes.length * sizeof(void *));\n         return 0;\n     }\n   };\n@@ -7018,7 +7018,7 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n     TemplateDeclaration *td_last = NULL;\n \n     OverloadSet *tovers = tempdecl->isOverloadSet();\n-    size_t overs_dim = tovers ? tovers->a.dim : 1;\n+    size_t overs_dim = tovers ? tovers->a.length : 1;\n     for (size_t oi = 0; oi < overs_dim; oi++)\n     {\n         // result\n@@ -7061,12 +7061,12 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n          *    S!num s;             // S!1 is instantiated, not S!num\n          *  }\n          */\n-        size_t dim = td_last->parameters->dim - (td_last->isVariadic() ? 1 : 0);\n+        size_t dim = td_last->parameters->length - (td_last->isVariadic() ? 1 : 0);\n         for (size_t i = 0; i < dim; i++)\n         {\n-            if (tiargs->dim <= i)\n+            if (tiargs->length <= i)\n                 tiargs->push(tdtypes[i]);\n-            assert(i < tiargs->dim);\n+            assert(i < tiargs->length);\n \n             TemplateValueParameter *tvp = (*td_last->parameters)[i]->isTemplateValueParameter();\n             if (!tvp)\n@@ -7076,11 +7076,11 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n \n             (*tiargs)[i] = tdtypes[i];\n         }\n-        if (td_last->isVariadic() && tiargs->dim == dim && tdtypes[dim])\n+        if (td_last->isVariadic() && tiargs->length == dim && tdtypes[dim])\n         {\n             Tuple *va = isTuple(tdtypes[dim]);\n             assert(va);\n-            for (size_t i = 0; i < va->objects.dim; i++)\n+            for (size_t i = 0; i < va->objects.length; i++)\n                 tiargs->push(va->objects[i]);\n         }\n     }\n@@ -7161,7 +7161,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n         {\n             if (!td2->onemember || !td2->onemember->isFuncDeclaration())\n                 return 0;\n-            if (ti->tiargs->dim >= td->parameters->dim - (td->isVariadic() ? 1 : 0))\n+            if (ti->tiargs->length >= td->parameters->length - (td->isVariadic() ? 1 : 0))\n                 return 0;\n             return 1;\n         }\n@@ -7171,7 +7171,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n             return 0;\n         }\n \n-        for (size_t i = 0; i < td->parameters->dim; i++)\n+        for (size_t i = 0; i < td->parameters->length; i++)\n         {\n             if ((*td->parameters)[i]->isTemplateThisParameter())\n                 return 1;\n@@ -7180,18 +7180,18 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n         /* Determine if the instance arguments, tiargs, are all that is necessary\n          * to instantiate the template.\n          */\n-        //printf(\"tp = %p, td->parameters->dim = %d, tiargs->dim = %d\\n\", tp, td->parameters->dim, ti->tiargs->dim);\n+        //printf(\"tp = %p, td->parameters->length = %d, tiargs->length = %d\\n\", tp, td->parameters->length, ti->tiargs->length);\n         TypeFunction *tf = (TypeFunction *)fd->type;\n         if (size_t dim = Parameter::dim(tf->parameters))\n         {\n             TemplateParameter *tp = td->isVariadic();\n-            if (tp && td->parameters->dim > 1)\n+            if (tp && td->parameters->length > 1)\n                 return 1;\n \n-            if (!tp && ti->tiargs->dim < td->parameters->dim)\n+            if (!tp && ti->tiargs->length < td->parameters->length)\n             {\n                 // Can remain tiargs be filled by default arguments?\n-                for (size_t i = ti->tiargs->dim; i < td->parameters->dim; i++)\n+                for (size_t i = ti->tiargs->length; i < td->parameters->length; i++)\n                 {\n                     if (!(*td->parameters)[i]->hasDefaultArg())\n                         return 1;\n@@ -7211,7 +7211,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n             /* Calculate the need for overload resolution.\n              * When only one template can match with tiargs, inference is not necessary.\n              */\n-            dedtypes.setDim(td->parameters->dim);\n+            dedtypes.setDim(td->parameters->length);\n             dedtypes.zero();\n             if (td->semanticRun == PASSinit)\n             {\n@@ -7251,7 +7251,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n     p.count = 0;\n \n     OverloadSet *tovers = tempdecl->isOverloadSet();\n-    size_t overs_dim = tovers ? tovers->a.dim : 1;\n+    size_t overs_dim = tovers ? tovers->a.length : 1;\n     unsigned olderrs = global.errors;\n     for (size_t oi = 0; oi < overs_dim; oi++)\n     {\n@@ -7287,7 +7287,7 @@ bool TemplateInstance::hasNestedArgs(Objects *args, bool isstatic)\n     /* A nested instance happens when an argument references a local\n      * symbol that is on the stack.\n      */\n-    for (size_t i = 0; i < args->dim; i++)\n+    for (size_t i = 0; i < args->length; i++)\n     {\n         RootObject *o = (*args)[i];\n         Expression *ea = isExpression(o);\n@@ -7492,8 +7492,8 @@ Identifier *TemplateInstance::genIdent(Objects *args)\n     }\n     else\n         buf.printf(\"__T%llu%s\", (ulonglong)strlen(id), id);\n-    size_t nparams = tempdecl->parameters->dim - (tempdecl->isVariadic() ? 1 : 0);\n-    for (size_t i = 0; i < args->dim; i++)\n+    size_t nparams = tempdecl->parameters->length - (tempdecl->isVariadic() ? 1 : 0);\n+    for (size_t i = 0; i < args->length; i++)\n     {\n         RootObject *o = (*args)[i];\n         Type *ta = isType(o);\n@@ -7584,7 +7584,7 @@ Identifier *TemplateInstance::genIdent(Objects *args)\n         }\n         else if (va)\n         {\n-            assert(i + 1 == args->dim);         // must be last one\n+            assert(i + 1 == args->length);         // must be last one\n             args = &va->objects;\n             i = -(size_t)1;\n         }\n@@ -7620,7 +7620,7 @@ void TemplateInstance::declareParameters(Scope *sc)\n     assert(tempdecl);\n \n     //printf(\"TemplateInstance::declareParameters()\\n\");\n-    for (size_t i = 0; i < tdtypes.dim; i++)\n+    for (size_t i = 0; i < tdtypes.length; i++)\n     {\n         TemplateParameter *tp = (*tempdecl->parameters)[i];\n         //RootObject *o = (*tiargs)[i];\n@@ -7654,7 +7654,7 @@ void TemplateInstance::semantic2(Scope *sc)\n         if (needGagging)\n             oldGaggedErrors = global.startGagging();\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic2(sc);\n@@ -7709,7 +7709,7 @@ void TemplateInstance::semantic3(Scope *sc)\n         if (needGagging)\n             oldGaggedErrors = global.startGagging();\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic3(sc);\n@@ -7884,7 +7884,7 @@ int TemplateInstance::compare(RootObject *o)\n     TemplateInstance *ti = (TemplateInstance *)o;\n \n     //printf(\"this = %p, ti = %p\\n\", this, ti);\n-    assert(tdtypes.dim == ti->tdtypes.dim);\n+    assert(tdtypes.length == ti->tdtypes.length);\n \n     // Nesting must match\n     if (enclosing != ti->enclosing)\n@@ -7913,7 +7913,7 @@ int TemplateInstance::compare(RootObject *o)\n                 {\n                     if (!fargs)\n                         goto Lnotequals;\n-                    if (fargs->dim <= j)\n+                    if (fargs->length <= j)\n                         break;\n                     Expression *farg = (*fargs)[j];\n                     if (farg->isLvalue())\n@@ -7961,7 +7961,7 @@ void unSpeculative(Scope *sc, RootObject *o)\n \n     if (Tuple *tup = isTuple(o))\n     {\n-        for (size_t i = 0; i < tup->objects.dim; i++)\n+        for (size_t i = 0; i < tup->objects.length; i++)\n         {\n             unSpeculative(sc, tup->objects[i]);\n         }\n@@ -8179,7 +8179,7 @@ bool TemplateInstance::needsCodegen()\n /* ======================== TemplateMixin ================================ */\n \n TemplateMixin::TemplateMixin(Loc loc, Identifier *ident, TypeQualified *tqual, Objects *tiargs)\n-        : TemplateInstance(loc, tqual->idents.dim ? (Identifier *)tqual->idents[tqual->idents.dim - 1]\n+        : TemplateInstance(loc, tqual->idents.length ? (Identifier *)tqual->idents[tqual->idents.length - 1]\n                                                   : ((TypeIdentifier *)tqual)->ident)\n {\n     //printf(\"TemplateMixin(ident = '%s')\\n\", ident ? ident->toChars() : \"\");\n@@ -8218,7 +8218,7 @@ bool TemplateMixin::findTempDecl(Scope *sc)\n         if (os)\n         {\n             Dsymbol *ds = NULL;\n-            for (size_t i = 0; i < os->a.dim; i++)\n+            for (size_t i = 0; i < os->a.length; i++)\n             {\n                 Dsymbol *s2 = os->a[i]->isTemplateDeclaration();\n                 if (s2)\n@@ -8264,7 +8264,7 @@ bool TemplateMixin::findTempDecl(Scope *sc)\n   };\n     // Look for forward references\n     OverloadSet *tovers = tempdecl->isOverloadSet();\n-    size_t overs_dim = tovers ? tovers->a.dim : 1;\n+    size_t overs_dim = tovers ? tovers->a.length : 1;\n     for (size_t oi = 0; oi < overs_dim; oi++)\n     {\n         if (overloadApply(tovers ? tovers->a[oi] : tempdecl, (void *)this, &ParamFwdResTm::fp))\n@@ -8356,10 +8356,10 @@ void TemplateMixin::semantic(Scope *sc)\n \n         /* Different argument list lengths happen with variadic args\n          */\n-        if (tiargs->dim != tm->tiargs->dim)\n+        if (tiargs->length != tm->tiargs->length)\n             continue;\n \n-        for (size_t i = 0; i < tiargs->dim; i++)\n+        for (size_t i = 0; i < tiargs->length; i++)\n         {\n             RootObject *o = (*tiargs)[i];\n             Type *ta = isType(o);\n@@ -8426,7 +8426,7 @@ void TemplateMixin::semantic(Scope *sc)\n     declareParameters(argscope);\n \n     // Add members to enclosing scope, as well as this scope\n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->addMember(argscope, this);\n@@ -8436,7 +8436,7 @@ void TemplateMixin::semantic(Scope *sc)\n \n     // Do semantic() analysis on template instance members\n     Scope *sc2 = argscope->push(this);\n-    //size_t deferred_dim = Module::deferred.dim;\n+    //size_t deferred_dim = Module::deferred.length;\n \n     static int nest;\n     //printf(\"%d\\n\", nest);\n@@ -8447,19 +8447,19 @@ void TemplateMixin::semantic(Scope *sc)\n         fatal();\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->setScope(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->importAll(sc2);\n     }\n \n-    for (size_t i = 0; i < members->dim; i++)\n+    for (size_t i = 0; i < members->length; i++)\n     {\n         Dsymbol *s = (*members)[i];\n         s->semantic(sc2);\n@@ -8471,7 +8471,7 @@ void TemplateMixin::semantic(Scope *sc)\n      * Because the members would already call Module::addDeferredSemantic() for themselves.\n      * See Struct, Class, Interface, and EnumDeclaration::semantic().\n      */\n-    //if (!sc->func && Module::deferred.dim > deferred_dim) {}\n+    //if (!sc->func && Module::deferred.length > deferred_dim) {}\n \n     AggregateDeclaration *ad = toParent()->isAggregateDeclaration();\n     if (sc->func && !ad)\n@@ -8502,7 +8502,7 @@ void TemplateMixin::semantic2(Scope *sc)\n         assert(sc);\n         sc = sc->push(argsym);\n         sc = sc->push(this);\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic2(sc);\n@@ -8521,7 +8521,7 @@ void TemplateMixin::semantic3(Scope *sc)\n     {\n         sc = sc->push(argsym);\n         sc = sc->push(this);\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic3(sc);\n@@ -8547,7 +8547,7 @@ int TemplateMixin::apply(Dsymbol_apply_ft_t fp, void *param)\n         semantic(NULL); // try to resolve it\n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             if (s)\n@@ -8566,7 +8566,7 @@ bool TemplateMixin::hasPointers()\n \n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\" s = %s %s\\n\", s->kind(), s->toChars());\n@@ -8586,7 +8586,7 @@ void TemplateMixin::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset,\n         semantic(NULL);         // try to resolve it\n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\"\\t%s\\n\", s->toChars());"}, {"sha": "df43a7f84bb7ff97b2212e731bb85e60c9548711", "filename": "gcc/d/dmd/escape.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -74,12 +74,12 @@ bool checkParamArgumentEscape(Scope *sc, FuncDeclaration *fdc, Identifier *par,\n \n     escapeByValue(arg, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byfunc.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byfunc.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n \n-    for (size_t i = 0; i < er.byvalue.dim; i++)\n+    for (size_t i = 0; i < er.byvalue.length; i++)\n     {\n         //printf(\"byvalue %s\\n\", v->toChars());\n         VarDeclaration *v = er.byvalue[i];\n@@ -111,7 +111,7 @@ bool checkParamArgumentEscape(Scope *sc, FuncDeclaration *fdc, Identifier *par,\n         }\n     }\n \n-    for (size_t i = 0; i < er.byref.dim; i++)\n+    for (size_t i = 0; i < er.byref.length; i++)\n     {\n         VarDeclaration *v = er.byref[i];\n         if (v->isDataseg())\n@@ -128,14 +128,14 @@ bool checkParamArgumentEscape(Scope *sc, FuncDeclaration *fdc, Identifier *par,\n         }\n     }\n \n-    for (size_t i = 0; i < er.byfunc.dim; i++)\n+    for (size_t i = 0; i < er.byfunc.length; i++)\n     {\n         FuncDeclaration *fd = er.byfunc[i];\n         //printf(\"fd = %s, %d\\n\", fd->toChars(), fd->tookAddressOf);\n         VarDeclarations vars;\n         findAllOuterAccessedVariables(fd, &vars);\n \n-        for (size_t j = 0; j < vars.dim; j++)\n+        for (size_t j = 0; j < vars.length; j++)\n         {\n             VarDeclaration *v = vars[j];\n             //printf(\"v = %s\\n\", v->toChars());\n@@ -153,7 +153,7 @@ bool checkParamArgumentEscape(Scope *sc, FuncDeclaration *fdc, Identifier *par,\n         }\n     }\n \n-    for (size_t i = 0; i < er.byexp.dim; i++)\n+    for (size_t i = 0; i < er.byexp.length; i++)\n     {\n         Expression *ee = er.byexp[i];\n         if (sc->func->setUnsafe())\n@@ -202,7 +202,7 @@ bool checkAssignEscape(Scope *sc, Expression *e, bool gag)\n \n     escapeByValue(e2, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byfunc.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byfunc.length && !er.byexp.length)\n         return false;\n \n     VarDeclaration *va = NULL;\n@@ -226,7 +226,7 @@ bool checkAssignEscape(Scope *sc, Expression *e, bool gag)\n         inferScope = ((TypeFunction *)sc->func->type)->trust != TRUSTsystem;\n \n     bool result = false;\n-    for (size_t i = 0; i < er.byvalue.dim; i++)\n+    for (size_t i = 0; i < er.byvalue.length; i++)\n     {\n         VarDeclaration *v = er.byvalue[i];\n         //printf(\"byvalue: %s\\n\", v->toChars());\n@@ -309,7 +309,7 @@ bool checkAssignEscape(Scope *sc, Expression *e, bool gag)\n         }\n     }\n \n-    for (size_t i = 0; i < er.byref.dim; i++)\n+    for (size_t i = 0; i < er.byref.length; i++)\n     {\n         VarDeclaration *v = er.byref[i];\n         //printf(\"byref: %s\\n\", v->toChars());\n@@ -352,14 +352,14 @@ bool checkAssignEscape(Scope *sc, Expression *e, bool gag)\n         }\n     }\n \n-    for (size_t i = 0; i < er.byfunc.dim; i++)\n+    for (size_t i = 0; i < er.byfunc.length; i++)\n     {\n         FuncDeclaration *fd = er.byfunc[i];\n         //printf(\"fd = %s, %d\\n\", fd->toChars(), fd->tookAddressOf);\n         VarDeclarations vars;\n         findAllOuterAccessedVariables(fd, &vars);\n \n-        for (size_t j = 0; j < vars.dim; j++)\n+        for (size_t j = 0; j < vars.length; j++)\n         {\n             VarDeclaration *v = vars[j];\n             //printf(\"v = %s\\n\", v->toChars());\n@@ -392,7 +392,7 @@ bool checkAssignEscape(Scope *sc, Expression *e, bool gag)\n         }\n     }\n \n-    for (size_t i = 0; i < er.byexp.dim; i++)\n+    for (size_t i = 0; i < er.byexp.length; i++)\n     {\n         Expression *ee = er.byexp[i];\n         if (va && !va->isDataseg() && !va->doNotInferScope)\n@@ -433,11 +433,11 @@ bool checkThrowEscape(Scope *sc, Expression *e, bool gag)\n \n     escapeByValue(e, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n-    for (size_t i = 0; i < er.byvalue.dim; i++)\n+    for (size_t i = 0; i < er.byvalue.length; i++)\n     {\n         VarDeclaration *v = er.byvalue[i];\n         //printf(\"byvalue %s\\n\", v->toChars());\n@@ -528,11 +528,11 @@ static bool checkReturnEscapeImpl(Scope *sc, Expression *e, bool refs, bool gag)\n     else\n         escapeByValue(e, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n-    for (size_t i = 0; i < er.byvalue.dim; i++)\n+    for (size_t i = 0; i < er.byvalue.length; i++)\n     {\n         VarDeclaration *v = er.byvalue[i];\n         //printf(\"byvalue %s\\n\", v->toChars());\n@@ -595,7 +595,7 @@ static bool checkReturnEscapeImpl(Scope *sc, Expression *e, bool refs, bool gag)\n         }\n     }\n \n-    for (size_t i = 0; i < er.byref.dim; i++)\n+    for (size_t i = 0; i < er.byref.length; i++)\n     {\n         VarDeclaration *v = er.byref[i];\n         //printf(\"byref %s\\n\", v->toChars());\n@@ -665,7 +665,7 @@ static bool checkReturnEscapeImpl(Scope *sc, Expression *e, bool refs, bool gag)\n         }\n     }\n \n-    for (size_t i = 0; i < er.byexp.dim; i++)\n+    for (size_t i = 0; i < er.byexp.length; i++)\n     {\n         Expression *ee = er.byexp[i];\n         //printf(\"byexp %s\\n\", ee->toChars());\n@@ -819,7 +819,7 @@ static void escapeByValue(Expression *e, EscapeByResults *er)\n             {\n                 if (e->basis)\n                     e->basis->accept(this);\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     Expression *el = (*e->elements)[i];\n                     if (el)\n@@ -832,7 +832,7 @@ static void escapeByValue(Expression *e, EscapeByResults *er)\n         {\n             if (e->elements)\n             {\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     Expression *ex = (*e->elements)[i];\n                     if (ex)\n@@ -846,7 +846,7 @@ static void escapeByValue(Expression *e, EscapeByResults *er)\n             Type *tb = e->newtype->toBasetype();\n             if (tb->ty == Tstruct && !e->member && e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     Expression *ex = (*e->arguments)[i];\n                     if (ex)\n@@ -945,13 +945,13 @@ static void escapeByValue(Expression *e, EscapeByResults *er)\n             else\n                 return;\n \n-            if (e->arguments && e->arguments->dim)\n+            if (e->arguments && e->arguments->length)\n             {\n                 /* j=1 if _arguments[] is first argument,\n                  * skip it because it is not passed by ref\n                  */\n                 size_t j = (tf->linkage == LINKd && tf->varargs == 1);\n-                for (size_t i = j; i < e->arguments->dim; ++i)\n+                for (size_t i = j; i < e->arguments->length; ++i)\n                 {\n                     Expression *arg = (*e->arguments)[i];\n                     size_t nparams = Parameter::dim(tf->parameters);\n@@ -1141,14 +1141,14 @@ static void escapeByRef(Expression *e, EscapeByResults *er)\n                 return;\n             if (tf->isref)\n             {\n-                if (e->arguments && e->arguments->dim)\n+                if (e->arguments && e->arguments->length)\n                 {\n                     /* j=1 if _arguments[] is first argument,\n                      * skip it because it is not passed by ref\n                      */\n                     size_t j = (tf->linkage == LINKd && tf->varargs == 1);\n \n-                    for (size_t i = j; i < e->arguments->dim; ++i)\n+                    for (size_t i = j; i < e->arguments->length; ++i)\n                     {\n                         Expression *arg = (*e->arguments)[i];\n                         size_t nparams = Parameter::dim(tf->parameters);\n@@ -1216,10 +1216,10 @@ void findAllOuterAccessedVariables(FuncDeclaration *fd, VarDeclarations *vars)\n         FuncDeclaration *fdp = p->isFuncDeclaration();\n         if (fdp)\n         {\n-            for (size_t i = 0; i < fdp->closureVars.dim; i++)\n+            for (size_t i = 0; i < fdp->closureVars.length; i++)\n             {\n                 VarDeclaration *v = fdp->closureVars[i];\n-                for (size_t j = 0; j < v->nestedrefs.dim; j++)\n+                for (size_t j = 0; j < v->nestedrefs.length; j++)\n                 {\n                     FuncDeclaration *fdv = v->nestedrefs[j];\n                     if (fdv == fd)"}, {"sha": "0b042732da85eff8187407a084cfac2252cf4d81", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -277,7 +277,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n             Expressions a;\n             a.push(e2);\n \n-            for (size_t i = 0; i < os->a.dim; i++)\n+            for (size_t i = 0; i < os->a.length; i++)\n             {\n                 FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, &a, 1);\n                 if (f)\n@@ -295,7 +295,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n             }\n         }\n         {\n-            for (size_t i = 0; i < os->a.dim; i++)\n+            for (size_t i = 0; i < os->a.length; i++)\n             {\n                 FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, NULL, 1);\n                 if (f)\n@@ -559,7 +559,7 @@ Expression *resolvePropertiesOnly(Scope *sc, Expression *e1)\n         os = ((OverExp *)e1)->vars;\n     Los:\n         assert(os);\n-        for (size_t i = 0; i < os->a.dim; i++)\n+        for (size_t i = 0; i < os->a.length; i++)\n         {\n             Dsymbol *s = os->a[i];\n             fd = s->isFuncDeclaration();\n@@ -808,7 +808,7 @@ Expression *resolveUFCS(Scope *sc, CallExp *ce)\n                 /* Transform:\n                  *  aa.remove(arg) into delete aa[arg]\n                  */\n-                if (!ce->arguments || ce->arguments->dim != 1)\n+                if (!ce->arguments || ce->arguments->length != 1)\n                 {\n                     ce->error(\"expected key as argument to aa.remove()\");\n                     return new ErrorExp();\n@@ -968,7 +968,7 @@ bool arrayExpressionSemantic(Expressions *exps, Scope *sc, bool preserveErrors)\n     bool err = false;\n     if (exps)\n     {\n-        for (size_t i = 0; i < exps->dim; i++)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *e = (*exps)[i];\n             if (e)\n@@ -997,7 +997,7 @@ void expandTuples(Expressions *exps)\n     //printf(\"expandTuples()\\n\");\n     if (exps)\n     {\n-        for (size_t i = 0; i < exps->dim; i++)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *arg = (*exps)[i];\n             if (!arg)\n@@ -1011,10 +1011,10 @@ void expandTuples(Expressions *exps)\n                 {\n                     TypeTuple *tt = (TypeTuple *)e->type->toBasetype();\n \n-                    if (!tt->arguments || tt->arguments->dim == 0)\n+                    if (!tt->arguments || tt->arguments->length == 0)\n                     {\n                         exps->remove(i);\n-                        if (i == exps->dim)\n+                        if (i == exps->length)\n                             return;\n                         i--;\n                         continue;\n@@ -1028,7 +1028,7 @@ void expandTuples(Expressions *exps)\n                 TupleExp *te = (TupleExp *)arg;\n                 exps->remove(i);                // remove arg\n                 exps->insert(i, te->exps);      // replace with tuple contents\n-                if (i == exps->dim)\n+                if (i == exps->length)\n                     return;             // empty tuple, no more arguments\n                 (*exps)[i] = Expression::combine(te->e0, (*exps)[i]);\n                 arg = (*exps)[i];\n@@ -1072,17 +1072,17 @@ TupleDeclaration *isAliasThisTuple(Expression *e)\n \n int expandAliasThisTuples(Expressions *exps, size_t starti)\n {\n-    if (!exps || exps->dim == 0)\n+    if (!exps || exps->length == 0)\n         return -1;\n \n-    for (size_t u = starti; u < exps->dim; u++)\n+    for (size_t u = starti; u < exps->length; u++)\n     {\n         Expression *exp = (*exps)[u];\n         TupleDeclaration *td = isAliasThisTuple(exp);\n         if (td)\n         {\n             exps->remove(u);\n-            for (size_t i = 0; i<td->objects->dim; ++i)\n+            for (size_t i = 0; i<td->objects->length; ++i)\n             {\n                 Expression *e = isExpression((*td->objects)[i]);\n                 assert(e);\n@@ -1127,7 +1127,7 @@ bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt)\n     size_t j0 = ~0;             // dead-store to prevent spurious warning\n     bool foundType = false;\n \n-    for (size_t i = 0; i < exps->dim; i++)\n+    for (size_t i = 0; i < exps->length; i++)\n     {\n         Expression *e = (*exps)[i];\n         if (!e)\n@@ -1190,7 +1190,7 @@ bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt)\n         t0 = Type::tvoid;               // [] is typed as void[]\n     else if (t0->ty != Terror)\n     {\n-        for (size_t i = 0; i < exps->dim; i++)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *e = (*exps)[i];\n             if (!e)\n@@ -1384,7 +1384,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n     //printf(\"functionParameters()\\n\");\n     assert(arguments);\n     assert(fd || tf->next);\n-    size_t nargs = arguments ? arguments->dim : 0;\n+    size_t nargs = arguments ? arguments->length : 0;\n     size_t nparams = Parameter::dim(tf->parameters);\n     unsigned olderrors = global.errors;\n     bool err = false;\n@@ -1499,7 +1499,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n \n                         Expressions *elements = new Expressions();\n                         elements->setDim(nargs - i);\n-                        for (size_t u = 0; u < elements->dim; u++)\n+                        for (size_t u = 0; u < elements->length; u++)\n                         {\n                             Expression *a = (*arguments)[i + u];\n                             if (tret && a->implicitConvTo(tret))\n@@ -1947,11 +1947,11 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n     // If D linkage and variadic, add _arguments[] as first argument\n     if (tf->linkage == LINKd && tf->varargs == 1)\n     {\n-        assert(arguments->dim >= nparams);\n+        assert(arguments->length >= nparams);\n \n         Parameters *args = new Parameters;\n-        args->setDim(arguments->dim - nparams);\n-        for (size_t i = 0; i < arguments->dim - nparams; i++)\n+        args->setDim(arguments->length - nparams);\n+        for (size_t i = 0; i < arguments->length - nparams; i++)\n         {\n             Parameter *arg = new Parameter(STCin, (*arguments)[nparams + i]->type, NULL, NULL);\n             (*args)[i] = arg;\n@@ -2833,8 +2833,8 @@ Expressions *Expression::arraySyntaxCopy(Expressions *exps)\n     if (exps)\n     {\n         a = new Expressions();\n-        a->setDim(exps->dim);\n-        for (size_t i = 0; i < a->dim; i++)\n+        a->setDim(exps->length);\n+        for (size_t i = 0; i < a->length; i++)\n         {\n             Expression *e = (*exps)[i];\n             (*a)[i] = e ? e->syntaxCopy() : NULL;\n@@ -3790,14 +3790,14 @@ bool ArrayLiteralExp::equals(RootObject *o)\n         ((Expression *)o)->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *ae = (ArrayLiteralExp *)o;\n-        if (elements->dim != ae->elements->dim)\n+        if (elements->length != ae->elements->length)\n             return false;\n-        if (elements->dim == 0 &&\n+        if (elements->length == 0 &&\n             !type->equals(ae->type))\n         {\n             return false;\n         }\n-        for (size_t i = 0; i < elements->dim; i++)\n+        for (size_t i = 0; i < elements->length; i++)\n         {\n             Expression *e1 = (*elements)[i];\n             Expression *e2 = (*ae->elements)[i];\n@@ -3834,9 +3834,9 @@ static void appendArrayLiteral(Expressions *elems, ArrayLiteralExp *ale)\n {\n     if (!ale->elements)\n         return;\n-    size_t d = elems->dim;\n+    size_t d = elems->length;\n     elems->append(ale->elements);\n-    for (size_t i = d; i < elems->dim; i++)\n+    for (size_t i = d; i < elems->length; i++)\n     {\n         Expression *el = (*elems)[i];\n         if (!el)\n@@ -3876,7 +3876,7 @@ Expressions* ArrayLiteralExp::copyElements(Expression *e1, Expression *e2)\n \n bool ArrayLiteralExp::isBool(bool result)\n {\n-    size_t dim = elements ? elements->dim : 0;\n+    size_t dim = elements ? elements->length : 0;\n     return result ? (dim != 0) : (dim == 0);\n }\n \n@@ -3885,7 +3885,7 @@ StringExp *ArrayLiteralExp::toStringExp()\n     TY telem = type->nextOf()->toBasetype()->ty;\n \n     if (telem == Tchar || telem == Twchar || telem == Tdchar ||\n-        (telem == Tvoid && (!elements || elements->dim == 0)))\n+        (telem == Tvoid && (!elements || elements->length == 0)))\n     {\n         unsigned char sz = 1;\n         if (telem == Twchar) sz = 2;\n@@ -3894,7 +3894,7 @@ StringExp *ArrayLiteralExp::toStringExp()\n         OutBuffer buf;\n         if (elements)\n         {\n-            for (size_t i = 0; i < elements->dim; ++i)\n+            for (size_t i = 0; i < elements->length; ++i)\n             {\n                 Expression *ch = getElement(i);\n                 if (ch->op != TOKint64)\n@@ -3929,7 +3929,7 @@ AssocArrayLiteralExp::AssocArrayLiteralExp(Loc loc,\n                 Expressions *keys, Expressions *values)\n     : Expression(loc, TOKassocarrayliteral, sizeof(AssocArrayLiteralExp))\n {\n-    assert(keys->dim == values->dim);\n+    assert(keys->length == values->length);\n     this->keys = keys;\n     this->values = values;\n     this->ownedByCtfe = OWNEDcode;\n@@ -3943,12 +3943,12 @@ bool AssocArrayLiteralExp::equals(RootObject *o)\n         ((Expression *)o)->op == TOKassocarrayliteral)\n     {\n         AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)o;\n-        if (keys->dim != ae->keys->dim)\n+        if (keys->length != ae->keys->length)\n             return false;\n         size_t count = 0;\n-        for (size_t i = 0; i < keys->dim; i++)\n+        for (size_t i = 0; i < keys->length; i++)\n         {\n-            for (size_t j = 0; j < ae->keys->dim; j++)\n+            for (size_t j = 0; j < ae->keys->length; j++)\n             {\n                 if ((*keys)[i]->equals((*ae->keys)[j]))\n                 {\n@@ -3958,7 +3958,7 @@ bool AssocArrayLiteralExp::equals(RootObject *o)\n                 }\n             }\n         }\n-        return count == keys->dim;\n+        return count == keys->length;\n     }\n     return false;\n }\n@@ -3971,7 +3971,7 @@ Expression *AssocArrayLiteralExp::syntaxCopy()\n \n bool AssocArrayLiteralExp::isBool(bool result)\n {\n-    size_t dim = keys->dim;\n+    size_t dim = keys->length;\n     return result ? (dim != 0) : (dim == 0);\n }\n \n@@ -4011,9 +4011,9 @@ bool StructLiteralExp::equals(RootObject *o)\n         StructLiteralExp *se = (StructLiteralExp *)o;\n         if (!type->equals(se->type))\n             return false;\n-        if (elements->dim != se->elements->dim)\n+        if (elements->length != se->elements->length)\n             return false;\n-        for (size_t i = 0; i < elements->dim; i++)\n+        for (size_t i = 0; i < elements->length; i++)\n         {\n             Expression *e1 = (*elements)[i];\n             Expression *e2 = (*se->elements)[i];\n@@ -4075,10 +4075,10 @@ Expression *StructLiteralExp::getField(Type *type, unsigned offset)\n     if (i != -1)\n     {\n         //printf(\"\\ti = %d\\n\", i);\n-        if (i == (int)sd->fields.dim - 1 && sd->isNested())\n+        if (i == (int)sd->fields.length - 1 && sd->isNested())\n             return NULL;\n \n-        assert(i < (int)elements->dim);\n+        assert(i < (int)elements->length);\n         e = (*elements)[i];\n         if (e)\n         {\n@@ -4121,17 +4121,17 @@ int StructLiteralExp::getFieldIndex(Type *type, unsigned offset)\n {\n     /* Find which field offset is by looking at the field offsets\n      */\n-    if (elements->dim)\n+    if (elements->length)\n     {\n-        for (size_t i = 0; i < sd->fields.dim; i++)\n+        for (size_t i = 0; i < sd->fields.length; i++)\n         {\n             VarDeclaration *v = sd->fields[i];\n \n             if (offset == v->offset &&\n                 type->size() == v->type->size())\n             {\n                 /* context field might not be filled. */\n-                if (i == sd->fields.dim - 1 && sd->isNested())\n+                if (i == sd->fields.length - 1 && sd->isNested())\n                     return (int)i;\n                 Expression *e = (*elements)[i];\n                 if (e)\n@@ -4489,8 +4489,8 @@ TupleExp::TupleExp(Loc loc, TupleDeclaration *tup)\n     this->e0 = NULL;\n     this->exps = new Expressions();\n \n-    this->exps->reserve(tup->objects->dim);\n-    for (size_t i = 0; i < tup->objects->dim; i++)\n+    this->exps->reserve(tup->objects->length);\n+    for (size_t i = 0; i < tup->objects->length; i++)\n     {   RootObject *o = (*tup->objects)[i];\n         if (Dsymbol *s = getDsymbol(o))\n         {\n@@ -4526,11 +4526,11 @@ bool TupleExp::equals(RootObject *o)\n     if (((Expression *)o)->op == TOKtuple)\n     {\n         TupleExp *te = (TupleExp *)o;\n-        if (exps->dim != te->exps->dim)\n+        if (exps->length != te->exps->length)\n             return false;\n         if ((e0 && !e0->equals(te->e0)) || (!e0 && te->e0))\n             return false;\n-        for (size_t i = 0; i < exps->dim; i++)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *e1 = (*exps)[i];\n             Expression *e2 = (*te->exps)[i];\n@@ -4562,7 +4562,7 @@ FuncExp::FuncExp(Loc loc, Dsymbol *s)\n     if (td)\n     {\n         assert(td->literal);\n-        assert(td->members && td->members->dim == 1);\n+        assert(td->members && td->members->length == 1);\n         fd = (*td->members)[0]->isFuncLiteralDeclaration();\n     }\n     tok = fd->tok;  // save original kind of function/delegate/(infer)\n@@ -4685,9 +4685,9 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n             goto L1;\n \n         Objects *tiargs = new Objects();\n-        tiargs->reserve(td->parameters->dim);\n+        tiargs->reserve(td->parameters->length);\n \n-        for (size_t i = 0; i < td->parameters->dim; i++)\n+        for (size_t i = 0; i < td->parameters->length; i++)\n         {\n             TemplateParameter *tp = (*td->parameters)[i];\n             size_t u = 0;\n@@ -4909,8 +4909,8 @@ Expression *IsExp::syntaxCopy()\n     if (parameters)\n     {\n         p = new TemplateParameters();\n-        p->setDim(parameters->dim);\n-        for (size_t i = 0; i < p->dim; i++)\n+        p->setDim(parameters->length);\n+        for (size_t i = 0; i < p->length; i++)\n             (*p)[i] = (*parameters)[i]->syntaxCopy();\n     }\n     return new IsExp(loc,\n@@ -5337,7 +5337,7 @@ int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\n                 sc->fieldinit[i] |= CSXthis_ctor;\n                 if (var->overlapped) // Bugzilla 15258\n                 {\n-                    for (size_t j = 0; j < ad->fields.dim; j++)\n+                    for (size_t j = 0; j < ad->fields.length; j++)\n                     {\n                         VarDeclaration *v = ad->fields[j];\n                         if (v == var || !var->isOverlappedWith(v))\n@@ -6808,7 +6808,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n     Dsymbol *slice = search_function(ad, Id::slice);\n     //printf(\"slice = %s %s\\n\", slice->kind(), slice->toChars());\n \n-    for (size_t i = 0; i < ae->arguments->dim; i++)\n+    for (size_t i = 0; i < ae->arguments->length; i++)\n     {\n         if (i == 0)\n             *pe0 = extractOpDollarSideEffect(sc, ae);\n@@ -6817,7 +6817,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n         if (e->op == TOKinterval && !(slice && slice->isTemplateDeclaration()))\n         {\n         Lfallback:\n-            if (ae->arguments->dim == 1)\n+            if (ae->arguments->length == 1)\n                 return NULL;\n             ae->error(\"multi-dimensional slicing requires template opSlice\");\n             return new ErrorExp();"}, {"sha": "048752dc23b7c9762b7d20f461426b9b098661c5", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -91,7 +91,7 @@ static bool preFunctionParameters(Scope *sc, Expressions *exps)\n     {\n         expandTuples(exps);\n \n-        for (size_t i = 0; i < exps->dim; i++)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *arg = (*exps)[i];\n \n@@ -165,7 +165,7 @@ class ExpressionSemanticVisitor : public Visitor\n         OverloadSet *os, Objects* tiargs, Type *tthis, Expressions *arguments)\n     {\n         FuncDeclaration *f = NULL;\n-        for (size_t i = 0; i < os->a.dim; i++)\n+        for (size_t i = 0; i < os->a.length; i++)\n         {\n             Dsymbol *s = os->a[i];\n             if (tiargs && s->isFuncDeclaration())\n@@ -708,7 +708,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         /* Disallow array literals of type void being used.\n         */\n-        if (e->elements->dim > 0 && t0->ty == Tvoid)\n+        if (e->elements->length > 0 && t0->ty == Tvoid)\n         {\n             e->error(\"%s of type %s has no value\", e->toChars(), e->type->toChars());\n             return setError();\n@@ -735,9 +735,9 @@ class ExpressionSemanticVisitor : public Visitor\n             return setError();\n         expandTuples(e->keys);\n         expandTuples(e->values);\n-        if (e->keys->dim != e->values->dim)\n+        if (e->keys->length != e->values->length)\n         {\n-            e->error(\"number of keys is %u, must match number of values %u\", e->keys->dim, e->values->dim);\n+            e->error(\"number of keys is %u, must match number of values %u\", e->keys->length, e->values->length);\n             return setError();\n         }\n \n@@ -792,7 +792,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return setError();\n         }\n \n-        if (checkFrameAccess(e->loc, sc, e->sd, e->elements->dim))\n+        if (checkFrameAccess(e->loc, sc, e->sd, e->elements->length))\n             return setError();\n \n         e->type = e->stype ? e->stype : e->sd->type;\n@@ -1060,7 +1060,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return setError();\n         }\n \n-        size_t nargs = exp->arguments ? exp->arguments->dim : 0;\n+        size_t nargs = exp->arguments ? exp->arguments->length : 0;\n         Expression *newprefix = NULL;\n \n         if (tb->ty == Tclass)\n@@ -1085,7 +1085,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (cd->isAbstract())\n             {\n                 exp->error(\"cannot create instance of abstract class %s\", cd->toChars());\n-                for (size_t i = 0; i < cd->vtbl.dim; i++)\n+                for (size_t i = 0; i < cd->vtbl.length; i++)\n                 {\n                     FuncDeclaration *fd = cd->vtbl[i]->isFuncDeclaration();\n                     if (fd && fd->isAbstract())\n@@ -1193,7 +1193,7 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n             else\n             {\n-                if (exp->newargs && exp->newargs->dim)\n+                if (exp->newargs && exp->newargs->length)\n                 {\n                     exp->error(\"no allocator for %s\", cd->toChars());\n                     return setError();\n@@ -1233,7 +1233,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 // references. This is the same as done for structs in sd->fill().\n                 for (ClassDeclaration *c = cd; c; c = c->baseClass)\n                 {\n-                    for (size_t i = 0; i < c->fields.dim; i++)\n+                    for (size_t i = 0; i < c->fields.length; i++)\n                     {\n                         VarDeclaration *v = c->fields[i];\n                         if (v->inuse || v->_scope == NULL || v->_init == NULL ||\n@@ -1288,7 +1288,7 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n             else\n             {\n-                if (exp->newargs && exp->newargs->dim)\n+                if (exp->newargs && exp->newargs->length)\n                 {\n                     exp->error(\"no allocator for %s\", sd->toChars());\n                     return setError();\n@@ -1315,7 +1315,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 exp->member = f->isCtorDeclaration();\n                 assert(exp->member);\n \n-                if (checkFrameAccess(exp->loc, sc, sd, sd->fields.dim))\n+                if (checkFrameAccess(exp->loc, sc, sd, sd->fields.length))\n                     return setError();\n             }\n             else\n@@ -1327,7 +1327,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     return setError();\n                 if (!sd->fill(exp->loc, exp->arguments, false))\n                     return setError();\n-                if (checkFrameAccess(exp->loc, sc, sd, exp->arguments ? exp->arguments->dim : 0))\n+                if (checkFrameAccess(exp->loc, sc, sd, exp->arguments ? exp->arguments->length : 0))\n                     return setError();\n             }\n \n@@ -1507,7 +1507,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         // Run semantic() on each argument\n         bool err = false;\n-        for (size_t i = 0; i < exp->exps->dim; i++)\n+        for (size_t i = 0; i < exp->exps->length; i++)\n         {\n             Expression *e = (*exp->exps)[i];\n             e = semantic(e, sc);\n@@ -1568,7 +1568,7 @@ class ExpressionSemanticVisitor : public Visitor\n             //printf(\"td = %p, treq = %p\\n\", exp->td, exp->fd->treq);\n             if (exp->td)\n             {\n-                assert(exp->td->parameters && exp->td->parameters->dim);\n+                assert(exp->td->parameters && exp->td->parameters->length);\n                 exp->td->semantic(sc);\n                 exp->type = Type::tvoid; // temporary type\n \n@@ -1639,35 +1639,35 @@ class ExpressionSemanticVisitor : public Visitor\n     // used from CallExp::semantic()\n     Expression *callExpSemantic(FuncExp *exp, Scope *sc, Expressions *arguments)\n     {\n-        if ((!exp->type || exp->type == Type::tvoid) && exp->td && arguments && arguments->dim)\n+        if ((!exp->type || exp->type == Type::tvoid) && exp->td && arguments && arguments->length)\n         {\n-            for (size_t k = 0; k < arguments->dim; k++)\n+            for (size_t k = 0; k < arguments->length; k++)\n             {   Expression *checkarg = (*arguments)[k];\n                 if (checkarg->op == TOKerror)\n                     return checkarg;\n             }\n \n             exp->genIdent(sc);\n \n-            assert(exp->td->parameters && exp->td->parameters->dim);\n+            assert(exp->td->parameters && exp->td->parameters->length);\n             exp->td->semantic(sc);\n \n             TypeFunction *tfl = (TypeFunction *)exp->fd->type;\n             size_t dim = Parameter::dim(tfl->parameters);\n-            if (arguments->dim < dim)\n+            if (arguments->length < dim)\n             {   // Default arguments are always typed, so they don't need inference.\n-                Parameter *p = Parameter::getNth(tfl->parameters, arguments->dim);\n+                Parameter *p = Parameter::getNth(tfl->parameters, arguments->length);\n                 if (p->defaultArg)\n-                    dim = arguments->dim;\n+                    dim = arguments->length;\n             }\n \n-            if ((!tfl->varargs && arguments->dim == dim) ||\n-                ( tfl->varargs && arguments->dim >= dim))\n+            if ((!tfl->varargs && arguments->length == dim) ||\n+                ( tfl->varargs && arguments->length >= dim))\n             {\n                 Objects *tiargs = new Objects();\n-                tiargs->reserve(exp->td->parameters->dim);\n+                tiargs->reserve(exp->td->parameters->length);\n \n-                for (size_t i = 0; i < exp->td->parameters->dim; i++)\n+                for (size_t i = 0; i < exp->td->parameters->length; i++)\n                 {\n                     TemplateParameter *tp = (*exp->td->parameters)[i];\n                     for (size_t u = 0; u < dim; u++)\n@@ -1712,7 +1712,7 @@ class ExpressionSemanticVisitor : public Visitor\n             AttribDeclaration *ad = s->isAttribDeclaration();\n             if (ad)\n             {\n-                if (ad->decl && ad->decl->dim == 1)\n+                if (ad->decl && ad->decl->length == 1)\n                 {\n                     s = (*ad->decl)[0];\n                     continue;\n@@ -1986,10 +1986,10 @@ class ExpressionSemanticVisitor : public Visitor\n                     {\n                         ClassDeclaration *cd = ((TypeClass *)e->targ)->sym;\n                         Parameters *args = new Parameters;\n-                        args->reserve(cd->baseclasses->dim);\n+                        args->reserve(cd->baseclasses->length);\n                         if (cd->semanticRun < PASSsemanticdone)\n                             cd->semantic(NULL);\n-                        for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+                        for (size_t i = 0; i < cd->baseclasses->length; i++)\n                         {\n                             BaseClass *b = (*cd->baseclasses)[i];\n                             args->push(new Parameter(STCin, b->type, NULL, NULL));\n@@ -2089,7 +2089,7 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n             goto Lyes;\n         }\n-        else if (e->tspec && !e->id && !(e->parameters && e->parameters->dim))\n+        else if (e->tspec && !e->id && !(e->parameters && e->parameters->length))\n         {\n             /* Evaluate to true if targ matches tspec\n              * is(targ == tspec)\n@@ -2129,7 +2129,7 @@ class ExpressionSemanticVisitor : public Visitor\n             e->parameters->insert(0, new TemplateTypeParameter(e->loc, tid, NULL, NULL));\n \n             Objects dedtypes;\n-            dedtypes.setDim(e->parameters->dim);\n+            dedtypes.setDim(e->parameters->length);\n             dedtypes.zero();\n \n             MATCH m = deduceType(e->targ, sc, e->tspec, e->parameters, &dedtypes);\n@@ -2151,7 +2151,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n                 /* Declare trailing parameters\n                 */\n-                for (size_t i = 1; i < e->parameters->dim; i++)\n+                for (size_t i = 1; i < e->parameters->length; i++)\n                 {\n                     TemplateParameter *tp = (*e->parameters)[i];\n                     Declaration *s = NULL;\n@@ -2527,8 +2527,8 @@ class ExpressionSemanticVisitor : public Visitor\n             Expression *ev = sc->func ? extractSideEffect(sc, \"__tup\", &e0, exp->e1) : exp->e1;\n \n             Expressions *exps = new Expressions;\n-            exps->reserve(tup->objects->dim);\n-            for (size_t i = 0; i < tup->objects->dim; i++)\n+            exps->reserve(tup->objects->length);\n+            for (size_t i = 0; i < tup->objects->length; i++)\n             {\n                 RootObject *o = (*tup->objects)[i];\n                 Expression *e;\n@@ -2977,13 +2977,13 @@ class ExpressionSemanticVisitor : public Visitor\n                 // First look for constructor\n                 if (exp->e1->op == TOKtype && sd->ctor)\n                 {\n-                    if (!sd->noDefaultCtor && !(exp->arguments && exp->arguments->dim))\n+                    if (!sd->noDefaultCtor && !(exp->arguments && exp->arguments->length))\n                         goto Lx;\n \n                     StructLiteralExp *sle = new StructLiteralExp(exp->loc, sd, NULL, exp->e1->type);\n                     if (!sd->fill(exp->loc, sle->elements, true))\n                         return setError();\n-                    if (checkFrameAccess(exp->loc, sc, sd, sle->elements->dim))\n+                    if (checkFrameAccess(exp->loc, sc, sd, sle->elements->length))\n                         return setError();\n                     // Bugzilla 14556: Set concrete type to avoid further redundant semantic().\n                     sle->type = exp->e1->type;\n@@ -3056,11 +3056,11 @@ class ExpressionSemanticVisitor : public Visitor\n                     t1 = exp->e1->type;\n                 }\n \n-                if (!exp->arguments || exp->arguments->dim == 0)\n+                if (!exp->arguments || exp->arguments->length == 0)\n                 {\n                     e = t1->defaultInitLiteral(exp->loc);\n                 }\n-                else if (exp->arguments->dim == 1)\n+                else if (exp->arguments->length == 1)\n                 {\n                     e = (*exp->arguments)[0];\n                     e = e->implicitCastTo(sc, t1);\n@@ -3122,7 +3122,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 ue->e1 = ue->e1->castTo(sc, ad2->type->addMod(ue->e1->type->mod));\n                 ue->e1 = semantic(ue->e1, sc);\n                 ue1 = ue->e1;\n-                int vi = exp->f->findVtblIndex((Dsymbols*)&ad2->vtbl, (int)ad2->vtbl.dim);\n+                int vi = exp->f->findVtblIndex((Dsymbols*)&ad2->vtbl, (int)ad2->vtbl.length);\n                 assert(vi >= 0);\n                 exp->f = ad2->vtbl[vi]->isFuncDeclaration();\n                 assert(exp->f);\n@@ -4582,7 +4582,7 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 te = (TupleExp *)exp->e1;\n                 tup = NULL;\n-                length = te->exps->dim;\n+                length = te->exps->length;\n             }\n             else if (exp->e1->op == TOKtype)     // slicing a type tuple\n             {\n@@ -4898,7 +4898,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->e2->op == TOKtuple)\n         {\n             TupleExp *te = (TupleExp *)exp->e2;\n-            if (te->exps && te->exps->dim == 1)\n+            if (te->exps && te->exps->length == 1)\n                 exp->e2 = Expression::combine(te->e0, (*te->exps)[0]);  // bug 4444 fix\n         }\n         if (sc != scx)\n@@ -4982,7 +4982,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     {\n                         te = (TupleExp *)exp->e1;\n                         tup = NULL;\n-                        length = te->exps->dim;\n+                        length = te->exps->length;\n                     }\n                     else if (exp->e1->op == TOKtype)\n                     {\n@@ -5190,10 +5190,10 @@ class ExpressionSemanticVisitor : public Visitor\n             Expression *ae1old = ae->e1;\n \n             const bool maybeSlice =\n-                (ae->arguments->dim == 0 ||\n-                 (ae->arguments->dim == 1 && (*ae->arguments)[0]->op == TOKinterval));\n+                (ae->arguments->length == 0 ||\n+                 (ae->arguments->length == 1 && (*ae->arguments)[0]->op == TOKinterval));\n             IntervalExp *ie = NULL;\n-            if (maybeSlice && ae->arguments->dim)\n+            if (maybeSlice && ae->arguments->length)\n             {\n                 assert((*ae->arguments)[0]->op == TOKinterval);\n                 ie = (IntervalExp *)(*ae->arguments)[0];\n@@ -5412,11 +5412,11 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 TupleExp *tup1 = (TupleExp *)exp->e1;\n                 TupleExp *tup2 = (TupleExp *)e2x;\n-                size_t dim = tup1->exps->dim;\n+                size_t dim = tup1->exps->length;\n                 Expression *e = NULL;\n-                if (dim != tup2->exps->dim)\n+                if (dim != tup2->exps->length)\n                 {\n-                    exp->error(\"mismatched tuple lengths, %d and %d\", (int)dim, (int)tup2->exps->dim);\n+                    exp->error(\"mismatched tuple lengths, %d and %d\", (int)dim, (int)tup2->exps->length);\n                     return setError();\n                 }\n                 if (dim == 0)\n@@ -5458,13 +5458,13 @@ class ExpressionSemanticVisitor : public Visitor\n                 Expressions *iexps = new Expressions();\n                 iexps->push(ev);\n \n-                for (size_t u = 0; u < iexps->dim ; u++)\n+                for (size_t u = 0; u < iexps->length ; u++)\n                 {\n             Lexpand:\n                     Expression *e = (*iexps)[u];\n \n                     Parameter *arg = Parameter::getNth(tt->arguments, u);\n-                    //printf(\"[%d] iexps->dim = %d, \", u, iexps->dim);\n+                    //printf(\"[%d] iexps->length = %d, \", u, iexps->length);\n                     //printf(\"e = (%s %s, %s), \", Token::tochars[e->op], e->toChars(), e->type->toChars());\n                     //printf(\"arg = (%s, %s)\\n\", arg->toChars(), arg->type->toChars());\n \n@@ -5473,7 +5473,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         // expand initializer to tuple\n                         if (expandAliasThisTuples(iexps, u) != -1)\n                         {\n-                            if (iexps->dim <= u)\n+                            if (iexps->length <= u)\n                                 break;\n                             goto Lexpand;\n                         }\n@@ -5857,7 +5857,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     if (e2x->op == TOKarrayliteral)\n                     {\n                         ArrayLiteralExp *ale = (ArrayLiteralExp *)e2x;\n-                        dim2 = ale->elements ? ale->elements->dim : 0;\n+                        dim2 = ale->elements ? ale->elements->length : 0;\n                     }\n                     else if (e2x->op == TOKslice)\n                     {\n@@ -6002,7 +6002,7 @@ class ExpressionSemanticVisitor : public Visitor\n             TypeSArray *tsa1 = (TypeSArray *)toStaticArrayType(se1);\n             TypeSArray *tsa2 = NULL;\n             if (e2x->op == TOKarrayliteral)\n-                tsa2 = (TypeSArray *)t2->nextOf()->sarrayOf(((ArrayLiteralExp *)e2x)->elements->dim);\n+                tsa2 = (TypeSArray *)t2->nextOf()->sarrayOf(((ArrayLiteralExp *)e2x)->elements->length);\n             else if (e2x->op == TOKslice)\n                 tsa2 = (TypeSArray *)toStaticArrayType((SliceExp *)e2x);\n             else if (t2->ty == Tsarray)\n@@ -8283,8 +8283,8 @@ Expression *semanticX(DotIdExp *exp, Scope *sc)\n         */\n         TupleExp *te = (TupleExp *)exp->e1;\n         Expressions *exps = new Expressions();\n-        exps->setDim(te->exps->dim);\n-        for (size_t i = 0; i < exps->dim; i++)\n+        exps->setDim(te->exps->length);\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *e = (*te->exps)[i];\n             e = semantic(e, sc);\n@@ -8300,7 +8300,7 @@ Expression *semanticX(DotIdExp *exp, Scope *sc)\n     {\n         TupleExp *te = (TupleExp *)exp->e1;\n         // Don't evaluate te->e0 in runtime\n-        Expression *e = new IntegerExp(exp->loc, te->exps->dim, Type::tsize_t);\n+        Expression *e = new IntegerExp(exp->loc, te->exps->length, Type::tsize_t);\n         return e;\n     }\n "}, {"sha": "961e84a010a526e281fdba892a9c59518ac07e6f", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -74,9 +74,9 @@ class StatementRewriteWalker : public Visitor\n     void visit(CompileStatement *) {  }\n     void visit(CompoundStatement *s)\n     {\n-        if (s->statements && s->statements->dim)\n+        if (s->statements && s->statements->length)\n         {\n-            for (size_t i = 0; i < s->statements->dim; i++)\n+            for (size_t i = 0; i < s->statements->length; i++)\n             {\n                 if ((*s->statements)[i])\n                     visitStmt((*s->statements)[i]);\n@@ -86,9 +86,9 @@ class StatementRewriteWalker : public Visitor\n     void visit(CompoundDeclarationStatement *s) { visit((CompoundStatement *)s); }\n     void visit(UnrolledLoopStatement *s)\n     {\n-        if (s->statements && s->statements->dim)\n+        if (s->statements && s->statements->length)\n         {\n-            for (size_t i = 0; i < s->statements->dim; i++)\n+            for (size_t i = 0; i < s->statements->length; i++)\n             {\n                 if ((*s->statements)[i])\n                     visitStmt((*s->statements)[i]);\n@@ -177,9 +177,9 @@ class StatementRewriteWalker : public Visitor\n     {\n         if (s->_body)\n             visitStmt(s->_body);\n-        if (s->catches && s->catches->dim)\n+        if (s->catches && s->catches->length)\n         {\n-            for (size_t i = 0; i < s->catches->dim; i++)\n+            for (size_t i = 0; i < s->catches->length; i++)\n             {\n                 Catch *c = (*s->catches)[i];\n                 if (c && c->handler)\n@@ -815,13 +815,13 @@ void FuncDeclaration::semantic(Scope *sc)\n             goto Ldone;\n \n         bool may_override = false;\n-        for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+        for (size_t i = 0; i < cd->baseclasses->length; i++)\n         {\n             BaseClass *b = (*cd->baseclasses)[i];\n             ClassDeclaration *cbd = b->type->toBasetype()->isClassHandle();\n             if (!cbd)\n                 continue;\n-            for (size_t j = 0; j < cbd->vtbl.dim; j++)\n+            for (size_t j = 0; j < cbd->vtbl.length; j++)\n             {\n                 FuncDeclaration *f2 = cbd->vtbl[j]->isFuncDeclaration();\n                 if (!f2 || f2->ident != ident)\n@@ -845,7 +845,7 @@ void FuncDeclaration::semantic(Scope *sc)\n         /* Find index of existing function in base class's vtbl[] to override\n          * (the index will be the same as in cd's current vtbl[])\n          */\n-        int vi = cd->baseClass ? findVtblIndex((Dsymbols*)&cd->baseClass->vtbl, (int)cd->baseClass->vtbl.dim)\n+        int vi = cd->baseClass ? findVtblIndex((Dsymbols*)&cd->baseClass->vtbl, (int)cd->baseClass->vtbl.length)\n                                : -1;\n \n         bool doesoverride = false;\n@@ -877,7 +877,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                 /* These quirky conditions mimic what VC++ appears to do\n                  */\n                 if (global.params.mscoff && cd->isCPPclass() &&\n-                    cd->baseClass && cd->baseClass->vtbl.dim)\n+                    cd->baseClass && cd->baseClass->vtbl.length)\n                 {\n                     /* if overriding an interface function, then this is not\n                      * introducing and don't put it in the class vtbl[]\n@@ -905,8 +905,8 @@ void FuncDeclaration::semantic(Scope *sc)\n                     if (cd->isCPPclass() && Target::reverseCppOverloads)\n                     {\n                         // with dmc, overloaded functions are grouped and in reverse order\n-                        vtblIndex = (int)cd->vtbl.dim;\n-                        for (int i = 0; i < (int)cd->vtbl.dim; i++)\n+                        vtblIndex = (int)cd->vtbl.length;\n+                        for (int i = 0; i < (int)cd->vtbl.length; i++)\n                         {\n                             if (cd->vtbl[i]->ident == ident && cd->vtbl[i]->parent == parent)\n                             {\n@@ -915,7 +915,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                             }\n                         }\n                         // shift all existing functions back\n-                        for (int i = (int)cd->vtbl.dim; i > vtblIndex; i--)\n+                        for (int i = (int)cd->vtbl.length; i > vtblIndex; i--)\n                         {\n                             FuncDeclaration *fd = cd->vtbl[i-1]->isFuncDeclaration();\n                             assert(fd);\n@@ -926,7 +926,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                     else\n                     {\n                         // Append to end of vtbl[]\n-                        vi = (int)cd->vtbl.dim;\n+                        vi = (int)cd->vtbl.length;\n                         cd->vtbl.push(this);\n                         vtblIndex = vi;\n                     }\n@@ -977,7 +977,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                     }\n                     else\n                     {\n-                        int vi2 = findVtblIndex(&cd->baseClass->vtbl, (int)cd->baseClass->vtbl.dim, false);\n+                        int vi2 = findVtblIndex(&cd->baseClass->vtbl, (int)cd->baseClass->vtbl.length, false);\n                         if (vi2 < 0)\n                             // https://issues.dlang.org/show_bug.cgi?id=17349\n                             ::deprecation(loc, \"cannot implicitly override base class method `%s` with `%s`; add `override` attribute\",\n@@ -1045,7 +1045,7 @@ void FuncDeclaration::semantic(Scope *sc)\n         for (size_t i = 0; i < cd->interfaces.length; i++)\n         {\n             BaseClass *b = cd->interfaces.ptr[i];\n-            vi = findVtblIndex((Dsymbols *)&b->sym->vtbl, (int)b->sym->vtbl.dim);\n+            vi = findVtblIndex((Dsymbols *)&b->sym->vtbl, (int)b->sym->vtbl.length);\n             switch (vi)\n             {\n                 case -1:\n@@ -1106,7 +1106,7 @@ void FuncDeclaration::semantic(Scope *sc)\n         {\n             BaseClass *bc = NULL;\n             Dsymbol *s = NULL;\n-            for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+            for (size_t i = 0; i < cd->baseclasses->length; i++)\n             {\n                 bc = (*cd->baseclasses)[i];\n                 s = bc->sym->search_correct(ident);\n@@ -1253,7 +1253,7 @@ static bool needsFensure(FuncDeclaration *fd)\n     if (fd->fensure)\n         return true;\n \n-    for (size_t i = 0; i < fd->foverrides.dim; i++)\n+    for (size_t i = 0; i < fd->foverrides.length; i++)\n     {\n         FuncDeclaration *fdv = fd->foverrides[i];\n \n@@ -1417,7 +1417,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n \n     if (frequire)\n     {\n-        for (size_t i = 0; i < foverrides.dim; i++)\n+        for (size_t i = 0; i < foverrides.length; i++)\n         {\n             FuncDeclaration *fdv = foverrides[i];\n \n@@ -1610,7 +1610,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n         // but not in parameters[].\n         if (f->parameters)\n         {\n-            for (size_t i = 0; i < f->parameters->dim; i++)\n+            for (size_t i = 0; i < f->parameters->length; i++)\n             {\n                 Parameter *fparam = (*f->parameters)[i];\n \n@@ -1695,8 +1695,8 @@ void FuncDeclaration::semantic3(Scope *sc)\n              */\n             if (ad2 && isCtorDeclaration())\n             {\n-                allocFieldinit(sc2, ad2->fields.dim);\n-                for (size_t i = 0; i < ad2->fields.dim; i++)\n+                allocFieldinit(sc2, ad2->fields.length);\n+                for (size_t i = 0; i < ad2->fields.length; i++)\n                 {\n                     VarDeclaration *v = ad2->fields[i];\n                     v->ctorinit = 0;\n@@ -1737,7 +1737,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n \n             if (returns && !fbody->isErrorStatement())\n             {\n-                for (size_t i = 0; i < returns->dim; )\n+                for (size_t i = 0; i < returns->length; )\n                 {\n                     Expression *exp = (*returns)[i]->exp;\n                     if (exp->op == TOKvar && ((VarExp *)exp)->var == vresult)\n@@ -1771,7 +1771,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                  * ctor consts were initialized.\n                  */\n                 ScopeDsymbol *pd = toParent()->isScopeDsymbol();\n-                for (size_t i = 0; i < pd->members->dim; i++)\n+                for (size_t i = 0; i < pd->members->length; i++)\n                 {\n                     Dsymbol *s = (*pd->members)[i];\n                     s->checkCtorConstInit();\n@@ -1784,7 +1784,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 // Verify that all the ctorinit fields got initialized\n                 if (!(sc2->callSuper & CSXthis_ctor))\n                 {\n-                    for (size_t i = 0; i < ad2->fields.dim; i++)\n+                    for (size_t i = 0; i < ad2->fields.length; i++)\n                     {\n                         VarDeclaration *v = ad2->fields[i];\n                         if (v->isThisDeclaration())\n@@ -1947,7 +1947,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 /* Cannot move this loop into NrvoWalker, because\n                  * returns[i] may be in the nested delegate for foreach-body.\n                  */\n-                for (size_t i = 0; i < returns->dim; i++)\n+                for (size_t i = 0; i < returns->length; i++)\n                 {\n                     ReturnStatement *rs = (*returns)[i];\n                     Expression *exp = rs->exp;\n@@ -2085,7 +2085,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n             // Merge in initialization of 'out' parameters\n             if (parameters)\n             {\n-                for (size_t i = 0; i < parameters->dim; i++)\n+                for (size_t i = 0; i < parameters->length; i++)\n                 {\n                     VarDeclaration *v = (*parameters)[i];\n                     if (v->storage_class & STCout)\n@@ -2172,7 +2172,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n              */\n             if (parameters)\n             {\n-                for (size_t i = 0; i < parameters->dim; i++)\n+                for (size_t i = 0; i < parameters->length; i++)\n                 {\n                     VarDeclaration *v = (*parameters)[i];\n \n@@ -2252,7 +2252,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n         // Fix up forward-referenced gotos\n         if (gotos)\n         {\n-            for (size_t i = 0; i < gotos->dim; ++i)\n+            for (size_t i = 0; i < gotos->length; ++i)\n             {\n                 (*gotos)[i]->checkLabel();\n             }\n@@ -2314,8 +2314,8 @@ void FuncDeclaration::semantic3(Scope *sc)\n     if (parameters)\n     {\n         size_t nfparams = Parameter::dim(f->parameters);\n-        assert(nfparams == parameters->dim);\n-        for (size_t u = 0; u < parameters->dim; u++)\n+        assert(nfparams == parameters->length);\n+        for (size_t u = 0; u < parameters->length; u++)\n         {\n             VarDeclaration *v = (*parameters)[u];\n             if (v->storage_class & STCmaybescope)\n@@ -2658,7 +2658,7 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)\n      *     a stack local, allocate that local immediately following the exception\n      *     handler block, so it is always at the same offset from EBP.\n      */\n-    for (size_t i = 0; i < foverrides.dim; i++)\n+    for (size_t i = 0; i < foverrides.length; i++)\n     {\n         FuncDeclaration *fdv = foverrides[i];\n \n@@ -2715,7 +2715,7 @@ Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)\n      * list for the 'this' pointer, something that would need an unknown amount\n      * of tweaking of various parts of the compiler that I'd rather leave alone.\n      */\n-    for (size_t i = 0; i < foverrides.dim; i++)\n+    for (size_t i = 0; i < foverrides.length; i++)\n     {\n         FuncDeclaration *fdv = foverrides[i];\n \n@@ -2796,7 +2796,7 @@ int FuncDeclaration::overrides(FuncDeclaration *fd)\n }\n \n /*************************************************\n- * Find index of function in vtbl[0..dim] that\n+ * Find index of function in vtbl[0..length] that\n  * this function overrides.\n  * Prefer an exact match to a covariant one.\n  * Params:\n@@ -2897,7 +2897,7 @@ BaseClass *FuncDeclaration::overrideInterface()\n     for (size_t i = 0; i < cd->interfaces.length; i++)\n     {\n         BaseClass *b = cd->interfaces.ptr[i];\n-        int v = findVtblIndex((Dsymbols *)&b->sym->vtbl, (int)b->sym->vtbl.dim);\n+        int v = findVtblIndex((Dsymbols *)&b->sym->vtbl, (int)b->sym->vtbl.length);\n         if (v >= 0)\n             return b;\n     }\n@@ -3790,7 +3790,7 @@ bool FuncDeclaration::isVirtualMethod()\n     if (!isVirtual())\n         return false;\n     // If it's a final method, and does not override anything, then it is not virtual\n-    if (isFinalFunc() && foverrides.dim == 0)\n+    if (isFinalFunc() && foverrides.length == 0)\n     {\n         return false;\n     }\n@@ -4006,7 +4006,7 @@ bool traverseIndirections(Type *ta, Type *tb, void *p = NULL, bool reversePass =\n         c.type = tb;\n \n         AggregateDeclaration *sym = tb->toDsymbol(NULL)->isAggregateDeclaration();\n-        for (size_t i = 0; i < sym->fields.dim; i++)\n+        for (size_t i = 0; i < sym->fields.length; i++)\n         {\n             VarDeclaration *v = sym->fields[i];\n             Type *tprmi = v->type->addMod(tb->mod);\n@@ -4353,7 +4353,7 @@ bool FuncDeclaration::checkNestedReference(Scope *sc, Loc loc)\n         if (fdthis != this)\n         {\n             bool found = false;\n-            for (size_t i = 0; i < siblingCallers.dim; ++i)\n+            for (size_t i = 0; i < siblingCallers.length; ++i)\n             {\n                 if (siblingCallers[i] == fdthis)\n                     found = true;\n@@ -4386,7 +4386,7 @@ void markAsNeedingClosure(Dsymbol *f, FuncDeclaration *outerFunc)\n     for (Dsymbol *sx = f; sx && sx != outerFunc; sx = sx->parent)\n     {\n         FuncDeclaration *fy = sx->isFuncDeclaration();\n-        if (fy && fy->closureVars.dim)\n+        if (fy && fy->closureVars.length)\n         {\n             /* fy needs a closure if it has closureVars[],\n              * because the frame pointer in the closure will be accessed.\n@@ -4419,7 +4419,7 @@ bool checkEscapingSiblings(FuncDeclaration *f, FuncDeclaration *outerFunc, void\n \n     //printf(\"checkEscapingSiblings(f = %s, outerfunc = %s)\\n\", f->toChars(), outerFunc->toChars());\n     bool bAnyClosures = false;\n-    for (size_t i = 0; i < f->siblingCallers.dim; ++i)\n+    for (size_t i = 0; i < f->siblingCallers.length; ++i)\n     {\n         FuncDeclaration *g = f->siblingCallers[i];\n         if (g->isThis() || g->tookAddressOf)\n@@ -4479,12 +4479,12 @@ bool FuncDeclaration::needsClosure()\n     if (requiresClosure)\n         goto Lyes;\n \n-    for (size_t i = 0; i < closureVars.dim; i++)\n+    for (size_t i = 0; i < closureVars.length; i++)\n     {\n         VarDeclaration *v = closureVars[i];\n         //printf(\"\\tv = %s\\n\", v->toChars());\n \n-        for (size_t j = 0; j < v->nestedrefs.dim; j++)\n+        for (size_t j = 0; j < v->nestedrefs.length; j++)\n         {\n             FuncDeclaration *f = v->nestedrefs[j];\n             assert(f != this);\n@@ -4561,11 +4561,11 @@ bool FuncDeclaration::checkClosure()\n     }\n \n     FuncDeclarations a;\n-    for (size_t i = 0; i < closureVars.dim; i++)\n+    for (size_t i = 0; i < closureVars.length; i++)\n     {\n         VarDeclaration *v = closureVars[i];\n \n-        for (size_t j = 0; j < v->nestedrefs.dim; j++)\n+        for (size_t j = 0; j < v->nestedrefs.length; j++)\n         {\n             FuncDeclaration *f = v->nestedrefs[j];\n             assert(f != this);\n@@ -4585,7 +4585,7 @@ bool FuncDeclaration::checkClosure()\n         Lfound:\n             for (size_t k = 0; ; k++)\n             {\n-                if (k == a.dim)\n+                if (k == a.length)\n                 {\n                     a.push(f);\n                     ::errorSupplemental(f->loc, \"%s closes over variable %s at %s\",\n@@ -4609,7 +4609,7 @@ bool FuncDeclaration::checkClosure()\n \n bool FuncDeclaration::hasNestedFrameRefs()\n {\n-    if (closureVars.dim)\n+    if (closureVars.length)\n         return true;\n \n     /* If a virtual function has contracts, assume its variables are referenced\n@@ -4622,9 +4622,9 @@ bool FuncDeclaration::hasNestedFrameRefs()\n     if (fdrequire || fdensure)\n         return true;\n \n-    if (foverrides.dim && isVirtualMethod())\n+    if (foverrides.length && isVirtualMethod())\n     {\n-        for (size_t i = 0; i < foverrides.dim; i++)\n+        for (size_t i = 0; i < foverrides.length; i++)\n         {\n             FuncDeclaration *fdv = foverrides[i];\n             if (fdv->hasNestedFrameRefs())"}, {"sha": "156f4a6df9744a43acefe7a6ce38f16003d5a06c", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -130,7 +130,7 @@ class PrettyPrintVisitor : public Visitor\n \n     void visit(CompoundStatement *s)\n     {\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n             if (sx)\n@@ -141,7 +141,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(CompoundDeclarationStatement *s)\n     {\n         bool anywritten = false;\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n             ExpStatement *ds = sx ? sx->isExpStatement() : NULL;\n@@ -167,7 +167,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n         buf->level++;\n \n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n         {\n             Statement *sx = (*s->statements)[i];\n             if (sx)\n@@ -253,7 +253,7 @@ class PrettyPrintVisitor : public Visitor\n     {\n         buf->writestring(Token::toChars(s->op));\n         buf->writestring(\" (\");\n-        for (size_t i = 0; i < s->parameters->dim; i++)\n+        for (size_t i = 0; i < s->parameters->length; i++)\n         {\n             Parameter *p = (*s->parameters)[i];\n             if (i)\n@@ -412,7 +412,7 @@ class PrettyPrintVisitor : public Visitor\n     {\n         buf->writestring(\"pragma (\");\n         buf->writestring(s->ident->toChars());\n-        if (s->args && s->args->dim)\n+        if (s->args && s->args->length)\n         {\n             buf->writestring(\", \");\n             argsToBuffer(s->args);\n@@ -584,7 +584,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n         if (s->_body)\n             s->_body->accept(this);\n-        for (size_t i = 0; i < s->catches->dim; i++)\n+        for (size_t i = 0; i < s->catches->length; i++)\n         {\n             Catch *c = (*s->catches)[i];\n             visit(c);\n@@ -686,7 +686,7 @@ class PrettyPrintVisitor : public Visitor\n \n     void visit(ImportStatement *s)\n     {\n-        for (size_t i = 0; i < s->imports->dim; i++)\n+        for (size_t i = 0; i < s->imports->length; i++)\n         {\n             Dsymbol *imp = (*s->imports)[i];\n             imp->accept(this);\n@@ -979,7 +979,7 @@ class PrettyPrintVisitor : public Visitor\n         if (td)\n         {\n             buf->writeByte('(');\n-            for (size_t i = 0; i < td->origParameters->dim; i++)\n+            for (size_t i = 0; i < td->origParameters->length; i++)\n             {\n                 TemplateParameter *p = (*td->origParameters)[i];\n                 if (i)\n@@ -1000,7 +1000,7 @@ class PrettyPrintVisitor : public Visitor\n \n     void visitTypeQualifiedHelper(TypeQualified *t)\n     {\n-        for (size_t i = 0; i < t->idents.dim; i++)\n+        for (size_t i = 0; i < t->idents.length; i++)\n         {\n             RootObject *id = t->idents[i];\n \n@@ -1172,19 +1172,19 @@ class PrettyPrintVisitor : public Visitor\n         {\n             buf->printf(\"%s = \", imp->aliasId->toChars());\n         }\n-        if (imp->packages && imp->packages->dim)\n+        if (imp->packages && imp->packages->length)\n         {\n-            for (size_t i = 0; i < imp->packages->dim; i++)\n+            for (size_t i = 0; i < imp->packages->length; i++)\n             {\n                 Identifier *pid = (*imp->packages)[i];\n                 buf->printf(\"%s.\", pid->toChars());\n             }\n         }\n         buf->printf(\"%s\", imp->id->toChars());\n-        if (imp->names.dim)\n+        if (imp->names.length)\n         {\n             buf->writestring(\" : \");\n-            for (size_t i = 0; i < imp->names.dim; i++)\n+            for (size_t i = 0; i < imp->names.length; i++)\n             {\n                 if (i)\n                     buf->writestring(\", \");\n@@ -1217,14 +1217,14 @@ class PrettyPrintVisitor : public Visitor\n             return;\n         }\n \n-        if (d->decl->dim == 0)\n+        if (d->decl->length == 0)\n             buf->writestring(\"{}\");\n-        else if (hgs->hdrgen && d->decl->dim == 1 && (*d->decl)[0]->isUnitTestDeclaration())\n+        else if (hgs->hdrgen && d->decl->length == 1 && (*d->decl)[0]->isUnitTestDeclaration())\n         {\n             // hack for bugzilla 8081\n             buf->writestring(\"{}\");\n         }\n-        else if (d->decl->dim == 1)\n+        else if (d->decl->length == 1)\n         {\n             ((*d->decl)[0])->accept(this);\n             return;\n@@ -1235,7 +1235,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte('{');\n             buf->writenl();\n             buf->level++;\n-            for (size_t i = 0; i < d->decl->dim; i++)\n+            for (size_t i = 0; i < d->decl->length; i++)\n             {\n                 Dsymbol *de = (*d->decl)[i];\n                 de->accept(this);\n@@ -1326,7 +1326,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->level++;\n         if (d->decl)\n         {\n-            for (size_t i = 0; i < d->decl->dim; i++)\n+            for (size_t i = 0; i < d->decl->length; i++)\n             {\n                 Dsymbol *de = (*d->decl)[i];\n                 de->accept(this);\n@@ -1340,7 +1340,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(PragmaDeclaration *d)\n     {\n         buf->printf(\"pragma (%s\", d->ident->toChars());\n-        if (d->args && d->args->dim)\n+        if (d->args && d->args->length)\n         {\n             buf->writestring(\", \");\n             argsToBuffer(d->args);\n@@ -1360,7 +1360,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->level++;\n             if (d->decl)\n             {\n-                for (size_t i = 0; i < d->decl->dim; i++)\n+                for (size_t i = 0; i < d->decl->length; i++)\n                 {\n                     Dsymbol *de = (*d->decl)[i];\n                     de->accept(this);\n@@ -1376,7 +1376,7 @@ class PrettyPrintVisitor : public Visitor\n                 buf->writeByte('{');\n                 buf->writenl();\n                 buf->level++;\n-                for (size_t i = 0; i < d->elsedecl->dim; i++)\n+                for (size_t i = 0; i < d->elsedecl->length; i++)\n                 {\n                     Dsymbol *de = (*d->elsedecl)[i];\n                     de->accept(this);\n@@ -1455,7 +1455,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte('{');\n             buf->writenl();\n             buf->level++;\n-            for (size_t i = 0; i < d->members->dim; i++)\n+            for (size_t i = 0; i < d->members->length; i++)\n             {\n                 Dsymbol *s = (*d->members)[i];\n                 s->accept(this);\n@@ -1469,7 +1469,7 @@ class PrettyPrintVisitor : public Visitor\n \n     bool visitEponymousMember(TemplateDeclaration *d)\n     {\n-        if (!d->members || d->members->dim != 1)\n+        if (!d->members || d->members->length != 1)\n             return false;\n \n         Dsymbol *onemember = (*d->members)[0];\n@@ -1507,7 +1507,7 @@ class PrettyPrintVisitor : public Visitor\n                 buf->writeByte('{');\n                 buf->writenl();\n                 buf->level++;\n-                for (size_t i = 0; i < ad->members->dim; i++)\n+                for (size_t i = 0; i < ad->members->length; i++)\n                 {\n                     Dsymbol *s = (*ad->members)[i];\n                     s->accept(this);\n@@ -1555,9 +1555,9 @@ class PrettyPrintVisitor : public Visitor\n     }\n     void visitTemplateParameters(TemplateParameters *parameters)\n     {\n-        if (!parameters || !parameters->dim)\n+        if (!parameters || !parameters->length)\n             return;\n-        for (size_t i = 0; i < parameters->dim; i++)\n+        for (size_t i = 0; i < parameters->length; i++)\n         {\n             TemplateParameter *p = (*parameters)[i];\n             if (i)\n@@ -1621,7 +1621,7 @@ class PrettyPrintVisitor : public Visitor\n             return;\n         }\n \n-        if (ti->tiargs->dim == 1)\n+        if (ti->tiargs->length == 1)\n         {\n             RootObject *oarg = (*ti->tiargs)[0];\n             if (Type *t = isType(oarg))\n@@ -1631,7 +1631,7 @@ class PrettyPrintVisitor : public Visitor\n                     t->equals(Type::tdstring) ||\n                     (t->mod == 0 &&\n                      (t->isTypeBasic() ||\n-                      (t->ty == Tident && ((TypeIdentifier *)t)->idents.dim == 0))))\n+                      (t->ty == Tident && ((TypeIdentifier *)t)->idents.length == 0))))\n                 {\n                     buf->writestring(t->toChars());\n                     return;\n@@ -1652,7 +1652,7 @@ class PrettyPrintVisitor : public Visitor\n         }\n         buf->writeByte('(');\n         ti->nest++;\n-        for (size_t i = 0; i < ti->tiargs->dim; i++)\n+        for (size_t i = 0; i < ti->tiargs->length; i++)\n         {\n             RootObject *arg = (*ti->tiargs)[i];\n             if (i)\n@@ -1695,7 +1695,7 @@ class PrettyPrintVisitor : public Visitor\n         else if (Tuple *v = isTuple(oarg))\n         {\n             Objects *args = &v->objects;\n-            for (size_t i = 0; i < args->dim; i++)\n+            for (size_t i = 0; i < args->length; i++)\n             {\n                 RootObject *arg = (*args)[i];\n                 if (i)\n@@ -1739,7 +1739,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writeByte('{');\n         buf->writenl();\n         buf->level++;\n-        for (size_t i = 0; i < d->members->dim; i++)\n+        for (size_t i = 0; i < d->members->length; i++)\n         {\n             EnumMember *em = (*d->members)[i]->isEnumMember();\n             if (!em)\n@@ -1763,7 +1763,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writeByte('{');\n         buf->writenl();\n         buf->level++;\n-        for (size_t i = 0; i < d->members->dim; i++)\n+        for (size_t i = 0; i < d->members->length; i++)\n         {\n             Dsymbol *s = (*d->members)[i];\n             s->accept(this);\n@@ -1788,7 +1788,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writeByte('{');\n         buf->writenl();\n         buf->level++;\n-        for (size_t i = 0; i < d->members->dim; i++)\n+        for (size_t i = 0; i < d->members->length; i++)\n         {\n             Dsymbol *s = (*d->members)[i];\n             s->accept(this);\n@@ -1813,7 +1813,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte('{');\n             buf->writenl();\n             buf->level++;\n-            for (size_t i = 0; i < d->members->dim; i++)\n+            for (size_t i = 0; i < d->members->length; i++)\n             {\n                 Dsymbol *s = (*d->members)[i];\n                 s->accept(this);\n@@ -1828,11 +1828,11 @@ class PrettyPrintVisitor : public Visitor\n \n     void visitBaseClasses(ClassDeclaration *d)\n     {\n-        if (!d || !d->baseclasses->dim)\n+        if (!d || !d->baseclasses->length)\n             return;\n \n         buf->writestring(\" : \");\n-        for (size_t i = 0; i < d->baseclasses->dim; i++)\n+        for (size_t i = 0; i < d->baseclasses->length; i++)\n         {\n             if (i)\n                 buf->writestring(\", \");\n@@ -2018,7 +2018,7 @@ class PrettyPrintVisitor : public Visitor\n         Statement *s1;\n         if (f->semanticRun >= PASSsemantic3done && cs)\n         {\n-            s1 = (*cs->statements)[cs->statements->dim - 1];\n+            s1 = (*cs->statements)[cs->statements->length - 1];\n         }\n         else\n             s1 = !cs ? f->fbody : NULL;\n@@ -2141,7 +2141,7 @@ class PrettyPrintVisitor : public Visitor\n     {\n         //printf(\"StructInitializer::toCBuffer()\\n\");\n         buf->writeByte('{');\n-        for (size_t i = 0; i < si->field.dim; i++)\n+        for (size_t i = 0; i < si->field.length; i++)\n         {\n             if (i)\n                 buf->writestring(\", \");\n@@ -2159,7 +2159,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(ArrayInitializer *ai)\n     {\n         buf->writeByte('[');\n-        for (size_t i = 0; i < ai->index.dim; i++)\n+        for (size_t i = 0; i < ai->index.length; i++)\n         {\n             if (i)\n                 buf->writestring(\", \");\n@@ -2186,10 +2186,10 @@ class PrettyPrintVisitor : public Visitor\n      */\n     void argsToBuffer(Expressions *expressions, Expression *basis = NULL)\n     {\n-        if (!expressions || !expressions->dim)\n+        if (!expressions || !expressions->length)\n             return;\n \n-        for (size_t i = 0; i < expressions->dim; i++)\n+        for (size_t i = 0; i < expressions->length; i++)\n         {\n             Expression *el = (*expressions)[i];\n             if (i)\n@@ -2277,7 +2277,7 @@ class PrettyPrintVisitor : public Visitor\n                         EnumDeclaration *sym = te->sym;\n                         if (inEnumDecl != sym)\n                         {\n-                            for (size_t i = 0; i < sym->members->dim; i++)\n+                            for (size_t i = 0; i < sym->members->length; i++)\n                             {\n                                 EnumMember *em = (EnumMember *)(*sym->members)[i];\n                                 if (em->value()->toInteger() == v)\n@@ -2521,7 +2521,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(AssocArrayLiteralExp *e)\n     {\n         buf->writeByte('[');\n-        for (size_t i = 0; i < e->keys->dim; i++)\n+        for (size_t i = 0; i < e->keys->length; i++)\n         {\n             Expression *key = (*e->keys)[i];\n             Expression *value = (*e->values)[i];\n@@ -2598,14 +2598,14 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte('.');\n         }\n         buf->writestring(\"new \");\n-        if (e->newargs && e->newargs->dim)\n+        if (e->newargs && e->newargs->length)\n         {\n             buf->writeByte('(');\n             argsToBuffer(e->newargs);\n             buf->writeByte(')');\n         }\n         typeToBuffer(e->newtype, NULL);\n-        if (e->arguments && e->arguments->dim)\n+        if (e->arguments && e->arguments->length)\n         {\n             buf->writeByte('(');\n             argsToBuffer(e->arguments);\n@@ -2621,14 +2621,14 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte('.');\n         }\n         buf->writestring(\"new\");\n-        if (e->newargs && e->newargs->dim)\n+        if (e->newargs && e->newargs->length)\n         {\n             buf->writeByte('(');\n             argsToBuffer(e->newargs);\n             buf->writeByte(')');\n         }\n         buf->writestring(\" class \");\n-        if (e->arguments && e->arguments->dim)\n+        if (e->arguments && e->arguments->length)\n         {\n             buf->writeByte('(');\n             argsToBuffer(e->arguments);\n@@ -2717,7 +2717,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->writestring(e->ident->toChars());\n         if (e->args)\n         {\n-            for (size_t i = 0; i < e->args->dim; i++)\n+            for (size_t i = 0; i < e->args->length; i++)\n             {\n                 RootObject *arg = (*e->args)[i];\n                 buf->writestring(\", \");\n@@ -2748,7 +2748,7 @@ class PrettyPrintVisitor : public Visitor\n                 buf->writestring(\" == \");\n             typeToBuffer(e->tspec, NULL);\n         }\n-        if (e->parameters && e->parameters->dim)\n+        if (e->parameters && e->parameters->length)\n         {\n             buf->writestring(\", \");\n             visitTemplateParameters(e->parameters);\n@@ -3158,7 +3158,7 @@ class PrettyPrintVisitor : public Visitor\n             }\n             if (varargs)\n             {\n-                if (parameters->dim && varargs == 1)\n+                if (parameters->length && varargs == 1)\n                     buf->writestring(\", \");\n                 buf->writestring(\"...\");\n             }\n@@ -3194,7 +3194,7 @@ class PrettyPrintVisitor : public Visitor\n             buf->writeByte(';');\n             buf->writenl();\n         }\n-        for (size_t i = 0; i < m->members->dim; i++)\n+        for (size_t i = 0; i < m->members->length; i++)\n         {\n             Dsymbol *s = (*m->members)[i];\n             s->accept(this);\n@@ -3433,12 +3433,12 @@ void toCBuffer(Expression *e, OutBuffer *buf, HdrGenState *hgs)\n  */\n void argExpTypesToCBuffer(OutBuffer *buf, Expressions *arguments)\n {\n-    if (!arguments || !arguments->dim)\n+    if (!arguments || !arguments->length)\n         return;\n \n     HdrGenState hgs;\n     PrettyPrintVisitor v(buf, &hgs);\n-    for (size_t i = 0; i < arguments->dim; i++)\n+    for (size_t i = 0; i < arguments->length; i++)\n     {\n         Expression *arg = (*arguments)[i];\n         if (i)\n@@ -3455,12 +3455,12 @@ void toCBuffer(TemplateParameter *tp, OutBuffer *buf, HdrGenState *hgs)\n \n void arrayObjectsToBuffer(OutBuffer *buf, Objects *objects)\n {\n-    if (!objects || !objects->dim)\n+    if (!objects || !objects->length)\n         return;\n \n     HdrGenState hgs;\n     PrettyPrintVisitor v(buf, &hgs);\n-    for (size_t i = 0; i < objects->dim; i++)\n+    for (size_t i = 0; i < objects->length; i++)\n     {\n         RootObject *o = (*objects)[i];\n         if (i)"}, {"sha": "5cc9025a7b312c38674be401840b9c59e8377432", "filename": "gcc/d/dmd/iasmgcc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -333,7 +333,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n     // Analyse all input and output operands.\n     if (s->args)\n     {\n-        for (size_t i = 0; i < s->args->dim; i++)\n+        for (size_t i = 0; i < s->args->length; i++)\n         {\n             Expression *e = (*s->args)[i];\n             e = semantic(e, sc);\n@@ -354,7 +354,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n     // Analyse all clobbers.\n     if (s->clobbers)\n     {\n-        for (size_t i = 0; i < s->clobbers->dim; i++)\n+        for (size_t i = 0; i < s->clobbers->length; i++)\n         {\n             Expression *e = (*s->clobbers)[i];\n             e = semantic(e, sc);\n@@ -366,7 +366,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n     // Analyse all goto labels.\n     if (s->labels)\n     {\n-        for (size_t i = 0; i < s->labels->dim; i++)\n+        for (size_t i = 0; i < s->labels->length; i++)\n         {\n             Identifier *ident = (*s->labels)[i];\n             GotoStatement *gs = new GotoStatement(s->loc, ident);"}, {"sha": "c4a496f8b5d4ff0ffa2f8944ac372b8254866778", "filename": "gcc/d/dmd/init.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -41,8 +41,8 @@ Initializers *Initializer::arraySyntaxCopy(Initializers *ai)\n     if (ai)\n     {\n         a = new Initializers();\n-        a->setDim(ai->dim);\n-        for (size_t i = 0; i < a->dim; i++)\n+        a->setDim(ai->length);\n+        for (size_t i = 0; i < a->length; i++)\n             (*a)[i] = (*ai)[i]->syntaxCopy();\n     }\n     return a;\n@@ -91,10 +91,10 @@ StructInitializer::StructInitializer(Loc loc)\n Initializer *StructInitializer::syntaxCopy()\n {\n     StructInitializer *ai = new StructInitializer(loc);\n-    assert(field.dim == value.dim);\n-    ai->field.setDim(field.dim);\n-    ai->value.setDim(value.dim);\n-    for (size_t i = 0; i < field.dim; i++)\n+    assert(field.length == value.length);\n+    ai->field.setDim(field.length);\n+    ai->value.setDim(value.length);\n+    for (size_t i = 0; i < field.length; i++)\n     {\n         ai->field[i] = field[i];\n         ai->value[i] = value[i]->syntaxCopy();\n@@ -123,10 +123,10 @@ Initializer *ArrayInitializer::syntaxCopy()\n {\n     //printf(\"ArrayInitializer::syntaxCopy()\\n\");\n     ArrayInitializer *ai = new ArrayInitializer(loc);\n-    assert(index.dim == value.dim);\n-    ai->index.setDim(index.dim);\n-    ai->value.setDim(value.dim);\n-    for (size_t i = 0; i < ai->value.dim; i++)\n+    assert(index.length == value.length);\n+    ai->index.setDim(index.length);\n+    ai->value.setDim(value.length);\n+    for (size_t i = 0; i < ai->value.length; i++)\n     {\n         ai->index[i] = index[i] ? index[i]->syntaxCopy() : NULL;\n         ai->value[i] = value[i]->syntaxCopy();\n@@ -144,7 +144,7 @@ void ArrayInitializer::addInit(Expression *index, Initializer *value)\n \n bool ArrayInitializer::isAssociativeArray()\n {\n-    for (size_t i = 0; i < value.dim; i++)\n+    for (size_t i = 0; i < value.length; i++)\n     {\n         if (index[i])\n             return true;\n@@ -163,11 +163,11 @@ Expression *ArrayInitializer::toAssocArrayLiteral()\n     //printf(\"ArrayInitializer::toAssocArrayInitializer()\\n\");\n     //static int i; if (++i == 2) halt();\n     Expressions *keys = new Expressions();\n-    keys->setDim(value.dim);\n+    keys->setDim(value.length);\n     Expressions *values = new Expressions();\n-    values->setDim(value.dim);\n+    values->setDim(value.length);\n \n-    for (size_t i = 0; i < value.dim; i++)\n+    for (size_t i = 0; i < value.length; i++)\n     {\n         e = index[i];\n         if (!e)\n@@ -274,7 +274,7 @@ bool hasNonConstPointers(Expression *e)\n \n bool arrayHasNonConstPointers(Expressions *elems)\n {\n-    for (size_t i = 0; i < elems->dim; i++)\n+    for (size_t i = 0; i < elems->length; i++)\n     {\n         Expression *e = (*elems)[i];\n         if (e && hasNonConstPointers(e))"}, {"sha": "b566ec4fa68843e8c14e124be2b3707bd6bbb4a6", "filename": "gcc/d/dmd/initsem.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Finitsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Finitsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -76,19 +76,19 @@ class InitializerSemanticVisitor : public Visitor\n                 result = new ErrorInitializer();\n                 return;\n             }\n-            size_t nfields = sd->fields.dim - sd->isNested();\n+            size_t nfields = sd->fields.length - sd->isNested();\n \n             //expandTuples for non-identity arguments?\n \n             Expressions *elements = new Expressions();\n             elements->setDim(nfields);\n-            for (size_t j = 0; j < elements->dim; j++)\n+            for (size_t j = 0; j < elements->length; j++)\n                 (*elements)[j] = NULL;\n \n             // Run semantic for explicitly given initializers\n             // TODO: this part is slightly different from StructLiteralExp::semantic.\n             bool errors = false;\n-            for (size_t fieldi = 0, j = 0; j < i->field.dim; j++)\n+            for (size_t fieldi = 0, j = 0; j < i->field.length; j++)\n             {\n                 if (Identifier *id = i->field[j])\n                 {\n@@ -177,7 +177,7 @@ class InitializerSemanticVisitor : public Visitor\n             result = ::semantic(ie, sc, t, needInterpret);\n             return;\n         }\n-        else if ((t->ty == Tdelegate || (t->ty == Tpointer && t->nextOf()->ty == Tfunction)) && i->value.dim == 0)\n+        else if ((t->ty == Tdelegate || (t->ty == Tpointer && t->nextOf()->ty == Tfunction)) && i->value.length == 0)\n         {\n             TOK tok = (t->ty == Tdelegate) ? TOKdelegate : TOKfunction;\n             /* Rewrite as empty delegate literal { }\n@@ -252,7 +252,7 @@ class InitializerSemanticVisitor : public Visitor\n         i->type = t;\n \n         length = 0;\n-        for (size_t j = 0; j < i->index.dim; j++)\n+        for (size_t j = 0; j < i->index.length; j++)\n         {\n             Expression *idx = i->index[j];\n             if (idx)\n@@ -289,7 +289,7 @@ class InitializerSemanticVisitor : public Visitor\n                 i->index.remove(j);\n                 i->value.remove(j);\n \n-                for (size_t k = 0; k < te->exps->dim; ++k)\n+                for (size_t k = 0; k < te->exps->length; ++k)\n                 {\n                     Expression *e = (*te->exps)[k];\n                     i->index.insert(j + k, (Expression *)NULL);\n@@ -381,7 +381,7 @@ class InitializerSemanticVisitor : public Visitor\n             return;\n         }\n \n-        if (i->exp->type->ty == Ttuple && ((TypeTuple *)i->exp->type)->arguments->dim == 0)\n+        if (i->exp->type->ty == Ttuple && ((TypeTuple *)i->exp->type)->arguments->length == 0)\n         {\n             Type *et = i->exp->type;\n             i->exp = new TupleExp(i->exp->loc, new Expressions());\n@@ -482,7 +482,7 @@ class InitializerSemanticVisitor : public Visitor\n                 if (i->exp->op == TOKarrayliteral)\n                 {\n                     ArrayLiteralExp *ale = (ArrayLiteralExp *)i->exp;\n-                    dim2 = ale->elements ? ale->elements->dim : 0;\n+                    dim2 = ale->elements ? ale->elements->length : 0;\n                 }\n                 else if (i->exp->op == TOKslice)\n                 {\n@@ -558,11 +558,11 @@ class InferTypeVisitor : public Visitor\n         if (init->isAssociativeArray())\n         {\n             keys = new Expressions();\n-            keys->setDim(init->value.dim);\n+            keys->setDim(init->value.length);\n             values = new Expressions();\n-            values->setDim(init->value.dim);\n+            values->setDim(init->value.length);\n \n-            for (size_t i = 0; i < init->value.dim; i++)\n+            for (size_t i = 0; i < init->value.length; i++)\n             {\n                 Expression *e = init->index[i];\n                 if (!e)\n@@ -591,10 +591,10 @@ class InferTypeVisitor : public Visitor\n         else\n         {\n             Expressions *elements = new Expressions();\n-            elements->setDim(init->value.dim);\n+            elements->setDim(init->value.length);\n             elements->zero();\n \n-            for (size_t i = 0; i < init->value.dim; i++)\n+            for (size_t i = 0; i < init->value.length; i++)\n             {\n                 assert(!init->index[i]);  // already asserted by isAssociativeArray()\n \n@@ -741,7 +741,7 @@ class InitToExpressionVisitor : public Visitor\n \n     void visit(ArrayInitializer *init)\n     {\n-        //printf(\"ArrayInitializer::toExpression(), dim = %d\\n\", init->dim);\n+        //printf(\"ArrayInitializer::toExpression(), dim = %d\\n\", init->length);\n         //static int i; if (++i == 2) halt();\n \n         Expressions *elements;\n@@ -783,8 +783,8 @@ class InitToExpressionVisitor : public Visitor\n         }\n         else\n         {\n-            edim = (unsigned)init->value.dim;\n-            for (size_t i = 0, j = 0; i < init->value.dim; i++, j++)\n+            edim = (unsigned)init->value.length;\n+            for (size_t i = 0, j = 0; i < init->value.length; i++, j++)\n             {\n                 if (init->index[i])\n                 {\n@@ -806,7 +806,7 @@ class InitToExpressionVisitor : public Visitor\n         elements = new Expressions();\n         elements->setDim(edim);\n         elements->zero();\n-        for (size_t i = 0, j = 0; i < init->value.dim; i++, j++)\n+        for (size_t i = 0, j = 0; i < init->value.length; i++, j++)\n         {\n             if (init->index[i])\n                 j = (size_t)(init->index[i])->toInteger();\n@@ -848,7 +848,7 @@ class InitToExpressionVisitor : public Visitor\n                 {\n                     size_t dim = ((TypeSArray *)tn)->dim->toInteger();\n                     Type *te = tn->nextOf()->toBasetype();\n-                    for (size_t i = 0; i < elements->dim; i++)\n+                    for (size_t i = 0; i < elements->length; i++)\n                     {\n                         Expression *e = (*elements)[i];\n                         if (te->equals(e->type))"}, {"sha": "ba0cc6f300a1926995df96eff024c0e497689f4e", "filename": "gcc/d/dmd/json.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -394,15 +394,15 @@ class ToJsonVisitor : public Visitor\n \n     void property(const char *name, Parameters *parameters)\n     {\n-        if (parameters == NULL || parameters->dim == 0)\n+        if (parameters == NULL || parameters->length == 0)\n             return;\n \n         propertyStart(name);\n         arrayStart();\n \n         if (parameters)\n         {\n-            for (size_t i = 0; i < parameters->dim; i++)\n+            for (size_t i = 0; i < parameters->length; i++)\n             {\n                 Parameter *p = (*parameters)[i];\n                 objectStart();\n@@ -512,7 +512,7 @@ class ToJsonVisitor : public Visitor\n \n         propertyStart(\"members\");\n         arrayStart();\n-        for (size_t i = 0; i < s->members->dim; i++)\n+        for (size_t i = 0; i < s->members->length; i++)\n         {\n             (*s->members)[i]->accept(this);\n         }\n@@ -530,9 +530,9 @@ class ToJsonVisitor : public Visitor\n \n         propertyStart(\"name\");\n         stringStart();\n-        if (s->packages && s->packages->dim)\n+        if (s->packages && s->packages->length)\n         {\n-            for (size_t i = 0; i < s->packages->dim; i++)\n+            for (size_t i = 0; i < s->packages->length; i++)\n             {\n                 Identifier *pid = (*s->packages)[i];\n                 stringPart(pid->toChars());\n@@ -553,7 +553,7 @@ class ToJsonVisitor : public Visitor\n \n         bool hasRenamed = false;\n         bool hasSelective = false;\n-        for (size_t i = 0; i < s->aliases.dim; i++)\n+        for (size_t i = 0; i < s->aliases.length; i++)\n         {\n             // avoid empty \"renamed\" and \"selective\" sections\n             if (hasRenamed && hasSelective)\n@@ -569,7 +569,7 @@ class ToJsonVisitor : public Visitor\n             // import foo : alias1 = target1;\n             propertyStart(\"renamed\");\n             objectStart();\n-            for (size_t i = 0; i < s->aliases.dim; i++)\n+            for (size_t i = 0; i < s->aliases.length; i++)\n             {\n                 Identifier *name = s->names[i];\n                 Identifier *alias = s->aliases[i];\n@@ -583,7 +583,7 @@ class ToJsonVisitor : public Visitor\n             // import foo : target1;\n             propertyStart(\"selective\");\n             arrayStart();\n-            for (size_t i = 0; i < s->names.dim; i++)\n+            for (size_t i = 0; i < s->names.length; i++)\n             {\n                 Identifier *name = s->names[i];\n                 if (!s->aliases[i]) item(name->toChars());\n@@ -600,7 +600,7 @@ class ToJsonVisitor : public Visitor\n \n         if (ds)\n         {\n-            for (size_t i = 0; i < ds->dim; i++)\n+            for (size_t i = 0; i < ds->length; i++)\n             {\n                 Dsymbol *s = (*ds)[i];\n                 s->accept(this);\n@@ -660,7 +660,7 @@ class ToJsonVisitor : public Visitor\n         {\n             propertyStart(\"members\");\n             arrayStart();\n-            for (size_t i = 0; i < d->members->dim; i++)\n+            for (size_t i = 0; i < d->members->length; i++)\n             {\n                 Dsymbol *s = (*d->members)[i];\n                 s->accept(this);\n@@ -683,11 +683,11 @@ class ToJsonVisitor : public Visitor\n \n         property(\"endline\", \"endchar\", &d->endloc);\n \n-        if (d->foverrides.dim)\n+        if (d->foverrides.length)\n         {\n             propertyStart(\"overrides\");\n             arrayStart();\n-            for (size_t i = 0; i < d->foverrides.dim; i++)\n+            for (size_t i = 0; i < d->foverrides.length; i++)\n             {\n                 FuncDeclaration *fd = d->foverrides[i];\n                 item(fd->toPrettyChars());\n@@ -721,7 +721,7 @@ class ToJsonVisitor : public Visitor\n \n         propertyStart(\"parameters\");\n         arrayStart();\n-        for (size_t i = 0; i < d->parameters->dim; i++)\n+        for (size_t i = 0; i < d->parameters->length; i++)\n         {\n             TemplateParameter *s = (*d->parameters)[i];\n             objectStart();\n@@ -786,7 +786,7 @@ class ToJsonVisitor : public Visitor\n \n         propertyStart(\"members\");\n         arrayStart();\n-        for (size_t i = 0; i < d->members->dim; i++)\n+        for (size_t i = 0; i < d->members->length; i++)\n         {\n             Dsymbol *s = (*d->members)[i];\n             s->accept(this);\n@@ -802,7 +802,7 @@ class ToJsonVisitor : public Visitor\n         {\n             if (d->members)\n             {\n-                for (size_t i = 0; i < d->members->dim; i++)\n+                for (size_t i = 0; i < d->members->length; i++)\n                 {\n                     Dsymbol *s = (*d->members)[i];\n                     s->accept(this);\n@@ -821,7 +821,7 @@ class ToJsonVisitor : public Visitor\n         {\n             propertyStart(\"members\");\n             arrayStart();\n-            for (size_t i = 0; i < d->members->dim; i++)\n+            for (size_t i = 0; i < d->members->length; i++)\n             {\n                 Dsymbol *s = (*d->members)[i];\n                 s->accept(this);\n@@ -879,7 +879,7 @@ void json_generate(OutBuffer *buf, Modules *modules)\n     ToJsonVisitor json(buf);\n \n     json.arrayStart();\n-    for (size_t i = 0; i < modules->dim; i++)\n+    for (size_t i = 0; i < modules->length; i++)\n     {\n         Module *m = (*modules)[i];\n         if (global.params.verbose)"}, {"sha": "8223d25be6b6eeaeed4c9e3413e4ac31ccd60b9d", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -1551,9 +1551,9 @@ Type *stripDefaultArgs(Type *t)\n     static Parameters *stripParams(Parameters *parameters)\n     {\n         Parameters *params = parameters;\n-        if (params && params->dim > 0)\n+        if (params && params->length > 0)\n         {\n-            for (size_t i = 0; i < params->dim; i++)\n+            for (size_t i = 0; i < params->length; i++)\n             {\n                 Parameter *p = (*params)[i];\n                 Type *ta = stripDefaultArgs(p->type);\n@@ -1562,8 +1562,8 @@ Type *stripDefaultArgs(Type *t)\n                     if (params == parameters)\n                     {\n                         params = new Parameters();\n-                        params->setDim(parameters->dim);\n-                        for (size_t j = 0; j < params->dim; j++)\n+                        params->setDim(parameters->length);\n+                        for (size_t j = 0; j < params->length; j++)\n                             (*params)[j] = (*parameters)[j];\n                     }\n                     (*params)[i] = new Parameter(p->storageClass, ta, NULL, NULL);\n@@ -2002,7 +2002,7 @@ Type *TypeFunction::substWildTo(unsigned)\n     Parameters *params = parameters;\n     if (mod & MODwild)\n         params = parameters->copy();\n-    for (size_t i = 0; i < params->dim; i++)\n+    for (size_t i = 0; i < params->length; i++)\n     {\n         Parameter *p = (*params)[i];\n         Type *t = p->type->substWildTo(m);\n@@ -4017,9 +4017,9 @@ void TypeSArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             dim = dim->ctfeInterpret();\n             uinteger_t d = dim->toUInteger();\n \n-            if (d >= td->objects->dim)\n+            if (d >= td->objects->length)\n             {\n-                error(loc, \"tuple index %llu exceeds length %u\", d, td->objects->dim);\n+                error(loc, \"tuple index %llu exceeds length %u\", d, td->objects->length);\n                 *ps = NULL;\n                 *pt = Type::terror;\n                 return;\n@@ -4091,8 +4091,8 @@ Type *TypeSArray::semantic(Loc loc, Scope *sc)\n         dim = dim->ctfeInterpret();\n         uinteger_t d = dim->toUInteger();\n \n-        if (d >= sd->objects->dim)\n-        {   error(loc, \"tuple index %llu exceeds %u\", d, sd->objects->dim);\n+        if (d >= sd->objects->length)\n+        {   error(loc, \"tuple index %llu exceeds %u\", d, sd->objects->length);\n             return Type::terror;\n         }\n         RootObject *o = (*sd->objects)[(size_t)d];\n@@ -4178,8 +4178,8 @@ Type *TypeSArray::semantic(Loc loc, Scope *sc)\n             TypeTuple *tt = (TypeTuple *)tbn;\n             uinteger_t d = dim->toUInteger();\n \n-            if (d >= tt->arguments->dim)\n-            {   error(loc, \"tuple index %llu exceeds %u\", d, tt->arguments->dim);\n+            if (d >= tt->arguments->length)\n+            {   error(loc, \"tuple index %llu exceeds %u\", d, tt->arguments->length);\n                 goto Lerror;\n             }\n             Type *telem = (*tt->arguments)[(size_t)d]->type;\n@@ -4757,9 +4757,9 @@ Type *TypeAArray::semantic(Loc loc, Scope *sc)\n         if (!fhash) fhash = search_function(ClassDeclaration::object, Id::tohash)->isFuncDeclaration();\n         assert(fcmp && feq && fhash);\n \n-        if (feq->vtblIndex < (int)cd->vtbl.dim && cd->vtbl[feq ->vtblIndex] == feq)\n+        if (feq->vtblIndex < (int)cd->vtbl.length && cd->vtbl[feq ->vtblIndex] == feq)\n         {\n-            if (fcmp->vtblIndex < (int)cd->vtbl.dim && cd->vtbl[fcmp->vtblIndex] != fcmp)\n+            if (fcmp->vtblIndex < (int)cd->vtbl.length && cd->vtbl[fcmp->vtblIndex] != fcmp)\n             {\n                 const char *s = (index->toBasetype()->ty != Tclass) ? \"bottom of \" : \"\";\n                 error(loc, \"%sAA key type %s now requires equality rather than comparison\",\n@@ -5303,8 +5303,8 @@ int Type::covariant(Type *t, StorageClass *pstc, bool fix17349)\n     }\n     else if (t1->parameters != t2->parameters)\n     {\n-        size_t dim1 = !t1->parameters ? 0 : t1->parameters->dim;\n-        size_t dim2 = !t2->parameters ? 0 : t2->parameters->dim;\n+        size_t dim1 = !t1->parameters ? 0 : t1->parameters->length;\n+        size_t dim2 = !t2->parameters ? 0 : t2->parameters->length;\n         if (dim1 || dim2)\n             goto Ldistinct;\n     }\n@@ -5464,7 +5464,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n     if (parameters)\n     {\n         tf->parameters = parameters->copy();\n-        for (size_t i = 0; i < parameters->dim; i++)\n+        for (size_t i = 0; i < parameters->length; i++)\n         {\n             void *pp = mem.xmalloc(sizeof(Parameter));\n             Parameter *p = (Parameter *)memcpy(pp, (void *)(*parameters)[i], sizeof(Parameter));\n@@ -5703,13 +5703,13 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n                  * sharing of Parameter object among other functions.\n                  */\n                 TypeTuple *tt = (TypeTuple *)t;\n-                if (tt->arguments && tt->arguments->dim)\n+                if (tt->arguments && tt->arguments->length)\n                 {\n                     /* Propagate additional storage class from tuple parameters to their\n                      * element-parameters.\n                      * Make a copy, as original may be referenced elsewhere.\n                      */\n-                    size_t tdim = tt->arguments->dim;\n+                    size_t tdim = tt->arguments->length;\n                     Parameters *newparams = new Parameters();\n                     newparams->setDim(tdim);\n                     for (size_t j = 0; j < tdim; j++)\n@@ -5752,7 +5752,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n              */\n             if (fparam->storageClass & STCauto)\n             {\n-                if (fargs && i < fargs->dim && (fparam->storageClass & STCref))\n+                if (fargs && i < fargs->length && (fparam->storageClass & STCref))\n                 {\n                     Expression *farg = (*fargs)[i];\n                     if (farg->isLvalue())\n@@ -5983,7 +5983,7 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n     }\n \n     size_t nparams = Parameter::dim(parameters);\n-    size_t nargs = args ? args->dim : 0;\n+    size_t nargs = args ? args->length : 0;\n     if (nparams == nargs)\n         ;\n     else if (nargs > nparams)\n@@ -6634,8 +6634,8 @@ Type *TypeTraits::semantic(Loc, Scope *sc)\n         {\n             TupleExp *te = e->toTupleExp();\n             Objects *elems = new Objects;\n-            elems->setDim(te->exps->dim);\n-            for (size_t i = 0; i < elems->dim; i++)\n+            elems->setDim(te->exps->length);\n+            for (size_t i = 0; i < elems->length; i++)\n             {\n                 Expression *src = (*te->exps)[i];\n                 switch (src->op)\n@@ -6717,8 +6717,8 @@ TypeQualified::TypeQualified(TY ty, Loc loc)\n void TypeQualified::syntaxCopyHelper(TypeQualified *t)\n {\n     //printf(\"TypeQualified::syntaxCopyHelper(%s) %s\\n\", t->toChars(), toChars());\n-    idents.setDim(t->idents.dim);\n-    for (size_t i = 0; i < idents.dim; i++)\n+    idents.setDim(t->idents.length);\n+    for (size_t i = 0; i < idents.length; i++)\n     {\n         RootObject *id = t->idents[i];\n         if (id->dyncast() == DYNCAST_DSYMBOL)\n@@ -6817,9 +6817,9 @@ void TypeQualified::resolveTupleIndex(Loc loc, Scope *sc, Dsymbol *s,\n     }\n \n     const uinteger_t d = eindex->toUInteger();\n-    if (d >= td->objects->dim)\n+    if (d >= td->objects->length)\n     {\n-        ::error(loc, \"tuple index %llu exceeds length %u\", (ulonglong)d, (unsigned)td->objects->dim);\n+        ::error(loc, \"tuple index %llu exceeds length %u\", (ulonglong)d, (unsigned)td->objects->length);\n         *pt = Type::terror;\n         return;\n     }\n@@ -6860,7 +6860,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n \n         s = s->toAlias();\n         //printf(\"\\t2: s = '%s' %p, kind = '%s'\\n\",s->toChars(), s, s->kind());\n-        for (size_t i = 0; i < idents.dim; i++)\n+        for (size_t i = 0; i < idents.length; i++)\n         {\n             RootObject *id = idents[i];\n \n@@ -7205,7 +7205,7 @@ const char *TypeInstance::kind()\n \n Type *TypeInstance::syntaxCopy()\n {\n-    //printf(\"TypeInstance::syntaxCopy() %s, %d\\n\", toChars(), idents.dim);\n+    //printf(\"TypeInstance::syntaxCopy() %s, %d\\n\", toChars(), idents.length);\n     TypeInstance *t = new TypeInstance(loc, (TemplateInstance *)tempinst->syntaxCopy(NULL));\n     t->syntaxCopyHelper(this);\n     t->mod = mod;\n@@ -7394,7 +7394,7 @@ void TypeTypeof::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             goto Lerr;\n         }\n     }\n-    if (idents.dim == 0)\n+    if (idents.length == 0)\n         *pt = t;\n     else\n     {\n@@ -7496,7 +7496,7 @@ void TypeReturn::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             goto Lerr;\n         }\n     }\n-    if (idents.dim == 0)\n+    if (idents.length == 0)\n         *pt = t;\n     else\n     {\n@@ -7904,8 +7904,8 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             ev = extractSideEffect(sc, \"__tup\", &e0, ev);\n \n         Expressions *exps = new Expressions;\n-        exps->reserve(sym->fields.dim);\n-        for (size_t i = 0; i < sym->fields.dim; i++)\n+        exps->reserve(sym->fields.length);\n+        for (size_t i = 0; i < sym->fields.length; i++)\n         {\n             VarDeclaration *v = sym->fields[i];\n             Expression *ex;\n@@ -8115,9 +8115,9 @@ Expression *TypeStruct::defaultInitLiteral(Loc loc)\n     if (sym->sizeok != SIZEOKdone)\n         return new ErrorExp();\n     Expressions *structelems = new Expressions();\n-    structelems->setDim(sym->fields.dim - sym->isNested());\n+    structelems->setDim(sym->fields.length - sym->isNested());\n     unsigned offset = 0;\n-    for (size_t j = 0; j < structelems->dim; j++)\n+    for (size_t j = 0; j < structelems->length; j++)\n     {\n         VarDeclaration *vd = sym->fields[j];\n         Expression *e;\n@@ -8176,7 +8176,7 @@ bool TypeStruct::needsNested()\n     if (sym->isNested())\n         return true;\n \n-    for (size_t i = 0; i < sym->fields.dim; i++)\n+    for (size_t i = 0; i < sym->fields.length; i++)\n     {\n         VarDeclaration *v = sym->fields[i];\n         if (!v->isDataseg() && v->type->needsNested())\n@@ -8193,7 +8193,7 @@ bool TypeStruct::isAssignable()\n     /* If any of the fields are const or immutable,\n      * then one cannot assign this struct.\n      */\n-    for (size_t i = 0; i < sym->fields.dim; i++)\n+    for (size_t i = 0; i < sym->fields.length; i++)\n     {\n         VarDeclaration *v = sym->fields[i];\n         //printf(\"%s [%d] v = (%s) %s, v->offset = %d, v->parent = %s\", sym->toChars(), i, v->kind(), v->toChars(), v->offset, v->parent->kind());\n@@ -8227,7 +8227,7 @@ bool TypeStruct::hasPointers()\n     StructDeclaration *s = sym;\n \n     sym->size(Loc());               // give error for forward references\n-    for (size_t i = 0; i < s->fields.dim; i++)\n+    for (size_t i = 0; i < s->fields.length; i++)\n     {\n         Declaration *d = s->fields[i];\n         if (d->storage_class & STCref || d->hasPointers())\n@@ -8242,7 +8242,7 @@ bool TypeStruct::hasVoidInitPointers()\n     StructDeclaration *s = sym;\n \n     sym->size(Loc()); // give error for forward references\n-    for (size_t i = 0; i < s->fields.dim; i++)\n+    for (size_t i = 0; i < s->fields.length; i++)\n     {\n         VarDeclaration *v = s->fields[i];\n         if (v->_init && v->_init->isVoidInitializer() && v->type->hasPointers())\n@@ -8272,7 +8272,7 @@ MATCH TypeStruct::implicitConvTo(Type *to)\n                  * allow the conversion.\n                  */\n                 unsigned offset = ~0;   // dead-store to prevent spurious warning\n-                for (size_t i = 0; i < sym->fields.dim; i++)\n+                for (size_t i = 0; i < sym->fields.length; i++)\n                 {\n                     VarDeclaration *v = sym->fields[i];\n                     if (i == 0)\n@@ -8465,8 +8465,8 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             ev = extractSideEffect(sc, \"__tup\", &e0, ev);\n \n         Expressions *exps = new Expressions;\n-        exps->reserve(sym->fields.dim);\n-        for (size_t i = 0; i < sym->fields.dim; i++)\n+        exps->reserve(sym->fields.length);\n+        for (size_t i = 0; i < sym->fields.length; i++)\n         {\n             VarDeclaration *v = sym->fields[i];\n             // Don't include hidden 'this' pointer\n@@ -8987,8 +8987,8 @@ TypeTuple::TypeTuple(Expressions *exps)\n     Parameters *arguments = new Parameters;\n     if (exps)\n     {\n-        arguments->setDim(exps->dim);\n-        for (size_t i = 0; i < exps->dim; i++)\n+        arguments->setDim(exps->length);\n+        for (size_t i = 0; i < exps->length; i++)\n         {   Expression *e = (*exps)[i];\n             if (e->type->ty == Ttuple)\n                 e->error(\"cannot form tuple of tuples\");\n@@ -9064,9 +9064,9 @@ bool TypeTuple::equals(RootObject *o)\n     if (t->ty == Ttuple)\n     {\n         TypeTuple *tt = (TypeTuple *)t;\n-        if (arguments->dim == tt->arguments->dim)\n+        if (arguments->length == tt->arguments->length)\n         {\n-            for (size_t i = 0; i < tt->arguments->dim; i++)\n+            for (size_t i = 0; i < tt->arguments->length; i++)\n             {\n                 Parameter *arg1 = (*arguments)[i];\n                 Parameter *arg2 = (*tt->arguments)[i];\n@@ -9085,7 +9085,7 @@ Expression *TypeTuple::getProperty(Loc loc, Identifier *ident, int flag)\n \n     if (ident == Id::length)\n     {\n-        e = new IntegerExp(loc, arguments->dim, Type::tsize_t);\n+        e = new IntegerExp(loc, arguments->length, Type::tsize_t);\n     }\n     else if (ident == Id::_init)\n     {\n@@ -9106,8 +9106,8 @@ Expression *TypeTuple::getProperty(Loc loc, Identifier *ident, int flag)\n Expression *TypeTuple::defaultInit(Loc loc)\n {\n     Expressions *exps = new Expressions();\n-    exps->setDim(arguments->dim);\n-    for (size_t i = 0; i < arguments->dim; i++)\n+    exps->setDim(arguments->length);\n+    for (size_t i = 0; i < arguments->length; i++)\n     {\n         Parameter *p = (*arguments)[i];\n         assert(p->type);\n@@ -9165,9 +9165,9 @@ Type *TypeSlice::semantic(Loc loc, Scope *sc)\n     upr = upr->ctfeInterpret();\n     uinteger_t i2 = upr->toUInteger();\n \n-    if (!(i1 <= i2 && i2 <= tt->arguments->dim))\n+    if (!(i1 <= i2 && i2 <= tt->arguments->length))\n     {\n-        error(loc, \"slice [%llu..%llu] is out of range of [0..%u]\", i1, i2, tt->arguments->dim);\n+        error(loc, \"slice [%llu..%llu] is out of range of [0..%u]\", i1, i2, tt->arguments->length);\n         return Type::terror;\n     }\n \n@@ -9217,15 +9217,15 @@ void TypeSlice::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             uinteger_t i1 = lwr->toUInteger();\n             uinteger_t i2 = upr->toUInteger();\n \n-            if (!(i1 <= i2 && i2 <= td->objects->dim))\n+            if (!(i1 <= i2 && i2 <= td->objects->length))\n             {\n-                error(loc, \"slice [%llu..%llu] is out of range of [0..%u]\", i1, i2, td->objects->dim);\n+                error(loc, \"slice [%llu..%llu] is out of range of [0..%u]\", i1, i2, td->objects->length);\n                 *ps = NULL;\n                 *pt = Type::terror;\n                 return;\n             }\n \n-            if (i1 == 0 && i2 == td->objects->dim)\n+            if (i1 == 0 && i2 == td->objects->length)\n             {\n                 *ps = td;\n                 return;\n@@ -9236,7 +9236,7 @@ void TypeSlice::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n              */\n             Objects *objects = new Objects;\n             objects->setDim((size_t)(i2 - i1));\n-            for (size_t i = 0; i < objects->dim; i++)\n+            for (size_t i = 0; i < objects->length; i++)\n             {\n                 (*objects)[i] = (*td->objects)[(size_t)i1 + i];\n             }\n@@ -9341,8 +9341,8 @@ Parameters *Parameter::arraySyntaxCopy(Parameters *parameters)\n     if (parameters)\n     {\n         params = new Parameters();\n-        params->setDim(parameters->dim);\n-        for (size_t i = 0; i < params->dim; i++)\n+        params->setDim(parameters->length);\n+        for (size_t i = 0; i < params->length; i++)\n             (*params)[i] = (*parameters)[i]->syntaxCopy();\n     }\n     return params;\n@@ -9443,7 +9443,7 @@ int Parameter_foreach(Parameters *parameters, ForeachDg dg, void *ctx, size_t *p\n \n     size_t n = pn ? *pn : 0; // take over index\n     int result = 0;\n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         Parameter *p = (*parameters)[i];\n         Type *t = p->type->toBasetype();"}, {"sha": "6b5c297348acfcad6b7211d3848c5e88551843ff", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -12,7 +12,7 @@\n \n #include \"root/root.h\"\n #include \"root/stringtable.h\"\n-#include \"root/rmem.h\" // for d_size_t\n+#include \"root/dcompat.h\" // for d_size_t\n \n #include \"arraytypes.h\"\n #include \"expression.h\""}, {"sha": "1372f4804a4b7132cf1415789b790ac7dca09882", "filename": "gcc/d/dmd/nogc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fnogc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fnogc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -78,7 +78,7 @@ class NOGCVisitor : public StoppableVisitor\n \n     void visit(ArrayLiteralExp *e)\n     {\n-        if (e->type->ty != Tarray || !e->elements || !e->elements->dim)\n+        if (e->type->ty != Tarray || !e->elements || !e->elements->length)\n             return;\n \n         if (f->setGC())\n@@ -93,7 +93,7 @@ class NOGCVisitor : public StoppableVisitor\n \n     void visit(AssocArrayLiteralExp *e)\n     {\n-        if (!e->keys->dim)\n+        if (!e->keys->length)\n             return;\n \n         if (f->setGC())"}, {"sha": "bee30e982509121825ce3621f692ead00ad2253c", "filename": "gcc/d/dmd/nspace.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fnspace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fnspace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -58,7 +58,7 @@ void Nspace::addMember(Scope *sc, ScopeDsymbol *sds)\n         sc = sc->push(this);\n         sc->linkage = LINKcpp; // namespaces default to C++ linkage\n         sc->parent = this;\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\"add %s to scope %s\\n\", s->toChars(), toChars());\n@@ -77,7 +77,7 @@ void Nspace::setScope(Scope *sc)\n         sc = sc->push(this);\n         sc->linkage = LINKcpp; // namespaces default to C++ linkage\n         sc->parent = this;\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->setScope(sc);\n@@ -107,13 +107,13 @@ void Nspace::semantic(Scope *sc)\n         sc->linkage = LINKcpp;          // note that namespaces imply C++ linkage\n         sc->parent = this;\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->importAll(sc);\n         }\n \n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic(sc);\n@@ -133,7 +133,7 @@ void Nspace::semantic2(Scope *sc)\n         assert(sc);\n         sc = sc->push(this);\n         sc->linkage = LINKcpp;\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic2(sc);\n@@ -151,7 +151,7 @@ void Nspace::semantic3(Scope *sc)\n     {\n         sc = sc->push(this);\n         sc->linkage = LINKcpp;\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             s->semantic3(sc);\n@@ -189,7 +189,7 @@ int Nspace::apply(Dsymbol_apply_ft_t fp, void *param)\n {\n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             if (s)\n@@ -208,7 +208,7 @@ bool Nspace::hasPointers()\n \n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\" s = %s %s\\n\", s->kind(), s->toChars());\n@@ -228,7 +228,7 @@ void Nspace::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool is\n         semantic(NULL);         // try to resolve it\n     if (members)\n     {\n-        for (size_t i = 0; i < members->dim; i++)\n+        for (size_t i = 0; i < members->length; i++)\n         {\n             Dsymbol *s = (*members)[i];\n             //printf(\"\\t%s\\n\", s->toChars());"}, {"sha": "21737a3a795133514606306ed34e13fba1cf5a74", "filename": "gcc/d/dmd/opover.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fopover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fopover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -239,10 +239,10 @@ Expression *op_overload(Expression *e, Scope *sc)\n                 Expression *ae1old = ae->e1;\n \n                 const bool maybeSlice =\n-                    (ae->arguments->dim == 0 ||\n-                     (ae->arguments->dim == 1 && (*ae->arguments)[0]->op == TOKinterval));\n+                    (ae->arguments->length == 0 ||\n+                     (ae->arguments->length == 1 && (*ae->arguments)[0]->op == TOKinterval));\n                 IntervalExp *ie = NULL;\n-                if (maybeSlice && ae->arguments->dim)\n+                if (maybeSlice && ae->arguments->length)\n                 {\n                     assert((*ae->arguments)[0]->op == TOKinterval);\n                     ie = (IntervalExp *)(*ae->arguments)[0];\n@@ -397,10 +397,10 @@ Expression *op_overload(Expression *e, Scope *sc)\n             Expression *ae1old = ae->e1;\n \n             const bool maybeSlice =\n-                (ae->arguments->dim == 0 ||\n-                 (ae->arguments->dim == 1 && (*ae->arguments)[0]->op == TOKinterval));\n+                (ae->arguments->length == 0 ||\n+                 (ae->arguments->length == 1 && (*ae->arguments)[0]->op == TOKinterval));\n             IntervalExp *ie = NULL;\n-            if (maybeSlice && ae->arguments->dim)\n+            if (maybeSlice && ae->arguments->length)\n             {\n                 assert((*ae->arguments)[0]->op == TOKinterval);\n                 ie = (IntervalExp *)(*ae->arguments)[0];\n@@ -439,7 +439,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                             return;\n                         }\n                         // Convert to IndexExp\n-                        if (ae->arguments->dim == 1)\n+                        if (ae->arguments->length == 1)\n                         {\n                             result = new IndexExp(ae->loc, ae->e1, (*ae->arguments)[0]);\n                             result = semantic(result, sc);\n@@ -1079,11 +1079,11 @@ Expression *op_overload(Expression *e, Scope *sc)\n             {\n                 TupleExp *tup1 = (TupleExp *)e->e1;\n                 TupleExp *tup2 = (TupleExp *)e->e2;\n-                size_t dim = tup1->exps->dim;\n-                if (dim != tup2->exps->dim)\n+                size_t dim = tup1->exps->length;\n+                if (dim != tup2->exps->length)\n                 {\n                     e->error(\"mismatched tuple lengths, %d and %d\",\n-                        (int)dim, (int)tup2->exps->dim);\n+                        (int)dim, (int)tup2->exps->length);\n                     result = new ErrorExp();\n                     return;\n                 }\n@@ -1140,10 +1140,10 @@ Expression *op_overload(Expression *e, Scope *sc)\n                 Expression *ae1old = ae->e1;\n \n                 const bool maybeSlice =\n-                    (ae->arguments->dim == 0 ||\n-                     (ae->arguments->dim == 1 && (*ae->arguments)[0]->op == TOKinterval));\n+                    (ae->arguments->length == 0 ||\n+                     (ae->arguments->length == 1 && (*ae->arguments)[0]->op == TOKinterval));\n                 IntervalExp *ie = NULL;\n-                if (maybeSlice && ae->arguments->dim)\n+                if (maybeSlice && ae->arguments->length)\n                 {\n                     assert((*ae->arguments)[0]->op == TOKinterval);\n                     ie = (IntervalExp *)(*ae->arguments)[0];\n@@ -1704,12 +1704,12 @@ bool inferAggregate(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n \n bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n {\n-    if (!fes->parameters || !fes->parameters->dim)\n+    if (!fes->parameters || !fes->parameters->length)\n         return false;\n \n     if (sapply)     // prefer opApply\n     {\n-        for (size_t u = 0; u < fes->parameters->dim; u++)\n+        for (size_t u = 0; u < fes->parameters->length; u++)\n         {\n             Parameter *p = (*fes->parameters)[u];\n             if (p->type)\n@@ -1742,7 +1742,7 @@ bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n \n     /* Return if no parameters need types.\n      */\n-    for (size_t u = 0; u < fes->parameters->dim; u++)\n+    for (size_t u = 0; u < fes->parameters->length; u++)\n     {\n         Parameter *p = (*fes->parameters)[u];\n         if (!p->type)\n@@ -1760,7 +1760,7 @@ bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n         case Tarray:\n         case Tsarray:\n         case Ttuple:\n-            if (fes->parameters->dim == 2)\n+            if (fes->parameters->length == 2)\n             {\n                 if (!p->type)\n                 {\n@@ -1780,7 +1780,7 @@ bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n         {\n             TypeAArray *taa = (TypeAArray *)tab;\n \n-            if (fes->parameters->dim == 2)\n+            if (fes->parameters->length == 2)\n             {\n                 if (!p->type)\n                 {\n@@ -1808,7 +1808,7 @@ bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n             goto Laggr;\n \n         Laggr:\n-            if (fes->parameters->dim == 1)\n+            if (fes->parameters->length == 1)\n             {\n                 if (!p->type)\n                 {\n@@ -1937,7 +1937,7 @@ static int inferApplyArgTypesY(TypeFunction *tf, Parameters *parameters, int fla\n     nparams = Parameter::dim(tf->parameters);\n     if (nparams == 0 || tf->varargs)\n         goto Lnomatch;          // not enough parameters\n-    if (parameters->dim != nparams)\n+    if (parameters->length != nparams)\n         goto Lnomatch;          // not enough parameters\n \n     for (size_t u = 0; u < nparams; u++)"}, {"sha": "fa736dc2a75a42c4c26bf1b223c191c089690526", "filename": "gcc/d/dmd/optimize.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -242,7 +242,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n         void visit(TupleExp *e)\n         {\n             expOptimize(e->e0, WANTvalue);\n-            for (size_t i = 0; i < e->exps->dim; i++)\n+            for (size_t i = 0; i < e->exps->length; i++)\n             {\n                 expOptimize((*e->exps)[i], WANTvalue);\n             }\n@@ -253,7 +253,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n             if (e->elements)\n             {\n                 expOptimize(e->basis, result & WANTexpand);\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     expOptimize((*e->elements)[i], result & WANTexpand);\n                 }\n@@ -262,8 +262,8 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n \n         void visit(AssocArrayLiteralExp *e)\n         {\n-            assert(e->keys->dim == e->values->dim);\n-            for (size_t i = 0; i < e->keys->dim; i++)\n+            assert(e->keys->length == e->values->length);\n+            for (size_t i = 0; i < e->keys->length; i++)\n             {\n                 expOptimize((*e->keys)[i], result & WANTexpand);\n                 expOptimize((*e->values)[i], result & WANTexpand);\n@@ -277,7 +277,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n             e->stageflags |= stageOptimize;\n             if (e->elements)\n             {\n-                for (size_t i = 0; i < e->elements->dim; i++)\n+                for (size_t i = 0; i < e->elements->length; i++)\n                 {\n                     expOptimize((*e->elements)[i], result & WANTexpand);\n                 }\n@@ -501,15 +501,15 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n             // Optimize parameters\n             if (e->newargs)\n             {\n-                for (size_t i = 0; i < e->newargs->dim; i++)\n+                for (size_t i = 0; i < e->newargs->length; i++)\n                 {\n                     expOptimize((*e->newargs)[i], WANTvalue);\n                 }\n             }\n \n             if (e->arguments)\n             {\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     expOptimize((*e->arguments)[i], WANTvalue);\n                 }\n@@ -529,7 +529,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n                 if (t1->ty == Tdelegate) t1 = t1->nextOf();\n                 assert(t1->ty == Tfunction);\n                 TypeFunction *tf = (TypeFunction *)t1;\n-                for (size_t i = 0; i < e->arguments->dim; i++)\n+                for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n                     Parameter *p = Parameter::getNth(tf->parameters, i);\n                     bool keep = p && (p->storageClass & (STCref | STCout)) != 0;\n@@ -1017,7 +1017,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n             if (arr->op == TOKstring)\n                 len = ((StringExp *)arr)->len;\n             else if (arr->op == TOKarrayliteral)\n-                len = ((ArrayLiteralExp *)arr)->elements->dim;\n+                len = ((ArrayLiteralExp *)arr)->elements->length;\n             else\n             {\n                 Type *t = arr->type->toBasetype();"}, {"sha": "7d858d715ced0bb39760aff0d858c453e5f290e6", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -354,8 +354,8 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n             case TOKtraits:\n             Ldeclaration:\n                 a = parseDeclarations(false, pAttrs, pAttrs->comment);\n-                if (a && a->dim)\n-                    *pLastDecl = (*a)[a->dim-1];\n+                if (a && a->length)\n+                    *pLastDecl = (*a)[a->length-1];\n                 break;\n \n             case TOKthis:\n@@ -577,8 +577,8 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                 {\n                     a = parseAutoDeclarations(pAttrs->storageClass, pAttrs->comment);\n                     pAttrs->storageClass = STCundefined;\n-                    if (a && a->dim)\n-                        *pLastDecl = (*a)[a->dim-1];\n+                    if (a && a->length)\n+                        *pLastDecl = (*a)[a->length-1];\n                     if (pAttrs->udas)\n                     {\n                         s = new UserAttributeDeclaration(pAttrs->udas, a);\n@@ -596,8 +596,8 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                    )\n                 {\n                     a = parseDeclarations(true, pAttrs, pAttrs->comment);\n-                    if (a && a->dim)\n-                        *pLastDecl = (*a)[a->dim-1];\n+                    if (a && a->length)\n+                        *pLastDecl = (*a)[a->length-1];\n                     if (pAttrs->udas)\n                     {\n                         s = new UserAttributeDeclaration(pAttrs->udas, a);\n@@ -704,8 +704,8 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                 if (idents)\n                 {\n                     assert(link == LINKcpp);\n-                    assert(idents->dim);\n-                    for (size_t i = idents->dim; i;)\n+                    assert(idents->length);\n+                    for (size_t i = idents->length; i;)\n                     {\n                         Identifier *id = (*idents)[--i];\n                         if (s)\n@@ -950,7 +950,7 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n             decldefs->push(s);\n             addComment(s, pAttrs->comment);\n         }\n-        else if (a && a->dim)\n+        else if (a && a->length)\n         {\n             decldefs->append(a);\n         }\n@@ -3251,10 +3251,10 @@ Type *Parser::parseBasicTypeStartingAt(TypeQualified *tid, bool dontLookDotIdent\n                             break;\n                         }\n                     }\n-                    assert(dimStack.dim > 0);\n+                    assert(dimStack.length > 0);\n                     // We're good. Replay indices in the reverse order.\n                     tid = (TypeQualified *)t;\n-                    while (dimStack.dim)\n+                    while (dimStack.length)\n                     {\n                         tid->addIndex(dimStack.pop());\n                     }\n@@ -4820,7 +4820,7 @@ Statement *Parser::parseForeach(Loc loc, bool *isRange, bool isDecl)\n     check(TOKsemicolon);\n \n     Expression *aggr = parseExpression();\n-    if (token.value == TOKslice && parameters->dim == 1)\n+    if (token.value == TOKslice && parameters->length == 1)\n     {\n         Parameter *p = (*parameters)[0];\n         delete parameters;\n@@ -5073,19 +5073,19 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         Ldeclaration:\n         {\n             Dsymbols *a = parseDeclarations(false, NULL, NULL);\n-            if (a->dim > 1)\n+            if (a->length > 1)\n             {\n                 Statements *as = new Statements();\n-                as->reserve(a->dim);\n-                for (size_t i = 0; i < a->dim; i++)\n+                as->reserve(a->length);\n+                for (size_t i = 0; i < a->length; i++)\n                 {\n                     Dsymbol *d = (*a)[i];\n                     s = new ExpStatement(loc, d);\n                     as->push(s);\n                 }\n                 s = new CompoundDeclarationStatement(loc, as);\n             }\n-            else if (a->dim == 1)\n+            else if (a->length == 1)\n             {\n                 Dsymbol *d = (*a)[0];\n                 s = new ExpStatement(loc, d);\n@@ -5500,7 +5500,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n              */\n             if (token.value == TOKslice)\n             {\n-                if (cases.dim > 1)\n+                if (cases.length > 1)\n                     error(\"only one case allowed for start of case range\");\n                 nextToken();\n                 check(TOKcase);\n@@ -5531,7 +5531,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n             else\n             {\n                 // Keep cases in order by building the case statements backwards\n-                for (size_t i = cases.dim; i; i--)\n+                for (size_t i = cases.length; i; i--)\n                 {\n                     exp = cases[i - 1];\n                     s = new CaseStatement(loc, exp, s);\n@@ -7154,7 +7154,7 @@ Expression *Parser::parsePrimaryExp()\n             while (token.value != TOKrbracket && token.value != TOKeof)\n             {\n                     e = parseAssignExp();\n-                    if (token.value == TOKcolon && (keys || values->dim == 0))\n+                    if (token.value == TOKcolon && (keys || values->length == 0))\n                     {   nextToken();\n                         if (!keys)\n                             keys = new Expressions();"}, {"sha": "fb838e69f4ba9f61095ae5ff4a8e0a65b65b8258", "filename": "gcc/d/dmd/root/array.h", "status": "modified", "additions": 115, "deletions": 112, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -9,50 +9,50 @@\n #pragma once\n \n #include \"dsystem.h\"\n+#include \"dcompat.h\"\n #include \"object.h\"\n #include \"rmem.h\"\n \n template <typename TYPE>\n struct Array\n {\n-    d_size_t dim;\n-    TYPE *data;\n+    d_size_t length;\n \n   private:\n-    Array(const Array&);\n-\n-    d_size_t allocdim;\n+    DArray<TYPE> data;\n     #define SMALLARRAYCAP       1\n     TYPE smallarray[SMALLARRAYCAP];    // inline storage for small arrays\n \n+    Array(const Array&);\n+\n   public:\n     Array()\n     {\n-        data = SMALLARRAYCAP ? &smallarray[0] : NULL;\n-        dim = 0;\n-        allocdim = SMALLARRAYCAP;\n+        data.ptr = SMALLARRAYCAP ? &smallarray[0] : NULL;\n+        length = 0;\n+        data.length = SMALLARRAYCAP;\n     }\n \n     ~Array()\n     {\n-        if (data != &smallarray[0])\n-            mem.xfree(data);\n+        if (data.ptr != &smallarray[0])\n+            mem.xfree(data.ptr);\n     }\n \n-    char *toChars()\n+    char *toChars() const\n     {\n-        const char **buf = (const char **)mem.xmalloc(dim * sizeof(const char *));\n+        const char **buf = (const char **)mem.xmalloc(length * sizeof(const char *));\n         d_size_t len = 2;\n-        for (d_size_t u = 0; u < dim; u++)\n+        for (d_size_t u = 0; u < length; u++)\n         {\n-            buf[u] = ((RootObject *)data[u])->toChars();\n+            buf[u] = ((RootObject *)data.ptr[u])->toChars();\n             len += strlen(buf[u]) + 1;\n         }\n         char *str = (char *)mem.xmalloc(len);\n \n         str[0] = '[';\n         char *p = str + 1;\n-        for (d_size_t u = 0; u < dim; u++)\n+        for (d_size_t u = 0; u < length; u++)\n         {\n             if (u)\n                 *p++ = ',';\n@@ -66,164 +66,167 @@ struct Array\n         return str;\n     }\n \n+    void push(TYPE ptr)\n+    {\n+        reserve(1);\n+        data.ptr[length++] = ptr;\n+    }\n+\n+    void append(Array *a)\n+    {\n+        insert(length, a);\n+    }\n+\n     void reserve(d_size_t nentries)\n     {\n-        //printf(\"Array::reserve: dim = %d, allocdim = %d, nentries = %d\\n\", (int)dim, (int)allocdim, (int)nentries);\n-        if (allocdim - dim < nentries)\n+        //printf(\"Array::reserve: length = %d, data.length = %d, nentries = %d\\n\", (int)length, (int)data.length, (int)nentries);\n+        if (data.length - length < nentries)\n         {\n-            if (allocdim == 0)\n-            {   // Not properly initialized, someone memset it to zero\n+            if (data.length == 0)\n+            {\n+                // Not properly initialized, someone memset it to zero\n                 if (nentries <= SMALLARRAYCAP)\n-                {   allocdim = SMALLARRAYCAP;\n-                    data = SMALLARRAYCAP ? &smallarray[0] : NULL;\n+                {\n+                    data.length = SMALLARRAYCAP;\n+                    data.ptr = SMALLARRAYCAP ? &smallarray[0] : NULL;\n                 }\n                 else\n-                {   allocdim = nentries;\n-                    data = (TYPE *)mem.xmalloc(allocdim * sizeof(*data));\n+                {\n+                    data.length = nentries;\n+                    data.ptr = (TYPE *)mem.xmalloc(data.length * sizeof(TYPE));\n                 }\n             }\n-            else if (allocdim == SMALLARRAYCAP)\n+            else if (data.length == SMALLARRAYCAP)\n             {\n-                allocdim = dim + nentries;\n-                data = (TYPE *)mem.xmalloc(allocdim * sizeof(*data));\n-                memcpy(data, &smallarray[0], dim * sizeof(*data));\n+                data.length = length + nentries;\n+                data.ptr = (TYPE *)mem.xmalloc(data.length * sizeof(TYPE));\n+                memcpy(data.ptr, &smallarray[0], length * sizeof(TYPE));\n             }\n             else\n             {\n                 /* Increase size by 1.5x to avoid excessive memory fragmentation\n                  */\n-                d_size_t increment = dim / 2;\n+                d_size_t increment = length / 2;\n                 if (nentries > increment)       // if 1.5 is not enough\n                     increment = nentries;\n-                allocdim = dim + increment;\n-                data = (TYPE *)mem.xrealloc(data, allocdim * sizeof(*data));\n+                data.length = length + increment;\n+                data.ptr = (TYPE *)mem.xrealloc(data.ptr, data.length * sizeof(TYPE));\n             }\n         }\n     }\n \n-    void setDim(d_size_t newdim)\n+    void remove(d_size_t i)\n     {\n-        if (dim < newdim)\n-        {\n-            reserve(newdim - dim);\n-        }\n-        dim = newdim;\n+        if (length - i - 1)\n+            memmove(data.ptr + i, data.ptr + i + 1, (length - i - 1) * sizeof(TYPE));\n+        length--;\n     }\n \n-    TYPE pop()\n+    void insert(d_size_t index, Array *a)\n     {\n-        return data[--dim];\n+        if (a)\n+        {\n+            d_size_t d = a->length;\n+            reserve(d);\n+            if (length != index)\n+                memmove(data.ptr + index + d, data.ptr + index, (length - index) * sizeof(TYPE));\n+            memcpy(data.ptr + index, a->data.ptr, d * sizeof(TYPE));\n+            length += d;\n+        }\n     }\n \n-    void shift(TYPE ptr)\n+    void insert(d_size_t index, TYPE ptr)\n     {\n         reserve(1);\n-        memmove(data + 1, data, dim * sizeof(*data));\n-        data[0] = ptr;\n-        dim++;\n-    }\n-\n-    void remove(d_size_t i)\n-    {\n-        if (dim - i - 1)\n-            memmove(data + i, data + i + 1, (dim - i - 1) * sizeof(data[0]));\n-        dim--;\n+        memmove(data.ptr + index + 1, data.ptr + index, (length - index) * sizeof(TYPE));\n+        data.ptr[index] = ptr;\n+        length++;\n     }\n \n-    void zero()\n+    void setDim(d_size_t newdim)\n     {\n-        memset(data,0,dim * sizeof(data[0]));\n+        if (length < newdim)\n+        {\n+            reserve(newdim - length);\n+        }\n+        length = newdim;\n     }\n \n-    void sort()\n+    d_size_t find(TYPE ptr) const\n     {\n-        struct ArraySort\n-        {\n-            static int\n-    #if _WIN32\n-              __cdecl\n-    #endif\n-            Array_sort_compare(const void *x, const void *y)\n-            {\n-                RootObject *ox = *(RootObject **)const_cast<void *>(x);\n-                RootObject *oy = *(RootObject **)const_cast<void *>(y);\n-\n-                return ox->compare(oy);\n-            }\n-        };\n-\n-        if (dim)\n+        for (d_size_t i = 0; i < length; i++)\n         {\n-            qsort(data, dim, sizeof(RootObject *), &ArraySort::Array_sort_compare);\n+            if (data.ptr[i] == ptr)\n+                return i;\n         }\n+        return SIZE_MAX;\n     }\n \n-    TYPE *tdata()\n+    bool contains(TYPE ptr) const\n     {\n-        return data;\n+        return find(ptr) != SIZE_MAX;\n     }\n \n     TYPE& operator[] (d_size_t index)\n     {\n-        return data[index];\n+#ifdef DEBUG\n+        assert(index < length);\n+#endif\n+        return data.ptr[index];\n     }\n \n-    void insert(d_size_t index, TYPE v)\n+    TYPE *tdata()\n     {\n-        reserve(1);\n-        memmove(data + index + 1, data + index, (dim - index) * sizeof(*data));\n-        data[index] = v;\n-        dim++;\n+        return data.ptr;\n     }\n \n-    void insert(d_size_t index, Array *a)\n+    Array *copy()\n     {\n-        if (a)\n-        {\n-            d_size_t d = a->dim;\n-            reserve(d);\n-            if (dim != index)\n-                memmove(data + index + d, data + index, (dim - index) * sizeof(*data));\n-            memcpy(data + index, a->data, d * sizeof(*data));\n-            dim += d;\n-        }\n+        Array *a = new Array();\n+        a->setDim(length);\n+        memcpy(a->data.ptr, data.ptr, length * sizeof(TYPE));\n+        return a;\n     }\n \n-    void append(Array *a)\n+    void shift(TYPE ptr)\n     {\n-        insert(dim, a);\n+        reserve(1);\n+        memmove(data.ptr + 1, data.ptr, length * sizeof(TYPE));\n+        data.ptr[0] = ptr;\n+        length++;\n     }\n \n-    void push(TYPE a)\n+    void zero()\n     {\n-        reserve(1);\n-        data[dim++] = a;\n+        memset(data.ptr, 0, length * sizeof(TYPE));\n     }\n \n-    Array *copy()\n+    TYPE pop()\n     {\n-        Array *a = new Array();\n-        a->setDim(dim);\n-        memcpy(a->data, data, dim * sizeof(*data));\n-        return a;\n+        return data.ptr[--length];\n     }\n-};\n-\n-struct BitArray\n-{\n-    BitArray()\n-      : len(0)\n-      , ptr(NULL)\n-    {}\n \n-    ~BitArray()\n+    void sort()\n     {\n-        mem.xfree(ptr);\n-    }\n+        struct ArraySort\n+        {\n+            static int\n+    #if _WIN32\n+              __cdecl\n+    #endif\n+            Array_sort_compare(const void *x, const void *y)\n+            {\n+                RootObject *ox = *(RootObject **)const_cast<void *>(x);\n+                RootObject *oy = *(RootObject **)const_cast<void *>(y);\n \n-    d_size_t len;\n-    d_size_t *ptr;\n+                return ox->compare(oy);\n+            }\n+        };\n \n-private:\n-    BitArray(const BitArray&);\n+        if (length)\n+        {\n+            qsort(data.ptr, length, sizeof(RootObject *), &ArraySort::Array_sort_compare);\n+        }\n+    }\n };\n+"}, {"sha": "fa01dd990d9b0b0aa5620ec9a963dc8a7df80104", "filename": "gcc/d/dmd/root/bitarray.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 2011-2020 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ * https://github.com/dlang/dmd/blob/master/src/dmd/root/bitarray.h\n+ */\n+\n+#pragma once\n+\n+#include \"dsystem.h\"\n+#include \"object.h\"\n+#include \"rmem.h\"\n+\n+struct BitArray\n+{\n+    BitArray()\n+      : len(0)\n+      , ptr(NULL)\n+    {}\n+\n+    ~BitArray()\n+    {\n+        mem.xfree(ptr);\n+    }\n+\n+    d_size_t len;\n+    d_size_t *ptr;\n+\n+private:\n+    BitArray(const BitArray&);\n+};"}, {"sha": "dc9a7883927af7c1d694071d280191047f05957b", "filename": "gcc/d/dmd/root/dcompat.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -18,3 +18,15 @@ struct DArray\n     size_t length;\n     T *ptr;\n };\n+\n+/// Corresponding C++ type that maps to D size_t\n+#if __APPLE__ && __i386__\n+// size_t is 'unsigned long', which makes it mangle differently than D's 'uint'\n+typedef unsigned d_size_t;\n+#elif MARS && DMD_VERSION >= 2079 && DMD_VERSION <= 2081 && \\\n+        __APPLE__ && __SIZEOF_SIZE_T__ == 8\n+// DMD versions between 2.079 and 2.081 mapped D ulong to uint64_t on OS X.\n+typedef uint64_t d_size_t;\n+#else\n+typedef size_t d_size_t;\n+#endif"}, {"sha": "88391df0f28473264a5d941c5e17dad16bff81c6", "filename": "gcc/d/dmd/root/filename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -425,7 +425,7 @@ const char *FileName::searchPath(Strings *path, const char *name, bool cwd)\n     if (path)\n     {\n \n-        for (size_t i = 0; i < path->dim; i++)\n+        for (size_t i = 0; i < path->length; i++)\n         {\n             const char *p = (*path)[i];\n             const char *n = combine(p, name);\n@@ -492,7 +492,7 @@ const char *FileName::safeSearchPath(Strings *path, const char *name)\n         /* Each path is converted to a cannonical name and then a check is done to see\n          * that the searched name is really a child one of the the paths searched.\n          */\n-        for (size_t i = 0; i < path->dim; i++)\n+        for (size_t i = 0; i < path->length; i++)\n         {\n             const char *cname = NULL;\n             const char *cpath = canonicalName((*path)[i]);"}, {"sha": "7f5e98091e96217e0513e943974fa8e0e6f1e969", "filename": "gcc/d/dmd/root/rmem.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -8,16 +8,7 @@\n \n #pragma once\n \n-#include \"dsystem.h\"    // for size_t\n-\n-#if __APPLE__ && __i386__\n-    /* size_t is 'unsigned long', which makes it mangle differently\n-     * than D's 'uint'\n-     */\n-    typedef unsigned d_size_t;\n-#else\n-    typedef size_t d_size_t;\n-#endif\n+#include \"dcompat.h\"    // for d_size_t\n \n struct Mem\n {"}, {"sha": "7df5c873c1ceaecffb7740d8f9cdd7e6ac0c1f4d", "filename": "gcc/d/dmd/root/stringtable.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -9,7 +9,7 @@\n #pragma once\n \n #include \"root.h\"\n-#include \"rmem.h\"   // for d_size_t\n+#include \"dcompat.h\" // for d_size_t\n \n struct StringEntry;\n "}, {"sha": "b15d2a8dabf0166b99b94b5c261e55934529dfe1", "filename": "gcc/d/dmd/sapply.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fsapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fsapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -55,14 +55,14 @@ class PostorderStatementVisitor : public StoppableVisitor\n     }\n     void visit(CompoundStatement *s)\n     {\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n             if (doCond((*s->statements)[i]))\n                 return;\n         applyTo(s);\n     }\n     void visit(UnrolledLoopStatement *s)\n     {\n-        for (size_t i = 0; i < s->statements->dim; i++)\n+        for (size_t i = 0; i < s->statements->length; i++)\n             if (doCond((*s->statements)[i]))\n                 return;\n         applyTo(s);\n@@ -124,7 +124,7 @@ class PostorderStatementVisitor : public StoppableVisitor\n         if (doCond(s->_body))\n             return;\n \n-        for (size_t i = 0; i < s->catches->dim; i++)\n+        for (size_t i = 0; i < s->catches->length; i++)\n             if (doCond((*s->catches)[i]->handler))\n                 return;\n         applyTo(s);"}, {"sha": "da305f465c9f2e9e1dc5864737ed416cb3600db0", "filename": "gcc/d/dmd/statement.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -360,7 +360,7 @@ Statement *toStatement(Dsymbol *s)\n                 return NULL;\n \n             Statements *statements = new Statements();\n-            for (size_t i = 0; i < a->dim; i++)\n+            for (size_t i = 0; i < a->length; i++)\n             {\n                 statements->push(toStatement((*a)[i]));\n             }\n@@ -376,7 +376,7 @@ Statement *toStatement(Dsymbol *s)\n         void visit(TemplateMixin *tm)\n         {\n             Statements *a = new Statements();\n-            for (size_t i = 0; i < tm->members->dim; i++)\n+            for (size_t i = 0; i < tm->members->length; i++)\n             {\n                 Statement *s = toStatement((*tm->members)[i]);\n                 if (s)\n@@ -561,8 +561,8 @@ CompoundStatement *CompoundStatement::create(Loc loc, Statement *s1, Statement *\n Statement *CompoundStatement::syntaxCopy()\n {\n     Statements *a = new Statements();\n-    a->setDim(statements->dim);\n-    for (size_t i = 0; i < statements->dim; i++)\n+    a->setDim(statements->length);\n+    for (size_t i = 0; i < statements->length; i++)\n     {\n         Statement *s = (*statements)[i];\n         (*a)[i] = s ? s->syntaxCopy() : NULL;\n@@ -579,7 +579,7 @@ ReturnStatement *CompoundStatement::isReturnStatement()\n {\n     ReturnStatement *rs = NULL;\n \n-    for (size_t i = 0; i < statements->dim; i++)\n+    for (size_t i = 0; i < statements->length; i++)\n     {\n         Statement *s = (*statements)[i];\n         if (s)\n@@ -596,7 +596,7 @@ Statement *CompoundStatement::last()\n {\n     Statement *s = NULL;\n \n-    for (size_t i = statements->dim; i; --i)\n+    for (size_t i = statements->length; i; --i)\n     {   s = (*statements)[i - 1];\n         if (s)\n         {\n@@ -619,8 +619,8 @@ CompoundDeclarationStatement::CompoundDeclarationStatement(Loc loc, Statements *\n Statement *CompoundDeclarationStatement::syntaxCopy()\n {\n     Statements *a = new Statements();\n-    a->setDim(statements->dim);\n-    for (size_t i = 0; i < statements->dim; i++)\n+    a->setDim(statements->length);\n+    for (size_t i = 0; i < statements->length; i++)\n     {\n         Statement *s = (*statements)[i];\n         (*a)[i] = s ? s->syntaxCopy() : NULL;\n@@ -639,8 +639,8 @@ UnrolledLoopStatement::UnrolledLoopStatement(Loc loc, Statements *s)\n Statement *UnrolledLoopStatement::syntaxCopy()\n {\n     Statements *a = new Statements();\n-    a->setDim(statements->dim);\n-    for (size_t i = 0; i < statements->dim; i++)\n+    a->setDim(statements->length);\n+    for (size_t i = 0; i < statements->length; i++)\n     {\n         Statement *s = (*statements)[i];\n         (*a)[i] = s ? s->syntaxCopy() : NULL;\n@@ -747,8 +747,8 @@ Statements *ForwardingStatement::flatten(Scope *sc)\n         return a;\n     }\n     Statements *b = new Statements();\n-    b->setDim(a->dim);\n-    for (size_t i = 0; i < a->dim; i++)\n+    b->setDim(a->length);\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Statement *s = (*a)[i];\n         (*b)[i] = s ? new ForwardingStatement(s->loc, sym, s) : NULL;\n@@ -887,7 +887,7 @@ bool ForeachStatement::checkForArgTypes()\n {\n     bool result = false;\n \n-    for (size_t i = 0; i < parameters->dim; i++)\n+    for (size_t i = 0; i < parameters->length; i++)\n     {\n         Parameter *p = (*parameters)[i];\n         if (!p->type)\n@@ -1151,7 +1151,7 @@ bool SwitchStatement::checkLabel()\n     if (sdefault && checkVar(this, sdefault->lastVar))\n         return !error; // return error once fully deprecated\n \n-    for (size_t i = 0; i < cases->dim; i++)\n+    for (size_t i = 0; i < cases->length; i++)\n     {\n         CaseStatement *scase = (*cases)[i];\n         if (scase && checkVar(this, scase->lastVar))\n@@ -1350,8 +1350,8 @@ TryCatchStatement::TryCatchStatement(Loc loc, Statement *body, Catches *catches)\n Statement *TryCatchStatement::syntaxCopy()\n {\n     Catches *a = new Catches();\n-    a->setDim(catches->dim);\n-    for (size_t i = 0; i < a->dim; i++)\n+    a->setDim(catches->length);\n+    for (size_t i = 0; i < a->length; i++)\n     {\n         Catch *c = (*catches)[i];\n         (*a)[i] = c->syntaxCopy();\n@@ -1515,7 +1515,7 @@ Statements *DebugStatement::flatten(Scope *sc)\n     Statements *a = statement ? statement->flatten(sc) : NULL;\n     if (a)\n     {\n-        for (size_t i = 0; i < a->dim; i++)\n+        for (size_t i = 0; i < a->length; i++)\n         {   Statement *s = (*a)[i];\n \n             s = new DebugStatement(loc, s);\n@@ -1640,7 +1640,7 @@ Statements *LabelStatement::flatten(Scope *sc)\n         a = statement->flatten(sc);\n         if (a)\n         {\n-            if (!a->dim)\n+            if (!a->length)\n             {\n                 a->push(new ExpStatement(loc, (Expression *)NULL));\n             }\n@@ -1737,8 +1737,8 @@ CompoundAsmStatement::CompoundAsmStatement(Loc loc, Statements *s, StorageClass\n CompoundAsmStatement *CompoundAsmStatement::syntaxCopy()\n {\n     Statements *a = new Statements();\n-    a->setDim(statements->dim);\n-    for (size_t i = 0; i < statements->dim; i++)\n+    a->setDim(statements->length);\n+    for (size_t i = 0; i < statements->length; i++)\n     {\n         Statement *s = (*statements)[i];\n         (*a)[i] = s ? s->syntaxCopy() : NULL;\n@@ -1762,8 +1762,8 @@ ImportStatement::ImportStatement(Loc loc, Dsymbols *imports)\n Statement *ImportStatement::syntaxCopy()\n {\n     Dsymbols *m = new Dsymbols();\n-    m->setDim(imports->dim);\n-    for (size_t i = 0; i < imports->dim; i++)\n+    m->setDim(imports->length);\n+    for (size_t i = 0; i < imports->length; i++)\n     {\n         Dsymbol *s = (*imports)[i];\n         (*m)[i] = s->syntaxCopy(NULL);"}, {"sha": "aac1c3094c8f205552248691d1ab99eb38b987c1", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -127,7 +127,7 @@ class StatementSemanticVisitor : public Visitor\n     void visit(CompoundStatement *cs)\n     {\n         //printf(\"CompoundStatement::semantic(this = %p, sc = %p)\\n\", cs, sc);\n-        for (size_t i = 0; i < cs->statements->dim; )\n+        for (size_t i = 0; i < cs->statements->length; )\n         {\n             Statement *s = (*cs->statements)[i];\n             if (s)\n@@ -158,7 +158,7 @@ class StatementSemanticVisitor : public Visitor\n                         sexception = semantic(sexception, sc);\n                     if (sexception)\n                     {\n-                        if (i + 1 == cs->statements->dim && !sfinally)\n+                        if (i + 1 == cs->statements->length && !sfinally)\n                         {\n                         }\n                         else\n@@ -172,7 +172,7 @@ class StatementSemanticVisitor : public Visitor\n                              *      { sexception; throw __o; }\n                              */\n                             Statements *a = new Statements();\n-                            for (size_t j = i + 1; j < cs->statements->dim; j++)\n+                            for (size_t j = i + 1; j < cs->statements->length; j++)\n                             {\n                                 a->push((*cs->statements)[j]);\n                             }\n@@ -206,7 +206,7 @@ class StatementSemanticVisitor : public Visitor\n                     }\n                     else if (sfinally)\n                     {\n-                        if (0 && i + 1 == cs->statements->dim)\n+                        if (0 && i + 1 == cs->statements->length)\n                         {\n                             cs->statements->push(sfinally);\n                         }\n@@ -218,7 +218,7 @@ class StatementSemanticVisitor : public Visitor\n                              *      s; try { s1; s2; } finally { sfinally; }\n                              */\n                             Statements *a = new Statements();\n-                            for (size_t j = i + 1; j < cs->statements->dim; j++)\n+                            for (size_t j = i + 1; j < cs->statements->length; j++)\n                             {\n                                 a->push((*cs->statements)[j]);\n                             }\n@@ -241,7 +241,7 @@ class StatementSemanticVisitor : public Visitor\n             }\n             i++;\n         }\n-        for (size_t i = 0; i < cs->statements->dim; ++i)\n+        for (size_t i = 0; i < cs->statements->length; ++i)\n         {\n         Lagain:\n             Statement *s = (*cs->statements)[i];\n@@ -263,12 +263,12 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 cs->statements->remove(i);\n                 cs->statements->insert(i, flt);\n-                if (cs->statements->dim <= i)\n+                if (cs->statements->length <= i)\n                     break;\n                 goto Lagain;\n             }\n         }\n-        if (cs->statements->dim == 1)\n+        if (cs->statements->length == 1)\n         {\n             result = (*cs->statements)[0];\n             return;\n@@ -284,7 +284,7 @@ class StatementSemanticVisitor : public Visitor\n         scd->scontinue = uls;\n \n         Statement *serror = NULL;\n-        for (size_t i = 0; i < uls->statements->dim; i++)\n+        for (size_t i = 0; i < uls->statements->length; i++)\n         {\n             Statement *s = (*uls->statements)[i];\n             if (s)\n@@ -634,7 +634,7 @@ class StatementSemanticVisitor : public Visitor\n         Statements *stmts = (isDecl) ? NULL : new Statements();\n         Dsymbols *decls = (isDecl) ? new Dsymbols() : NULL;\n \n-        size_t dim = fs->parameters->dim;\n+        size_t dim = fs->parameters->length;\n         if (!needExpansion && dim == 2)\n         {\n             // Declare key\n@@ -772,7 +772,7 @@ class StatementSemanticVisitor : public Visitor\n                           Statements *statements, Dsymbols *declarations, Dsymbols *dbody)\n     {\n         Loc loc = fs->loc;\n-        size_t dim = fs->parameters->dim;\n+        size_t dim = fs->parameters->length;\n         if (!needExpansion && (dim < 1 || dim > 2))\n         {\n             fs->error(\"only one (value) or two (key,value) arguments for tuple foreach\");\n@@ -795,7 +795,7 @@ class StatementSemanticVisitor : public Visitor\n         if (fs->aggr->op == TOKtuple)       // expression tuple\n         {\n             te = (TupleExp *)fs->aggr;\n-            n = te->exps->dim;\n+            n = te->exps->length;\n         }\n         else if (fs->aggr->op == TOKtype)   // type tuple\n         {\n@@ -841,7 +841,7 @@ class StatementSemanticVisitor : public Visitor\n         ScopeDsymbol *sym;\n         Statement *s = fs;\n         Loc loc = fs->loc;\n-        size_t dim = fs->parameters->dim;\n+        size_t dim = fs->parameters->length;\n         TypeAArray *taa = NULL;\n         Dsymbol *sapply = NULL;\n \n@@ -915,7 +915,7 @@ class StatementSemanticVisitor : public Visitor\n                 }\n             }\n \n-            //printf(\"dim = %d, parameters->dim = %d\\n\", dim, fs->parameters->dim);\n+            //printf(\"dim = %d, parameters->length = %d\\n\", dim, fs->parameters->length);\n             if (foundMismatch && dim != foreachParamCount)\n             {\n                 const char *plural = foreachParamCount > 1 ? \"s\" : \"\";\n@@ -1128,7 +1128,7 @@ class StatementSemanticVisitor : public Visitor\n                         !((*fs->parameters)[dim - 1]->storageClass & STCref))\n                     {\n                         ArrayLiteralExp *ale = (ArrayLiteralExp *)fs->aggr;\n-                        size_t edim = ale->elements ? ale->elements->dim : 0;\n+                        size_t edim = ale->elements ? ale->elements->length : 0;\n                         Type *telem = (*fs->parameters)[dim - 1]->type;\n \n                         // Bugzilla 12936: if telem has been specified explicitly,\n@@ -1362,17 +1362,17 @@ class StatementSemanticVisitor : public Visitor\n                         Expressions *exps = new Expressions();\n                         exps->push(ve);\n                         int pos = 0;\n-                        while (exps->dim < dim)\n+                        while (exps->length < dim)\n                         {\n                             pos = expandAliasThisTuples(exps, pos);\n                             if (pos == -1)\n                                 break;\n                         }\n-                        if (exps->dim != dim)\n+                        if (exps->length != dim)\n                         {\n-                            const char *plural = exps->dim > 1 ? \"s\" : \"\";\n+                            const char *plural = exps->length > 1 ? \"s\" : \"\";\n                             fs->error(\"cannot infer argument types, expected %d argument%s, not %d\",\n-                                      exps->dim, plural, dim);\n+                                      exps->length, plural, dim);\n                             goto Lerror2;\n                         }\n \n@@ -1433,7 +1433,7 @@ class StatementSemanticVisitor : public Visitor\n                             tfld = (TypeFunction *)tab->nextOf();\n                         Lget:\n                             //printf(\"tfld = %s\\n\", tfld->toChars());\n-                            if (tfld->parameters->dim == 1)\n+                            if (tfld->parameters->length == 1)\n                             {\n                                 Parameter *p = Parameter::getNth(tfld->parameters, 0);\n                                 if (p->type && p->type->ty == Tdelegate)\n@@ -1507,14 +1507,14 @@ class StatementSemanticVisitor : public Visitor\n                     fld->tookAddressOf = 0;\n \n                     // Resolve any forward referenced goto's\n-                    for (size_t i = 0; i < fs->gotos->dim; i++)\n+                    for (size_t i = 0; i < fs->gotos->length; i++)\n                     {\n                         GotoStatement *gs = (GotoStatement *)(*fs->gotos)[i]->statement;\n                         if (!gs->label->statement)\n                         {\n                             // 'Promote' it to this scope, and replace with a return\n                             fs->cases->push(gs);\n-                            s = new ReturnStatement(Loc(), new IntegerExp(fs->cases->dim + 1));\n+                            s = new ReturnStatement(Loc(), new IntegerExp(fs->cases->length + 1));\n                             (*fs->gotos)[i]->statement = s;\n                         }\n                     }\n@@ -1701,7 +1701,7 @@ class StatementSemanticVisitor : public Visitor\n                     }\n                     e = Expression::combine(e, ec);\n \n-                    if (!fs->cases->dim)\n+                    if (!fs->cases->length)\n                     {\n                         // Easy case, a clean exit from the loop\n                         e = new CastExp(loc, e, Type::tvoid);   // Bugzilla 13899\n@@ -1719,7 +1719,7 @@ class StatementSemanticVisitor : public Visitor\n                         a->push(s);\n \n                         // cases 2...\n-                        for (size_t i = 0; i < fs->cases->dim; i++)\n+                        for (size_t i = 0; i < fs->cases->length; i++)\n                         {\n                             s = (*fs->cases)[i];\n                             s = new CaseStatement(Loc(), new IntegerExp(i + 2), s);\n@@ -2054,7 +2054,7 @@ class StatementSemanticVisitor : public Visitor\n         {\n             if (ps->args)\n             {\n-                for (size_t i = 0; i < ps->args->dim; i++)\n+                for (size_t i = 0; i < ps->args->length; i++)\n                 {\n                     Expression *e = (*ps->args)[i];\n \n@@ -2090,7 +2090,7 @@ class StatementSemanticVisitor : public Visitor\n         }\n         else if (ps->ident == Id::startaddress)\n         {\n-            if (!ps->args || ps->args->dim != 1)\n+            if (!ps->args || ps->args->length != 1)\n                 ps->error(\"function name expected for start address\");\n             else\n             {\n@@ -2125,9 +2125,9 @@ class StatementSemanticVisitor : public Visitor\n         else if (ps->ident == Id::Pinline)\n         {\n             PINLINE inlining = PINLINEdefault;\n-            if (!ps->args || ps->args->dim == 0)\n+            if (!ps->args || ps->args->length == 0)\n                 inlining = PINLINEdefault;\n-            else if (!ps->args || ps->args->dim != 1)\n+            else if (!ps->args || ps->args->length != 1)\n             {\n                 ps->error(\"boolean expression expected for pragma(inline)\");\n                 goto Lerror;\n@@ -2261,7 +2261,7 @@ class StatementSemanticVisitor : public Visitor\n             goto Lerror;\n \n         // Resolve any goto case's with exp\n-        for (size_t i = 0; i < ss->gotoCases.dim; i++)\n+        for (size_t i = 0; i < ss->gotoCases.length; i++)\n         {\n             GotoCaseStatement *gcs = ss->gotoCases[i];\n \n@@ -2275,7 +2275,7 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 if (!scx->sw)\n                     continue;\n-                for (size_t j = 0; j < scx->sw->cases->dim; j++)\n+                for (size_t j = 0; j < scx->sw->cases->length; j++)\n                 {\n                     CaseStatement *cs = (*scx->sw->cases)[j];\n \n@@ -2304,13 +2304,13 @@ class StatementSemanticVisitor : public Visitor\n                 ed = ds->isEnumDeclaration();\n             if (ed)\n             {\n-                size_t dim = ed->members->dim;\n+                size_t dim = ed->members->length;\n                 for (size_t i = 0; i < dim; i++)\n                 {\n                     EnumMember *em = (*ed->members)[i]->isEnumMember();\n                     if (em)\n                     {\n-                        for (size_t j = 0; j < ss->cases->dim; j++)\n+                        for (size_t j = 0; j < ss->cases->length; j++)\n                         {\n                             CaseStatement *cs = (*ss->cases)[j];\n                             if (cs->exp->equals(em->value()) ||\n@@ -2459,7 +2459,7 @@ class StatementSemanticVisitor : public Visitor\n             }\n \n         L1:\n-            for (size_t i = 0; i < sw->cases->dim; i++)\n+            for (size_t i = 0; i < sw->cases->length; i++)\n             {\n                 CaseStatement *cs2 = (*sw->cases)[i];\n \n@@ -2475,7 +2475,7 @@ class StatementSemanticVisitor : public Visitor\n             sw->cases->push(cs);\n \n             // Resolve any goto case's with no exp to this case statement\n-            for (size_t i = 0; i < sw->gotoCases.dim; )\n+            for (size_t i = 0; i < sw->gotoCases.length; )\n             {\n                 GotoCaseStatement *gcs = sw->gotoCases[i];\n \n@@ -2691,7 +2691,7 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 assert(rs->caseDim == 0);\n                 sc->fes->cases->push(rs);\n-                result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->dim + 1));\n+                result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->length + 1));\n                 return;\n             }\n             if (fd->returnLabel)\n@@ -2972,8 +2972,8 @@ class StatementSemanticVisitor : public Visitor\n                 sc->fes->cases->push(s);\n \n                 // Immediately rewrite \"this\" return statement as:\n-                //  return cases->dim+1;\n-                rs->exp = new IntegerExp(sc->fes->cases->dim + 1);\n+                //  return cases->length+1;\n+                rs->exp = new IntegerExp(sc->fes->cases->length + 1);\n                 if (e0)\n                 {\n                     result = new CompoundStatement(rs->loc, new ExpStatement(rs->loc, e0), rs);\n@@ -2997,7 +2997,7 @@ class StatementSemanticVisitor : public Visitor\n                 //  return exp;\n                 // to:\n                 //  vresult = exp; retrun caseDim;\n-                rs->caseDim = sc->fes->cases->dim + 1;\n+                rs->caseDim = sc->fes->cases->length + 1;\n             }\n         }\n         if (rs->exp)\n@@ -3039,7 +3039,7 @@ class StatementSemanticVisitor : public Visitor\n                          * and 1 is break.\n                          */\n                         sc->fes->cases->push(bs);\n-                        result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->dim + 1));\n+                        result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->length + 1));\n                         return;\n                     }\n                     break;                  // can't break to it\n@@ -3126,7 +3126,7 @@ class StatementSemanticVisitor : public Visitor\n                          * and 1 is break.\n                          */\n                         sc->fes->cases->push(cs);\n-                        result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->dim + 1));\n+                        result = new ReturnStatement(Loc(), new IntegerExp(sc->fes->cases->length + 1));\n                         return;\n                     }\n                     break;                  // can't continue to it\n@@ -3429,7 +3429,7 @@ class StatementSemanticVisitor : public Visitor\n         /* Even if body is empty, still do semantic analysis on catches\n         */\n         bool catchErrors = false;\n-        for (size_t i = 0; i < tcs->catches->dim; i++)\n+        for (size_t i = 0; i < tcs->catches->length; i++)\n         {\n             Catch *c = (*tcs->catches)[i];\n             semantic(c, sc);\n@@ -3480,7 +3480,7 @@ class StatementSemanticVisitor : public Visitor\n \n         if (!(blockExit(tcs->_body, sc->func, false) & BEthrow) && ClassDeclaration::exception)\n         {\n-            for (size_t i = 0; i < tcs->catches->dim; i++)\n+            for (size_t i = 0; i < tcs->catches->length; i++)\n             {\n                 Catch *c = (*tcs->catches)[i];\n \n@@ -3496,7 +3496,7 @@ class StatementSemanticVisitor : public Visitor\n             }\n         }\n \n-        if (tcs->catches->dim == 0)\n+        if (tcs->catches->length == 0)\n         {\n             result = tcs->_body->hasCode() ? tcs->_body : NULL;\n             return;\n@@ -3717,7 +3717,7 @@ class StatementSemanticVisitor : public Visitor\n         sc = sc->push();\n         sc->stc |= cas->stc;\n \n-        for (size_t i = 0; i < cas->statements->dim; i++)\n+        for (size_t i = 0; i < cas->statements->length; i++)\n         {\n             Statement *s = (*cas->statements)[i];\n             (*cas->statements)[i] = s ? semantic(s, sc) : NULL;\n@@ -3739,11 +3739,11 @@ class StatementSemanticVisitor : public Visitor\n \n     void visit(ImportStatement *imps)\n     {\n-        for (size_t i = 0; i < imps->imports->dim; i++)\n+        for (size_t i = 0; i < imps->imports->length; i++)\n         {\n             Import *s = (*imps->imports)[i]->isImport();\n-            assert(!s->aliasdecls.dim);\n-            for (size_t j = 0; j < s->names.dim; j++)\n+            assert(!s->aliasdecls.length);\n+            for (size_t j = 0; j < s->names.length; j++)\n             {\n                 Identifier *name = s->names[j];\n                 Identifier *alias = s->aliases[j];\n@@ -3766,7 +3766,7 @@ class StatementSemanticVisitor : public Visitor\n                 Module::addDeferredSemantic2(s);     // Bugzilla 14666\n                 sc->insert(s);\n \n-                for (size_t j = 0; j < s->aliasdecls.dim; j++)\n+                for (size_t j = 0; j < s->aliasdecls.length; j++)\n                 {\n                     sc->insert(s->aliasdecls[j]);\n                 }"}, {"sha": "c38a4abdb498ee5d42c6546428d908089cfc1e40", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -97,7 +97,7 @@ static void collectUnitTests(Dsymbols *symbols, AA *uniqueUnitTests, Expressions\n {\n     if (!symbols)\n         return;\n-    for (size_t i = 0; i < symbols->dim; i++)\n+    for (size_t i = 0; i < symbols->length; i++)\n     {\n         Dsymbol *symbol = (*symbols)[i];\n         UnitTestDeclaration *unitTest = symbol->isUnitTestDeclaration();\n@@ -143,9 +143,9 @@ bool isTypeFinalClass(Type *t)       { return t->toBasetype()->ty == Tclass && (\n \n Expression *isTypeX(TraitsExp *e, bool (*fp)(Type *t))\n {\n-    if (!e->args || !e->args->dim)\n+    if (!e->args || !e->args->length)\n         return False(e);\n-    for (size_t i = 0; i < e->args->dim; i++)\n+    for (size_t i = 0; i < e->args->length; i++)\n     {\n         Type *t = getType((*e->args)[i]);\n         if (!t || !fp(t))\n@@ -163,9 +163,9 @@ bool isFuncOverrideFunction(FuncDeclaration *f) { return f->isOverride(); }\n \n Expression *isFuncX(TraitsExp *e, bool (*fp)(FuncDeclaration *f))\n {\n-    if (!e->args || !e->args->dim)\n+    if (!e->args || !e->args->length)\n         return False(e);\n-    for (size_t i = 0; i < e->args->dim; i++)\n+    for (size_t i = 0; i < e->args->length; i++)\n     {\n         Dsymbol *s = getDsymbol((*e->args)[i]);\n         if (!s)\n@@ -183,9 +183,9 @@ bool isDeclLazy(Declaration *d) { return (d->storage_class & STClazy) != 0; }\n \n Expression *isDeclX(TraitsExp *e, bool (*fp)(Declaration *d))\n {\n-    if (!e->args || !e->args->dim)\n+    if (!e->args || !e->args->length)\n         return False(e);\n-    for (size_t i = 0; i < e->args->dim; i++)\n+    for (size_t i = 0; i < e->args->length; i++)\n     {\n         Dsymbol *s = getDsymbol((*e->args)[i]);\n         if (!s)\n@@ -309,9 +309,9 @@ bool isTemplate(Dsymbol *s)\n \n Expression *isSymbolX(TraitsExp *e, bool (*fp)(Dsymbol *s))\n {\n-    if (!e->args || !e->args->dim)\n+    if (!e->args || !e->args->length)\n         return False(e);\n-    for (size_t i = 0; i < e->args->dim; i++)\n+    for (size_t i = 0; i < e->args->length; i++)\n     {\n         Dsymbol *s = getDsymbol((*e->args)[i]);\n         if (!s || !fp(s))\n@@ -332,7 +332,7 @@ Expression *isSymbolX(TraitsExp *e, bool (*fp)(Dsymbol *s))\n  */\n Expression *pointerBitmap(TraitsExp *e)\n {\n-    if (!e->args || e->args->dim != 1)\n+    if (!e->args || e->args->length != 1)\n     {\n         error(e->loc, \"a single type expected for trait pointerBitmap\");\n         return new ErrorExp();\n@@ -430,7 +430,7 @@ Expression *pointerBitmap(TraitsExp *e)\n         virtual void visit(TypeStruct *t)\n         {\n             d_uns64 structoff = offset;\n-            for (size_t i = 0; i < t->sym->fields.dim; i++)\n+            for (size_t i = 0; i < t->sym->fields.length; i++)\n             {\n                 VarDeclaration *v = t->sym->fields[i];\n                 offset = structoff + v->offset;\n@@ -451,7 +451,7 @@ Expression *pointerBitmap(TraitsExp *e)\n             if (t->sym->baseClass)\n                 visitClass((TypeClass*)t->sym->baseClass->type);\n \n-            for (size_t i = 0; i < t->sym->fields.dim; i++)\n+            for (size_t i = 0; i < t->sym->fields.length; i++)\n             {\n                 VarDeclaration *v = t->sym->fields[i];\n                 offset = classoff + v->offset;\n@@ -497,7 +497,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         if (!TemplateInstance::semanticTiargs(e->loc, sc, e->args, 1))\n             return new ErrorExp();\n     }\n-    size_t dim = e->args ? e->args->dim : 0;\n+    size_t dim = e->args ? e->args->length : 0;\n \n     if (e->ident == Id::isArithmetic)\n     {\n@@ -1242,7 +1242,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n                     /* Skip if already present in idents[]\n                      */\n-                    for (size_t j = 0; j < idents->dim; j++)\n+                    for (size_t j = 0; j < idents->length; j++)\n                     {\n                         Identifier *id = (*idents)[j];\n                         if (id == sm->ident)\n@@ -1278,12 +1278,12 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             {\n                 static void dg(ClassDeclaration *cd, PushIdentsDg *ctx)\n                 {\n-                    for (size_t i = 0; i < cd->baseclasses->dim; i++)\n+                    for (size_t i = 0; i < cd->baseclasses->length; i++)\n                     {\n                         ClassDeclaration *cb = (*cd->baseclasses)[i]->sym;\n                         assert(cb);\n                         ScopeDsymbol_foreach(NULL, cb->members, &PushIdentsDg::dg, ctx);\n-                        if (cb->baseclasses->dim)\n+                        if (cb->baseclasses->length)\n                             dg(cb, ctx);\n                     }\n                 }\n@@ -1294,7 +1294,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         // Turn Identifiers into StringExps reusing the allocated array\n         assert(sizeof(Expressions) == sizeof(Identifiers));\n         Expressions *exps = (Expressions *)idents;\n-        for (size_t i = 0; i < idents->dim; i++)\n+        for (size_t i = 0; i < idents->length; i++)\n         {\n             Identifier *id = (*idents)[i];\n             StringExp *se = new StringExp(e->loc, const_cast<char *>(id->toChars()));"}, {"sha": "2933e983b019caf458d3b7a56c8d4993c94c6194", "filename": "gcc/d/dmd/typesem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ftypesem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fdmd%2Ftypesem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.c?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -82,7 +82,7 @@ Expression *typeToExpression(Type *t)\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i)\n {\n     //printf(\"toExpressionHelper(e = %s %s)\\n\", Token::toChars(e->op), e->toChars());\n-    for (; i < t->idents.dim; i++)\n+    for (; i < t->idents.length; i++)\n     {\n         RootObject *id = t->idents[i];\n         //printf(\"\\t[%d] e: '%s', id: '%s'\\n\", i, e->toChars(), id->toChars());"}, {"sha": "461124f704eef6d13244bb0e597925cc2857f09a", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -1642,7 +1642,7 @@ class ExprVisitor : public Visitor\n       {\n \tStructDeclaration *sd = ((TypeStruct *) tnext)->sym;\n \n-\tfor (size_t i = 0; i < sd->fields.dim; i++)\n+\tfor (size_t i = 0; i < sd->fields.length; i++)\n \t  {\n \t    VarDeclaration *field = sd->fields[i];\n \n@@ -2439,7 +2439,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    /* If we have a user supplied initializer, then set-up with a\n \t       struct literal.  */\n-\t    if (e->arguments != NULL && sd->fields.dim != 0)\n+\t    if (e->arguments != NULL && sd->fields.length != 0)\n \t      {\n \t\tStructLiteralExp *se = StructLiteralExp::create (e->loc, sd,\n \t\t\t\t\t\t\t\t e->arguments,\n@@ -2464,9 +2464,9 @@ class ExprVisitor : public Visitor\n \tTypeDArray *tarray = (TypeDArray *) tb;\n \n \tgcc_assert (!e->allocator);\n-\tgcc_assert (e->arguments && e->arguments->dim >= 1);\n+\tgcc_assert (e->arguments && e->arguments->length >= 1);\n \n-\tif (e->arguments->dim == 1)\n+\tif (e->arguments->length == 1)\n \t  {\n \t    /* Single dimension array allocations.  */\n \t    Expression *arg = (*e->arguments)[0];\n@@ -2488,14 +2488,14 @@ class ExprVisitor : public Visitor\n \telse\n \t  {\n \t    /* Multidimensional array allocations.  */\n-\t    tree tarray = make_array_type (Type::tsize_t, e->arguments->dim);\n+\t    tree tarray = make_array_type (Type::tsize_t, e->arguments->length);\n \t    tree var = build_local_temp (tarray);\n \t    vec<constructor_elt, va_gc> *elms = NULL;\n \n \t    /* Get the base element type for the array, generating the\n \t       initializer for the dims parameter along the way.  */\n \t    Type *telem = e->newtype->toBasetype ();\n-\t    for (size_t i = 0; i < e->arguments->dim; i++)\n+\t    for (size_t i = 0; i < e->arguments->length; i++)\n \t      {\n \t\tExpression *arg = (*e->arguments)[i];\n \t\tCONSTRUCTOR_APPEND_ELT (elms, size_int (i), build_expr (arg));\n@@ -2516,7 +2516,7 @@ class ExprVisitor : public Visitor\n \n \t    tree tinfo = build_typeinfo (e->loc, e->type);\n \t    tree dims = d_array_value (build_ctype (Type::tsize_t->arrayOf ()),\n-\t\t\t\t       size_int (e->arguments->dim),\n+\t\t\t\t       size_int (e->arguments->length),\n \t\t\t\t       build_address (var));\n \n \t    result = build_libcall (libcall, tb, 2, tinfo, dims);\n@@ -2544,7 +2544,7 @@ class ExprVisitor : public Visitor\n \ttree arg = build_typeinfo (e->loc, e->newtype);\n \tresult = build_libcall (libcall, tb, 1, arg);\n \n-\tif (e->arguments && e->arguments->dim == 1)\n+\tif (e->arguments && e->arguments->length == 1)\n \t  {\n \t    result = d_save_expr (result);\n \t    tree init = modify_expr (build_deref (result),\n@@ -2661,7 +2661,7 @@ class ExprVisitor : public Visitor\n     if (e->e0)\n       result = build_expr (e->e0);\n \n-    for (size_t i = 0; i < e->exps->dim; ++i)\n+    for (size_t i = 0; i < e->exps->length; ++i)\n       {\n \tExpression *exp = (*e->exps)[i];\n \tresult = compound_expr (result, build_expr (exp));\n@@ -2688,7 +2688,7 @@ class ExprVisitor : public Visitor\n     gcc_assert (tb->ty == Tarray || tb->ty == Tsarray || tb->ty == Tpointer);\n \n     /* Handle empty array literals.  */\n-    if (e->elements->dim == 0)\n+    if (e->elements->length == 0)\n       {\n \tif (tb->ty == Tarray)\n \t  this->result_ = d_array_value (build_ctype (e->type),\n@@ -2703,14 +2703,14 @@ class ExprVisitor : public Visitor\n     /* Build an expression that assigns the expressions in ELEMENTS to\n        a constructor.  */\n     vec<constructor_elt, va_gc> *elms = NULL;\n-    vec_safe_reserve (elms, e->elements->dim);\n+    vec_safe_reserve (elms, e->elements->length);\n     bool constant_p = true;\n     tree saved_elems = NULL_TREE;\n \n     Type *etype = tb->nextOf ();\n-    tree satype = make_array_type (etype, e->elements->dim);\n+    tree satype = make_array_type (etype, e->elements->length);\n \n-    for (size_t i = 0; i < e->elements->dim; i++)\n+    for (size_t i = 0; i < e->elements->length; i++)\n       {\n \tExpression *expr = e->getElement (i);\n \ttree value = build_expr (expr, this->constp_);\n@@ -2749,7 +2749,7 @@ class ExprVisitor : public Visitor\n \t    tree decl = build_artificial_decl (TREE_TYPE (ctor), ctor, \"A\");\n \t    ctor = build_address (decl);\n \t    if (tb->ty == Tarray)\n-\t      ctor = d_array_value (type, size_int (e->elements->dim), ctor);\n+\t      ctor = d_array_value (type, size_int (e->elements->length), ctor);\n \n \t    d_pushdecl (decl);\n \t    rest_of_decl_compilation (decl, 1, 0);\n@@ -2769,12 +2769,12 @@ class ExprVisitor : public Visitor\n \ttree mem = build_libcall (LIBCALL_ARRAYLITERALTX,\n \t\t\t\t  etype->pointerTo (), 2,\n \t\t\t\t  build_typeinfo (e->loc, etype->arrayOf ()),\n-\t\t\t\t  size_int (e->elements->dim));\n+\t\t\t\t  size_int (e->elements->length));\n \tmem = d_save_expr (mem);\n \n \t/* Now copy the constructor into memory.  */\n \ttree tmemcpy = builtin_decl_explicit (BUILT_IN_MEMCPY);\n-\ttree size = size_mult_expr (size_int (e->elements->dim),\n+\ttree size = size_mult_expr (size_int (e->elements->length),\n \t\t\t\t    size_int (tb->nextOf ()->size ()));\n \n \ttree result = build_call_expr (tmemcpy, 3, mem,\n@@ -2784,7 +2784,7 @@ class ExprVisitor : public Visitor\n \tresult = compound_expr (result, mem);\n \n \tif (tb->ty == Tarray)\n-\t  result = d_array_value (type, size_int (e->elements->dim), result);\n+\t  result = d_array_value (type, size_int (e->elements->length), result);\n \n \tthis->result_ = compound_expr (saved_elems, result);\n       }\n@@ -2802,7 +2802,7 @@ class ExprVisitor : public Visitor\n \n     /* Handle empty assoc array literals.  */\n     TypeAArray *ta = (TypeAArray *) tb;\n-    if (e->keys->dim == 0)\n+    if (e->keys->length == 0)\n       {\n \tthis->result_ = build_constructor (build_ctype (ta), NULL);\n \treturn;\n@@ -2811,35 +2811,35 @@ class ExprVisitor : public Visitor\n     /* Build an expression that assigns all expressions in KEYS\n        to a constructor.  */\n     vec<constructor_elt, va_gc> *kelts = NULL;\n-    vec_safe_reserve (kelts, e->keys->dim);\n-    for (size_t i = 0; i < e->keys->dim; i++)\n+    vec_safe_reserve (kelts, e->keys->length);\n+    for (size_t i = 0; i < e->keys->length; i++)\n       {\n \tExpression *key = (*e->keys)[i];\n \ttree t = build_expr (key);\n \tCONSTRUCTOR_APPEND_ELT (kelts, size_int (i),\n \t\t\t\tconvert_expr (t, key->type, ta->index));\n       }\n-    tree tkeys = make_array_type (ta->index, e->keys->dim);\n+    tree tkeys = make_array_type (ta->index, e->keys->length);\n     tree akeys = build_constructor (tkeys, kelts);\n \n     /* Do the same with all expressions in VALUES.  */\n     vec<constructor_elt, va_gc> *velts = NULL;\n-    vec_safe_reserve (velts, e->values->dim);\n-    for (size_t i = 0; i < e->values->dim; i++)\n+    vec_safe_reserve (velts, e->values->length);\n+    for (size_t i = 0; i < e->values->length; i++)\n       {\n \tExpression *value = (*e->values)[i];\n \ttree t = build_expr (value);\n \tCONSTRUCTOR_APPEND_ELT (velts, size_int (i),\n \t\t\t\tconvert_expr (t, value->type, ta->next));\n       }\n-    tree tvals = make_array_type (ta->next, e->values->dim);\n+    tree tvals = make_array_type (ta->next, e->values->length);\n     tree avals = build_constructor (tvals, velts);\n \n     /* Generate: _d_assocarrayliteralTX (ti, keys, vals);  */\n     tree keys = d_array_value (build_ctype (ta->index->arrayOf ()),\n-\t\t\t       size_int (e->keys->dim), build_address (akeys));\n+\t\t\t       size_int (e->keys->length), build_address (akeys));\n     tree vals = d_array_value (build_ctype (ta->next->arrayOf ()),\n-\t\t\t       size_int (e->values->dim),\n+\t\t\t       size_int (e->values->length),\n \t\t\t       build_address (avals));\n \n     tree mem = build_libcall (LIBCALL_ASSOCARRAYLITERALTX, Type::tvoidptr, 3,\n@@ -2859,7 +2859,7 @@ class ExprVisitor : public Visitor\n   void visit (StructLiteralExp *e)\n   {\n     /* Handle empty struct literals.  */\n-    if (e->elements == NULL || e->sd->fields.dim == 0)\n+    if (e->elements == NULL || e->sd->fields.length == 0)\n       {\n \tthis->result_ = build_constructor (build_ctype (e->type), NULL);\n \treturn;\n@@ -2879,12 +2879,12 @@ class ExprVisitor : public Visitor\n     tree saved_elems = NULL_TREE;\n \n     /* CTFE may fill the hidden pointer by NullExp.  */\n-    gcc_assert (e->elements->dim <= e->sd->fields.dim);\n+    gcc_assert (e->elements->length <= e->sd->fields.length);\n \n     Type *tb = e->type->toBasetype ();\n     gcc_assert (tb->ty == Tstruct);\n \n-    for (size_t i = 0; i < e->elements->dim; i++)\n+    for (size_t i = 0; i < e->elements->length; i++)\n       {\n \tExpression *exp = (*e->elements)[i];\n \tif (!exp)\n@@ -2921,7 +2921,7 @@ class ExprVisitor : public Visitor\n       }\n \n     /* Maybe setup hidden pointer to outer scope context.  */\n-    if (e->sd->isNested () && e->elements->dim != e->sd->fields.dim\n+    if (e->sd->isNested () && e->elements->length != e->sd->fields.length\n \t&& this->constp_ == false)\n       {\n \ttree field = get_symbol_decl (e->sd->vthis);\n@@ -2989,8 +2989,8 @@ class ExprVisitor : public Visitor\n \tvec<constructor_elt, va_gc> *elms = NULL;\n \tbool constant_p = true;\n \n-\tvec_safe_reserve (elms, ale->elements->dim);\n-\tfor (size_t i = 0; i < ale->elements->dim; i++)\n+\tvec_safe_reserve (elms, ale->elements->length);\n+\tfor (size_t i = 0; i < ale->elements->length; i++)\n \t  {\n \t    Expression *expr = ale->getElement (i);\n \t    tree value = d_convert (etype, build_expr (expr, this->constp_));"}, {"sha": "0ff41630f05a7d60c1500b6a572532ae93fcf90d", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -506,8 +506,8 @@ layout_moduleinfo_fields (Module *decl, tree type)\n \n   /* Array of module imports is laid out as a length field, followed by\n      a static array of ModuleInfo pointers.  */\n-  size_t aimports_dim = decl->aimports.dim;\n-  for (size_t i = 0; i < decl->aimports.dim; i++)\n+  size_t aimports_dim = decl->aimports.length;\n+  for (size_t i = 0; i < decl->aimports.length; i++)\n     {\n       Module *mi = decl->aimports[i];\n       if (!mi->needmoduleinfo)\n@@ -523,16 +523,17 @@ layout_moduleinfo_fields (Module *decl, tree type)\n \n   /* Array of local ClassInfo decls are laid out in the same way.  */\n   ClassDeclarations aclasses;\n-  for (size_t i = 0; i < decl->members->dim; i++)\n+  for (size_t i = 0; i < decl->members->length; i++)\n     {\n       Dsymbol *member = (*decl->members)[i];\n       member->addLocalClass (&aclasses);\n     }\n \n-  if (aclasses.dim)\n+  if (aclasses.length)\n     {\n       layout_moduleinfo_field (size_type_node, type, offset);\n-      layout_moduleinfo_field (make_array_type (Type::tvoidptr, aclasses.dim),\n+      layout_moduleinfo_field (make_array_type (Type::tvoidptr,\n+\t\t\t\t\t\taclasses.length),\n \t\t\t       type, offset);\n     }\n \n@@ -556,14 +557,14 @@ layout_moduleinfo (Module *decl)\n   ClassDeclarations aclasses;\n   FuncDeclaration *sgetmembers;\n \n-  for (size_t i = 0; i < decl->members->dim; i++)\n+  for (size_t i = 0; i < decl->members->length; i++)\n     {\n       Dsymbol *member = (*decl->members)[i];\n       member->addLocalClass (&aclasses);\n     }\n \n-  size_t aimports_dim = decl->aimports.dim;\n-  for (size_t i = 0; i < decl->aimports.dim; i++)\n+  size_t aimports_dim = decl->aimports.length;\n+  for (size_t i = 0; i < decl->aimports.length; i++)\n     {\n       Module *mi = decl->aimports[i];\n       if (!mi->needmoduleinfo)\n@@ -589,7 +590,7 @@ layout_moduleinfo (Module *decl)\n     flags |= MIunitTest;\n   if (aimports_dim)\n     flags |= MIimportedModules;\n-  if (aclasses.dim)\n+  if (aclasses.length)\n     flags |= MIlocalClasses;\n   if (!decl->needmoduleinfo)\n     flags |= MIstandalone;\n@@ -652,7 +653,7 @@ layout_moduleinfo (Module *decl)\n       tree satype = make_array_type (Type::tvoidptr, aimports_dim);\n       size_t idx = 0;\n \n-      for (size_t i = 0; i < decl->aimports.dim; i++)\n+      for (size_t i = 0; i < decl->aimports.length; i++)\n \t{\n \t  Module *mi = decl->aimports[i];\n \t  if (mi->needmoduleinfo)\n@@ -671,16 +672,16 @@ layout_moduleinfo (Module *decl)\n   if (flags & MIlocalClasses)\n     {\n       vec<constructor_elt, va_gc> *elms = NULL;\n-      tree satype = make_array_type (Type::tvoidptr, aclasses.dim);\n+      tree satype = make_array_type (Type::tvoidptr, aclasses.length);\n \n-      for (size_t i = 0; i < aclasses.dim; i++)\n+      for (size_t i = 0; i < aclasses.length; i++)\n \t{\n \t  ClassDeclaration *cd = aclasses[i];\n \t  CONSTRUCTOR_APPEND_ELT (elms, size_int (i),\n \t\t\t\t  build_address (get_classinfo_decl (cd)));\n \t}\n \n-      CONSTRUCTOR_APPEND_ELT (minit, NULL_TREE, size_int (aclasses.dim));\n+      CONSTRUCTOR_APPEND_ELT (minit, NULL_TREE, size_int (aclasses.length));\n       CONSTRUCTOR_APPEND_ELT (minit, NULL_TREE,\n \t\t\t      build_constructor (satype, elms));\n     }\n@@ -722,7 +723,7 @@ build_module_tree (Module *decl)\n   /* Layout module members.  */\n   if (decl->members)\n     {\n-      for (size_t i = 0; i < decl->members->dim; i++)\n+      for (size_t i = 0; i < decl->members->length; i++)\n \t{\n \t  Dsymbol *s = (*decl->members)[i];\n \t  build_decl_tree (s);"}, {"sha": "92d0ecdb0a0441c172dce59ce91a5f749d015835", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -812,12 +812,12 @@ class IRVisitor : public Visitor\n \n \t/* Apparently the backend is supposed to sort and set the indexes\n \t   on the case array, have to change them to be usable.  */\n-\tType *satype = condtype->sarrayOf (s->cases->dim);\n+\tType *satype = condtype->sarrayOf (s->cases->length);\n \tvec<constructor_elt, va_gc> *elms = NULL;\n \n \ts->cases->sort ();\n \n-\tfor (size_t i = 0; i < s->cases->dim; i++)\n+\tfor (size_t i = 0; i < s->cases->length; i++)\n \t  {\n \t    CaseStatement *cs = (*s->cases)[i];\n \t    cs->index = i;\n@@ -840,7 +840,7 @@ class IRVisitor : public Visitor\n \n \t/* Pass it as a dynamic array.  */\n \tdecl = d_array_value (build_ctype (condtype->arrayOf ()),\n-\t\t\t      size_int (s->cases->dim),\n+\t\t\t      size_int (s->cases->length),\n \t\t\t      build_address (decl));\n \n \tcondition = build_libcall (libcall, Type::tint32, 2, decl, condition);\n@@ -858,7 +858,7 @@ class IRVisitor : public Visitor\n        Also checking the jump from the switch to the label is allowed.  */\n     if (s->cases)\n       {\n-\tfor (size_t i = 0; i < s->cases->dim; i++)\n+\tfor (size_t i = 0; i < s->cases->length; i++)\n \t  {\n \t    CaseStatement *cs = (*s->cases)[i];\n \t    tree caselabel = this->lookup_label (cs);\n@@ -1049,7 +1049,7 @@ class IRVisitor : public Visitor\n     if (s->statements == NULL)\n       return;\n \n-    for (size_t i = 0; i < s->statements->dim; i++)\n+    for (size_t i = 0; i < s->statements->length; i++)\n       {\n \tStatement *statement = (*s->statements)[i];\n \n@@ -1070,7 +1070,7 @@ class IRVisitor : public Visitor\n     tree lbreak = this->push_break_label (s);\n     this->start_scope (level_loop);\n \n-    for (size_t i = 0; i < s->statements->dim; i++)\n+    for (size_t i = 0; i < s->statements->length; i++)\n       {\n \tStatement *statement = (*s->statements)[i];\n \n@@ -1175,7 +1175,7 @@ class IRVisitor : public Visitor\n \n     if (s->catches)\n       {\n-\tfor (size_t i = 0; i < s->catches->dim; i++)\n+\tfor (size_t i = 0; i < s->catches->length; i++)\n \t  {\n \t    Catch *vcatch = (*s->catches)[i];\n \n@@ -1301,7 +1301,7 @@ class IRVisitor : public Visitor\n     /* Collect all arguments, which may be input or output operands.  */\n     if (s->args)\n       {\n-\tfor (size_t i = 0; i < s->args->dim; i++)\n+\tfor (size_t i = 0; i < s->args->length; i++)\n \t  {\n \t    Identifier *name = (*s->names)[i];\n \t    const char *sname = name ? name->toChars () : NULL;\n@@ -1331,7 +1331,7 @@ class IRVisitor : public Visitor\n     /* Collect all clobber arguments.  */\n     if (s->clobbers)\n       {\n-\tfor (size_t i = 0; i < s->clobbers->dim; i++)\n+\tfor (size_t i = 0; i < s->clobbers->length; i++)\n \t  {\n \t    StringExp *clobber = (StringExp *)(*s->clobbers)[i];\n \t    const char *cstring = (const char *)(clobber->len\n@@ -1346,7 +1346,7 @@ class IRVisitor : public Visitor\n        by the front-end, so pass down the label symbol to the back-end.  */\n     if (s->labels)\n       {\n-\tfor (size_t i = 0; i < s->labels->dim; i++)\n+\tfor (size_t i = 0; i < s->labels->length; i++)\n \t  {\n \t    Identifier *ident = (*s->labels)[i];\n \t    GotoStatement *gs = (*s->gotos)[i];\n@@ -1372,7 +1372,7 @@ class IRVisitor : public Visitor\n     if (s->args)\n       {\n \tunsigned noutputs = s->outputargs;\n-\tunsigned ninputs = (s->args->dim - noutputs);\n+\tunsigned ninputs = (s->args->length - noutputs);\n \tconst char **oconstraints = XALLOCAVEC (const char *, noutputs);\n \tbool allows_mem, allows_reg, is_inout;\n \tsize_t i;\n@@ -1447,7 +1447,7 @@ class IRVisitor : public Visitor\n     if (s->imports == NULL)\n       return;\n \n-    for (size_t i = 0; i < s->imports->dim; i++)\n+    for (size_t i = 0; i < s->imports->length; i++)\n       {\n \tDsymbol *dsym = (*s->imports)[i];\n "}, {"sha": "fdeb70030cb756e41bcbd84580d1d5855169241b", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -417,7 +417,7 @@ class TypeInfoVisitor : public Visitor\n \n     /* Put out the offset to where vtblInterfaces are written.  */\n     tree value = d_array_value (array_type_node,\n-\t\t\t\tsize_int (cd->vtblInterfaces->dim),\n+\t\t\t\tsize_int (cd->vtblInterfaces->length),\n \t\t\t\tbuild_offset (csym, size_int (offset)));\n     this->layout_field (value);\n \n@@ -430,7 +430,7 @@ class TypeInfoVisitor : public Visitor\n \tsize_t offset;  */\n     vec<constructor_elt, va_gc> *elms = NULL;\n \n-    for (size_t i = 0; i < cd->vtblInterfaces->dim; i++)\n+    for (size_t i = 0; i < cd->vtblInterfaces->length; i++)\n       {\n \tBaseClass *b = (*cd->vtblInterfaces)[i];\n \tClassDeclaration *id = b->sym;\n@@ -451,7 +451,7 @@ class TypeInfoVisitor : public Visitor\n \t    gcc_assert (voffset != 0u);\n \t    value = build_offset (csym, size_int (voffset));\n \n-\t    CONSTRUCTOR_APPEND_ELT (v, size_int (1), size_int (id->vtbl.dim));\n+\t    CONSTRUCTOR_APPEND_ELT (v, size_int (1), size_int (id->vtbl.length));\n \t    CONSTRUCTOR_APPEND_ELT (v, size_int (2), value);\n \t  }\n \n@@ -463,7 +463,7 @@ class TypeInfoVisitor : public Visitor\n \tCONSTRUCTOR_APPEND_ELT (elms, size_int (i), value);\n       }\n \n-    tree domain = size_int (cd->vtblInterfaces->dim - 1);\n+    tree domain = size_int (cd->vtblInterfaces->length - 1);\n     tree arrtype = build_array_type (vtbl_interface_type_node,\n \t\t\t\t     build_index_type (domain));\n     return build_constructor (arrtype, elms);\n@@ -483,7 +483,7 @@ class TypeInfoVisitor : public Visitor\n     vec<constructor_elt, va_gc> *elms = NULL;\n     FuncDeclarations bvtbl;\n \n-    if (id->vtbl.dim == 0 || base_vtable_offset (cd, bs) == ~0u)\n+    if (id->vtbl.length == 0 || base_vtable_offset (cd, bs) == ~0u)\n       return;\n \n     /* Fill bvtbl with the functions we want to put out.  */\n@@ -500,7 +500,7 @@ class TypeInfoVisitor : public Visitor\n \tCONSTRUCTOR_APPEND_ELT (elms, size_zero_node, value);\n       }\n \n-    for (size_t i = id->vtblOffset () ? 1 : 0; i < id->vtbl.dim; i++)\n+    for (size_t i = id->vtblOffset () ? 1 : 0; i < id->vtbl.length; i++)\n       {\n \tFuncDeclaration *fd = (cd == bcd) ? bs->vtbl[i] : bvtbl[i];\n \tif (fd != NULL)\n@@ -510,7 +510,7 @@ class TypeInfoVisitor : public Visitor\n \t  }\n       }\n \n-    tree vtbldomain = build_index_type (size_int (id->vtbl.dim - 1));\n+    tree vtbldomain = build_index_type (size_int (id->vtbl.length - 1));\n     tree vtbltype = build_array_type (vtable_entry_type, vtbldomain);\n     tree value = build_constructor (vtbltype, elms);\n     this->layout_field (value);\n@@ -827,12 +827,12 @@ class TypeInfoVisitor : public Visitor\n \tthis->layout_string (name);\n \n \t/* The vtable of the class declaration.  */\n-\tvalue = d_array_value (array_type_node, size_int (cd->vtbl.dim),\n+\tvalue = d_array_value (array_type_node, size_int (cd->vtbl.length),\n \t\t\t       build_address (get_vtable_decl (cd)));\n \tthis->layout_field (value);\n \n \t/* Array of base interfaces that have their own vtable.  */\n-\tif (cd->vtblInterfaces->dim)\n+\tif (cd->vtblInterfaces->length)\n \t  interfaces = this->layout_interfaces (cd);\n \telse\n \t  this->layout_field (null_array_node);\n@@ -884,7 +884,7 @@ class TypeInfoVisitor : public Visitor\n \t    if (!bcd->members)\n \t      continue;\n \n-\t    for (size_t i = 0; i < bcd->members->dim; i++)\n+\t    for (size_t i = 0; i < bcd->members->length; i++)\n \t      {\n \t\tDsymbol *sm = (*bcd->members)[i];\n \t\tif (sm->hasPointers ())\n@@ -933,7 +933,7 @@ class TypeInfoVisitor : public Visitor\n \tthis->layout_field (null_array_node);\n \n \t/* Array of base interfaces that have their own vtable.  */\n-\tif (cd->vtblInterfaces->dim)\n+\tif (cd->vtblInterfaces->length)\n \t  interfaces = this->layout_interfaces (cd);\n \telse\n \t  this->layout_field (null_array_node);\n@@ -974,13 +974,13 @@ class TypeInfoVisitor : public Visitor\n     if (!cd->isInterfaceDeclaration ())\n       {\n \t/* Put out this class' interface vtables[].  */\n-\tfor (size_t i = 0; i < cd->vtblInterfaces->dim; i++)\n+\tfor (size_t i = 0; i < cd->vtblInterfaces->length; i++)\n \t  this->layout_base_vtable (cd, cd, i);\n \n \t/* Put out the overriding interface vtables[].  */\n \tfor (ClassDeclaration *bcd = cd->baseClass; bcd; bcd = bcd->baseClass)\n \t  {\n-\t    for (size_t i = 0; i < bcd->vtblInterfaces->dim; i++)\n+\t    for (size_t i = 0; i < bcd->vtblInterfaces->length; i++)\n \t      this->layout_base_vtable (cd, bcd, i);\n \t  }\n       }\n@@ -1134,9 +1134,9 @@ class TypeInfoVisitor : public Visitor\n     this->layout_base (Type::typeinfotypelist);\n \n     /* TypeInfo[] elements;  */\n-    Type *satype = Type::tvoidptr->sarrayOf (ti->arguments->dim);\n+    Type *satype = Type::tvoidptr->sarrayOf (ti->arguments->length);\n     vec<constructor_elt, va_gc> *elms = NULL;\n-    for (size_t i = 0; i < ti->arguments->dim; i++)\n+    for (size_t i = 0; i < ti->arguments->length; i++)\n       {\n \tParameter *arg = (*ti->arguments)[i];\n \tCONSTRUCTOR_APPEND_ELT (elms, size_int (i),\n@@ -1145,7 +1145,7 @@ class TypeInfoVisitor : public Visitor\n     tree ctor = build_constructor (build_ctype (satype), elms);\n     tree decl = this->internal_reference (ctor);\n \n-    tree length = size_int (ti->arguments->dim);\n+    tree length = size_int (ti->arguments->length);\n     tree ptr = build_address (decl);\n     this->layout_field (d_array_value (array_type_node, length, ptr));\n \n@@ -1193,7 +1193,7 @@ layout_classinfo_interfaces (ClassDeclaration *decl)\n   tree type = tinfo_types[TK_CLASSINFO_TYPE];\n   size_t structsize = int_size_in_bytes (type);\n \n-  if (decl->vtblInterfaces->dim)\n+  if (decl->vtblInterfaces->length)\n     {\n       size_t interfacesize = int_size_in_bytes (vtbl_interface_type_node);\n       tree field;\n@@ -1202,52 +1202,52 @@ layout_classinfo_interfaces (ClassDeclaration *decl)\n \n       /* First layout the static array of Interface, which provides information\n \t about the vtables that follow.  */\n-      tree domain = size_int (decl->vtblInterfaces->dim - 1);\n+      tree domain = size_int (decl->vtblInterfaces->length - 1);\n       tree arrtype = build_array_type (vtbl_interface_type_node,\n \t\t\t\t       build_index_type (domain));\n       field = create_field_decl (arrtype, NULL, 1, 1);\n       insert_aggregate_field (type, field, structsize);\n-      structsize += decl->vtblInterfaces->dim * interfacesize;\n+      structsize += decl->vtblInterfaces->length * interfacesize;\n \n       /* For each interface, layout each vtable.  */\n-      for (size_t i = 0; i < decl->vtblInterfaces->dim; i++)\n+      for (size_t i = 0; i < decl->vtblInterfaces->length; i++)\n \t{\n \t  BaseClass *b = (*decl->vtblInterfaces)[i];\n \t  ClassDeclaration *id = b->sym;\n \t  unsigned offset = base_vtable_offset (decl, b);\n \n-\t  if (id->vtbl.dim && offset != ~0u)\n+\t  if (id->vtbl.length && offset != ~0u)\n \t    {\n-\t      tree vtbldomain = build_index_type (size_int (id->vtbl.dim - 1));\n+\t      tree vtbldomain = build_index_type (size_int (id->vtbl.length - 1));\n \t      tree vtbltype = build_array_type (vtable_entry_type, vtbldomain);\n \n \t      field = create_field_decl (vtbltype, NULL, 1, 1);\n \t      insert_aggregate_field (type, field, offset);\n-\t      structsize += id->vtbl.dim * Target::ptrsize;\n+\t      structsize += id->vtbl.length * Target::ptrsize;\n \t    }\n \t}\n     }\n \n   /* Layout the arrays of overriding interface vtables.  */\n   for (ClassDeclaration *bcd = decl->baseClass; bcd; bcd = bcd->baseClass)\n     {\n-      for (size_t i = 0; i < bcd->vtblInterfaces->dim; i++)\n+      for (size_t i = 0; i < bcd->vtblInterfaces->length; i++)\n \t{\n \t  BaseClass *b = (*bcd->vtblInterfaces)[i];\n \t  ClassDeclaration *id = b->sym;\n \t  unsigned offset = base_vtable_offset (decl, b);\n \n-\t  if (id->vtbl.dim && offset != ~0u)\n+\t  if (id->vtbl.length && offset != ~0u)\n \t    {\n \t      if (type == tinfo_types[TK_CLASSINFO_TYPE])\n \t\ttype = copy_aggregate_type (type);\n \n-\t      tree vtbldomain = build_index_type (size_int (id->vtbl.dim - 1));\n+\t      tree vtbldomain = build_index_type (size_int (id->vtbl.length - 1));\n \t      tree vtbltype = build_array_type (vtable_entry_type, vtbldomain);\n \n \t      tree field = create_field_decl (vtbltype, NULL, 1, 1);\n \t      insert_aggregate_field (type, field, offset);\n-\t      structsize += id->vtbl.dim * Target::ptrsize;\n+\t      structsize += id->vtbl.length * Target::ptrsize;\n \t    }\n \t}\n     }\n@@ -1732,7 +1732,7 @@ class SpeculativeTypeVisitor : public Visitor\n     if (!t->arguments)\n       return;\n \n-    for (size_t i = 0; i < t->arguments->dim; i++)\n+    for (size_t i = 0; i < t->arguments->length; i++)\n       {\n \tType *tprm = (*t->arguments)[i]->type;\n \tif (tprm)"}, {"sha": "1f43352885a9dc10eb37a9bd46285221532b0bf7", "filename": "gcc/d/types.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbc99d18dc411ac3fdef94e22ce86859806e63c/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=2cbc99d18dc411ac3fdef94e22ce86859806e63c", "patch": "@@ -268,7 +268,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n {\n   size_t fields = 0;\n \n-  for (size_t i = 0; i < members->dim; i++)\n+  for (size_t i = 0; i < members->length; i++)\n     {\n       Dsymbol *sym = (*members)[i];\n       VarDeclaration *var = sym->isVarDeclaration ();\n@@ -285,7 +285,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t      Dsymbols tmembers;\n \t      /* No other way to coerce the underlying type out of the tuple.\n \t\t Frontend should have already validated this.  */\n-\t      for (size_t j = 0; j < td->objects->dim; j++)\n+\t      for (size_t j = 0; j < td->objects->length; j++)\n \t\t{\n \t\t  RootObject *ro = (*td->objects)[j];\n \t\t  gcc_assert (ro->dyncast () == DYNCAST_EXPRESSION);\n@@ -409,7 +409,7 @@ layout_aggregate_type (AggregateDeclaration *decl, tree type,\n \n \t  /* Add the vtable pointer, and optionally the monitor fields.  */\n \t  InterfaceDeclaration *id = cd->isInterfaceDeclaration ();\n-\t  if (!id || id->vtblInterfaces->dim == 0)\n+\t  if (!id || id->vtblInterfaces->length == 0)\n \t    {\n \t      tree field = create_field_decl (vtbl_ptr_type_node, \"__vptr\", 1,\n \t\t\t\t\t      inherited_p);\n@@ -429,7 +429,7 @@ layout_aggregate_type (AggregateDeclaration *decl, tree type,\n \n       if (cd->vtblInterfaces)\n \t{\n-\t  for (size_t i = 0; i < cd->vtblInterfaces->dim; i++)\n+\t  for (size_t i = 0; i < cd->vtblInterfaces->length; i++)\n \t    {\n \t      BaseClass *bc = (*cd->vtblInterfaces)[i];\n \t      tree field = create_field_decl (vtbl_ptr_type_node, NULL, 1, 1);\n@@ -442,12 +442,12 @@ layout_aggregate_type (AggregateDeclaration *decl, tree type,\n     {\n       size_t fields = layout_aggregate_members (base->members, type,\n \t\t\t\t\t\tinherited_p);\n-      gcc_assert (fields == base->fields.dim);\n+      gcc_assert (fields == base->fields.length);\n \n       /* Make sure that all fields have been created.  */\n       if (!inherited_p)\n \t{\n-\t  for (size_t i = 0; i < base->fields.dim; i++)\n+\t  for (size_t i = 0; i < base->fields.length; i++)\n \t    {\n \t      VarDeclaration *var = base->fields[i];\n \t      gcc_assert (var->csym != NULL);\n@@ -836,7 +836,7 @@ class TypeVisitor : public Visitor\n \ttree values = NULL_TREE;\n \tif (t->sym->members)\n \t  {\n-\t    for (size_t i = 0; i < t->sym->members->dim; i++)\n+\t    for (size_t i = 0; i < t->sym->members->length; i++)\n \t      {\n \t\tEnumMember *member = (*t->sym->members)[i]->isEnumMember ();\n \t\t/* Templated functions can seep through to the back-end\n@@ -972,7 +972,7 @@ class TypeVisitor : public Visitor\n       }\n \n     /* Associate all virtual methods with the class too.  */\n-    for (size_t i = 0; i < t->sym->vtbl.dim; i++)\n+    for (size_t i = 0; i < t->sym->vtbl.length; i++)\n       {\n \tFuncDeclaration *fd = t->sym->vtbl[i]->isFuncDeclaration ();\n \ttree method = fd ? get_symbol_decl (fd) : error_mark_node;"}]}