{"sha": "422c3a54ea4ba93eb21c1a6c72c42bd804665646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIyYzNhNTRlYTRiYTkzZWIyMWMxYTZjNzJjNDJiZDgwNDY2NTY0Ng==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2006-11-24T01:50:33Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2006-11-24T01:50:33Z"}, "message": "re PR c/2707 (gcc does not warn on truncate)\n\n2006-11-24  Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n\n\tPR c/2707\n\tPR c++/26167\n\t* c-common.c (conversion_warning): New.\n\t(convert_and_check): Call conversion_warning unless there is an\n\toverflow warning.\n\t* doc/invoke.texi (-Wconversion): Update description.\n\ntestsuite/\n\n\t* gcc.dg/Wconversion-integer.c: New. Supersedes\t\n\tWconversion-negative-constants.c \n\t* gcc.dg/Wconversion-real.c: New.\n\t* gcc.dg/Wconversion-real-integer.c: New.\n\t* gcc.dg/Wconversion-negative-constants.c: Deleted.\n\t* g++.dg/warn/Wconversion1.C: Modified.\n\nFrom-SVN: r119143", "tree": {"sha": "5f5522ac3829784d28af2cccffb6ea3878cf5875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5522ac3829784d28af2cccffb6ea3878cf5875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/422c3a54ea4ba93eb21c1a6c72c42bd804665646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422c3a54ea4ba93eb21c1a6c72c42bd804665646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422c3a54ea4ba93eb21c1a6c72c42bd804665646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422c3a54ea4ba93eb21c1a6c72c42bd804665646/comments", "author": null, "committer": null, "parents": [{"sha": "2941f691d916975ce707918ef42b22b928a4a11f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2941f691d916975ce707918ef42b22b928a4a11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2941f691d916975ce707918ef42b22b928a4a11f"}], "stats": {"total": 503, "additions": 418, "deletions": 85}, "files": [{"sha": "d5dfb09e39a0f429a72052fe8c178854fae22502", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -1,3 +1,12 @@\n+2006-11-24  Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n+\n+\tPR c/2707\n+\tPR c++/26167\n+\t* c-common.c (conversion_warning): New.\n+\t(convert_and_check): Call conversion_warning unless there is an\n+\toverflow warning.\n+\t* doc/invoke.texi (-Wconversion): Update description.\n+\n 2006-11-23  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-alias.c (tree_pointer_compare): New function."}, {"sha": "8e4cbff3b9ec7827ac5ecaa6785e651bb466682b", "filename": "gcc/c-common.c", "status": "modified", "additions": 139, "deletions": 26, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -1127,6 +1127,113 @@ vector_types_convertible_p (tree t1, tree t2)\n \t\t== INTEGRAL_TYPE_P (TREE_TYPE (t2)));\n }\n \n+/* Warns if the conversion of EXPR to TYPE may alter a value.\n+   This function is called from convert_and_check.  */\n+\n+static void\n+conversion_warning (tree type, tree expr)\n+{\n+  bool give_warning = false;\n+\n+  unsigned int formal_prec = TYPE_PRECISION (type);\n+\n+  if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n+    {\n+      /* Warn for real constant that is not an exact integer converted\n+         to integer type.  */\n+      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+          && TREE_CODE (type) == INTEGER_TYPE)\n+        {\n+          if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (TREE_TYPE (expr))))\n+            give_warning = true;\n+        }\n+      /* Warn for an integer constant that does not fit into integer\n+         type. However, warnings for negative constants converted to\n+         unsigned types are detected by unsigned_conversion_warning.  */\n+      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+               && TREE_CODE (type) == INTEGER_TYPE\n+               && !int_fits_type_p (expr, type)\n+               && !(TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr))))\n+        give_warning = true;\n+\n+      else if (TREE_CODE (type) == REAL_TYPE)\n+        {\n+          /* Warn for an integer constant that does not fit into real type.  */\n+          if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE)\n+            {\n+              REAL_VALUE_TYPE a = real_value_from_int_cst (0, expr);\n+              if (!exact_real_truncate (TYPE_MODE (type), &a))\n+                give_warning = true;\n+            }\n+          /* Warn for a real constant that does not fit into a smaller\n+             real type.  */\n+          else if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+                   && formal_prec < TYPE_PRECISION (TREE_TYPE (expr)))\n+            {\n+              REAL_VALUE_TYPE a = TREE_REAL_CST (expr);\n+              if (!exact_real_truncate (TYPE_MODE (type), &a))\n+                give_warning = true;\n+            }\n+        }\n+\n+      if (give_warning)\n+        warning (OPT_Wconversion,\n+                 \"conversion to %qT alters %qT constant value\",\n+                 type, TREE_TYPE (expr));\n+    }\n+  else /* 'expr' is not a constant.  */\n+    {\n+      /* Warn for real types converted to integer types.  */\n+      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+          && TREE_CODE (type) == INTEGER_TYPE)\n+        give_warning = true;\n+\n+      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+               && TREE_CODE (type) == INTEGER_TYPE)\n+        {\n+          /* Warn for integer types converted to smaller integer types.  */\n+          if (formal_prec < TYPE_PRECISION (TREE_TYPE (expr))\n+              /* When they are the same width but different signedness,\n+                 then the value may change.  */\n+              || (formal_prec == TYPE_PRECISION (TREE_TYPE (expr))\n+                  && TYPE_UNSIGNED (TREE_TYPE (expr)) != TYPE_UNSIGNED (type))\n+              /* Even when converted to a bigger type, if the type is\n+                 unsigned but expr is signed, then negative values\n+                 will be changed.  */\n+              || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr))))\n+            give_warning = true;\n+        }\n+\n+      /* Warn for integer types converted to real types if and only if\n+         all the range of values of the integer type cannot be\n+         represented by the real type.  */\n+      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+               && TREE_CODE (type) == REAL_TYPE)\n+        {\n+          tree type_low_bound = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+          tree type_high_bound = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+          REAL_VALUE_TYPE real_low_bound = real_value_from_int_cst (0, type_low_bound);\n+          REAL_VALUE_TYPE real_high_bound = real_value_from_int_cst (0, type_high_bound);\n+\n+          if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n+              || !exact_real_truncate (TYPE_MODE (type), &real_high_bound))\n+            give_warning = true;\n+        }\n+\n+      /* Warn for real types converted to smaller real types.  */\n+      else if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+               && TREE_CODE (type) == REAL_TYPE\n+               && formal_prec < TYPE_PRECISION (TREE_TYPE (expr)))\n+        give_warning = true;\n+\n+\n+      if (give_warning)\n+        warning (OPT_Wconversion,\n+                 \"conversion to %qT from %qT may alter its value\",\n+                 type, TREE_TYPE (expr));\n+    }\n+}\n+\n /* Convert EXPR to TYPE, warning about conversion problems with constants.\n    Invoke this function on every expression that is converted implicitly,\n    i.e. because of language rules and not because of an explicit cast.  */\n@@ -1135,33 +1242,39 @@ tree\n convert_and_check (tree type, tree expr)\n {\n   tree t = convert (type, expr);\n-  if (TREE_CODE (t) == INTEGER_CST)\n+  if (TREE_CODE (t) == INTEGER_CST && TREE_OVERFLOW (t))\n+    {\n+      TREE_OVERFLOW (t) = 0;\n+\n+      /* Do not diagnose overflow in a constant expression merely\n+         because a conversion overflowed.  */\n+      TREE_CONSTANT_OVERFLOW (t) = CONSTANT_CLASS_P (expr)\n+        && TREE_CONSTANT_OVERFLOW (expr);\n+      \n+      /* No warning for converting 0x80000000 to int.  */\n+      if (!(TYPE_UNSIGNED (type) < TYPE_UNSIGNED (TREE_TYPE (expr))\n+            && TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+            && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (expr))))\n+        {\n+          /* If EXPR fits in the unsigned version of TYPE,\n+             don't warn unless pedantic.  */\n+          if ((pedantic\n+               || TYPE_UNSIGNED (type)\n+               || !constant_fits_type_p (expr,\n+                                         c_common_unsigned_type (type)))\n+              && skip_evaluation == 0)\n+            warning (OPT_Woverflow,\n+                     \"overflow in implicit constant conversion\");\n+        }\n+      else if (warn_conversion && !skip_evaluation)\n+          conversion_warning (type, expr);\n+    }\n+  else \n     {\n-      if (TREE_OVERFLOW (t))\n-\t{\n-\t  TREE_OVERFLOW (t) = 0;\n-\n-\t  /* Do not diagnose overflow in a constant expression merely\n-\t     because a conversion overflowed.  */\n-\t  TREE_CONSTANT_OVERFLOW (t) = CONSTANT_CLASS_P (expr)\n-                                       && TREE_CONSTANT_OVERFLOW (expr);\n-\n-\t  /* No warning for converting 0x80000000 to int.  */\n-\t  if (!(TYPE_UNSIGNED (type) < TYPE_UNSIGNED (TREE_TYPE (expr))\n-\t\t&& TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n-\t\t&& TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (expr))))\n-\t    /* If EXPR fits in the unsigned version of TYPE,\n-\t       don't warn unless pedantic.  */\n-\t    if ((pedantic\n-\t\t || TYPE_UNSIGNED (type)\n-\t\t || !constant_fits_type_p (expr,\n-\t\t\t\t\t   c_common_unsigned_type (type)))\n-\t\t&& skip_evaluation == 0)\n-\t      warning (OPT_Woverflow,\n-                       \"overflow in implicit constant conversion\");\n-\t}\n-      else\n-\tunsigned_conversion_warning (t, expr);\n+      if (warn_conversion && !skip_evaluation)\n+        conversion_warning (type, expr);\n+\n+      unsigned_conversion_warning (t, expr);\n     }\n   return t;\n }"}, {"sha": "c98772191d63c763821ada41fc0cb6d33d8f9b0b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -3156,10 +3156,13 @@ this is why we did not make @option{-Wall} request these warnings.\n \n @item -Wconversion\n @opindex Wconversion\n-Warn if a negative integer constant expression is implicitly converted\n-to an unsigned type.  For example, warn about the assignment\n-@code{unsigned x = -1} if @code{x} is unsigned. But do not warn about\n-explicit casts like @code{(unsigned) -1}.\n+Warn for implicit conversions that may alter a value. This includes\n+conversions between real and integer, like @code{abs (x)} when\n+@code{x} is @code{double}; conversions between signed and unsigned,\n+like @code{unsigned ui = -1}; and conversions to smaller types, like\n+@code{sqrtf (M_PI)}. Do not warn for explicit casts like @code{abs\n+((int) x)} and @code{ui = (unsigned) -1}, or if the value is not\n+changed by the conversion like in @code{abs (2.0)}.\n \n @item -Wsign-compare\n @opindex Wsign-compare"}, {"sha": "6c6c933cd5179dc8a62d17fd088dcc2bded384ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -1,3 +1,14 @@\n+2006-11-24  Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n+\n+\tPR c/2707\n+\tPR c++/26167\n+\t* gcc.dg/Wconversion-integer.c: New. Supersedes\t\n+\tWconversion-negative-constants.c \n+\t* gcc.dg/Wconversion-real.c: New.\n+\t* gcc.dg/Wconversion-real-integer.c: New.\n+\t* gcc.dg/Wconversion-negative-constants.c: Deleted.\n+\t* g++.dg/warn/Wconversion1.C: Modified.\n+\t\n 2006-11-23  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.dg/overload_1.f90: New test."}, {"sha": "8a2092938479a538811a6c2cf655413b75608b84", "filename": "gcc/testsuite/g++.dg/warn/Wconversion1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion1.C?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -9,4 +9,4 @@ unsigned char uc1 = -129; // { dg-warning \"unsigned\" }\n \n bool b1 = -3;\n \n-int i1 = 0x80000000;\n+int i1 = 0x80000000; // { dg-warning \"conversion\" }"}, {"sha": "bab8062b777ffc8722c026f89698472f7bbe38d0", "filename": "gcc/testsuite/gcc.dg/Wconversion-integer.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -0,0 +1,95 @@\n+/* Test for diagnostics for implicit conversions between integer types\n+   These tests come from gcc/testsuite/gcc.dg/overflow-warn-2.c  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wconversion\" } */\n+\n+#include <limits.h>\n+\n+void fsc (signed char sc);\n+void fuc (unsigned char uc);\n+unsigned fui (unsigned int  ui);\n+void fsi (signed int ui);\n+\n+void h (int x)\n+{\n+  unsigned int ui = 3;\n+  int   si = 3;\n+  unsigned char uc = 3;\n+  signed char   sc = 3;\n+\n+  fuc (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  fuc ('\\xa0'); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = '\\xa0'; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = x ? 1U : -1; /* { dg-warning \"conversion\" } */\n+  /* { dg-warning \"negative integer implicitly converted to unsigned type\" \"\" { target *-*-* } 25 } */\n+  uc = x ? SCHAR_MIN : 1U; /* { dg-warning \"conversion\" } */\n+  /* { dg-warning \"negative integer implicitly converted to unsigned type\" \"\" { target *-*-* } 27 } */\n+\n+  uc = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n+\n+  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+\n+  fuc ('A');\n+  uc = 'A';\n+  uc = (unsigned char) -1;\n+\n+  fui (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = x ? INT_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = ui ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = 1U * -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = ui + INT_MIN; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n+  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+\n+  ui = -1 * (1 * -1);\n+  ui = (unsigned) -1;\n+\n+  fsc (uc); /* { dg-warning \"conversion\" } */\n+  sc = uc;  /* { dg-warning \"conversion\" } */\n+  fuc (sc); /* { dg-warning \"conversion\" } */\n+  uc = sc;  /* { dg-warning \"conversion\" } */\n+  fsi (ui); /* { dg-warning \"conversion\" } */\n+  si = ui;  /* { dg-warning \"conversion\" } */\n+  fui (si); /* { dg-warning \"conversion\" } */ \n+  ui = si;  /* { dg-warning \"conversion\" } */ \n+  fui (sc); /* { dg-warning \"conversion\" } */\n+  ui = sc;  /* { dg-warning \"conversion\" } */\n+\n+  fui ('\\xa0');/* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = '\\xa0'; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+\n+  fsi (si);\n+  fui (ui);\n+  fsi (uc);\n+  si = uc;\n+  fui (uc);\n+  ui = uc;\n+  fui ('A');\n+  ui = 'A';\n+  fsi ('A');\n+  si = 'A';\n+  \n+\n+  fsi (UINT_MAX - 1);  /* { dg-warning \"conversion\" } */\n+  si = UINT_MAX - 1;   /* { dg-warning \"conversion\" } */\n+  fsi (UINT_MAX - 1U); /* { dg-warning \"conversion\" } */\n+  si = UINT_MAX - 1U;  /* { dg-warning \"conversion\" } */\n+  fsi (UINT_MAX/3U);\n+  si = UINT_MAX/3U;\n+  fsi (UINT_MAX/3);\n+  si = UINT_MAX/3;\n+  fui (UINT_MAX - 1);\n+  ui = UINT_MAX - 1;\n+\n+  fsi (0x80000000); /* { dg-warning \"conversion\" } */\n+  si = 0x80000000;  /* { dg-warning \"conversion\" } */\n+}\n+\n+\n+unsigned fui (unsigned a) { return a + -1; } /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+\n+"}, {"sha": "80ef4105cfc59d74e3a7c52640626a1dce8a1746", "filename": "gcc/testsuite/gcc.dg/Wconversion-negative-constants.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2941f691d916975ce707918ef42b22b928a4a11f/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-negative-constants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2941f691d916975ce707918ef42b22b928a4a11f/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-negative-constants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-negative-constants.c?ref=2941f691d916975ce707918ef42b22b928a4a11f", "patch": "@@ -1,54 +0,0 @@\n-/* Test for diagnostics for negative constants converted to unsigned types.\n-   These tests come from gcc/testsuite/gcc.dg/overflow-warn-2.c  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-std=c99 -Wconversion\" } */\n-\n-#include <limits.h>\n-\n-void fuc (unsigned char);\n-\n-void hc (int x)\n-{\n-  unsigned char uc;\n-\n-  fuc (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = x ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = '\\xa0'; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-\n-  fuc('A');\n-  uc = 'A';\n-\n-  uc = x ? 1 : -1;\n-\n-  uc = x ? SCHAR_MIN : 1;\n-}\n-\n-unsigned fui (unsigned int ui);\n-\n-void hi (int x)\n-{\n-  unsigned ui;\n-\n-  fui (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = x ? INT_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = ui ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = 1U * -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = ui + INT_MIN; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-\n-  ui = -1 * (1 * -1);\n-  ui = (unsigned) -1;\n-\n-  ui = x ? 1 : -1;\n-\n-  ui = x ? INT_MIN : 1;\n-\n-  ui = ui ? SCHAR_MIN : 1;\n-}\n-\n-\n-unsigned fui(unsigned a) { return a + -1; } /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */"}, {"sha": "5911f6a778b46fdc446ee0ffbd947160bded1f92", "filename": "gcc/testsuite/gcc.dg/Wconversion-real-integer.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real-integer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real-integer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real-integer.c?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -0,0 +1,72 @@\n+/* Test for diagnostics for Wconversion between floating-point and\n+   integers.  */\n+\n+/* { dg-do compile }\n+/* { dg-options \"-std=c99 -Wconversion\" } */\n+\n+#include <limits.h>\n+\n+void fsi (signed int x);\n+void fui (unsigned int x);\n+void ffloat (float x);\n+void fdouble (double x);\n+\n+float  vfloat;\n+double vdouble;\n+\n+void h (void)\n+{\n+  unsigned int ui = 3;\n+  int   si = 3;\n+  unsigned char uc = 3;\n+  signed char sc = 3;\n+  float  f = 3;\n+  double d = 3;\n+\n+  fsi (3.1f); /* { dg-warning \"conversion\" } */\n+  si = 3.1f; /* { dg-warning \"conversion\" } */\n+  fsi (3.1);  /* { dg-warning \"conversion\" } */\n+  si = 3.1;  /* { dg-warning \"conversion\" } */\n+  fsi (d);    /* { dg-warning \"conversion\" } */\n+  si = d;    /* { dg-warning \"conversion\" } */\n+  fui (-1.0); /* { dg-warning \"overflow\" } */\n+  ui = -1.0;   /* { dg-warning \"overflow\" } */\n+  ffloat (INT_MAX);  /* { dg-warning \"conversion\" } */\n+  vfloat = INT_MAX;  /* { dg-warning \"conversion\" } */\n+  ffloat (16777217); /* { dg-warning \"conversion\" } */\n+  vfloat = 16777217; /* { dg-warning \"conversion\" } */\n+  ffloat (si); /* { dg-warning \"conversion\" } */\n+  vfloat = si; /* { dg-warning \"conversion\" } */\n+  ffloat (ui); /* { dg-warning \"conversion\" } */\n+  vfloat = ui; /* { dg-warning \"conversion\" } */\n+\n+  fsi (3);\n+  si = 3;\n+  fsi (3.0f);\n+  si = 3.0f;\n+  fsi (3.0);\n+  si = 3.0;\n+  fsi (16777217.0f);\n+  si = 16777217.0f;\n+  fsi ((int) 3.1);\n+  si = (int) 3.1;\n+  ffloat (3U);\n+  vfloat = 3U;\n+  ffloat (3);\n+  vfloat = 3;\n+  ffloat (INT_MIN);\n+  vfloat = INT_MIN;\n+  ffloat (uc);\n+  vfloat = uc;\n+  ffloat (sc);\n+  vfloat = sc;\n+\n+  fdouble (UINT_MAX);\n+  vdouble = UINT_MAX;\n+  fdouble (ui);\n+  vdouble = ui;\n+  fdouble (si);\n+  vdouble = si;\n+}\n+\n+"}, {"sha": "53ac9a7e1b6577367cab11d097df3a4d55a6a297", "filename": "gcc/testsuite/gcc.dg/Wconversion-real.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/422c3a54ea4ba93eb21c1a6c72c42bd804665646/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-real.c?ref=422c3a54ea4ba93eb21c1a6c72c42bd804665646", "patch": "@@ -0,0 +1,84 @@\n+/* Test for diagnostics for Wconversion for floating-point.  */\n+\n+/* { dg-do compile }\n+/* { dg-options \"-std=c99 -Wconversion\" } */\n+\n+float  vfloat;\n+double vdouble;\n+long double vlongdouble;\n+\n+void ffloat (float f);\n+void fdouble (double d);\n+void flongdouble (long double ld);\n+\n+void h (void)\n+{\n+  float f = 0;\n+  double d = 0;\n+  long double ld = 0;\n+\n+  ffloat (3.1); /* { dg-warning \"conversion\" } */\n+  vfloat = 3.1; /* { dg-warning \"conversion\" } */\n+  ffloat (3.1L); /* { dg-warning \"conversion\" } */\n+  vfloat = 3.1L; /* { dg-warning \"conversion\" } */\n+  fdouble (3.1L); /* { dg-warning \"conversion\" } */\n+  vdouble = 3.1L; /* { dg-warning \"conversion\" } */\n+  ffloat (vdouble); /* { dg-warning \"conversion\" } */\n+  vfloat = vdouble; /* { dg-warning \"conversion\" } */\n+  ffloat (vlongdouble); /* { dg-warning \"conversion\" } */\n+  vfloat = vlongdouble; /* { dg-warning \"conversion\" } */\n+  fdouble (vlongdouble); /* { dg-warning \"conversion\" } */\n+  vdouble = vlongdouble; /* { dg-warning \"conversion\" } */\n+\n+\n+  ffloat ((float) 3.1); \n+  vfloat = (float) 3.1;\n+  ffloat ((float) 3.1L);\n+  vfloat = (float) 3.1L; \n+  fdouble ((double) 3.1L); \n+  vdouble = (double) 3.1L; \n+  ffloat ((float) vdouble); \n+  vfloat = (float) vdouble; \n+  ffloat ((float) vlongdouble); \n+  vfloat = (float) vlongdouble;\n+  fdouble ((double) vlongdouble);\n+  vdouble = (double) vlongdouble;\n+\n+\n+  ffloat (3.0);\n+  vfloat = 3.0;\n+  ffloat (3.1f);\n+  vfloat = 3.1f;\n+  ffloat (0.25L);\n+  vfloat = 0.25L;\n+\n+\n+  fdouble (3.0);\n+  vdouble = 3.0;\n+  fdouble (3.1f);\n+  vdouble = 3.1f;\n+  fdouble (0.25L);\n+  vdouble = 0.25L;\n+\n+  flongdouble (3.0);\n+  vlongdouble = 3.0;\n+  flongdouble (3.1f);\n+  vlongdouble = 3.1f;\n+  flongdouble (0.25L);\n+  vlongdouble = 0.25L;\n+\n+  ffloat (f);\n+  vfloat = f;\n+  fdouble (f);\n+  vdouble = f;\n+  fdouble (d);\n+  vdouble = d;\n+  flongdouble (f);\n+  vlongdouble = f;\n+  flongdouble (d);\n+  vlongdouble = d;\n+  flongdouble (ld);\n+  vlongdouble = ld;\n+}\n+\n+"}]}