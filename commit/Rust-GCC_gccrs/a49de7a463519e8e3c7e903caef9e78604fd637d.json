{"sha": "a49de7a463519e8e3c7e903caef9e78604fd637d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ5ZGU3YTQ2MzUxOWU4ZTNjN2U5MDNjYWVmOWU3ODYwNGZkNjM3ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-12-18T22:16:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-12-18T22:16:24Z"}, "message": "re PR debug/68860 (FAIL: gcc.dg/guality/pr36728-1.c   -flto -O3 -g  line 17 arg1 == 1)\n\n\tPR debug/68860\n\t* ipa-split.c (split_function): Only perform caller side\n\tmodifications for decl_debug_args here.\n\t* cgraph.c: Include gimplify.h.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Add caller side\n\tdebug stmts for decl_debug_args.  Spelling fix in a comment.\n\t* tree-inline.c (tree_function_versioning): Populate decl_debug_args\n\tfor args_to_skip arguments and add callee side debug stmts.\n\tFormatting fixes.  Avoid shadowing i variable.\n\n\t* gcc.dg/guality/pr68860-1.c: New test.\n\t* gcc.dg/guality/pr68860-2.c: New test.\n\nFrom-SVN: r231840", "tree": {"sha": "9d8f68bcec113d5a41ce201bffd8fc2d69889feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d8f68bcec113d5a41ce201bffd8fc2d69889feb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a49de7a463519e8e3c7e903caef9e78604fd637d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49de7a463519e8e3c7e903caef9e78604fd637d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a49de7a463519e8e3c7e903caef9e78604fd637d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49de7a463519e8e3c7e903caef9e78604fd637d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca2c1b328327f998338cfa4b9e902e439cf57278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2c1b328327f998338cfa4b9e902e439cf57278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca2c1b328327f998338cfa4b9e902e439cf57278"}], "stats": {"total": 416, "additions": 334, "deletions": 82}, "files": [{"sha": "e0452951fd745ba58bbaf9d5ae1059c0031f86d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -1,3 +1,15 @@\n+2015-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/68860\n+\t* ipa-split.c (split_function): Only perform caller side\n+\tmodifications for decl_debug_args here.\n+\t* cgraph.c: Include gimplify.h.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Add caller side\n+\tdebug stmts for decl_debug_args.  Spelling fix in a comment.\n+\t* tree-inline.c (tree_function_versioning): Populate decl_debug_args\n+\tfor args_to_skip arguments and add callee side debug stmts.\n+\tFormatting fixes.  Avoid shadowing i variable.\n+\n 2015-12-18  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.c (nvptx_maybe_convert_symbolic_operand):"}, {"sha": "98846fca0bb6707efe96c1e3dc7e7bb3364c229f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-chkp.h\"\n #include \"context.h\"\n+#include \"gimplify.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -1275,7 +1276,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n       if (decl)\n \te = e->resolve_speculation (decl);\n       /* If types do not match, speculation was likely wrong. \n-         The direct edge was posisbly redirected to the clone with a different\n+         The direct edge was possibly redirected to the clone with a different\n \t signature.  We did not update the call statement yet, so compare it \n \t with the reference that still points to the proper type.  */\n       else if (!gimple_check_call_matching_types (e->call_stmt,\n@@ -1420,6 +1421,70 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n \n       gsi = gsi_for_stmt (e->call_stmt);\n+\n+      /* For optimized away parameters, add on the caller side\n+\t before the call\n+\t DEBUG D#X => parm_Y(D)\n+\t stmts and associate D#X with parm in decl_debug_args_lookup\n+\t vector to say for debug info that if parameter parm had been passed,\n+\t it would have value parm_Y(D).  */\n+      if (e->callee->clone.combined_args_to_skip && MAY_HAVE_DEBUG_STMTS)\n+\t{\n+\t  vec<tree, va_gc> **debug_args\n+\t    = decl_debug_args_lookup (e->callee->decl);\n+\t  tree old_decl = gimple_call_fndecl (e->call_stmt);\n+\t  if (debug_args && old_decl)\n+\t    {\n+\t      tree parm;\n+\t      unsigned i = 0, num;\n+\t      unsigned len = vec_safe_length (*debug_args);\n+\t      unsigned nargs = gimple_call_num_args (e->call_stmt);\n+\t      for (parm = DECL_ARGUMENTS (old_decl), num = 0;\n+\t\t   parm && num < nargs;\n+\t\t   parm = DECL_CHAIN (parm), num++)\n+\t\tif (bitmap_bit_p (e->callee->clone.combined_args_to_skip, num)\n+\t\t    && is_gimple_reg (parm))\n+\t\t  {\n+\t\t    unsigned last = i;\n+\n+\t\t    while (i < len && (**debug_args)[i] != DECL_ORIGIN (parm))\n+\t\t      i += 2;\n+\t\t    if (i >= len)\n+\t\t      {\n+\t\t\ti = 0;\n+\t\t\twhile (i < last\n+\t\t\t       && (**debug_args)[i] != DECL_ORIGIN (parm))\n+\t\t\t  i += 2;\n+\t\t\tif (i >= last)\n+\t\t\t  continue;\n+\t\t      }\n+\t\t    tree ddecl = (**debug_args)[i + 1];\n+\t\t    tree arg = gimple_call_arg (e->call_stmt, num);\n+\t\t    if (!useless_type_conversion_p (TREE_TYPE (ddecl),\n+\t\t\t\t\t\t    TREE_TYPE (arg)))\n+\t\t      {\n+\t\t\ttree rhs1;\n+\t\t\tif (!fold_convertible_p (TREE_TYPE (ddecl), arg))\n+\t\t\t  continue;\n+\t\t\tif (TREE_CODE (arg) == SSA_NAME\n+\t\t\t    && gimple_assign_cast_p (SSA_NAME_DEF_STMT (arg))\n+\t\t\t    && (rhs1\n+\t\t\t\t= gimple_assign_rhs1 (SSA_NAME_DEF_STMT (arg)))\n+\t\t\t    && useless_type_conversion_p (TREE_TYPE (ddecl),\n+\t\t\t\t\t\t\t  TREE_TYPE (rhs1)))\n+\t\t\t  arg = rhs1;\n+\t\t\telse\n+\t\t\t  arg = fold_convert (TREE_TYPE (ddecl), arg);\n+\t\t      }\n+\n+\t\t    gimple *def_temp\n+\t\t      = gimple_build_debug_bind (ddecl, unshare_expr (arg),\n+\t\t\t\t\t\t e->call_stmt);\n+\t\t    gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n+\t\t  }\n+\t    }\n+\t}\n+\n       gsi_replace (&gsi, new_stmt, false);\n       /* We need to defer cleaning EH info on the new statement to\n          fixup-cfg.  We may not have dominator information at this point"}, {"sha": "ca82e3a31d3c67b787b55b1b44686d1dd3e2cd18", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 29, "deletions": 65, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -1209,7 +1209,6 @@ split_function (basic_block return_bb, struct split_point *split_point,\n   gimple *last_stmt = NULL;\n   unsigned int i;\n   tree arg, ddef;\n-  vec<tree, va_gc> **debug_args = NULL;\n \n   if (dump_file)\n     {\n@@ -1432,73 +1431,38 @@ split_function (basic_block return_bb, struct split_point *split_point,\n      vector to say for debug info that if parameter parm had been passed,\n      it would have value parm_Y(D).  */\n   if (args_to_skip)\n-    for (parm = DECL_ARGUMENTS (current_function_decl), num = 0;\n-\t parm; parm = DECL_CHAIN (parm), num++)\n-      if (bitmap_bit_p (args_to_skip, num)\n-\t  && is_gimple_reg (parm))\n-\t{\n-\t  tree ddecl;\n-\t  gimple *def_temp;\n-\n-\t  /* This needs to be done even without MAY_HAVE_DEBUG_STMTS,\n-\t     otherwise if it didn't exist before, we'd end up with\n-\t     different SSA_NAME_VERSIONs between -g and -g0.  */\n-\t  arg = get_or_create_ssa_default_def (cfun, parm);\n-\t  if (!MAY_HAVE_DEBUG_STMTS)\n-\t    continue;\n-\n-\t  if (debug_args == NULL)\n-\t    debug_args = decl_debug_args_insert (node->decl);\n-\t  ddecl = make_node (DEBUG_EXPR_DECL);\n-\t  DECL_ARTIFICIAL (ddecl) = 1;\n-\t  TREE_TYPE (ddecl) = TREE_TYPE (parm);\n-\t  DECL_MODE (ddecl) = DECL_MODE (parm);\n-\t  vec_safe_push (*debug_args, DECL_ORIGIN (parm));\n-\t  vec_safe_push (*debug_args, ddecl);\n-\t  def_temp = gimple_build_debug_bind (ddecl, unshare_expr (arg),\n-\t\t\t\t\t      call);\n-\t  gsi_insert_after (&gsi, def_temp, GSI_NEW_STMT);\n-\t}\n-  /* And on the callee side, add\n-     DEBUG D#Y s=> parm\n-     DEBUG var => D#Y\n-     stmts to the first bb where var is a VAR_DECL created for the\n-     optimized away parameter in DECL_INITIAL block.  This hints\n-     in the debug info that var (whole DECL_ORIGIN is the parm PARM_DECL)\n-     is optimized away, but could be looked up at the call site\n-     as value of D#X there.  */\n-  if (debug_args != NULL)\n     {\n-      unsigned int i;\n-      tree var, vexpr;\n-      gimple_stmt_iterator cgsi;\n-      gimple *def_temp;\n-\n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-      var = BLOCK_VARS (DECL_INITIAL (node->decl));\n-      i = vec_safe_length (*debug_args);\n-      cgsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n-      do\n+      vec<tree, va_gc> **debug_args = NULL;\n+      unsigned i = 0, len = 0;\n+      if (MAY_HAVE_DEBUG_STMTS)\n \t{\n-\t  i -= 2;\n-\t  while (var != NULL_TREE\n-\t\t && DECL_ABSTRACT_ORIGIN (var) != (**debug_args)[i])\n-\t    var = TREE_CHAIN (var);\n-\t  if (var == NULL_TREE)\n-\t    break;\n-\t  vexpr = make_node (DEBUG_EXPR_DECL);\n-\t  parm = (**debug_args)[i];\n-\t  DECL_ARTIFICIAL (vexpr) = 1;\n-\t  TREE_TYPE (vexpr) = TREE_TYPE (parm);\n-\t  DECL_MODE (vexpr) = DECL_MODE (parm);\n-\t  def_temp = gimple_build_debug_source_bind (vexpr, parm,\n-\t\t\t\t\t\t     NULL);\n-\t  gsi_insert_before (&cgsi, def_temp, GSI_SAME_STMT);\n-\t  def_temp = gimple_build_debug_bind (var, vexpr, NULL);\n-\t  gsi_insert_before (&cgsi, def_temp, GSI_SAME_STMT);\n+\t  debug_args = decl_debug_args_lookup (node->decl);\n+\t  if (debug_args)\n+\t    len = vec_safe_length (*debug_args);\n \t}\n-      while (i);\n-      pop_cfun ();\n+      for (parm = DECL_ARGUMENTS (current_function_decl), num = 0;\n+\t   parm; parm = DECL_CHAIN (parm), num++)\n+\tif (bitmap_bit_p (args_to_skip, num) && is_gimple_reg (parm))\n+\t  {\n+\t    tree ddecl;\n+\t    gimple *def_temp;\n+\n+\t    /* This needs to be done even without MAY_HAVE_DEBUG_STMTS,\n+\t       otherwise if it didn't exist before, we'd end up with\n+\t       different SSA_NAME_VERSIONs between -g and -g0.  */\n+\t    arg = get_or_create_ssa_default_def (cfun, parm);\n+\t    if (!MAY_HAVE_DEBUG_STMTS || debug_args == NULL)\n+\t      continue;\n+\n+\t    while (i < len && (**debug_args)[i] != DECL_ORIGIN (parm))\n+\t      i += 2;\n+\t    if (i >= len)\n+\t      continue;\n+\t    ddecl = (**debug_args)[i + 1];\n+\t    def_temp\n+\t      = gimple_build_debug_bind (ddecl, unshare_expr (arg), call);\n+\t    gsi_insert_after (&gsi, def_temp, GSI_NEW_STMT);\n+\t  }\n     }\n \n   /* We avoid address being taken on any variable used by split part,"}, {"sha": "ceba598dc4ebb7a50a80b07c781aa014347ae53e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -1,3 +1,9 @@\n+2015-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/68860\n+\t* gcc.dg/guality/pr68860-1.c: New test.\n+\t* gcc.dg/guality/pr68860-2.c: New test.\n+\n 2015-12-18  Nathan Sidwell  <nathan@acm.org>\n \n \t* lib/target-supports.exp (check_effective_target_cilkplus): Not nvptx."}, {"sha": "8c8d8354587fb8d8ba8d28ae1b28d53ae576a4b2", "filename": "gcc/testsuite/gcc.dg/guality/pr68860-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-1.c?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -0,0 +1,54 @@\n+/* PR debug/68860 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+static int __attribute__((noinline))\n+foo (int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8)\n+{\n+  char *x = __builtin_alloca (arg7);\n+  int __attribute__ ((aligned(32))) y;\n+\n+  y = 2;\n+  asm (NOP : \"=m\" (y) : \"m\" (y));\n+  x[0] = 25 + arg8;\n+  asm volatile (NOP : \"=m\" (x[0]) : \"m\" (x[0]));\n+  return y;\n+}\n+\n+/* On s390(x) r2 and r3 are (depending on the optimization level) used\n+   when adjusting the addresses in order to meet the alignment\n+   requirements above.  They usually hold the function arguments arg1\n+   and arg2.  So it is expected that these values are unavailable in\n+   some of these tests.  */\n+\n+/* { dg-final { gdb-test 14 \"arg1\" \"1\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 14 \"arg2\" \"2\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 14 \"arg3\" \"3\" } } */\n+/* { dg-final { gdb-test 14 \"arg4\" \"4\" } } */\n+/* { dg-final { gdb-test 14 \"arg5\" \"5\" } } */\n+/* { dg-final { gdb-test 14 \"arg6\" \"6\" } } */\n+/* { dg-final { gdb-test 14 \"arg7\" \"30\" } } */\n+/* { dg-final { gdb-test 14 \"arg8\" \"7\" } } */\n+/* { dg-final { gdb-test 14 \"y\" \"2\" } } */\n+/* { dg-final { gdb-test 16 \"arg1\" \"1\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 16 \"arg2\" \"2\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 16 \"arg3\" \"3\" } } */\n+/* { dg-final { gdb-test 16 \"arg4\" \"4\" } } */\n+/* { dg-final { gdb-test 16 \"arg5\" \"5\" } } */\n+/* { dg-final { gdb-test 16 \"arg6\" \"6\" } } */\n+/* { dg-final { gdb-test 16 \"arg7\" \"30\" } } */\n+/* { dg-final { gdb-test 16 \"arg8\" \"7\" } } */\n+/* { dg-final { gdb-test 16 \"*x\" \"(char) 32\" } } */\n+/* { dg-final { gdb-test 16 \"y\" \"2\" } } */\n+\n+int\n+main ()\n+{\n+  int l = 0;\n+  asm volatile (\"\" : \"=r\" (l) : \"0\" (l));\n+  foo (l + 1, l + 2, l + 3, l + 4, l + 5, l + 6, l + 30, 7);\n+  asm volatile (\"\" :: \"r\" (l));\n+  return 0;\n+}"}, {"sha": "070efbcd10ce86d7cc48055da2e10f11fb903e8e", "filename": "gcc/testsuite/gcc.dg/guality/pr68860-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr68860-2.c?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -0,0 +1,54 @@\n+/* PR debug/68860 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+int __attribute__((noinline))\n+foo (int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8)\n+{\n+  char *x = __builtin_alloca (arg7);\n+  int __attribute__ ((aligned(32))) y;\n+\n+  y = 2;\n+  asm (NOP : \"=m\" (y) : \"m\" (y));\n+  x[0] = 25 + arg8;\n+  asm volatile (NOP : \"=m\" (x[0]) : \"m\" (x[0]));\n+  return y;\n+}\n+\n+/* On s390(x) r2 and r3 are (depending on the optimization level) used\n+   when adjusting the addresses in order to meet the alignment\n+   requirements above.  They usually hold the function arguments arg1\n+   and arg2.  So it is expected that these values are unavailable in\n+   some of these tests.  */\n+\n+/* { dg-final { gdb-test 14 \"arg1\" \"1\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 14 \"arg2\" \"2\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 14 \"arg3\" \"3\" } } */\n+/* { dg-final { gdb-test 14 \"arg4\" \"4\" } } */\n+/* { dg-final { gdb-test 14 \"arg5\" \"5\" } } */\n+/* { dg-final { gdb-test 14 \"arg6\" \"6\" } } */\n+/* { dg-final { gdb-test 14 \"arg7\" \"30\" } } */\n+/* { dg-final { gdb-test 14 \"arg8\" \"7\" } } */\n+/* { dg-final { gdb-test 14 \"y\" \"2\" } } */\n+/* { dg-final { gdb-test 16 \"arg1\" \"1\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 16 \"arg2\" \"2\" { target { ! \"s390*-*-*\" } } } } */\n+/* { dg-final { gdb-test 16 \"arg3\" \"3\" } } */\n+/* { dg-final { gdb-test 16 \"arg4\" \"4\" } } */\n+/* { dg-final { gdb-test 16 \"arg5\" \"5\" } } */\n+/* { dg-final { gdb-test 16 \"arg6\" \"6\" } } */\n+/* { dg-final { gdb-test 16 \"arg7\" \"30\" } } */\n+/* { dg-final { gdb-test 16 \"arg8\" \"7\" } } */\n+/* { dg-final { gdb-test 16 \"*x\" \"(char) 32\" } } */\n+/* { dg-final { gdb-test 16 \"y\" \"2\" } } */\n+\n+int\n+main ()\n+{\n+  int l = 0;\n+  asm volatile (\"\" : \"=r\" (l) : \"0\" (l));\n+  foo (l + 1, l + 2, l + 3, l + 4, l + 5, l + 6, l + 30, 7);\n+  asm volatile (\"\" :: \"r\" (l));\n+  return 0;\n+}"}, {"sha": "36c9622544927c3e7c566977d6ba5520c5cb7a45", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 113, "deletions": 16, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49de7a463519e8e3c7e903caef9e78604fd637d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a49de7a463519e8e3c7e903caef9e78604fd637d", "patch": "@@ -5668,6 +5668,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   basic_block old_entry_block, bb;\n   auto_vec<gimple *, 10> init_stmts;\n   tree vars = NULL_TREE;\n+  bitmap debug_args_to_skip = args_to_skip;\n \n   gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n \t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n@@ -5740,9 +5741,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   /* Copy the function's static chain.  */\n   p = DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl;\n   if (p)\n-    DECL_STRUCT_FUNCTION (new_decl)->static_chain_decl =\n-      copy_static_chain (DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl,\n-\t\t\t &id);\n+    DECL_STRUCT_FUNCTION (new_decl)->static_chain_decl\n+      = copy_static_chain (p, &id);\n \n   /* If there's a tree_map, prepare for substitution.  */\n   if (tree_map)\n@@ -5752,29 +5752,39 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \treplace_info = (*tree_map)[i];\n \tif (replace_info->replace_p)\n \t  {\n+\t    int parm_num = -1;\n \t    if (!replace_info->old_tree)\n \t      {\n-\t\tint i = replace_info->parm_num;\n+\t\tint p = replace_info->parm_num;\n \t\ttree parm;\n-\t\ttree req_type;\n+\t\ttree req_type, new_type;\n \n-\t\tfor (parm = DECL_ARGUMENTS (old_decl); i; parm = DECL_CHAIN (parm))\n-\t\t  i --;\n+\t\tfor (parm = DECL_ARGUMENTS (old_decl); p;\n+\t\t     parm = DECL_CHAIN (parm))\n+\t\t  p--;\n \t\treplace_info->old_tree = parm;\n+\t\tparm_num = replace_info->parm_num;\n \t\treq_type = TREE_TYPE (parm);\n-\t\tif (!useless_type_conversion_p (req_type, TREE_TYPE (replace_info->new_tree)))\n+\t\tnew_type = TREE_TYPE (replace_info->new_tree);\n+\t\tif (!useless_type_conversion_p (req_type, new_type))\n \t\t  {\n \t\t    if (fold_convertible_p (req_type, replace_info->new_tree))\n-\t\t      replace_info->new_tree = fold_build1 (NOP_EXPR, req_type, replace_info->new_tree);\n-\t\t    else if (TYPE_SIZE (req_type) == TYPE_SIZE (TREE_TYPE (replace_info->new_tree)))\n-\t\t      replace_info->new_tree = fold_build1 (VIEW_CONVERT_EXPR, req_type, replace_info->new_tree);\n+\t\t      replace_info->new_tree\n+\t\t\t= fold_build1 (NOP_EXPR, req_type,\n+\t\t\t\t       replace_info->new_tree);\n+\t\t    else if (TYPE_SIZE (req_type) == TYPE_SIZE (new_type))\n+\t\t      replace_info->new_tree\n+\t\t\t= fold_build1 (VIEW_CONVERT_EXPR, req_type,\n+\t\t\t\t       replace_info->new_tree);\n \t\t    else\n \t\t      {\n \t\t\tif (dump_file)\n \t\t\t  {\n \t\t\t    fprintf (dump_file, \"    const \");\n-\t\t\t    print_generic_expr (dump_file, replace_info->new_tree, 0);\n-\t\t\t    fprintf (dump_file, \"  can't be converted to param \");\n+\t\t\t    print_generic_expr (dump_file,\n+\t\t\t\t\t\treplace_info->new_tree, 0);\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"  can't be converted to param \");\n \t\t\t    print_generic_expr (dump_file, parm, 0);\n \t\t\t    fprintf (dump_file, \"\\n\");\n \t\t\t  }\n@@ -5792,14 +5802,38 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t\t\t\t\t    &vars);\n \t\tif (init)\n \t\t  init_stmts.safe_push (init);\n+\t\tif (MAY_HAVE_DEBUG_STMTS && args_to_skip)\n+\t\t  {\n+\t\t    if (parm_num == -1)\n+\t\t      {\n+\t\t\ttree parm;\n+\t\t\tint p;\n+\t\t\tfor (parm = DECL_ARGUMENTS (old_decl), p = 0; parm;\n+\t\t\t     parm = DECL_CHAIN (parm), p++)\n+\t\t\t  if (parm == replace_info->old_tree)\n+\t\t\t    {\n+\t\t\t      parm_num = p;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t      }\n+\t\t    if (parm_num != -1)\n+\t\t      {\n+\t\t\tif (debug_args_to_skip == args_to_skip)\n+\t\t\t  {\n+\t\t\t    debug_args_to_skip = BITMAP_ALLOC (NULL);\n+\t\t\t    bitmap_copy (debug_args_to_skip, args_to_skip);\n+\t\t\t  }\n+\t\t\tbitmap_clear_bit (debug_args_to_skip, parm_num);\n+\t\t      }\n+\t\t  }\n \t      }\n \t  }\n       }\n   /* Copy the function's arguments.  */\n   if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n-    DECL_ARGUMENTS (new_decl) =\n-      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n-      \t\t\t\t     args_to_skip, &vars);\n+    DECL_ARGUMENTS (new_decl)\n+      = copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n+\t\t\t\t       args_to_skip, &vars);\n \n   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (new_decl)) = new_decl;\n@@ -5914,6 +5948,69 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t}\n     }\n \n+  if (debug_args_to_skip && MAY_HAVE_DEBUG_STMTS)\n+    {\n+      tree parm;\n+      vec<tree, va_gc> **debug_args = NULL;\n+      unsigned int len = 0;\n+      for (parm = DECL_ARGUMENTS (old_decl), i = 0;\n+\t   parm; parm = DECL_CHAIN (parm), i++)\n+\tif (bitmap_bit_p (debug_args_to_skip, i) && is_gimple_reg (parm))\n+\t  {\n+\t    tree ddecl;\n+\n+\t    if (debug_args == NULL)\n+\t      {\n+\t\tdebug_args = decl_debug_args_insert (new_decl);\n+\t\tlen = vec_safe_length (*debug_args);\n+\t      }\n+\t    ddecl = make_node (DEBUG_EXPR_DECL);\n+\t    DECL_ARTIFICIAL (ddecl) = 1;\n+\t    TREE_TYPE (ddecl) = TREE_TYPE (parm);\n+\t    DECL_MODE (ddecl) = DECL_MODE (parm);\n+\t    vec_safe_push (*debug_args, DECL_ORIGIN (parm));\n+\t    vec_safe_push (*debug_args, ddecl);\n+\t  }\n+      if (debug_args != NULL)\n+\t{\n+\t  /* On the callee side, add\n+\t     DEBUG D#Y s=> parm\n+\t     DEBUG var => D#Y\n+\t     stmts to the first bb where var is a VAR_DECL created for the\n+\t     optimized away parameter in DECL_INITIAL block.  This hints\n+\t     in the debug info that var (whole DECL_ORIGIN is the parm\n+\t     PARM_DECL) is optimized away, but could be looked up at the\n+\t     call site as value of D#X there.  */\n+\t  tree var = vars, vexpr;\n+\t  gimple_stmt_iterator cgsi\n+\t    = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t  gimple *def_temp;\n+\t  var = vars;\n+\t  i = vec_safe_length (*debug_args);\n+\t  do\n+\t    {\n+\t      i -= 2;\n+\t      while (var != NULL_TREE\n+\t\t     && DECL_ABSTRACT_ORIGIN (var) != (**debug_args)[i])\n+\t\tvar = TREE_CHAIN (var);\n+\t      if (var == NULL_TREE)\n+\t\tbreak;\n+\t      vexpr = make_node (DEBUG_EXPR_DECL);\n+\t      parm = (**debug_args)[i];\n+\t      DECL_ARTIFICIAL (vexpr) = 1;\n+\t      TREE_TYPE (vexpr) = TREE_TYPE (parm);\n+\t      DECL_MODE (vexpr) = DECL_MODE (parm);\n+\t      def_temp = gimple_build_debug_bind (var, vexpr, NULL);\n+\t      gsi_insert_before (&cgsi, def_temp, GSI_NEW_STMT);\n+\t      def_temp = gimple_build_debug_source_bind (vexpr, parm, NULL);\n+\t      gsi_insert_before (&cgsi, def_temp, GSI_NEW_STMT);\n+\t    }\n+\t  while (i > len);\n+\t}\n+    }\n+\n+  if (debug_args_to_skip && debug_args_to_skip != args_to_skip)\n+    BITMAP_FREE (debug_args_to_skip);\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n "}]}