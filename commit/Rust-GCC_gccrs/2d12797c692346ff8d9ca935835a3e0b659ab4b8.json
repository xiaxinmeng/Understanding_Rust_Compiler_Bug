{"sha": "2d12797c692346ff8d9ca935835a3e0b659ab4b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQxMjc5N2M2OTIzNDZmZjhkOWNhOTM1ODM1YTNlMGI2NTlhYjRiOA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-06T16:17:41Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-06T16:17:41Z"}, "message": "re PR c++/8715 ('~' operator for unsigned char and conversion to bool)\n\n2008-08-06  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR 8715\n\t* c-common.c (warn_for_sign_compare): New. Handle separately the\n\tcase that 'constant' is zero.\n\t* c-typeck.c (build_binary_op): Move code to c-common.c\ncp/\n\t* typeck.c (cp_build_binary_op): Move code to c-common.c.\ntestsuite/\n\t* gcc.dg/pr8715.c: New.\n\t* g++.dg/warn/pr8715.C: New.\n\nFrom-SVN: r138814", "tree": {"sha": "a1e568cec33c05d17fd32cf2c3885137e848b1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1e568cec33c05d17fd32cf2c3885137e848b1ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d12797c692346ff8d9ca935835a3e0b659ab4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d12797c692346ff8d9ca935835a3e0b659ab4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d12797c692346ff8d9ca935835a3e0b659ab4b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d12797c692346ff8d9ca935835a3e0b659ab4b8/comments", "author": null, "committer": null, "parents": [{"sha": "0a2aaacccae56098361e7b602dd823ac2c9a850e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2aaacccae56098361e7b602dd823ac2c9a850e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2aaacccae56098361e7b602dd823ac2c9a850e"}], "stats": {"total": 421, "additions": 195, "deletions": 226}, "files": [{"sha": "47226532a561036293dabcd9040a68d1c2d7791d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -1,3 +1,10 @@\n+2008-08-06  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 8715\n+\t* c-common.c (warn_for_sign_compare): New. Handle separately the\n+\tcase that 'constant' is zero.\n+\t* c-typeck.c (build_binary_op): Move code to c-common.c\n+\t\n 2008-08-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/alpha/alpha.c (alpha_preferred_reload_class,"}, {"sha": "d0ff04be79d2ed8ef351897d8f53a15cf8acf571", "filename": "gcc/c-common.c", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -8202,4 +8202,145 @@ warn_for_div_by_zero (tree divisor)\n     warning (OPT_Wdiv_by_zero, \"division by zero\");\n }\n \n+/* Subroutine of build_binary_op. Give warnings for comparisons\n+   between signed and unsigned quantities that may fail. Do the\n+   checking based on the original operand trees ORIG_OP0 and ORIG_OP1,\n+   so that casts will be considered, but default promotions won't\n+   be. \n+\n+   The arguments of this function map directly to local variables\n+   of build_binary_op.  */\n+\n+void \n+warn_for_sign_compare (tree orig_op0, tree orig_op1, \n+\t\t       tree op0, tree op1, \n+\t\t       tree result_type, enum tree_code resultcode)\n+{\n+  int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n+  int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n+  int unsignedp0, unsignedp1;\n+  \n+  /* In C++, check for comparison of different enum types.  */\n+  if (c_dialect_cxx()\n+      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n+      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n+      != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n+    {\n+      warning (OPT_Wsign_compare, \"comparison between types %qT and %qT\",\n+               TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+    }\n+\n+  /* Do not warn if the comparison is being done in a signed type,\n+     since the signed type will only be chosen if it can represent\n+     all the values of the unsigned type.  */\n+  if (!TYPE_UNSIGNED (result_type))\n+    /* OK */;\n+  /* Do not warn if both operands are unsigned.  */\n+  else if (op0_signed == op1_signed)\n+    /* OK */;\n+  else\n+    {\n+      tree sop, uop;\n+      bool ovf;\n+      \n+      if (op0_signed)\n+        sop = orig_op0, uop = orig_op1;\n+      else \n+        sop = orig_op1, uop = orig_op0;\n+\n+      STRIP_TYPE_NOPS (sop); \n+      STRIP_TYPE_NOPS (uop);\n+\n+      /* Do not warn if the signed quantity is an unsuffixed integer\n+         literal (or some static constant expression involving such\n+         literals or a conditional expression involving such literals)\n+         and it is non-negative.  */\n+      if (tree_expr_nonnegative_warnv_p (sop, &ovf))\n+        /* OK */;\n+      /* Do not warn if the comparison is an equality operation, the\n+         unsigned quantity is an integral constant, and it would fit\n+         in the result if the result were signed.  */\n+      else if (TREE_CODE (uop) == INTEGER_CST\n+               && (resultcode == EQ_EXPR || resultcode == NE_EXPR)\n+               && int_fits_type_p (uop, c_common_signed_type (result_type)))\n+        /* OK */;\n+      /* In C, do not warn if the unsigned quantity is an enumeration\n+         constant and its maximum value would fit in the result if the\n+         result were signed.  */\n+      else if (!c_dialect_cxx() && TREE_CODE (uop) == INTEGER_CST\n+               && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n+               && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n+                                   c_common_signed_type (result_type)))\n+        /* OK */;\n+      else \n+        warning (OPT_Wsign_compare, \n+                 \"comparison between signed and unsigned integer expressions\");\n+    }\n+  \n+  /* Warn if two unsigned values are being compared in a size larger\n+     than their original size, and one (and only one) is the result of\n+     a `~' operator.  This comparison will always fail.\n+     \n+     Also warn if one operand is a constant, and the constant does not\n+     have all bits set that are set in the ~ operand when it is\n+     extended.  */\n+\n+  op0 = get_narrower (op0, &unsignedp0);\n+  op1 = get_narrower (op1, &unsignedp1);\n+  \n+  if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n+      ^ (TREE_CODE (op1) == BIT_NOT_EXPR))\n+    {\n+      if (TREE_CODE (op0) == BIT_NOT_EXPR)\n+\top0 = get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n+      if (TREE_CODE (op1) == BIT_NOT_EXPR)\n+\top1 = get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n+\n+      if (host_integerp (op0, 0) || host_integerp (op1, 0))\n+        {\n+          tree primop;\n+          HOST_WIDE_INT constant, mask;\n+          int unsignedp;\n+          unsigned int bits;\n+          \n+          if (host_integerp (op0, 0))\n+            {\n+              primop = op1;\n+              unsignedp = unsignedp1;\n+              constant = tree_low_cst (op0, 0);\n+            }\n+          else\n+            {\n+              primop = op0;\n+              unsignedp = unsignedp0;\n+              constant = tree_low_cst (op1, 0);\n+            }\n+          \n+          bits = TYPE_PRECISION (TREE_TYPE (primop));\n+          if (bits < TYPE_PRECISION (result_type)\n+              && bits < HOST_BITS_PER_LONG && unsignedp)\n+            {\n+              mask = (~ (HOST_WIDE_INT) 0) << bits;\n+              if ((mask & constant) != mask)\n+\t\t{\n+\t\t  if (constant == 0)\n+\t\t    warning (OPT_Wsign_compare, \n+\t\t\t     \"promoted ~unsigned is always non-zero\");\n+\t\t  else\n+\t\t    warning (OPT_Wsign_compare, \n+\t\t\t     \"comparison of promoted ~unsigned with constant\");\n+\t\t}\n+            }\n+        }\n+      else if (unsignedp0 && unsignedp1\n+               && (TYPE_PRECISION (TREE_TYPE (op0))\n+                   < TYPE_PRECISION (result_type))\n+               && (TYPE_PRECISION (TREE_TYPE (op1))\n+                   < TYPE_PRECISION (result_type)))\n+        warning (OPT_Wsign_compare, \n+                 \"comparison of promoted ~unsigned with unsigned\");\n+    }\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "0f2a359c16f0bf07ec49f1dace7c33276af9feaf", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -928,6 +928,10 @@ extern void warn_about_parentheses (enum tree_code, enum tree_code,\n \t\t\t\t    enum tree_code);\n extern void warn_for_unused_label (tree label);\n extern void warn_for_div_by_zero (tree divisor);\n+extern void warn_for_sign_compare (tree orig_op0, tree orig_op1, \n+\t\t\t\t   tree op0, tree op1, \n+\t\t\t\t   tree result_type, \n+\t\t\t\t   enum tree_code resultcode);\n \n /* In c-gimplify.c  */\n extern void c_genericize (tree);"}, {"sha": "bacff90be02afdf98a4fbb9770f79560f95fef8d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 118, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -8372,124 +8372,10 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  converted = 1;\n \t  resultcode = xresultcode;\n \n-\t  if (warn_sign_compare && skip_evaluation == 0)\n-\t    {\n-\t      int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n-\t      int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n-\t      int unsignedp0, unsignedp1;\n-\t      tree primop0 = get_narrower (op0, &unsignedp0);\n-\t      tree primop1 = get_narrower (op1, &unsignedp1);\n-\n-\t      xop0 = orig_op0;\n-\t      xop1 = orig_op1;\n-\t      STRIP_TYPE_NOPS (xop0);\n-\t      STRIP_TYPE_NOPS (xop1);\n-\n-\t      /* Give warnings for comparisons between signed and unsigned\n-\t\t quantities that may fail.\n-\n-\t\t Do the checking based on the original operand trees, so that\n-\t\t casts will be considered, but default promotions won't be.\n-\n-\t\t Do not warn if the comparison is being done in a signed type,\n-\t\t since the signed type will only be chosen if it can represent\n-\t\t all the values of the unsigned type.  */\n-\t      if (!TYPE_UNSIGNED (result_type))\n-\t\t/* OK */;\n-\t      /* Do not warn if both operands are the same signedness.  */\n-\t      else if (op0_signed == op1_signed)\n-\t\t/* OK */;\n-\t      else\n-\t\t{\n-\t\t  tree sop, uop;\n-\t\t  bool ovf;\n-\n-\t\t  if (op0_signed)\n-\t\t    sop = xop0, uop = xop1;\n-\t\t  else\n-\t\t    sop = xop1, uop = xop0;\n-\n-\t\t  /* Do not warn if the signed quantity is an\n-\t\t     unsuffixed integer literal (or some static\n-\t\t     constant expression involving such literals or a\n-\t\t     conditional expression involving such literals)\n-\t\t     and it is non-negative.  */\n-\t\t  if (tree_expr_nonnegative_warnv_p (sop, &ovf))\n-\t\t    /* OK */;\n-\t\t  /* Do not warn if the comparison is an equality operation,\n-\t\t     the unsigned quantity is an integral constant, and it\n-\t\t     would fit in the result if the result were signed.  */\n-\t\t  else if (TREE_CODE (uop) == INTEGER_CST\n-\t\t\t   && (resultcode == EQ_EXPR || resultcode == NE_EXPR)\n-\t\t\t   && int_fits_type_p\n-\t\t\t   (uop, c_common_signed_type (result_type)))\n-\t\t    /* OK */;\n-\t\t  /* Do not warn if the unsigned quantity is an enumeration\n-\t\t     constant and its maximum value would fit in the result\n-\t\t     if the result were signed.  */\n-\t\t  else if (TREE_CODE (uop) == INTEGER_CST\n-\t\t\t   && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n-\t\t\t   && int_fits_type_p\n-\t\t\t   (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n-\t\t\t    c_common_signed_type (result_type)))\n-\t\t    /* OK */;\n-\t\t  else\n-\t\t    warning (OPT_Wsign_compare, \"comparison between signed and unsigned\");\n-\t\t}\n-\n-\t      /* Warn if two unsigned values are being compared in a size\n-\t\t larger than their original size, and one (and only one) is the\n-\t\t result of a `~' operator.  This comparison will always fail.\n-\n-\t\t Also warn if one operand is a constant, and the constant\n-\t\t does not have all bits set that are set in the ~ operand\n-\t\t when it is extended.  */\n-\n-\t      if ((TREE_CODE (primop0) == BIT_NOT_EXPR)\n-\t\t  != (TREE_CODE (primop1) == BIT_NOT_EXPR))\n-\t\t{\n-\t\t  if (TREE_CODE (primop0) == BIT_NOT_EXPR)\n-\t\t    primop0 = get_narrower (TREE_OPERAND (primop0, 0),\n-\t\t\t\t\t    &unsignedp0);\n-\t\t  else\n-\t\t    primop1 = get_narrower (TREE_OPERAND (primop1, 0),\n-\t\t\t\t\t    &unsignedp1);\n-\n-\t\t  if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n-\t\t    {\n-\t\t      tree primop;\n-\t\t      HOST_WIDE_INT constant, mask;\n-\t\t      int unsignedp, bits;\n-\n-\t\t      if (host_integerp (primop0, 0))\n-\t\t\t{\n-\t\t\t  primop = primop1;\n-\t\t\t  unsignedp = unsignedp1;\n-\t\t\t  constant = tree_low_cst (primop0, 0);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  primop = primop0;\n-\t\t\t  unsignedp = unsignedp0;\n-\t\t\t  constant = tree_low_cst (primop1, 0);\n-\t\t\t}\n-\n-\t\t      bits = TYPE_PRECISION (TREE_TYPE (primop));\n-\t\t      if (bits < TYPE_PRECISION (result_type)\n-\t\t\t  && bits < HOST_BITS_PER_WIDE_INT && unsignedp)\n-\t\t\t{\n-\t\t\t  mask = (~(HOST_WIDE_INT) 0) << bits;\n-\t\t\t  if ((mask & constant) != mask)\n-\t\t\t    warning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with constant\");\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (unsignedp0 && unsignedp1\n-\t\t\t   && (TYPE_PRECISION (TREE_TYPE (primop0))\n-\t\t\t       < TYPE_PRECISION (result_type))\n-\t\t\t   && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t\t       < TYPE_PRECISION (result_type)))\n-\t\t    warning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with unsigned\");\n-\t\t}\n+\t  if (warn_sign_compare && !skip_evaluation)\n+            {\n+              warn_for_sign_compare (orig_op0, orig_op1, op0, op1, \n+                                     result_type, resultcode);\n \t    }\n \t}\n     }"}, {"sha": "c55e4b5c3066c940cc61050d170d43b3efd95874", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -1,3 +1,8 @@\n+2008-08-06  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 8715\n+\t* typeck.c (cp_build_binary_op): Move code to c-common.c.\n+\n 2008-08-05  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/37016"}, {"sha": "792a77cc1a85a6055e2b9284f41f2bfbbb595112", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 108, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -3839,115 +3839,11 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  && warn_sign_compare\n \t  /* Do not warn until the template is instantiated; we cannot\n \t     bound the ranges of the arguments until that point.  */\n-\t  && !processing_template_decl)\n+\t  && !processing_template_decl\n+          && (complain & tf_warning))\n \t{\n-\t  int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n-\t  int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n-\n-\t  int unsignedp0, unsignedp1;\n-\t  tree primop0 = get_narrower (op0, &unsignedp0);\n-\t  tree primop1 = get_narrower (op1, &unsignedp1);\n-\n-\t  /* Check for comparison of different enum types.  */\n-\t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n-\t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n-\t\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1))\n-\t      && (complain & tf_warning))\n-\t    {\n-\t      warning (OPT_Wsign_compare, \"comparison between types %q#T and %q#T\",\n-\t\t       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n-\t    }\n-\n-\t  /* Give warnings for comparisons between signed and unsigned\n-\t     quantities that may fail.  */\n-\t  /* Do the checking based on the original operand trees, so that\n-\t     casts will be considered, but default promotions won't be.  */\n-\n-\t  /* Do not warn if the comparison is being done in a signed type,\n-\t     since the signed type will only be chosen if it can represent\n-\t     all the values of the unsigned type.  */\n-\t  if (!TYPE_UNSIGNED (result_type))\n-\t    /* OK */;\n-\t  /* Do not warn if both operands are unsigned.  */\n-\t  else if (op0_signed == op1_signed)\n-\t    /* OK */;\n-\t  /* Do not warn if the signed quantity is an unsuffixed\n-\t     integer literal (or some static constant expression\n-\t     involving such literals or a conditional expression\n-\t     involving such literals) and it is non-negative.  */\n-\t  else if ((op0_signed && tree_expr_nonnegative_p (orig_op0))\n-\t\t   || (op1_signed && tree_expr_nonnegative_p (orig_op1)))\n-\t    /* OK */;\n-\t  /* Do not warn if the comparison is an equality operation,\n-\t     the unsigned quantity is an integral constant and it does\n-\t     not use the most significant bit of result_type.  */\n-\t  else if ((resultcode == EQ_EXPR || resultcode == NE_EXPR)\n-\t\t   && ((op0_signed && TREE_CODE (orig_op1) == INTEGER_CST\n-\t\t\t&& int_fits_type_p (orig_op1, c_common_signed_type\n-\t\t\t\t\t    (result_type)))\n-\t\t\t|| (op1_signed && TREE_CODE (orig_op0) == INTEGER_CST\n-\t\t\t    && int_fits_type_p (orig_op0, c_common_signed_type\n-\t\t\t\t\t\t(result_type)))))\n-\t    /* OK */;\n-\t  else if (complain & tf_warning)\n-\t    warning (OPT_Wsign_compare, \n-\t\t     \"comparison between signed and unsigned integer expressions\");\n-\n-\t  /* Warn if two unsigned values are being compared in a size\n-\t     larger than their original size, and one (and only one) is the\n-\t     result of a `~' operator.  This comparison will always fail.\n-\n-\t     Also warn if one operand is a constant, and the constant does not\n-\t     have all bits set that are set in the ~ operand when it is\n-\t     extended.  */\n-\n-\t  if ((TREE_CODE (primop0) == BIT_NOT_EXPR)\n-\t      ^ (TREE_CODE (primop1) == BIT_NOT_EXPR))\n-\t    {\n-\t      if (TREE_CODE (primop0) == BIT_NOT_EXPR)\n-\t\tprimop0 = get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n-\t      if (TREE_CODE (primop1) == BIT_NOT_EXPR)\n-\t\tprimop1 = get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n-\n-\t      if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n-\t\t{\n-\t\t  tree primop;\n-\t\t  HOST_WIDE_INT constant, mask;\n-\t\t  int unsignedp;\n-\t\t  unsigned int bits;\n-\n-\t\t  if (host_integerp (primop0, 0))\n-\t\t    {\n-\t\t      primop = primop1;\n-\t\t      unsignedp = unsignedp1;\n-\t\t      constant = tree_low_cst (primop0, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      primop = primop0;\n-\t\t      unsignedp = unsignedp0;\n-\t\t      constant = tree_low_cst (primop1, 0);\n-\t\t    }\n-\n-\t\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n-\t\t  if (bits < TYPE_PRECISION (result_type)\n-\t\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n-\t\t    {\n-\t\t      mask = (~ (HOST_WIDE_INT) 0) << bits;\n-\t\t      if ((mask & constant) != mask\n-\t\t\t  && (complain & tf_warning))\n-\t\t\twarning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with constant\");\n-\t\t    }\n-\t\t}\n-\t      else if (unsignedp0 && unsignedp1\n-\t\t       && (TYPE_PRECISION (TREE_TYPE (primop0))\n-\t\t\t   < TYPE_PRECISION (result_type))\n-\t\t       && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t\t   < TYPE_PRECISION (result_type))\n-\t\t       && (complain & tf_warning))\n-\t\twarning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with unsigned\");\n-\t    }\n+            warn_for_sign_compare (orig_op0, orig_op1, op0, op1, \n+                                   result_type, resultcode);\n \t}\n     }\n "}, {"sha": "ad00fee706c26df696f72a319a30c0d1981ce253", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -1,3 +1,9 @@\n+2008-08-06  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 8715\n+\t* gcc.dg/pr8715.c: New.\n+\t* g++.dg/warn/pr8715.C: New.\n+\t\n 2008-08-06  Marc Gauthier  <marc@tensilica.com>\n \n \t* lib/target-supports.exp (check_profiling_available): Match more"}, {"sha": "330c148bb59d11f3515889163d0fbfe75a624dcc", "filename": "gcc/testsuite/g++.dg/warn/pr8715.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr8715.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr8715.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr8715.C?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wsign-compare\" } */\n+\n+int foo()\n+{\n+  unsigned char b = '1';\n+\n+  bool x = ~b; /* { dg-warning \"promoted ~unsigned is always non-zero\" } */\n+\n+  return 0;\n+}"}, {"sha": "e45e77c09f4cb65b50a04a06c862bb2b17f5a115", "filename": "gcc/testsuite/gcc.dg/pr8715.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr8715.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d12797c692346ff8d9ca935835a3e0b659ab4b8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr8715.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr8715.c?ref=2d12797c692346ff8d9ca935835a3e0b659ab4b8", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wsign-compare -std=c99\" } */\n+\n+#include <stdbool.h>\n+\n+int foo()\n+{\n+  unsigned char b = '1';\n+\n+  bool x = ~b; /* { dg-warning \"promoted ~unsigned is always non-zero\" } */\n+\n+  return 0;\n+}"}]}