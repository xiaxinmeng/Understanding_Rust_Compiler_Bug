{"sha": "9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhOTljNjNhYjVkOTNlNWFiMTI4ODhjZmI0NGJlYjk5NDBiMjM0Zg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-03-30T05:38:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-30T05:38:28Z"}, "message": "String.java: Reordered to follow Classpath; merged in javadoc.\n\n\t* java/lang/String.java: Reordered to follow Classpath; merged in\n\tjavadoc.\n\nFrom-SVN: r65036", "tree": {"sha": "b3b8447e2cb32ea56f2ab0cd71ee8154f631125d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3b8447e2cb32ea56f2ab0cd71ee8154f631125d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba99c63ab5d93e5ab12888cfb44beb9940b234f/comments", "author": null, "committer": null, "parents": [{"sha": "59ee40a472d6d15fb491d5f758bc736a32ffd51c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ee40a472d6d15fb491d5f758bc736a32ffd51c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ee40a472d6d15fb491d5f758bc736a32ffd51c"}], "stats": {"total": 940, "additions": 812, "deletions": 128}, "files": [{"sha": "d93cdd3f5d2178566fc9ffafc6d0c9dbdb4cd298", "filename": "libjava/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba99c63ab5d93e5ab12888cfb44beb9940b234f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba99c63ab5d93e5ab12888cfb44beb9940b234f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "patch": "@@ -1,5 +1,8 @@\n 2003-03-29  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/lang/String.java: Reordered to follow Classpath; merged in\n+\tjavadoc.\n+\n \t* java/text/MessageFormat.java: Removed some whitespace.\n \n \t* Makefile.in: Rebuilt."}, {"sha": "e10e7dd1814b1aeaff717425cf30d16f4c44bc91", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 809, "deletions": 128, "changes": 937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba99c63ab5d93e5ab12888cfb44beb9940b234f/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba99c63ab5d93e5ab12888cfb44beb9940b234f/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "patch": "@@ -1,53 +1,113 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* String.java -- immutable character sequences; the object of string literals\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang;\n+\n import java.io.UnsupportedEncodingException;\n import java.io.Serializable;\n import java.lang.Comparable;\n import java.util.Comparator;\n import java.util.Locale;\n \n /**\n+ * Strings represent an immutable set of characters.  All String literals\n+ * are instances of this class, and two string literals with the same contents\n+ * refer to the same String object.\n+ *\n+ * <p>This class also includes a number of methods for manipulating the\n+ * contents of strings (of course, creating a new object if there are any\n+ * changes, as String is immutable). Case mapping relies on Unicode 3.0.0\n+ * standards, where some character sequences have a different number of\n+ * characters in the uppercase version than the lower case.\n+ *\n+ * <p>Strings are special, in that they are the only object with an overloaded\n+ * operator. When you use '+' with at least one String argument, both\n+ * arguments have String conversion performed on them, and another String (not\n+ * guaranteed to be unique) results.\n+ *\n+ * <p>String is special-cased when doing data serialization - rather than\n+ * listing the fields of this class, a String object is converted to a string\n+ * literal in the object stream.\n+ *\n+ * @author Paul N. Fisher\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date September 4, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Complete to 1.3.\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n-\n public final class String implements Serializable, Comparable, CharSequence\n {\n+  // WARNING: String is a CORE class in the bootstrap cycle. See the comments\n+  // in vm/reference/java/lang/Runtime for implications of this fact.\n+\n+  /**\n+   * This is probably not necessary because this class is special cased already\n+   * but it will avoid showing up as a discrepancy when comparing SUIDs.\n+   */\n+  private static final long serialVersionUID = -6849794470754667710L;\n+\n   private Object data;\n   private int boffset; // Note this is a byte offset - don't use in Java code!\n   int count;\n \n-  // This is probably not necessary because this class is special cased already\n-  // but it will avoid showing up as a discrepancy when comparing SUIDs.\n-  private static final long serialVersionUID = -6849794470754667710L;\n-\n   /**\n    * An implementation for {@link CASE_INSENSITIVE_ORDER}.\n-   * This must be {@link Serializable}.\n+   * This must be {@link Serializable}. The class name is dictated by\n+   * compatibility with Sun's JDK.\n    */\n   private static final class CaseInsensitiveComparator\n     implements Comparator, Serializable\n   {\n     /**\n-     * The default private constructor generates unnecessary overhead\n+     * Compatible with JDK 1.2.\n+     */\n+    private static final long serialVersionUID = 8575799808933029326L;\n+\n+    /**\n+     * The default private constructor generates unnecessary overhead.\n      */\n     CaseInsensitiveComparator() {}\n \n     /**\n-     * Compares two Strings, using\n+     * Compares to Strings, using\n      * <code>String.compareToIgnoreCase(String)</code>.\n-     * \n+     *\n      * @param o1 the first string\n      * @param o2 the second string\n      * @return &lt; 0, 0, or &gt; 0 depending on the case-insensitive\n@@ -60,69 +120,194 @@ public int compare(Object o1, Object o2)\n     {\n       return ((String) o1).compareToIgnoreCase((String) o2);\n     }\n-  }\n+  } // class CaseInsensitiveComparator\n \n   /**\n    * A Comparator that uses <code>String.compareToIgnoreCase(String)</code>.\n-   * This comparator is {@link Serializable}.\n+   * This comparator is {@link Serializable}. Note that it ignores Locale,\n+   * for that, you want a Collator.\n    *\n+   * @see Collator#compare(String, String)\n    * @since 1.2\n    */\n   public static final Comparator CASE_INSENSITIVE_ORDER\n     = new CaseInsensitiveComparator();\n \n+  /**\n+   * Creates an empty String (length 0). Unless you really need a new object,\n+   * consider using <code>\"\"</code> instead.\n+   */\n   public String ()\n   {\n     init();\n   }\n \n-  public String (String value)\n+  /**\n+   * Copies the contents of a String to a new String. Since Strings are\n+   * immutable, only a shallow copy is performed.\n+   *\n+   * @param str String to copy\n+   * @throws NullPointerException if value is null\n+   */\n+  public String (String str)\n   {\n-    data = value.data;\n-    boffset = value.boffset;\n-    count = value.count;\n+    data = str.data;\n+    boffset = str.boffset;\n+    count = str.count;\n   }\n \n-  public String (StringBuffer buffer)\n+  /**\n+   * Creates a new String using the character sequence of the char array.\n+   * Subsequent changes to data do not affect the String.\n+   *\n+   * @param data char array to copy\n+   * @throws NullPointerException if data is null\n+   */\n+  public String (char[] data)\n   {\n-    synchronized (buffer)\n-      {\n-\tbuffer.shared = true;\n-\tinit (buffer.value, 0, buffer.count, true);\n-      }\n+    init(data, 0, data.length, false);\n   }\n \n-  // This is used by gnu.gcj.runtime.StringBuffer, so it must have\n-  // package-private protection.  It is accessed via CNI and so avoids\n-  // ordinary protection mechanisms.\n-  String (gnu.gcj.runtime.StringBuffer buffer)\n+  /**\n+   * Creates a new String using the character sequence of a subarray of\n+   * characters. The string starts at offset, and copies count chars.\n+   * Subsequent changes to data do not affect the String.\n+   *\n+   * @param data char array to copy\n+   * @param offset position (base 0) to start copying out of data\n+   * @param count the number of characters from data to copy\n+   * @throws NullPointerException if data is null\n+   * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count > data.length)\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n+  public String (char[] data, int offset, int count)\n   {\n-    // No need to synchronize or mark the buffer, since we know it is\n-    // only used once.\n-    init (buffer.value, 0, buffer.count, true);\n+    init(data, offset, count, false);\n   }\n \n-  public String (char[] data)\n+  /**\n+   * Creates a new String using an 8-bit array of integer values, starting at\n+   * an offset, and copying up to the count. Each character c, using\n+   * corresponding byte b, is created in the new String as if by performing:\n+   *\n+   * <pre>\n+   * c = (char) (((hibyte & 0xff) << 8) | (b & 0xff))\n+   * </pre>\n+   *\n+   * @param ascii array of integer values\n+   * @param hibyte top byte of each Unicode character\n+   * @param offset position (base 0) to start copying out of ascii\n+   * @param count the number of characters from ascii to copy\n+   * @throws NullPointerException if ascii is null\n+   * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count > ascii.length)\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @see #String(byte[])\n+   * @see #String(byte[], String)\n+   * @see #String(byte[], int, int)\n+   * @see #String(byte[], int, int, String)\n+   * @deprecated use {@link #String(byte[], int, int, String)} to perform\n+   *             correct encoding\n+   */\n+  public String (byte[] ascii, int hibyte, int offset, int count)\n   {\n-    init(data, 0, data.length, false);\n+    init(ascii, hibyte, offset, count);\n   }\n \n-  public String (char[] data, int offset, int count)\n+  /**\n+   * Creates a new String using an 8-bit array of integer values. Each\n+   * character c, using corresponding byte b, is created in the new String\n+   * as if by performing:\n+   *\n+   * <pre>\n+   * c = (char) (((hibyte & 0xff) << 8) | (b & 0xff))\n+   * </pre>\n+   *\n+   * @param ascii array of integer values\n+   * @param hibyte top byte of each Unicode character\n+   * @throws NullPointerException if ascii is null\n+   * @see #String(byte[])\n+   * @see #String(byte[], String)\n+   * @see #String(byte[], int, int)\n+   * @see #String(byte[], int, int, String)\n+   * @see #String(byte[], int, int, int)\n+   * @deprecated use {@link #String(byte[], String)} to perform\n+   *             correct encoding\n+   */\n+  public String (byte[] ascii, int hibyte)\n   {\n-    init(data, offset, count, false);\n+    init(ascii, hibyte, 0, ascii.length);\n   }\n \n-  // This is used by Integer.toString(int,int).\n-  String (char[] data, int offset, int count, boolean dont_copy)\n+  /**\n+   * Creates a new String using the portion of the byte array starting at the\n+   * offset and ending at offset + count. Uses the specified encoding type\n+   * to decode the byte array, so the resulting string may be longer or\n+   * shorter than the byte array. For more decoding control, use\n+   * {@link java.nio.charset.CharsetDecoder}, and for valid character sets,\n+   * see {@link java.nio.charset.Charset}. The behavior is not specified if\n+   * the decoder encounters invalid characters; this implementation throws\n+   * an Error.\n+   *\n+   * @param data byte array to copy\n+   * @param offset the offset to start at\n+   * @param count the number of characters in the array to use\n+   * @param encoding the name of the encoding to use\n+   * @throws NullPointerException if data or encoding is null\n+   * @throws IndexOutOfBoundsException if offset or count is incorrect\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @throws UnsupportedEncodingException if encoding is not found\n+   * @throws Error if the decoding fails\n+   * @since 1.1\n+   */\n+  public String (byte[] byteArray, int offset, int count, String enc)\n+    throws UnsupportedEncodingException\n   {\n-    init(data, offset, count, dont_copy);\n+    init (byteArray, offset, count, enc);\n   }\n \n-  public String (byte[] byteArray)\n+  /**\n+   * Creates a new String using the byte array. Uses the specified encoding\n+   * type to decode the byte array, so the resulting string may be longer or\n+   * shorter than the byte array. For more decoding control, use\n+   * {@link java.nio.charset.CharsetDecoder}, and for valid character sets,\n+   * see {@link java.nio.charset.Charset}. The behavior is not specified if\n+   * the decoder encounters invalid characters; this implementation throws\n+   * an Error.\n+   *\n+   * @param data byte array to copy\n+   * @param encoding the name of the encoding to use\n+   * @throws NullPointerException if data or encoding is null\n+   * @throws UnsupportedEncodingException if encoding is not found\n+   * @throws Error if the decoding fails\n+   * @see #String(byte[], int, int, String)\n+   * @since 1.1\n+   */\n+  public String (byte[] byteArray, String enc)\n+    throws UnsupportedEncodingException\n   {\n-    this (byteArray, 0, byteArray.length);\n+    this (byteArray, 0, byteArray.length, enc);\n   }\n \n+  /**\n+   * Creates a new String using the portion of the byte array starting at the\n+   * offset and ending at offset + count. Uses the encoding of the platform's\n+   * default charset, so the resulting string may be longer or shorter than\n+   * the byte array. For more decoding control, use\n+   * {@link java.nio.charset.CharsetDecoder}.  The behavior is not specified\n+   * if the decoder encounters invalid characters; this implementation throws\n+   * an Error.\n+   *\n+   * @param data byte array to copy\n+   * @param offset the offset to start at\n+   * @param count the number of characters in the array to use\n+   * @throws NullPointerException if data is null\n+   * @throws IndexOutOfBoundsException if offset or count is incorrect\n+   * @throws Error if the decoding fails\n+   * @see #String(byte[], int, int, String)\n+   * @since 1.1\n+   */\n   public String (byte[] byteArray, int offset, int count)\n   {\n     try\n@@ -144,61 +329,153 @@ public String (byte[] byteArray, int offset, int count)\n       }\n   }\n \n-  public String (byte[] byteArray, String enc)\n-    throws UnsupportedEncodingException\n-  {\n-    this (byteArray, 0, byteArray.length, enc);\n-  }\n-\n-  public String (byte[] byteArray, int offset, int count, String enc)\n-    throws UnsupportedEncodingException\n-  {\n-    init (byteArray, offset, count, enc);\n-  }\n-\n-  public static String copyValueOf(char[] data)\n-  {\n-    return copyValueOf (data, 0, data.length);\n-  }\n-\n-  public static String copyValueOf(char[] data, int offset, int count)\n+  /**\n+   * Creates a new String using the byte array. Uses the encoding of the\n+   * platform's default charset, so the resulting string may be longer or\n+   * shorter than the byte array. For more decoding control, use\n+   * {@link java.nio.charset.CharsetDecoder}.  The behavior is not specified\n+   * if the decoder encounters invalid characters; this implementation throws\n+   * an Error.\n+   *\n+   * @param data byte array to copy\n+   * @throws NullPointerException if data is null\n+   * @throws Error if the decoding fails\n+   * @see #String(byte[], int, int)\n+   * @see #String(byte[], int, int, String)\n+   * @since 1.1\n+   */\n+  public String (byte[] byteArray)\n   {\n-    String r = new String ();\n-    r.init(data, offset, count, false);\n-    return r;\n+    this (byteArray, 0, byteArray.length);\n   }\n \n-  /** @deprecated */\n-  public String (byte[] ascii, int hibyte)\n+  /**\n+   * Creates a new String using the character sequence represented by\n+   * the StringBuffer. Subsequent changes to buf do not affect the String.\n+   *\n+   * @param buffer StringBuffer to copy\n+   * @throws NullPointerException if buffer is null\n+   */\n+  public String (StringBuffer buffer)\n   {\n-    init(ascii, hibyte, 0, ascii.length);\n+    synchronized (buffer)\n+      {\n+\tbuffer.shared = true;\n+\tinit (buffer.value, 0, buffer.count, true);\n+      }\n   }\n \n-  /** @deprecated */\n-  public String (byte[] ascii, int hibyte, int offset, int count)\n+  /**\n+   * Special constructor which can share an array when safe to do so.\n+   *\n+   * @param data the characters to copy\n+   * @param offset the location to start from\n+   * @param count the number of characters to use\n+   * @param dont_copy true if the array is trusted, and need not be copied\n+   * @throws NullPointerException if chars is null\n+   * @throws StringIndexOutOfBoundsException if bounds check fails\n+   */\n+  String (char[] data, int offset, int count, boolean dont_copy)\n   {\n-    init(ascii, hibyte, offset, count);\n+    init(data, offset, count, dont_copy);\n   }\n \n-  public String toString ()\n+  // This is used by gnu.gcj.runtime.StringBuffer, so it must have\n+  // package-private protection.  It is accessed via CNI and so avoids\n+  // ordinary protection mechanisms.\n+  String (gnu.gcj.runtime.StringBuffer buffer)\n   {\n-    return this;\n+    // No need to synchronize or mark the buffer, since we know it is\n+    // only used once.\n+    init (buffer.value, 0, buffer.count, true);\n   }\n \n-  public native boolean equals (Object anObject);\n-\n-  public native int hashCode ();\n-\n-  public int length ()\n+  /**\n+   * Returns the number of characters contained in this String.\n+   *\n+   * @return the length of this String\n+   */\n+  public int length()\n   {\n     return count;\n   }\n \n+  /**\n+   * Returns the character located at the specified index within this String.\n+   *\n+   * @param index position of character to return (base 0)\n+   * @return character located at position index\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n   public native char charAt (int index);\n \n+  /**\n+   * Copies characters from this String starting at a specified start index,\n+   * ending at a specified stop index, to a character array starting at\n+   * a specified destination begin index.\n+   *\n+   * @param srcBegin index to begin copying characters from this String\n+   * @param srcEnd index after the last character to be copied from this String\n+   * @param dst character array which this String is copied into\n+   * @param dstBegin index to start writing characters into dst\n+   * @throws NullPointerException if dst is null\n+   * @throws IndexOutOfBoundsException if any indices are out of bounds\n+   *         (while unspecified, source problems cause a\n+   *         StringIndexOutOfBoundsException, and dst problems cause an\n+   *         ArrayIndexOutOfBoundsException)\n+   */\n   public native void getChars (int srcBegin, int srcEnd,\n \t\t\t       char[] dst, int dstBegin);\n \n+  /**\n+   * Copies the low byte of each character from this String starting at a\n+   * specified start index, ending at a specified stop index, to a byte array\n+   * starting at a specified destination begin index.\n+   *\n+   * @param srcBegin index to being copying characters from this String\n+   * @param srcEnd index after the last character to be copied from this String\n+   * @param dst byte array which each low byte of this String is copied into\n+   * @param dstBegin index to start writing characters into dst\n+   * @throws NullPointerException if dst is null and copy length is non-zero\n+   * @throws IndexOutOfBoundsException if any indices are out of bounds\n+   *         (while unspecified, source problems cause a\n+   *         StringIndexOutOfBoundsException, and dst problems cause an\n+   *         ArrayIndexOutOfBoundsException)\n+   * @see #getBytes()\n+   * @see #getBytes(String)\n+   * @deprecated use {@link #getBytes()}, which uses a char to byte encoder\n+   */\n+  public native void getBytes (int srcBegin, int srcEnd,\n+\t\t\t       byte[] dst, int dstBegin);\n+\n+  /**\n+   * Converts the Unicode characters in this String to a byte array. Uses the\n+   * specified encoding method, so the result may be longer or shorter than\n+   * the String. For more encoding control, use\n+   * {@link java.nio.charset.CharsetEncoder}, and for valid character sets,\n+   * see {@link java.nio.charset.Charset}. The behavior is not specified if\n+   * the encoder encounters a problem; this implementation returns null.\n+   *\n+   * @param enc encoding name\n+   * @return the resulting byte array, or null on a problem\n+   * @throws NullPointerException if enc is null\n+   * @throws UnsupportedEncodingException if encoding is not supported\n+   * @since 1.1\n+   */\n+  public native byte[] getBytes (String enc)\n+    throws UnsupportedEncodingException;\n+\n+  /**\n+   * Converts the Unicode characters in this String to a byte array. Uses the\n+   * encoding of the platform's default charset, so the result may be longer\n+   * or shorter than the String. For more encoding control, use\n+   * {@link java.nio.charset.CharsetEncoder}.  The behavior is not specified if\n+   * the encoder encounters a problem; this implementation returns null.\n+   *\n+   * @return the resulting byte array, or null on a problem\n+   * @since 1.1\n+   */\n   public byte[] getBytes ()\n   {\n     try\n@@ -222,84 +499,269 @@ public byte[] getBytes ()\n       }\n   }\n \n-  public native byte[] getBytes (String enc)\n-    throws UnsupportedEncodingException;\n-\n-  /** @deprecated */\n-  public native void getBytes (int srcBegin, int srcEnd,\n-\t\t\t\tbyte[] dst, int dstBegin);\n-\n-  public native char[] toCharArray ();\n+  /**\n+   * Predicate which compares anObject to this. This is true only for Strings\n+   * with the same character sequence.\n+   *\n+   * @param anObject the object to compare\n+   * @return true if anObject is semantically equal to this\n+   * @see #compareTo(String)\n+   * @see #equalsIgnoreCase(String)\n+   */\n+  public native boolean equals (Object anObject);\n \n+  /**\n+   * Compares a String to this String, ignoring case. This does not handle\n+   * multi-character capitalization exceptions; instead the comparison is\n+   * made on a character-by-character basis, and is true if:<br><ul>\n+   * <li><code>c1 == c2</code></li>\n+   * <li><code>Character.toUpperCase(c1)\n+   *     == Character.toUpperCase(c2)</code></li>\n+   * <li><code>Character.toLowerCase(c1)\n+   *     == Character.toLowerCase(c2)</code></li>\n+   * </ul>\n+   *\n+   * @param anotherString String to compare to this String\n+   * @return true if anotherString is equal, ignoring case\n+   * @see #equals(Object)\n+   * @see Character#toUpperCase(char)\n+   * @see Character#toLowerCase(char)\n+   */\n   public native boolean equalsIgnoreCase (String anotherString);\n \n+  /**\n+   * Compares this String and another String (case sensitive,\n+   * lexicographically). The result is less than 0 if this string sorts\n+   * before the other, 0 if they are equal, and greater than 0 otherwise.\n+   * After any common starting sequence is skipped, the result is\n+   * <code>this.charAt(k) - anotherString.charAt(k)</code> if both strings\n+   * have characters remaining, or\n+   * <code>this.length() - anotherString.length()</code> if one string is\n+   * a subsequence of the other.\n+   *\n+   * @param anotherString the String to compare against\n+   * @return the comparison\n+   * @throws NullPointerException if anotherString is null\n+   */\n   public native int compareTo (String anotherString);\n \n-  public int compareTo (Object obj)\n+  /**\n+   * Behaves like <code>compareTo(java.lang.String)</code> unless the Object\n+   * is not a <code>String</code>.  Then it throws a\n+   * <code>ClassCastException</code>.\n+   *\n+   * @param o the object to compare against\n+   * @return the comparison\n+   * @throws NullPointerException if o is null\n+   * @throws ClassCastException if o is not a <code>String</code>\n+   * @since 1.2\n+   */\n+  public int compareTo(Object o)\n   {\n-    return compareTo ((String)obj);\n+    return compareTo((String) o);\n   }\n-  \n+\n+  /**\n+   * Compares this String and another String (case insensitive). This\n+   * comparison is <em>similar</em> to equalsIgnoreCase, in that it ignores\n+   * locale and multi-characater capitalization, and compares characters\n+   * after performing\n+   * <code>Character.toLowerCase(Character.toUpperCase(c))</code> on each\n+   * character of the string. This is unsatisfactory for locale-based\n+   * comparison, in which case you should use {@link java.text.Collator}.\n+   *\n+   * @param s the string to compare against\n+   * @return the comparison\n+   * @see Collator#compare(String, String)\n+   * @since 1.2\n+   */\n   public int compareToIgnoreCase (String str)\n   {\n     return this.toUpperCase().toLowerCase().compareTo(\n      str.toUpperCase().toLowerCase());\n   }  \n \n+  /**\n+   * Predicate which determines if this String matches another String\n+   * starting at a specified offset for each String and continuing\n+   * for a specified length. Indices out of bounds are harmless, and give\n+   * a false result.\n+   *\n+   * @param toffset index to start comparison at for this String\n+   * @param other String to compare region to this String\n+   * @param oofset index to start comparison at for other\n+   * @param len number of characters to compare\n+   * @return true if regions match (case sensitive)\n+   * @throws NullPointerException if other is null\n+   */\n   public native boolean regionMatches (int toffset,\n \t\t\t\t       String other, int ooffset, int len);\n \n+  /**\n+   * Predicate which determines if this String matches another String\n+   * starting at a specified offset for each String and continuing\n+   * for a specified length, optionally ignoring case. Indices out of bounds\n+   * are harmless, and give a false result. Case comparisons are based on\n+   * <code>Character.toLowerCase()</code> and\n+   * <code>Character.toUpperCase()</code>, not on multi-character\n+   * capitalization expansions.\n+   *\n+   * @param ignoreCase true if case should be ignored in comparision\n+   * @param toffset index to start comparison at for this String\n+   * @param other String to compare region to this String\n+   * @param oofset index to start comparison at for other\n+   * @param len number of characters to compare\n+   * @return true if regions match, false otherwise\n+   * @throws NullPointerException if other is null\n+   */\n   public native boolean regionMatches (boolean ignoreCase, int toffset,\n \t\t\t\t       String other, int ooffset, int len);\n \n+  /**\n+   * Predicate which determines if this String contains the given prefix,\n+   * beginning comparison at toffset. The result is false if toffset is\n+   * negative or greater than this.length(), otherwise it is the same as\n+   * <code>this.subString(toffset).startsWith(prefix)</code>.\n+   *\n+   * @param prefix String to compare\n+   * @param toffset offset for this String where comparison starts\n+   * @return true if this String starts with prefix\n+   * @throws NullPointerException if prefix is null\n+   * @see #regionMatches(boolean, int, String, int, int)\n+   */\n+  public native boolean startsWith (String prefix, int toffset);\n+\n+  /**\n+   * Predicate which determines if this String starts with a given prefix.\n+   * If the prefix is an empty String, true is returned.\n+   *\n+   * @param prefex String to compare\n+   * @return true if this String starts with the prefix\n+   * @throws NullPointerException if prefix is null\n+   * @see #startsWith(String, int)\n+   */\n   public boolean startsWith (String prefix)\n   {\n     return startsWith (prefix, 0);\n   }\n \n-  public native boolean startsWith (String prefix, int toffset);\n-\n+  /**\n+   * Predicate which determines if this String ends with a given suffix.\n+   * If the suffix is an empty String, true is returned.\n+   *\n+   * @param suffix String to compare\n+   * @return true if this String ends with the suffix\n+   * @throws NullPointerException if suffix is null\n+   * @see #regionMatches(boolean, int, String, int, int)\n+   */\n   public boolean endsWith (String suffix)\n   {\n     return regionMatches (this.count - suffix.count, suffix, 0, suffix.count);\n   }\n \n-  // No such method specified in the doc, including JDK 1.2.\n-  // public boolean endsWith (String suffix, int toffset)\n-  // {\n-  //   return regionMatches (toffset, suffix, 0, suffix.count);\n-  // }\n-\n-  // The Language Specification, and the JDK 1.2 API docs say that\n-  // index and lastIndex take an int, while the Class Libraries\n-  // say they take a char.  The former wins ...\n+  /**\n+   * Computes the hashcode for this String. This is done with int arithmetic,\n+   * where ** represents exponentiation, by this formula:<br>\n+   * <code>s[0]*31**(n-1) + s[1]*31**(n-2) + ... + s[n-1]</code>.\n+   *\n+   * @return hashcode value of this String\n+   */\n+  public native int hashCode ();\n \n+  /**\n+   * Finds the first instance of a character in this String.\n+   *\n+   * @param ch character to find\n+   * @return location (base 0) of the character, or -1 if not found\n+   */\n   public int indexOf (int ch)\n   {\n     return indexOf (ch, 0);\n   }\n \n+  /**\n+   * Finds the first instance of a character in this String, starting at\n+   * a given index.  If starting index is less than 0, the search\n+   * starts at the beginning of this String.  If the starting index\n+   * is greater than the length of this String, -1 is returned.\n+   *\n+   * @param ch character to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the character, or -1 if not found\n+   */\n   public native int indexOf (int ch, int fromIndex);\n \n-  public int indexOf (String str)\n+  /**\n+   * Finds the last instance of a character in this String.\n+   *\n+   * @param ch character to find\n+   * @return location (base 0) of the character, or -1 if not found\n+   */\n+  public int lastIndexOf (int ch)\n   {\n-    return indexOf (str, 0);\n+    return lastIndexOf (ch, count - 1);\n   }\n \n-  public native int indexOf (String str, int fromIndex);\n+  /**\n+   * Finds the last instance of a character in this String, starting at\n+   * a given index.  If starting index is greater than the maximum valid\n+   * index, then the search begins at the end of this String.  If the\n+   * starting index is less than zero, -1 is returned.\n+   *\n+   * @param ch character to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the character, or -1 if not found\n+   */\n+  public native int lastIndexOf (int ch, int fromIndex);\n \n-  public int lastIndexOf (int ch)\n+  /**\n+   * Finds the first instance of a String in this String.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n+  public int indexOf (String str)\n   {\n-    return lastIndexOf (ch, count - 1);\n+    return indexOf (str, 0);\n   }\n \n-  public native int lastIndexOf (int ch, int fromIndex);\n+  /**\n+   * Finds the first instance of a String in this String, starting at\n+   * a given index.  If starting index is less than 0, the search\n+   * starts at the beginning of this String.  If the starting index\n+   * is greater than the length of this String, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n+  public native int indexOf (String str, int fromIndex);\n \n+  /**\n+   * Finds the last instance of a String in this String.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n   public int lastIndexOf (String str)\n   {\n     return lastIndexOf (str, count - str.count);\n   }\n \n+  /**\n+   * Finds the last instance of a String in this String, starting at\n+   * a given index.  If starting index is greater than the maximum valid\n+   * index, then the search begins at the end of this String.  If the\n+   * starting index is less than zero, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n   public int lastIndexOf (String str, int fromIndex)\n   {\n     if (fromIndex >= count)\n@@ -313,42 +775,93 @@ public int lastIndexOf (String str, int fromIndex)\n       }\n   }\n \n+  /**\n+   * Creates a substring of this String, starting at a specified index\n+   * and ending at the end of this String.\n+   *\n+   * @param begin index to start substring (base 0)\n+   * @return new String which is a substring of this String\n+   * @throws IndexOutOfBoundsException if begin &lt; 0 || begin &gt; length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n+  public String substring (int beginIndex)\n+  {\n+    return substring (beginIndex, count);\n+  }\n+\n   /**\n    * Creates a substring of this String, starting at a specified index\n    * and ending at one character before a specified index.\n-   * <p>\n-   * To implement <code>CharSequence</code>.\n-   * Calls <code>substring(beginIndex, endIndex)</code>.\n-   *\n-   * @param beginIndex index to start substring (base 0)\n-   * @param endIndex index after the last character to be \n-   *   copied into the substring\n-   * \n+   *\n+   * @param begin index to start substring (inclusive, base 0)\n+   * @param end index to end at (exclusive)\n    * @return new String which is a substring of this String\n+   * @throws IndexOutOfBoundsException if begin &lt; 0 || end &gt; length()\n+   *         || begin > end (while unspecified, this is a\n+   *         StringIndexOutOfBoundsException)\n+   */\n+  public native String substring (int beginIndex, int endIndex);\n+\n+  /**\n+   * Creates a substring of this String, starting at a specified index\n+   * and ending at one character before a specified index. This behaves like\n+   * <code>substring(beginIndex, endIndex)</code>.\n    *\n-   * @exception StringIndexOutOfBoundsException \n-   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)\n+   * @param beginIndex index to start substring (inclusive, base 0)\n+   * @param endIndex index to end at (exclusive)\n+   * @return new String which is a substring of this String\n+   * @throws IndexOutOfBoundsException if begin &lt; 0 || end &gt; length()\n+   *         || begin > end\n+   * @since 1.4\n    */\n   public CharSequence subSequence(int beginIndex, int endIndex)\n     throws IndexOutOfBoundsException\n   {\n     return substring(beginIndex, endIndex);\n   }\n \n-  public String substring (int beginIndex)\n-  {\n-    return substring (beginIndex, count);\n-  }\n-\n-  public native String substring (int beginIndex, int endIndex);\n-\n+  /**\n+   * Concatenates a String to this String. This results in a new string unless\n+   * one of the two originals is \"\".\n+   *\n+   * @param str String to append to this String\n+   * @return newly concatenated String\n+   * @throws NullPointerException if str is null\n+   */\n   public native String concat (String str);\n \n+  /**\n+   * Replaces every instance of a character in this String with a new\n+   * character. If no replacements occur, this is returned.\n+   *\n+   * @param oldChar the old character to replace\n+   * @param newChar the new character\n+   * @return new String with all instances of oldChar replaced with newChar\n+   */\n   public native String replace (char oldChar, char newChar);\n \n+  /**\n+   * Lowercases this String according to a particular locale. This uses\n+   * Unicode's special case mappings, as applied to the given Locale, so the\n+   * resulting string may be a different length.\n+   *\n+   * @param loc locale to use\n+   * @return new lowercased String, or this if no characters were lowercased\n+   * @throws NullPointerException if loc is null\n+   * @see #toUpperCase(Locale)\n+   * @since 1.1\n+   */\n   public native String toLowerCase (Locale locale);\n-  public native String toUpperCase (Locale locale);\n \n+  /**\n+   * Lowercases this String. This uses Unicode's special case mappings, as\n+   * applied to the platform's default Locale, so the resulting string may\n+   * be a different length.\n+   *\n+   * @return new lowercased String, or this if no characters were lowercased\n+   * @see #toLowerCase(Locale)\n+   * @see #toUpperCase()\n+   */\n   public String toLowerCase ()\n   {\n     // The JDK is a bit confused about what to do here.  If we pass in\n@@ -358,6 +871,28 @@ public String toLowerCase ()\n     return toLowerCase (null);\n   }\n \n+  /**\n+   * Uppercases this String according to a particular locale. This uses\n+   * Unicode's special case mappings, as applied to the given Locale, so the\n+   * resulting string may be a different length.\n+   *\n+   * @param loc locale to use\n+   * @return new uppercased String, or this if no characters were uppercased\n+   * @throws NullPointerException if loc is null\n+   * @see #toLowerCase(Locale)\n+   * @since 1.1\n+   */\n+  public native String toUpperCase (Locale locale);\n+\n+  /**\n+   * Uppercases this String. This uses Unicode's special case mappings, as\n+   * applied to the platform's default Locale, so the resulting string may\n+   * be a different length.\n+   *\n+   * @return new uppercased String, or this if no characters were uppercased\n+   * @see #toUpperCase(Locale)\n+   * @see #toLowerCase()\n+   */\n   public String toUpperCase ()\n   {\n     // The JDK is a bit confused about what to do here.  If we pass in\n@@ -367,46 +902,192 @@ public String toUpperCase ()\n     return toUpperCase (null);\n   }\n \n+  /**\n+   * Trims all characters less than or equal to <code>'\\u0020'</code>\n+   * (<code>' '</code>) from the beginning and end of this String. This\n+   * includes many, but not all, ASCII control characters, and all\n+   * {@link Character#whitespace(char)}.\n+   *\n+   * @return new trimmed String, or this if nothing trimmed\n+   */\n   public native String trim ();\n \n+  /**\n+   * Returns this, as it is already a String!\n+   *\n+   * @return this\n+   */\n+  public String toString ()\n+  {\n+    return this;\n+  }\n+\n+  /**\n+   * Copies the contents of this String into a character array. Subsequent\n+   * changes to the array do not affect the String.\n+   *\n+   * @return character array copying the String\n+   */\n+  public native char[] toCharArray ();\n+\n+  /**\n+   * Returns a String representation of an Object. This is \"null\" if the\n+   * object is null, otherwise it is <code>obj.toString()</code> (which\n+   * can be null).\n+   *\n+   * @param obj the Object\n+   * @return the string conversion of obj\n+   */\n   public static String valueOf (Object obj)\n   {\n     return obj == null ? \"null\" : obj.toString();\n   }\n \n+  /**\n+   * Returns a String representation of a character array. Subsequent\n+   * changes to the array do not affect the String.\n+   *\n+   * @param data the character array\n+   * @return a String containing the same character sequence as data\n+   * @throws NullPointerException if data is null\n+   * @see #valueOf(char[], int, int)\n+   * @see #String(char[])\n+   */\n   public static String valueOf (char[] data)\n   {\n     return valueOf (data, 0, data.length);\n   }\n \n+  /**\n+   * Returns a String representing the character sequence of the char array,\n+   * starting at the specified offset, and copying chars up to the specified\n+   * count. Subsequent changes to the array do not affect the String.\n+   *\n+   * @param data character array\n+   * @param offset position (base 0) to start copying out of data\n+   * @param count the number of characters from data to copy\n+   * @return String containing the chars from data[offset..offset+count]\n+   * @throws NullPointerException if data is null\n+   * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count > data.length)\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @see #String(char[], int, int)\n+   */\n   public static native String valueOf (char[] data, int offset, int count);\n \n+  /**\n+   * Returns a String representing the character sequence of the char array,\n+   * starting at the specified offset, and copying chars up to the specified\n+   * count. Subsequent changes to the array do not affect the String.\n+   *\n+   * @param data character array\n+   * @param offset position (base 0) to start copying out of data\n+   * @param count the number of characters from data to copy\n+   * @return String containing the chars from data[offset..offset+count]\n+   * @throws NullPointerException if data is null\n+   * @throws IndexOutOfBoundsException if (offset &lt; 0 || count &lt; 0\n+   *         || offset + count > data.length)\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @see #String(char[], int, int)\n+   */\n+  public static String copyValueOf(char[] data, int offset, int count)\n+  {\n+    String r = new String ();\n+    r.init(data, offset, count, false);\n+    return r;\n+  }\n+\n+  /**\n+   * Returns a String representation of a character array. Subsequent\n+   * changes to the array do not affect the String.\n+   *\n+   * @param data the character array\n+   * @return a String containing the same character sequence as data\n+   * @throws NullPointerException if data is null\n+   * @see #copyValueOf(char[], int, int)\n+   * @see #String(char[])\n+   */\n+  public static String copyValueOf(char[] data)\n+  {\n+    return copyValueOf (data, 0, data.length);\n+  }\n+\n+  /**\n+   * Returns a String representing a boolean.\n+   *\n+   * @param b the boolean\n+   * @return \"true\" if b is true, else \"false\"\n+   */\n   public static String valueOf (boolean b)\n   {\n     return b ? \"true\" : \"false\";\n   }\n \n+  /**\n+   * Returns a String representing a character.\n+   *\n+   * @param c the character\n+   * @return String containing the single character c\n+   */\n   public static native String valueOf (char c);\n \n+  /**\n+   * Returns a String representing an integer.\n+   *\n+   * @param i the integer\n+   * @return String containing the integer in base 10\n+   * @see Integer#toString(int)\n+   */\n   public static native String valueOf (int i);\n \n+  /**\n+   * Returns a String representing a long.\n+   *\n+   * @param l the long\n+   * @return String containing the long in base 10\n+   * @see Long#toString(long)\n+   */\n   public static String valueOf (long l)\n   {\n     return Long.toString(l);\n   }\n \n+  /**\n+   * Returns a String representing a float.\n+   *\n+   * @param f the float\n+   * @return String containing the float\n+   * @see Float#toString(float)\n+   */\n   public static String valueOf (float f)\n   {\n     return Float.toString(f);\n   }\n \n+  /**\n+   * Returns a String representing a double.\n+   *\n+   * @param d the double\n+   * @return String containing the double\n+   * @see Double#toString(double)\n+   */\n   public static String valueOf (double d)\n   {\n     return Double.toString(d);\n   }\n \n+  /**\n+   * Fetches this String from the intern hashtable. If two Strings are\n+   * considered equal, by the equals() method, then intern() will return the\n+   * same String instance. ie. if (s1.equals(s2)) then\n+   * (s1.intern() == s2.intern()). All string literals and string-valued\n+   * constant expressions are already interned.\n+   *\n+   * @return the interned String\n+   */\n   public native String intern ();\n \n+\n   private native void init ();\n   private native void init (char[] chars, int offset, int count,\n \t\t\t    boolean dont_copy);"}]}