{"sha": "16d74a3cc2e10045063e16a0b04cdb5645a744b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZkNzRhM2NjMmUxMDA0NTA2M2UxNmEwYjA0Y2RiNTY0NWE3NDRiNg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2006-04-09T17:19:42Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-04-09T17:19:42Z"}, "message": "re PR target/26743 (gcc generates unreachable branch)\n\n\tPR target/26743\n\tPR target/11254\n\tPR target/10274\n\t* pa.md (cbranch patterns): Revise arguments used in calls to\n\toutput_cbranch, output_bb and output_bvd.  Add long branch length\n\tattributes.\n\t(fbranch patterns): Handle long branches.\n\t(jump): Revise length check.  Revise arguments for output_lbranch call.\n\tAdd long branch length attributes.\n\t(decrement_and_branch_until_zero): Add long branch length attributes.\n\t(output_movb, output_parallel_addb and output_parallel_movb patterns):\n\tLikewise.  Revise arguments for output_parallel_addb and\n\toutput_parallel_movb calls.\n\t* pa-protos.h (output_cbranch, output_lbranch, output_bb, output_bvb,\n\toutput_parallel_movb and output_parallel_addb): Update prototypes.\n\t* pa.c (output_cbranch): Revise arguments.  Correct handling of\n\tnullification in long branches.\n\t(output_lbranch): Add new argument to control extraction of delay\n\tinstruction.\n\t(output_bb): Handle long branches.\n\t(output_bvb, output_dbra, output_movb, output_parallel_movb,\n\toutput_parallel_addb): Likewise.\n\nFrom-SVN: r112805", "tree": {"sha": "7ec96ac7b9acc88053f4a11f7b5f7ed1bd2ddbaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec96ac7b9acc88053f4a11f7b5f7ed1bd2ddbaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16d74a3cc2e10045063e16a0b04cdb5645a744b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d74a3cc2e10045063e16a0b04cdb5645a744b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d74a3cc2e10045063e16a0b04cdb5645a744b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d74a3cc2e10045063e16a0b04cdb5645a744b6/comments", "author": null, "committer": null, "parents": [{"sha": "c3a50ca3a820618098bbcc991d5d3a38764933f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a50ca3a820618098bbcc991d5d3a38764933f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a50ca3a820618098bbcc991d5d3a38764933f0"}], "stats": {"total": 1121, "additions": 807, "deletions": 314}, "files": [{"sha": "ffd80adde1d3154ad6c582adab21919448059231", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16d74a3cc2e10045063e16a0b04cdb5645a744b6", "patch": "@@ -1,3 +1,28 @@\n+2006-04-09  John David Anglin  <dave.anglin@nrc-crnc.gc.ca>\n+\n+\tPR target/26743\n+\tPR target/11254\n+\tPR target/10274\n+\t* pa.md (cbranch patterns): Revise arguments used in calls to\n+\toutput_cbranch, output_bb and output_bvd.  Add long branch length\n+\tattributes.\n+\t(fbranch patterns): Handle long branches.\n+\t(jump): Revise length check.  Revise arguments for output_lbranch call.\n+\tAdd long branch length attributes.\n+\t(decrement_and_branch_until_zero): Add long branch length attributes.\n+\t(output_movb, output_parallel_addb and output_parallel_movb patterns):\n+\tLikewise.  Revise arguments for output_parallel_addb and\n+\toutput_parallel_movb calls.\n+\t* pa-protos.h (output_cbranch, output_lbranch, output_bb, output_bvb,\n+\toutput_parallel_movb and output_parallel_addb): Update prototypes.\n+\t* pa.c (output_cbranch): Revise arguments.  Correct handling of\n+\tnullification in long branches.\n+\t(output_lbranch): Add new argument to control extraction of delay\n+\tinstruction.\n+\t(output_bb): Handle long branches.\n+\t(output_bvb, output_dbra, output_movb, output_parallel_movb,\n+\toutput_parallel_addb): Likewise.\n+\n 2006-04-09  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR rtl-optimization/27073"}, {"sha": "e91ac16c8e168205fc632d7effb7e0ccaf2d2d78", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=16d74a3cc2e10045063e16a0b04cdb5645a744b6", "patch": "@@ -42,14 +42,14 @@ extern const char *output_move_double (rtx *);\n extern const char *output_fp_move_double (rtx *);\n extern const char *output_block_move (rtx *, int);\n extern const char *output_block_clear (rtx *, int);\n-extern const char *output_cbranch (rtx *, int, int, int, rtx);\n-extern const char *output_lbranch (rtx, rtx);\n-extern const char *output_bb (rtx *, int, int, int, rtx, int);\n-extern const char *output_bvb (rtx *, int, int, int, rtx, int);\n+extern const char *output_cbranch (rtx *, int, rtx);\n+extern const char *output_lbranch (rtx, rtx, int);\n+extern const char *output_bb (rtx *, int, rtx, int);\n+extern const char *output_bvb (rtx *, int, rtx, int);\n extern const char *output_dbra (rtx *, rtx, int);\n extern const char *output_movb (rtx *, rtx, int, int);\n-extern const char *output_parallel_movb (rtx *, int);\n-extern const char *output_parallel_addb (rtx *, int);\n+extern const char *output_parallel_movb (rtx *, rtx);\n+extern const char *output_parallel_addb (rtx *, rtx);\n extern const char *output_call (rtx, rtx, int);\n extern const char *output_indirect_call (rtx, rtx);\n extern const char *output_millicode_call (rtx, rtx);"}, {"sha": "509e016cd136cf1c52d913ab9d28a4ffa7d7b1d2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 262, "deletions": 78, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=16d74a3cc2e10045063e16a0b04cdb5645a744b6", "patch": "@@ -5962,11 +5962,13 @@ pa_scalar_mode_supported_p (enum machine_mode mode)\n    parameters.  */\n \n const char *\n-output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n+output_cbranch (rtx *operands, int negated, rtx insn)\n {\n   static char buf[100];\n   int useskip = 0;\n-  rtx xoperands[5];\n+  int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+  int length = get_attr_length (insn);\n+  int xdelay;\n \n   /* A conditional branch to the following instruction (e.g. the delay slot)\n      is asking for a disaster.  This can happen when not optimizing and\n@@ -6036,7 +6038,7 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n \twith an unfilled delay slot.  */\n       case 8:\n \t/* Handle weird backwards branch with a filled delay slot\n-\t   with is nullified.  */\n+\t   which is nullified.  */\n \tif (dbr_sequence_length () != 0\n \t    && ! forward_branch_p (insn)\n \t    && nullify)\n@@ -6083,19 +6085,24 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n \t  }\n \tbreak;\n \n-      case 20:\n-      case 28:\n-\txoperands[0] = operands[0];\n-\txoperands[1] = operands[1];\n-\txoperands[2] = operands[2];\n-\txoperands[3] = operands[3];\n-\n+      default:\n \t/* The reversed conditional branch must branch over one additional\n-\t   instruction if the delay slot is filled.  If the delay slot\n-\t   is empty, the instruction after the reversed condition branch\n-\t   must be nullified.  */\n-\tnullify = dbr_sequence_length () == 0;\n-\txoperands[4] = nullify ? GEN_INT (length) : GEN_INT (length + 4);\n+\t   instruction if the delay slot is filled and needs to be extracted\n+\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   nullified forward branch, the instruction after the reversed\n+\t   condition branch must be nullified.  */\n+\tif (dbr_sequence_length () == 0\n+\t    || (nullify && forward_branch_p (insn)))\n+\t  {\n+\t    nullify = 1;\n+\t    xdelay = 0;\n+\t    operands[4] = GEN_INT (length);\n+\t  }\n+\telse\n+\t  {\n+\t    xdelay = 1;\n+\t    operands[4] = GEN_INT (length + 4);\n+\t  }\n \n \t/* Create a reversed conditional branch which branches around\n \t   the following insns.  */\n@@ -6142,27 +6149,38 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n \t      }\n \t  }\n \n-\toutput_asm_insn (buf, xoperands);\n-\treturn output_lbranch (operands[0], insn);\n-\n-      default:\n-\tgcc_unreachable ();\n+\toutput_asm_insn (buf, operands);\n+\treturn output_lbranch (operands[0], insn, xdelay);\n     }\n   return buf;\n }\n \n-/* This routine handles long unconditional branches that exceed the\n-   maximum range of a simple branch instruction.  */\n+/* This routine handles output of long unconditional branches that\n+   exceed the maximum range of a simple branch instruction.  Since\n+   we don't have a register available for the branch, we save register\n+   %r1 in the frame marker, load the branch destination DEST into %r1,\n+   execute the branch, and restore %r1 in the delay slot of the branch.\n+\n+   Since long branches may have an insn in the delay slot and the\n+   delay slot is used to restore %r1, we in general need to extract\n+   this insn and execute it before the branch.  However, to facilitate\n+   use of this function by conditional branches, we also provide an\n+   option to not extract the delay insn so that it will be emitted\n+   after the long branch.  So, if there is an insn in the delay slot,\n+   it is extracted if XDELAY is nonzero.\n+\n+   The lengths of the various long-branch sequences are 20, 16 and 24\n+   bytes for the portable runtime, non-PIC and PIC cases, respectively.  */\n \n const char *\n-output_lbranch (rtx dest, rtx insn)\n+output_lbranch (rtx dest, rtx insn, int xdelay)\n {\n   rtx xoperands[2];\n  \n   xoperands[0] = dest;\n \n   /* First, free up the delay slot.  */\n-  if (dbr_sequence_length () != 0)\n+  if (xdelay && dbr_sequence_length () != 0)\n     {\n       /* We can't handle a jump in the delay slot.  */\n       gcc_assert (GET_CODE (NEXT_INSN (insn)) != JUMP_INSN);\n@@ -6272,11 +6290,13 @@ output_lbranch (rtx dest, rtx insn)\n    above.  it returns the appropriate output template to emit the branch.  */\n \n const char *\n-output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n-\t   int negated, rtx insn, int which)\n+output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n {\n   static char buf[100];\n   int useskip = 0;\n+  int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+  int length = get_attr_length (insn);\n+  int xdelay;\n \n   /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  I do not think this can happen as this pattern\n@@ -6343,7 +6363,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \twith an unfilled delay slot.  */\n       case 8:\n \t/* Handle weird backwards branch with a filled delay slot\n-\t   with is nullified.  */\n+\t   which is nullified.  */\n \tif (dbr_sequence_length () != 0\n \t    && ! forward_branch_p (insn)\n \t    && nullify)\n@@ -6385,9 +6405,10 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \t  }\n \telse\n \t  {\n-\t    strcpy (buf, \"{extrs,|extrw,s,}\");\n \t    if (GET_MODE (operands[0]) == DImode)\n \t      strcpy (buf, \"extrd,s,*\");\n+\t    else\n+\t      strcpy (buf, \"{extrs,|extrw,s,}\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \"<\");\n@@ -6405,7 +6426,40 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \tbreak;\n \n       default:\n-\tgcc_unreachable ();\n+\t/* The reversed conditional branch must branch over one additional\n+\t   instruction if the delay slot is filled and needs to be extracted\n+\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   nullified forward branch, the instruction after the reversed\n+\t   condition branch must be nullified.  */\n+\tif (dbr_sequence_length () == 0\n+\t    || (nullify && forward_branch_p (insn)))\n+\t  {\n+\t    nullify = 1;\n+\t    xdelay = 0;\n+\t    operands[4] = GEN_INT (length - 8);\n+\t  }\n+\telse\n+\t  {\n+\t    xdelay = 1;\n+\t    operands[4] = GEN_INT (length - 4);\n+\t  }\n+\n+\tif (GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"extrd,s,*\");\n+\telse\n+\t  strcpy (buf, \"{extrs,|extrw,s,}\");\n+\tif ((which == 0 && negated)\n+\t    || (which == 1 && !negated))\n+\t  strcat (buf, \">= %0,%1,1,%%r0\\n\\t\");\n+\telse\n+\t  strcat (buf, \"< %0,%1,1,%%r0\\n\\t\");\n+\tif (nullify)\n+\t  strcat (buf, \"b,n .+%4\");\n+\telse\n+\t  strcat (buf, \"b .+%4\");\n+\toutput_asm_insn (buf, operands);\n+\treturn output_lbranch (negated ? operands[3] : operands[2],\n+\t\t\t       insn, xdelay);\n     }\n   return buf;\n }\n@@ -6417,11 +6471,13 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n    branch.  */\n \n const char *\n-output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n-\t    int negated, rtx insn, int which)\n+output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n {\n   static char buf[100];\n   int useskip = 0;\n+  int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+  int length = get_attr_length (insn);\n+  int xdelay;\n \n   /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  I do not think this can happen as this pattern\n@@ -6488,7 +6544,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \twith an unfilled delay slot.  */\n       case 8:\n \t/* Handle weird backwards branch with a filled delay slot\n-\t   with is nullified.  */\n+\t   which is nullified.  */\n \tif (dbr_sequence_length () != 0\n \t    && ! forward_branch_p (insn)\n \t    && nullify)\n@@ -6550,7 +6606,40 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \tbreak;\n \n       default:\n-\tgcc_unreachable ();\n+\t/* The reversed conditional branch must branch over one additional\n+\t   instruction if the delay slot is filled and needs to be extracted\n+\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   nullified forward branch, the instruction after the reversed\n+\t   condition branch must be nullified.  */\n+\tif (dbr_sequence_length () == 0\n+\t    || (nullify && forward_branch_p (insn)))\n+\t  {\n+\t    nullify = 1;\n+\t    xdelay = 0;\n+\t    operands[4] = GEN_INT (length - 8);\n+\t  }\n+\telse\n+\t  {\n+\t    xdelay = 1;\n+\t    operands[4] = GEN_INT (length - 4);\n+\t  }\n+\n+\tif (GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"extrd,s,*\");\n+\telse\n+\t  strcpy (buf, \"{extrs,|extrw,s,}\");\n+\tif ((which == 0 && negated)\n+\t    || (which == 1 && !negated))\n+\t  strcat (buf, \">= {%0,%1,1,%%r0|%0,%%sar,1,%%r0}\\n\\t\");\n+\telse\n+\t  strcat (buf, \"< {%0,%1,1,%%r0|%0,%%sar,1,%%r0}\\n\\t\");\n+\tif (nullify)\n+\t  strcat (buf, \"b,n .+%4\");\n+\telse\n+\t  strcat (buf, \"b .+%4\");\n+\toutput_asm_insn (buf, operands);\n+\treturn output_lbranch (negated ? operands[3] : operands[2],\n+\t\t\t       insn, xdelay);\n     }\n   return buf;\n }\n@@ -6562,6 +6651,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n const char *\n output_dbra (rtx *operands, rtx insn, int which_alternative)\n {\n+  int length = get_attr_length (insn);\n \n   /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  Be prepared!  */\n@@ -6587,7 +6677,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n   if (which_alternative == 0)\n     {\n       int nullify = INSN_ANNULLED_BRANCH_P (insn);\n-      int length = get_attr_length (insn);\n+      int xdelay;\n \n       /* If this is a long branch with its delay slot unfilled, set `nullify'\n \t as it can nullify the delay slot and save a nop.  */\n@@ -6631,7 +6721,30 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \t    return \"addi,%N2 %1,%0,%0\\n\\tb %3\";\n \n \tdefault:\n-\t  gcc_unreachable ();\n+\t  /* The reversed conditional branch must branch over one additional\n+\t     instruction if the delay slot is filled and needs to be extracted\n+\t     by output_lbranch.  If the delay slot is empty or this is a\n+\t     nullified forward branch, the instruction after the reversed\n+\t     condition branch must be nullified.  */\n+\t  if (dbr_sequence_length () == 0\n+\t      || (nullify && forward_branch_p (insn)))\n+\t    {\n+\t      nullify = 1;\n+\t      xdelay = 0;\n+\t      operands[4] = GEN_INT (length);\n+\t    }\n+\t  else\n+\t    {\n+\t      xdelay = 1;\n+\t      operands[4] = GEN_INT (length + 4);\n+\t    }\n+\n+\t  if (nullify)\n+\t    output_asm_insn (\"addib,%N2,n %1,%0,.+%4\", operands);\n+\t  else\n+\t    output_asm_insn (\"addib,%N2 %1,%0,.+%4\", operands);\n+\n+\t  return output_lbranch (operands[3], insn, xdelay);\n \t}\n       \n     }\n@@ -6644,32 +6757,46 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n       output_asm_insn (\"{fstws|fstw} %0,-16(%%r30)\\n\\tldw -16(%%r30),%4\",\n \t\t       operands);\n       output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(%%r30)\", operands);\n-      if (get_attr_length (insn) == 24)\n+      if (length == 24)\n \treturn \"{comb|cmpb},%S2 %%r0,%4,%3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n-      else\n+      else if (length == 28)\n \treturn \"{comclr|cmpclr},%B2 %%r0,%4,%%r0\\n\\tb %3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n+      else\n+\t{\n+\t  operands[4] = GEN_INT (length - 24);\n+\t  output_asm_insn (\"addib,%N2 %1,%0,.+%4\", operands);\n+\t  output_asm_insn (\"{fldws|fldw} -16(%%r30),%0\", operands);\n+\t  return output_lbranch (operands[3], insn, 0);\n+\t}\n     }\n   /* Deal with gross reload from memory case.  */\n   else\n     {\n       /* Reload loop counter from memory, the store back to memory\n \t happens in the branch's delay slot.  */\n       output_asm_insn (\"ldw %0,%4\", operands);\n-      if (get_attr_length (insn) == 12)\n+      if (length == 12)\n \treturn \"addib,%C2 %1,%4,%3\\n\\tstw %4,%0\";\n-      else\n+      else if (length == 16)\n \treturn \"addi,%N2 %1,%4,%4\\n\\tb %3\\n\\tstw %4,%0\";\n+      else\n+\t{\n+\t  operands[5] = GEN_INT (length - 12);\n+\t  output_asm_insn (\"addib,%N2 %1,%0,.+%5\\n\\tstw %4,%0\", operands);\n+\t  return output_lbranch (operands[3], insn, 0);\n+\t}\n     }\n }\n \n-/* Return the output template for emitting a dbra type insn.\n+/* Return the output template for emitting a movb type insn.\n \n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n output_movb (rtx *operands, rtx insn, int which_alternative,\n \t     int reverse_comparison)\n {\n+  int length = get_attr_length (insn);\n \n   /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  Be prepared!  */\n@@ -6696,7 +6823,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n   if (which_alternative == 0)\n     {\n       int nullify = INSN_ANNULLED_BRANCH_P (insn);\n-      int length = get_attr_length (insn);\n+      int xdelay;\n \n       /* If this is a long branch with its delay slot unfilled, set `nullify'\n \t as it can nullify the delay slot and save a nop.  */\n@@ -6740,38 +6867,80 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t    return \"or,%N2 %1,%%r0,%0\\n\\tb %3\";\n \n \tdefault:\n-\t  gcc_unreachable ();\n+\t  /* The reversed conditional branch must branch over one additional\n+\t     instruction if the delay slot is filled and needs to be extracted\n+\t     by output_lbranch.  If the delay slot is empty or this is a\n+\t     nullified forward branch, the instruction after the reversed\n+\t     condition branch must be nullified.  */\n+\t  if (dbr_sequence_length () == 0\n+\t      || (nullify && forward_branch_p (insn)))\n+\t    {\n+\t      nullify = 1;\n+\t      xdelay = 0;\n+\t      operands[4] = GEN_INT (length);\n+\t    }\n+\t  else\n+\t    {\n+\t      xdelay = 1;\n+\t      operands[4] = GEN_INT (length + 4);\n+\t    }\n+\n+\t  if (nullify)\n+\t    output_asm_insn (\"movb,%N2,n %1,%0,.+%4\", operands);\n+\t  else\n+\t    output_asm_insn (\"movb,%N2 %1,%0,.+%4\", operands);\n+\n+\t  return output_lbranch (operands[3], insn, xdelay);\n \t}\n     }\n-  /* Deal with gross reload from FP register case.  */\n+  /* Deal with gross reload for FP destination register case.  */\n   else if (which_alternative == 1)\n     {\n-      /* Move loop counter from FP register to MEM then into a GR,\n-\t increment the GR, store the GR into MEM, and finally reload\n-\t the FP register from MEM from within the branch's delay slot.  */\n+      /* Move source register to MEM, perform the branch test, then\n+\t finally load the FP register from MEM from within the branch's\n+\t delay slot.  */\n       output_asm_insn (\"stw %1,-16(%%r30)\", operands);\n-      if (get_attr_length (insn) == 12)\n+      if (length == 12)\n \treturn \"{comb|cmpb},%S2 %%r0,%1,%3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n-      else\n+      else if (length == 16)\n \treturn \"{comclr|cmpclr},%B2 %%r0,%1,%%r0\\n\\tb %3\\n\\t{fldws|fldw} -16(%%r30),%0\";\n+      else\n+\t{\n+\t  operands[4] = GEN_INT (length - 12);\n+\t  output_asm_insn (\"movb,%N2 %1,%0,.+%4\", operands);\n+\t  output_asm_insn (\"{fldws|fldw} -16(%%r30),%0\", operands);\n+\t  return output_lbranch (operands[3], insn, 0);\n+\t}\n     }\n   /* Deal with gross reload from memory case.  */\n   else if (which_alternative == 2)\n     {\n       /* Reload loop counter from memory, the store back to memory\n \t happens in the branch's delay slot.  */\n-      if (get_attr_length (insn) == 8)\n+      if (length == 8)\n \treturn \"{comb|cmpb},%S2 %%r0,%1,%3\\n\\tstw %1,%0\";\n-      else\n+      else if (length == 12)\n \treturn \"{comclr|cmpclr},%B2 %%r0,%1,%%r0\\n\\tb %3\\n\\tstw %1,%0\";\n+      else\n+\t{\n+\t  operands[4] = GEN_INT (length - 8);\n+\t  output_asm_insn (\"movb,%N2 %1,%0,.+%4\\n\\tstw %1,%0\", operands);\n+\t  return output_lbranch (operands[3], insn, 0);\n+\t}\n     }\n   /* Handle SAR as a destination.  */\n   else\n     {\n-      if (get_attr_length (insn) == 8)\n+      if (length == 8)\n \treturn \"{comb|cmpb},%S2 %%r0,%1,%3\\n\\tmtsar %r1\";\n-      else\n+      else if (length == 12)\n \treturn \"{comclr|cmpclr},%B2 %%r0,%1,%%r0\\n\\tb %3\\n\\tmtsar %r1\";\n+      else\n+\t{\n+\t  operands[4] = GEN_INT (length - 8);\n+\t  output_asm_insn (\"movb,%N2 %1,%0,.+%4\\n\\tmtsar %r1\", operands);\n+\t  return output_lbranch (operands[3], insn, 0);\n+\t}\n     }\n }\n \n@@ -8241,37 +8410,50 @@ jump_in_call_delay (rtx insn)\n /* Output an unconditional move and branch insn.  */\n \n const char *\n-output_parallel_movb (rtx *operands, int length)\n+output_parallel_movb (rtx *operands, rtx insn)\n {\n+  int length = get_attr_length (insn);\n+\n   /* These are the cases in which we win.  */\n   if (length == 4)\n     return \"mov%I1b,tr %1,%0,%2\";\n \n-  /* None of these cases wins, but they don't lose either.  */\n-  if (dbr_sequence_length () == 0)\n+  /* None of the following cases win, but they don't lose either.  */\n+  if (length == 8)\n     {\n-      /* Nothing in the delay slot, fake it by putting the combined\n-\t insn (the copy or add) in the delay slot of a bl.  */\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\treturn \"b %2\\n\\tldi %1,%0\";\n+      if (dbr_sequence_length () == 0)\n+\t{\n+\t  /* Nothing in the delay slot, fake it by putting the combined\n+\t     insn (the copy or add) in the delay slot of a bl.  */\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    return \"b %2\\n\\tldi %1,%0\";\n+\t  else\n+\t    return \"b %2\\n\\tcopy %1,%0\";\n+\t}\n       else\n-\treturn \"b %2\\n\\tcopy %1,%0\";\n+\t{\n+\t  /* Something in the delay slot, but we've got a long branch.  */\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    return \"ldi %1,%0\\n\\tb %2\";\n+\t  else\n+\t    return \"copy %1,%0\\n\\tb %2\";\n+\t}\n     }\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    output_asm_insn (\"ldi %1,%0\", operands);\n   else\n-    {\n-      /* Something in the delay slot, but we've got a long branch.  */\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\treturn \"ldi %1,%0\\n\\tb %2\";\n-      else\n-\treturn \"copy %1,%0\\n\\tb %2\";\n-    }\n+    output_asm_insn (\"copy %1,%0\", operands);\n+  return output_lbranch (operands[2], insn, 1);\n }\n \n /* Output an unconditional add and branch insn.  */\n \n const char *\n-output_parallel_addb (rtx *operands, int length)\n+output_parallel_addb (rtx *operands, rtx insn)\n {\n+  int length = get_attr_length (insn);\n+\n   /* To make life easy we want operand0 to be the shared input/output\n      operand and operand1 to be the readonly operand.  */\n   if (operands[0] == operands[1])\n@@ -8281,18 +8463,20 @@ output_parallel_addb (rtx *operands, int length)\n   if (length == 4)\n     return \"add%I1b,tr %1,%0,%3\";\n \n-  /* None of these cases win, but they don't lose either.  */\n-  if (dbr_sequence_length () == 0)\n+  /* None of the following cases win, but they don't lose either.  */\n+  if (length == 8)\n     {\n-      /* Nothing in the delay slot, fake it by putting the combined\n-\t insn (the copy or add) in the delay slot of a bl.  */\n-      return \"b %3\\n\\tadd%I1 %1,%0,%0\";\n-    }\n-  else\n-    {\n-      /* Something in the delay slot, but we've got a long branch.  */\n-      return \"add%I1 %1,%0,%0\\n\\tb %3\";\n+      if (dbr_sequence_length () == 0)\n+\t/* Nothing in the delay slot, fake it by putting the combined\n+\t   insn (the copy or add) in the delay slot of a bl.  */\n+\treturn \"b %3\\n\\tadd%I1 %1,%0,%0\";\n+      else\n+\t/* Something in the delay slot, but we've got a long branch.  */\n+\treturn \"add%I1 %1,%0,%0\\n\\tb %3\";\n     }\n+\n+  output_asm_insn (\"add%I1 %1,%0,%0\", operands);\n+  return output_lbranch (operands[3], insn, 1);\n }\n \n /* Return nonzero if INSN (a jump insn) immediately follows a call"}, {"sha": "e8acd9a465a1af6eed01b479944e312d3bfefada", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 514, "deletions": 230, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d74a3cc2e10045063e16a0b04cdb5645a744b6/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=16d74a3cc2e10045063e16a0b04cdb5645a744b6", "patch": "@@ -139,7 +139,7 @@\n (define_delay (eq_attr \"type\" \"btable_branch,branch,parallel_branch\")\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n-;; Floating point conditional branch delay slot description and\n+;; Floating point conditional branch delay slot description.\n (define_delay (eq_attr \"type\" \"fbranch\")\n   [(eq_attr \"in_branch_delay\" \"true\")\n    (eq_attr \"in_nullified_branch_delay\" \"true\")\n@@ -1708,8 +1708,7 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn);\n+  return output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1719,6 +1718,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1736,8 +1737,7 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn);\n+  return output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1747,6 +1747,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1762,8 +1764,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn);\n+  return output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1773,6 +1774,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1790,8 +1793,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn);\n+  return output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1801,6 +1803,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1815,8 +1819,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn);\n+  return output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1826,6 +1829,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1843,8 +1848,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn);\n+  return output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1854,6 +1858,8 @@\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n \t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n \t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n \t   (const_int 20)]\n \t  (const_int 28)))])\n@@ -1871,15 +1877,21 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn, 0);\n+  return output_bb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1893,15 +1905,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn, 0);\n+  return output_bb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1915,15 +1933,21 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn, 0);\n+  return output_bb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1937,15 +1961,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn, 0);\n+  return output_bb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1959,15 +1989,21 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn, 1);\n+  return output_bb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1981,15 +2017,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 0, insn, 1);\n+  return output_bb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2003,15 +2045,21 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn, 1);\n+  return output_bb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2025,15 +2073,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t get_attr_length (insn), 1, insn, 1);\n+  return output_bb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n ;; Branch on Variable Bit patterns.\n (define_insn \"\"\n@@ -2048,15 +2102,21 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 0, insn, 0);\n+  return output_bvb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2070,15 +2130,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 0, insn, 0);\n+  return output_bvb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2092,15 +2158,21 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 1, insn, 0);\n+  return output_bvb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2114,15 +2186,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 1, insn, 0);\n+  return output_bvb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2136,15 +2214,21 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 0, insn, 1);\n+  return output_bvb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2158,15 +2242,21 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 0, insn, 1);\n+  return output_bvb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2180,15 +2270,21 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 1, insn, 1);\n+  return output_bvb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2202,46 +2298,114 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n-\t\t     get_attr_length (insn), 1, insn, 1);\n+  return output_bvb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n ;; Floating point branches\n+\n+;; ??? Nullification is handled differently from other branches.\n+;; If nullification is specified, the delay slot is nullified on any\n+;; taken branch regardless of branch direction.\n (define_insn \"\"\n   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n \t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n \t\t\t   (pc)))]\n-  \"! TARGET_SOFT_FLOAT\"\n+  \"!TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  if (INSN_ANNULLED_BRANCH_P (insn))\n-    return \\\"ftest\\;b,n %0\\\";\n+  int length = get_attr_length (insn);\n+  rtx xoperands[1];\n+  int nullify, xdelay;\n+\n+  if (length < 16)\n+    return \\\"ftest\\;b%* %l0\\\";\n+\n+  if (dbr_sequence_length () == 0 || INSN_ANNULLED_BRANCH_P (insn))\n+    {\n+      nullify = 1;\n+      xdelay = 0;\n+      xoperands[0] = GEN_INT (length - 8);\n+    }\n+  else\n+    {\n+      nullify = 0;\n+      xdelay = 1;\n+      xoperands[0] = GEN_INT (length - 4);\n+    }\n+\n+  if (nullify)\n+    output_asm_insn (\\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b,n .+%0\\\", xoperands);\n   else\n-    return \\\"ftest\\;b%* %0\\\";\n+    output_asm_insn (\\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b .+%0\\\", xoperands);\n+  return output_lbranch (operands[0], insn, xdelay);\n }\"\n-  [(set_attr \"type\" \"fbranch\")\n-   (set_attr \"length\" \"8\")])\n+[(set_attr \"type\" \"fbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 32)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 28)]\n+\t  (const_int 36)))])\n \n (define_insn \"\"\n   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n \t\t\t   (pc)\n \t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"! TARGET_SOFT_FLOAT\"\n+  \"!TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  if (INSN_ANNULLED_BRANCH_P (insn))\n-    return \\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b,n %0\\\";\n-  else\n+  int length = get_attr_length (insn);\n+  rtx xoperands[1];\n+  int nullify, xdelay;\n+\n+  if (length < 16)\n     return \\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b%* %0\\\";\n+\n+  if (dbr_sequence_length () == 0 || INSN_ANNULLED_BRANCH_P (insn))\n+    {\n+      nullify = 1;\n+      xdelay = 0;\n+      xoperands[0] = GEN_INT (length - 4);\n+    }\n+  else\n+    {\n+      nullify = 0;\n+      xdelay = 1;\n+      xoperands[0] = GEN_INT (length);\n+    }\n+\n+  if (nullify)\n+    output_asm_insn (\\\"ftest\\;b,n .+%0\\\", xoperands);\n+  else\n+    output_asm_insn (\\\"ftest\\;b .+%0\\\", xoperands);\n+  return output_lbranch (operands[0], insn, xdelay);\n }\"\n-  [(set_attr \"type\" \"fbranch\")\n-   (set_attr \"length\" \"12\")])\n+[(set_attr \"type\" \"fbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 12)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 28)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 24)]\n+\t  (const_int 32)))])\n \n ;; Move instructions\n \n@@ -7006,11 +7170,10 @@\n   \"*\n {\n   /* An unconditional branch which can reach its target.  */\n-  if (get_attr_length (insn) != 24\n-      && get_attr_length (insn) != 16)\n+  if (get_attr_length (insn) < 16)\n     return \\\"b%* %l0\\\";\n \n-  return output_lbranch (operands[0], insn);\n+  return output_lbranch (operands[0], insn, 1);\n }\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"pa_combine_type\" \"uncond_branch\")\n@@ -7019,14 +7182,16 @@\n \t   (if_then_else (lt (abs (minus (match_dup 0)\n \t\t\t\t\t (plus (pc) (const_int 8))))\n \t\t\t     (const_int 8184))\n-\t\t\t (const_int 4)\n-\t\t\t (const_int 8))\n-\t   (ge (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t   (const_int 4)\n+\t   (const_int 8))\n+\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t       (const_int 262100))\n-\t   (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n-\t\t\t (const_int 16)\n-\t\t\t (const_int 24))]\n-\t  (const_int 4)))])\n+\t   (const_int 4)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 20)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 16)]\n+\t  (const_int 24)))])\n \n ;;; Hope this is only within a function...\n (define_insn \"indirect_jump\"\n@@ -8840,39 +9005,71 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n       (if_then_else (eq_attr \"alternative\" \"0\")\n ;; Loop counter in register case\n ;; Short branch has length of 4\n-;; Long branch has length of 8\n-\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8))\n+;; Long branch has length of 8, 20, 24 or 28\n+\t(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28))\n \n ;; Loop counter in FP reg case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n-\t\t  (const_int 8184))\n-\t      (const_int 24)\n-\t      (const_int 28))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8184))\n-\t      (const_int 24)\n-\t      (const_int 28)))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 24)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 28)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 44)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 40)]\n+\t\t  (const_int 48))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 24)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 28)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 44)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 40)]\n+\t\t  (const_int 48)))\n+\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (lt (match_dup 3) (pc))\n-\t  (if_then_else\n-\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t(const_int 8184))\n-\t    (const_int 12)\n-\t    (const_int 16))\n-\t  (if_then_else\n-\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t(const_int 8184))\n-\t    (const_int 12)\n-\t    (const_int 16))))))])\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36))))))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -8891,33 +9088,59 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n       (if_then_else (eq_attr \"alternative\" \"0\")\n ;; Loop counter in register case\n ;; Short branch has length of 4\n-;; Long branch has length of 8\n-\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8))\n+;; Long branch has length of 8, 20, 24 or 28\n+        (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28))\n \n ;; Loop counter in FP reg case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t  (const_int 8184))\n-\t      (const_int 12)\n-\t      (const_int 16))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8184))\n-\t      (const_int 12)\n-\t      (const_int 16)))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36)))\n+\n ;; Loop counter in memory or sar case.\n ;; Extra goo to deal with additional reload insns.\n-\t(if_then_else\n-\t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t      (const_int 8184))\n-\t  (const_int 8)\n-\t  (const_int 12)))))])\n+\t(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t   (const_int 8184))\n+\t\t(const_int 8)\n+\t\t(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t  (const_int 262100))\n+\t\t(const_int 12)\n+\t\t(ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t(const_int 28)\n+\t\t(eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t(const_int 24)]\n+\t      (const_int 32)))))])\n \n ;; Handle negated branch.\n (define_insn \"\"\n@@ -8938,32 +9161,58 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; Loop counter in register case\n ;; Short branch has length of 4\n ;; Long branch has length of 8\n-\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8))\n+        (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28))\n \n ;; Loop counter in FP reg case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t  (const_int 8184))\n-\t      (const_int 12)\n-\t      (const_int 16))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8184))\n-\t      (const_int 12)\n-\t      (const_int 16)))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36))\n+\t     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+\t\t    (const_int 12)\n+\t\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 262100))\n+\t\t    (const_int 16)\n+\t\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t    (const_int 32)\n+\t\t    (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t    (const_int 28)]\n+\t\t  (const_int 36)))\n+\n ;; Loop counter in memory or SAR case.\n ;; Extra goo to deal with additional reload insns.\n-\t(if_then_else\n-\t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t      (const_int 8184))\n-\t  (const_int 8)\n-\t  (const_int 12)))))])\n+\t(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t   (const_int 8184))\n+\t\t(const_int 8)\n+\t\t(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t  (const_int 262100))\n+\t\t(const_int 12)\n+\t\t(ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t\t(const_int 28)\n+\t\t(eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t(const_int 24)]\n+\t      (const_int 32)))))])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 3 \"\" \"\" )))\n@@ -8973,14 +9222,21 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"(reload_completed && operands[0] == operands[1]) || operands[0] == operands[2]\"\n   \"*\n {\n-  return output_parallel_addb (operands, get_attr_length (insn));\n+  return output_parallel_addb (operands, insn);\n }\"\n-  [(set_attr \"type\" \"parallel_branch\")\n-   (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+[(set_attr \"type\" \"parallel_branch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n@@ -8989,14 +9245,21 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, get_attr_length (insn));\n+  return output_parallel_movb (operands, insn);\n }\"\n-  [(set_attr \"type\" \"parallel_branch\")\n-   (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+[(set_attr \"type\" \"parallel_branch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n@@ -9005,14 +9268,21 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, get_attr_length (insn));\n+  return output_parallel_movb (operands, insn);\n }\"\n-  [(set_attr \"type\" \"parallel_branch\")\n-   (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+[(set_attr \"type\" \"parallel_branch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n@@ -9021,14 +9291,21 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, get_attr_length (insn));\n+  return output_parallel_movb (operands, insn);\n }\"\n-  [(set_attr \"type\" \"parallel_branch\")\n-   (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+[(set_attr \"type\" \"parallel_branch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n@@ -9037,14 +9314,21 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, get_attr_length (insn));\n+  return output_parallel_movb (operands, insn);\n }\"\n-  [(set_attr \"type\" \"parallel_branch\")\n-   (set (attr \"length\")\n-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8)))])\n+[(set_attr \"type\" \"parallel_branch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t   (const_int 24)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=f\")"}]}