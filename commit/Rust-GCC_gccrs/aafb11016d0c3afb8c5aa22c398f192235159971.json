{"sha": "aafb11016d0c3afb8c5aa22c398f192235159971", "node_id": "C_kwDOANBUbNoAKGFhZmIxMTAxNmQwYzNhZmI4YzVhYTIyYzM5OGYxOTIyMzUxNTk5NzE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-06T19:15:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-06T19:15:27Z"}, "message": "Merge #1359\n\n1359: typecheck: Move TypeCheckItem into source and header file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "d23fcd4fe9088ac2b510973815d713fb35409a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d23fcd4fe9088ac2b510973815d713fb35409a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aafb11016d0c3afb8c5aa22c398f192235159971", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixd9PCRBK7hj4Ov3rIwAA4ScIAKM1Gc684OEujF+Pa4jVvxOd\nrrK23dYNCKPSnfkKASB+RIEBJBYOV5oFSHw8ofMQRL88QG4/yuHHH3tFanMEnTF4\ntgk/Lhv1SPiSjtz6GwwfaEeSoClGV3/mxLFZ5iJn6NdI/MXOpqCSj9Zl+2vK9A+F\nZ81E1CyX9NVltk2zOMPX37BGA1Zee4437/rNaTXLm7Rxs80hb3WkCLluW9HIAFeq\nf7RxJjkf+hgUOYmUZMcifn9LbN8XS9eOjlNr7NaIFp32A5xIvLOspHfgrwCnvI39\nSOdXnSv0pY0TZbiMfwszfzI7pPilby63uWWzBxVRONFaAaE/830pDqPBAEG91CQ=\n=vKTA\n-----END PGP SIGNATURE-----\n", "payload": "tree d23fcd4fe9088ac2b510973815d713fb35409a8b\nparent 29d594e263f0ccbcbd2babf43ff453c5188f4f2c\nparent 9cc83569d196ef1fd2e19abda06231b42dce4f51\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657134927 +0000\ncommitter GitHub <noreply@github.com> 1657134927 +0000\n\nMerge #1359\n\n1359: typecheck: Move TypeCheckItem into source and header file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aafb11016d0c3afb8c5aa22c398f192235159971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aafb11016d0c3afb8c5aa22c398f192235159971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aafb11016d0c3afb8c5aa22c398f192235159971/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d594e263f0ccbcbd2babf43ff453c5188f4f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d594e263f0ccbcbd2babf43ff453c5188f4f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d594e263f0ccbcbd2babf43ff453c5188f4f2c"}, {"sha": "9cc83569d196ef1fd2e19abda06231b42dce4f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc83569d196ef1fd2e19abda06231b42dce4f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc83569d196ef1fd2e19abda06231b42dce4f51"}], "stats": {"total": 423, "additions": 232, "deletions": 191}, "files": [{"sha": "b448da95aea455239c9a883c7cdd6d41b9859fb0", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=aafb11016d0c3afb8c5aa22c398f192235159971", "patch": "@@ -110,6 +110,7 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n+    rust/rust-hir-type-check-item.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-type-check-pattern.o \\"}, {"sha": "28cac51f7934ab4d295dd5dd0eab42164019abd8", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=aafb11016d0c3afb8c5aa22c398f192235159971", "patch": "@@ -0,0 +1,226 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-item.h\"\n+\n+namespace Rust {\n+\n+namespace Resolver {\n+void\n+TypeCheckItem::Resolve (HIR::Item *item)\n+{\n+  TypeCheckItem resolver;\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic_param : impl_block.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tTyTy::BaseType *l = nullptr;\n+\t\tbool ok = context->lookup_type (\n+\t\t  generic_param->get_mappings ().get_hirid (), &l);\n+\t\tif (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t  {\n+\t\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t      static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t      static_cast<TyTy::ParamType *> (l)));\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  auto specified_bound = TyTy::TypeBoundPredicate::error ();\n+  TraitReference *trait_reference = &TraitReference::error_node ();\n+  if (impl_block.has_trait_ref ())\n+    {\n+      std::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n+      trait_reference = TraitResolver::Resolve (*ref.get ());\n+      rust_assert (!trait_reference->is_error ());\n+\n+      // we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n+      // for example\n+      specified_bound = get_predicate_from_bound (*ref.get ());\n+    }\n+\n+  TyTy::BaseType *self = nullptr;\n+  if (!context->lookup_type (\n+\timpl_block.get_type ()->get_mappings ().get_hirid (), &self))\n+    {\n+      rust_error_at (impl_block.get_locus (),\n+\t\t     \"failed to resolve Self for ImplBlock\");\n+      return;\n+    }\n+\n+  // inherit the bounds\n+  if (!specified_bound.is_error ())\n+    self->inherit_bounds ({specified_bound});\n+\n+  // check for any unconstrained type-params\n+  const TyTy::SubstitutionArgumentMappings trait_constraints\n+    = specified_bound.get_substitution_arguments ();\n+  const TyTy::SubstitutionArgumentMappings impl_constraints\n+    = GetUsedSubstArgs::From (self);\n+\n+  bool impl_block_has_unconstrained_typarams\n+    = check_for_unconstrained (substitutions, trait_constraints,\n+\t\t\t       impl_constraints, self);\n+  if (impl_block_has_unconstrained_typarams)\n+    return;\n+\n+  // validate the impl items\n+  bool is_trait_impl_block = !trait_reference->is_error ();\n+  std::vector<const TraitItemReference *> trait_item_refs;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (!is_trait_impl_block)\n+\tTypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n+      else\n+\t{\n+\t  auto trait_item_ref\n+\t    = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n+\t\t\t\t\t\t   impl_item.get (), self,\n+\t\t\t\t\t\t   specified_bound,\n+\t\t\t\t\t\t   substitutions);\n+\t  trait_item_refs.push_back (trait_item_ref.get_raw_item ());\n+\t}\n+    }\n+\n+  bool impl_block_missing_trait_items\n+    = is_trait_impl_block\n+      && trait_reference->size () != trait_item_refs.size ();\n+  if (impl_block_missing_trait_items)\n+    {\n+      // filter the missing impl_items\n+      std::vector<std::reference_wrapper<const TraitItemReference>>\n+\tmissing_trait_items;\n+      for (const auto &trait_item_ref : trait_reference->get_trait_items ())\n+\t{\n+\t  bool found = false;\n+\t  for (auto implemented_trait_item : trait_item_refs)\n+\t    {\n+\t      std::string trait_item_name = trait_item_ref.get_identifier ();\n+\t      std::string impl_item_name\n+\t\t= implemented_trait_item->get_identifier ();\n+\t      found = trait_item_name.compare (impl_item_name) == 0;\n+\t      if (found)\n+\t\tbreak;\n+\t    }\n+\n+\t  bool is_required_trait_item = !trait_item_ref.is_optional ();\n+\t  if (!found && is_required_trait_item)\n+\t    missing_trait_items.push_back (trait_item_ref);\n+\t}\n+\n+      if (missing_trait_items.size () > 0)\n+\t{\n+\t  std::string missing_items_buf;\n+\t  RichLocation r (impl_block.get_locus ());\n+\t  for (size_t i = 0; i < missing_trait_items.size (); i++)\n+\t    {\n+\t      bool has_more = (i + 1) < missing_trait_items.size ();\n+\t      const TraitItemReference &missing_trait_item\n+\t\t= missing_trait_items.at (i);\n+\t      missing_items_buf += missing_trait_item.get_identifier ()\n+\t\t\t\t   + (has_more ? \", \" : \"\");\n+\t      r.add_range (missing_trait_item.get_locus ());\n+\t    }\n+\n+\t  rust_error_at (r, \"missing %s in implementation of trait %<%s%>\",\n+\t\t\t missing_items_buf.c_str (),\n+\t\t\t trait_reference->get_name ().c_str ());\n+\t}\n+    }\n+\n+  if (is_trait_impl_block)\n+    {\n+      trait_reference->clear_associated_types ();\n+\n+      AssociatedImplTrait associated (trait_reference, &impl_block, self,\n+\t\t\t\t      context);\n+      context->insert_associated_trait_impl (\n+\timpl_block.get_mappings ().get_hirid (), std::move (associated));\n+      context->insert_associated_impl_mapping (\n+\ttrait_reference->get_mappings ().get_hirid (), self,\n+\timpl_block.get_mappings ().get_hirid ());\n+    }\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    {\n+      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      rust_error_at (function.get_locus (),\n+\t\t     \"found invalid type for function [%s]\",\n+\t\t     lookup->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    TypeCheckItem::Resolve (item.get ());\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Trait &trait)\n+{\n+  TraitResolver::Resolve (trait);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "b9a0d9b2e906a3026988cdebb8570e5078cb178f", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 5, "deletions": 191, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafb11016d0c3afb8c5aa22c398f192235159971/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=aafb11016d0c3afb8c5aa22c398f192235159971", "patch": "@@ -35,198 +35,12 @@ class TypeCheckItem : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static void Resolve (HIR::Item *item)\n-  {\n-    TypeCheckItem resolver;\n-    item->accept_vis (resolver);\n-  }\n+  static void Resolve (HIR::Item *item);\n \n-  void visit (HIR::ImplBlock &impl_block) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic_param : impl_block.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  TyTy::BaseType *l = nullptr;\n-\t\t  bool ok = context->lookup_type (\n-\t\t    generic_param->get_mappings ().get_hirid (), &l);\n-\t\t  if (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n-\t\t    {\n-\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n-\t\t\tstatic_cast<TyTy::ParamType *> (l)));\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    auto specified_bound = TyTy::TypeBoundPredicate::error ();\n-    TraitReference *trait_reference = &TraitReference::error_node ();\n-    if (impl_block.has_trait_ref ())\n-      {\n-\tstd::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n-\ttrait_reference = TraitResolver::Resolve (*ref.get ());\n-\trust_assert (!trait_reference->is_error ());\n-\n-\t// we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n-\t// for example\n-\tspecified_bound = get_predicate_from_bound (*ref.get ());\n-      }\n-\n-    TyTy::BaseType *self = nullptr;\n-    if (!context->lookup_type (\n-\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n-      {\n-\trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve Self for ImplBlock\");\n-\treturn;\n-      }\n-\n-    // inherit the bounds\n-    if (!specified_bound.is_error ())\n-      self->inherit_bounds ({specified_bound});\n-\n-    // check for any unconstrained type-params\n-    const TyTy::SubstitutionArgumentMappings trait_constraints\n-      = specified_bound.get_substitution_arguments ();\n-    const TyTy::SubstitutionArgumentMappings impl_constraints\n-      = GetUsedSubstArgs::From (self);\n-\n-    bool impl_block_has_unconstrained_typarams\n-      = check_for_unconstrained (substitutions, trait_constraints,\n-\t\t\t\t impl_constraints, self);\n-    if (impl_block_has_unconstrained_typarams)\n-      return;\n-\n-    // validate the impl items\n-    bool is_trait_impl_block = !trait_reference->is_error ();\n-    std::vector<const TraitItemReference *> trait_item_refs;\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tif (!is_trait_impl_block)\n-\t  TypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n-\telse\n-\t  {\n-\t    auto trait_item_ref\n-\t      = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n-\t\t\t\t\t\t     impl_item.get (), self,\n-\t\t\t\t\t\t     specified_bound,\n-\t\t\t\t\t\t     substitutions);\n-\t    trait_item_refs.push_back (trait_item_ref.get_raw_item ());\n-\t  }\n-      }\n-\n-    bool impl_block_missing_trait_items\n-      = is_trait_impl_block\n-\t&& trait_reference->size () != trait_item_refs.size ();\n-    if (impl_block_missing_trait_items)\n-      {\n-\t// filter the missing impl_items\n-\tstd::vector<std::reference_wrapper<const TraitItemReference>>\n-\t  missing_trait_items;\n-\tfor (const auto &trait_item_ref : trait_reference->get_trait_items ())\n-\t  {\n-\t    bool found = false;\n-\t    for (auto implemented_trait_item : trait_item_refs)\n-\t      {\n-\t\tstd::string trait_item_name = trait_item_ref.get_identifier ();\n-\t\tstd::string impl_item_name\n-\t\t  = implemented_trait_item->get_identifier ();\n-\t\tfound = trait_item_name.compare (impl_item_name) == 0;\n-\t\tif (found)\n-\t\t  break;\n-\t      }\n-\n-\t    bool is_required_trait_item = !trait_item_ref.is_optional ();\n-\t    if (!found && is_required_trait_item)\n-\t      missing_trait_items.push_back (trait_item_ref);\n-\t  }\n-\n-\tif (missing_trait_items.size () > 0)\n-\t  {\n-\t    std::string missing_items_buf;\n-\t    RichLocation r (impl_block.get_locus ());\n-\t    for (size_t i = 0; i < missing_trait_items.size (); i++)\n-\t      {\n-\t\tbool has_more = (i + 1) < missing_trait_items.size ();\n-\t\tconst TraitItemReference &missing_trait_item\n-\t\t  = missing_trait_items.at (i);\n-\t\tmissing_items_buf += missing_trait_item.get_identifier ()\n-\t\t\t\t     + (has_more ? \", \" : \"\");\n-\t\tr.add_range (missing_trait_item.get_locus ());\n-\t      }\n-\n-\t    rust_error_at (r, \"missing %s in implementation of trait %<%s%>\",\n-\t\t\t   missing_items_buf.c_str (),\n-\t\t\t   trait_reference->get_name ().c_str ());\n-\t  }\n-      }\n-\n-    if (is_trait_impl_block)\n-      {\n-\ttrait_reference->clear_associated_types ();\n-\n-\tAssociatedImplTrait associated (trait_reference, &impl_block, self,\n-\t\t\t\t\tcontext);\n-\tcontext->insert_associated_trait_impl (\n-\t  impl_block.get_mappings ().get_hirid (), std::move (associated));\n-\tcontext->insert_associated_impl_mapping (\n-\t  trait_reference->get_mappings ().get_hirid (), self,\n-\t  impl_block.get_mappings ().get_hirid ());\n-      }\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (),\n-\t\t       \"found invalid type for function [%s]\",\n-\t\t       lookup->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // need to get the return type from this\n-    TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n-    auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (TypeCheckContextItem (&function),\n-\t\t\t       expected_ret_tyty);\n-\n-    auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n-\n-    context->pop_return_type ();\n-\n-    if (block_expr_ty->get_kind () != TyTy::NEVER)\n-      expected_ret_tyty->unify (block_expr_ty);\n-  }\n-\n-  void visit (HIR::Module &module) override\n-  {\n-    for (auto &item : module.get_items ())\n-      TypeCheckItem::Resolve (item.get ());\n-  }\n-\n-  void visit (HIR::Trait &trait) override { TraitResolver::Resolve (trait); }\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::Trait &trait) override;\n \n private:\n   TypeCheckItem () : TypeCheckBase () {}"}]}