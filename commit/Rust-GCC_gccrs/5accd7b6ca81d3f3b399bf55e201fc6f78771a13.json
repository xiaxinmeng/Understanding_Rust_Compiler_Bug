{"sha": "5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjY2Q3YjZjYTgxZDNmM2IzOTliZjU1ZTIwMWZjNmY3ODc3MWExMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T11:06:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T11:06:09Z"}, "message": "[multiple changes]\n\n2011-08-29  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Reject test-case on\n\tlibrary-level subprogram.\n\t* sem_prag.adb (Check_Test_Case): Stricter rules for test-case\n\tplacement.\n\t(Analyze_Pragma): Change name \"Normal\" for \"Nominal\" in test-case\n\tcomponent.\n\t* snames.ads-tmpl: Change name \"Normal\" for \"Nominal\" in test-case\n\tcomponent.\n\t* gnat_rm.texi: Update doc for Test_Case pragma.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* a-exexpr-gcc.adb (Unwind_Exception): Remove default value, made it\n\tconvention C.\n\t(GCC_Exception_Access): New type.\n\t(Unwind_DeleteException): New imported procedure\n\t(Foreign_Exception): Import it.\n\t(GNAT_GCC_Exception): Simply have the occurrence inside.\n\t(To_GCC_Exception): New function.\n\t(To_GNAT_GCC_Exception): New function.\n\t(GNAT_GCC_Exception_Cleanup): New procedure..\n\t(Propagate_GCC_Exception): New procedure.\n\t(Reraise_GCC_Exception): New procedure.\n\t(Setup_Current_Excep): New procedure.\n\t(CleanupUnwind_Handler): Change type of UW_Exception parameter.\n\t(Unwind_RaiseException): Ditto.\n\t(Unwind_ForcedUnwind): Ditto.\n\t(Remove): Removed.\n\t(Begin_Handler): Change type of parameter.\n\t(End_Handler): Ditto. Now delete the exception if still present.\n\t(Setup_Key): Removed.\n\t(Is_Setup_And_Not_Propagated): Removed.\n\t(Set_Setup_And_Not_Propagated): Ditto.\n\t(Clear_Setup_And_Not_Propagated): Ditto.\n\t(Save_Occurrence_And_Private): Ditto.\n\t(EID_For): Add 'not null' constraint on parameter.\n\t(Setup_Exception): Does nothing.\n\t(Propagate_Exception): Simplified.\n\t* exp_ch11.adb (Expand_N_Raise_Statement): In back-end exception model,\n\tre-raise is not expanded anymore.\n\t* s-except.ads (Foreign_Exception): New exception - placeholder for\n\tnon Ada exceptions.\n\t* raise-gcc.c (__gnat_setup_current_excep): Declare\n\t(CXX_EXCEPTION_CLASS): Define (not yet used)\n\t(GNAT_EXCEPTION_CLASS): Define.\n\t(is_handled_by): Handle foreign exceptions.\n\t(PERSONALITY_FUNCTION): Call __gnat_setup_current_excep.\n\n2011-08-29  Jose Ruiz  <ruiz@adacore.com>\n\n\t* a-synbar.adb (Synchronous_Barrier): Some additional clarification.\n\nFrom-SVN: r178204", "tree": {"sha": "5296dea30b4ab9b51a3198c680e9713accd59479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5296dea30b4ab9b51a3198c680e9713accd59479"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/comments", "author": null, "committer": null, "parents": [{"sha": "2ef48385c29c519a157e3a6d60011196cd7e9409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef48385c29c519a157e3a6d60011196cd7e9409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef48385c29c519a157e3a6d60011196cd7e9409"}], "stats": {"total": 769, "additions": 358, "deletions": 411}, "files": [{"sha": "ba9fcbe5f7a7cc89f6b944a8e2be48d0eca1ea69", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -1,3 +1,57 @@\n+2011-08-29  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Reject test-case on\n+\tlibrary-level subprogram.\n+\t* sem_prag.adb (Check_Test_Case): Stricter rules for test-case\n+\tplacement.\n+\t(Analyze_Pragma): Change name \"Normal\" for \"Nominal\" in test-case\n+\tcomponent.\n+\t* snames.ads-tmpl: Change name \"Normal\" for \"Nominal\" in test-case\n+\tcomponent.\n+\t* gnat_rm.texi: Update doc for Test_Case pragma.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-exexpr-gcc.adb (Unwind_Exception): Remove default value, made it\n+\tconvention C.\n+\t(GCC_Exception_Access): New type.\n+\t(Unwind_DeleteException): New imported procedure\n+\t(Foreign_Exception): Import it.\n+\t(GNAT_GCC_Exception): Simply have the occurrence inside.\n+\t(To_GCC_Exception): New function.\n+\t(To_GNAT_GCC_Exception): New function.\n+\t(GNAT_GCC_Exception_Cleanup): New procedure..\n+\t(Propagate_GCC_Exception): New procedure.\n+\t(Reraise_GCC_Exception): New procedure.\n+\t(Setup_Current_Excep): New procedure.\n+\t(CleanupUnwind_Handler): Change type of UW_Exception parameter.\n+\t(Unwind_RaiseException): Ditto.\n+\t(Unwind_ForcedUnwind): Ditto.\n+\t(Remove): Removed.\n+\t(Begin_Handler): Change type of parameter.\n+\t(End_Handler): Ditto. Now delete the exception if still present.\n+\t(Setup_Key): Removed.\n+\t(Is_Setup_And_Not_Propagated): Removed.\n+\t(Set_Setup_And_Not_Propagated): Ditto.\n+\t(Clear_Setup_And_Not_Propagated): Ditto.\n+\t(Save_Occurrence_And_Private): Ditto.\n+\t(EID_For): Add 'not null' constraint on parameter.\n+\t(Setup_Exception): Does nothing.\n+\t(Propagate_Exception): Simplified.\n+\t* exp_ch11.adb (Expand_N_Raise_Statement): In back-end exception model,\n+\tre-raise is not expanded anymore.\n+\t* s-except.ads (Foreign_Exception): New exception - placeholder for\n+\tnon Ada exceptions.\n+\t* raise-gcc.c (__gnat_setup_current_excep): Declare\n+\t(CXX_EXCEPTION_CLASS): Define (not yet used)\n+\t(GNAT_EXCEPTION_CLASS): Define.\n+\t(is_handled_by): Handle foreign exceptions.\n+\t(PERSONALITY_FUNCTION): Call __gnat_setup_current_excep.\n+\n+2011-08-29  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* a-synbar.adb (Synchronous_Barrier): Some additional clarification.\n+\n 2011-08-29  Thomas Quinot  <quinot@adacore.com>\n \n \t* a-synbar-posix.adb: Minor reformatting."}, {"sha": "d32e7a43805e9ccc7c0c2b838210340ee0c62afb", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 172, "deletions": 323, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -104,11 +104,12 @@ package body Exception_Propagation is\n    --  Map the corresponding C type used in Unwind_Exception below\n \n    type Unwind_Exception is record\n-      Class    : Exception_Class := GNAT_Exception_Class;\n-      Cleanup  : System.Address  := System.Null_Address;\n+      Class    : Exception_Class;\n+      Cleanup  : System.Address;\n       Private1 : Unwind_Word;\n       Private2 : Unwind_Word;\n    end record;\n+   pragma Convention (C, Unwind_Exception);\n    --  Map the GCC struct used for exception handling\n \n    for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n@@ -117,6 +118,19 @@ package body Exception_Propagation is\n    --  maximally aligned (see unwind.h). See additional comments on the\n    --  alignment below.\n \n+   type GCC_Exception_Access is access all Unwind_Exception;\n+   pragma Convention (C, GCC_Exception_Access);\n+   --  Pointer to a GCC exception\n+\n+   procedure Unwind_DeleteException (Excp : not null GCC_Exception_Access);\n+   pragma Import (C, Unwind_DeleteException, \"_Unwind_DeleteException\");\n+   --  Procedure to free any GCC exception\n+\n+   Foreign_Exception : aliased System.Standard_Library.Exception_Data;\n+   pragma Import (Ada, Foreign_Exception,\n+                  \"system__exceptions__foreign_exception\");\n+   --  Id for foreign exceptions\n+\n    --------------------------------------------------------------\n    -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n    --------------------------------------------------------------\n@@ -128,13 +142,8 @@ package body Exception_Propagation is\n       Header : Unwind_Exception;\n       --  ABI Exception header first\n \n-      Id : Exception_Id;\n-      --  GNAT Exception identifier.  This is filled by Propagate_Exception\n-      --  and then used by the personality routine to determine if the context\n-      --  it examines contains a handler for the exception being propagated.\n-\n-      Next_Exception : EOA;\n-      --  Used to create a linked list of exception occurrences\n+      Occurrence : Exception_Occurrence;\n+      --  The Ada occurrence\n    end record;\n \n    pragma Convention (C, GNAT_GCC_Exception);\n@@ -158,20 +167,40 @@ package body Exception_Propagation is\n \n    type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n \n-   function To_GNAT_GCC_Exception is new\n-     Unchecked_Conversion (System.Address, GNAT_GCC_Exception_Access);\n+   function To_GCC_Exception is new\n+     Unchecked_Conversion (GNAT_GCC_Exception_Access, GCC_Exception_Access);\n \n-   procedure Free is new Unchecked_Deallocation\n-     (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n-\n-   procedure Free is new Unchecked_Deallocation\n-     (Exception_Occurrence, EOA);\n+   function To_GNAT_GCC_Exception is new\n+     Unchecked_Conversion (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n+\n+   procedure GNAT_GCC_Exception_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      Excep  : not null GNAT_GCC_Exception_Access);\n+   pragma Convention (C, GNAT_GCC_Exception_Cleanup);\n+   --  Procedure called when a GNAT GCC exception is free.\n+\n+   procedure Propagate_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma No_Return (Propagate_GCC_Exception);\n+   --  Propagate a GCC exception\n+\n+   procedure Reraise_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma No_Return (Reraise_GCC_Exception);\n+   pragma Export (C, Reraise_GCC_Exception, \"__gnat_reraise_zcx\");\n+   --  Called to implement raise without exception, ie reraise.  Called\n+   --  directly from gigi.\n+\n+   procedure Setup_Current_Excep\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n+   --  Write Get_Current_Excep.all from GCC_Exception\n \n    function CleanupUnwind_Handler\n      (UW_Version   : Integer;\n       UW_Phases    : Unwind_Action;\n       UW_Eclass    : Exception_Class;\n-      UW_Exception : not null access GNAT_GCC_Exception;\n+      UW_Exception : not null GCC_Exception_Access;\n       UW_Context   : System.Address;\n       UW_Argument  : System.Address) return Unwind_Reason_Code;\n    --  Hook called at each step of the forced unwinding we perform to\n@@ -183,57 +212,25 @@ package body Exception_Propagation is\n    --  __gnat stubs for these.\n \n    procedure Unwind_RaiseException\n-     (UW_Exception : not null access GNAT_GCC_Exception);\n+     (UW_Exception : not null GCC_Exception_Access);\n    pragma Import (C, Unwind_RaiseException, \"__gnat_Unwind_RaiseException\");\n \n    procedure Unwind_ForcedUnwind\n-     (UW_Exception : not null access GNAT_GCC_Exception;\n+     (UW_Exception : not null GCC_Exception_Access;\n       UW_Handler   : System.Address;\n       UW_Argument  : System.Address);\n    pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n \n-   ------------------------------------------------------------------\n-   -- Occurrence Stack Management Facilities for the GCC-EH Scheme --\n-   ------------------------------------------------------------------\n-\n-   function Remove\n-     (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access) return Boolean;\n-   --  Remove Excep from the stack starting at Top.\n-   --  Return True if Excep was found and removed, false otherwise.\n-\n    --  Hooks called when entering/leaving an exception handler for a given\n    --  occurrence, aimed at handling the stack of active occurrences. The\n    --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n \n-   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n+   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access);\n    pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n \n-   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access);\n+   procedure End_Handler (GCC_Exception : GCC_Exception_Access);\n    pragma Export (C, End_Handler, \"__gnat_end_handler\");\n \n-   Setup_Key : constant := 16#DEAD#;\n-   --  To handle the case of a task \"transferring\" an exception occurrence to\n-   --  another task, for instance via Exceptional_Complete_Rendezvous, we need\n-   --  to be able to identify occurrences which have been Setup and not yet\n-   --  Propagated. We hijack one of the common header fields for that purpose,\n-   --  setting it to a special key value during the setup process, clearing it\n-   --  at the very beginning of the propagation phase, and expecting it never\n-   --  to be reset to the special value later on. A 16-bit value is used rather\n-   --  than a 32-bit value for static compatibility with 16-bit targets such as\n-   --  AAMP (where type Unwind_Word will be 16 bits).\n-\n-   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean;\n-\n-   procedure Set_Setup_And_Not_Propagated (E : EOA);\n-   procedure Clear_Setup_And_Not_Propagated (E : EOA);\n-\n-   procedure Save_Occurrence_And_Private\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence);\n-   --  Copy all the components of Source to Target as well as the\n-   --  Private_Data pointer.\n-\n    --------------------------------------------------------------------\n    -- Accessors to Basic Components of a GNAT Exception Data Pointer --\n    --------------------------------------------------------------------\n@@ -254,7 +251,7 @@ package body Exception_Propagation is\n    function Import_Code_For (E : Exception_Data_Ptr) return Exception_Code;\n    pragma Export (C, Import_Code_For, \"__gnat_import_code_for\");\n \n-   function EID_For (GNAT_Exception : GNAT_GCC_Exception_Access)\n+   function EID_For (GNAT_Exception : not null GNAT_GCC_Exception_Access)\n      return Exception_Id;\n    pragma Export (C, EID_For, \"__gnat_eid_for\");\n \n@@ -274,64 +271,24 @@ package body Exception_Propagation is\n    All_Others_Value : constant Integer := 16#7FFF#;\n    pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n \n-   ------------\n-   -- Remove --\n-   ------------\n-\n-   function Remove\n-     (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access) return Boolean\n-   is\n-      Prev          : GNAT_GCC_Exception_Access := null;\n-      Iter          : EOA := Top;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n-   begin\n-      --  Pop stack\n-\n-      loop\n-         pragma Assert (Iter.Private_Data /= System.Null_Address);\n-\n-         GCC_Exception := To_GNAT_GCC_Exception (Iter.Private_Data);\n-\n-         if GCC_Exception = Excep then\n-            if Prev = null then\n-\n-               --  Special case for the top of the stack: shift the contents\n-               --  of the next item to the top, since top is at a fixed\n-               --  location and can't be changed.\n-\n-               Iter := GCC_Exception.Next_Exception;\n-\n-               if Iter = null then\n-\n-                  --  Stack is now empty\n-\n-                  Top.Private_Data := System.Null_Address;\n-\n-               else\n-                  Save_Occurrence_And_Private (Top.all, Iter.all);\n-                  Free (Iter);\n-               end if;\n-\n-            else\n-               Prev.Next_Exception := GCC_Exception.Next_Exception;\n-               Free (Iter);\n-            end if;\n-\n-            Free (GCC_Exception);\n+   --------------------------------\n+   -- GNAT_GCC_Exception_Cleanup --\n+   --------------------------------\n \n-            return True;\n-         end if;\n+   procedure GNAT_GCC_Exception_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      Excep  : not null GNAT_GCC_Exception_Access) is\n+      pragma Unreferenced (Reason);\n \n-         exit when GCC_Exception.Next_Exception = null;\n+      procedure Free is new Unchecked_Deallocation\n+        (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n \n-         Prev := GCC_Exception;\n-         Iter := GCC_Exception.Next_Exception;\n-      end loop;\n+      Copy : GNAT_GCC_Exception_Access := Excep;\n+   begin\n+      --  Simply free the memory\n \n-      return False;\n-   end Remove;\n+      Free (Copy);\n+   end GNAT_GCC_Exception_Cleanup;\n \n    ---------------------------\n    -- CleanupUnwind_Handler --\n@@ -341,17 +298,16 @@ package body Exception_Propagation is\n      (UW_Version   : Integer;\n       UW_Phases    : Unwind_Action;\n       UW_Eclass    : Exception_Class;\n-      UW_Exception : not null access GNAT_GCC_Exception;\n+      UW_Exception : not null GCC_Exception_Access;\n       UW_Context   : System.Address;\n       UW_Argument  : System.Address) return Unwind_Reason_Code\n    is\n-      pragma Unreferenced\n-        (UW_Version, UW_Eclass, UW_Exception, UW_Context, UW_Argument);\n-\n+      pragma Unreferenced (UW_Version, UW_Eclass, UW_Context, UW_Argument);\n    begin\n       --  Terminate when the end of the stack is reached\n \n       if UW_Phases >= UA_END_OF_STACK then\n+         Setup_Current_Excep (UW_Exception);\n          Unhandled_Exception_Terminate;\n       end if;\n \n@@ -362,54 +318,6 @@ package body Exception_Propagation is\n       return URC_NO_REASON;\n    end CleanupUnwind_Handler;\n \n-   ---------------------------------\n-   -- Is_Setup_And_Not_Propagated --\n-   ---------------------------------\n-\n-   function Is_Setup_And_Not_Propagated (E : EOA) return Boolean is\n-      GCC_E : constant GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      return GCC_E /= null and then GCC_E.Header.Private1 = Setup_Key;\n-   end Is_Setup_And_Not_Propagated;\n-\n-   ------------------------------------\n-   -- Clear_Setup_And_Not_Propagated --\n-   ------------------------------------\n-\n-   procedure Clear_Setup_And_Not_Propagated (E : EOA) is\n-      GCC_E : constant GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      pragma Assert (GCC_E /= null);\n-      GCC_E.Header.Private1 := 0;\n-   end Clear_Setup_And_Not_Propagated;\n-\n-   ----------------------------------\n-   -- Set_Setup_And_Not_Propagated --\n-   ----------------------------------\n-\n-   procedure Set_Setup_And_Not_Propagated (E : EOA) is\n-      GCC_E : constant GNAT_GCC_Exception_Access :=\n-                To_GNAT_GCC_Exception (E.Private_Data);\n-   begin\n-      pragma Assert (GCC_E /= null);\n-      GCC_E.Header.Private1 := Setup_Key;\n-   end Set_Setup_And_Not_Propagated;\n-\n-   --------------------------------\n-   -- Save_Occurrence_And_Private --\n-   --------------------------------\n-\n-   procedure Save_Occurrence_And_Private\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence)\n-   is\n-   begin\n-      Save_Occurrence_No_Private (Target, Source);\n-      Target.Private_Data := Source.Private_Data;\n-   end Save_Occurrence_And_Private;\n-\n    ---------------------\n    -- Setup_Exception --\n    ---------------------\n@@ -423,94 +331,125 @@ package body Exception_Propagation is\n       Current  : EOA;\n       Reraised : Boolean := False)\n    is\n-      Top           : constant EOA := Current;\n-      Next          : EOA;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n+      pragma Unreferenced (Excep, Current, Reraised);\n    begin\n-      --  The exception Excep is soon to be propagated, and the\n-      --  storage used for that will be the occurrence statically allocated\n-      --  for the current thread. This storage might currently be used for a\n-      --  still active occurrence, so we need to push it on the thread's\n-      --  occurrence stack (headed at that static occurrence) before it gets\n-      --  clobbered.\n-\n-      --  What we do here is to trigger this push when need be, and allocate a\n-      --  Private_Data block for the forthcoming Propagation.\n-\n-      --  Some tasking rendez-vous attempts lead to an occurrence transfer\n-      --  from the server to the client (see Exceptional_Complete_Rendezvous).\n-      --  In those cases Setup is called twice for the very same occurrence\n-      --  before it gets propagated: once from the server, because this is\n-      --  where the occurrence contents is elaborated and known, and then\n-      --  once from the client when it detects the case and actually raises\n-      --  the exception in its own context.\n-\n-      --  The Is_Setup_And_Not_Propagated predicate tells us when we are in\n-      --  the second call to Setup for a Transferred occurrence, and there is\n-      --  nothing to be done here in this situation. This predicate cannot be\n-      --  True if we are dealing with a Reraise, and we may even be called\n-      --  with a raw uninitialized Excep occurrence in this case so we should\n-      --  not check anyway. Observe the front-end expansion for a \"raise;\" to\n-      --  see that happening. We get a local occurrence and a direct call to\n-      --  Save_Occurrence without the intermediate init-proc call.\n-\n-      if not Reraised and then Is_Setup_And_Not_Propagated (Excep) then\n-         return;\n-      end if;\n+      --  In the GNAT-SJLJ case this \"stack\" only exists implicitly, by way of\n+      --  local occurrence declarations together with save/restore operations\n+      --  generated by the front-end, and this routine has nothing to do.\n \n-      --  Allocate what will be the Private_Data block for the exception\n-      --  to be propagated.\n+      null;\n+   end Setup_Exception;\n \n-      GCC_Exception := new GNAT_GCC_Exception;\n+   -------------------------\n+   -- Setup_Current_Excep --\n+   -------------------------\n \n-      --  If the Top of the occurrence stack is not currently used for an\n-      --  active exception (the stack is empty) we just need to setup the\n-      --  Private_Data pointer.\n+   procedure Setup_Current_Excep\n+     (GCC_Exception : not null GCC_Exception_Access) is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+   begin\n+      --  Setup the exception occurrence\n \n-      --  Otherwise, we also need to shift the contents of the Top of the\n-      --  stack in a freshly allocated entry and link everything together.\n+      if GCC_Exception.Class = GNAT_Exception_Class then\n \n-      if Top.Private_Data /= System.Null_Address then\n-         Next := new Exception_Occurrence;\n-         Save_Occurrence_And_Private (Next.all, Top.all);\n+         --  From the GCC exception\n \n-         GCC_Exception.Next_Exception := Next;\n-         Top.Private_Data := GCC_Exception.all'Address;\n-      end if;\n+         declare\n+            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n+              To_GNAT_GCC_Exception (GCC_Exception);\n+         begin\n+            Excep.all := GNAT_Occurrence.Occurrence;\n+         end;\n+      else\n \n-      Top.Private_Data := GCC_Exception.all'Address;\n+         --  A default one\n \n-      Set_Setup_And_Not_Propagated (Top);\n-   end Setup_Exception;\n+         Excep.Id := Foreign_Exception'Access;\n+         Excep.Msg_Length := 0;\n+         Excep.Cleanup_Flag := False;\n+         Excep.Exception_Raised := True;\n+         Excep.Pid := Local_Partition_ID;\n+         Excep.Num_Tracebacks := 0;\n+         Excep.Private_Data := System.Null_Address;\n+      end if;\n+   end Setup_Current_Excep;\n \n    -------------------\n    -- Begin_Handler --\n    -------------------\n \n-   procedure Begin_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n+   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access) is\n       pragma Unreferenced (GCC_Exception);\n-\n    begin\n-      --  Every necessary operation related to the occurrence stack has\n-      --  already been performed by Propagate_Exception. This hook remains for\n-      --  potential future necessity in optimizing the overall scheme, as well\n-      --  a useful debugging tool.\n-\n       null;\n    end Begin_Handler;\n \n    -----------------\n    -- End_Handler --\n    -----------------\n \n-   procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n-      Removed : Boolean;\n+   procedure End_Handler (GCC_Exception : GCC_Exception_Access) is\n    begin\n-      Removed := Remove (Get_Current_Excep.all, GCC_Exception);\n-      pragma Assert (Removed);\n+      if GCC_Exception /= null then\n+\n+         --  The exception might have been reraised, in this case the cleanup\n+         --  mustn't be called.\n+\n+         Unwind_DeleteException (GCC_Exception);\n+      end if;\n    end End_Handler;\n \n+   -----------------------------\n+   -- Reraise_GCC_Exception --\n+   -----------------------------\n+\n+   procedure Reraise_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access) is\n+   begin\n+      --  Simply propagate it\n+      Propagate_GCC_Exception (GCC_Exception);\n+   end Reraise_GCC_Exception;\n+\n+   -----------------------------\n+   -- Propagate_GCC_Exception --\n+   -----------------------------\n+\n+   --  Call Unwind_RaiseException to actually throw, taking care of handling\n+   --  the two phase scheme it implements.\n+\n+   procedure Propagate_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access) is\n+   begin\n+      --  Perform a standard raise first. If a regular handler is found, it\n+      --  will be entered after all the intermediate cleanups have run. If\n+      --  there is no regular handler, it will return.\n+\n+      Unwind_RaiseException (GCC_Exception);\n+\n+      --  If we get here we know the exception is not handled, as otherwise\n+      --  Unwind_RaiseException arranges for the handler to be entered. Take\n+      --  the necessary steps to enable the debugger to gain control while the\n+      --  stack is still intact.\n+\n+      Setup_Current_Excep (GCC_Exception);\n+      Notify_Unhandled_Exception;\n+\n+      --  Now, un a forced unwind to trigger cleanups. Control should not\n+      --  resume there, if there are cleanups and in any cases as the\n+      --  unwinding hook calls Unhandled_Exception_Terminate when end of stack\n+      --  is reached.\n+\n+      Unwind_ForcedUnwind (GCC_Exception,\n+                           CleanupUnwind_Handler'Address,\n+                           System.Null_Address);\n+\n+      --  We get here in case of error.\n+      --  The debugger has been notified before the second step above.\n+\n+      Setup_Current_Excep (GCC_Exception);\n+      Unhandled_Exception_Terminate;\n+   end Propagate_GCC_Exception;\n+\n    -------------------------\n    -- Propagate_Exception --\n    -------------------------\n@@ -530,18 +469,6 @@ package body Exception_Propagation is\n       GCC_Exception : GNAT_GCC_Exception_Access;\n \n    begin\n-      pragma Assert (Excep.Private_Data /= System.Null_Address);\n-\n-      --  Retrieve the Private_Data for this occurrence and set the useful\n-      --  flags for the personality routine, which will be called for each\n-      --  frame via Unwind_RaiseException below.\n-\n-      GCC_Exception := To_GNAT_GCC_Exception (Excep.Private_Data);\n-\n-      Clear_Setup_And_Not_Propagated (Excep);\n-\n-      GCC_Exception.Id := Excep.Id;\n-\n       --  Compute the backtrace for this occurrence if the corresponding\n       --  binder option has been set. Call_Chain takes care of the reraise\n       --  case.\n@@ -565,43 +492,28 @@ package body Exception_Propagation is\n \n       Call_Chain (Excep);\n \n-      --  Perform a standard raise first. If a regular handler is found, it\n-      --  will be entered after all the intermediate cleanups have run. If\n-      --  there is no regular handler, it will return.\n+      --  Allocate the GCC exception\n \n-      Unwind_RaiseException (GCC_Exception);\n+      GCC_Exception := new GNAT_GCC_Exception'\n+        (Header    => (Class => GNAT_Exception_Class,\n+                       Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n+                       Private1 => 0,\n+                       Private2 => 0),\n+         Occurrence => Excep.all);\n \n-      --  If we get here we know the exception is not handled, as otherwise\n-      --  Unwind_RaiseException arranges for the handler to be entered. Take\n-      --  the necessary steps to enable the debugger to gain control while the\n-      --  stack is still intact.\n-\n-      Notify_Unhandled_Exception;\n-\n-      --  Now, un a forced unwind to trigger cleanups. Control should not\n-      --  resume there, if there are cleanups and in any cases as the\n-      --  unwinding hook calls Unhandled_Exception_Terminate when end of stack\n-      --  is reached.\n-\n-      Unwind_ForcedUnwind (GCC_Exception,\n-                           CleanupUnwind_Handler'Address,\n-                           System.Null_Address);\n-\n-      --  We get here in case of error.\n-      --  The debugger has been notified before the second step above.\n-\n-      Unhandled_Exception_Terminate;\n+      --  Propagate it.\n+      Propagate_GCC_Exception (To_GCC_Exception (GCC_Exception));\n    end Propagate_Exception;\n \n    -------------\n    -- EID_For --\n    -------------\n \n    function EID_For\n-     (GNAT_Exception : GNAT_GCC_Exception_Access) return Exception_Id\n+     (GNAT_Exception : not null GNAT_GCC_Exception_Access) return Exception_Id\n    is\n    begin\n-      return GNAT_Exception.Id;\n+      return GNAT_Exception.Occurrence.Id;\n    end EID_For;\n \n    ---------------------\n@@ -633,67 +545,4 @@ package body Exception_Propagation is\n       return E.all.Lang;\n    end Language_For;\n \n-   -----------\n-   -- Notes --\n-   -----------\n-\n-   --  The current model implemented for the stack of occurrences is a\n-   --  simplification of previous attempts, which all proved to be flawed or\n-   --  would have needed significant additional circuitry to be made to work\n-   --  correctly.\n-\n-   --  We now represent every propagation by a new entry on the stack, which\n-   --  means that an exception occurrence may appear more than once (e.g. when\n-   --  it is reraised during the course of its own handler).\n-\n-   --  This may seem overcostly compared to the C++ model as implemented in\n-   --  the g++ v3 libstd. This is actually understandable when one considers\n-   --  the extra variations of possible run-time configurations induced by the\n-   --  freedom offered by the Save_Occurrence/Reraise_Occurrence public\n-   --  interface.\n-\n-   --  The basic point is that arranging for an occurrence to always appear at\n-   --  most once on the stack requires a way to determine if a given occurrence\n-   --  is already there, which is not as easy as it might seem.\n-\n-   --  An attempt was made to use the Private_Data pointer for this purpose.\n-   --  It did not work because:\n-\n-   --  1) The Private_Data has to be saved by Save_Occurrence to be usable\n-   --     as a key in case of a later reraise,\n-\n-   --  2) There is no easy way to synchronize End_Handler for an occurrence\n-   --     and the data attached to potential copies, so these copies may end\n-   --     up pointing to stale data. Moreover ...\n-\n-   --  3) The same address may be reused for different occurrences, which\n-   --     defeats the idea of using it as a key.\n-\n-   --  The example below illustrates:\n-\n-   --  Saved_CE : Exception_Occurrence;\n-\n-   --  begin\n-   --    raise Constraint_Error;\n-   --  exception\n-   --    when CE: others =>\n-   --      Save_Occurrence (Saved_CE, CE);      <= Saved_CE.PDA = CE.PDA\n-   --  end;\n-\n-   --                                           <= Saved_CE.PDA is stale (!)\n-\n-   --  begin\n-   --    raise Program_Error;                   <= Saved_CE.PDA = PE.PDA (!!)\n-   --  exception\n-   --    when others =>\n-   --      Reraise_Occurrence (Saved_CE);\n-   --  end;\n-\n-   --  Not releasing the Private_Data via End_Handler could be an option,\n-   --  but making this to work while still avoiding memory leaks is far\n-   --  from trivial.\n-\n-   --  The current scheme has the advantage of being simple, and induces\n-   --  extra costs only in reraise cases which is acceptable.\n-\n end Exception_Propagation;"}, {"sha": "35a53aab696134e67c2d99ac0876b3df0b3699ec", "filename": "gcc/ada/a-synbar.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fa-synbar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fa-synbar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-synbar.adb?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -40,8 +40,11 @@ package body Ada.Synchronous_Barriers is\n       --  The condition \"Wait'Count = Release_Threshold\" opens the barrier when\n       --  the required number of tasks is reached. The condition \"Keep_Open\"\n       --  leaves the barrier open while there are queued tasks. While there are\n-      --  tasks in the queue no new task will be queued, guaranteeing that the\n-      --  barrier will remain open only for those tasks already inside.\n+      --  tasks in the queue no new task will be queued (no new protected\n+      --  action can be started on a protected object while another protected\n+      --  action on the same protected object is underway, RM 9.5.1 (4)),\n+      --  guaranteeing that the barrier will remain open only for those tasks\n+      --  already inside the queue when the barrier was open.\n \n       entry Wait (Notified : out Boolean)\n         when Keep_Open or else Wait'Count = Release_Threshold"}, {"sha": "2f16743ebe9fbebd94a6c1c610b584469db1ed36", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -1665,6 +1665,15 @@ package body Exp_Ch11 is\n       --  does not have a choice parameter specification, then we provide one.\n \n       else\n+\n+         --  Don't expand if back end exception handling active\n+\n+         if VM_Target = No_VM\n+           and then Exception_Mechanism = Back_End_Exceptions\n+         then\n+            return;\n+         end if;\n+\n          --  Find innermost enclosing exception handler (there must be one,\n          --  since the semantics has already verified that this raise statement\n          --  is valid, and a raise with no arguments is only permitted in the"}, {"sha": "faf3e839a27499ef79adc8d29085dfae21c9c2ea", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -5074,23 +5074,23 @@ Syntax:\n @smallexample @c ada\n pragma Test_Case (\n    [Name     =>] static_string_Expression\n-  ,[Mode     =>] (Normal | Robustness)\n+  ,[Mode     =>] (Nominal | Robustness)\n  [, Requires =>  Boolean_Expression]\n  [, Ensures  =>  Boolean_Expression]);\n @end smallexample\n \n @noindent\n The @code{Test_Case} pragma allows defining fine-grain specifications\n-for use by testing and verification tools. The compiler only checks its\n+for use by testing and verification tools. The compiler checks its\n validity but the presence of pragma @code{Test_Case} does not lead to\n any modification of the code generated by the compiler.\n \n @code{Test_Case} pragmas may only appear immediately following the\n-(separate) declaration of a subprogram. Only other pragmas may intervene\n-(that is appear between the subprogram declaration and its\n-postconditions).\n+(separate) declaration of a subprogram in a package declaration, inside\n+a package spec unit. Only other pragmas may intervene (that is appear\n+between the subprogram declaration and a test case).\n \n-The compiler checks that boolean expression given in @code{Requires} and\n+The compiler checks that boolean expressions given in @code{Requires} and\n @code{Ensures} are valid, where the rules for @code{Requires} are the\n same as the rule for an expression in @code{Precondition} and the rules\n for @code{Ensures} are the same as the rule for an expression in\n@@ -5103,7 +5103,7 @@ package Math_Functions is\n    ...\n    function Sqrt (Arg : Float) return Float;\n    pragma Test_Case (Name     => \"Test 1\",\n-                     Mode     => Normal,\n+                     Mode     => Nominal,\n                      Requires => Arg < 100,\n                      Ensures  => Sqrt'Result < 10);\n    ...\n@@ -5113,10 +5113,10 @@ end Math_Functions;\n @noindent\n The meaning of a test case is that, if the associated subprogram is\n executed in a context where @code{Requires} holds, then @code{Ensures}\n-should hold when the subprogram returns. Mode @code{Normal} indicates\n-that the input context should satisfy the normal precondition of the\n+should hold when the subprogram returns. Mode @code{Nominal} indicates\n+that the input context should satisfy the precondition of the\n subprogram, and the output context should then satisfy its\n-postcondition. More @code{Robustness} indicates that the normal pre- and\n+postcondition. More @code{Robustness} indicates that the pre- and\n postcondition of the subprogram should be ignored for this test case.\n \n @node Pragma Thread_Local_Storage"}, {"sha": "6dff0dee205fcb84e1b6bfb2657c1e9c718ac713", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -101,13 +101,18 @@ __gnat_Unwind_RaiseException (_Unwind_Exception *);\n _Unwind_Reason_Code\n __gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n \n+extern void __gnat_setup_current_excep (_Unwind_Exception *);\n \n #ifdef IN_RTS   /* For eh personality routine */\n \n #include \"dwarf2.h\"\n #include \"unwind-dw2-fde.h\"\n #include \"unwind-pe.h\"\n \n+/* The known and handled exception classes.  */\n+\n+#define CXX_EXCEPTION_CLASS 0x474e5543432b2b00ULL\n+#define GNAT_EXCEPTION_CLASS 0x474e552d41646100ULL\n \n /* --------------------------------------------------------------\n    -- The DB stuff below is there for debugging purposes only. --\n@@ -853,39 +858,51 @@ extern Exception_Id EID_For (_GNAT_Exception * e);\n static int\n is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n {\n-  /* Pointer to the GNAT exception data corresponding to the propagated\n-     occurrence.  */\n-  _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n-\n-  /* Base matching rules: An exception data (id) matches itself, \"when\n-     all_others\" matches anything and \"when others\" matches anything unless\n-     explicitly stated otherwise in the propagated occurrence.  */\n-\n-  bool is_handled =\n-    choice == E\n-    || choice == GNAT_ALL_OTHERS\n-    || (choice == GNAT_OTHERS && Is_Handled_By_Others (E));\n-\n-  /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n-     may have different exception data pointers that should match for the\n-     same condition code, if both an export and an import have been\n-     registered.  The import code for both the choice and the propagated\n-     occurrence are expected to have been masked off regarding severity\n-     bits already (at registration time for the former and from within the\n-     low level exception vector for the latter).  */\n+  if (propagated_exception->common.exception_class == GNAT_EXCEPTION_CLASS)\n+    {\n+      /* Pointer to the GNAT exception data corresponding to the propagated\n+         occurrence.  */\n+      _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n+\n+      /* Base matching rules: An exception data (id) matches itself, \"when\n+         all_others\" matches anything and \"when others\" matches anything\n+         unless explicitly stated otherwise in the propagated occurrence.  */\n+\n+      bool is_handled =\n+        choice == E\n+        || choice == GNAT_ALL_OTHERS\n+        || (choice == GNAT_OTHERS && Is_Handled_By_Others (E));\n+\n+      /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n+         may have different exception data pointers that should match for the\n+         same condition code, if both an export and an import have been\n+         registered.  The import code for both the choice and the propagated\n+         occurrence are expected to have been masked off regarding severity\n+         bits already (at registration time for the former and from within the\n+         low level exception vector for the latter).  */\n #ifdef VMS\n-  #define Non_Ada_Error system__aux_dec__non_ada_error\n-  extern struct Exception_Data Non_Ada_Error;\n-\n-  is_handled |=\n-    (Language_For (E) == 'V'\n-     && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n-     && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n-\t  && Import_Code_For (choice) == Import_Code_For (E))\n-\t || choice == (_Unwind_Ptr)&Non_Ada_Error));\n+#     define Non_Ada_Error system__aux_dec__non_ada_error\n+      extern struct Exception_Data Non_Ada_Error;\n+\n+      is_handled |=\n+        (Language_For (E) == 'V'\n+         && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n+         && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n+              && Import_Code_For (choice) == Import_Code_For (E))\n+             || choice == (_Unwind_Ptr)&Non_Ada_Error));\n #endif\n \n-  return is_handled;\n+      return is_handled;\n+    }\n+  else\n+    {\n+#     define Foreign_Exception system__exceptions__foreign_exception;\n+      extern struct Exception_Data Foreign_Exception;\n+\n+      return choice == GNAT_ALL_OTHERS\n+        || choice == GNAT_OTHERS\n+        || choice == (_Unwind_Ptr)&Foreign_Exception;\n+    }\n }\n \n /* Fill out the ACTION to be taken from propagating UW_EXCEPTION up to\n@@ -1079,17 +1096,14 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n      Condition Handling Facility.  */\n   int uw_version = (int) version_arg;\n   _Unwind_Action uw_phases = (_Unwind_Action) phases_arg;\n-\n-  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n-\n   region_descriptor region;\n   action_descriptor action;\n \n   /* Check that we're called from the ABI context we expect, with a major\n      possible variation on VMS for IA64.  */\n   if (uw_version != 1)\n     {\n-      #if defined (VMS) && defined (__IA64)\n+#if defined (VMS) && defined (__IA64)\n \n       /* Assume we're called with sigargs/mechargs arguments if really\n \t unexpected bits are set in our first two formals.  Redirect to the\n@@ -1103,7 +1117,7 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n       if ((unsigned int)uw_version & version_unexpected_bits_mask\n \t  && (unsigned int)uw_phases & phases_unexpected_bits_mask)\n \treturn __gnat_handle_vms_condition (version_arg, phases_arg);\n-      #endif\n+#endif\n \n       return _URC_FATAL_PHASE1_ERROR;\n     }\n@@ -1160,6 +1174,9 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n   setup_to_install\n     (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n \n+  /* Write current exception, so that it can be retrieved from Ada.  */\n+  __gnat_setup_current_excep (uw_exception);\n+\n   return _URC_INSTALL_CONTEXT;\n }\n "}, {"sha": "0d21bc33d7198b01d3588134d5592dca343ee99a", "filename": "gcc/ada/s-except.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fs-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fs-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-except.ads?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -81,4 +81,9 @@ package System.Exceptions is\n private\n    ZCX_By_Default : constant Boolean := System.ZCX_By_Default;\n \n+   Foreign_Exception : exception;\n+   pragma Unreferenced (Foreign_Exception);\n+   --  This hidden exception is used to represent non-Ada exception to\n+   --  Ada handlers. It is in fact referenced by its linking name.\n+\n end System.Exceptions;"}, {"sha": "1f076755db5599da8585cc5a3ae6386baf643d60", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -1365,6 +1365,12 @@ package body Sem_Ch13 is\n                begin\n                   Args := New_List;\n \n+                  if Nkind (Parent (N)) = N_Compilation_Unit then\n+                     Error_Msg_N\n+                       (\"incorrect placement of aspect `Test_Case`\", E);\n+                     goto Continue;\n+                  end if;\n+\n                   if Nkind (Expr) /= N_Aggregate then\n                      Error_Msg_NE\n                        (\"wrong syntax for aspect `Test_Case` for &\", Id, E);"}, {"sha": "7f51294e2a20b08493707b2cdaca638ef33ecc7d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -500,24 +500,13 @@ package body Sem_Prag is\n \n       procedure Check_Test_Case;\n       --  Called to process a test-case pragma. The treatment is similar to the\n-      --  one for pre- and postcondition in Check_Precondition_Postcondition.\n-      --  There are three cases:\n-      --\n-      --    The pragma appears after a subprogram spec\n-      --\n-      --      The first step is to analyze the pragma, but this is skipped if\n-      --      the subprogram spec appears within a package specification\n-      --      (because this is the case where we delay analysis till the end of\n-      --      the spec). Then (whether or not it was analyzed), the pragma is\n-      --      chained to the subprogram in question (using Spec_TC_List and\n-      --      Next_Pragma).\n-      --\n-      --    The pragma appears at the start of subprogram body declarations\n-      --\n-      --      In this case an immediate return to the caller is made, and the\n-      --      pragma is NOT analyzed.\n-      --\n-      --    In all other cases, an error message for bad placement is given\n+      --  one for pre- and postcondition in Check_Precondition_Postcondition,\n+      --  except the placement rules for the test-case pragma are stricter.\n+      --  This pragma may only occur after a subprogram spec declared directly\n+      --  in a package spec unit. In this case, the pragma is chained to the\n+      --  subprogram in question (using Spec_TC_List and Next_Pragma) and\n+      --  analysis of the pragma is delayed till the end of the spec. In\n+      --  all other cases, an error message for bad placement is given.\n \n       procedure Check_Valid_Configuration_Pragma;\n       --  Legality checks for placement of a configuration pragma\n@@ -1972,9 +1961,9 @@ package body Sem_Prag is\n          PO : Node_Id;\n \n          procedure Chain_TC (PO : Node_Id);\n-         --  If PO is an entry or a [generic] subprogram declaration node, then\n-         --  the test-case applies to this subprogram and the processing for\n-         --  the pragma is completed. Otherwise the pragma is misplaced.\n+         --  If PO is a [generic] subprogram declaration node, then the\n+         --  test-case applies to this subprogram and the processing for the\n+         --  pragma is completed. Otherwise the pragma is misplaced.\n \n          --------------\n          -- Chain_TC --\n@@ -1993,20 +1982,22 @@ package body Sem_Prag is\n                     (\"pragma% cannot be applied to abstract subprogram\");\n                end if;\n \n+            elsif Nkind (PO) = N_Entry_Declaration then\n+               if From_Aspect_Specification (N) then\n+                  Error_Pragma (\"aspect% cannot be applied to entry\");\n+               else\n+                  Error_Pragma (\"pragma% cannot be applied to entry\");\n+               end if;\n+\n             elsif not Nkind_In (PO, N_Subprogram_Declaration,\n-                                    N_Generic_Subprogram_Declaration,\n-                                    N_Entry_Declaration)\n+                                    N_Generic_Subprogram_Declaration)\n             then\n                Pragma_Misplaced;\n             end if;\n \n-            --  Here if we have [generic] subprogram or entry declaration\n+            --  Here if we have [generic] subprogram declaration\n \n-            if Nkind (PO) = N_Entry_Declaration then\n-               S := Defining_Entity (PO);\n-            else\n-               S := Defining_Unit_Name (Specification (PO));\n-            end if;\n+            S := Defining_Unit_Name (Specification (PO));\n \n             --  Note: we do not analyze the pragma at this point. Instead we\n             --  delay this analysis until the end of the declarative part in\n@@ -2054,6 +2045,16 @@ package body Sem_Prag is\n             Pragma_Misplaced;\n          end if;\n \n+         --  Test cases should only appear in package spec unit\n+\n+         if Get_Source_Unit (N) = No_Unit\n+           or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n+                                 N_Package_Declaration,\n+                                 N_Generic_Package_Declaration)\n+         then\n+            Pragma_Misplaced;\n+         end if;\n+\n          --  Search prior declarations\n \n          P := N;\n@@ -2082,22 +2083,25 @@ package body Sem_Prag is\n             elsif not Comes_From_Source (PO) then\n                null;\n \n-            --  Only remaining possibility is subprogram declaration\n+            --  Only remaining possibility is subprogram declaration. First\n+            --  check that it is declared directly in a package declaration.\n+            --  This may be either the package declaration for the current unit\n+            --  being defined or a local package declaration.\n+\n+            elsif not Present (Parent (Parent (PO)))\n+              or else not Present (Parent (Parent (Parent (PO))))\n+              or else not Nkind_In (Parent (Parent (PO)),\n+                                    N_Package_Declaration,\n+                                    N_Generic_Package_Declaration)\n+            then\n+               Pragma_Misplaced;\n \n             else\n                Chain_TC (PO);\n                return;\n             end if;\n          end loop;\n \n-         --  If we fall through loop, pragma is at start of list, so see if it\n-         --  is in the pragmas after a library level subprogram.\n-\n-         if Nkind (Parent (N)) = N_Compilation_Unit_Aux then\n-            Chain_TC (Unit (Parent (Parent (N))));\n-            return;\n-         end if;\n-\n          --  If we fall through, pragma was misplaced\n \n          Pragma_Misplaced;\n@@ -13301,7 +13305,7 @@ package body Sem_Prag is\n          --                  [, Requires =>  Boolean_EXPRESSION]\n          --                  [, Ensures  =>  Boolean_EXPRESSION]);\n \n-         --  MODE_TYPE ::= Normal | Robustness\n+         --  MODE_TYPE ::= Nominal | Robustness\n \n          when Pragma_Test_Case => Test_Case : declare\n          begin\n@@ -13314,7 +13318,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Name);\n             Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n             Check_Optional_Identifier (Arg2, Name_Mode);\n-            Check_Arg_Is_One_Of (Arg2, Name_Normal, Name_Robustness);\n+            Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n \n             if Arg_Count = 4 then\n                Check_Identifier (Arg3, Name_Requires);"}, {"sha": "fbe0584f1402d09f4eadc871cc9eb4124e56374c", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd7b6ca81d3f3b399bf55e201fc6f78771a13/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "patch": "@@ -661,7 +661,7 @@ package Snames is\n    Name_No_Requeue_Statements          : constant Name_Id := N + $;\n    Name_No_Task_Attributes             : constant Name_Id := N + $;\n    Name_No_Task_Attributes_Package     : constant Name_Id := N + $;\n-   Name_Normal                         : constant Name_Id := N + $;\n+   Name_Nominal                        : constant Name_Id := N + $;\n    Name_On                             : constant Name_Id := N + $;\n    Name_Policy                         : constant Name_Id := N + $;\n    Name_Parameter_Types                : constant Name_Id := N + $;"}]}