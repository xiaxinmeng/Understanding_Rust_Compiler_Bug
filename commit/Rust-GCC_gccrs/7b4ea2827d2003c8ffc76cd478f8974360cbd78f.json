{"sha": "7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I0ZWEyODI3ZDIwMDNjOGZmYzc2Y2Q0NzhmODk3NDM2MGNiZDc4Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-12-04T10:13:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-12-07T07:15:15Z"}, "message": "tree-optimization/98137 - enhance split_constant_offset range handling\n\nsplit_constant_offset currently gives up looking at ranges when\ndealing with possibly wrapping operations for looking through\nconversions when the downstream analysis does not yield a SSA name.\nThat's overly conservative and we have a nice helper that can\ndeal with arbitrary expresssions.  Use that.  This helps data\nreference group analysis so the testcase is fully SLP vectorized,\nmaking use of the whole-function \"BB\" vectorization capabilities\nwe now have.\n\n2020-12-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98137\n\t* tree-data-ref.c (split_constant_offset_1): Use\n\tdetermine_value_range instead of get_range_info to handle\n\tarbitrary expressions.\n\n\t* gcc.dg/vect/bb-slp-pr98137.c: New testcase.", "tree": {"sha": "31ea9a8ce51a8fef5e4214c627c118778a5a1546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31ea9a8ce51a8fef5e4214c627c118778a5a1546"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4ea2827d2003c8ffc76cd478f8974360cbd78f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e49145550fe1284dc56e8e02ba1720c4f737a74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e49145550fe1284dc56e8e02ba1720c4f737a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e49145550fe1284dc56e8e02ba1720c4f737a74"}], "stats": {"total": 51, "additions": 41, "deletions": 10}, "files": [{"sha": "ecf7df21e6a7fc1ed13309dc31eaacdf21d55d1e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr98137.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4ea2827d2003c8ffc76cd478f8974360cbd78f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98137.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4ea2827d2003c8ffc76cd478f8974360cbd78f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98137.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr98137.c?ref=7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+/* { dg-require-effective-target vect_double } */\n+\n+void\n+gemm (const double* __restrict__ A, const double* __restrict__ B,\n+      double* __restrict__ C)\n+{\n+  unsigned int l_m = 0;\n+  unsigned int l_n = 0;\n+  unsigned int l_k = 0;\n+\n+  for ( l_n = 0; l_n < 9; l_n++ ) {\n+    /* Use -O3 so this loop is unrolled completely early.  */\n+    for ( l_m = 0; l_m < 10; l_m++ ) { C[(l_n*10)+l_m] = 0.0; }\n+    for ( l_k = 0; l_k < 17; l_k++ ) {\n+      /* Use -O3 so this loop is unrolled completely early.  */\n+      for ( l_m = 0; l_m < 10; l_m++ ) {\n+        C[(l_n*10)+l_m] += A[(l_k*20)+l_m] * B[(l_n*20)+l_k];\n+      }\n+    }\n+  }\n+}\n+\n+/* Exact scanning is difficult but we expect all loads and stores\n+   and computations to be vectorized.  */\n+/* { dg-final { scan-tree-dump \"optimized: basic block\" \"slp1\" } } */"}, {"sha": "e8308ce8250625ee467aac6aa864899b1adc196b", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4ea2827d2003c8ffc76cd478f8974360cbd78f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4ea2827d2003c8ffc76cd478f8974360cbd78f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=7b4ea2827d2003c8ffc76cd478f8974360cbd78f", "patch": "@@ -763,18 +763,22 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\ttree tmp_var, tmp_off;\n \t\tsplit_constant_offset (op0, &tmp_var, &tmp_off, cache, limit);\n \n-\t\t/* See whether we have an SSA_NAME whose range is known\n-\t\t   to be [A, B].  */\n-\t\tif (TREE_CODE (tmp_var) != SSA_NAME)\n-\t\t  return false;\n+\t\t/* See whether we have an known range [A, B] for tmp_var.  */\n \t\twide_int var_min, var_max;\n-\t\tvalue_range_kind vr_type = get_range_info (tmp_var, &var_min,\n-\t\t\t\t\t\t\t   &var_max);\n-\t\twide_int var_nonzero = get_nonzero_bits (tmp_var);\n \t\tsignop sgn = TYPE_SIGN (itype);\n-\t\tif (intersect_range_with_nonzero_bits (vr_type, &var_min,\n-\t\t\t\t\t\t       &var_max, var_nonzero,\n-\t\t\t\t\t\t       sgn) != VR_RANGE)\n+\t\tif (TREE_CODE (tmp_var) == SSA_NAME)\n+\t\t  {\n+\t\t    value_range_kind vr_type\n+\t\t      = get_range_info (tmp_var, &var_min, &var_max);\n+\t\t    wide_int var_nonzero = get_nonzero_bits (tmp_var);\n+\t\t    if (intersect_range_with_nonzero_bits (vr_type, &var_min,\n+\t\t\t\t\t\t\t   &var_max,\n+\t\t\t\t\t\t\t   var_nonzero,\n+\t\t\t\t\t\t\t   sgn) != VR_RANGE)\n+\t\t      return false;\n+\t\t  }\n+\t\telse if (determine_value_range (tmp_var, &var_min, &var_max)\n+\t\t\t != VR_RANGE)\n \t\t  return false;\n \n \t\t/* See whether the range of OP0 (i.e. TMP_VAR + TMP_OFF)"}]}