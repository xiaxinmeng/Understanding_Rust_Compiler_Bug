{"sha": "c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY3NDE1NzJjZmQ0YjJhZDljMjYyZWMwMGUxNTJjYmYxZWE4ZWI1MQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-27T14:48:34Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-27T14:48:34Z"}, "message": "re PR tree-optimization/26854 (Inordinate compile times on large routines)\n\n2009-06-07  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/26854\n        * timevar.def: Remove TV_DF_RU, add TV_DF_MD.\n        * df-problems.c (df_rd_add_problem): Fix comment.\n        (df_md_set_bb_info, df_md_free_bb_info, df_md_alloc,\n        df_md_simulate_artificial_defs_at_top,\n        df_md_simulate_one_insn, df_md_bb_local_compute_process_def,\n        df_md_bb_local_compute, df_md_local_compute, df_md_reset,\n        df_md_transfer_function, df_md_init, df_md_confluence_0,\n        df_md_confluence_n, df_md_free, df_md_top_dump, df_md_bottom_dump,\n        problem_MD, df_md_add_problem): New.\n        * df.h (DF_MD, DF_MD_BB_INFO, struct df_md_bb_info, df_md,\n        df_md_get_bb_info): New.\n        DF_LAST_PROBLEM_PLUS1): Adjust.\n\n        * Makefile.in (fwprop.o): Include domwalk.h.\n        * fwprop.c: Include domwalk.h.\n        (reg_defs, reg_defs_stack): New.\n        (bitmap_only_bit_between): Remove.\n        (process_defs): New.\n        (process_uses): Use reg_defs and local_md instead of\n        bitmap_only_bit_between and local_rd.\n        (single_def_use_enter_block): New, from build_single_def_use_links.\n        (single_def_use_leave_block): New.\n        (build_single_def_use_links): Remove code moved to\n        single_def_use_enter_block, invoke domwalk.\n        (use_killed_between): Adjust comment.\n\nFrom-SVN: r149010", "tree": {"sha": "ccbd0084107a8508be366e60ac20d8c9a438201b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccbd0084107a8508be366e60ac20d8c9a438201b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ff23740a3d7fa1e41f7e58891c711b7ef25a90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ff23740a3d7fa1e41f7e58891c711b7ef25a90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ff23740a3d7fa1e41f7e58891c711b7ef25a90b"}], "stats": {"total": 727, "additions": 658, "deletions": 69}, "files": [{"sha": "4134a2cf66e485ae468ec9f00362b2e3f5639f7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -1,3 +1,32 @@\n+2009-06-07  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/26854\n+        * timevar.def: Remove TV_DF_RU, add TV_DF_MD.\n+        * df-problems.c (df_rd_add_problem): Fix comment.\n+        (df_md_set_bb_info, df_md_free_bb_info, df_md_alloc,\n+        df_md_simulate_artificial_defs_at_top,\n+        df_md_simulate_one_insn, df_md_bb_local_compute_process_def,\n+        df_md_bb_local_compute, df_md_local_compute, df_md_reset,\n+        df_md_transfer_function, df_md_init, df_md_confluence_0,\n+        df_md_confluence_n, df_md_free, df_md_top_dump, df_md_bottom_dump,\n+        problem_MD, df_md_add_problem): New.\n+        * df.h (DF_MD, DF_MD_BB_INFO, struct df_md_bb_info, df_md,\n+        df_md_get_bb_info): New.\n+        DF_LAST_PROBLEM_PLUS1): Adjust.\n+\n+        * Makefile.in (fwprop.o): Include domwalk.h.\n+        * fwprop.c: Include domwalk.h.\n+        (reg_defs, reg_defs_stack): New.\n+        (bitmap_only_bit_between): Remove.\n+        (process_defs): New.\n+        (process_uses): Use reg_defs and local_md instead of\n+        bitmap_only_bit_between and local_rd.\n+        (single_def_use_enter_block): New, from build_single_def_use_links.\n+        (single_def_use_leave_block): New.\n+        (build_single_def_use_links): Remove code moved to\n+        single_def_use_enter_block, invoke domwalk.\n+        (use_killed_between): Adjust comment.\n+\n 2009-06-27  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* bitmap.h (bitmap_ior_and_into): New."}, {"sha": "d8bbc681146d3b5a3de89d0e4e0d929fb8f6f948", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -2761,7 +2761,7 @@ dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TOPLEV_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\\n    output.h $(DF_H) alloc-pool.h $(TIMEVAR_H) $(TREE_PASS_H) $(TARGET_H) \\\n-   $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H)\n+   $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) domwalk.h\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \\\n    $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H)"}, {"sha": "5e56025ed8b9d663e7e67904a799669efbac20c6", "filename": "gcc/df-problems.c", "status": "modified", "additions": 447, "deletions": 3, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -726,9 +726,8 @@ static struct df_problem problem_RD =\n \n \n \n-/* Create a new DATAFLOW instance and add it to an existing instance\n-   of DF.  The returned structure is what is used to get at the\n-   solution.  */\n+/* Create a new RD instance and add it to the existing instance\n+   of DF.  */\n \n void\n df_rd_add_problem (void)\n@@ -3952,3 +3951,448 @@ df_simulate_finalize_forwards (basic_block bb, bitmap live)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n }\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   MULTIPLE DEFINITIONS\n+\n+   Find the locations in the function reached by multiple definition sites\n+   for a pseudo.  In and out bitvectors are built for each basic\n+   block.\n+\n+   The gen and kill sets for the problem are obvious.  Together they\n+   include all defined registers in a basic block; the gen set includes\n+   registers where a partial or conditional or may-clobber definition is\n+   last in the BB, while the kill set includes registers with a complete\n+   definition coming last.  However, the computation of the dataflow\n+   itself is interesting.\n+\n+   The idea behind it comes from SSA form's iterated dominance frontier\n+   criterion for inserting PHI functions.  Just like in that case, we can use\n+   the dominance frontier to find places where multiple definitions meet;\n+   a register X defined in a basic block BB1 has multiple definitions in\n+   basic blocks in BB1's dominance frontier.\n+\n+   So, the in-set of a basic block BB2 is not just the union of the\n+   out-sets of BB2's predecessors, but includes some more bits that come\n+   from the basic blocks of whose dominance frontier BB2 is part (BB1 in\n+   the previous paragraph).  I called this set the init-set of BB2.\n+\n+      (Note: I actually use the kill-set only to build the init-set.\n+      gen bits are anyway propagated from BB1 to BB2 by dataflow).\n+\n+    For example, if you have\n+\n+       BB1 : r10 = 0\n+             r11 = 0\n+             if <...> goto BB2 else goto BB3;\n+\n+       BB2 : r10 = 1\n+             r12 = 1\n+             goto BB3;\n+\n+       BB3 :\n+\n+    you have BB3 in BB2's dominance frontier but not in BB1's, so that the\n+    init-set of BB3 includes r10 and r12, but not r11.  Note that we do\n+    not need to iterate the dominance frontier, because we do not insert\n+    anything like PHI functions there!  Instead, dataflow will take care of\n+    propagating the information to BB3's successors. \n+   ---------------------------------------------------------------------------*/\n+\n+/* Set basic block info.  */\n+\n+static void\n+df_md_set_bb_info (unsigned int index, \n+                   struct df_md_bb_info *bb_info)\n+{\n+  gcc_assert (df_md);\n+  gcc_assert (index < df_md->block_info_size);\n+  df_md->block_info[index] = bb_info;\n+}\n+\n+\n+static void\n+df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+                    void *vbb_info)\n+{\n+  struct df_md_bb_info *bb_info = (struct df_md_bb_info *) vbb_info;\n+  if (bb_info)\n+    {\n+      BITMAP_FREE (bb_info->kill);\n+      BITMAP_FREE (bb_info->gen);\n+      BITMAP_FREE (bb_info->init);\n+      BITMAP_FREE (bb_info->in);\n+      BITMAP_FREE (bb_info->out);\n+      pool_free (df_md->block_pool, bb_info);\n+    }\n+}\n+\n+\n+/* Allocate or reset bitmaps for DF_MD. The solution bits are\n+   not touched unless the block is new.  */\n+\n+static void \n+df_md_alloc (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  if (!df_md->block_pool)\n+    df_md->block_pool = create_alloc_pool (\"df_md_block pool\", \n+                                           sizeof (struct df_md_bb_info), 50);\n+\n+  df_grow_bb_info (df_md);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      if (bb_info)\n+        { \n+          bitmap_clear (bb_info->init);\n+          bitmap_clear (bb_info->gen);\n+          bitmap_clear (bb_info->kill);\n+          bitmap_clear (bb_info->in);\n+          bitmap_clear (bb_info->out);\n+        }\n+      else\n+        { \n+          bb_info = (struct df_md_bb_info *) pool_alloc (df_md->block_pool);\n+          df_md_set_bb_info (bb_index, bb_info);\n+          bb_info->init = BITMAP_ALLOC (NULL);\n+          bb_info->gen = BITMAP_ALLOC (NULL);\n+          bb_info->kill = BITMAP_ALLOC (NULL);\n+          bb_info->in = BITMAP_ALLOC (NULL);\n+          bb_info->out = BITMAP_ALLOC (NULL);\n+        }\n+    }\n+\n+  df_md->optional_p = true;\n+}\n+\n+/* Add the effect of the top artificial defs of BB to the multiple definitions\n+   bitmap LOCAL_MD.  */\n+\n+void\n+df_md_simulate_artificial_defs_at_top (basic_block bb, bitmap local_md)\n+{\n+  int bb_index = bb->index;\n+  df_ref *def_rec;\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  if (DF_REF_FLAGS (def)\n+\t      & (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))\n+\t    bitmap_set_bit (local_md, dregno);\n+\t  else\n+\t    bitmap_clear_bit (local_md, dregno);\n+\t}\n+    }\n+}\n+\n+\n+/* Add the effect of the defs of INSN to the reaching definitions bitmap\n+   LOCAL_MD.  */\n+\n+void\n+df_md_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n+                        bitmap local_md)\n+{\n+  unsigned uid = INSN_UID (insn);\n+  df_ref *def_rec;\n+\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      unsigned int dregno = DF_REF_REGNO (def);\n+      if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n+          || (dregno >= FIRST_PSEUDO_REGISTER))\n+        {\n+          if (DF_REF_FLAGS (def)\n+\t      & (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))\n+           bitmap_set_bit (local_md, DF_REF_ID (def));\n+         else\n+           bitmap_clear_bit (local_md, DF_REF_ID (def));\n+        }\n+    }\n+}\n+\n+static void\n+df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info, \n+                                    df_ref *def_rec,\n+                                    int top_flag)\n+{\n+  df_ref def;\n+  bitmap_clear (seen_in_insn);\n+\n+  while ((def = *def_rec++) != NULL)\n+    {\n+      unsigned int dregno = DF_REF_REGNO (def);\n+      if (((!(df->changeable_flags & DF_NO_HARD_REGS))\n+\t    || (dregno >= FIRST_PSEUDO_REGISTER))\n+\t  && top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+\t{\n+          if (!bitmap_bit_p (seen_in_insn, dregno))\n+\t    {\n+\t      if (DF_REF_FLAGS (def)\n+\t          & (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))\n+\t        {\n+\t          bitmap_set_bit (bb_info->gen, dregno);\n+\t          bitmap_clear_bit (bb_info->kill, dregno);\n+\t        }\n+\t      else\n+\t        {\n+\t\t  /* When we find a clobber and a regular def,\n+\t\t     make sure the regular def wins.  */\n+\t          bitmap_set_bit (seen_in_insn, dregno);\n+\t          bitmap_set_bit (bb_info->kill, dregno);\n+\t          bitmap_clear_bit (bb_info->gen, dregno);\n+\t        }\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Compute local multiple def info for basic block BB.  */\n+\n+static void\n+df_md_bb_local_compute (unsigned int bb_index)\n+{\n+  basic_block bb = BASIC_BLOCK (bb_index);\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  rtx insn;\n+\n+  /* Artificials are only hard regs.  */\n+  if (!(df->changeable_flags & DF_NO_HARD_REGS))\n+    df_md_bb_local_compute_process_def (bb_info, \n+                                        df_get_artificial_defs (bb_index),\n+                                        DF_REF_AT_TOP);\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      if (!INSN_P (insn))\n+        continue;\n+\n+      df_md_bb_local_compute_process_def (bb_info, DF_INSN_UID_DEFS (uid), 0);\n+    }\n+\n+  if (!(df->changeable_flags & DF_NO_HARD_REGS))\n+    df_md_bb_local_compute_process_def (bb_info, \n+                                        df_get_artificial_defs (bb_index),\n+                                        0);\n+}\n+\n+/* Compute local reaching def info for each basic block within BLOCKS.  */\n+\n+static void\n+df_md_local_compute (bitmap all_blocks)\n+{\n+  unsigned int bb_index, df_bb_index;\n+  bitmap_iterator bi1, bi2;\n+  basic_block bb;\n+  bitmap *frontiers;\n+\n+  df_set_seen ();\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi1)\n+    {\n+      df_md_bb_local_compute (bb_index);\n+    }\n+  \n+  df_unset_seen ();\n+\n+  frontiers = XNEWVEC (bitmap, last_basic_block);\n+  FOR_ALL_BB (bb)\n+    frontiers[bb->index] = BITMAP_ALLOC (NULL);\n+\n+  compute_dominance_frontiers (frontiers);\n+\n+  /* Add each basic block's kills to the nodes in the frontier of the BB.  */\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi1)\n+    {\n+      bitmap kill = df_md_get_bb_info (bb_index)->kill;\n+      EXECUTE_IF_SET_IN_BITMAP (frontiers[bb_index], 0, df_bb_index, bi2)\n+\t{\n+\t  if (bitmap_bit_p (all_blocks, df_bb_index))\n+\t    bitmap_ior_into (df_md_get_bb_info (df_bb_index)->init, kill);\n+\t}\n+    }\n+\n+  FOR_ALL_BB (bb)\n+    BITMAP_FREE (frontiers[bb->index]);\n+  free (frontiers);\n+}\n+\n+\n+/* Reset the global solution for recalculation.  */\n+\n+static void \n+df_md_reset (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      gcc_assert (bb_info);\n+      bitmap_clear (bb_info->in);\n+      bitmap_clear (bb_info->out);\n+    }\n+}\n+\n+static bool\n+df_md_transfer_function (int bb_index)\n+{\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  bitmap in = bb_info->in;\n+  bitmap out = bb_info->out;\n+  bitmap gen = bb_info->gen;\n+  bitmap kill = bb_info->kill;\n+\n+  return bitmap_ior_and_compl (out, gen, in, kill);\n+}\n+\n+/* Initialize the solution bit vectors for problem.  */\n+\n+static void \n+df_md_init (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      \n+      bitmap_copy (bb_info->in, bb_info->init);\n+      df_md_transfer_function (bb_index);\n+    }\n+}\n+\n+static void\n+df_md_confluence_0 (basic_block bb)\n+{\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  bitmap_copy (bb_info->in, bb_info->init);\n+} \n+\n+/* In of target gets or of out of source.  */\n+\n+static void\n+df_md_confluence_n (edge e)\n+{\n+  bitmap op1 = df_md_get_bb_info (e->dest->index)->in;\n+  bitmap op2 = df_md_get_bb_info (e->src->index)->out;\n+\n+  if (e->flags & EDGE_FAKE) \n+    return;\n+\n+  if (e->flags & EDGE_EH)\n+    bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n+  else\n+    bitmap_ior_into (op1, op2);\n+}\n+\n+/* Free all storage associated with the problem.  */\n+\n+static void\n+df_md_free (void)\n+{\n+  unsigned int i;\n+  for (i = 0; i < df_md->block_info_size; i++)\n+    {\n+      struct df_md_bb_info *bb_info = df_md_get_bb_info (i);\n+      if (bb_info)\n+\t{\n+\t  BITMAP_FREE (bb_info->kill);\n+\t  BITMAP_FREE (bb_info->gen);\n+\t  BITMAP_FREE (bb_info->init);\n+\t  BITMAP_FREE (bb_info->in);\n+\t  BITMAP_FREE (bb_info->out);\n+\t}\n+    }\n+\n+  free_alloc_pool (df_md->block_pool);\n+\n+  df_md->block_info_size = 0;\n+  free (df_md->block_info);\n+  free (df_md);\n+}\n+\n+\n+/* Debugging info at top of bb.  */\n+\n+static void\n+df_md_top_dump (basic_block bb, FILE *file)\n+{\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  if (!bb_info || !bb_info->in)\n+    return;\n+      \n+  fprintf (file, \";; md  in  \\t\");\n+  df_print_regset (file, bb_info->in);\n+  fprintf (file, \";; md  init  \\t\");\n+  df_print_regset (file, bb_info->init);\n+  fprintf (file, \";; md  gen \\t\");\n+  df_print_regset (file, bb_info->gen);\n+  fprintf (file, \";; md  kill \\t\");\n+  df_print_regset (file, bb_info->kill);\n+}\n+\n+/* Debugging info at bottom of bb.  */\n+\n+static void\n+df_md_bottom_dump (basic_block bb, FILE *file)\n+{\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  if (!bb_info || !bb_info->out)\n+    return;\n+  \n+  fprintf (file, \";; md  out \\t\");\n+  df_print_regset (file, bb_info->out);\n+}  \n+\n+static struct df_problem problem_MD =\n+{\n+  DF_MD,                      /* Problem id.  */\n+  DF_FORWARD,                 /* Direction.  */\n+  df_md_alloc,                /* Allocate the problem specific data.  */\n+  df_md_reset,                /* Reset global information.  */\n+  df_md_free_bb_info,         /* Free basic block info.  */\n+  df_md_local_compute,        /* Local compute function.  */\n+  df_md_init,                 /* Init the solution specific data.  */\n+  df_worklist_dataflow,       /* Worklist solver.  */\n+  df_md_confluence_0,         /* Confluence operator 0.  */ \n+  df_md_confluence_n,         /* Confluence operator n.  */ \n+  df_md_transfer_function,    /* Transfer function.  */\n+  NULL,                       /* Finalize function.  */\n+  df_md_free,                 /* Free all of the problem information.  */\n+  df_md_free,                 /* Remove this problem from the stack of dataflow problems.  */\n+  NULL,                       /* Debugging.  */\n+  df_md_top_dump,             /* Debugging start block.  */\n+  df_md_bottom_dump,          /* Debugging end block.  */\n+  NULL,\t\t\t      /* Incremental solution verify start.  */\n+  NULL,\t\t\t      /* Incremental solution verify end.  */\n+  NULL,                       /* Dependent problem.  */\n+  TV_DF_MD,                   /* Timing variable.  */ \n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n+};\n+\n+/* Create a new MD instance and add it to the existing instance\n+   of DF.  */\n+\n+void\n+df_md_add_problem (void)\n+{\n+  df_add_problem (&problem_MD);\n+}\n+\n+\n+"}, {"sha": "f1c581248d32ae00987a7795e3cc57a8dff32ff7", "filename": "gcc/df.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -52,8 +52,9 @@ union df_ref_d;\n #define DF_CHAIN   4      /* Def-Use and/or Use-Def Chains. */\n #define DF_BYTE_LR 5      /* Subreg tracking lr.  */\n #define DF_NOTE    6      /* REG_DEF and REG_UNUSED notes. */\n+#define DF_MD      7      /* Multiple Definitions. */\n \n-#define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n+#define DF_LAST_PROBLEM_PLUS1 (DF_MD + 1)\n \n /* Dataflow direction.  */\n enum df_flow_dir\n@@ -619,6 +620,7 @@ struct df\n #define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n #define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n #define DF_BYTE_LR_BB_INFO(BB) (df_byte_lr_get_bb_info((BB)->index))\n+#define DF_MD_BB_INFO(BB) (df_md_get_bb_info((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n@@ -802,6 +804,22 @@ struct df_rd_bb_info\n };\n \n \n+/* Multiple reaching definitions.  All bitmaps are referenced by the\n+   register number.  */\n+\n+struct df_md_bb_info \n+{\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap gen;    /* Partial/conditional definitions live at BB out.  */\n+  bitmap kill;   /* Other definitions that are live at BB out.  */\n+  bitmap init;   /* Definitions coming from dominance frontier edges. */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* Just before the block itself. */\n+  bitmap out;   /* At the bottom of the block.  */\n+};\n+\n+\n /* Live registers, a backwards dataflow problem.  All bitmaps are\n    referenced by the register number.  */\n \n@@ -862,6 +880,7 @@ extern struct df *df;\n #define df_chain   (df->problems_by_index[DF_CHAIN])\n #define df_byte_lr (df->problems_by_index[DF_BYTE_LR])\n #define df_note    (df->problems_by_index[DF_NOTE])\n+#define df_md      (df->problems_by_index[DF_MD])\n \n /* This symbol turns on checking that each modification of the cfg has\n   been identified to the appropriate df routines.  It is not part of\n@@ -955,6 +974,9 @@ extern void df_byte_lr_simulate_uses (rtx, bitmap);\n extern void df_byte_lr_simulate_artificial_refs_at_top (basic_block, bitmap);\n extern void df_byte_lr_simulate_artificial_refs_at_end (basic_block, bitmap);\n extern void df_note_add_problem (void);\n+extern void df_md_add_problem (void);\n+extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);\n+extern void df_md_simulate_one_insn (basic_block, rtx, bitmap);\n extern void df_simulate_find_defs (rtx, bitmap);\n extern void df_simulate_defs (rtx, bitmap);\n extern void df_simulate_uses (rtx, bitmap);\n@@ -1034,6 +1056,15 @@ df_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n+static inline struct df_md_bb_info *\n+df_md_get_bb_info (unsigned int index)\n+{\n+  if (index < df_md->block_info_size)\n+    return (struct df_md_bb_info *) df_md->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n static inline struct df_live_bb_info *\n df_live_get_bb_info (unsigned int index)\n {"}, {"sha": "df4edf93574153854abef843f03f57177982e10d", "filename": "gcc/fwprop.c", "status": "modified", "additions": 148, "deletions": 63, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n+#include \"domwalk.h\"\n \n \n /* This pass does simple forward propagation and simplification when an\n@@ -100,14 +101,26 @@ along with GCC; see the file COPYING3.  If not see\n      (set (reg:QI 121) (subreg:QI (reg:SI 119) 0))\n      (set (reg:SI 122) (plus:SI (reg:SI 118) (reg:SI 119)))\n \n-   where the first two insns are now dead.  */\n+   where the first two insns are now dead.\n+\n+   We used to use reaching definitions to find which uses have a\n+   single reaching definition (sounds obvious...), but this is too\n+   complex a problem in nasty testcases like PR33928.  Now we use the\n+   multiple definitions problem in df-problems.c.  The similarity\n+   between that problem and SSA form creation is taken further, in\n+   that fwprop does a dominator walk to create its chains; however,\n+   instead of creating a PHI function where multiple definitions meet\n+   I just punt and record only singleton use-def chains, which is\n+   all that is needed by fwprop.  */\n \n \n static int num_changes;\n \n DEF_VEC_P(df_ref);\n DEF_VEC_ALLOC_P(df_ref,heap);\n VEC(df_ref,heap) *use_def_ref;\n+VEC(df_ref,heap) *reg_defs;\n+VEC(df_ref,heap) *reg_defs_stack;\n \n \n /* Return the only def in USE's use-def chain, or NULL if there is\n@@ -120,96 +133,168 @@ get_def_for_use (df_ref use)\n }\n \n \n-/* Return the only bit between FIRST and LAST that is set in B,\n-   or -1 if there are zero or more than one such bits.  */\n+/* Update the reg_defs vector with non-partial definitions in DEF_REC.\n+   TOP_FLAG says which artificials uses should be used, when DEF_REC\n+   is an artificial def vector.  LOCAL_MD is modified as after a\n+   df_md_simulate_* function; we do more or less the same processing\n+   done there, so we do not use those functions.  */\n+\n+#define DF_MD_GEN_FLAGS \\\n+\t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER)\n \n-static inline int\n-bitmap_only_bit_between (const_bitmap b, unsigned first, unsigned last)\n+static void\n+process_defs (bitmap local_md, df_ref *def_rec, int top_flag)\n {\n-  bitmap_iterator bi;\n-  unsigned bit, bit2;\n+  df_ref def;\n+  while ((def = *def_rec++) != NULL)\n+    {\n+      df_ref curr_def = VEC_index (df_ref, reg_defs, DF_REF_REGNO (def));\n+      unsigned int dregno;\n \n-  if (last < first)\n-    return -1;\n+      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) != top_flag)\n+\tcontinue;\n \n-  bmp_iter_set_init (&bi, b, first, &bit);\n-  if (bmp_iter_set (&bi, &bit) && bit <= last)\n-    {\n-      bit2 = bit;\n-      bmp_iter_next (&bi, &bit2);\n-      if (!bmp_iter_set (&bi, &bit2) || bit2 > last)\n-        return bit;\n+      dregno = DF_REF_REGNO (def);\n+      if (curr_def)\n+\tVEC_safe_push (df_ref, heap, reg_defs_stack, curr_def);\n+      else\n+\t{\n+\t  /* Do not store anything if \"transitioning\" from NULL to NULL.  But\n+             otherwise, push a special entry on the stack to tell the\n+\t     leave_block callback that the entry in reg_defs was NULL.  */\n+\t  if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n+\t    ;\n+\t  else\n+\t    VEC_safe_push (df_ref, heap, reg_defs_stack, def);\n+\t}\n+\n+      if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n+\t{\n+\t  bitmap_set_bit (local_md, dregno);\n+\t  VEC_replace (df_ref, reg_defs, dregno, NULL);\n+\t}\n+      else\n+\t{\n+\t  bitmap_clear_bit (local_md, dregno);\n+\t  VEC_replace (df_ref, reg_defs, dregno, def);\n+\t}\n     }\n-  return -1;\n }\n \n \n /* Fill the use_def_ref vector with values for the uses in USE_REC,\n-   taking reaching definitions info from LOCAL_RD.  TOP_FLAG says\n-   which artificials uses should be used, when USE_REC is an\n-   artificial use vector.  */\n+   taking reaching definitions info from LOCAL_MD and REG_DEFS.\n+   TOP_FLAG says which artificials uses should be used, when USE_REC\n+   is an artificial use vector.  */\n \n static void\n-process_uses (bitmap local_rd, df_ref *use_rec, int top_flag)\n+process_uses (bitmap local_md, df_ref *use_rec, int top_flag)\n {\n   df_ref use;\n   while ((use = *use_rec++) != NULL)\n-    if (top_flag == (DF_REF_FLAGS (use) & DF_REF_AT_TOP))\n+    if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == top_flag)\n       {\n-\tunsigned int uregno = DF_REF_REGNO (use);\n-\tunsigned int first = DF_DEFS_BEGIN (uregno);\n-\tunsigned int last = first + DF_DEFS_COUNT (uregno) - 1;\n-\tint defno = bitmap_only_bit_between (local_rd, first, last);\n-\tdf_ref def = (defno == -1) ? NULL : DF_DEFS_GET (defno);\n+        unsigned int uregno = DF_REF_REGNO (use);\n+        if (VEC_index (df_ref, reg_defs, uregno)\n+\t    && !bitmap_bit_p (local_md, uregno))\n+\t  VEC_replace (df_ref, use_def_ref, DF_REF_ID (use),\n+\t\t       VEC_index (df_ref, reg_defs, uregno));\n+      }\n+}\n+\n+\n+static void\n+single_def_use_enter_block (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  bitmap local_md = (bitmap) walk_data->global_data;\n+  int bb_index = bb->index;\n+  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  rtx insn;\n+\n+  bitmap_copy (local_md, bb_info->in);\n \n-\tVEC_replace (df_ref, use_def_ref, DF_REF_ID (use), def);\n+  /* Push a marker for the leave_block callback.  */\n+  VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);\n+\n+  process_uses (local_md, df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n+  process_defs (local_md, df_get_artificial_defs (bb_index), DF_REF_AT_TOP);\n+\n+  FOR_BB_INSNS (bb, insn)\n+    if (INSN_P (insn))\n+      {\n+        unsigned int uid = INSN_UID (insn);\n+        process_uses (local_md, DF_INSN_UID_USES (uid), 0);\n+        process_uses (local_md, DF_INSN_UID_EQ_USES (uid), 0);\n+        process_defs (local_md, DF_INSN_UID_DEFS (uid), 0);\n       }\n+\n+  process_uses (local_md, df_get_artificial_uses (bb_index), 0);\n+  process_defs (local_md, df_get_artificial_defs (bb_index), 0);\n+}\n+\n+/* Pop the definitions created in this basic block when leaving its\n+   dominated parts.  */\n+\n+static void\n+single_def_use_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  df_ref saved_def;\n+  while ((saved_def = VEC_pop (df_ref, reg_defs_stack)) != NULL)\n+    {\n+      unsigned int dregno = DF_REF_REGNO (saved_def);\n+\n+      /* See also process_defs.  */\n+      if (saved_def == VEC_index (df_ref, reg_defs, dregno))\n+\tVEC_replace (df_ref, reg_defs, dregno, NULL);\n+      else\n+\tVEC_replace (df_ref, reg_defs, dregno, saved_def);\n+    }\n }\n \n \n-/* Do dataflow analysis and use reaching definitions to build\n-   a vector holding the reaching definitions of uses that have a\n-   single RD.  */\n+/* Build a vector holding the reaching definitions of uses reached by a\n+   single dominating definition.  */\n \n static void\n build_single_def_use_links (void)\n {\n-  basic_block bb;\n-  bitmap local_rd = BITMAP_ALLOC (NULL);\n+  struct dom_walk_data walk_data;\n+  bitmap local_md;\n \n-  /* We use reaching definitions to compute our restricted use-def chains.  */\n+  /* We use the multiple definitions problem to compute our restricted\n+     use-def chains.  */\n   df_set_flags (DF_EQ_NOTES);\n-  df_rd_add_problem ();\n+  df_md_add_problem ();\n   df_analyze ();\n   df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n \n   use_def_ref = VEC_alloc (df_ref, heap, DF_USES_TABLE_SIZE ());\n-  VEC_safe_grow (df_ref, heap, use_def_ref, DF_USES_TABLE_SIZE ());\n+  VEC_safe_grow_cleared (df_ref, heap, use_def_ref, DF_USES_TABLE_SIZE ());\n \n-  FOR_EACH_BB (bb)\n-    {\n-      int bb_index = bb->index;\n-      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n-      rtx insn;\n-\n-      bitmap_copy (local_rd, bb_info->in);\n-      process_uses (local_rd, df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n-\n-      df_rd_simulate_artificial_defs_at_top (bb, local_rd);\n-      FOR_BB_INSNS (bb, insn)\n-        if (INSN_P (insn))\n-          {\n-            unsigned int uid = INSN_UID (insn);\n-            process_uses (local_rd, DF_INSN_UID_USES (uid), 0);\n-            process_uses (local_rd, DF_INSN_UID_EQ_USES (uid), 0);\n-            df_rd_simulate_one_insn (bb, insn, local_rd);\n-\t  }\n+  reg_defs = VEC_alloc (df_ref, heap, max_reg_num ());\n+  VEC_safe_grow_cleared (df_ref, heap, reg_defs, max_reg_num ());\n \n-      process_uses (local_rd, df_get_artificial_uses (bb_index), 0);\n-    }\n+  reg_defs_stack = VEC_alloc (df_ref, heap, n_basic_blocks * 10);\n+  local_md = BITMAP_ALLOC (NULL);\n+\n+  /* Walk the dominator tree looking for single reaching definitions\n+     dominating the uses.  This is similar to how SSA form is built.  */\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children = single_def_use_enter_block;\n+  walk_data.after_dom_children = single_def_use_leave_block;\n+  walk_data.global_data = local_md;\n \n-  BITMAP_FREE (local_rd);\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  BITMAP_FREE (local_md);\n+  VEC_free (df_ref, heap, reg_defs);\n+  VEC_free (df_ref, heap, reg_defs_stack);\n }\n+\n \f\n /* Do not try to replace constant addresses or addresses of local and\n    argument slots.  These MEM expressions are made only once and inserted\n@@ -629,12 +714,12 @@ use_killed_between (df_ref use, rtx def_insn, rtx target_insn)\n   int regno;\n   df_ref def;\n \n-  /* In some obscure situations we can have a def reaching a use\n-     that is _before_ the def.  In other words the def does not\n-     dominate the use even though the use and def are in the same\n-     basic block.  This can happen when a register may be used\n-     uninitialized in a loop.  In such cases, we must assume that\n-     DEF is not available.  */\n+  /* We used to have a def reaching a use that is _before_ the def,\n+     with the def not dominating the use even though the use and def\n+     are in the same basic block, when a register may be used\n+     uninitialized in a loop.  This should not happen anymore since\n+     we do not use reaching definitions, but still we test for such\n+     cases and assume that DEF is not available.  */\n   if (def_bb == target_bb\n       ? DF_INSN_LUID (def_insn) >= DF_INSN_LUID (target_insn)\n       : !dominated_by_p (CDI_DOMINATORS, target_bb, def_bb))"}, {"sha": "938447f03b129af7ffa649b7f689b69daa8a1e72", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c6741572cfd4b2ad9c262ec00e152cbf1ea8eb51", "patch": "@@ -58,7 +58,7 @@ DEFTIMEVAR (TV_LIFE_UPDATE\t     , \"life info update\")\n \n /* Time spent in dataflow problems.  */\n DEFTIMEVAR (TV_DF_SCAN\t\t     , \"df scan insns\")\n-DEFTIMEVAR (TV_DF_RU\t\t     , \"df reaching uses\")\n+DEFTIMEVAR (TV_DF_MD\t\t     , \"df multiple defs\")\n DEFTIMEVAR (TV_DF_RD\t\t     , \"df reaching defs\")\n DEFTIMEVAR (TV_DF_LR\t\t     , \"df live regs\")\n DEFTIMEVAR (TV_DF_LIVE\t\t     , \"df live&initialized regs\")"}]}