{"sha": "1941069a58da0f4d4c8a126c0374387dc50a02d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0MTA2OWE1OGRhMGY0ZDRjOGExMjZjMDM3NDM4N2RjNTBhMDJkNg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-11-30T08:20:23Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-11-30T08:20:23Z"}, "message": "simplify-rtx.c (simplify_plus_minus): Remove final parameter.\n\n2005-11-30  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* simplify-rtx.c (simplify_plus_minus): Remove final parameter.\n\tAlways produce an output if we can remove NEGs or canonicalize\n\t(minus (minus ...)) expressions.  Provide a fast path for the\n\ttwo-operand case.\n\t(simplify_gen_binary): Do not call simplify_plus_minus.\n\t(simplify_binary_operation_1): Reassociate at the end of the\n\tfunction.\n\nFrom-SVN: r107702", "tree": {"sha": "f2996e7ef00d0f0892750036fb2ccd9f07567730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2996e7ef00d0f0892750036fb2ccd9f07567730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1941069a58da0f4d4c8a126c0374387dc50a02d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1941069a58da0f4d4c8a126c0374387dc50a02d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1941069a58da0f4d4c8a126c0374387dc50a02d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1941069a58da0f4d4c8a126c0374387dc50a02d6/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77bfa77887bcf457c44b7a67b666428e0ec64fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bfa77887bcf457c44b7a67b666428e0ec64fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77bfa77887bcf457c44b7a67b666428e0ec64fc7"}], "stats": {"total": 106, "additions": 62, "deletions": 44}, "files": [{"sha": "1dee38ec0c1b46c848a373849c4a08feab1c51fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1941069a58da0f4d4c8a126c0374387dc50a02d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1941069a58da0f4d4c8a126c0374387dc50a02d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1941069a58da0f4d4c8a126c0374387dc50a02d6", "patch": "@@ -1,3 +1,13 @@\n+2005-11-30  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* simplify-rtx.c (simplify_plus_minus): Remove final parameter.\n+\tAlways produce an output if we can remove NEGs or canonicalize\n+\t(minus (minus ...)) expressions.  Provide a fast path for the\n+\ttwo-operand case.\n+\t(simplify_gen_binary): Do not call simplify_plus_minus.\n+\t(simplify_binary_operation_1): Reassociate at the end of the\n+\tfunction.\n+\n 2005-11-29  Evan Cheng  <evan.cheng@apple.com>\n \n \t* config/i386/xmmintrin.h (_MM_TRANSPOSE4_PS): Rewrite using high/low"}, {"sha": "bc17131458906c6bff21c0f3bb0b5b898054ac57", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1941069a58da0f4d4c8a126c0374387dc50a02d6/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1941069a58da0f4d4c8a126c0374387dc50a02d6/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1941069a58da0f4d4c8a126c0374387dc50a02d6", "patch": "@@ -52,8 +52,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static rtx neg_const_int (enum machine_mode, rtx);\n static bool plus_minus_operand_p (rtx);\n static int simplify_plus_minus_op_data_cmp (const void *, const void *);\n-static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n-\t\t\t\trtx, int);\n+static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx, rtx);\n static rtx simplify_immed_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\t  unsigned int);\n static rtx simplify_associative_operation (enum rtx_code, enum machine_mode,\n@@ -125,16 +124,6 @@ simplify_gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0,\n   if (tem)\n     return tem;\n \n-  /* Handle addition and subtraction specially.  Otherwise, just form\n-     the operation.  */\n-\n-  if (code == PLUS || code == MINUS)\n-    {\n-      tem = simplify_plus_minus (code, mode, op0, op1, 1);\n-      if (tem)\n-\treturn tem;\n-    }\n-\n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n@@ -1366,7 +1355,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (INTEGRAL_MODE_P (mode)\n \t  && (plus_minus_operand_p (op0)\n \t      || plus_minus_operand_p (op1))\n-\t  && (tem = simplify_plus_minus (code, mode, op0, op1, 0)) != 0)\n+\t  && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n \treturn tem;\n \n       /* Reassociate floating point addition only when the user\n@@ -1531,18 +1520,6 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t    return simplify_gen_binary (MINUS, mode, tem, XEXP (op0, 0));\n \t}\n \n-      /* If one of the operands is a PLUS or a MINUS, see if we can\n-\t simplify this by the associative law.\n-\t Don't use the associative law for floating point.\n-\t The inaccuracy makes it nonassociative,\n-\t and subtle programs can break if operations are associated.  */\n-\n-      if (INTEGRAL_MODE_P (mode)\n-\t  && (plus_minus_operand_p (op0)\n-\t      || plus_minus_operand_p (op1))\n-\t  && (tem = simplify_plus_minus (code, mode, op0, op1, 0)) != 0)\n-\treturn tem;\n-\n       /* Don't let a relocatable value get a negative coeff.  */\n       if (GET_CODE (op1) == CONST_INT && GET_MODE (op0) != VOIDmode)\n \treturn simplify_gen_binary (PLUS, mode,\n@@ -1565,6 +1542,19 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      return simplify_gen_binary (AND, mode, op0, tem);\n \t    }\n \t}\n+\n+      /* If one of the operands is a PLUS or a MINUS, see if we can\n+\t simplify this by the associative law.  This will, for example,\n+         canonicalize (minus A (plus B C)) to (minus (minus A B) C).\n+\t Don't use the associative law for floating point.\n+\t The inaccuracy makes it nonassociative,\n+\t and subtle programs can break if operations are associated.  */\n+\n+      if (INTEGRAL_MODE_P (mode)\n+\t  && (plus_minus_operand_p (op0)\n+\t      || plus_minus_operand_p (op1))\n+\t  && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n+\treturn tem;\n       break;\n \n     case MULT:\n@@ -2583,12 +2573,7 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n    Rather than test for specific case, we do this by a brute-force method\n    and do all possible simplifications until no more changes occur.  Then\n-   we rebuild the operation.\n-\n-   If FORCE is true, then always generate the rtx.  This is used to\n-   canonicalize stuff emitted from simplify_gen_binary.  Note that this\n-   can still fail if the rtx is too complex.  It won't fail just because\n-   the result is not 'simpler' than the input, however.  */\n+   we rebuild the operation.  */\n \n struct simplify_plus_minus_op_data\n {\n@@ -2613,12 +2598,12 @@ simplify_plus_minus_op_data_cmp (const void *p1, const void *p2)\n \n static rtx\n simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n-\t\t     rtx op1, int force)\n+\t\t     rtx op1)\n {\n   struct simplify_plus_minus_op_data ops[8];\n   rtx result, tem;\n   int n_ops = 2, input_ops = 2, input_consts = 0, n_consts;\n-  int first, changed;\n+  int first, changed, canonicalized = 0;\n   int i, j;\n \n   memset (ops, 0, sizeof ops);\n@@ -2656,12 +2641,14 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t      ops[i].op = XEXP (this_op, 0);\n \t      input_ops++;\n \t      changed = 1;\n+\t      canonicalized |= this_neg;\n \t      break;\n \n \t    case NEG:\n \t      ops[i].op = XEXP (this_op, 0);\n \t      ops[i].neg = ! this_neg;\n \t      changed = 1;\n+\t      canonicalized = 1;\n \t      break;\n \n \t    case CONST:\n@@ -2676,6 +2663,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t  n_ops++;\n \t\t  input_consts++;\n \t\t  changed = 1;\n+\t          canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -2688,6 +2676,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t  ops[i].op = XEXP (this_op, 0);\n \t\t  ops[i].neg = !this_neg;\n \t\t  changed = 1;\n+\t          canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -2697,6 +2686,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t  ops[i].op = neg_const_int (mode, this_op);\n \t\t  ops[i].neg = 0;\n \t\t  changed = 1;\n+\t          canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -2707,10 +2697,37 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n     }\n   while (changed);\n \n-  /* If we only have two operands, we can't do anything.  */\n-  if (n_ops <= 2 && !force)\n+  gcc_assert (n_ops >= 2);\n+  if (!canonicalized)\n     return NULL_RTX;\n \n+  /* If we only have two operands, we can avoid the loops.  */\n+  if (n_ops == 2)\n+    {\n+      enum rtx_code code = ops[0].neg || ops[1].neg ? MINUS : PLUS;\n+      rtx lhs, rhs;\n+\n+      /* Get the two operands.  Be careful with the order, especially for\n+\t the cases where code == MINUS.  */\n+      if (ops[0].neg && ops[1].neg)\n+\t{\n+\t  lhs = gen_rtx_NEG (mode, ops[0].op);\n+\t  rhs = ops[1].op;\n+\t}\n+      else if (ops[0].neg)\n+\t{\n+\t  lhs = ops[1].op;\n+\t  rhs = ops[0].op;\n+\t}\n+      else\n+\t{\n+\t  lhs = ops[0].op;\n+\t  rhs = ops[1].op;\n+\t}\n+\n+      return simplify_const_binary_operation (code, mode, lhs, rhs);\n+    }\n+\n   /* Count the number of CONSTs we didn't split above.  */\n   for (i = 0; i < n_ops; i++)\n     if (GET_CODE (ops[i].op) == CONST)\n@@ -2824,15 +2841,6 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n     if (GET_CODE (ops[i].op) == CONST)\n       n_consts++;\n \n-  /* Give up if we didn't reduce the number of operands we had.  Make\n-     sure we count a CONST as two operands.  If we have the same\n-     number of operands, but have made more CONSTs than before, this\n-     is also an improvement, so accept it.  */\n-  if (!force\n-      && (n_ops + n_consts > input_ops\n-\t  || (n_ops + n_consts == input_ops && n_consts <= input_consts)))\n-    return NULL_RTX;\n-\n   /* Put a non-negated operand first, if possible.  */\n \n   for (i = 0; i < n_ops && ops[i].neg; i++)"}]}