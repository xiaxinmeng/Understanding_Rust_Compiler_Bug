{"sha": "107b023cee9d3ce4928b2767fe69a1e316c20d1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3YjAyM2NlZTlkM2NlNDkyOGIyNzY3ZmU2OWExZTMxNmMyMGQxYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T15:25:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T15:25:01Z"}, "message": "[multiple changes]\n\n2009-04-29  Vincent Celier  <celier@adacore.com>\n\n\t* prj-part.adb: Minor comment update\n\n2009-04-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate): handle properly\n\tbox-initialized records with discriminated subcomponents that are\n\tconstrained by discriminants of enclosing components. New subsidiary\n\tprocedures Add_Discriminant_Values, Propagate_Discriminants.\n\n2009-04-29  Arnaud Charlet  <charlet@adacore.com>\n\n\t* g-socket.adb: Code clean up.\n\nFrom-SVN: r146976", "tree": {"sha": "22b5e0a70a62cb26894ab653d474436c22a1b492", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22b5e0a70a62cb26894ab653d474436c22a1b492"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/107b023cee9d3ce4928b2767fe69a1e316c20d1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107b023cee9d3ce4928b2767fe69a1e316c20d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107b023cee9d3ce4928b2767fe69a1e316c20d1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107b023cee9d3ce4928b2767fe69a1e316c20d1c/comments", "author": null, "committer": null, "parents": [{"sha": "e50e30817e79d18bb9e662d70940cc79dbbe9e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50e30817e79d18bb9e662d70940cc79dbbe9e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50e30817e79d18bb9e662d70940cc79dbbe9e15"}], "stats": {"total": 319, "additions": 230, "deletions": 89}, "files": [{"sha": "3db1b05787031960d1535259a1f719973ff3c878", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=107b023cee9d3ce4928b2767fe69a1e316c20d1c", "patch": "@@ -1,3 +1,18 @@\n+2009-04-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-part.adb: Minor comment update\n+\n+2009-04-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Record_Aggregate): handle properly\n+\tbox-initialized records with discriminated subcomponents that are\n+\tconstrained by discriminants of enclosing components. New subsidiary\n+\tprocedures Add_Discriminant_Values, Propagate_Discriminants.\n+\n+2009-04-29  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* g-socket.adb: Code clean up.\n+\n 2009-04-29  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_aggr.adb (Valid_Limited_Ancestor): Add test for the name of a"}, {"sha": "4caa5f47244047c01a4344118598460593134c16", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=107b023cee9d3ce4928b2767fe69a1e316c20d1c", "patch": "@@ -1904,7 +1904,8 @@ package body GNAT.Sockets is\n       Count  : out Ada.Streams.Stream_Element_Count;\n       Flags  : Request_Flag_Type := No_Request_Flag)\n    is\n-      use type SOSC.Msg_Iovlen_T;\n+      use SOSC;\n+      use Interfaces.C;\n \n       Res            : ssize_t;\n       Iov_Count      : SOSC.Msg_Iovlen_T;"}, {"sha": "871517cba66b48dd31a52cb9b78813ec12ecb258", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=107b023cee9d3ce4928b2767fe69a1e316c20d1c", "patch": "@@ -1101,10 +1101,10 @@ package body Prj.Part is\n                   begin\n                      --  Loop through extending projects to find the ultimate\n                      --  extending project, that is the one that is not\n-                     --  extended. But don't attempt to find an extending\n-                     --  project if the initial project is an abstract project,\n-                     --  as it may have been extended several time, so it\n-                     --  cannot have a single extending project.\n+                     --  extended. For an abstract project, as it can be\n+                     --  extended several times, there is no extending project\n+                     --  registered, so the loop does not execute and the\n+                     --  resulting project is the abstract project.\n \n                      while\n                        Extending_Project_Of (Decl, In_Tree) /= Empty_Node"}, {"sha": "3760e79e9af3c1be1508e3c044449c4393ac465e", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 209, "deletions": 84, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107b023cee9d3ce4928b2767fe69a1e316c20d1c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=107b023cee9d3ce4928b2767fe69a1e316c20d1c", "patch": "@@ -2356,10 +2356,12 @@ package body Sem_Aggr is\n       procedure Add_Association\n         (Component      : Entity_Id;\n          Expr           : Node_Id;\n+         Assoc_List     : List_Id;\n          Is_Box_Present : Boolean := False);\n       --  Builds a new N_Component_Association node which associates\n-      --  Component to expression Expr and adds it to the new association\n-      --  list New_Assoc_List being built.\n+      --  Component to expression Expr and adds it to the association\n+      --  list being built, either New_Assoc_List, or the association\n+      --  being build for an inner aggregate.\n \n       function Discr_Present (Discr : Entity_Id) return Boolean;\n       --  If aggregate N is a regular aggregate this routine will return True.\n@@ -2406,6 +2408,7 @@ package body Sem_Aggr is\n       procedure Add_Association\n         (Component      : Entity_Id;\n          Expr           : Node_Id;\n+         Assoc_List     : List_Id;\n          Is_Box_Present : Boolean := False)\n       is\n          Choice_List : constant List_Id := New_List;\n@@ -2418,7 +2421,7 @@ package body Sem_Aggr is\n              Choices     => Choice_List,\n              Expression  => Expr,\n              Box_Present => Is_Box_Present);\n-         Append (New_Assoc, New_Assoc_List);\n+         Append (New_Assoc, Assoc_List);\n       end Add_Association;\n \n       -------------------\n@@ -2781,9 +2784,9 @@ package body Sem_Aggr is\n          end if;\n \n          if Relocate then\n-            Add_Association (New_C, Relocate_Node (Expr));\n+            Add_Association (New_C, Relocate_Node (Expr), New_Assoc_List);\n          else\n-            Add_Association (New_C, Expr);\n+            Add_Association (New_C, Expr, New_Assoc_List);\n          end if;\n       end Resolve_Aggr_Expr;\n \n@@ -3254,8 +3257,9 @@ package body Sem_Aggr is\n                       New_Sloc => Sloc (N));\n \n                   Add_Association\n-                    (Component => Component,\n-                     Expr      => Expr);\n+                    (Component  => Component,\n+                     Expr       => Expr,\n+                     Assoc_List => New_Assoc_List);\n                   Set_Has_Self_Reference (N);\n \n                --  A box-defaulted access component gets the value null. Also\n@@ -3270,8 +3274,9 @@ package body Sem_Aggr is\n                      Expr := Make_Null (Sloc (N));\n                      Set_Etype (Expr, Ctyp);\n                      Add_Association\n-                       (Component => Component,\n-                        Expr      => Expr);\n+                       (Component  => Component,\n+                        Expr       => Expr,\n+                        Assoc_List => New_Assoc_List);\n \n                   --  If the component's type is private with an access type as\n                   --  its underlying type then we have to create an unchecked\n@@ -3293,7 +3298,9 @@ package body Sem_Aggr is\n                      begin\n                         Analyze_And_Resolve (Convert_Null, Ctyp);\n                         Add_Association\n-                          (Component => Component, Expr => Convert_Null);\n+                          (Component  => Component,\n+                           Expr       => Convert_Null,\n+                           Assoc_List => New_Assoc_List);\n                      end;\n                   end if;\n \n@@ -3307,101 +3314,219 @@ package body Sem_Aggr is\n                      --  values of the discriminants and box initialization\n                      --  for the rest, if other components are present.\n                      --  The type of the aggregate is the known subtype of\n-                     --  the component.\n+                     --  the component. The capture of discriminants must\n+                     --  be recursive because subcomponents may be contrained\n+                     --  (transitively) by discriminants of enclosing types.\n \n-                     declare\n+                     Capture_Discriminants : declare\n                         Loc        : constant Source_Ptr := Sloc (N);\n-                        Assoc      : Node_Id;\n-                        Discr      : Entity_Id;\n-                        Discr_Elmt : Elmt_Id;\n-                        Discr_Val  : Node_Id;\n                         Expr       : Node_Id;\n \n-                     begin\n-                        Expr := Make_Aggregate (Loc, New_List, New_List);\n-                        Set_Etype (Expr, Ctyp);\n+                        procedure Add_Discriminant_Values\n+                          (New_Aggr   : Node_Id;\n+                           Assoc_List : List_Id);\n+                        --  The constraint to a component may be given by a\n+                        --  discriminant of the enclosing type, in which case\n+                        --  we have to retrieve its value, which is part of the\n+                        --  enclosing aggregate. Assoc_List provides the\n+                        --  discriminant associations of the current type or\n+                        --  of some enclosing record.\n+\n+                        procedure Propagate_Discriminants\n+                          (Aggr       : Node_Id;\n+                           Assoc_List : List_Id;\n+                           Comp       : Entity_Id);\n+                        --  Nested components may themselves be discriminated\n+                        --  types constrained by outer discriminants. Their\n+                        --  values must be captured before the aggregate is\n+                        --  expanded into assignments.\n+\n+                        -----------------------------\n+                        -- Add_Discriminant_Values --\n+                        -----------------------------\n+\n+                        procedure Add_Discriminant_Values\n+                          (New_Aggr   : Node_Id;\n+                           Assoc_List : List_Id)\n+                        is\n+                           Assoc      : Node_Id;\n+                           Discr      : Entity_Id;\n+                           Discr_Elmt : Elmt_Id;\n+                           Discr_Val  : Node_Id;\n+                           Val        : Entity_Id;\n \n-                        Discr_Elmt :=\n-                          First_Elmt (Discriminant_Constraint (Ctyp));\n-                        while Present (Discr_Elmt) loop\n-                           Discr_Val := Node (Discr_Elmt);\n-\n-                           --  The constraint may be given by a discriminant\n-                           --  of the enclosing type, in which case we have\n-                           --  to retrieve its value, which is part of the\n-                           --  current aggregate.\n-\n-                           if Is_Entity_Name (Discr_Val)\n-                             and then\n-                               Ekind (Entity (Discr_Val)) = E_Discriminant\n-                           then\n-                              Discr := Entity (Discr_Val);\n-\n-                              Assoc := First (New_Assoc_List);\n-                              while Present (Assoc) loop\n-                                 if Present\n-                                   (Entity (First (Choices (Assoc))))\n-                                   and then\n-                                     Entity (First (Choices (Assoc))) = Discr\n-                                 then\n-                                    Discr_Val := Expression (Assoc);\n-                                    exit;\n-                                 end if;\n-                                 Next (Assoc);\n-                              end loop;\n-                           end if;\n-\n-                           Append\n-                             (New_Copy_Tree (Discr_Val), Expressions (Expr));\n+                        begin\n+                           Discr := First_Discriminant (Etype (New_Aggr));\n+                           Discr_Elmt :=\n+                             First_Elmt\n+                               (Discriminant_Constraint (Etype (New_Aggr)));\n+                           while Present (Discr_Elmt) loop\n+                              Discr_Val := Node (Discr_Elmt);\n+\n+                              --  If the constraint is given by a discriminant\n+                              --  it is a discriminant of an enclosing record,\n+                              --  and its value has already been placed in the\n+                              --  association list.\n+\n+                              if Is_Entity_Name (Discr_Val)\n+                                and then\n+                                  Ekind (Entity (Discr_Val)) = E_Discriminant\n+                              then\n+                                 Val := Entity (Discr_Val);\n+\n+                                 Assoc := First (Assoc_List);\n+                                 while Present (Assoc) loop\n+                                    if Present\n+                                      (Entity (First (Choices (Assoc))))\n+                                      and then\n+                                        Entity (First (Choices (Assoc)))\n+                                          = Val\n+                                    then\n+                                       Discr_Val := Expression (Assoc);\n+                                       exit;\n+                                    end if;\n+                                    Next (Assoc);\n+                                 end loop;\n+                              end if;\n \n-                           --  If the discriminant constraint is a current\n-                           --  instance, mark the current aggregate so that\n-                           --  the self-reference can be expanded later.\n+                              Add_Association\n+                                (Discr, New_Copy_Tree (Discr_Val),\n+                                  Component_Associations (New_Aggr));\n \n-                           if Nkind (Discr_Val) = N_Attribute_Reference\n-                             and then Is_Entity_Name (Prefix (Discr_Val))\n-                             and then Is_Type (Entity (Prefix (Discr_Val)))\n-                             and then Etype (N) = Entity (Prefix (Discr_Val))\n-                           then\n-                              Set_Has_Self_Reference (N);\n-                           end if;\n+                              --  If the discriminant constraint is a current\n+                              --  instance, mark the current aggregate so that\n+                              --  the self-reference can be expanded later.\n \n-                           Next_Elmt (Discr_Elmt);\n-                        end loop;\n+                              if Nkind (Discr_Val) = N_Attribute_Reference\n+                                and then Is_Entity_Name (Prefix (Discr_Val))\n+                                and then Is_Type (Entity (Prefix (Discr_Val)))\n+                                and then Etype (N) =\n+                                  Entity (Prefix (Discr_Val))\n+                              then\n+                                 Set_Has_Self_Reference (N);\n+                              end if;\n \n-                        declare\n-                           Comp : Entity_Id;\n+                              Next_Elmt (Discr_Elmt);\n+                              Next_Discriminant (Discr);\n+                           end loop;\n+                        end Add_Discriminant_Values;\n+\n+                        ------------------------------\n+                        --  Propagate_Discriminants --\n+                        ------------------------------\n+\n+                        procedure Propagate_Discriminants\n+                          (Aggr       : Node_Id;\n+                           Assoc_List : List_Id;\n+                           Comp       : Entity_Id)\n+                        is\n+                           Inner_Comp : Entity_Id;\n+                           Comp_Type  : Entity_Id;\n+                           Needs_Box  : Boolean := False;\n+                           New_Aggr   : Node_Id;\n \n                         begin\n-                           --  Look for a component that is not a discriminant\n-                           --  before creating an others box association.\n-\n-                           Comp := First_Component (Ctyp);\n-                           while Present (Comp) loop\n-                              if Ekind (Comp) = E_Component then\n-                                 Append\n-                                   (Make_Component_Association (Loc,\n-                                      Choices     =>\n-                                        New_List (Make_Others_Choice (Loc)),\n-                                      Expression  => Empty,\n-                                      Box_Present => True),\n-                                    Component_Associations (Expr));\n-                                 exit;\n+\n+                           Inner_Comp := First_Component (Etype (Comp));\n+                           while Present (Inner_Comp) loop\n+                              Comp_Type := Etype (Inner_Comp);\n+\n+                              if Is_Record_Type (Comp_Type)\n+                                and then Has_Discriminants (Comp_Type)\n+                              then\n+                                 New_Aggr :=\n+                                   Make_Aggregate (Loc, New_List, New_List);\n+                                 Set_Etype (New_Aggr, Comp_Type);\n+                                 Add_Association\n+                                   (Inner_Comp, New_Aggr,\n+                                     Component_Associations (Aggr));\n+\n+                                 --  Collect disciminant values, and recurse.\n+\n+                                 Add_Discriminant_Values\n+                                   (New_Aggr, Assoc_List);\n+                                 Propagate_Discriminants\n+                                   (New_Aggr, Assoc_List, Inner_Comp);\n+\n+                              else\n+                                 Needs_Box := True;\n                               end if;\n \n-                              Next_Component (Comp);\n+                              Next_Component (Inner_Comp);\n                            end loop;\n-                        end;\n+\n+                           if Needs_Box then\n+                              Append\n+                                (Make_Component_Association (Loc,\n+                                   Choices     =>\n+                                     New_List (Make_Others_Choice (Loc)),\n+                                   Expression  => Empty,\n+                                      Box_Present => True),\n+                                 Component_Associations (Aggr));\n+                           end if;\n+                        end Propagate_Discriminants;\n+\n+                     begin\n+                        Expr := Make_Aggregate (Loc, New_List, New_List);\n+                        Set_Etype (Expr, Ctyp);\n+\n+                        --  If the enclosing type has discriminants, they\n+                        --  have been collected in the aggregate earlier, and\n+                        --  they may appear as constraints of subcomponents.\n+                        --  Similarly if this component has discriminants, they\n+                        --  might it turn be propagated to their components.\n+\n+                        if Has_Discriminants (Typ) then\n+                           Add_Discriminant_Values (Expr, New_Assoc_List);\n+                           Propagate_Discriminants\n+                              (Expr, New_Assoc_List, Component);\n+\n+                        elsif Has_Discriminants (Ctyp) then\n+                           Add_Discriminant_Values\n+                              (Expr,  Component_Associations (Expr));\n+                           Propagate_Discriminants\n+                              (Expr, Component_Associations (Expr), Component);\n+\n+                        else\n+                           declare\n+                              Comp            : Entity_Id;\n+\n+                           begin\n+                              --  If the type has additional components, create\n+                              --  an others box association for them.\n+\n+                              Comp := First_Component (Ctyp);\n+                              while Present (Comp) loop\n+                                 if Ekind (Comp) = E_Component then\n+                                    if not Is_Record_Type (Etype (Comp)) then\n+                                       Append\n+                                         (Make_Component_Association (Loc,\n+                                            Choices     =>\n+                                              New_List\n+                                               (Make_Others_Choice (Loc)),\n+                                            Expression  => Empty,\n+                                               Box_Present => True),\n+                                          Component_Associations (Expr));\n+                                    end if;\n+                                    exit;\n+                                 end if;\n+\n+                                 Next_Component (Comp);\n+                              end loop;\n+                           end;\n+                        end if;\n \n                         Add_Association\n-                          (Component      => Component,\n-                           Expr           => Expr);\n-                     end;\n+                          (Component  => Component,\n+                           Expr       => Expr,\n+                           Assoc_List => New_Assoc_List);\n+                     end Capture_Discriminants;\n \n                   else\n                      Add_Association\n                        (Component      => Component,\n                         Expr           => Empty,\n+                        Assoc_List     => New_Assoc_List,\n                         Is_Box_Present => True);\n                   end if;\n "}]}