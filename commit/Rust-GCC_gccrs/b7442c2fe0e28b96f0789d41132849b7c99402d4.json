{"sha": "b7442c2fe0e28b96f0789d41132849b7c99402d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0NDJjMmZlMGUyOGI5NmYwNzg5ZDQxMTMyODQ5YjdjOTk0MDJkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-17T17:12:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-17T17:12:05Z"}, "message": "tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Add edge_to_cancel parameter and use it to estimate code optimized out in the...\n\n\n\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Add edge_to_cancel\n\tparameter and use it to estimate code optimized out in the final iteration.\n\t(loop_edge_to_cancel): New function.\n\t(try_unroll_loop_completely): New IRRED_IVALIDATED parameter;\n\thandle unrolling loops with bounds given via max_loop_iteratins;\n\thandle unrolling non-inner loops when code size shrinks;\n\ttidy dump output; when the last iteration loop still stays\n\tas loop in the CFG forcongly redirect the latch to\n\t__builtin_unreachable.\n\t(canonicalize_loop_induction_variables): Add irred_invlaidated\n\tparameter; record niter bound derrived; dump\n\tmax_loop_iterations bounds; call try_unroll_loop_completely\n\teven if no niter bound is given.\n\t(canonicalize_induction_variables): Handle irred_invalidated.\n\t(tree_unroll_loops_completely): Handle non-innermost loops;\n\thandle irred_invalidated.\n\t* cfgloop.h (unlop): Declare.\n\t* cfgloopmanip.c (unloop): Export.\n\t* tree.c (build_common_builtin_nodes): Build BULTIN_UNREACHABLE.\n\n\t* gcc.target/i386/l_fma_float_?.c: Update.\n\t* gcc.target/i386/l_fma_double_?.c: Update.\n\t* gfortran.dg/do_1.f90: XFAIL\n\t* gcc.dg/tree-ssa/cunroll-1.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-2.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-3.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-4.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-5.c: New testcase.\n\t* gcc.dg/tree-ssa/ldist-17.c: Block cunroll to make testcase still\n\tvalid.\n\nFrom-SVN: r192538", "tree": {"sha": "ec690798a65b49ddcc245df79c6075578b59178a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec690798a65b49ddcc245df79c6075578b59178a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7442c2fe0e28b96f0789d41132849b7c99402d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7442c2fe0e28b96f0789d41132849b7c99402d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7442c2fe0e28b96f0789d41132849b7c99402d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7442c2fe0e28b96f0789d41132849b7c99402d4/comments", "author": null, "committer": null, "parents": [{"sha": "90922d36383f2d2f5d09f26046a48d71168a166b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90922d36383f2d2f5d09f26046a48d71168a166b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90922d36383f2d2f5d09f26046a48d71168a166b"}], "stats": {"total": 466, "additions": 360, "deletions": 106}, "files": [{"sha": "63635b8f0199ecce21657c1502b37ca624cd861a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -1,3 +1,25 @@\n+2012-10-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Add edge_to_cancel\n+\tparameter and use it to estimate code optimized out in the final iteration.\n+\t(loop_edge_to_cancel): New function.\n+\t(try_unroll_loop_completely): New IRRED_IVALIDATED parameter;\n+\thandle unrolling loops with bounds given via max_loop_iteratins;\n+\thandle unrolling non-inner loops when code size shrinks;\n+\ttidy dump output; when the last iteration loop still stays\n+\tas loop in the CFG forcongly redirect the latch to\n+\t__builtin_unreachable.\n+\t(canonicalize_loop_induction_variables): Add irred_invlaidated\n+\tparameter; record niter bound derrived; dump\n+\tmax_loop_iterations bounds; call try_unroll_loop_completely\n+\teven if no niter bound is given.\n+\t(canonicalize_induction_variables): Handle irred_invalidated.\n+\t(tree_unroll_loops_completely): Handle non-innermost loops;\n+\thandle irred_invalidated.\n+\t* cfgloop.h (unlop): Declare.\n+\t* cfgloopmanip.c (unloop): Export.\n+\t* tree.c (build_common_builtin_nodes): Build BULTIN_UNREACHABLE.\n+\n 2012-10-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* opth-gen.awk (TARGET_* generation): Always generate TARGET_<xxx>"}, {"sha": "976606637817d1d0ce51c8f981992ad238019802", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -320,7 +320,8 @@ extern struct loop *loopify (edge, edge,\n struct loop * loop_version (struct loop *, void *,\n \t\t\t    basic_block *, unsigned, unsigned, unsigned, bool);\n extern bool remove_path (edge);\n-void scale_loop_frequencies (struct loop *, int, int);\n+extern void unloop (struct loop *, bool *);\n+extern void scale_loop_frequencies (struct loop *, int, int);\n \n /* Induction variable analysis.  */\n "}, {"sha": "98f359e086cf778a9d37a160dbbe31a12d317130", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -37,7 +37,6 @@ static int find_path (edge, basic_block **);\n static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *);\n-static void unloop (struct loop *, bool *);\n \n /* Checks whether basic block BB is dominated by DATA.  */\n static bool\n@@ -895,7 +894,7 @@ loopify (edge latch_edge, edge header_edge,\n    If this may cause the information about irreducible regions to become\n    invalid, IRRED_INVALIDATED is set to true.  */\n \n-static void\n+void\n unloop (struct loop *loop, bool *irred_invalidated)\n {\n   basic_block *body;"}, {"sha": "da34d4d6c8ad5f6a833030c49627d12b33c26408", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -1,3 +1,16 @@\n+2012-10-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.target/i386/l_fma_float_?.c: Update.\n+\t* gcc.target/i386/l_fma_double_?.c: Update.\n+\t* gfortran.dg/do_1.f90: XFAIL\n+\t* gcc.dg/tree-ssa/cunroll-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-2.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-3.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-4.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-5.c: New testcase.\n+\t* gcc.dg/tree-ssa/ldist-17.c: Block cunroll to make testcase still\n+\tvalid.\n+\n 2012-10-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/53063"}, {"sha": "5c280b3f0c43716a4a3aa5920964e721a18ebab2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details -fdisable-tree-cunroll -fdisable-tree-cunrolli\" } */\n \n typedef int mad_fixed_t;\n struct mad_pcm"}, {"sha": "716acfef65ceef0826049f9ab0135c26ca01a00f", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_1.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -16,11 +16,11 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231pd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 20  } } */"}, {"sha": "01173afb223176842f3003b8e055e49c3a68e3bf", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_2.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 40  } } */"}, {"sha": "8cda521a8701d0fb79737df9401dabe1532f3163", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_3.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_3.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -16,11 +16,11 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231pd\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd213sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 20  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub213sd\" 20  } } */"}, {"sha": "9f2331b51e827333a01326017b84255da3270b75", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_4.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 40  } } */"}, {"sha": "9e33975b1e454c4f8ca720ce73560f5ad308e502", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_5.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 40  } } */"}, {"sha": "28d264dd20d2528deb04efb0af7c5510466ed9b4", "filename": "gcc/testsuite/gcc.target/i386/l_fma_double_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_double_6.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132pd\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132pd\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132sd\" 40 } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132sd\" 40  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132sd\" 40  } } */"}, {"sha": "fea0b20619d858e104206184dc76a76ef1010b20", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_1.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -16,11 +16,11 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231ps\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 36  } } */"}, {"sha": "dd5f543f58c6d4bf15f563c99f587835fa32beba", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_2.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 72  } } */"}, {"sha": "38853353b017c8b370c00f1ebcec351fb7e5c13c", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_3.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_3.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -16,11 +16,11 @@\n /* { dg-final { scan-assembler-times \"vfnmadd231ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 4  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub231ps\" 4  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 8  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd213ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 36  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub213ss\" 36  } } */"}, {"sha": "5a7bb217836041ba276d9b9d766e4d331fe2ba24", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_4.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 72  } } */"}, {"sha": "0b0454ed336d3d11263153ee4c5271b2e67280af", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_5.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 72  } } */"}, {"sha": "03bf8e84835816ccf3dfd0a918b2ea0455664fb1", "filename": "gcc/testsuite/gcc.target/i386/l_fma_float_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fl_fma_float_6.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -12,7 +12,7 @@\n /* { dg-final { scan-assembler-times \"vfmsub132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmadd132ps\" 8  } } */\n /* { dg-final { scan-assembler-times \"vfnmsub132ps\" 8  } } */\n-/* { dg-final { scan-assembler-times \"vfmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfmsub132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 16  } } */\n-/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 16  } } */\n+/* { dg-final { scan-assembler-times \"vfmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfmsub132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmadd132ss\" 72  } } */\n+/* { dg-final { scan-assembler-times \"vfnmsub132ss\" 72  } } */"}, {"sha": "8ed0f7fb6c2328454e13ef6bef98e4bd835aee8c", "filename": "gcc/testsuite/gfortran.dg/do_1.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_1.f90?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -1,4 +1,5 @@\n-! { dg-do run }\n+! { dg-do run { xfail *-*-* } }\n+! XFAIL is tracked in PR 54932\n ! Program to check corner cases for DO statements.\n program do_1\n   implicit none"}, {"sha": "81bf09e9f8ab6a2a778902c495790565a8a1f05d", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 246, "deletions": 37, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -192,7 +192,7 @@ constant_after_peeling (tree op, gimple stmt, struct loop *loop)\n    Return results in SIZE, estimate benefits for complete unrolling exiting by EXIT.  */\n \n static void\n-tree_estimate_loop_size (struct loop *loop, edge exit, struct loop_size *size)\n+tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, struct loop_size *size)\n {\n   basic_block *body = get_loop_body (loop);\n   gimple_stmt_iterator gsi;\n@@ -208,8 +208,8 @@ tree_estimate_loop_size (struct loop *loop, edge exit, struct loop_size *size)\n     fprintf (dump_file, \"Estimating sizes for loop %i\\n\", loop->num);\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      if (exit && body[i] != exit->src\n-\t  && dominated_by_p (CDI_DOMINATORS, body[i], exit->src))\n+      if (edge_to_cancel && body[i] != edge_to_cancel->src\n+\t  && dominated_by_p (CDI_DOMINATORS, body[i], edge_to_cancel->src))\n \tafter_exit = true;\n       else\n \tafter_exit = false;\n@@ -231,7 +231,7 @@ tree_estimate_loop_size (struct loop *loop, edge exit, struct loop_size *size)\n \t  /* Look for reasons why we might optimize this stmt away. */\n \n \t  /* Exit conditional.  */\n-\t  if (body[i] == exit->src && stmt == last_stmt (exit->src))\n+\t  if (exit && body[i] == exit->src && stmt == last_stmt (exit->src))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"   Exit condition will be eliminated.\\n\");\n@@ -314,36 +314,161 @@ estimated_unrolled_size (struct loop_size *size,\n   return unr_insns;\n }\n \n+/* Loop LOOP is known to not loop.  See if there is an edge in the loop\n+   body that can be remove to make the loop to always exit and at\n+   the same time it does not make any code potentially executed \n+   during the last iteration dead.  \n+\n+   After complette unrolling we still may get rid of the conditional\n+   on the exit in the last copy even if we have no idea what it does.\n+   This is quite common case for loops of form\n+\n+     int a[5];\n+     for (i=0;i<b;i++)\n+       a[i]=0;\n+\n+   Here we prove the loop to iterate 5 times but we do not know\n+   it from induction variable.\n+\n+   For now we handle only simple case where there is exit condition\n+   just before the latch block and the latch block contains no statements\n+   with side effect that may otherwise terminate the execution of loop\n+   (such as by EH or by terminating the program or longjmp).\n+\n+   In the general case we may want to cancel the paths leading to statements\n+   loop-niter identified as having undefined effect in the last iteration.\n+   The other cases are hopefully rare and will be cleaned up later.  */\n+\n+edge\n+loop_edge_to_cancel (struct loop *loop)\n+{\n+  VEC (edge, heap) *exits;\n+  unsigned i;\n+  edge edge_to_cancel;\n+  gimple_stmt_iterator gsi;\n+\n+  /* We want only one predecestor of the loop.  */\n+  if (EDGE_COUNT (loop->latch->preds) > 1)\n+    return NULL;\n+\n+  exits = get_loop_exit_edges (loop);\n+\n+  FOR_EACH_VEC_ELT (edge, exits, i, edge_to_cancel)\n+    {\n+       /* Find the other edge than the loop exit\n+          leaving the conditoinal.  */\n+       if (EDGE_COUNT (edge_to_cancel->src->succs) != 2)\n+         continue;\n+       if (EDGE_SUCC (edge_to_cancel->src, 0) == edge_to_cancel)\n+         edge_to_cancel = EDGE_SUCC (edge_to_cancel->src, 1);\n+       else\n+         edge_to_cancel = EDGE_SUCC (edge_to_cancel->src, 0);\n+\n+      /* We should never have conditionals in the loop latch. */\n+      gcc_assert (edge_to_cancel->dest != loop->header);\n+\n+      /* Check that it leads to loop latch.  */\n+      if (edge_to_cancel->dest != loop->latch)\n+        continue;\n+\n+      VEC_free (edge, heap, exits);\n+\n+      /* Verify that the code in loop latch does nothing that may end program\n+         execution without really reaching the exit.  This may include\n+\t non-pure/const function calls, EH statements, volatile ASMs etc.  */\n+      for (gsi = gsi_start_bb (loop->latch); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif (gimple_has_side_effects (gsi_stmt (gsi)))\n+\t   return NULL;\n+      return edge_to_cancel;\n+    }\n+  VEC_free (edge, heap, exits);\n+  return NULL;\n+}\n+\n /* Tries to unroll LOOP completely, i.e. NITER times.\n    UL determines which loops we are allowed to unroll.\n-   EXIT is the exit of the loop that should be eliminated.  */\n+   EXIT is the exit of the loop that should be eliminated.  \n+   IRRED_INVALIDATED is used to bookkeep if information about\n+   irreducible regions may become invalid as a result\n+   of the transformation.  */\n \n static bool\n try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter,\n-\t\t\t    enum unroll_level ul)\n+\t\t\t    enum unroll_level ul,\n+\t\t\t    bool *irred_invalidated)\n {\n   unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   gimple cond;\n   struct loop_size size;\n+  bool n_unroll_found = false;\n+  HOST_WIDE_INT maxiter;\n+  basic_block latch;\n+  edge latch_edge;\n+  location_t locus;\n+  int flags;\n+  gimple stmt;\n+  gimple_stmt_iterator gsi;\n+  edge edge_to_cancel = NULL;\n+  int num = loop->num;\n \n-  if (loop->inner)\n-    return false;\n+  /* See if we proved number of iterations to be low constant.\n \n-  if (!host_integerp (niter, 1))\n+     EXIT is an edge that will be removed in all but last iteration of \n+     the loop.\n+\n+     EDGE_TO_CACNEL is an edge that will be removed from the last iteration\n+     of the unrolled sequence and is expected to make the final loop not\n+     rolling. \n+\n+     If the number of execution of loop is determined by standard induction\n+     variable test, then EXIT and EDGE_TO_CANCEL are the two edges leaving\n+     from the iv test.  */\n+  if (host_integerp (niter, 1))\n+    {\n+      n_unroll = tree_low_cst (niter, 1);\n+      n_unroll_found = true;\n+      edge_to_cancel = EDGE_SUCC (exit->src, 0);\n+      if (edge_to_cancel == exit)\n+\tedge_to_cancel = EDGE_SUCC (exit->src, 1);\n+    }\n+  /* We do not know the number of iterations and thus we can not eliminate\n+     the EXIT edge.  */\n+  else\n+    exit = NULL;\n+\n+  /* See if we can improve our estimate by using recorded loop bounds.  */\n+  maxiter = max_loop_iterations_int (loop);\n+  if (maxiter >= 0\n+      && (!n_unroll_found || (unsigned HOST_WIDE_INT)maxiter < n_unroll))\n+    {\n+      n_unroll = maxiter;\n+      n_unroll_found = true;\n+      /* Loop terminates before the IV variable test, so we can not\n+\t remove it in the last iteration.  */\n+      edge_to_cancel = NULL;\n+    }\n+\n+  if (!n_unroll_found)\n     return false;\n-  n_unroll = tree_low_cst (niter, 1);\n \n   max_unroll = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES);\n   if (n_unroll > max_unroll)\n     return false;\n \n+  if (!edge_to_cancel)\n+    edge_to_cancel = loop_edge_to_cancel (loop);\n+\n   if (n_unroll)\n     {\n+      sbitmap wont_exit;\n+      edge e;\n+      unsigned i;\n+      VEC (edge, heap) *to_remove = NULL;\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n-      tree_estimate_loop_size (loop, exit, &size);\n+      tree_estimate_loop_size (loop, exit, edge_to_cancel, &size);\n       ninsns = size.overall;\n \n       unr_insns = estimated_unrolled_size (&size, n_unroll);\n@@ -354,6 +479,18 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t   (int) unr_insns);\n \t}\n \n+      /* We unroll only inner loops, because we do not consider it profitable\n+\t otheriwse.  We still can cancel loopback edge of not rolling loop;\n+\t this is always a good idea.  */\n+      if (loop->inner && unr_insns > ninsns)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Not unrolling loop %d:\"\n+\t\t     \"it is not innermost and code would grow.\\n\",\n+\t\t     loop->num);\n+\t  return false;\n+\t}\n+\n       if (unr_insns > ninsns\n \t  && (unr_insns\n \t      > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS)))\n@@ -369,17 +506,10 @@ try_unroll_loop_completely (struct loop *loop,\n \t  && unr_insns > ninsns)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d.\\n\", loop->num);\n+\t    fprintf (dump_file, \"Not unrolling loop %d: size would grow.\\n\",\n+\t\t     loop->num);\n \t  return false;\n \t}\n-    }\n-\n-  if (n_unroll)\n-    {\n-      sbitmap wont_exit;\n-      edge e;\n-      unsigned i;\n-      VEC (edge, heap) *to_remove = NULL;\n \n       initialize_original_copy_tables ();\n       wont_exit = sbitmap_alloc (n_unroll + 1);\n@@ -408,15 +538,67 @@ try_unroll_loop_completely (struct loop *loop,\n       free_original_copy_tables ();\n     }\n \n-  cond = last_stmt (exit->src);\n-  if (exit->flags & EDGE_TRUE_VALUE)\n-    gimple_cond_make_true (cond);\n+  /* Remove the conditional from the last copy of the loop.  */\n+  if (edge_to_cancel)\n+    {\n+      cond = last_stmt (edge_to_cancel->src);\n+      if (edge_to_cancel->flags & EDGE_TRUE_VALUE)\n+\tgimple_cond_make_false (cond);\n+      else\n+\tgimple_cond_make_true (cond);\n+      update_stmt (cond);\n+      /* Do not remove the path. Doing so may remove outer loop\n+\t and confuse bookkeeping code in tree_unroll_loops_completelly.  */\n+    }\n+  /* We did not manage to cancel the loop.\n+     The loop latch remains reachable even if it will never be reached\n+     at runtime.  We must redirect it to somewhere, so create basic\n+     block containg __builtin_unreachable call for this reason.  */\n   else\n-    gimple_cond_make_false (cond);\n-  update_stmt (cond);\n+    {\n+      latch = loop->latch;\n+      latch_edge = loop_latch_edge (loop);\n+      flags = latch_edge->flags;\n+      locus = latch_edge->goto_locus;\n+\n+      /* Unloop destroys the latch edge.  */\n+      unloop (loop, irred_invalidated);\n+\n+      /* Create new basic block for the latch edge destination and wire\n+\t it in.  */\n+      stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n+      latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n+      latch_edge->probability = 0;\n+      latch_edge->count = 0;\n+      latch_edge->flags |= flags;\n+      latch_edge->goto_locus = locus;\n+\n+      latch_edge->dest->loop_father = current_loops->tree_root;\n+      latch_edge->dest->count = 0;\n+      latch_edge->dest->frequency = 0;\n+      set_immediate_dominator (CDI_DOMINATORS, latch_edge->dest, latch_edge->src);\n+\n+      gsi = gsi_start_bb (latch_edge->dest);\n+      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Unrolled loop %d completely.\\n\", loop->num);\n+    {\n+      if (!n_unroll)\n+        fprintf (dump_file, \"Turned loop %d to non-loop; it never loops.\\n\",\n+\t\t num);\n+      else\n+        fprintf (dump_file, \"Unrolled loop %d completely \"\n+\t\t \"(duplicated %i times).\\n\", num, (int)n_unroll);\n+      if (exit)\n+        fprintf (dump_file, \"Exit condition of peeled iterations was \"\n+\t\t \"eliminated.\\n\");\n+      if (edge_to_cancel)\n+        fprintf (dump_file, \"Last iteration exit edge was proved true.\\n\");\n+      else\n+        fprintf (dump_file, \"Latch of last iteration was marked by \"\n+\t\t \"__builtin_unreachable ().\\n\");\n+    }\n \n   return true;\n }\n@@ -425,12 +607,15 @@ try_unroll_loop_completely (struct loop *loop,\n    CREATE_IV is true if we may create a new iv.  UL determines\n    which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n    to determine the number of iterations of a loop by direct evaluation.\n-   Returns true if cfg is changed.  */\n+   Returns true if cfg is changed.  \n+\n+   IRRED_INVALIDATED is used to keep if irreducible reginos needs to be recomputed.  */\n \n static bool\n canonicalize_loop_induction_variables (struct loop *loop,\n \t\t\t\t       bool create_iv, enum unroll_level ul,\n-\t\t\t\t       bool try_eval)\n+\t\t\t\t       bool try_eval,\n+\t\t\t\t       bool *irred_invalidated)\n {\n   edge exit = NULL;\n   tree niter;\n@@ -455,22 +640,34 @@ canonicalize_loop_induction_variables (struct loop *loop,\n \t      || TREE_CODE (niter) != INTEGER_CST))\n \tniter = find_loop_niter_by_eval (loop, &exit);\n \n-      if (chrec_contains_undetermined (niter)\n-\t  || TREE_CODE (niter) != INTEGER_CST)\n-\treturn false;\n+      if (TREE_CODE (niter) != INTEGER_CST)\n+\texit = NULL;\n     }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  /* We work exceptionally hard here to estimate the bound\n+     by find_loop_niter_by_eval.  Be sure to keep it for future.  */\n+  if (niter && TREE_CODE (niter) == INTEGER_CST)\n+    record_niter_bound (loop, tree_to_double_int (niter), false, true);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && TREE_CODE (niter) == INTEGER_CST)\n     {\n       fprintf (dump_file, \"Loop %d iterates \", loop->num);\n       print_generic_expr (dump_file, niter, TDF_SLIM);\n       fprintf (dump_file, \" times.\\n\");\n     }\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && max_loop_iterations_int (loop) >= 0)\n+    {\n+      fprintf (dump_file, \"Loop %d iterates at most %i times.\\n\", loop->num,\n+\t       (int)max_loop_iterations_int (loop));\n+    }\n \n-  if (try_unroll_loop_completely (loop, exit, niter, ul))\n+  if (try_unroll_loop_completely (loop, exit, niter, ul, irred_invalidated))\n     return true;\n \n-  if (create_iv)\n+  if (create_iv\n+      && niter && !chrec_contains_undetermined (niter))\n     create_canonical_iv (loop, exit, niter);\n \n   return false;\n@@ -485,15 +682,21 @@ canonicalize_induction_variables (void)\n   loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n+  bool irred_invalidated = false;\n \n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       changed |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\ttrue, UL_SINGLE_ITER,\n-\t\t\t\t\t\t\ttrue);\n+\t\t\t\t\t\t\ttrue,\n+\t\t\t\t\t\t\t&irred_invalidated);\n     }\n   gcc_assert (!need_ssa_update_p (cfun));\n \n+  if (irred_invalidated\n+      && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n+    mark_irreducible_loops ();\n+\n   /* Clean up the information about numbers of iterations, since brute force\n      evaluation could reveal new information.  */\n   scev_reset ();\n@@ -594,9 +797,10 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n   do\n     {\n+      bool irred_invalidated = false;\n       changed = false;\n \n-      FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+      FOR_EACH_LOOP (li, loop, 0)\n \t{\n \t  struct loop *loop_father = loop_outer (loop);\n \n@@ -609,7 +813,8 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t    ul = UL_NO_GROWTH;\n \n \t  if (canonicalize_loop_induction_variables (loop, false, ul,\n-\t\t\t\t\t\t     !flag_tree_loop_ivcanon))\n+\t\t\t\t\t\t     !flag_tree_loop_ivcanon,\n+\t\t\t\t\t\t     &irred_invalidated))\n \t    {\n \t      changed = true;\n \t      /* If we'll continue unrolling, we need to propagate constants\n@@ -629,6 +834,10 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  struct loop **iter;\n \t  unsigned i;\n \n+\t  if (irred_invalidated\n+\t      && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n+\t    mark_irreducible_loops ();\n+\n \t  update_ssa (TODO_update_ssa);\n \n \t  /* Propagate the constants within the new basic blocks.  */"}, {"sha": "d974362de279d2d6b8921a56d2388a4682881b6c", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442c2fe0e28b96f0789d41132849b7c99402d4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b7442c2fe0e28b96f0789d41132849b7c99402d4", "patch": "@@ -9524,6 +9524,15 @@ build_common_builtin_nodes (void)\n   tree tmp, ftype;\n   int ecf_flags;\n \n+  if (!builtin_decl_explicit_p (BUILT_IN_UNREACHABLE))\n+    {\n+      ftype = build_function_type (void_type_node, void_list_node);\n+      local_define_builtin (\"__builtin_unreachable\", ftype, BUILT_IN_UNREACHABLE,\n+\t\t\t    \"__builtin_unreachable\",\n+\t\t\t    ECF_NOTHROW | ECF_LEAF | ECF_NORETURN\n+\t\t\t    | ECF_CONST | ECF_LEAF);\n+    }\n+\n   if (!builtin_decl_explicit_p (BUILT_IN_MEMCPY)\n       || !builtin_decl_explicit_p (BUILT_IN_MEMMOVE))\n     {"}]}