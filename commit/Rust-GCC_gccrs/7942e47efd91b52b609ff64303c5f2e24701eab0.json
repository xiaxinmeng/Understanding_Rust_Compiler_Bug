{"sha": "7942e47efd91b52b609ff64303c5f2e24701eab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0MmU0N2VmZDkxYjUyYjYwOWZmNjQzMDNjNWYyZTI0NzAxZWFiMA==", "commit": {"author": {"name": "Reza Yazdani", "email": "reza.yazdani@amd.com", "date": "2010-09-09T23:11:36Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-09-09T23:11:36Z"}, "message": "Dispatch scheduling for AMD Bulldozer processors.\n\n2010-09-09  Reza Yazdani  <reza.yazdani@amd.com>\n\n\t* config/i386/i386.c: Include sched-int.h.\n\t(TARGET_SCHED_DISPATCH): Defined.\n\t(TARGET_SCHED_DISPATCH_DO): Defined.\n\t(DISPATCH_WINDOW_SIZE): Defined.\n\t(MAX_DISPATCH_WINDOWS): Defined.\n\t(MAX_INSN): Defined.\n\t(MAX_IMM): Defined.\n\t(MAX_IMM_SIZE): Defined.\n\t(MAX_IMM_32): Defined.\n\t(MAX_IMM_64): Defined.\n\t(MAX_LOAD): Defined.\n\t(MAX_STORE): Defined.\n\t(BIG): Defined.\n\t(dispatch_group): New.\n\t(num_allowable_groups): New.\n\t(group_name): New.\n\t(sched_insn_info_s): New.\n\t(dispatch_windows_s): New.\n\t(imm_info_s): New.\n\t(dispatch_window_list): New.\n\t(dispatch_window_list1): New.\n\t(get_mem_group): New.\n\t(is_cmp): New.\n\t(dispatch_violation): New.\n\t(is_branch): New.\n\t(is_prefetch): New.\n\t(init_window): New.\n\t(allocate_window): New.\n\t(init_dispatch_sched): New.\n\t(is_end_basic_block): New.\n\t(process_end_window): New.\n\t(allocate_next_window): New.\n\t(find_constant_1): New.\n\t(find_constant): New.\n\t(get_num_immediates): New.\n\t(has_immediate): New.\n\t(get_insn_path): New.\n\t(get_insn_group): New.\n\t(count_num_restricted): New.\n\t(fits_dispatch_window): New.\n\t(add_insn_window): New.\n\t(add_to_dispatch_window): New.\n\t(debug_dispatch_window_file): New.\n\t(debug_dispatch_window): New.\n\t(debug_insn_dispatch_info_file): New.\n\t(debug_ready_dispatch): New.\n\t(do_dispatch): New.\n\t(has_dispatch): New.\n\t* config/i386/i386.h (debug_ready_dispatch): Declared.\n\t(debug_dispatch_window): Declared.\n\t* config/i386/i386.opt (mdispatch-scheduler): New flag.\n\t* doc/tm.texi.in (TARGET_SCHED_DISPATCH): New.\n\t(TARGET_SCHED_DISPATCH_DO): New.\n\t* doc/tm.texi: Regererated.\n\t* haifa-sched.c (choose_ready): Call targetm.sched.dispatch and\n\tready_remove_first_dispatch\n\t(schedule_block): Call targetm.sched.dispatch and\n\ttargetm.sched.dispatch_do.\n\t(sched_init): Call targetm.sched.dispatch and\n\ttargetm.sched.dispatch_do.\n\t(ready_remove_first_dispatch): New.\n\t(number_in_ready): New.\n\t(get_ready_element): New.\n\t* hooks.c (hook_bool_rtx_int_false): New.\n\t(hook_void_rtx_int): New.\n\t* hooks.h (hook_bool_rtx_int_false): Declared.\n\t(hook_void_rtx_int): Declared.\n\t* sched-int.h (IS_DISPATCH_ON): Defined.\n\t(IS_CMP): Defined.\n\t(DISPATCH_VIOLATION): Defined.\n\t(FITS_DISPATCH_WINDOW): Defined.\n\t(DISPATCH_INIT): Defined.\n\t(ADD_TO_DISPATCH_WINDOW): Defined.\n\t(get_ready_element): Declared.\n\t(number_in_ready): Declared.\n\t* target.def (dispatch): Defined.\n\t(dispatch_do): Defined.\n\nFrom-SVN: r164133", "tree": {"sha": "1454bef85bf406eb8a5c96db18f42d3f309e3f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1454bef85bf406eb8a5c96db18f42d3f309e3f46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7942e47efd91b52b609ff64303c5f2e24701eab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7942e47efd91b52b609ff64303c5f2e24701eab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7942e47efd91b52b609ff64303c5f2e24701eab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7942e47efd91b52b609ff64303c5f2e24701eab0/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be1c764ef44e1b2e1b04f49f24b699b3e2911c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1c764ef44e1b2e1b04f49f24b699b3e2911c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1c764ef44e1b2e1b04f49f24b699b3e2911c2f"}], "stats": {"total": 1038, "additions": 1036, "deletions": 2}, "files": [{"sha": "17a253afca7563d9258b9ff05ef3a28040c6d61e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -1,3 +1,83 @@\n+2010-09-09  Reza Yazdani  <reza.yazdani@amd.com>\n+\n+\t* config/i386/i386.c: Include sched-int.h.\n+\t(TARGET_SCHED_DISPATCH): Defined.\n+\t(TARGET_SCHED_DISPATCH_DO): Defined.\n+\t(DISPATCH_WINDOW_SIZE): Defined.\n+\t(MAX_DISPATCH_WINDOWS): Defined.\n+\t(MAX_INSN): Defined.\n+\t(MAX_IMM): Defined.\n+\t(MAX_IMM_SIZE): Defined.\n+\t(MAX_IMM_32): Defined.\n+\t(MAX_IMM_64): Defined.\n+\t(MAX_LOAD): Defined.\n+\t(MAX_STORE): Defined.\n+\t(BIG): Defined.\n+\t(dispatch_group): New.\n+\t(num_allowable_groups): New.\n+\t(group_name): New.\n+\t(sched_insn_info_s): New.\n+\t(dispatch_windows_s): New.\n+\t(imm_info_s): New.\n+\t(dispatch_window_list): New.\n+\t(dispatch_window_list1): New.\n+\t(get_mem_group): New.\n+\t(is_cmp): New.\n+\t(dispatch_violation): New.\n+\t(is_branch): New.\n+\t(is_prefetch): New.\n+\t(init_window): New.\n+\t(allocate_window): New.\n+\t(init_dispatch_sched): New.\n+\t(is_end_basic_block): New.\n+\t(process_end_window): New.\n+\t(allocate_next_window): New.\n+\t(find_constant_1): New.\n+\t(find_constant): New.\n+\t(get_num_immediates): New.\n+\t(has_immediate): New.\n+\t(get_insn_path): New.\n+\t(get_insn_group): New.\n+\t(count_num_restricted): New.\n+\t(fits_dispatch_window): New.\n+\t(add_insn_window): New.\n+\t(add_to_dispatch_window): New.\n+\t(debug_dispatch_window_file): New.\n+\t(debug_dispatch_window): New.\n+\t(debug_insn_dispatch_info_file): New.\n+\t(debug_ready_dispatch): New.\n+\t(do_dispatch): New.\n+\t(has_dispatch): New.\n+\t* config/i386/i386.h (debug_ready_dispatch): Declared.\n+\t(debug_dispatch_window): Declared.\n+\t* config/i386/i386.opt (mdispatch-scheduler): New flag.\n+\t* doc/tm.texi.in (TARGET_SCHED_DISPATCH): New.\n+\t(TARGET_SCHED_DISPATCH_DO): New.\n+\t* doc/tm.texi: Regererated.\n+\t* haifa-sched.c (choose_ready): Call targetm.sched.dispatch and\n+\tready_remove_first_dispatch\n+\t(schedule_block): Call targetm.sched.dispatch and\n+\ttargetm.sched.dispatch_do.\n+\t(sched_init): Call targetm.sched.dispatch and\n+\ttargetm.sched.dispatch_do.\n+\t(ready_remove_first_dispatch): New.\n+\t(number_in_ready): New.\n+\t(get_ready_element): New.\n+\t* hooks.c (hook_bool_rtx_int_false): New.\n+\t(hook_void_rtx_int): New.\n+\t* hooks.h (hook_bool_rtx_int_false): Declared.\n+\t(hook_void_rtx_int): Declared.\n+\t* sched-int.h (IS_DISPATCH_ON): Defined.\n+\t(IS_CMP): Defined.\n+\t(DISPATCH_VIOLATION): Defined.\n+\t(FITS_DISPATCH_WINDOW): Defined.\n+\t(DISPATCH_INIT): Defined.\n+\t(ADD_TO_DISPATCH_WINDOW): Defined.\n+\t(get_ready_element): Declared.\n+\t(number_in_ready): Declared.\n+\t* target.def (dispatch): Defined.\n+\t(dispatch_do): Defined.\n+\n 2010-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/45312"}, {"sha": "1d79a18b93a04a1b4a833dbb9211d8dc3bdb42c5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 801, "deletions": 1, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cselib.h\"\n #include \"debug.h\"\n #include \"dwarf2out.h\"\n-\n+#include \"sched-int.h\"\n static rtx legitimize_dllimport_symbol (rtx, bool);\n \n #ifndef CHECK_STACK_LIMIT\n@@ -31534,6 +31534,806 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n   return 0;\n }\n \n+#undef TARGET_SCHED_DISPATCH\n+#define TARGET_SCHED_DISPATCH has_dispatch\n+#undef TARGET_SCHED_DISPATCH_DO\n+#define TARGET_SCHED_DISPATCH_DO do_dispatch\n+\n+/* The size of the dispatch window is the total number of bytes of\n+   object code allowed in a window.  */\n+#define DISPATCH_WINDOW_SIZE 16\n+\n+/* Number of dispatch windows considered for scheduling.  */\n+#define MAX_DISPATCH_WINDOWS 3\n+\n+/* Maximum number of instructions in a window.  */\n+#define MAX_INSN 4\n+\n+/* Maximum number of immediate operands in a window.  */\n+#define MAX_IMM 4\n+\n+/* Maximum number of immediate bits allowed in a window.  */\n+#define MAX_IMM_SIZE 128\n+\n+/* Maximum number of 32 bit immediates allowed in a window.  */\n+#define MAX_IMM_32 4\n+\n+/* Maximum number of 64 bit immediates allowed in a window.  */\n+#define MAX_IMM_64 2\n+\n+/* Maximum total of loads or prefetches allowed in a window.  */\n+#define MAX_LOAD 2\n+\n+/* Maximum total of stores allowed in a window.  */\n+#define MAX_STORE 1\n+\n+#undef BIG\n+#define BIG 100\n+\n+\n+/* Dispatch groups.  Istructions that affect the mix in a dispatch window.  */\n+enum dispatch_group {\n+  disp_no_group = 0,\n+  disp_load,\n+  disp_store,\n+  disp_load_store,\n+  disp_prefetch,\n+  disp_imm,\n+  disp_imm_32,\n+  disp_imm_64,\n+  disp_branch,\n+  disp_cmp,\n+  disp_jcc,\n+  disp_last\n+};\n+\n+/* Number of allowable groups in a dispatch window.  It is an array\n+   indexed by dispatch_group enum.  100 is used as a big number,\n+   because the number of these kind of operations does not have any\n+   effect in dispatch window, but we need them for other reasons in\n+   the table.  */\n+static unsigned int num_allowable_groups[disp_last] = {\n+  0, 2, 1, 1, 2, 4, 4, 2, 1, BIG, BIG\n+};\n+\n+char group_name[disp_last + 1][16] = {\n+  \"disp_no_group\", \"disp_load\", \"disp_store\", \"disp_load_store\",\n+  \"disp_prefetch\", \"disp_imm\", \"disp_imm_32\", \"disp_imm_64\",\n+  \"disp_branch\", \"disp_cmp\", \"disp_jcc\", \"disp_last\"\n+};\n+\n+/* Instruction path.  */\n+enum insn_path {\n+  no_path = 0,\n+  path_single, /* Single micro op.  */\n+  path_double, /* Double micro op.  */\n+  path_multi,  /* Instructions with more than 2 micro op..  */\n+  last_path\n+};\n+\n+/* sched_insn_info defines a window to the instructions scheduled in\n+   the basic block.  It contains a pointer to the insn_info table and\n+   the instruction scheduled.\n+\n+   Windows are allocated for each basic block and are linked\n+   together.  */\n+typedef struct sched_insn_info_s {\n+  rtx insn;\n+  enum dispatch_group group;\n+  enum insn_path path;\n+  int byte_len;\n+  int imm_bytes;\n+} sched_insn_info;\n+\n+/* Linked list of dispatch windows.  This is a two way list of\n+   dispatch windows of a basic block.  It contains information about\n+   the number of uops in the window and the total number of\n+   instructions and of bytes in the object code for this dispatch\n+   window.  */\n+typedef struct dispatch_windows_s {\n+  int num_insn;            /* Number of insn in the window.  */\n+  int num_uops;            /* Number of uops in the window.  */\n+  int window_size;         /* Number of bytes in the window.  */\n+  int window_num;          /* Window number between 0 or 1.  */\n+  int num_imm;             /* Number of immediates in an insn.  */\n+  int num_imm_32;          /* Number of 32 bit immediates in an insn.  */\n+  int num_imm_64;          /* Number of 64 bit immediates in an insn.  */\n+  int imm_size;            /* Total immediates in the window.  */\n+  int num_loads;           /* Total memory loads in the window.  */\n+  int num_stores;          /* Total memory stores in the window.  */\n+  int violation;          /* Violation exists in window.  */\n+  sched_insn_info *window; /* Pointer to the window.  */\n+  struct dispatch_windows_s *next;\n+  struct dispatch_windows_s *prev;\n+} dispatch_windows;\n+\n+/* Immediate valuse used in an insn.  */\n+typedef struct imm_info_s\n+  {\n+    int imm;\n+    int imm32;\n+    int imm64;\n+  } imm_info;\n+\n+static dispatch_windows *dispatch_window_list;\n+static dispatch_windows *dispatch_window_list1;\n+\n+/* Get dispatch group of insn.  */\n+\n+static enum dispatch_group\n+get_mem_group (rtx insn)\n+{\n+  enum attr_memory memory;\n+\n+  if (INSN_CODE (insn) < 0)\n+    return disp_no_group;\n+  memory = get_attr_memory (insn);\n+  if (memory == MEMORY_STORE)\n+    return disp_store;\n+\n+  if (memory == MEMORY_LOAD)\n+    return disp_load;\n+\n+  if (memory == MEMORY_BOTH)\n+    return disp_load_store;\n+\n+  return disp_no_group;\n+}\n+\n+/* Return true if insn is a compare instruction.  */\n+\n+static bool\n+is_cmp (rtx insn)\n+{\n+  enum attr_type type;\n+\n+  type = get_attr_type (insn);\n+  return (type == TYPE_TEST\n+\t  || type == TYPE_ICMP\n+\t  || type == TYPE_FCMP\n+\t  || GET_CODE (PATTERN (insn)) == COMPARE);\n+}\n+\n+/* Return true if a dispatch violation encountered.  */\n+\n+static bool\n+dispatch_violation (void)\n+{\n+  if (dispatch_window_list->next)\n+    return dispatch_window_list->next->violation;\n+  return dispatch_window_list->violation;\n+}\n+\n+/* Return true if insn is a branch instruction.  */\n+\n+static bool\n+is_branch (rtx insn)\n+{\n+  return (CALL_P (insn) || JUMP_P (insn));\n+}\n+\n+/* Return true if insn is a prefetch instruction.  */\n+\n+static bool\n+is_prefetch (rtx insn)\n+{\n+  return NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == PREFETCH;\n+}\n+\n+/* This function initializes a dispatch window and the list container holding a\n+   pointer to the window.  */\n+\n+static void\n+init_window (int window_num)\n+{\n+  int i;\n+  dispatch_windows *new_list;\n+\n+  if (window_num == 0)\n+    new_list = dispatch_window_list;\n+  else\n+    new_list = dispatch_window_list1;\n+\n+  new_list->num_insn = 0;\n+  new_list->num_uops = 0;\n+  new_list->window_size = 0;\n+  new_list->next = NULL;\n+  new_list->prev = NULL;\n+  new_list->window_num = window_num;\n+  new_list->num_imm = 0;\n+  new_list->num_imm_32 = 0;\n+  new_list->num_imm_64 = 0;\n+  new_list->imm_size = 0;\n+  new_list->num_loads = 0;\n+  new_list->num_stores = 0;\n+  new_list->violation = false;\n+\n+  for (i = 0; i < MAX_INSN; i++)\n+    {\n+      new_list->window[i].insn = NULL;\n+      new_list->window[i].group = disp_no_group;\n+      new_list->window[i].path = no_path;\n+      new_list->window[i].byte_len = 0;\n+      new_list->window[i].imm_bytes = 0;\n+    }\n+  return;\n+}\n+\n+/* This function allocates and initializes a dispatch window and the\n+   list container holding a pointer to the window.  */\n+\n+static dispatch_windows *\n+allocate_window (void)\n+{\n+  dispatch_windows *new_list = XNEW (struct dispatch_windows_s);\n+  new_list->window = XNEWVEC (struct sched_insn_info_s, MAX_INSN + 1);\n+\n+  return new_list;\n+}\n+\n+/* This routine initializes the dispatch scheduling information.  It\n+   initiates building dispatch scheduler tables and constructs the\n+   first dispatch window.  */\n+\n+static void\n+init_dispatch_sched (void)\n+{\n+  /* Allocate a dispatch list and a window.  */\n+  dispatch_window_list = allocate_window ();\n+  dispatch_window_list1 = allocate_window ();\n+  init_window (0);\n+  init_window (1);\n+}\n+\n+/* This function returns true if a branch is detected.  End of a basic block\n+   does not have to be a branch, but here we assume only branches end a\n+   window.  */\n+\n+static bool\n+is_end_basic_block (enum dispatch_group group)\n+{\n+  return group == disp_branch;\n+}\n+\n+/* This function is called when the end of a window processing is reached.  */\n+\n+static void\n+process_end_window (void)\n+{\n+  gcc_assert (dispatch_window_list->num_insn <= MAX_INSN);\n+  if (dispatch_window_list->next)\n+    {\n+      gcc_assert (dispatch_window_list1->num_insn <= MAX_INSN);\n+      gcc_assert (dispatch_window_list->window_size\n+\t\t  + dispatch_window_list1->window_size <= 48);\n+      init_window (1);\n+    }\n+  init_window (0);\n+}\n+\n+/* Allocates a new dispatch window and adds it to WINDOW_LIST.\n+   WINDOW_NUM is either 0 or 1.  A maximum of two windows are generated\n+   for 48 bytes of instructions.  Note that these windows are not dispatch\n+   windows that their sizes are DISPATCH_WINDOW_SIZE.  */\n+\n+static dispatch_windows *\n+allocate_next_window (int window_num)\n+{\n+  if (window_num == 0)\n+    {\n+      if (dispatch_window_list->next)\n+\t  init_window (1);\n+      init_window (0);\n+      return dispatch_window_list;\n+    }\n+\n+  dispatch_window_list->next = dispatch_window_list1;\n+  dispatch_window_list1->prev = dispatch_window_list;\n+\n+  return dispatch_window_list1;\n+}\n+\n+/* Increment the number of immediate operands of an instruction.  */\n+\n+static int\n+find_constant_1 (rtx *in_rtx, imm_info *imm_values)\n+{\n+  if (*in_rtx == 0)\n+    return 0;\n+\n+    switch ( GET_CODE (*in_rtx))\n+    {\n+    case CONST:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+      (imm_values->imm)++;\n+      if (x86_64_immediate_operand (*in_rtx, SImode))\n+\t(imm_values->imm32)++;\n+      else\n+\t(imm_values->imm64)++;\n+      break;\n+\n+    case CONST_DOUBLE:\n+      (imm_values->imm)++;\n+      (imm_values->imm64)++;\n+      break;\n+\n+    case CODE_LABEL:\n+      if (LABEL_KIND (*in_rtx) == LABEL_NORMAL)\n+\t{\n+\t  (imm_values->imm)++;\n+\t  (imm_values->imm32)++;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Compute number of immediate operands of an instruction.  */\n+\n+static void\n+find_constant (rtx in_rtx, imm_info *imm_values)\n+{\n+  for_each_rtx (INSN_P (in_rtx) ? &PATTERN (in_rtx) : &in_rtx,\n+\t\t(rtx_function) find_constant_1, (void *) imm_values);\n+}\n+\n+/* Return total size of immediate operands of an instruction along with number\n+   of corresponding immediate-operands.  It initializes its parameters to zero\n+   befor calling FIND_CONSTANT.\n+   INSN is the input instruction.  IMM is the total of immediates.\n+   IMM32 is the number of 32 bit immediates.  IMM64 is the number of 64\n+   bit immediates.  */\n+\n+static int\n+get_num_immediates (rtx insn, int *imm, int *imm32, int *imm64)\n+{\n+  imm_info imm_values = {0, 0, 0};\n+\n+  find_constant (insn, &imm_values);\n+  *imm = imm_values.imm;\n+  *imm32 = imm_values.imm32;\n+  *imm64 = imm_values.imm64;\n+  return imm_values.imm32 * 4 + imm_values.imm64 * 8;\n+}\n+\n+/* This function indicates if an operand of an instruction is an\n+   immediate.  */\n+\n+static bool\n+has_immediate (rtx insn)\n+{\n+  int num_imm_operand;\n+  int num_imm32_operand;\n+  int num_imm64_operand;\n+\n+  if (insn)\n+    return get_num_immediates (insn, &num_imm_operand, &num_imm32_operand,\n+\t\t\t       &num_imm64_operand);\n+  return false;\n+}\n+\n+/* Return single or double path for instructions.  */\n+\n+static enum insn_path\n+get_insn_path (rtx insn)\n+{\n+  enum attr_amdfam10_decode path = get_attr_amdfam10_decode (insn);\n+\n+  if ((int)path == 0)\n+    return path_single;\n+\n+  if ((int)path == 1)\n+    return path_double;\n+\n+  return path_multi;\n+}\n+\n+/* Return insn dispatch group.  */\n+\n+static enum dispatch_group\n+get_insn_group (rtx insn)\n+{\n+  enum dispatch_group group = get_mem_group (insn);\n+  if (group)\n+    return group;\n+\n+  if (is_branch (insn))\n+    return disp_branch;\n+\n+  if (is_cmp (insn))\n+    return disp_cmp;\n+\n+  if (has_immediate (insn))\n+    return disp_imm;\n+\n+  if (is_prefetch (insn))\n+    return disp_prefetch;\n+\n+  return disp_no_group;\n+}\n+\n+/* Count number of GROUP restricted instructions in a dispatch\n+   window WINDOW_LIST.  */\n+\n+static int\n+count_num_restricted (rtx insn, dispatch_windows *window_list)\n+{\n+  enum dispatch_group group = get_insn_group (insn);\n+  int imm_size;\n+  int num_imm_operand;\n+  int num_imm32_operand;\n+  int num_imm64_operand;\n+\n+  if (group == disp_no_group)\n+    return 0;\n+\n+  if (group == disp_imm)\n+    {\n+      imm_size = get_num_immediates (insn, &num_imm_operand, &num_imm32_operand,\n+\t\t\t      &num_imm64_operand);\n+      if (window_list->imm_size + imm_size > MAX_IMM_SIZE\n+\t  || num_imm_operand + window_list->num_imm > MAX_IMM\n+\t  || (num_imm32_operand > 0\n+\t      && (window_list->num_imm_32 + num_imm32_operand > MAX_IMM_32\n+\t\t  || window_list->num_imm_64 * 2 + num_imm32_operand > MAX_IMM_32))\n+\t  || (num_imm64_operand > 0\n+\t      && (window_list->num_imm_64 + num_imm64_operand > MAX_IMM_64\n+\t\t  || window_list->num_imm_32 + num_imm64_operand * 2 > MAX_IMM_32))\n+\t  || (window_list->imm_size + imm_size == MAX_IMM_SIZE\n+\t      && num_imm64_operand > 0\n+\t      && ((window_list->num_imm_64 > 0\n+\t\t   && window_list->num_insn >= 2)\n+\t\t  || window_list->num_insn >= 3)))\n+\treturn BIG;\n+\n+      return 1;\n+    }\n+\n+  if ((group == disp_load_store\n+       && (window_list->num_loads >= MAX_LOAD\n+\t   || window_list->num_stores >= MAX_STORE))\n+      || ((group == disp_load\n+\t   || group == disp_prefetch)\n+\t  && window_list->num_loads >= MAX_LOAD)\n+      || (group == disp_store\n+\t  && window_list->num_stores >= MAX_STORE))\n+    return BIG;\n+\n+  return 1;\n+}\n+\n+/* This function returns true if insn satisfies dispatch rules on the\n+   last window scheduled.  */\n+\n+static bool\n+fits_dispatch_window (rtx insn)\n+{\n+  dispatch_windows *window_list = dispatch_window_list;\n+  dispatch_windows *window_list_next = dispatch_window_list->next;\n+  unsigned int num_restrict;\n+  enum dispatch_group group = get_insn_group (insn);\n+  enum insn_path path = get_insn_path (insn);\n+  int sum;\n+\n+  /* Make disp_cmp and disp_jcc get scheduled at the latest.  These\n+     instructions should be given the lowest priority in the\n+     scheduling process in Haifa scheduler to make sure they will be\n+     scheduled in the same dispatch window as the refrence to them.  */\n+  if (group == disp_jcc || group == disp_cmp)\n+    return false;\n+\n+  /* Check nonrestricted.  */\n+  if (group == disp_no_group || group == disp_branch)\n+    return true;\n+\n+  /* Get last dispatch window.  */\n+  if (window_list_next)\n+    window_list = window_list_next;\n+\n+  if (window_list->window_num == 1)\n+    {\n+      sum = window_list->prev->window_size + window_list->window_size;\n+\n+      if (sum == 32\n+\t  || (min_insn_size (insn) + sum) >= 48)\n+\t/* Window 1 is full.  Go for next window.  */\n+\treturn true;\n+    }\n+\n+  num_restrict = count_num_restricted (insn, window_list);\n+\n+  if (num_restrict > num_allowable_groups[group])\n+    return false;\n+\n+  /* See if it fits in the first window.  */\n+  if (window_list->window_num == 0)\n+    {\n+      /* The first widow should have only single and double path\n+\t uops.  */\n+      if (path == path_double\n+\t  && (window_list->num_uops + 2) > MAX_INSN)\n+\treturn false;\n+      else if (path != path_single)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* Add an instruction INSN with NUM_UOPS micro-operations to the\n+   dispatch window WINDOW_LIST.  */\n+\n+static void\n+add_insn_window (rtx insn, dispatch_windows *window_list, int num_uops)\n+{\n+  int byte_len = min_insn_size (insn);\n+  int num_insn = window_list->num_insn;\n+  int imm_size;\n+  sched_insn_info *window = window_list->window;\n+  enum dispatch_group group = get_insn_group (insn);\n+  enum insn_path path = get_insn_path (insn);\n+  int num_imm_operand;\n+  int num_imm32_operand;\n+  int num_imm64_operand;\n+\n+  if (!window_list->violation && group != disp_cmp\n+      && !fits_dispatch_window (insn))\n+    window_list->violation = true;\n+\n+  imm_size = get_num_immediates (insn, &num_imm_operand, &num_imm32_operand,\n+\t\t\t\t &num_imm64_operand);\n+\n+  /* Initialize window with new instruction.  */\n+  window[num_insn].insn = insn;\n+  window[num_insn].byte_len = byte_len;\n+  window[num_insn].group = group;\n+  window[num_insn].path = path;\n+  window[num_insn].imm_bytes = imm_size;\n+\n+  window_list->window_size += byte_len;\n+  window_list->num_insn = num_insn + 1;\n+  window_list->num_uops = window_list->num_uops + num_uops;\n+  window_list->imm_size += imm_size;\n+  window_list->num_imm += num_imm_operand;\n+  window_list->num_imm_32 += num_imm32_operand;\n+  window_list->num_imm_64 += num_imm64_operand;\n+\n+  if (group == disp_store)\n+    window_list->num_stores += 1;\n+  else if (group == disp_load\n+\t   || group == disp_prefetch)\n+    window_list->num_loads += 1;\n+  else if (group == disp_load_store)\n+    {\n+      window_list->num_stores += 1;\n+      window_list->num_loads += 1;\n+    }\n+}\n+\n+/* Adds a scheduled instruction, INSN, to the current dispatch window.\n+   If the total bytes of instructions or the number of instructions in\n+   the window exceed allowable, it allocates a new window.  */\n+\n+static void\n+add_to_dispatch_window (rtx insn)\n+{\n+  int byte_len;\n+  dispatch_windows *window_list;\n+  dispatch_windows *next_list;\n+  dispatch_windows *window0_list;\n+  enum insn_path path;\n+  enum dispatch_group insn_group;\n+  bool insn_fits;\n+  int num_insn;\n+  int num_uops;\n+  int window_num;\n+  int insn_num_uops;\n+  int sum;\n+\n+  if (INSN_CODE (insn) < 0)\n+    return;\n+\n+  byte_len = min_insn_size (insn);\n+  window_list = dispatch_window_list;\n+  next_list = window_list->next;\n+  path = get_insn_path (insn);\n+  insn_group = get_insn_group (insn);\n+\n+  /* Get the last dispatch window.  */\n+  if (next_list)\n+      window_list = dispatch_window_list->next;\n+\n+  if (path == path_single)\n+    insn_num_uops = 1;\n+  else if (path == path_double)\n+    insn_num_uops = 2;\n+  else\n+    insn_num_uops = (int) path;\n+\n+  /* If current window is full, get a new window.\n+     Window number zero is full, if MAX_INSN uops are scheduled in it.\n+     Window number one is full, if window zero's bytes plus window\n+     one's bytes is 32, or if the bytes of the new instruction added\n+     to the total makes it greater than 48, or it has already MAX_INSN\n+     instructions in it.  */\n+  num_insn = window_list->num_insn;\n+  num_uops = window_list->num_uops;\n+  window_num = window_list->window_num;\n+  insn_fits = fits_dispatch_window (insn);\n+\n+  if (num_insn >= MAX_INSN\n+      || num_uops + insn_num_uops > MAX_INSN\n+      || !(insn_fits))\n+    {\n+      window_num = ~window_num & 1;\n+      window_list = allocate_next_window (window_num);\n+    }\n+\n+  if (window_num == 0)\n+    {\n+      add_insn_window (insn, window_list, insn_num_uops);\n+      if (window_list->num_insn >= MAX_INSN\n+\t  && insn_group == disp_branch)\n+\t{\n+\t  process_end_window ();\n+\t  return;\n+\t}\n+    }\n+  else if (window_num == 1)\n+    {\n+      window0_list = window_list->prev;\n+      sum = window0_list->window_size + window_list->window_size;\n+      if (sum == 32\n+\t  || (byte_len + sum) >= 48)\n+\t{\n+\t  process_end_window ();\n+\t  window_list = dispatch_window_list;\n+\t}\n+\n+      add_insn_window (insn, window_list, insn_num_uops);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  if (is_end_basic_block (insn_group))\n+    {\n+      /* End of basic block is reached do end-basic-block process.  */\n+      process_end_window ();\n+      return;\n+    }\n+}\n+\n+/* Print the dispatch window, WINDOW_NUM, to FILE.  */\n+\n+DEBUG_FUNCTION static void\n+debug_dispatch_window_file (FILE *file, int window_num)\n+{\n+  dispatch_windows *list;\n+  int i;\n+\n+  if (window_num == 0)\n+    list = dispatch_window_list;\n+  else\n+    list = dispatch_window_list1;\n+\n+  fprintf (file, \"Window #%d:\\n\", list->window_num);\n+  fprintf (file, \"  num_insn = %d, num_uops = %d, window_size = %d\\n\",\n+\t  list->num_insn, list->num_uops, list->window_size);\n+  fprintf (file, \"  num_imm = %d, num_imm_32 = %d, num_imm_64 = %d, imm_size = %d\\n\",\n+\t   list->num_imm, list->num_imm_32, list->num_imm_64, list->imm_size);\n+\n+  fprintf (file, \"  num_loads = %d, num_stores = %d\\n\", list->num_loads,\n+\t  list->num_stores);\n+  fprintf (file, \" insn info:\\n\");\n+\n+  for (i = 0; i < MAX_INSN; i++)\n+    {\n+      if (!list->window[i].insn)\n+\tbreak;\n+      fprintf (file, \"    group[%d] = %s, insn[%d] = %p, path[%d] = %d byte_len[%d] = %d, imm_bytes[%d] = %d\\n\",\n+\t      i, group_name[list->window[i].group],\n+\t      i, (void *)list->window[i].insn,\n+\t      i, list->window[i].path,\n+\t      i, list->window[i].byte_len,\n+\t      i, list->window[i].imm_bytes);\n+    }\n+}\n+\n+/* Print to stdout a dispatch window.  */\n+\n+DEBUG_FUNCTION void\n+debug_dispatch_window (int window_num)\n+{\n+  debug_dispatch_window_file (stdout, window_num);\n+}\n+\n+/* Print INSN dispatch information to FILE.  */\n+\n+DEBUG_FUNCTION static void\n+debug_insn_dispatch_info_file (FILE *file, rtx insn)\n+{\n+  int byte_len;\n+  enum insn_path path;\n+  enum dispatch_group group;\n+  int imm_size;\n+  int num_imm_operand;\n+  int num_imm32_operand;\n+  int num_imm64_operand;\n+\n+  if (INSN_CODE (insn) < 0)\n+    return;\n+\n+  byte_len = min_insn_size (insn);\n+  path = get_insn_path (insn);\n+  group = get_insn_group (insn);\n+  imm_size = get_num_immediates (insn, &num_imm_operand, &num_imm32_operand,\n+\t\t\t\t &num_imm64_operand);\n+\n+  fprintf (file, \" insn info:\\n\");\n+  fprintf (file, \"  group = %s, path = %d, byte_len = %d\\n\",\n+\t   group_name[group], path, byte_len);\n+  fprintf (file, \"  num_imm = %d, num_imm_32 = %d, num_imm_64 = %d, imm_size = %d\\n\",\n+\t   num_imm_operand, num_imm32_operand, num_imm64_operand, imm_size);\n+}\n+\n+/* Print to STDERR the status of the ready list with respect to\n+   dispatch windows.  */\n+\n+DEBUG_FUNCTION void\n+debug_ready_dispatch (void)\n+{\n+  int i;\n+  int no_ready = number_in_ready ();\n+\n+  fprintf (stdout, \"Number of ready: %d\\n\", no_ready);\n+\n+  for (i = 0; i < no_ready; i++)\n+    debug_insn_dispatch_info_file (stdout, get_ready_element (i));\n+}\n+\n+/* This routine is the driver of the dispatch scheduler.  */\n+\n+static void\n+do_dispatch (rtx insn, int mode)\n+{\n+  if (mode == DISPATCH_INIT)\n+    init_dispatch_sched ();\n+  else if (mode == ADD_TO_DISPATCH_WINDOW)\n+    add_to_dispatch_window (insn);\n+}\n+\n+/* Return TRUE if Dispatch Scheduling is supported.  */\n+\n+static bool\n+has_dispatch (rtx insn, int action)\n+{\n+  if (ix86_tune == PROCESSOR_BDVER1 && flag_dispatch_scheduler)\n+    switch (action)\n+      {\n+      default:\n+\treturn false;\n+\n+      case IS_DISPATCH_ON:\n+\treturn true;\n+\tbreak;\n+\n+      case IS_CMP:\n+\treturn is_cmp (insn);\n+\n+      case DISPATCH_VIOLATION:\n+\treturn dispatch_violation ();\n+\n+      case FITS_DISPATCH_WINDOW:\n+\treturn fits_dispatch_window (insn);\n+      }\n+\n+  return false;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory"}, {"sha": "91238d5d7c7ce45c86ebe0a9c51661bfdc20b5ad", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -2375,6 +2375,9 @@ struct GTY(()) machine_function {\n #define SYMBOL_REF_DLLEXPORT_P(X) \\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)\n \n+extern void debug_ready_dispatch (void);\n+extern void debug_dispatch_window (int);\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "5790e7675115b26a7c2b4f820b5a9da3cd54ed04", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -254,6 +254,11 @@ Enable automatic generation of fused floating point multiply-add instructions\n if the ISA supports such instructions.  The -mfused-madd option is on by\n default.\n \n+mdispatch-scheduler\n+Target RejectNegative Var(flag_dispatch_scheduler)\n+Do dispatch scheduling if processor is bdver1 and Haifa scheduling\n+is selected.\n+\n ;; ISA support\n \n m32"}, {"sha": "91fbaf7a893ff8ca2e277baa46761eac7b9f4f54", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -6777,6 +6777,16 @@ bound will be used in case this hook is not implemented: the total number\n of instructions divided by the issue rate.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SCHED_DISPATCH (rtx @var{insn}, int @var{x})\n+This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling\n+is supported in hardware and the condition specified in the parameter is true.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_DISPATCH_DO (rtx @var{insn}, int @var{x})\n+This hook is called by Haifa Scheduler.  It performs the operation specified\n+in its second parameter.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "a180a56c9ab7b9bc931b526257bec8cee0f8ad62", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -6777,6 +6777,16 @@ bound will be used in case this hook is not implemented: the total number\n of instructions divided by the issue rate.\n @end deftypefn\n \n+@hook TARGET_SCHED_DISPATCH\n+This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling\n+is supported in hardware and the condition specified in the parameter is true.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_DISPATCH_DO\n+This hook is called by Haifa Scheduler.  It performs the operation specified\n+in its second parameter.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "5b5459f7caed42a94bb342fd2fc11119793ec610", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -532,6 +532,7 @@ static void extend_h_i_d (void);\n \n static void ready_add (struct ready_list *, rtx, bool);\n static rtx ready_remove_first (struct ready_list *);\n+static rtx ready_remove_first_dispatch (struct ready_list *ready);\n \n static void queue_to_ready (struct ready_list *);\n static int early_queue_to_ready (state_t, struct ready_list *);\n@@ -2642,7 +2643,11 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n   if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0))\n       || DEBUG_INSN_P (ready_element (ready, 0)))\n     {\n-      *insn_ptr = ready_remove_first (ready);\n+      if (targetm.sched.dispatch (NULL_RTX, IS_DISPATCH_ON))\n+\t*insn_ptr = ready_remove_first_dispatch (ready);\n+      else\n+\t*insn_ptr = ready_remove_first (ready);\n+\n       return 0;\n     }\n   else\n@@ -3140,6 +3145,10 @@ schedule_block (basic_block *target_bb)\n \t\t\t\t\t\t       last_scheduled_insn);\n \n \t  move_insn (insn, last_scheduled_insn, current_sched_info->next_tail);\n+\n+\t  if (targetm.sched.dispatch (NULL_RTX, IS_DISPATCH_ON))\n+\t    targetm.sched.dispatch_do (insn, ADD_TO_DISPATCH_WINDOW);\n+\n \t  reemit_notes (insn);\n \t  last_scheduled_insn = insn;\n \n@@ -3364,8 +3373,12 @@ sched_init (void)\n   flag_schedule_speculative_load = 0;\n #endif\n \n+  if (targetm.sched.dispatch (NULL_RTX, IS_DISPATCH_ON))\n+    targetm.sched.dispatch_do (NULL_RTX, DISPATCH_INIT);\n+\n   sched_pressure_p = (flag_sched_pressure && ! reload_completed\n \t\t      && common_sched_info->sched_pass_id == SCHED_RGN_PASS);\n+\n   if (sched_pressure_p)\n     ira_setup_eliminable_regset ();\n \n@@ -5557,4 +5570,73 @@ sched_emit_insn (rtx pat)\n   return insn;\n }\n \n+/* This function returns a candidate satisfying dispatch constraints from\n+   the ready list.  */\n+\n+static rtx\n+ready_remove_first_dispatch (struct ready_list *ready)\n+{\n+  int i;\n+  rtx insn = ready_element (ready, 0);\n+\n+  if (ready->n_ready == 1\n+      || INSN_CODE (insn) < 0\n+      || !INSN_P (insn)\n+      || !active_insn_p (insn)\n+      || targetm.sched.dispatch (insn, FITS_DISPATCH_WINDOW))\n+    return ready_remove_first (ready);\n+\n+  for (i = 1; i < ready->n_ready; i++)\n+    {\n+      insn = ready_element (ready, i);\n+\n+      if (INSN_CODE (insn) < 0\n+\t  || !INSN_P (insn)\n+\t  || !active_insn_p (insn))\n+\tcontinue;\n+\n+      if (targetm.sched.dispatch (insn, FITS_DISPATCH_WINDOW))\n+\t{\n+\t  /* Return ith element of ready.  */\n+\t  insn = ready_remove (ready, i);\n+\t  return insn;\n+\t}\n+    }\n+\n+  if (targetm.sched.dispatch (NULL_RTX, DISPATCH_VIOLATION))\n+    return ready_remove_first (ready);\n+\n+  for (i = 1; i < ready->n_ready; i++)\n+    {\n+      insn = ready_element (ready, i);\n+\n+      if (INSN_CODE (insn) < 0\n+\t  || !INSN_P (insn)\n+\t  || !active_insn_p (insn))\n+\tcontinue;\n+\n+      /* Return i-th element of ready.  */\n+      if (targetm.sched.dispatch (insn, IS_CMP))\n+\treturn ready_remove (ready, i);\n+    }\n+\n+  return ready_remove_first (ready);\n+}\n+\n+/* Get number of ready insn in the ready list.  */\n+\n+int\n+number_in_ready (void)\n+{\n+  return ready.n_ready;\n+}\n+\n+/* Get number of ready's in the ready list.  */\n+\n+rtx\n+get_ready_element (int i)\n+{\n+  return ready_element (&ready, i);\n+}\n+\n #endif /* INSN_SCHEDULING */"}, {"sha": "4d5be73c5994fe6e171c1c0c208e890fead93a03", "filename": "gcc/hooks.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -340,3 +340,18 @@ hook_tree_const_tree_null (const_tree t ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }\n+\n+/* Generic hook that takes a rtx and an int and returns a bool.  */\n+\n+bool\n+hook_bool_rtx_int_false (rtx insn ATTRIBUTE_UNUSED, int mode ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+/* Generic hook that takes a rtx and an int and returns void.  */\n+\n+void\n+hook_void_rtx_int (rtx insn ATTRIBUTE_UNUSED, int mode ATTRIBUTE_UNUSED)\n+{\n+}"}, {"sha": "9e4a0aeeb748c255d4a740407e2c0f3ee0a59584", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -46,6 +46,7 @@ extern bool hook_bool_const_tree_hwi_hwi_const_tree_true (const_tree,\n \t\t\t\t\t\t\t  HOST_WIDE_INT,\n \t\t\t\t\t\t\t  const_tree);\n extern bool hook_bool_rtx_false (rtx);\n+extern bool hook_bool_rtx_int_false (rtx, int);\n extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n extern bool hook_bool_rtx_int_int_intp_bool_false (rtx, int, int, int *, bool);\n extern bool hook_bool_size_t_constcharptr_int_true (size_t, const char *, int);\n@@ -55,6 +56,7 @@ extern bool hook_bool_tree_bool_false (tree, bool);\n \n extern void hook_void_void (void);\n extern void hook_void_constcharptr (const char *);\n+extern void hook_void_rtx_int (rtx, int);\n extern void hook_void_FILEptr_constcharptr (FILE *, const char *);\n extern void hook_void_tree (tree);\n extern void hook_void_tree_treeptr (tree, tree *);"}, {"sha": "fd2e15d70cfe167bbe359723fd97decf41f7fc8b", "filename": "gcc/sched-int.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -1269,6 +1269,8 @@ extern void add_block (basic_block, basic_block);\n extern rtx bb_note (basic_block);\n extern void concat_note_lists (rtx, rtx *);\n extern rtx sched_emit_insn (rtx);\n+extern rtx get_ready_element (int);\n+extern int number_in_ready (void);\n \f\n \n /* Types and functions in sched-rgn.c.  */\n@@ -1477,6 +1479,13 @@ sd_iterator_next (sd_iterator_def *it_ptr)\n        sd_iterator_cond (&(ITER), &(DEP));\t\t\t\\\n        sd_iterator_next (&(ITER)))\n \n+#define IS_DISPATCH_ON 1\n+#define IS_CMP 2\n+#define DISPATCH_VIOLATION 3\n+#define FITS_DISPATCH_WINDOW 4\n+#define DISPATCH_INIT 5\n+#define ADD_TO_DISPATCH_WINDOW 6\n+\n extern int sd_lists_size (const_rtx, sd_list_types_def);\n extern bool sd_lists_empty_p (const_rtx, sd_list_types_def);\n extern void sd_init_insn (rtx);"}, {"sha": "cecf882c9054cc2e9c1dbb288c419b4700a6caf5", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942e47efd91b52b609ff64303c5f2e24701eab0/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=7942e47efd91b52b609ff64303c5f2e24701eab0", "patch": "@@ -777,6 +777,24 @@ DEFHOOK\n  \"\",\n  int, (struct ddg *g), NULL)\n \n+/* The following member value is a function that initializes dispatch\n+   schedling and adds instructions to dispatch window according to its\n+   parameters.  */\n+DEFHOOK\n+(dispatch_do,\n+\"\",\n+void, (rtx insn, int x),\n+hook_void_rtx_int)\n+\n+/* The following member value is a a function that returns true is\n+   dispatch schedling is supported in hardware and condition passed\n+   as the second parameter is true.  */\n+DEFHOOK\n+(dispatch,\n+\"\",\n+bool, (rtx insn, int x),\n+hook_bool_rtx_int_false)\n+\n HOOK_VECTOR_END (sched)\n \n /* Functions relating to vectorization.  */"}]}