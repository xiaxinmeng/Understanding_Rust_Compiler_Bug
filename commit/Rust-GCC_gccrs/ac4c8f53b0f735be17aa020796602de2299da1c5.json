{"sha": "ac4c8f53b0f735be17aa020796602de2299da1c5", "node_id": "C_kwDOANBUbNoAKGFjNGM4ZjUzYjBmNzM1YmUxN2FhMDIwNzk2NjAyZGUyMjk5ZGExYzU", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-07-04T15:45:47Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-07-04T15:45:47Z"}, "message": "middle-end: Support ABIs that pass FP values as wider integers.\n\nSorry for the long delay getting back to this, but after deeper\ninvestigation, it turns out that Jeff Law's tingling spider senses\nthat the original patch wasn't updating everywhere that was required\nwere spot on.  Although my nvptx testing showed no problems with -O2,\ncompiling the same tests with -O0 found several additional assertion\nICEs (exactly where he'd predicted they'd be).\n\nHere's a revised patch that updates five locations (up from the\nprevious two).  Finding any remaining locations (if any) might be\neasier once folks are able to test things on their targets.  This\nalso implements Jeff's suggestion to factor the common code into\nhelper routines.\n\n2022-07-04  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR target/104489\n\t* calls.cc (precompute_register_parameters): Allow promotion\n\tof floating point values to be passed in wider integer modes\n\tby calling new convert_float_to_wider_int.\n\t(expand_call): Allow floating point results to be returned in\n\twider integer modes by calling new convert wider_int_to_float.\n\t* cfgexpand.cc (expand_value_return): Allow backends to promote\n\ta scalar floating point return value to a wider integer mode\n\tby calling new convert_float_to_wider_int.\n\t* expr.cc (convert_float_to_wider_int): New function.\n\t(convert_wider_int_to_float): Likewise.\n\t(expand_expr_real_1) <expand_decl_rtl>: Allow backends to promote\n\tscalar FP PARM_DECLs to wider integer modes, by calling new\n\tconvert_wider_int_to_float.\n\t* expr.h (convert_modes): Name arguments for improved documentation.\n\t(convert_float_to_wider_int): Prototype new function here.\n\t(convert_wider_int_to_float): Likewise.\n\t* function.cc (assign_parm_setup_stack): Allow floating point\n\tvalues to be passed on the stack as wider integer modes by\n\tcalling new convert_wider_int_to_float.", "tree": {"sha": "cc3b7b25905f59d4ab62635cd2b5dfc0925f04e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc3b7b25905f59d4ab62635cd2b5dfc0925f04e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac4c8f53b0f735be17aa020796602de2299da1c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4c8f53b0f735be17aa020796602de2299da1c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac4c8f53b0f735be17aa020796602de2299da1c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4c8f53b0f735be17aa020796602de2299da1c5/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc968115a742d9e4674d9725ce9c2106b91b6ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc968115a742d9e4674d9725ce9c2106b91b6ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc968115a742d9e4674d9725ce9c2106b91b6ead"}], "stats": {"total": 108, "additions": 95, "deletions": 13}, "files": [{"sha": "7f3cf5fd047fc479b53d6aa69e02b7e9e7b9bab3", "filename": "gcc/calls.cc", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fcalls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fcalls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.cc?ref=ac4c8f53b0f735be17aa020796602de2299da1c5", "patch": "@@ -992,11 +992,21 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \t/* If we are to promote the function arg to a wider mode,\n \t   do it now.  */\n \n-\tif (args[i].mode != TYPE_MODE (TREE_TYPE (args[i].tree_value)))\n-\t  args[i].value\n-\t    = convert_modes (args[i].mode,\n-\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n-\t\t\t     args[i].value, args[i].unsignedp);\n+\tmachine_mode old_mode = TYPE_MODE (TREE_TYPE (args[i].tree_value));\n+\n+\t/* Some ABIs require scalar floating point modes to be returned\n+\t   in a wider scalar integer mode.  We need to explicitly\n+\t   reinterpret to an integer mode of the correct precision\n+\t   before extending to the desired result.  */\n+\tif (SCALAR_INT_MODE_P (args[i].mode)\n+\t    && SCALAR_FLOAT_MODE_P (old_mode)\n+\t    && known_gt (GET_MODE_SIZE (args[i].mode),\n+\t\t\t GET_MODE_SIZE (old_mode)))\n+\t  args[i].value = convert_float_to_wider_int (args[i].mode, old_mode,\n+\t\t\t\t\t\t      args[i].value);\n+\telse if (args[i].mode != old_mode)\n+\t  args[i].value = convert_modes (args[i].mode, old_mode,\n+\t\t\t\t\t args[i].value, args[i].unsignedp);\n \n \t/* If the value is a non-legitimate constant, force it into a\n \t   pseudo now.  TLS symbols sometimes need a call to resolve.  */\n@@ -3825,18 +3835,24 @@ expand_call (tree exp, rtx target, int ignore)\n \t{\n \t  tree type = rettype;\n \t  int unsignedp = TYPE_UNSIGNED (type);\n+\t  machine_mode ret_mode = TYPE_MODE (type);\n \t  machine_mode pmode;\n \n \t  /* Ensure we promote as expected, and get the new unsignedness.  */\n-\t  pmode = promote_function_mode (type, TYPE_MODE (type), &unsignedp,\n+\t  pmode = promote_function_mode (type, ret_mode, &unsignedp,\n \t\t\t\t\t funtype, 1);\n \t  gcc_assert (GET_MODE (target) == pmode);\n \n-\t  poly_uint64 offset = subreg_lowpart_offset (TYPE_MODE (type),\n-\t\t\t\t\t\t      GET_MODE (target));\n-\t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n-\t  SUBREG_PROMOTED_VAR_P (target) = 1;\n-\t  SUBREG_PROMOTED_SET (target, unsignedp);\n+\t  if (SCALAR_INT_MODE_P (pmode)\n+\t      && SCALAR_FLOAT_MODE_P (ret_mode)\n+\t      && known_gt (GET_MODE_SIZE (pmode), GET_MODE_SIZE (ret_mode)))\n+\t    target = convert_wider_int_to_float (ret_mode, pmode, target);\n+\t  else\n+\t    {\n+\t      target = gen_lowpart_SUBREG (ret_mode, target);\n+\t      SUBREG_PROMOTED_VAR_P (target) = 1;\n+\t      SUBREG_PROMOTED_SET (target, unsignedp);\n+\t    }\n \t}\n \n       /* If size of args is variable or this was a constructor call for a stack"}, {"sha": "dd29ffffc038742fce06386500d425c12dae6933", "filename": "gcc/cfgexpand.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fcfgexpand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fcfgexpand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.cc?ref=ac4c8f53b0f735be17aa020796602de2299da1c5", "patch": "@@ -3720,7 +3720,18 @@ expand_value_return (rtx val)\n         mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 1);\n \n       if (mode != old_mode)\n-\tval = convert_modes (mode, old_mode, val, unsignedp);\n+\t{\n+\t  /* Some ABIs require scalar floating point modes to be returned\n+\t     in a wider scalar integer mode.  We need to explicitly\n+\t     reinterpret to an integer mode of the correct precision\n+\t     before extending to the desired result.  */\n+\t  if (SCALAR_INT_MODE_P (mode)\n+\t      && SCALAR_FLOAT_MODE_P (old_mode)\n+\t      && known_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (old_mode)))\n+\t    val = convert_float_to_wider_int (mode, old_mode, val);\n+\t  else\n+\t    val = convert_modes (mode, old_mode, val, unsignedp);\n+\t}\n \n       if (GET_CODE (return_reg) == PARALLEL)\n \temit_group_load (return_reg, val, type, int_size_in_bytes (type));"}, {"sha": "62297379ec909b4818a9edeea4505dc013917bb4", "filename": "gcc/expr.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=ac4c8f53b0f735be17aa020796602de2299da1c5", "patch": "@@ -776,6 +776,32 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n   convert_move (temp, x, unsignedp);\n   return temp;\n }\n+\n+/* Variant of convert_modes for ABI parameter passing/return.\n+   Return an rtx for a value that would result from converting X from\n+   a floating point mode FMODE to wider integer mode MODE.  */\n+\n+rtx\n+convert_float_to_wider_int (machine_mode mode, machine_mode fmode, rtx x)\n+{\n+  gcc_assert (SCALAR_INT_MODE_P (mode) && SCALAR_FLOAT_MODE_P (fmode));\n+  scalar_int_mode tmp_mode = int_mode_for_mode (fmode).require ();\n+  rtx tmp = force_reg (tmp_mode, gen_lowpart (tmp_mode, x));\n+  return convert_modes (mode, tmp_mode, tmp, 1);\n+}\n+\n+/* Variant of convert_modes for ABI parameter passing/return.\n+   Return an rtx for a value that would result from converting X from\n+   an integer mode IMODE to a narrower floating point mode MODE.  */\n+ \n+rtx\n+convert_wider_int_to_float (machine_mode mode, machine_mode imode, rtx x)\n+{\n+  gcc_assert (SCALAR_FLOAT_MODE_P (mode) && SCALAR_INT_MODE_P (imode));\n+  scalar_int_mode tmp_mode = int_mode_for_mode (mode).require ();\n+  rtx tmp = force_reg (tmp_mode, gen_lowpart (tmp_mode, x));\n+  return gen_lowpart_SUBREG (mode, tmp);\n+}\n \f\n /* Return the largest alignment we can use for doing a move (or store)\n    of MAX_PIECES.  ALIGN is the largest alignment we could use.  */\n@@ -10771,6 +10797,15 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    pmode = promote_ssa_mode (ssa_name, &unsignedp);\n \t  gcc_assert (GET_MODE (decl_rtl) == pmode);\n \n+\t  /* Some ABIs require scalar floating point modes to be passed\n+\t     in a wider scalar integer mode.  We need to explicitly\n+\t     truncate to an integer mode of the correct precision before\n+\t     using a SUBREG to reinterpret as a floating point value.  */\n+\t  if (SCALAR_FLOAT_MODE_P (mode)\n+\t      && SCALAR_INT_MODE_P (pmode)\n+\t      && known_lt (GET_MODE_SIZE (mode), GET_MODE_SIZE (pmode)))\n+\t    return convert_wider_int_to_float (mode, pmode, decl_rtl);\n+\n \t  temp = gen_lowpart_SUBREG (mode, decl_rtl);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_SET (temp, unsignedp);"}, {"sha": "b00c068f2fa0ca54c7ade093fb96b096398f13fa", "filename": "gcc/expr.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ac4c8f53b0f735be17aa020796602de2299da1c5", "patch": "@@ -69,7 +69,16 @@ extern void convert_move (rtx, rtx, int);\n extern rtx convert_to_mode (machine_mode, rtx, int);\n \n /* Convert an rtx to MODE from OLDMODE and return the result.  */\n-extern rtx convert_modes (machine_mode, machine_mode, rtx, int);\n+extern rtx convert_modes (machine_mode mode, machine_mode oldmode,\n+\t\t\t  rtx x, int unsignedp);\n+\n+/* Variant of convert_modes for ABI parameter passing/return.  */\n+extern rtx convert_float_to_wider_int (machine_mode mode, machine_mode fmode,\n+\t\t\t\t       rtx x);\n+\n+/* Variant of convert_modes for ABI parameter passing/return.  */\n+extern rtx convert_wider_int_to_float (machine_mode mode, machine_mode imode,\n+\t\t\t\t       rtx x);\n \n /* Expand a call to memcpy or memmove or memcmp, and return the result.  */\n extern rtx emit_block_op_via_libcall (enum built_in_function, rtx, rtx, rtx,"}, {"sha": "31256b5719720678aa46974403c1dc8afc4bb8f3", "filename": "gcc/function.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Ffunction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4c8f53b0f735be17aa020796602de2299da1c5/gcc%2Ffunction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.cc?ref=ac4c8f53b0f735be17aa020796602de2299da1c5", "patch": "@@ -3472,6 +3472,17 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \n       emit_move_insn (tempreg, validize_mem (copy_rtx (data->entry_parm)));\n \n+      /* Some ABIs require scalar floating point modes to be passed\n+\t in a wider scalar integer mode.  We need to explicitly\n+\t truncate to an integer mode of the correct precision before\n+\t using a SUBREG to reinterpret as a floating point value.  */\n+      if (SCALAR_FLOAT_MODE_P (data->nominal_mode)\n+\t  && SCALAR_INT_MODE_P (data->arg.mode)\n+\t  && known_lt (GET_MODE_SIZE (data->nominal_mode),\n+\t\t       GET_MODE_SIZE (data->arg.mode)))\n+\ttempreg = convert_wider_int_to_float (data->nominal_mode,\n+\t\t\t\t\t      data->arg.mode, tempreg);\n+\n       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);\n       to_conversion = true;\n "}]}