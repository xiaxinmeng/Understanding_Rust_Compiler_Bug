{"sha": "f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhmZTA1NDU4ZDIxMTZlNWRjZDJhYTNlYWM5ZGZmODY4YmUyN2NmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-03-09T16:11:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-03-09T16:11:00Z"}, "message": "fold-const.c (build_range_check): Make sure to use a valid type to apply the \"(c>=low) && (c<=high) into...\n\n\t* fold-const.c (build_range_check): Make sure to use a valid type to\n\tapply the \"(c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low)\"\n\ttransformation.\n\n\t(range_predecessor): New static function.\n\t(range_successor): Likewise.\n\t(merge_ranges): Use them to compute predecessors and successors of\n\trange bounds.\n\nFrom-SVN: r111866", "tree": {"sha": "5bedf0f0da9dcfb87f673767d4565f885cf8cb74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bedf0f0da9dcfb87f673767d4565f885cf8cb74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb/comments", "author": null, "committer": null, "parents": [{"sha": "d56ee62bfe7847ec4a100f3773827c2e3697879a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56ee62bfe7847ec4a100f3773827c2e3697879a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56ee62bfe7847ec4a100f3773827c2e3697879a"}], "stats": {"total": 154, "additions": 95, "deletions": 59}, "files": [{"sha": "5a138e2529eb9db43119794a73e781099ded357f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "patch": "@@ -1,3 +1,14 @@\n+2006-03-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fold-const.c (build_range_check): Make sure to use a valid type to\n+\tapply the \"(c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low)\"\n+\ttransformation.\n+\n+\t(range_predecessor): New static function.\n+\t(range_successor): Likewise.\n+\t(merge_ranges): Use them to compute predecessors and successors of\n+\trange bounds.\n+\n 2006-03-09  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/26561"}, {"sha": "582b496597255eca477d314dd4c757015123c5fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "patch": "@@ -108,6 +108,8 @@ static int all_ones_mask_p (tree, int);\n static tree sign_bit_p (tree, tree);\n static int simple_operand_p (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n+static tree range_predecessor (tree);\n+static tree range_successor (tree);\n static tree make_range (tree, int *, tree *, tree *);\n static tree build_range_check (tree, tree, int, tree, tree);\n static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n@@ -3722,6 +3724,32 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n   return constant_boolean_node (result, type);\n }\n \f\n+/* Return the predecessor of VAL in its type, handling the infinite case.  */\n+\n+static tree\n+range_predecessor (tree val)\n+{\n+  tree type = TREE_TYPE (val);\n+\n+  if (INTEGRAL_TYPE_P (type) && val == TYPE_MIN_VALUE (type))\n+    return 0;\n+  else\n+    return range_binop (MINUS_EXPR, NULL_TREE, val, 0, integer_one_node, 0);\n+}\n+\n+/* Return the successor of VAL in its type, handling the infinite case.  */\n+\n+static tree\n+range_successor (tree val)\n+{\n+  tree type = TREE_TYPE (val);\n+\n+  if (INTEGRAL_TYPE_P (type) && val == TYPE_MAX_VALUE (type))\n+    return 0;\n+  else\n+    return range_binop (PLUS_EXPR, NULL_TREE, val, 0, integer_one_node, 0);\n+}\n+\n /* Given EXP, a logical expression, set the range it is testing into\n    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n    actually being tested.  *PLOW and *PHIGH will be made of the same type\n@@ -4089,60 +4117,59 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \t}\n     }\n \n-  value = const_binop (MINUS_EXPR, high, low, 0);\n-  if (value != 0 && (!flag_wrapv || TREE_OVERFLOW (value))\n-      && ! TYPE_UNSIGNED (etype))\n+  /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).\n+     This requires wrap-around arithmetics for the type of the expression.  */\n+  switch (TREE_CODE (etype))\n+    {\n+    case INTEGER_TYPE:\n+      /* There is no requirement that LOW be within the range of ETYPE\n+\t if the latter is a subtype.  It must, however, be within the base\n+\t type of ETYPE.  So be sure we do the subtraction in that type.  */\n+      if (TREE_TYPE (etype))\n+\tetype = TREE_TYPE (etype);\n+      break;\n+\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+      etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),\n+\t\t\t\t\t      TYPE_UNSIGNED (etype));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* If we don't have wrap-around arithmetics upfront, try to force it.  */\n+  if (TREE_CODE (etype) == INTEGER_TYPE\n+      && !TYPE_UNSIGNED (etype) && !flag_wrapv)\n     {\n       tree utype, minv, maxv;\n \n       /* Check if (unsigned) INT_MAX + 1 == (unsigned) INT_MIN\n \t for the type in question, as we rely on this here.  */\n-      switch (TREE_CODE (etype))\n-\t{\n-\tcase INTEGER_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\t  /* There is no requirement that LOW be within the range of ETYPE\n-\t     if the latter is a subtype.  It must, however, be within the base\n-\t     type of ETYPE.  So be sure we do the subtraction in that type.  */\n-\t  if (TREE_TYPE (etype))\n-\t    etype = TREE_TYPE (etype);\n-\t  utype = lang_hooks.types.unsigned_type (etype);\n-\t  maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));\n-\t  maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,\n-\t\t\t      integer_one_node, 1);\n-\t  minv = fold_convert (utype, TYPE_MIN_VALUE (etype));\n-\t  if (integer_zerop (range_binop (NE_EXPR, integer_type_node,\n-\t\t\t\t\t  minv, 1, maxv, 1)))\n-\t    {\n-\t      etype = utype;\n-\t      high = fold_convert (etype, high);\n-\t      low = fold_convert (etype, low);\n-\t      exp = fold_convert (etype, exp);\n-\t      value = const_binop (MINUS_EXPR, high, low, 0);\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n+      utype = lang_hooks.types.unsigned_type (etype);\n+      maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));\n+      maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,\n+\t\t\t  integer_one_node, 1);\n+      minv = fold_convert (utype, TYPE_MIN_VALUE (etype));\n+\n+      if (integer_zerop (range_binop (NE_EXPR, integer_type_node,\n+\t\t\t\t      minv, 1, maxv, 1)))\n+\tetype = utype;\n+      else\n+\treturn 0;\n     }\n \n-  if (value != 0 && ! TREE_OVERFLOW (value))\n-    {\n-      /* There is no requirement that LOW be within the range of ETYPE\n-\t if the latter is a subtype.  It must, however, be within the base\n-\t type of ETYPE.  So be sure we do the subtraction in that type.  */\n-      if (INTEGRAL_TYPE_P (etype) && TREE_TYPE (etype))\n-\t{\n-\t  etype = TREE_TYPE (etype);\n-\t  exp = fold_convert (etype, exp);\n-\t  low = fold_convert (etype, low);\n-\t  value = fold_convert (etype, value);\n-\t}\n+  high = fold_convert (etype, high);\n+  low = fold_convert (etype, low);\n+  exp = fold_convert (etype, exp);\n \n-      return build_range_check (type,\n-\t\t\t\tfold_build2 (MINUS_EXPR, etype, exp, low),\n-\t\t\t\t1, build_int_cst (etype, 0), value);\n-    }\n+  value = const_binop (MINUS_EXPR, high, low, 0);\n+\n+  if (value != 0 && !TREE_OVERFLOW (value))\n+    return build_range_check (type,\n+\t\t\t      fold_build2 (MINUS_EXPR, etype, exp, low),\n+\t\t\t      1, build_int_cst (etype, 0), value);\n \n   return 0;\n }\n@@ -4208,7 +4235,7 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n       /* If they don't overlap, the result is the first range.  If they are\n \t equal, the result is false.  If the second range is a subset of the\n \t first, and the ranges begin at the same place, we go from just after\n-\t the end of the first range to the end of the second.  If the second\n+\t the end of the second range to the end of the first.  If the second\n \t range is not a subset of the first, or if it is a subset and both\n \t ranges end at the same place, the range starts at the start of the\n \t first range and ends just before the second range.\n@@ -4219,15 +4246,15 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \tin_p = 0, low = high = 0;\n       else if (subset && lowequal)\n \t{\n-\t  in_p = 1, high = high0;\n-\t  low = range_binop (PLUS_EXPR, NULL_TREE, high1, 0,\n-\t\t\t     integer_one_node, 0);\n+\t  low = range_successor (high1);\n+\t  high = high0;\n+\t  in_p = (low != 0);\n \t}\n       else if (! subset || highequal)\n \t{\n-\t  in_p = 1, low = low0;\n-\t  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,\n-\t\t\t      integer_one_node, 0);\n+\t  low = low0;\n+\t  high = range_predecessor (low1);\n+\t  in_p = (high != 0);\n \t}\n       else\n \treturn 0;\n@@ -4245,9 +4272,9 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \tin_p = 0, low = high = 0;\n       else\n \t{\n-\t  in_p = 1, high = high1;\n-\t  low = range_binop (PLUS_EXPR, NULL_TREE, high0, 1,\n-\t\t\t     integer_one_node, 0);\n+\t  low = range_successor (high0);\n+\t  high = high1;\n+\t  in_p = (low != 0);\n \t}\n     }\n \n@@ -4262,9 +4289,7 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n       if (no_overlap)\n \t{\n \t  if (integer_onep (range_binop (EQ_EXPR, integer_type_node,\n-\t\t\t\t\t range_binop (PLUS_EXPR, NULL_TREE,\n-\t\t\t\t\t\t      high0, 1,\n-\t\t\t\t\t\t      integer_one_node, 1),\n+\t\t\t\t\t range_successor (high0),\n \t\t\t\t\t 1, low1, 0)))\n \t    in_p = 0, low = low0, high = high1;\n \t  else"}]}