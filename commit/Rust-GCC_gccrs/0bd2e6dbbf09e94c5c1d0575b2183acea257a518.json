{"sha": "0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkMmU2ZGJiZjA5ZTk0YzVjMWQwNTc1YjIxODNhY2VhMjU3YTUxOA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:49Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:49Z"}, "message": "java-tree.h (end_params_node): Declare global.\n\n\ufffd\n\t* java-tree.h (end_params_node):  Declare global.\n\t* decl.c (end_params_node):  New global.\n\t(init_decl_processing, start_java_method):  Use end_params_node for\n\tend of list of parameter types.  Follows correct gcc conventions.\n\t* expr.c (pop_argument_types, pop_arguments):  Likewise.\n\t* lang.c (put_decl_node):  Likewise.\n\t* typeck.c (various places):  Likewise.\n\t* class.y (various places):  Likewise.\n\t* parse.y (various places):  Likewise.\n\t* parse.y (java_complete_tree):  Move CAN_COMPLETE_NORMALLY.\n\t(build_jump_to_finally):  Add missing CAN_COMPLETE_NORMALLY.\n\t* class.c:  Add #include flags.h, remove no-longer needed declaration.\n\t* class.c (layout_class_method):  Remove commented-out code, re-format.\n\tDon't add vtable entry (or index) for private methods.\n\t* expr.c (expand_invoke):  A private method is implicitly final.\n\t* class.c (make_class_data):  If inlining or optimizing,\n\tskip private methods.\n\t* class.c (finish_class):  New function.  Calls existing methods,\n\tbut alls emits deferred inline functions.\n\t* jcf-parse.c (parse_class_file):  Call finish_class.\n\t* parse.y (java_complete_expand_methods):  Likewise.\n\t* expr.c (build_java_binop):  Explicit default, to silence -Wall.\n\nFrom-SVN: r23870", "tree": {"sha": "06cb396402bd1f0563a483d3a6cdf7428c7fc198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06cb396402bd1f0563a483d3a6cdf7428c7fc198"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd2e6dbbf09e94c5c1d0575b2183acea257a518/comments", "author": null, "committer": null, "parents": [{"sha": "75d01ad77d70305c737b2c92c2674305edbf8306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d01ad77d70305c737b2c92c2674305edbf8306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d01ad77d70305c737b2c92c2674305edbf8306"}], "stats": {"total": 69, "additions": 27, "deletions": 42}, "files": [{"sha": "6224bb684a6d31bddc00d4135af1eb71645af3a3", "filename": "gcc/java/decl.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd2e6dbbf09e94c5c1d0575b2183acea257a518/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd2e6dbbf09e94c5c1d0575b2183acea257a518/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "patch": "@@ -333,6 +333,8 @@ tree length_identifier_node;\n tree this_identifier_node;\n tree super_identifier_node;\n \n+tree end_params_node;\n+\n /* References to internal libjava functions we use. */\n tree alloc_object_node;\n tree soft_instanceof_node;\n@@ -415,6 +417,7 @@ builtin_function (name, type, function_code, library_name)\n void\n init_decl_processing ()\n {\n+  register tree endlink;\n   tree field;\n   tree t;\n \n@@ -672,104 +675,101 @@ init_decl_processing ()\n   CLASS_LOADED_P (method_type_node) = 1;\n   build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n \n+  endlink = end_params_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+\n   t = tree_cons (NULL_TREE, class_ptr_type,\n-\t\t build_tree_list (NULL_TREE, int_type_node));\n+\t\t tree_cons (NULL_TREE, int_type_node, endlink));\n   alloc_object_node = builtin_function (\"_Jv_AllocObject\",\n \t\t\t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\t\t\tNOT_BUILT_IN, NULL_PTR);\n   soft_initclass_node = builtin_function (\"_Jv_InitClass\",\n \t\t\t\t\t  build_function_type (void_type_node,\n \t\t\t\t\t\t\t       t),\n \t\t\t\t\t  NOT_BUILT_IN, NULL_PTR);\n-  t = build_tree_list (NULL_TREE, void_type_node);\n+  t = tree_cons (NULL_TREE, ptr_type_node, endlink);\n   throw_node = builtin_function (\"_Jv_Throw\",\n \t\t\t\t build_function_type (ptr_type_node, t),\n \t\t\t\t NOT_BUILT_IN, NULL_PTR);\n+  t = build_function_type (int_type_node, endlink);\n   soft_monitorenter_node \n-      = builtin_function (\"_Jv_MonitorEnter\",\n-\t\t\t  build_function_type (int_type_node, t),\n-\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+      = builtin_function (\"_Jv_MonitorEnter\", t, NOT_BUILT_IN, NULL_PTR);\n   soft_monitorexit_node \n-      = builtin_function (\"_Jv_MonitorExit\",\n-\t\t\t  build_function_type (int_type_node, t),\n-\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+      = builtin_function (\"_Jv_MonitorExit\", t, NOT_BUILT_IN, NULL_PTR);\n   \n   t = tree_cons (NULL_TREE, int_type_node, \n-\t\t build_tree_list (NULL_TREE, int_type_node));\n+\t\t tree_cons (NULL_TREE, int_type_node, endlink));\n   soft_newarray_node\n       = builtin_function (\"_Jv_NewArray\",\n \t\t\t  build_function_type(ptr_type_node, t),\n \t\t\t  NOT_BUILT_IN, NULL_PTR );\n \n   t = tree_cons (NULL_TREE, int_type_node,\n \t\t tree_cons (NULL_TREE, class_ptr_type,\n-\t\t\t    build_tree_list (NULL_TREE, \n-\t\t\t\t\t     object_ptr_type_node)));\n+\t\t\t    tree_cons (NULL_TREE, object_ptr_type_node, endlink)));\n   soft_anewarray_node\n       = builtin_function (\"_Jv_NewObjectArray\",\n \t\t\t  build_function_type (ptr_type_node, t),\n \t\t\t  NOT_BUILT_IN, NULL_PTR );\n \n   t = tree_cons (NULL_TREE, ptr_type_node,\n-\t\t build_tree_list (NULL_TREE, int_type_node));\n+\t\t tree_cons (NULL_TREE, int_type_node, endlink));\n   soft_multianewarray_node\n       = builtin_function (\"_Jv_NewMultiArray\",\n \t\t\t  build_function_type (ptr_type_node, t),\n \t\t\t  NOT_BUILT_IN, NULL_PTR );\n \n   t = build_function_type (void_type_node, \n-\t\t\t   build_tree_list (NULL_TREE, int_type_node));\n+\t\t\t   tree_cons (NULL_TREE, int_type_node, endlink));\n   soft_badarrayindex_node\n       = builtin_function (\"_Jv_ThrowBadArrayIndex\", t, \n \t\t\t  NOT_BUILT_IN, NULL_PTR);\n   TREE_THIS_VOLATILE (soft_badarrayindex_node) = 1;\n   TREE_SIDE_EFFECTS (soft_badarrayindex_node) = 1;\n \n   t = tree_cons (NULL_TREE, class_ptr_type,\n-\t\t build_tree_list (NULL_TREE, object_ptr_type_node));\n+\t\t tree_cons (NULL_TREE, object_ptr_type_node, endlink));\n   soft_checkcast_node\n     = builtin_function (\"_Jv_CheckCast\",\n \t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   t = tree_cons (NULL_TREE, object_ptr_type_node,\n-\t\t build_tree_list (NULL_TREE, class_ptr_type));\n+\t\t tree_cons (NULL_TREE, class_ptr_type, endlink));\n   soft_instanceof_node\n     = builtin_function (\"_Jv_IsInstanceOf\",\n \t\t\tbuild_function_type (promoted_boolean_type_node, t),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   t = tree_cons (NULL_TREE, object_ptr_type_node,\n-\t\t build_tree_list (NULL_TREE, object_ptr_type_node));\n+\t\t tree_cons (NULL_TREE, object_ptr_type_node, endlink));\n   soft_checkarraystore_node\n     = builtin_function (\"_Jv_CheckArrayStore\",\n \t\t\tbuild_function_type (void_type_node, t),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   t = tree_cons (NULL_TREE, ptr_type_node,\n \t\t tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t    build_tree_list (NULL_TREE, ptr_type_node)));\n+\t\t\t    tree_cons (NULL_TREE, ptr_type_node, endlink)));\n   soft_lookupinterfacemethod_node \n     = builtin_function (\"_Jv_LookupInterfaceMethod\",\n \t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   t = tree_cons (NULL_TREE, double_type_node,\n-\t\t build_tree_list (NULL_TREE, double_type_node));\n+\t\t tree_cons (NULL_TREE, double_type_node, endlink));\n   soft_fmod_node\n     = builtin_function (\"__builtin_fmod\",\n \t\t\tbuild_function_type (double_type_node, t),\n \t\t\tBUILT_IN_FMOD, \"fmod\");\n \n-  t = build_tree_list (NULL_TREE, void_type_node);\n   soft_exceptioninfo_call_node\n     = build (CALL_EXPR, \n \t     ptr_type_node,\n \t     build_address_of \n \t       (builtin_function (\"_Jv_exception_info\", \n-\t\t\t\t  build_function_type (ptr_type_node, t),\n+\t\t\t\t  build_function_type (ptr_type_node, endlink),\n \t\t\t\t  NOT_BUILT_IN, NULL_PTR)),\n \t     NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (soft_exceptioninfo_call_node) = 1;\n #if 0\n   t = tree_cons (NULL_TREE, float_type_node,\n-\t\t build_tree_list (NULL_TREE, float_type_node));\n+\t\t tree_cons (NULL_TREE, float_type_node, endlink));\n   soft_fmodf_node\n     = builtin_function (\"__builtin_fmodf\",\n \t\t\tbuild_function_type (float_type_node, t),\n@@ -1535,7 +1535,7 @@ start_java_method (fndecl)\n \n   ptr = &DECL_ARGUMENTS (fndecl);\n   for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;\n-       tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)\n+       tem != end_params_node; tem = TREE_CHAIN (tem), i++)\n     {\n       tree parm_name = NULL_TREE, parm_decl;\n       tree parm_type = TREE_VALUE (tem);"}, {"sha": "e97569d5a7bc1948a9d7caa3d27eebbfe3dfa410", "filename": "gcc/java/expr.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd2e6dbbf09e94c5c1d0575b2183acea257a518/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd2e6dbbf09e94c5c1d0575b2183acea257a518/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "patch": "@@ -1028,23 +1028,7 @@ build_java_binop (op, type, arg1, arg2)\n \t  return call;\n \t}\n       break;\n-\n-#if 0\t/* not required */\n-    case PLUS_EXPR:\n-    case MULT_EXPR:\n-    case MINUS_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case RDIV_EXPR:\n-/*    case REM_EXPR: */\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-      break;\n-    default:\n-      error (\"unknown opcode\");\n-      return error_mark_node;\n-#endif\n-\n+    default:  ;\n     }\n   return fold (build (op, type, arg1, arg2));\n }\n@@ -1278,7 +1262,7 @@ void\n pop_argument_types (arg_types)\n      tree arg_types;\n {\n-  if (arg_types == NULL_TREE)\n+  if (arg_types == end_params_node)\n     return;\n   if (TREE_CODE (arg_types) == TREE_LIST)\n     {\n@@ -1293,7 +1277,7 @@ tree\n pop_arguments (arg_types)\n      tree arg_types;\n {\n-  if (arg_types == NULL_TREE)\n+  if (arg_types == end_params_node)\n     return NULL_TREE;\n   if (TREE_CODE (arg_types) == TREE_LIST)\n     {\n@@ -1542,7 +1526,8 @@ expand_invoke (opcode, method_ref_index, nargs)\n   func = NULL_TREE;\n   if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n       || (opcode == OPCODE_invokevirtual\n-\t  && (METHOD_FINAL (method) || CLASS_FINAL (TYPE_NAME (self_type)))))\n+\t  && (METHOD_PRIVATE (method)\n+\t      || METHOD_FINAL (method) || CLASS_FINAL (TYPE_NAME (self_type)))))\n     func = build_known_method_ref (method, method_type, self_type,\n \t\t\t\t   method_signature, arg_list);\n   else"}]}