{"sha": "e19a18d4e42fcf080cc7c3db2d38d11feade5347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5YTE4ZDRlNDJmY2YwODBjYzdjM2RiMmQzOGQxMWZlYWRlNTM0Nw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-05-04T17:08:04Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-05-04T17:08:04Z"}, "message": "don't use TYPE_ARG_TYPES in c-family/\n\ndon't use TYPE_ARG_TYPES in c-family/\n\t* c-common.c (check_main_parameter_types): Reindent.  Don't use\n\tTYPE_ARG_TYPES directly.\n\t(handle_nonnull_attribute): Likewise.\n\t(sync_resolve_params): Likewise.\n\t* c-format.c (handle_format_arg_attribute): Likewise.  Adjust call\n\tto check_format_string.\n\t(handle_format_attribute): Likewise.\n\t(check_format_string): Take a function type to examine instead of\n\ta type list.  Use a function_arg_iterator to step through argument\n\ttypes.\n\nFrom-SVN: r173384", "tree": {"sha": "c5306f59e22f64edb09f5b44e264c21545a366a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5306f59e22f64edb09f5b44e264c21545a366a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e19a18d4e42fcf080cc7c3db2d38d11feade5347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19a18d4e42fcf080cc7c3db2d38d11feade5347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19a18d4e42fcf080cc7c3db2d38d11feade5347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19a18d4e42fcf080cc7c3db2d38d11feade5347/comments", "author": null, "committer": null, "parents": [{"sha": "7a2f720889eaee0e35a62ccb8e5685f1da944243", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2f720889eaee0e35a62ccb8e5685f1da944243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a2f720889eaee0e35a62ccb8e5685f1da944243"}], "stats": {"total": 157, "additions": 89, "deletions": 68}, "files": [{"sha": "55c03b30ddfae1d71de1948bdb98b5f949a42e14", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e19a18d4e42fcf080cc7c3db2d38d11feade5347", "patch": "@@ -1,3 +1,16 @@\n+2011-05-04  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* c-common.c (check_main_parameter_types): Reindent.  Don't use\n+\tTYPE_ARG_TYPES directly.\n+\t(handle_nonnull_attribute): Likewise.\n+\t(sync_resolve_params): Likewise.\n+\t* c-format.c (handle_format_arg_attribute): Likewise.  Adjust call\n+\tto check_format_string.\n+\t(handle_format_attribute): Likewise.\n+\t(check_format_string): Take a function type to examine instead of\n+\ta type list.  Use a function_arg_iterator to step through argument\n+\ttypes.\n+\n 2011-05-04  Richard Guenther  <rguenther@suse.de>\n \n \t* c-common.c (fix_string_type): Use size_int for index type bounds."}, {"sha": "207f77be451d2041aeb7aad7501c54c2620fd5d0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e19a18d4e42fcf080cc7c3db2d38d11feade5347", "patch": "@@ -1663,51 +1663,52 @@ strict_aliasing_warning (tree otype, tree type, tree expr)\n void\n check_main_parameter_types (tree decl)\n {\n-  tree args;\n+  function_args_iterator iter;\n+  tree type;\n   int argct = 0;\n \n-  for (args = TYPE_ARG_TYPES (TREE_TYPE (decl)); args;\n-      args = TREE_CHAIN (args))\n-   {\n-     tree type = args ? TREE_VALUE (args) : 0;\n-\n-     if (type == void_type_node || type == error_mark_node )\n-       break;\n-\n-     ++argct;\n-     switch (argct)\n-       {\n-       case 1:\n-         if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-           pedwarn (input_location, OPT_Wmain, \"first argument of %q+D should be %<int%>\",\n-\t\t    decl);\n-         break;\n-\n-       case 2:\n-         if (TREE_CODE (type) != POINTER_TYPE\n-             || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n-             || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n-                 != char_type_node))\n-           pedwarn (input_location, OPT_Wmain, \"second argument of %q+D should be %<char **%>\",\n-\t\t    decl);\n-         break;\n-\n-       case 3:\n-         if (TREE_CODE (type) != POINTER_TYPE\n-             || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n-             || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n-                 != char_type_node))\n-\t   pedwarn (input_location, OPT_Wmain, \"third argument of %q+D should probably be \"\n-\t\t    \"%<char **%>\", decl);\n-         break;\n-       }\n-   }\n+  FOREACH_FUNCTION_ARGS (TREE_TYPE (decl), type, iter)\n+    {\n+      /* XXX void_type_node belies the abstraction.  */\n+      if (type == void_type_node || type == error_mark_node )\n+\tbreak;\n+\n+      ++argct;\n+      switch (argct)\n+\t{\n+\tcase 1:\n+\t  if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"first argument of %q+D should be %<int%>\", decl);\n+\t  break;\n+\n+\tcase 2:\n+\t  if (TREE_CODE (type) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n+\t\t  != char_type_node))\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"second argument of %q+D should be %<char **%>\", decl);\n+\t  break;\n+\n+\tcase 3:\n+\t  if (TREE_CODE (type) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n+\t\t  != char_type_node))\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"third argument of %q+D should probably be \"\n+\t\t     \"%<char **%>\", decl);\n+\t  break;\n+\t}\n+    }\n \n   /* It is intentional that this message does not mention the third\n     argument because it's only mentioned in an appendix of the\n     standard.  */\n   if (argct > 0 && (argct < 2 || argct > 3))\n-    pedwarn (input_location, OPT_Wmain, \"%q+D takes only zero or two arguments\", decl);\n+    pedwarn (input_location, OPT_Wmain,\n+\t     \"%q+D takes only zero or two arguments\", decl);\n }\n \n /* True if pointers to distinct types T1 and T2 can be converted to\n@@ -7395,7 +7396,6 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n      a pointer argument.  */\n   for (attr_arg_num = 1; args; args = TREE_CHAIN (args))\n     {\n-      tree argument;\n       unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n \n       if (!get_nonnull_operand (TREE_VALUE (args), &arg_num))\n@@ -7406,26 +7406,29 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n \t  return NULL_TREE;\n \t}\n \n-      argument = TYPE_ARG_TYPES (type);\n-      if (argument)\n+      if (prototype_p (type))\n \t{\n-\t  for (ck_num = 1; ; ck_num++)\n+\t  function_args_iterator iter;\n+\t  tree argument;\n+\n+\t  function_args_iter_init (&iter, type);\n+\t  for (ck_num = 1; ; ck_num++, function_args_iter_next (&iter))\n \t    {\n-\t      if (!argument || ck_num == arg_num)\n+\t      argument = function_args_iter_cond (&iter);\n+\t      if (argument == NULL_TREE || ck_num == arg_num)\n \t\tbreak;\n-\t      argument = TREE_CHAIN (argument);\n \t    }\n \n \t  if (!argument\n-\t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n+\t      || TREE_CODE (argument) == VOID_TYPE)\n \t    {\n \t      error (\"nonnull argument with out-of-range operand number (argument %lu, operand %lu)\",\n \t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n \t      *no_add_attrs = true;\n \t      return NULL_TREE;\n \t    }\n \n-\t  if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n+\t  if (TREE_CODE (argument) != POINTER_TYPE)\n \t    {\n \t      error (\"nonnull argument references non-pointer operand (argument %lu, operand %lu)\",\n \t\t   (unsigned long) attr_arg_num, (unsigned long) arg_num);\n@@ -8922,22 +8925,28 @@ sync_resolve_size (tree function, VEC(tree,gc) *params)\n static bool\n sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n {\n-  tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n+  function_args_iterator iter;\n   tree ptype;\n   unsigned int parmnum;\n \n+  function_args_iter_init (&iter, TREE_TYPE (function));\n   /* We've declared the implementation functions to use \"volatile void *\"\n      as the pointer parameter, so we shouldn't get any complaints from the\n      call to check_function_arguments what ever type the user used.  */\n-  arg_types = TREE_CHAIN (arg_types);\n+  function_args_iter_next (&iter);\n   ptype = TREE_TYPE (TREE_TYPE (VEC_index (tree, params, 0)));\n \n   /* For the rest of the values, we need to cast these to FTYPE, so that we\n      don't get warnings for passing pointer types, etc.  */\n   parmnum = 0;\n-  while (arg_types != void_list_node)\n+  while (1)\n     {\n-      tree val;\n+      tree val, arg_type;\n+\n+      arg_type = function_args_iter_cond (&iter);\n+      /* XXX void_type_node belies the abstraction.  */\n+      if (arg_type == void_type_node)\n+\tbreak;\n \n       ++parmnum;\n       if (VEC_length (tree, params) <= parmnum)\n@@ -8951,10 +8960,10 @@ sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n \t type.  This isn't portable across the C and C++ front ends atm.  */\n       val = VEC_index (tree, params, parmnum);\n       val = convert (ptype, val);\n-      val = convert (TREE_VALUE (arg_types), val);\n+      val = convert (arg_type, val);\n       VEC_replace (tree, params, parmnum, val);\n \n-      arg_types = TREE_CHAIN (arg_types);\n+      function_args_iter_next (&iter);\n     }\n \n   /* The definition of these primitives is variadic, with the remaining"}, {"sha": "66012c4a88eb60f8526448139f56e81c6cfbf628", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19a18d4e42fcf080cc7c3db2d38d11feade5347/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=e19a18d4e42fcf080cc7c3db2d38d11feade5347", "patch": "@@ -120,7 +120,6 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n   tree type = *node;\n   tree format_num_expr = TREE_VALUE (args);\n   unsigned HOST_WIDE_INT format_num = 0;\n-  tree argument;\n \n   if (!get_constant (format_num_expr, &format_num, 0))\n     {\n@@ -129,12 +128,11 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n       return NULL_TREE;\n     }\n \n-  argument = TYPE_ARG_TYPES (type);\n-  if (argument)\n+  if (prototype_p (type))\n     {\n       /* The format arg can be any string reference valid for the language and\n          target.  We cannot be more specific in this case.  */\n-      if (!check_format_string (argument, format_num, flags, no_add_attrs, -1))\n+      if (!check_format_string (type, format_num, flags, no_add_attrs, -1))\n \treturn NULL_TREE;\n     }\n \n@@ -154,23 +152,24 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n    error).  When we know the specific reference type expected, this is also \n    checked.  */\n static bool\n-check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n+check_format_string (tree fntype, unsigned HOST_WIDE_INT format_num,\n \t\t     int flags, bool *no_add_attrs, int expected_format_type)\n {\n   unsigned HOST_WIDE_INT i;\n   bool is_objc_sref, is_target_sref, is_char_ref;\n   tree ref;\n   int fmt_flags;\n+  function_args_iterator iter;\n \n-  for (i = 1; i != format_num; i++)\n+  i = 1;\n+  FOREACH_FUNCTION_ARGS (fntype, ref, iter)\n     {\n-      if (argument == 0)\n+      if (i == format_num)\n \tbreak;\n-      argument = TREE_CHAIN (argument);\n+      i++;\n     }\n \n-  if (!argument\n-      || !(ref = TREE_VALUE (argument))\n+  if (!ref\n       || !valid_stringptr_type_p (ref))\n     {\n       if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n@@ -2957,7 +2956,6 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n {\n   tree type = *node;\n   function_format_info info;\n-  tree argument;\n \n #ifdef TARGET_FORMAT_TYPES\n   /* If the target provides additional format types, we need to\n@@ -2984,21 +2982,22 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       return NULL_TREE;\n     }\n \n-  argument = TYPE_ARG_TYPES (type);\n-  if (argument)\n+  if (prototype_p (type))\n     {\n-      if (!check_format_string (argument, info.format_num, flags,\n+      if (!check_format_string (type, info.format_num, flags,\n \t\t\t\tno_add_attrs, info.format_type))\n \treturn NULL_TREE;\n \n       if (info.first_arg_num != 0)\n \t{\n \t  unsigned HOST_WIDE_INT arg_num = 1;\n+\t  function_args_iterator iter;\n+\t  tree arg_type;\n \n \t  /* Verify that first_arg_num points to the last arg,\n \t     the ...  */\n-\t  while (argument)\n-\t    arg_num++, argument = TREE_CHAIN (argument);\n+\t  FOREACH_FUNCTION_ARGS (type, arg_type, iter)\n+\t    arg_num++;\n \n \t  if (arg_num != info.first_arg_num)\n \t    {"}]}