{"sha": "67c605a553faab6244a1b1d987059798e6c1f9aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdjNjA1YTU1M2ZhYWI2MjQ0YTFiMWQ5ODcwNTk3OThlNmMxZjlhYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-06-11T18:41:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-06-11T18:41:47Z"}, "message": "i386.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n\n        * config/i386/i386.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n        * config/i386/i386.c (ix86_va_arg): Remove.\n        * config/rs6000/rs6000.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n        * config/rs6000/rs6000.c (rs6000_va_arg): Remove.\n        * config/alpha/alpha.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n        * config/alpha/alpha.c (alpha_va_arg): Remove.\n        * config/sparc/sparc.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n        * config/sparc/sparc.c (sparc_va_arg): Remove.\n\n        * tree-ssa-operands.c (get_stmt_operands): Use a V_MAY_DEF if the\n        assignment might throw.\n        * tree-eh.c (tree_could_throw_p): Support non-call exceptions in\n        expressions.\n\nFrom-SVN: r82992", "tree": {"sha": "53b714fbb57b9a4edc2c059014d88e351591041f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53b714fbb57b9a4edc2c059014d88e351591041f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67c605a553faab6244a1b1d987059798e6c1f9aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67c605a553faab6244a1b1d987059798e6c1f9aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67c605a553faab6244a1b1d987059798e6c1f9aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67c605a553faab6244a1b1d987059798e6c1f9aa/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67fc0c0f596944a4bc88cb8d8061bf4c8753c03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67fc0c0f596944a4bc88cb8d8061bf4c8753c03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67fc0c0f596944a4bc88cb8d8061bf4c8753c03f"}], "stats": {"total": 775, "additions": 37, "deletions": 738}, "files": [{"sha": "c755b367987083bd181fc1c80769b36866a4cd05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1,3 +1,19 @@\n+2004-06-11  Jason Merrill  <jason@redhat.com>\n+\n+\t* config/i386/i386.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n+\t* config/i386/i386.c (ix86_va_arg): Remove.\n+\t* config/rs6000/rs6000.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n+\t* config/rs6000/rs6000.c (rs6000_va_arg): Remove.\n+\t* config/alpha/alpha.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n+\t* config/alpha/alpha.c (alpha_va_arg): Remove.\n+\t* config/sparc/sparc.h (EXPAND_BUILTIN_VA_ARG): Just abort.\n+\t* config/sparc/sparc.c (sparc_va_arg): Remove.\n+\n+\t* tree-ssa-operands.c (get_stmt_operands): Use a V_MAY_DEF if the\n+\tassignment might throw.\n+\t* tree-eh.c (tree_could_throw_p): Support non-call exceptions in\n+\texpressions.\n+\n 2004-06-11  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \tPR 15886:"}, {"sha": "d4b78d33dcd402c6e643fd14a9157f2e652459f8", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -6291,115 +6291,6 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     }\n }\n \n-rtx\n-alpha_va_arg (tree valist, tree type)\n-{\n-  rtx addr;\n-  tree t, type_size, rounded_size;\n-  tree offset_field, base_field, addr_tree, addend;\n-  tree wide_type, wide_ofs;\n-  int indirect = 0;\n-\n-  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n-    return std_expand_builtin_va_arg (valist, type);\n-\n-  if (type == error_mark_node\n-      || (type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type))) == NULL\n-      || TREE_OVERFLOW (type_size))\n-    rounded_size = size_zero_node;\n-  else\n-    rounded_size = fold (build (MULT_EXPR, sizetype,\n-\t\t\t\tfold (build (TRUNC_DIV_EXPR, sizetype,\n-\t\t\t\t\t     fold (build (PLUS_EXPR, sizetype,\n-\t\t\t\t\t\t\t  type_size,\n-\t\t\t\t\t\t\t  size_int (7))),\n-\t\t\t\t\t     size_int (8))),\n-\t\t\t\tsize_int (8)));\n-\n-  base_field = TYPE_FIELDS (TREE_TYPE (valist));\n-  offset_field = TREE_CHAIN (base_field);\n-\n-  base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n-\t\t      valist, base_field);\n-  offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n-\t\t\tvalist, offset_field);\n-\n-  /* If the type could not be passed in registers, skip the block\n-     reserved for the registers.  */\n-  if (MUST_PASS_IN_STACK (TYPE_MODE (type), type))\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field,\n-\t\t build (MAX_EXPR, TREE_TYPE (offset_field), \n-\t\t\toffset_field, build_int_2 (6*8, 0)));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n-\n-  wide_type = make_signed_type (64);\n-  wide_ofs = save_expr (build1 (CONVERT_EXPR, wide_type, offset_field));\n-\n-  addend = wide_ofs;\n-\n-  if (TYPE_MODE (type) == TFmode || TYPE_MODE (type) == TCmode)\n-    {\n-      indirect = 1;\n-      rounded_size = size_int (UNITS_PER_WORD);\n-    }\n-  else if (TREE_CODE (type) == COMPLEX_TYPE)\n-    {\n-      rtx real_part, imag_part, value, tmp;\n-\n-      real_part = alpha_va_arg (valist, TREE_TYPE (type));\n-      imag_part = alpha_va_arg (valist, TREE_TYPE (type));\n-\n-      /* ??? Most irritatingly, we're not returning the value here,\n-\t but the address.  Since real_part and imag_part are not\n-\t necessarily contiguous, we must copy to local storage.  */\n-\n-      real_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), real_part);\n-      imag_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), imag_part);\n-      value = gen_rtx_CONCAT (TYPE_MODE (type), real_part, imag_part);\n-\n-      tmp = assign_temp (type, 0, 1, 0);\n-      emit_move_insn (tmp, value);\n-\n-      return XEXP (tmp, 0);\n-    }\n-  else if (TREE_CODE (type) == REAL_TYPE)\n-    {\n-      tree fpaddend, cond;\n-\n-      fpaddend = fold (build (PLUS_EXPR, TREE_TYPE (addend),\n-\t\t\t      addend, build_int_2 (-6*8, 0)));\n-\n-      cond = fold (build (LT_EXPR, integer_type_node,\n-\t\t\t  wide_ofs, build_int_2 (6*8, 0)));\n-\n-      addend = fold (build (COND_EXPR, TREE_TYPE (addend), cond,\n-\t\t\t    fpaddend, addend));\n-    }\n-\n-  addr_tree = build (PLUS_EXPR, TREE_TYPE (base_field),\n-\t\t     base_field, addend);\n-\n-  addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n-  addr = copy_to_reg (addr);\n-\n-  t = build (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field,\n-\t     build (PLUS_EXPR, TREE_TYPE (offset_field), \n-\t\t    offset_field, rounded_size));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  if (indirect)\n-    {\n-      addr = force_reg (Pmode, addr);\n-      addr = gen_rtx_MEM (Pmode, addr);\n-    }\n-\n-  return addr;\n-}\n-\n static tree\n alpha_gimplify_va_arg_1 (tree type, tree base, tree offset,\n \t\t\t tree *pre_p, tree *post_p)"}, {"sha": "8cc22caf1b4ce1cb1f7eb973c53471e8e386fe86", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1687,8 +1687,7 @@ do {\t\t\t\t\t\t\\\n   alpha_va_start (valist, nextarg)\n \n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  alpha_va_arg (valist, type)\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) (abort (), NULL_RTX)\n \f\n /* Tell collect that the object format is ECOFF.  */\n #define OBJECT_FORMAT_COFF"}, {"sha": "1f0cfc85d9d75d6feeb72afd85753e199be1e3ae", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -3177,246 +3177,6 @@ ix86_va_start (tree valist, rtx nextarg)\n }\n \n /* Implement va_arg.  */\n-rtx\n-ix86_va_arg (tree valist, tree type)\n-{\n-  static const int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n-  tree f_gpr, f_fpr, f_ovf, f_sav;\n-  tree gpr, fpr, ovf, sav, t;\n-  int size, rsize;\n-  rtx lab_false, lab_over = NULL_RTX;\n-  rtx addr_rtx, r;\n-  rtx container;\n-  int indirect_p = 0;\n-\n-  /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT)\n-    {\n-      return std_expand_builtin_va_arg (valist, type);\n-    }\n-\n-  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_ovf = TREE_CHAIN (f_fpr);\n-  f_sav = TREE_CHAIN (f_ovf);\n-\n-  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n-\n-  size = int_size_in_bytes (type);\n-  if (size == -1)\n-    {\n-      /* Passed by reference.  */\n-      indirect_p = 1;\n-      type = build_pointer_type (type);\n-      size = int_size_in_bytes (type);\n-    }\n-  rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  container = construct_container (TYPE_MODE (type), type, 0,\n-\t\t\t\t   REGPARM_MAX, SSE_REGPARM_MAX, intreg, 0);\n-  /*\n-   * Pull the value out of the saved registers ...\n-   */\n-\n-  addr_rtx = gen_reg_rtx (Pmode);\n-\n-  if (container)\n-    {\n-      rtx int_addr_rtx, sse_addr_rtx;\n-      int needed_intregs, needed_sseregs;\n-      int need_temp;\n-\n-      lab_over = gen_label_rtx ();\n-      lab_false = gen_label_rtx ();\n-\n-      examine_argument (TYPE_MODE (type), type, 0,\n-\t\t        &needed_intregs, &needed_sseregs);\n-\n-\n-      need_temp = ((needed_intregs && TYPE_ALIGN (type) > 64)\n-\t\t   || TYPE_ALIGN (type) > 128);\n-\n-      /* In case we are passing structure, verify that it is consecutive block\n-         on the register save area.  If not we need to do moves.  */\n-      if (!need_temp && !REG_P (container))\n-\t{\n-\t  /* Verify that all registers are strictly consecutive  */\n-\t  if (SSE_REGNO_P (REGNO (XEXP (XVECEXP (container, 0, 0), 0))))\n-\t    {\n-\t      int i;\n-\n-\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n-\t\t{\n-\t\t  rtx slot = XVECEXP (container, 0, i);\n-\t\t  if (REGNO (XEXP (slot, 0)) != FIRST_SSE_REG + (unsigned int) i\n-\t\t      || INTVAL (XEXP (slot, 1)) != i * 16)\n-\t\t    need_temp = 1;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      int i;\n-\n-\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n-\t\t{\n-\t\t  rtx slot = XVECEXP (container, 0, i);\n-\t\t  if (REGNO (XEXP (slot, 0)) != (unsigned int) i\n-\t\t      || INTVAL (XEXP (slot, 1)) != i * 8)\n-\t\t    need_temp = 1;\n-\t\t}\n-\t    }\n-\t}\n-      if (!need_temp)\n-\t{\n-\t  int_addr_rtx = addr_rtx;\n-\t  sse_addr_rtx = addr_rtx;\n-\t}\n-      else\n-\t{\n-\t  int_addr_rtx = gen_reg_rtx (Pmode);\n-\t  sse_addr_rtx = gen_reg_rtx (Pmode);\n-\t}\n-      /* First ensure that we fit completely in registers.  */\n-      if (needed_intregs)\n-\t{\n-\t  emit_cmp_and_jump_insns (expand_expr\n-\t\t\t\t   (gpr, NULL_RTX, SImode, EXPAND_NORMAL),\n-\t\t\t\t   GEN_INT ((REGPARM_MAX - needed_intregs +\n-\t\t\t\t\t     1) * 8), GE, const1_rtx, SImode,\n-\t\t\t\t   1, lab_false);\n-\t}\n-      if (needed_sseregs)\n-\t{\n-\t  emit_cmp_and_jump_insns (expand_expr\n-\t\t\t\t   (fpr, NULL_RTX, SImode, EXPAND_NORMAL),\n-\t\t\t\t   GEN_INT ((SSE_REGPARM_MAX -\n-\t\t\t\t\t     needed_sseregs + 1) * 16 +\n-\t\t\t\t\t    REGPARM_MAX * 8), GE, const1_rtx,\n-\t\t\t\t   SImode, 1, lab_false);\n-\t}\n-\n-      /* Compute index to start of area used for integer regs.  */\n-      if (needed_intregs)\n-\t{\n-\t  t = build (PLUS_EXPR, ptr_type_node, sav, gpr);\n-\t  r = expand_expr (t, int_addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != int_addr_rtx)\n-\t    emit_move_insn (int_addr_rtx, r);\n-\t}\n-      if (needed_sseregs)\n-\t{\n-\t  t = build (PLUS_EXPR, ptr_type_node, sav, fpr);\n-\t  r = expand_expr (t, sse_addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != sse_addr_rtx)\n-\t    emit_move_insn (sse_addr_rtx, r);\n-\t}\n-      if (need_temp)\n-\t{\n-\t  int i;\n-\t  rtx mem;\n-\t  rtx x;\n-\n-\t  /* Never use the memory itself, as it has the alias set.  */\n-\t  x = XEXP (assign_temp (type, 0, 1, 0), 0);\n-\t  mem = gen_rtx_MEM (BLKmode, x);\n-\t  force_operand (x, addr_rtx);\n-\t  set_mem_alias_set (mem, get_varargs_alias_set ());\n-\t  set_mem_align (mem, BITS_PER_UNIT);\n-\n-\t  for (i = 0; i < XVECLEN (container, 0); i++)\n-\t    {\n-\t      rtx slot = XVECEXP (container, 0, i);\n-\t      rtx reg = XEXP (slot, 0);\n-\t      enum machine_mode mode = GET_MODE (reg);\n-\t      rtx src_addr;\n-\t      rtx src_mem;\n-\t      int src_offset;\n-\t      rtx dest_mem;\n-\n-\t      if (SSE_REGNO_P (REGNO (reg)))\n-\t\t{\n-\t\t  src_addr = sse_addr_rtx;\n-\t\t  src_offset = (REGNO (reg) - FIRST_SSE_REG) * 16;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  src_addr = int_addr_rtx;\n-\t\t  src_offset = REGNO (reg) * 8;\n-\t\t}\n-\t      src_mem = gen_rtx_MEM (mode, src_addr);\n-\t      set_mem_alias_set (src_mem, get_varargs_alias_set ());\n-\t      src_mem = adjust_address (src_mem, mode, src_offset);\n-\t      dest_mem = adjust_address (mem, mode, INTVAL (XEXP (slot, 1)));\n-\t      emit_move_insn (dest_mem, src_mem);\n-\t    }\n-\t}\n-\n-      if (needed_intregs)\n-\t{\n-\t  t =\n-\t    build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t   build_int_2 (needed_intregs * 8, 0));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t}\n-      if (needed_sseregs)\n-\t{\n-\t  t =\n-\t    build (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t   build_int_2 (needed_sseregs * 16, 0));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t}\n-\n-      emit_jump_insn (gen_jump (lab_over));\n-      emit_barrier ();\n-      emit_label (lab_false);\n-    }\n-\n-  /* ... otherwise out of the overflow area.  */\n-\n-  /* Care for on-stack alignment if needed.  */\n-  if (FUNCTION_ARG_BOUNDARY (VOIDmode, type) <= 64)\n-    t = ovf;\n-  else\n-    {\n-      HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n-      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (align - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n-    }\n-  t = save_expr (t);\n-\n-  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-  if (r != addr_rtx)\n-    emit_move_insn (addr_rtx, r);\n-\n-  t =\n-    build (PLUS_EXPR, TREE_TYPE (t), t,\n-\t   build_int_2 (rsize * UNITS_PER_WORD, 0));\n-  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  if (container)\n-    emit_label (lab_over);\n-\n-  if (indirect_p)\n-    {\n-      r = gen_rtx_MEM (Pmode, addr_rtx);\n-      set_mem_alias_set (r, get_varargs_alias_set ());\n-      emit_move_insn (addr_rtx, r);\n-    }\n-\n-  return addr_rtx;\n-}\n-\n-/* Lower VA_ARG_EXPR at gimplification time.  */\n \n tree\n ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)"}, {"sha": "61a1f9e1dc427cc721ce5e4861d460195ea69904", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1790,8 +1790,7 @@ typedef struct ix86_args {\n   ix86_va_start (VALIST, NEXTARG)\n \n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) \\\n-  ix86_va_arg ((VALIST), (TYPE))\n+#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) (abort (), NULL_RTX)\n \n #define TARGET_ASM_FILE_END ix86_file_end\n #define NEED_INDICATE_EXEC_STACK 0"}, {"sha": "c29fee46d90dcf28275b8b5e2b2d02d4d5482677", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -3958,41 +3958,6 @@ ia64_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n \n /* Implement va_arg.  */\n \n-rtx\n-ia64_va_arg (tree valist, tree type)\n-{\n-  tree t;\n-\n-  /* Variable sized types are passed by reference.  */\n-  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-    {\n-      rtx addr = force_reg (ptr_mode,\n-\t    std_expand_builtin_va_arg (valist, build_pointer_type (type)));\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-      addr = convert_memory_address (Pmode, addr);\n-#endif\n-      return gen_rtx_MEM (ptr_mode, addr);\n-    }\n-\n-  /* Aggregate arguments with alignment larger than 8 bytes start at\n-     the next even boundary.  Integer and floating point arguments\n-     do so if they are larger than 8 bytes, whether or not they are\n-     also aligned larger than 8 bytes.  */\n-  if ((TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == INTEGER_TYPE)\n-      ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n-    {\n-      t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n-\n-  return std_expand_builtin_va_arg (valist, type);\n-}\n-\n static tree\n ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n {"}, {"sha": "a26a1da4b870965704932dfb5aa4037e34f80b48", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1403,8 +1403,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n  || ((REGNO) >= FR_ARG_FIRST && (REGNO) < (FR_ARG_FIRST + MAX_ARGUMENT_SLOTS)))\n \f\n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  ia64_va_arg (valist, type)\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) (abort (), NULL_RTX)\n \f\n /* How Scalar Function Values are Returned */\n "}, {"sha": "2376fc44498fdaa4c3747a7601cb76f33b2a5a16", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -5069,229 +5069,6 @@ rs6000_va_start (tree valist, rtx nextarg)\n \n /* Implement va_arg.  */\n \n-rtx\n-rs6000_va_arg (tree valist, tree type)\n-{\n-  tree f_gpr, f_fpr, f_res, f_ovf, f_sav;\n-  tree gpr, fpr, ovf, sav, reg, t, u;\n-  int indirect_p, size, rsize, n_reg, sav_ofs, sav_scale;\n-  rtx lab_false, lab_over, addr_rtx, r;\n-  int align;\n-\n-  if (DEFAULT_ABI != ABI_V4)\n-    {\n-      /* Variable sized types are passed by reference, as are AltiVec\n-\t vectors when 32-bit and not using the AltiVec ABI extension.  */\n-      if (int_size_in_bytes (type) < 0\n-\t  || (TARGET_32BIT\n-\t      && !TARGET_ALTIVEC_ABI\n-\t      && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n-\t{\n-\t  u = build_pointer_type (type);\n-\n-\t  /* Args grow upward.  */\n-\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (valist), valist,\n-\t\t     build_int_2 (POINTER_SIZE / BITS_PER_UNIT, 0));\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\n-\t  t = build1 (NOP_EXPR, build_pointer_type (u), t);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\n-\t  t = build1 (INDIRECT_REF, u, t);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\n-\t  return expand_expr (t, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t}\n-      if (targetm.calls.split_complex_arg\n-\t  && TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tree elem_type = TREE_TYPE (type);\n-\t  enum machine_mode elem_mode = TYPE_MODE (elem_type);\n-\t  int elem_size = GET_MODE_SIZE (elem_mode);\n-\n-\t  if (elem_size < UNITS_PER_WORD)\n-\t    {\n-\t      rtx real_part, imag_part, dest_real, rr;\n-\n-\t      real_part = rs6000_va_arg (valist, elem_type);\n-\t      imag_part = rs6000_va_arg (valist, elem_type);\n-\n-\t      /* We're not returning the value here, but the address.\n-\t\t real_part and imag_part are not contiguous, and we know\n-\t\t there is space available to pack real_part next to\n-\t\t imag_part.  float _Complex is not promoted to\n-\t\t double _Complex by the default promotion rules that\n-\t\t promote float to double.  */\n-\t      if (2 * elem_size > UNITS_PER_WORD)\n-\t\tabort ();\n-\n-\t      real_part = gen_rtx_MEM (elem_mode, real_part);\n-\t      imag_part = gen_rtx_MEM (elem_mode, imag_part);\n-\n-\t      dest_real = adjust_address (imag_part, elem_mode, -elem_size);\n-\t      rr = gen_reg_rtx (elem_mode);\n-\t      emit_move_insn (rr, real_part);\n-\t      emit_move_insn (dest_real, rr);\n-\n-\t      return XEXP (dest_real, 0);\n-\t    }\n-\t}\n-\n-      return std_expand_builtin_va_arg (valist, type);\n-    }\n-\n-  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_res = TREE_CHAIN (f_fpr);\n-  f_ovf = TREE_CHAIN (f_res);\n-  f_sav = TREE_CHAIN (f_ovf);\n-\n-  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n-\n-  size = int_size_in_bytes (type);\n-  rsize = (size + 3) / 4;\n-  align = 1;\n-\n-  if (AGGREGATE_TYPE_P (type)\n-      || TYPE_MODE (type) == TFmode\n-      || (!TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n-    {\n-      /* Aggregates, long doubles, and AltiVec vectors are passed by\n-\t reference.  */\n-      indirect_p = 1;\n-      reg = gpr;\n-      n_reg = 1;\n-      sav_ofs = 0;\n-      sav_scale = 4;\n-      size = 4;\n-      rsize = 1;\n-    }\n-  else if (TARGET_HARD_FLOAT && TARGET_FPRS\n-\t   && (TYPE_MODE (type) == SFmode || TYPE_MODE (type) == DFmode))\n-    {\n-      /* FP args go in FP registers, if present.  */\n-      indirect_p = 0;\n-      reg = fpr;\n-      n_reg = 1;\n-      sav_ofs = 8*4;\n-      sav_scale = 8;\n-      if (TYPE_MODE (type) == DFmode)\n-\talign = 8;\n-    }\n-  else\n-    {\n-      /* Otherwise into GP registers.  */\n-      indirect_p = 0;\n-      reg = gpr;\n-      n_reg = rsize;\n-      sav_ofs = 0;\n-      sav_scale = 4;\n-      if (n_reg == 2)\n-\talign = 8;\n-    }\n-\n-  /* Pull the value out of the saved registers....  */\n-\n-  lab_over = NULL_RTX;\n-  addr_rtx = gen_reg_rtx (Pmode);\n-\n-  /*  AltiVec vectors never go in registers when -mabi=altivec.  */\n-  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type)))\n-    align = 16;\n-  else\n-    {\n-      lab_false = gen_label_rtx ();\n-      lab_over = gen_label_rtx ();\n-\n-      /* Long long and SPE vectors are aligned in the registers.\n-\t As are any other 2 gpr item such as complex int due to a\n-\t historical mistake.  */\n-      u = reg;\n-      if (n_reg == 2)\n-\t{\n-\t  u = build (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n-\t\t     build_int_2 (n_reg - 1, 0));\n-\t  u = build (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, u);\n-\t  TREE_SIDE_EFFECTS (u) = 1;\n-\t}\n-\n-      emit_cmp_and_jump_insns\n-\t(expand_expr (u, NULL_RTX, QImode, EXPAND_NORMAL),\n-\t GEN_INT (8 - n_reg + 1), GE, const1_rtx, QImode, 1,\n-\t lab_false);\n-\n-      t = sav;\n-      if (sav_ofs)\n-\tt = build (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n-\n-      u = build (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg,\n-\t\t build_int_2 (n_reg, 0));\n-      TREE_SIDE_EFFECTS (u) = 1;\n-\n-      u = build1 (CONVERT_EXPR, integer_type_node, u);\n-      TREE_SIDE_EFFECTS (u) = 1;\n-\n-      u = build (MULT_EXPR, integer_type_node, u, build_int_2 (sav_scale, 0));\n-      TREE_SIDE_EFFECTS (u) = 1;\n-\n-      t = build (PLUS_EXPR, ptr_type_node, t, u);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-\n-      r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-      if (r != addr_rtx)\n-\temit_move_insn (addr_rtx, r);\n-\n-      emit_jump_insn (gen_jump (lab_over));\n-      emit_barrier ();\n-\n-      emit_label (lab_false);\n-      if (n_reg > 2)\n-\t{\n-\t  /* Ensure that we don't find any more args in regs.\n-\t     Alignment has taken care of the n_reg == 2 case.  */\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (reg), reg, build_int_2 (8, 0));\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t}\n-    }\n-\n-  /* ... otherwise out of the overflow area.  */\n-\n-  /* Care for on-stack alignment if needed.  */\n-  t = ovf;\n-  if (align != 1)\n-    {\n-      t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (align - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n-    }\n-  t = save_expr (t);\n-\n-  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-  if (r != addr_rtx)\n-    emit_move_insn (addr_rtx, r);\n-\n-  t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (size, 0));\n-  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  if (lab_over)\n-    emit_label (lab_over);\n-\n-  if (indirect_p)\n-    {\n-      r = gen_rtx_MEM (Pmode, addr_rtx);\n-      set_mem_alias_set (r, get_varargs_alias_set ());\n-      emit_move_insn (addr_rtx, r);\n-    }\n-\n-  return addr_rtx;\n-}\n-\n tree\n rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n {"}, {"sha": "b3ec7f8a65e199e7d24fb071ad305924e3fb23db", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1760,8 +1760,7 @@ typedef struct rs6000_args\n   rs6000_va_start (valist, nextarg)\n \n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  rs6000_va_arg (valist, type)\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) (abort (), NULL_RTX)\n \n #define PAD_VARARGS_DOWN \\\n    (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)"}, {"sha": "2f08388eb027586bef188f6a1d04b4763b8b376c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -5942,111 +5942,6 @@ sparc_va_start (tree valist, rtx nextarg)\n \n /* Implement `va_arg' for stdarg.  */\n \n-rtx\n-sparc_va_arg (tree valist, tree type)\n-{\n-  HOST_WIDE_INT size, rsize, align;\n-  tree addr, incr;\n-  rtx addr_rtx;\n-  bool indirect;\n-\n-  if (function_arg_pass_by_reference (0, TYPE_MODE (type), type, 0))\n-    {\n-      indirect = true;\n-      size = rsize = UNITS_PER_WORD;\n-      align = 0;\n-    }\n-  else\n-    {\n-      indirect = false;\n-      size = int_size_in_bytes (type);\n-      rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-      align = 0;\n-    \n-      if (TARGET_ARCH64)\n-\t{\n-\t  /* For SPARC64, objects requiring 16-byte alignment get it.  */\n-\t  if (TYPE_ALIGN (type) >= 2 * (unsigned) BITS_PER_WORD)\n-\t    align = 2 * UNITS_PER_WORD;\n-\n-\t  /* SPARC-V9 ABI states that structures up to 16 bytes in size\n-\t     are given whole slots as needed.  */\n-\t  if (AGGREGATE_TYPE_P (type))\n-\t    {\n-\t      if (size == 0)\n-\t\tsize = rsize = UNITS_PER_WORD;\n-\t      else\n-\t\tsize = rsize;\n-\t    }\n-\t}\n-    }\n-\n-  incr = valist;\n-  if (align)\n-    {\n-      incr = fold (build (PLUS_EXPR, ptr_type_node, incr,\n-\t\t\t build_int_2 (align - 1, 0)));\n-      incr = fold (build (BIT_AND_EXPR, ptr_type_node, incr,\n-\t\t\t  build_int_2 (-align, -1)));\n-    }\n-\n-  addr = incr = save_expr (incr);\n-  if (BYTES_BIG_ENDIAN && size < rsize)\n-    {\n-      addr = fold (build (PLUS_EXPR, ptr_type_node, incr,\n-\t\t\t  build_int_2 (rsize - size, 0)));\n-    }\n-  incr = fold (build (PLUS_EXPR, ptr_type_node, incr,\n-\t\t      build_int_2 (rsize, 0)));\n-\n-  incr = build (MODIFY_EXPR, ptr_type_node, valist, incr);\n-  TREE_SIDE_EFFECTS (incr) = 1;\n-  expand_expr (incr, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  addr_rtx = expand_expr (addr, NULL, Pmode, EXPAND_NORMAL);\n-\n-  /* If the address isn't aligned properly for the type,\n-     we may need to copy to a temporary.  \n-     FIXME: This is inefficient.  Usually we can do this\n-     in registers.  */\n-  if (align == 0\n-      && TYPE_ALIGN (type) > BITS_PER_WORD\n-      && !indirect)\n-    {\n-      /* FIXME: We really need to specify that the temporary is live\n-\t for the whole function because expand_builtin_va_arg wants\n-\t the alias set to be get_varargs_alias_set (), but in this\n-\t case the alias set is that for TYPE and if the memory gets\n-\t reused it will be reused with alias set TYPE.  */\n-      rtx tmp = assign_temp (type, 0, 1, 0);\n-      rtx dest_addr;\n-\n-      addr_rtx = force_reg (Pmode, addr_rtx);\n-      addr_rtx = gen_rtx_MEM (BLKmode, addr_rtx);\n-      set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n-      set_mem_align (addr_rtx, BITS_PER_WORD);\n-      tmp = shallow_copy_rtx (tmp);\n-      PUT_MODE (tmp, BLKmode);\n-      set_mem_alias_set (tmp, 0);\n-      \n-      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize),\n-\t\t\t\t   BLOCK_OP_NORMAL);\n-      if (dest_addr != NULL_RTX)\n-\taddr_rtx = dest_addr;\n-      else\n-\taddr_rtx = XCEXP (tmp, 0, MEM);\n-    }\n-\n-  if (indirect)\n-    {\n-      addr_rtx = force_reg (Pmode, addr_rtx);\n-      addr_rtx = gen_rtx_MEM (Pmode, addr_rtx);\n-      set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n-    }\n-\n-  return addr_rtx;\n-}\n-\n tree\n sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n {"}, {"sha": "0b2dceba1e26841ff13868b8b602082e7ade5554", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1804,8 +1804,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   sparc_va_start (valist, nextarg)\n \n /* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  sparc_va_arg (valist, type)\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) (abort (), NULL_RTX)\n \n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */"}, {"sha": "70b89f6fa25d6695f76366080935e629fc3a7584", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -3870,11 +3870,15 @@ This hook performs target-specific gimplification of\n arguments to @code{va_arg}; the latter two are as in\n @code{gimplify.c:gimplify_expr}.\n \n-You only need to define this hook if you also define\n+You only need to define this hook if you previously defined\n @code{EXPAND_BUILTIN_VA_ARG}; it is pretty easy to reuse the same code\n for both.  One significant difference is that\n @code{EXPAND_BUILTIN_VA_ARG} returns an address, whereas this hook\n produces an expression of type @var{type}, usually an @code{INDIRECT_REF}.\n+\n+Once you define this macro, you can change\n+@code{EXPAND_BUILTIN_VA_ARG} to just abort, as it should never be\n+called.\n @end deftypefn\n \n @node Scalar Return"}, {"sha": "a4a0bc41d6ea45c816ed256fc327f61712886ac5", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -1716,24 +1716,16 @@ tree_could_throw_p (tree t)\n     return false;\n   if (TREE_CODE (t) == MODIFY_EXPR)\n     {\n-      tree sub = TREE_OPERAND (t, 1);\n-      if (TREE_CODE (sub) == CALL_EXPR)\n-\tt = sub;\n-      else\n-\t{\n-\t  if (flag_non_call_exceptions)\n-\t    {\n-\t      if (tree_could_trap_p (sub))\n-\t\treturn true;\n-\t      return tree_could_trap_p (TREE_OPERAND (t, 0));\n-\t    }\n-\t  return false;\n-\t}\n+      if (flag_non_call_exceptions\n+\t  && tree_could_trap_p (TREE_OPERAND (t, 0)))\n+\treturn true;\n+      t = TREE_OPERAND (t, 1);\n     }\n \n   if (TREE_CODE (t) == CALL_EXPR)\n     return (call_expr_flags (t) & ECF_NOTHROW) == 0;\n-\n+  if (flag_non_call_exceptions)\n+    return tree_could_trap_p (t);\n   return false;\n }\n "}, {"sha": "b94a799946b7e30fd62743263083379e80fefd37", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c605a553faab6244a1b1d987059798e6c1f9aa/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=67c605a553faab6244a1b1d987059798e6c1f9aa", "patch": "@@ -821,7 +821,11 @@ get_stmt_operands (tree stmt)\n       if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF \n           || TREE_CODE (TREE_OPERAND (stmt, 0)) == COMPONENT_REF\n \t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == REALPART_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == IMAGPART_EXPR)\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == IMAGPART_EXPR\n+\t  /* Use a V_MAY_DEF if the RHS might throw, as the LHS won't be\n+\t     modified in that case.  FIXME we should represent somehow\n+\t     that it is killed on the fallthrough path.  */\n+\t  || tree_could_throw_p (TREE_OPERAND (stmt, 1)))\n         get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_is_def, \n \t                   &prev_vops);\n       else"}]}