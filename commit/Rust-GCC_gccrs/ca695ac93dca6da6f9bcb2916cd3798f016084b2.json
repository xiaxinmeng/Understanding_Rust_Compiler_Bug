{"sha": "ca695ac93dca6da6f9bcb2916cd3798f016084b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2OTVhYzkzZGNhNmRhNmY5YmNiMjkxNmNkMzc5OGYwMTYwODRiMg==", "commit": {"author": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:25:24Z"}, "committer": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-21T21:25:24Z"}, "message": "bytecode\n\nFrom-SVN: r5379", "tree": {"sha": "9955b06ba9da7010dd96c146915e52676d09d15f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9955b06ba9da7010dd96c146915e52676d09d15f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca695ac93dca6da6f9bcb2916cd3798f016084b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca695ac93dca6da6f9bcb2916cd3798f016084b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca695ac93dca6da6f9bcb2916cd3798f016084b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca695ac93dca6da6f9bcb2916cd3798f016084b2/comments", "author": null, "committer": null, "parents": [{"sha": "86d7f2db057abae09db4208bf0578f6e9a0da17b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d7f2db057abae09db4208bf0578f6e9a0da17b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86d7f2db057abae09db4208bf0578f6e9a0da17b"}], "stats": {"total": 7758, "additions": 5248, "deletions": 2510}, "files": [{"sha": "2c044eedadf8da2d8c450726329ef9c80108274c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 72, "deletions": 11, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -399,6 +399,9 @@ CPLUS_OBJS = cp-parse.o cp-decl.o cp-decl2.o \\\n    cp-expr.o cp-pt.o cp-edsel.o cp-xref.o \\\n    $(CPLUS_INPUT) cp-spew.o c-common.o\n \n+# Files specific to the C interpreter bytecode compiler(s).\n+BC_OBJS = bc-emit.o bc-optab.o\n+\n # Language-independent object files.\n OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o expr.o calls.o expmed.o explow.o optabs.o varasm.o \\\n@@ -461,6 +464,7 @@ CONFIG_H =\n RTL_H = rtl.h rtl.def machmode.h machmode.def\n TREE_H = tree.h real.h tree.def machmode.h machmode.def\n CPLUS_TREE_H = $(TREE_H) cp-tree.h cp-tree.def\n+BYTECODE_H = bytecode.h bc-emit.h bc-optab.h\n \f\n # Avoid a lot of time thinking about remaking Makefile.in and *.def.\n .SUFFIXES: .in .def\n@@ -484,7 +488,7 @@ for-bootstrap: start.encap $(LIBGCC)\n rest.encap: $(LIBGCC) stmp-headers $(STMP_FIXPROTO) $(EXTRA_PARTS)\n # This is what is made with the host's compiler\n # whether making a cross compiler or not.\n-native: config.status cpp $(LANGUAGES) $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)\n+native: bytecode config.status cpp $(LANGUAGES) $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)\n \n # Define the names for selecting languages in LANGUAGES.\n C c: cc1\n@@ -545,14 +549,14 @@ g++-cross: $(srcdir)/g++.c\n \t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o g++-cross \\\n \t   -DGCC_NAME=\\\"$(target)-gcc\\\" $(srcdir)/g++.c version.o $(LIBS)\n \n-cc1:$(P) $(C_OBJS) $(OBJS) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1 $(C_OBJS) $(OBJS) $(LIBS)\n+cc1:$(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1 $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)\n \n-cc1plus:$(P) $(CPLUS_OBJS) $(OBJS) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1plus $(CPLUS_OBJS) $(OBJS) $(LIBS)\n+cc1plus:$(P) $(CPLUS_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1plus $(CPLUS_OBJS) $(BC_OBJS) $(OBJS) $(LIBS)\n \n-cc1obj:$(P) $(OBJC_OBJS) $(OBJS) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1obj $(OBJC_OBJS) $(OBJS) $(LIBS)\n+cc1obj:$(P) $(OBJC_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1obj $(OBJC_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)\n \n # Copy float.h from its source.\n gfloat.h: $(FLOAT_H)\n@@ -1247,6 +1251,63 @@ $(HOST_PREFIX_1)malloc.o: malloc.c\n $(HOST_PREFIX_1): \n \ttouch $(HOST_PREFIX_1)\n \f\n+# Remake bytecode files.\n+# BI_ALL=bi-run.o\n+BI_ALL=\n+BC_ALL=bc-opname.h bc-opcode.h bc-arity.h\n+BI_OBJ=bi-parser.o bi-lexer.o bi-reverse.o\n+\n+\n+bc-emit.o : bc-emit.c $(CONFIG_H) $(BYTECODE_H)\n+bc-optab.o : bc-optab.c bc-typecd.def $(CONFIG_H) $(BYTECODE_H)\n+\n+\n+bytecode: $(BI_ALL) $(BC_ALL)\n+\n+bi-arity:\tbi-arity.o\n+bi-opcode:\tbi-opcode.o\n+bi-opname:\tbi-opname.o\n+bi-unparse:\tbi-unparse.o\n+bi-lexer:\tbi-lexer.o\n+\n+bi-arity bi-opcode bi-opname bi-unparse bi-lexer: $(BI_OBJ)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $^ $(LEXLIB)\n+\n+bi-run.o:\t$(srcdir)/bi-run.c $(srcdir)/bi-run.h $(srcdir)/bc-typecd.h bc-opname.h bc-arity.h bc-opcode.h\n+\t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $<\n+\n+bi-parser.c: $(srcdir)/bi-parser.y $(srcdir)/bi-parser.h\n+\n+bi-parser.o:\t$(srcdir)/bi-parser.c $(srcdir)/bi-defs.h\n+\t$(CC) $(CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $<\n+\n+bi-lexer.c:\t$(srcdir)/bi-lexer.l $(srcdir)/bi-parser.h\n+\n+bi-lexer.o:\tbi-lexer.c bi-parser.h\n+\t$(CC) $(CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $<\n+\n+bc-arity.h:\t$(srcdir)/bytecode.def bi-arity\n+\t-rm -f $@\n+\tbi-arity <$< >$@\n+\n+bc-opcode.h:\t$(srcdir)/bytecode.def bi-opcode\n+\t-rm -f $@\n+\tbi-opcode <$< >$@\n+\n+bc-opname.h:\t $(srcdir)/bytecode.def bi-opname\n+\t-rm -f $@\n+\tbi-opname <$< >$@\n+\n+bytecode.mostlyclean:\n+\t-rm -f bc-arity.h bc-opcode.h bc-opname.h\n+\n+bytecode.distclean bytecode.clean:\tbytecode.mostlyclean\n+\t-rm -f bi-arity bi-opcode bi-opname bi-unparse bi-lexer\n+\n+bytecode.realclean: bytecode.clean\n+\t-rm -f bi-parser.c bi-lexer.c bi-parser.h\n+\n+\f\n # Remake cpp and protoize.\n \n # Making the preprocessor\n@@ -1507,7 +1568,7 @@ $(srcdir)/INSTALL: install1.texi install.texi\n # `realclean' also deletes everything that could be regenerated automatically.\n \n \n-mostlyclean:\n+mostlyclean: bytecode.mostlyclean\n \t-rm -f $(STAGESTUFF)\n # Clean the objc subdir if we created one.\n \tif [ -d objc ]; then \\\n@@ -1545,7 +1606,7 @@ mostlyclean:\n \n # Delete all files made by compilation\n # that don't exist in the distribution.\n-clean: mostlyclean\n+clean: mostlyclean bytecode.clean\n # It may not be quite desirable to delete unprotoize.c here,\n # but the spec for `make clean' requires it.\n # Using unprotoize.c is not quite right in the first place, \n@@ -1557,7 +1618,7 @@ clean: mostlyclean\n \n # Delete all files that users would normally create\n # while building and installing GCC.\n-distclean: clean\n+distclean: clean bytecode.distclean\n \t-rm -f tm.h aux-output.c config.h md config.status tconfig.h hconfig.h\n \t-rm -f Makefile *.oaux\n \t-rm -fr stage1 stage2 stage3 stage4\n@@ -1581,7 +1642,7 @@ extraclean: distclean\n \n # Get rid of every file that's generated from some other file.\n # Most of these files ARE PRESENT in the GCC distribution.\n-realclean: distclean\n+realclean: distclean bytecode.realclean\n \t-rm -f c-parse.y objc-parse.y\n \t-rm -f cp-parse.c cp-parse.h cp-parse.output\n \t-rm -f objc-parse.c objc-parse.output"}, {"sha": "002c0946780fea7c4ec06cd8f8e84dd95dc57bef", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -20,6 +20,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <stdio.h>\n #include \"config.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n \n #ifdef HANDLE_SYSV_PRAGMA\n \n@@ -45,20 +46,7 @@ handle_pragma_token (string, token)\n      char *string;\n      tree token;\n {\n-  static enum pragma_state\n-    {\n-      ps_start,\n-      ps_done,\n-      ps_bad,\n-      ps_weak,\n-      ps_name,\n-      ps_equals,\n-      ps_value,\n-      ps_pack,\n-      ps_left,\n-      ps_align,\n-      ps_right\n-      } state = ps_start, type;\n+  static enum pragma_state state = ps_start, type;\n   static char *name;\n   static char *value;\n   static int align;\n@@ -76,24 +64,8 @@ handle_pragma_token (string, token)\n \t{\n #ifdef HANDLE_PRAGMA_WEAK\n \t  if (HANDLE_PRAGMA_WEAK)\n-\t    {\n-\t      if (state == ps_name || state == ps_value)\n-\t\t{\n-\t\t  fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n-\t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n-\t\t  fputc ('\\n', asm_out_file);\n-\t\t  if (state == ps_value)\n-\t\t    {\n-\t\t      fprintf (asm_out_file, \"\\t%s\\t\", SET_ASM_OP);\n-\t\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n-\t\t      fputc (',', asm_out_file);\n-\t\t      ASM_OUTPUT_LABELREF (asm_out_file, value);\n-\t\t      fputc ('\\n', asm_out_file);\n-\t\t    }\n-\t\t}\n-\t      else if (! (state == ps_done || state == ps_start))\n-\t\twarning (\"malformed `#pragma weak'\");\n-\t    }\n+\t    handle_pragma_weak (state, asm_out_file, name, value);\n+\n #endif /* HANDLE_PRAMA_WEAK */\n \t}\n "}, {"sha": "a927fd0a5ceade2b0b8771b054b3fa72313fd1a7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -42,8 +42,29 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"regs.h\"\n #include \"insn-config.h\"\n #include \"real.h\"\n+#include \"obstack.h\"\n+\n+#include \"bytecode.h\"\n+#include \"machmode.h\"\n+#include \"bc-opcode.h\"\n+#include \"bc-typecd.h\"\n+#include \"bc-optab.h\"\n+#include \"bc-emit.h\"\n+\n #include <stdio.h>\n \n+\n+/* Opcode names */\n+#ifdef BCDEBUG_PRINT_CODE\n+char *opcode_name[] =\n+{\n+#include \"bc-opname.h\"\n+\n+\"***END***\"\n+};\n+#endif\n+\n+\n /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n    After rtl generation, it is 1 plus the largest register number used.  */\n \n@@ -203,6 +224,11 @@ extern int emit_lineno;\n rtx change_address ();\n void init_emit ();\n \f\n+extern struct obstack *rtl_obstack;\n+\n+extern int stack_depth;\n+extern int max_stack_depth;\n+\f\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n **\n **\t    This routine generates an RTX of the size specified by\n@@ -1216,8 +1242,12 @@ change_address (memref, mode, addr)\n rtx\n gen_label_rtx ()\n {\n-  register rtx label = gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0,\n-\t\t\t\tlabel_num++, NULL_PTR);\n+  register rtx label;\n+\n+  label = output_bytecode\n+    ? bc_gen_rtx (0, 0, bc_get_bytecode_label ())\n+      : gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0, label_num++, NULL_PTR);\n+\n   LABEL_NUSES (label) = 0;\n   return label;\n }\n@@ -2559,6 +2589,13 @@ emit_line_note (file, line)\n      char *file;\n      int line;\n {\n+  if (output_bytecode)\n+    {\n+      /* FIXME: for now we do nothing, but eventually we will have to deal with\n+\t debugging information.  */\n+      return 0;\n+    }\n+\n   emit_filename = file;\n   emit_lineno = line;\n "}, {"sha": "33f1bae588af196c05b810a231bc29988744e718", "filename": "gcc/expr.c", "status": "modified", "additions": 3617, "deletions": 2309, "changes": 5926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2"}, {"sha": "c5e049484765055daec0786b682cc056b57ac7c2", "filename": "gcc/integrate.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -32,6 +32,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"integrate.h\"\n #include \"real.h\"\n #include \"function.h\"\n+#include \"bytecode.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -2850,9 +2851,16 @@ void\n output_inline_function (fndecl)\n      tree fndecl;\n {\n-  rtx head = DECL_SAVED_INSNS (fndecl);\n+  rtx head;\n   rtx last;\n \n+  if (output_bytecode)\n+    {\n+      warning (\"`inline' ignored for bytecode output\");\n+      return;\n+    }\n+\n+  head = DECL_SAVED_INSNS (fndecl);\n   current_function_decl = fndecl;\n \n   /* This call is only used to initialize global variables.  */"}, {"sha": "47da72fc69c73f320245ba58e5f04ee8eabc421b", "filename": "gcc/regclass.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -32,6 +32,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"recog.h\"\n #include \"reload.h\"\n #include \"real.h\"\n+#include \"bytecode.h\"\n \n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n@@ -413,6 +414,13 @@ fix_register (name, fixed, call_used)\n {\n   int i;\n \n+  if (output_bytecode)\n+    {\n+      warning (\"request to mark `%s' as %s ignored by bytecode compiler\",\n+\t       name, call_used ? \"call-used\" : \"fixed\");\n+      return;\n+    }\n+\n   /* Decode the name and update the primary form of\n      the register info.  */\n "}, {"sha": "945fbc8d22c7929b751e109e3357bfd4e2f963a2", "filename": "gcc/rtl.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -139,6 +139,22 @@ typedef struct rtx_def\n      The number of operands and their types are controlled\n      by the `code' field, according to rtl.def.  */\n   rtunion fld[1];\n+\n+  /* The rest is used instead of the above if bytecode is being output */\n+\n+  /* For static or external objects.  */\n+  char *label;\n+\n+  /* From the named label, or the local variable pointer or the\n+     argument pointer, depending on context.  */\n+\n+  int offset;\n+\n+  /* For goto labels inside bytecode functions.  */\n+  struct bc_label *bc_label;\n+\n+  /* A unique identifier */\n+  int uid;\n } *rtx;\n \n /* Add prototype support.  */\n@@ -640,6 +656,7 @@ extern rtx gen_rtx\t\t\tPROTO((enum rtx_code, enum machine_mode, ...));\n extern rtvec gen_rtvec\t\t\tPROTO((int, ...));\n \n #else\n+extern rtx bc_gen_rtx ();\n extern rtx gen_rtx ();\n extern rtvec gen_rtvec ();\n #endif"}, {"sha": "2b9ff9145dd513b9e1800cfe80b226c0dcb56ae4", "filename": "gcc/stmt.c", "status": "modified", "additions": 902, "deletions": 28, "changes": 930, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -49,6 +49,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"loop.h\"\n #include \"recog.h\"\n+#include \"machmode.h\"\n+\n+#include \"bytecode.h\"\n+#include \"bc-typecd.h\"\n+#include \"bc-opcode.h\"\n+#include \"bc-optab.h\"\n+#include \"bc-emit.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -181,13 +188,28 @@ static void emit_jump_if_reachable ();\n \n static int warn_if_unused_value ();\n static void expand_goto_internal ();\n+static void bc_expand_goto_internal ();\n static int expand_fixup ();\n+static void bc_expand_fixup ();\n void fixup_gotos ();\n+static void bc_fixup_gotos ();\n void free_temp_slots ();\n static void expand_cleanups ();\n static void expand_null_return_1 ();\n static int tail_recursion_args ();\n static void do_jump_if_equal ();\n+int bc_expand_exit_loop_if_false ();\n+void bc_expand_start_cond ();\n+void bc_expand_end_cond ();\n+void bc_expand_start_else ();\n+void bc_expand_end_bindings ();\n+void bc_expand_start_case ();\n+void bc_check_for_full_enumeration_handling ();\n+void bc_expand_end_case ();\n+void bc_expand_decl ();\n+\n+extern rtx bc_allocate_local ();\n+extern rtx bc_allocate_variable_array ();\n \f\n /* Stack of control and binding constructs we are currently inside.\n \n@@ -250,7 +272,8 @@ struct nesting\n \t  /* Sequence number of this binding contour within the function,\n \t     in order of entry.  */\n \t  int block_start_count;\n-\t  /* Nonzero => value to restore stack to on exit.  */\n+\t  /* Nonzero => value to restore stack to on exit.  Complemented by\n+\t     bc_stack_level (see below) when generating bytecodes. */\n \t  rtx stack_level;\n \t  /* The NOTE that starts this contour.\n \t     Used by expand_goto to check whether the destination\n@@ -277,6 +300,8 @@ struct nesting\n \t  struct label_chain *label_chain;\n \t  /* Number of function calls seen, as of start of this block.  */\n \t  int function_call_count;\n+\t  /* Bytecode specific: stack level to restore stack to on exit.  */\n+\t  int bc_stack_level;\n \t} block;\n       /* For switch (C) or case (Pascal) statements,\n \t and also for dummies (see `expand_start_case_dummy').  */\n@@ -285,6 +310,10 @@ struct nesting\n \t  /* The insn after which the case dispatch should finally\n \t     be emitted.  Zero for a dummy.  */\n \t  rtx start;\n+\t  /* For bytecodes, the case table is in-lined right in the code.\n+\t     A label is needed for skipping over this block. It is only\n+\t     used when generating bytecodes. */\n+\t  rtx skip_label;\n \t  /* A list of case labels, kept in ascending order by value\n \t     as the list is built.\n \t     During expand_end_case, this list may be rearranged into a\n@@ -425,6 +454,21 @@ struct goto_fixup\n      time this goto was seen.\n      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */\n   tree cleanup_list_list;\n+\n+  /* Bytecode specific members follow */\n+\n+  /* The label that this jump is jumping to, or 0 for break, continue\n+     or return.  */\n+  struct bc_label *bc_target;\n+\n+  /* The label we use for the fixup patch */\n+  struct bc_label *label;\n+\n+  /* True (non-0) if fixup has been handled */\n+  int bc_handled:1;\n+\n+  /* Like stack_level above, except refers to the interpreter stack */\n+  int bc_stack_level;\n };\n \n static struct goto_fixup *goto_fixup_chain;\n@@ -514,11 +558,16 @@ restore_stmt_status (p)\n void\n emit_nop ()\n {\n-  rtx last_insn = get_last_insn ();\n-  if (!optimize\n-      && (GET_CODE (last_insn) == CODE_LABEL\n-\t  || prev_real_insn (last_insn) == 0))\n-    emit_insn (gen_nop ());\n+  rtx last_insn;\n+\n+  if (!output_bytecode)\n+    {\n+      last_insn = get_last_insn ();\n+      if (!optimize\n+\t  && (GET_CODE (last_insn) == CODE_LABEL\n+\t      || prev_real_insn (last_insn) == 0))\n+\temit_insn (gen_nop ());\n+    }\n }\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n@@ -555,9 +604,17 @@ void\n expand_computed_goto (exp)\n      tree exp;\n {\n-  rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n-  emit_queue ();\n-  emit_indirect_jump (x);\n+  if (output_bytecode)\n+    {\n+      bc_expand_expr (exp);\n+      bc_emit_instruction (jumpP);\n+    }\n+  else\n+    {\n+      rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+      emit_queue ();\n+      emit_indirect_jump (x);\n+    }\n }\n \f\n /* Handle goto statements and the labels that they can go to.  */\n@@ -579,6 +636,15 @@ expand_label (label)\n {\n   struct label_chain *p;\n \n+  if (output_bytecode)\n+    {\n+      if (! DECL_RTL (label))\n+\tDECL_RTL (label) = bc_gen_rtx ((char *) 0, 0, bc_get_bytecode_label ());\n+      if (! bc_emit_bytecode_labeldef (DECL_RTL (label)->bc_label))\n+\terror (\"multiply defined label\");\n+      return;\n+    }\n+\n   do_pending_stack_adjust ();\n   emit_label (label_rtx (label));\n   if (DECL_NAME (label))\n@@ -620,8 +686,16 @@ void\n expand_goto (label)\n      tree label;\n {\n+  tree context;\n+\n+  if (output_bytecode)\n+    {\n+      expand_goto_internal (label, label_rtx (label), NULL_RTX);\n+      return;\n+    }\n+\n   /* Check for a nonlocal goto to a containing function.  */\n-  tree context = decl_function_context (label);\n+  context = decl_function_context (label);\n   if (context != 0 && context != current_function_decl)\n     {\n       struct function *p = find_function_data (context);\n@@ -701,6 +775,16 @@ expand_goto_internal (body, label, last_insn)\n   struct nesting *block;\n   rtx stack_level = 0;\n \n+  /* NOTICE!  If a bytecode instruction other than `jump' is needed,\n+     then the caller has to call bc_expand_goto_internal()\n+     directly. This is rather an exceptional case, and there aren't\n+     that many places where this is necessary. */\n+  if (output_bytecode)\n+    {\n+      expand_goto_internal (body, label, last_insn);\n+      return;\n+    }\n+\n   if (GET_CODE (label) != CODE_LABEL)\n     abort ();\n \n@@ -753,6 +837,77 @@ expand_goto_internal (body, label, last_insn)\n   emit_jump (label);\n }\n \f\n+/* Generate a jump with OPCODE to the given bytecode LABEL which is\n+   found within BODY. */\n+static void\n+bc_expand_goto_internal (opcode, label, body)\n+     enum bytecode_opcode opcode;\n+     struct bc_label *label;\n+     tree body;\n+{\n+  struct nesting *block;\n+  int stack_level = -1;\n+\n+  /* If the label is defined, adjust the stack as necessary.\n+     If it's not defined, we have to push the reference on the\n+     fixup list. */\n+\n+  if (label->defined)\n+    {\n+\n+      /* Find the innermost pending block that contains the label.\n+\t (Check containment by comparing bytecode uids.)  Then restore the\n+\t outermost stack level within that block.  */\n+\n+      for (block = block_stack; block; block = block->next)\n+\t{\n+\t  if (block->data.block.first_insn->uid < label->uid)\n+\t    break;\n+\t  if (block->data.block.bc_stack_level)\n+\t    stack_level = block->data.block.bc_stack_level;\n+\n+\t  /* Execute the cleanups for blocks we are exiting.  */\n+\t  if (block->data.block.cleanups != 0)\n+\t    {\n+\t      expand_cleanups (block->data.block.cleanups, NULL_TREE);\n+\t      do_pending_stack_adjust ();\n+\t    }\n+\t}\n+\n+      /* Restore the stack level. If we need to adjust the stack, we\n+\t must do so after the jump, since the jump may depend on\n+\t what's on the stack.  Thus, any stack-modifying conditional\n+\t jumps (these are the only ones that rely on what's on the\n+\t stack) go into the fixup list. */\n+\n+      if (stack_level >= 0\n+\t  && stack_depth != stack_level\n+\t  && opcode != jump)\n+\n+\tbc_expand_fixup (opcode, label, stack_level);\n+      else\n+\t{\n+\t  if (stack_level >= 0)\n+\t    bc_adjust_stack (stack_depth - stack_level);\n+\n+\t  if (body && DECL_BIT_FIELD (body))\n+\t    error (\"jump to `%s' invalidly jumps into binding contour\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (body)));\n+\t  \n+\t  /* Emit immediate jump */\n+\t  bc_emit_bytecode (opcode);\n+\t  bc_emit_bytecode_labelref (label);\n+\t  \n+#ifdef DEBUG_PRINT_CODE\n+\t  fputc ('\\n', stderr);\n+#endif\n+\t}\n+    }\n+  else\n+    /* Put goto in the fixup list */\n+    bc_expand_fixup (opcode, label, stack_level);\n+}\n+\f\n /* Generate if necessary a fixup for a goto\n    whose target label in tree structure (if any) is TREE_LABEL\n    and whose target in rtl is RTL_LABEL.\n@@ -884,6 +1039,37 @@ expand_fixup (tree_label, rtl_label, last_insn)\n   return block != 0;\n }\n \n+\n+/* Generate bytecode jump with OPCODE to a fixup routine that links to LABEL.\n+   Make the fixup restore the stack level to STACK_LEVEL.  */\n+\n+static void\n+bc_expand_fixup (opcode, label, stack_level)\n+     enum bytecode_opcode opcode;\n+     struct bc_label *label;\n+     int stack_level;\n+{\n+  struct goto_fixup *fixup\n+    = (struct goto_fixup *) oballoc (sizeof (struct goto_fixup));\n+\n+  fixup->label  = bc_get_bytecode_label ();\n+  fixup->bc_target = label;\n+  fixup->bc_stack_level = stack_level;\n+  fixup->bc_handled = FALSE;\n+\n+  fixup->next = goto_fixup_chain;\n+  goto_fixup_chain = fixup;\n+\n+  /* Insert a jump to the fixup code */\n+  bc_emit_bytecode (opcode);\n+  bc_emit_bytecode_labelref (fixup->label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+}\n+\n+\n /* When exiting a binding contour, process all pending gotos requiring fixups.\n    THISBLOCK is the structure that describes the block being exited.\n    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.\n@@ -907,6 +1093,12 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n {\n   register struct goto_fixup *f, *prev;\n \n+  if (output_bytecode)\n+    {\n+      bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in);\n+      return;\n+    }\n+\n   /* F is the fixup we are considering; PREV is the previous one.  */\n   /* We run this loop in two passes so that cleanups of exited blocks\n      are run first, and blocks that are exited are marked so\n@@ -1039,6 +1231,72 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t  f->stack_level = stack_level;\n       }\n }\n+\n+\n+/* When exiting a binding contour, process all pending gotos requiring fixups.\n+   Note: STACK_DEPTH is not altered.\n+\n+   The arguments are currently not used in the bytecode compiler, but we may need\n+   them one day for languages other than C.\n+\n+   THISBLOCK is the structure that describes the block being exited.\n+   STACK_LEVEL is the rtx for the stack level to restore exiting this contour.\n+   CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.\n+   FIRST_INSN is the insn that began this contour.\n+\n+   Gotos that jump out of this contour must restore the\n+   stack level and do the cleanups before actually jumping.\n+\n+   DONT_JUMP_IN nonzero means report error there is a jump into this\n+   contour from before the beginning of the contour.\n+   This is also done if STACK_LEVEL is nonzero.  */\n+\n+static void\n+bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n+     struct nesting *thisblock;\n+     int stack_level;\n+     tree cleanup_list;\n+     rtx first_insn;\n+     int dont_jump_in;\n+{\n+  register struct goto_fixup *f, *prev;\n+  int saved_stack_depth;\n+\n+  /* F is the fixup we are considering; PREV is the previous one.  */\n+\n+  for (prev = 0, f = goto_fixup_chain; f; prev = f, f = f->next)\n+    {\n+      /* Test for a fixup that is inactive because it is already handled.  */\n+      if (f->before_jump == 0)\n+\t{\n+\t  /* Delete inactive fixup from the chain, if that is easy to do.  */\n+\t  if (prev)\n+\t    prev->next = f->next;\n+\t}\n+\n+      /* Emit code to restore the stack and continue */\n+      bc_emit_bytecode_labeldef (f->label);\n+\n+      /* Save stack_depth across call, since bc_adjust_stack () will alter\n+         the perceived stack depth via the instructions generated. */\n+\n+      if (f->bc_stack_level >= 0)\n+\t{\n+\t  saved_stack_depth = stack_depth;\n+\t  bc_adjust_stack (stack_depth - f->bc_stack_level);\n+\t  stack_depth = saved_stack_depth;\n+\t}\n+\n+      bc_emit_bytecode (jump);\n+      bc_emit_bytecode_labelref (f->bc_target);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+    }\n+\n+  goto_fixup_chain = NULL;\n+}\n \f\n /* Generate RTL for an asm statement (explicit assembler code).\n    BODY is a STRING_CST node containing the assembler code text,\n@@ -1048,6 +1306,12 @@ void\n expand_asm (body)\n      tree body;\n {\n+  if (output_bytecode)\n+    {\n+      error (\"`asm' is illegal when generating bytecode\");\n+      return;\n+    }\n+\n   if (TREE_CODE (body) == ADDR_EXPR)\n     body = TREE_OPERAND (body, 0);\n \n@@ -1090,6 +1354,12 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   /* The insn we have emitted.  */\n   rtx insn;\n \n+  if (output_bytecode)\n+    {\n+      error (\"`asm' is illegal when generating bytecode\");\n+      return;\n+    }\n+\n   /* Count the number of meaningful clobbered registers, ignoring what\n      we would ignore later.  */\n   nclobbers = 0;\n@@ -1310,6 +1580,22 @@ void\n expand_expr_stmt (exp)\n      tree exp;\n {\n+  if (output_bytecode)\n+    {\n+      int org_stack_depth = stack_depth;\n+\n+      bc_expand_expr (exp);\n+\n+      /* Restore stack depth */\n+      if (stack_depth < org_stack_depth)\n+\tabort ();\n+      \n+      bc_emit_instruction (drop);\n+\n+      last_expr_type = TREE_TYPE (exp);\n+      return;\n+    }\n+\n   /* If -W, warn about statements with no side effects,\n      except for an explicit cast to void (e.g. for assert()), and\n      except inside a ({...}) where they may be useful.  */\n@@ -1459,10 +1745,17 @@ clear_last_expr ()\n tree\n expand_start_stmt_expr ()\n {\n+  int momentary;\n+  tree t;\n+\n+  /* When generating bytecode just note down the stack depth */\n+  if (output_bytecode)\n+    return (build_int_2 (stack_depth, 0));\n+\n   /* Make the RTL_EXPR node temporary, not momentary,\n      so that rtl_expr_chain doesn't become garbage.  */\n-  int momentary = suspend_momentary ();\n-  tree t = make_node (RTL_EXPR);\n+  momentary = suspend_momentary ();\n+  t = make_node (RTL_EXPR);\n   resume_momentary (momentary);\n   start_sequence ();\n   NO_DEFER_POP;\n@@ -1486,6 +1779,38 @@ tree\n expand_end_stmt_expr (t)\n      tree t;\n {\n+  if (output_bytecode)\n+    {\n+      int i;\n+      tree t;\n+      \n+      \n+      /* At this point, all expressions have been evaluated in order.\n+\t However, all expression values have been popped when evaluated,\n+\t which means we have to recover the last expression value.  This is\n+\t the last value removed by means of a `drop' instruction.  Instead\n+\t of adding code to inhibit dropping the last expression value, it\n+\t is here recovered by undoing the `drop'.  Since `drop' is\n+\t equivalent to `adjustackSI [1]', it can be undone with `adjstackSI\n+\t [-1]'. */\n+      \n+      bc_adjust_stack (-1);\n+      \n+      if (!last_expr_type)\n+\tlast_expr_type = void_type_node;\n+      \n+      t = make_node (RTL_EXPR);\n+      TREE_TYPE (t) = last_expr_type;\n+      RTL_EXPR_RTL (t) = NULL;\n+      RTL_EXPR_SEQUENCE (t) = NULL;\n+      \n+      /* Don't consider deleting this expr or containing exprs at tree level.  */\n+      TREE_THIS_VOLATILE (t) = 1;\n+      \n+      last_expr_type = 0;\n+      return t;\n+    }\n+\n   OK_DEFER_POP;\n \n   if (last_expr_type == 0)\n@@ -1849,7 +2174,10 @@ expand_start_cond (cond, exitflag)\n   cond_stack = thiscond;\n   nesting_stack = thiscond;\n \n-  do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n+  if (output_bytecode)\n+    bc_expand_start_cond (cond, exitflag);\n+  else\n+    do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n }\n \n /* Generate RTL between then-clause and the elseif-clause\n@@ -1875,6 +2203,13 @@ expand_start_else ()\n {\n   if (cond_stack->data.cond.endif_label == 0)\n     cond_stack->data.cond.endif_label = gen_label_rtx ();\n+\n+  if (output_bytecode)\n+    {\n+      bc_expand_start_else ();\n+      return;\n+    }\n+\n   emit_jump (cond_stack->data.cond.endif_label);\n   emit_label (cond_stack->data.cond.next_label);\n   cond_stack->data.cond.next_label = 0;  /* No more _else or _elseif calls. */\n@@ -1888,15 +2223,71 @@ expand_end_cond ()\n {\n   struct nesting *thiscond = cond_stack;\n \n-  do_pending_stack_adjust ();\n-  if (thiscond->data.cond.next_label)\n-    emit_label (thiscond->data.cond.next_label);\n-  if (thiscond->data.cond.endif_label)\n-    emit_label (thiscond->data.cond.endif_label);\n+  if (output_bytecode)\n+    bc_expand_end_cond ();\n+  else\n+    {\n+      do_pending_stack_adjust ();\n+      if (thiscond->data.cond.next_label)\n+\temit_label (thiscond->data.cond.next_label);\n+      if (thiscond->data.cond.endif_label)\n+\temit_label (thiscond->data.cond.endif_label);\n+    }\n \n   POPSTACK (cond_stack);\n   last_expr_type = 0;\n }\n+\n+\n+/* Generate code for the start of an if-then.  COND is the expression\n+   whose truth is to be tested; if EXITFLAG is nonzero this conditional\n+   is to be visible to exit_something.  It is assumed that the caller\n+   has pushed the previous context on the cond stack. */\n+void\n+bc_expand_start_cond (cond, exitflag)\n+     tree cond;\n+     int exitflag;\n+{\n+  struct nesting *thiscond = cond_stack;\n+\n+  thiscond->data.case_stmt.nominal_type = cond;\n+  bc_expand_expr (cond);\n+  bc_emit_bytecode (jumpifnot);\n+  bc_emit_bytecode_labelref (thiscond->exit_label->bc_label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+}\n+\n+/* Generate the label for the end of an if with\n+   no else- clause.  */\n+void\n+bc_expand_end_cond ()\n+{\n+  struct nesting *thiscond = cond_stack;\n+\n+  bc_emit_bytecode_labeldef (thiscond->exit_label->bc_label);\n+}\n+\n+/* Generate code for the start of the else- clause of\n+   an if-then-else.  */\n+void\n+bc_expand_start_else ()\n+{\n+  struct nesting *thiscond = cond_stack;\n+\n+  thiscond->data.cond.endif_label = thiscond->exit_label;\n+  thiscond->exit_label = gen_label_rtx ();\n+  bc_emit_bytecode (jump);\n+  bc_emit_bytecode_labelref (thiscond->exit_label->bc_label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+\n+  bc_emit_bytecode_labeldef (thiscond->data.cond.endif_label->bc_label);\n+}\n \f\n /* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this\n    loop should be exited by `exit_something'.  This is a loop for which\n@@ -1923,6 +2314,12 @@ expand_start_loop (exit_flag)\n   loop_stack = thisloop;\n   nesting_stack = thisloop;\n \n+  if (output_bytecode)\n+    {\n+      bc_emit_bytecode_labeldef (thisloop->data.loop.start_label->bc_label);\n+      return thisloop;\n+    }\n+\n   do_pending_stack_adjust ();\n   emit_queue ();\n   emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n@@ -1951,21 +2348,54 @@ expand_start_loop_continue_elsewhere (exit_flag)\n void\n expand_loop_continue_here ()\n {\n+  if (output_bytecode)\n+    {\n+      bc_emit_bytecode_labeldef (loop_stack->data.loop.continue_label->bc_label);\n+      return;\n+    }\n   do_pending_stack_adjust ();\n   emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n   emit_label (loop_stack->data.loop.continue_label);\n }\n \n+/* End a loop.  */\n+static void\n+bc_expand_end_loop ()\n+{\n+  struct nesting *thisloop = loop_stack;\n+\n+  bc_emit_bytecode (jump);\n+  bc_emit_bytecode_labelref (thisloop->data.loop.start_label->bc_label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+\n+  bc_emit_bytecode_labeldef (thisloop->exit_label->bc_label);\n+  POPSTACK (loop_stack);\n+  last_expr_type = 0;\n+}\n+\n+\n /* Finish a loop.  Generate a jump back to the top and the loop-exit label.\n    Pop the block off of loop_stack.  */\n \n void\n expand_end_loop ()\n {\n-  register rtx insn = get_last_insn ();\n-  register rtx start_label = loop_stack->data.loop.start_label;\n+  register rtx insn;\n+  register rtx start_label;\n   rtx last_test_insn = 0;\n   int num_insns = 0;\n+    \n+  if (output_bytecode)\n+    {\n+      bc_expand_end_loop ();\n+      return;\n+    }\n+\n+  insn = get_last_insn ();\n+  start_label = loop_stack->data.loop.start_label;\n \n   /* Mark the continue-point at the top of the loop if none elsewhere.  */\n   if (start_label == loop_stack->data.loop.continue_label)\n@@ -2113,7 +2543,15 @@ expand_exit_loop_if_false (whichloop, cond)\n     whichloop = loop_stack;\n   if (whichloop == 0)\n     return 0;\n-  do_jump (cond, whichloop->data.loop.end_label, NULL_RTX);\n+  if (output_bytecode)\n+    {\n+      bc_expand_expr (cond);\n+      bc_expand_goto_internal (jumpifnot,\n+\t\t\t       whichloop->exit_label->bc_label, NULL_RTX);\n+    }\n+  else\n+    do_jump (cond, whichloop->data.loop.end_label, NULL_RTX);\n+\n   return 1;\n }\n \n@@ -2176,6 +2614,12 @@ expand_null_return ()\n   struct nesting *block = block_stack;\n   rtx last_insn = 0;\n \n+  if (output_bytecode)\n+    {\n+      bc_emit_instruction (ret);\n+      return;\n+    }\n+\n   /* Does any pending block have cleanups?  */\n \n   while (block && block->data.block.cleanups == 0)\n@@ -2298,6 +2742,15 @@ expand_return (retval)\n   int cleanups;\n   struct nesting *block;\n \n+  /* Bytecode returns are quite simple, just leave the result on the\n+     arithmetic stack. */\n+  if (output_bytecode)\n+    {\n+      bc_expand_expr (retval);\n+      bc_emit_instruction (ret);\n+      return;\n+    }\n+  \n   /* If function wants no value, give it none.  */\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n     {\n@@ -2536,8 +2989,10 @@ expand_start_bindings (exit_flag)\n      int exit_flag;\n {\n   struct nesting *thisblock = ALLOC_NESTING ();\n+  rtx note;\n \n-  rtx note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+  if (!output_bytecode)\n+    note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n \n   /* Make an entry on block_stack for the block we are entering.  */\n \n@@ -2580,8 +3035,11 @@ expand_start_bindings (exit_flag)\n   block_stack = thisblock;\n   nesting_stack = thisblock;\n \n-  /* Make a new level for allocating stack slots.  */\n-  push_temp_slots ();\n+  if (!output_bytecode)\n+    {\n+      /* Make a new level for allocating stack slots.  */\n+      push_temp_slots ();\n+    }\n }\n \n /* Given a pointer to a BLOCK node, save a pointer to the most recently\n@@ -2614,6 +3072,12 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n   register struct nesting *thisblock = block_stack;\n   register tree decl;\n \n+  if (output_bytecode)\n+    {\n+      bc_expand_end_bindings (vars, mark_ends, dont_jump_in);\n+      return;\n+    }\n+\n   if (warn_unused)\n     for (decl = vars; decl; decl = TREE_CHAIN (decl))\n       if (! TREE_USED (decl) && TREE_CODE (decl) == VAR_DECL\n@@ -2830,6 +3294,35 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n   /* Pop the stack slot nesting and free any slots at this level.  */\n   pop_temp_slots ();\n }\n+\n+\n+/* End a binding contour.\n+   VARS is the chain of VAR_DECL nodes for the variables bound\n+   in this contour.  MARK_ENDS is nonzer if we should put a note\n+   at the beginning and end of this binding contour.\n+   DONT_JUMP_IN is nonzero if it is not valid to jump into this\n+   contour.  */\n+\n+void\n+bc_expand_end_bindings (vars, mark_ends, dont_jump_in)\n+     tree vars;\n+     int mark_ends;\n+     int dont_jump_in;\n+{\n+  struct nesting *thisbind = nesting_stack;\n+  tree decl;\n+\n+  if (warn_unused)\n+    for (decl = vars; decl; decl = TREE_CHAIN (decl))\n+      if (! TREE_USED (TREE_VALUE (decl)) && TREE_CODE (TREE_VALUE (decl)) == VAR_DECL)\n+\twarning_with_decl (decl, \"unused variable `%s'\");\n+\n+  bc_emit_bytecode_labeldef (thisbind->exit_label->bc_label);\n+\n+  /* Pop block/bindings off stack */\n+  POPSTACK (nesting_stack);\n+  POPSTACK (block_stack);\n+}\n \f\n /* Generate RTL for the automatic variable declaration DECL.\n    (Other kinds of declarations are simply ignored if seen here.)\n@@ -2854,7 +3347,15 @@ expand_decl (decl)\n      register tree decl;\n {\n   struct nesting *thisblock = block_stack;\n-  tree type = TREE_TYPE (decl);\n+  tree type;\n+\n+  if (output_bytecode)\n+    {\n+      bc_expand_decl (decl, 0);\n+      return;\n+    }\n+\n+  type = TREE_TYPE (decl);\n \n   /* Only automatic variables need any expansion done.\n      Static and external variables, and external functions,\n@@ -3046,6 +3547,52 @@ expand_decl (decl)\n   if (obey_regdecls)\n     use_variable (DECL_RTL (decl));\n }\n+\n+\n+/* Generate code for the automatic variable declaration DECL.  For\n+   most variables this just means we give it a stack offset.  The\n+   compiler sometimes emits cleanups without variables and we will\n+   have to deal with those too.  */\n+\n+void\n+bc_expand_decl (decl, cleanup)\n+     tree decl;\n+     tree cleanup;\n+{\n+  tree type;\n+\n+  if (!decl)\n+    {\n+      /* A cleanup with no variable.  */\n+      if (!cleanup)\n+\tabort ();\n+\n+      return;\n+    }\n+\n+  /* Only auto variables need any work.  */\n+  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n+    return;\n+\n+  type = TREE_TYPE (decl);\n+\n+  if (type == error_mark_node)\n+    DECL_RTL (decl) = bc_gen_rtx ((char *) 0, 0, (struct bc_label *) 0);\n+\n+  else if (DECL_SIZE (decl) == 0)\n+\n+    /* Variable with incomplete type.  The stack offset herein will be\n+       fixed later in expand_decl_init ().  */\n+    DECL_RTL (decl) = bc_gen_rtx ((char *) 0, 0, (struct bc_label *) 0);\n+\n+  else if (TREE_CONSTANT (DECL_SIZE (decl)))\n+    {\n+      DECL_RTL (decl) = bc_allocate_local (TREE_INT_CST_LOW (DECL_SIZE (decl)) / BITS_PER_UNIT,\n+\t\t\t\t\t   DECL_ALIGN (decl));\n+    }\n+  else\n+    DECL_RTL (decl) = bc_allocate_variable_array (DECL_SIZE (decl));\n+}\n \f\n /* Emit code to perform the initialization of a declaration DECL.  */\n \n@@ -3083,6 +3630,82 @@ expand_decl_init (decl)\n   free_temp_slots ();\n }\n \n+/* Expand initialization for variable-sized types. Allocate array\n+   using newlocalSI and set local variable, which is a pointer to the\n+   storage. */\n+\n+bc_expand_variable_local_init (decl)\n+     tree decl;\n+{\n+  /* Evaluate size expression and coerce to SI */\n+  bc_expand_expr (DECL_SIZE (decl));\n+\n+  /* Type sizes are always (?) of TREE_CODE INTEGER_CST, so\n+     no coercion is necessary (?) */\n+\n+/*  emit_typecode_conversion (preferred_typecode (TYPE_MODE (DECL_SIZE (decl)),\n+\t\t\t\t\t\tTREE_UNSIGNED (DECL_SIZE (decl))), SIcode); */\n+\n+  /* Emit code to allocate array */\n+  bc_emit_instruction (newlocalSI);\n+\n+  /* Store array pointer in local variable. This is the only instance\n+     where we actually want the address of the pointer to the\n+     variable-size block, rather than the pointer itself.  We avoid\n+     using expand_address() since that would cause the pointer to be\n+     pushed rather than its address. Hence the hard-coded reference;\n+     notice also that the variable is always local (no global\n+     variable-size type variables). */\n+\n+  bc_load_localaddr (DECL_RTL (decl));\n+  bc_emit_instruction (storeP);\n+}\n+\n+\n+/* Emit code to initialize a declaration.  */\n+void\n+bc_expand_decl_init (decl)\n+     tree decl;\n+{\n+  int org_stack_depth;\n+\n+  /* Statical initializers are handled elsewhere */\n+\n+  if (TREE_STATIC (decl))\n+    return;\n+\n+  /* Memory original stack depth */\n+  org_stack_depth = stack_depth;\n+\n+  /* If the type is variable-size, we first create its space (we ASSUME\n+     it CAN'T be static).  We do this regardless of whether there's an\n+     initializer assignment or not. */\n+\n+  if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+    bc_expand_variable_local_init (decl);\n+\n+  /* Expand initializer assignment */\n+  if (DECL_INITIAL (decl) == error_mark_node)\n+    {\n+      enum tree_code code = TREE_CODE (TREE_TYPE (decl));\n+\n+      if (code == INTEGER_TYPE || code == REAL_TYPE || code == ENUMERAL_TYPE\n+\t  || code == POINTER_TYPE)\n+\n+\texpand_assignment (TREE_TYPE (decl), decl,\n+\t\t\t   convert (TREE_TYPE (decl), integer_zero_node));\n+    }\n+  else if (DECL_INITIAL (decl))\n+    expand_assignment (TREE_TYPE (decl), decl, DECL_INITIAL (decl));\n+\n+  /* Restore stack depth */\n+  if (org_stack_depth > stack_depth)\n+    abort ();\n+\n+  bc_adjust_stack (stack_depth - org_stack_depth);\n+}\n+ \n+\n /* CLEANUP is an expression to be executed at exit from this binding contour;\n    for example, in C++, it might call the destructor for this variable.\n \n@@ -3301,6 +3924,12 @@ expand_start_case (exit_flag, expr, type, printname)\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n \n+  if (output_bytecode)\n+    {\n+      bc_expand_start_case (thiscase, expr, type, printname);\n+      return;\n+    }\n+\n   do_pending_stack_adjust ();\n \n   /* Make sure case_stmt.start points to something that won't\n@@ -3311,6 +3940,32 @@ expand_start_case (exit_flag, expr, type, printname)\n   thiscase->data.case_stmt.start = get_last_insn ();\n }\n \n+\n+/* Enter a case statement. It is assumed that the caller has pushed\n+   the current context onto the case stack. */\n+void\n+bc_expand_start_case (thiscase, expr, type, printname)\n+     struct nesting *thiscase;\n+     tree expr;\n+     tree type;\n+     char *printname;\n+{\n+  bc_expand_expr (expr);\n+  bc_expand_conversion (TREE_TYPE (expr), type);\n+\n+  /* For cases, the skip is a place we jump to that's emitted after\n+     the size of the jump table is known.  */\n+\n+  thiscase->data.case_stmt.skip_label = gen_label_rtx ();\n+  bc_emit_bytecode (jump);\n+  bc_emit_bytecode_labelref (thiscase->data.case_stmt.skip_label->bc_label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+}\n+\n+\n /* Start a \"dummy case statement\" within which case labels are invalid\n    and are not connected to any larger real case statement.\n    This can be used if you don't want to let a case statement jump\n@@ -3382,6 +4037,9 @@ pushcase (value, converter, label, duplicate)\n   tree index_type;\n   tree nominal_type;\n \n+  if (output_bytecode)\n+    return bc_pushcase (value, label);\n+\n   /* Fail if not inside a real case statement.  */\n   if (! (case_stack && case_stack->data.case_stmt.start))\n     return 1;\n@@ -3588,6 +4246,62 @@ pushcase_range (value1, value2, converter, label, duplicate)\n \n   return 0;\n }\n+\n+\n+/* Accumulate one case or default label; VALUE is the value of the\n+   case, or nil for a default label.  If not currently inside a case,\n+   return 1 and do nothing.  If VALUE is a duplicate or overlaps, return\n+   2 and do nothing.  If VALUE is out of range, return 3 and do nothing.\n+   Return 0 on success.  This function is a leftover from the earlier\n+   bytecode compiler, which was based on gcc 1.37.  It should be\n+   merged into pushcase. */\n+\n+int\n+bc_pushcase (value, label)\n+     tree value;\n+     tree label;\n+{\n+  struct nesting *thiscase = case_stack;\n+  struct case_node *case_label, *new_label;\n+\n+  if (! thiscase)\n+    return 1;\n+\n+  /* Fail if duplicate, overlap, or out of type range.  */\n+  if (value)\n+    {\n+      value = convert (thiscase->data.case_stmt.nominal_type, value);\n+      if (! int_fits_type_p (value, thiscase->data.case_stmt.nominal_type))\n+\treturn 3;\n+\n+      for (case_label = thiscase->data.case_stmt.case_list;\n+\t   case_label->left; case_label = case_label->left)\n+\tif (! tree_int_cst_lt (case_label->left->high, value))\n+\t  break;\n+\n+      if (case_label != thiscase->data.case_stmt.case_list\n+\t  && ! tree_int_cst_lt (case_label->high, value)\n+\t  || case_label->left && ! tree_int_cst_lt (value, case_label->left->low))\n+\treturn 2;\n+\n+      new_label = (struct case_node *) oballoc (sizeof (struct case_node));\n+      new_label->low = new_label->high = copy_node (value);\n+      new_label->code_label = label;\n+      new_label->left = case_label->left;\n+\n+      case_label->left = new_label;\n+      thiscase->data.case_stmt.num_ranges++;\n+    }\n+  else\n+    {\n+      if (thiscase->data.case_stmt.default_label)\n+\treturn 2;\n+      thiscase->data.case_stmt.default_label = label;\n+    }\n+\n+  expand_label (label);\n+  return 0;\n+}\n \f\n /* Called when the index of a switch statement is an enumerated type\n    and there is no default label.\n@@ -3609,6 +4323,12 @@ check_for_full_enumeration_handling (type)\n   register tree chain;\n   int all_values = 1;\n \n+  if (output_bytecode)\n+    {\n+      bc_check_for_full_enumeration_handling (type);\n+      return;\n+    }\n+\n   /* The time complexity of this loop is currently O(N * M), with\n      N being the number of members in the enumerated type, and\n      M being the number of case expressions in the switch. */\n@@ -3707,6 +4427,46 @@ check_for_full_enumeration_handling (type)\n     }\n #endif /* 0 */\n }\n+\n+\n+/* Check that all enumeration literals are covered by the case\n+   expressions of a switch.  Also warn if there are any cases\n+   that are not elements of the enumerated type.  */\n+void\n+bc_check_for_full_enumeration_handling (type)\n+     tree type;\n+{\n+  struct nesting *thiscase = case_stack;\n+  struct case_node *c;\n+  tree e;\n+\n+  /* Check for enums not handled.  */\n+  for (e = TYPE_VALUES (type); e; e = TREE_CHAIN (e))\n+    {\n+      for (c = thiscase->data.case_stmt.case_list->left;\n+\t   c && tree_int_cst_lt (c->high, TREE_VALUE (e));\n+\t   c = c->left)\n+\t;\n+      if (! (c && tree_int_cst_equal (c->low, TREE_VALUE (e))))\n+\twarning (\"enumerated value `%s' not handled in switch\",\n+\t\t IDENTIFIER_POINTER (TREE_PURPOSE (e)));\n+    }\n+\n+  /* Check for cases not in the enumeration.  */\n+  for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n+    {\n+      for (e = TYPE_VALUES (type);\n+\t   e && !tree_int_cst_equal (c->low, TREE_VALUE (e));\n+\t   e = TREE_CHAIN (e))\n+\t;\n+      if (! e)\n+\twarning (\"case value `%d' not in enumerated type `%s'\",\n+\t\t TREE_INT_CST_LOW (c->low),\n+\t\t IDENTIFIER_POINTER (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE\n+\t\t\t\t     ? TYPE_NAME (type)\n+\t\t\t\t     : DECL_NAME (TYPE_NAME (type))));\n+    }\n+}\n \f\n /* Terminate a case (Pascal) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n@@ -3721,14 +4481,24 @@ expand_end_case (orig_index)\n   register struct case_node *n;\n   int count;\n   rtx index;\n-  rtx table_label = gen_label_rtx ();\n+  rtx table_label;\n   int ncases;\n   rtx *labelvec;\n   register int i;\n   rtx before_case;\n   register struct nesting *thiscase = case_stack;\n-  tree index_expr = thiscase->data.case_stmt.index_expr;\n-  int unsignedp = TREE_UNSIGNED (TREE_TYPE (index_expr));\n+  tree index_expr;\n+  int unsignedp;\n+\n+  if (output_bytecode)\n+    {\n+      bc_expand_end_case (orig_index);\n+      return;\n+    }\n+\n+  table_label = gen_label_rtx ();\n+  index_expr = thiscase->data.case_stmt.index_expr;\n+  unsignedp = TREE_UNSIGNED (TREE_TYPE (index_expr));\n \n   do_pending_stack_adjust ();\n \n@@ -4069,6 +4839,110 @@ expand_end_case (orig_index)\n   free_temp_slots ();\n }\n \n+\n+/* Terminate a case statement.  EXPR is the original index\n+   expression.  */\n+void\n+bc_expand_end_case (expr)\n+     tree expr;\n+{\n+  struct nesting *thiscase = case_stack;\n+  enum bytecode_opcode opcode;\n+  struct bc_label *jump_label;\n+  struct case_node *c;\n+\n+  bc_emit_bytecode (jump);\n+  bc_emit_bytecode_labelref (thiscase->exit_label->bc_label);\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+\n+  /* Now that the size of the jump table is known, emit the actual\n+     indexed jump instruction.  */\n+  bc_emit_bytecode_labeldef (thiscase->data.case_stmt.skip_label->bc_label);\n+\n+  opcode = TYPE_MODE (thiscase->data.case_stmt.nominal_type) == SImode\n+    ? TREE_UNSIGNED (thiscase->data.case_stmt.nominal_type) ? caseSU : caseSI\n+      : TREE_UNSIGNED (thiscase->data.case_stmt.nominal_type) ? caseDU : caseDI;\n+\n+  bc_emit_bytecode (opcode);\n+\n+  /* Now emit the case instructions literal arguments, in order.\n+     In addition to the value on the stack, it uses:\n+     1.  The address of the jump table.\n+     2.  The size of the jump table.\n+     3.  The default label.  */\n+\n+  jump_label = bc_get_bytecode_label ();\n+  bc_emit_bytecode_labelref (jump_label);\n+  bc_emit_bytecode_const ((char *) &thiscase->data.case_stmt.num_ranges,\n+\t\t\t  sizeof thiscase->data.case_stmt.num_ranges);\n+\n+  if (thiscase->data.case_stmt.default_label)\n+    bc_emit_bytecode_labelref (DECL_RTL (thiscase->\n+\t\t\t\t\t data.case_stmt.default_label)->bc_label);\n+  else\n+    bc_emit_bytecode_labelref (thiscase->exit_label->bc_label);\n+\n+  /* Output the jump table.  */\n+\n+  bc_align_bytecode (3 /* PTR_ALIGN */);\n+  bc_emit_bytecode_labeldef (jump_label);\n+\n+  if (TYPE_MODE (thiscase->data.case_stmt.nominal_type) == SImode)\n+    for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n+      {\n+\topcode = TREE_INT_CST_LOW (c->low);\n+\tbc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\n+\n+\topcode = TREE_INT_CST_LOW (c->high);\n+\tbc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\n+\n+\tbc_emit_bytecode_labelref (DECL_RTL (c->code_label)->bc_label);\n+      }\n+  else\n+    if (TYPE_MODE (thiscase->data.case_stmt.nominal_type) == DImode)\n+      for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n+\t{\n+\t  bc_emit_bytecode_DI_const (c->low);\n+\t  bc_emit_bytecode_DI_const (c->high);\n+\n+\t  bc_emit_bytecode_labelref (DECL_RTL (c->code_label)->bc_label);\n+\t}\n+    else\n+      /* Bad mode */\n+      abort ();\n+\n+    \n+  bc_emit_bytecode_labeldef (thiscase->exit_label->bc_label);\n+\n+  /* Possibly issue enumeration warnings.  */\n+\n+  if (!thiscase->data.case_stmt.default_label\n+      && TREE_CODE (TREE_TYPE (expr)) == ENUMERAL_TYPE\n+      && TREE_CODE (expr) != INTEGER_CST\n+      && warn_switch)\n+    check_for_full_enumeration_handling (TREE_TYPE (expr));\n+\n+\n+#ifdef DEBUG_PRINT_CODE\n+  fputc ('\\n', stderr);\n+#endif\n+\n+  POPSTACK (case_stack);\n+}\n+\n+\n+/* Return unique bytecode ID. */\n+int \n+bc_new_uid ()\n+{\n+  static int bc_uid = 0;\n+\n+  return (++bc_uid);\n+}\n+\n /* Generate code to jump to LABEL if OP1 and OP2 are equal.  */\n \n static void"}, {"sha": "94e428000a8ff46be8648a3ef5fc7bb63b2b5ed6", "filename": "gcc/toplev.c", "status": "modified", "additions": 107, "deletions": 46, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -57,6 +57,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\n #endif\n+\n+#include \"bytecode.h\"\n+#include \"bc-emit.h\"\n \f\n #ifdef VMS\n /* The extra parameters substantially improve the I/O performance.  */\n@@ -211,6 +214,9 @@ int errorcount = 0;\n int warningcount = 0;\n int sorrycount = 0;\n \n+/* Flag to output bytecode instead of native assembler */\n+int output_bytecode = 0;\n+\n /* Pointer to function to compute the name to use to print a declaration.  */\n \n char *(*decl_printable_name) ();\n@@ -515,6 +521,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"inhibit-size-directive\", &flag_inhibit_size_directive, 1},\n   {\"verbose-asm\", &flag_verbose_asm, 1},\n   {\"gnu-linker\", &flag_gnu_linker, 1}\n+  {\"bytecode\", &output_bytecode, 1}\n };\n \n /* Table of language-specific options.  */\n@@ -885,11 +892,14 @@ void\n fatal_insn_not_found (insn)\n      rtx insn;\n {\n-  if (INSN_CODE (insn) < 0)\n-    error (\"internal error--unrecognizable insn:\", 0);\n-  else\n-    error (\"internal error--insn does not satisfy its constraints:\", 0);\n-  debug_rtx (insn);\n+  if (!output_bytecode)\n+    {\n+      if (INSN_CODE (insn) < 0)\n+\terror (\"internal error--unrecognizable insn:\", 0);\n+      else\n+\terror (\"internal error--insn does not satisfy its constraints:\", 0);\n+      debug_rtx (insn);\n+    }\n   if (asm_out_file)\n     fflush (asm_out_file);\n   if (aux_info_file)\n@@ -1585,6 +1595,8 @@ compile_file (name)\n   init_obstacks ();\n   init_tree_codes ();\n   init_lex ();\n+  /* Some of these really don't need to be called when generating bytecode,\n+     but the options would have to be parsed first to know that. -bson */\n   init_rtl ();\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE);\n@@ -1813,34 +1825,51 @@ compile_file (name)\n   input_file_stack->next = 0;\n   input_file_stack->name = input_filename;\n \n-  ASM_FILE_START (asm_out_file);\n+  if (!output_bytecode)\n+    {\n+      ASM_FILE_START (asm_out_file);\n+    }\n \n-  /* Output something to inform GDB that this compilation was by GCC.  */\n+  /* Output something to inform GDB that this compilation was by GCC.  Also\n+     serves to tell GDB file consists of bytecodes. */\n+  if (output_bytecode)\n+    fprintf (asm_out_file, \"bc_gcc2_compiled.:\\n\");\n+  else\n+    {\n #ifndef ASM_IDENTIFY_GCC\n-  fprintf (asm_out_file, \"gcc2_compiled.:\\n\");\n+      fprintf (asm_out_file, \"gcc2_compiled.:\\n\");\n #else\n-  ASM_IDENTIFY_GCC (asm_out_file);\n+      ASM_IDENTIFY_GCC (asm_out_file);\n #endif\n+    }\n \n   /* Output something to identify which front-end produced this file. */\n #ifdef ASM_IDENTIFY_LANGUAGE\n   ASM_IDENTIFY_LANGUAGE (asm_out_file);\n #endif\n \n-/* ??? Note: There used to be a conditional here\n-   to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.\n-   This was to guarantee separation between gcc_compiled. and\n-   the first function, for the sake of dbx on Suns.\n-   However, having the extra zero here confused the Emacs\n-   code for unexec, and might confuse other programs too.\n-   Therefore, I took out that change.\n-   In future versions we should find another way to solve\n-   that dbx problem.  -- rms, 23 May 93.  */\n-\n-  /* Don't let the first function fall at the same address\n-     as gcc_compiled., if profiling.  */\n-  if (profile_flag || profile_block_flag)\n-    assemble_zeros (UNITS_PER_WORD);\n+  if (output_bytecode)\n+    {\n+      if (profile_flag || profile_block_flag)\n+\terror (\"profiling not supported in bytecode compilation\");\n+    }\n+  else\n+    {\n+      /* ??? Note: There used to be a conditional here\n+\t to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.\n+\t This was to guarantee separation between gcc_compiled. and\n+\t the first function, for the sake of dbx on Suns.\n+\t However, having the extra zero here confused the Emacs\n+\t code for unexec, and might confuse other programs too.\n+\t Therefore, I took out that change.\n+\t In future versions we should find another way to solve\n+\t that dbx problem.  -- rms, 23 May 93.  */\n+      \n+      /* Don't let the first function fall at the same address\n+\t as gcc_compiled., if profiling.  */\n+      if (profile_flag || profile_block_flag)\n+\tassemble_zeros (UNITS_PER_WORD);\n+    }\n \n   /* If dbx symbol table desired, initialize writing it\n      and output the predefined types.  */\n@@ -1861,7 +1890,8 @@ compile_file (name)\n \n   /* Initialize yet another pass.  */\n \n-  init_final (main_input_filename);\n+  if (!output_bytecode)\n+    init_final (main_input_filename);\n \n   start_time = get_run_time ();\n \n@@ -2031,11 +2061,14 @@ compile_file (name)\n \n   /* Output some stuff at end of file if nec.  */\n \n-  end_final (main_input_filename);\n+  if (!output_bytecode)\n+    {\n+      end_final (main_input_filename);\n \n #ifdef ASM_FILE_END\n-  ASM_FILE_END (asm_out_file);\n+      ASM_FILE_END (asm_out_file);\n #endif\n+    }\n \n  after_finish_compilation:\n \n@@ -2113,24 +2146,28 @@ compile_file (name)\n     {\n       fprintf (stderr,\"\\n\");\n       print_time (\"parse\", parse_time);\n-      print_time (\"integration\", integration_time);\n-      print_time (\"jump\", jump_time);\n-      print_time (\"cse\", cse_time);\n-      print_time (\"loop\", loop_time);\n-      print_time (\"cse2\", cse2_time);\n-      print_time (\"flow\", flow_time);\n-      print_time (\"combine\", combine_time);\n-      print_time (\"sched\", sched_time);\n-      print_time (\"local-alloc\", local_alloc_time);\n-      print_time (\"global-alloc\", global_alloc_time);\n-      print_time (\"sched2\", sched2_time);\n-      print_time (\"dbranch\", dbr_sched_time);\n-      print_time (\"shorten-branch\", shorten_branch_time);\n-      print_time (\"stack-reg\", stack_reg_time);\n-      print_time (\"final\", final_time);\n-      print_time (\"varconst\", varconst_time);\n-      print_time (\"symout\", symout_time);\n-      print_time (\"dump\", dump_time);\n+\n+      if (!output_bytecode)\n+\t{\n+\t  print_time (\"integration\", integration_time);\n+\t  print_time (\"jump\", jump_time);\n+\t  print_time (\"cse\", cse_time);\n+\t  print_time (\"loop\", loop_time);\n+\t  print_time (\"cse2\", cse2_time);\n+\t  print_time (\"flow\", flow_time);\n+\t  print_time (\"combine\", combine_time);\n+\t  print_time (\"sched\", sched_time);\n+\t  print_time (\"local-alloc\", local_alloc_time);\n+\t  print_time (\"global-alloc\", global_alloc_time);\n+\t  print_time (\"sched2\", sched2_time);\n+\t  print_time (\"dbranch\", dbr_sched_time);\n+\t  print_time (\"shorten-branch\", shorten_branch_time);\n+\t  print_time (\"stack-reg\", stack_reg_time);\n+\t  print_time (\"final\", final_time);\n+\t  print_time (\"varconst\", varconst_time);\n+\t  print_time (\"symout\", symout_time);\n+\t  print_time (\"dump\", dump_time);\n+\t}\n     }\n }\n \f\n@@ -2236,6 +2273,9 @@ rest_of_compilation (decl)\n   tree saved_arguments = 0;\n   int failure = 0;\n \n+  if (output_bytecode)\n+    return;\n+\n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n \n@@ -3166,7 +3206,12 @@ main (argc, argv, envp)\n \t\terror (\"Invalid option `%s'\", argv[i]);\n \t    }\n \t  else if (!strcmp (str, \"p\"))\n-\t    profile_flag = 1;\n+\t    {\n+\t      if (!output_bytecode)\n+\t\tprofile_flag = 1;\n+\t      else\n+\t\terror (\"profiling not supported in bytecode compilation\");\n+\t    }\n \t  else if (!strcmp (str, \"a\"))\n \t    {\n #if !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n@@ -3325,6 +3370,18 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n \tfilename = argv[i];\n     }\n \n+  /* Initialize for bytecode output.  A good idea to do this as soon as\n+     possible after the \"-f\" options have been parsed. */\n+  if (output_bytecode)\n+    {\n+#ifndef TARGET_SUPPORTS_BYTECODE\n+      /* Just die with a fatal error if not supported */\n+      fatal (\"-fbytecode can not be used for this target\");\n+#else\n+      bc_initialize ();\n+#endif\n+    }\n+\n   if (optimize == 0)\n     {\n       /* Inlining does not work if not optimizing,\n@@ -3398,10 +3455,14 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n     }\n \n   /* Now that register usage is specified, convert it to HARD_REG_SETs.  */\n-  init_reg_sets_1 ();\n+  if (!output_bytecode)\n+    init_reg_sets_1 ();\n \n   compile_file (filename);\n \n+  if (output_bytecode)\n+    bc_write_file (stdout);\n+\n #ifndef OS2\n #ifndef VMS\n   if (flag_print_mem)"}, {"sha": "7d16f36a2a34e41150be5d326c14e4a89709880f", "filename": "gcc/varasm.c", "status": "modified", "additions": 473, "deletions": 81, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca695ac93dca6da6f9bcb2916cd3798f016084b2/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ca695ac93dca6da6f9bcb2916cd3798f016084b2", "patch": "@@ -38,6 +38,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"regs.h\"\n #include \"defaults.h\"\n #include \"real.h\"\n+#include \"bytecode.h\"\n \n #include \"obstack.h\"\n \n@@ -96,9 +97,11 @@ void assemble_name ();\n int output_addressed_constants ();\n void output_constant ();\n void output_constructor ();\n+void output_byte_asm ();\n void text_section ();\n void readonly_data_section ();\n void data_section ();\n+static void bc_assemble_integer ();\n \f\n #ifdef EXTRA_SECTIONS\n static enum in_section {no_section, in_text, in_data, EXTRA_SECTIONS} in_section\n@@ -120,7 +123,11 @@ text_section ()\n {\n   if (in_section != in_text)\n     {\n-      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n+      if (output_bytecode)\n+\tbc_text ();\n+      else\n+\tfprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n+\n       in_section = in_text;\n     }\n }\n@@ -132,16 +139,21 @@ data_section ()\n {\n   if (in_section != in_data)\n     {\n-      if (flag_shared_data)\n+      if (output_bytecode)\n+\tbc_data ();\n+      else\n \t{\n+\t  if (flag_shared_data)\n+\t    {\n #ifdef SHARED_SECTION_ASM_OP\n-\t  fprintf (asm_out_file, \"%s\\n\", SHARED_SECTION_ASM_OP);\n+\t      fprintf (asm_out_file, \"%s\\n\", SHARED_SECTION_ASM_OP);\n #else\n-\t  fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n+\t      fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n #endif\n+\t    }\n+\t  else\n+\t    fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n \t}\n-      else\n-\tfprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n \n       in_section = in_data;\n     }\n@@ -178,6 +190,16 @@ make_function_rtl (decl)\n {\n   char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n+  if (output_bytecode)\n+    {\n+      if (DECL_RTL (decl) == 0)\n+\tDECL_RTL (decl) = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n+      \n+      /* Record that at least one function has been defined.  */\n+      function_defined = 1;\n+      return;\n+    }\n+\n   /* Rename a nested function to avoid conflicts.  */\n   if (decl_function_context (decl) != 0\n       && DECL_INITIAL (decl) != 0\n@@ -211,6 +233,48 @@ make_function_rtl (decl)\n   function_defined = 1;\n }\n \n+/* Create the DECL_RTL for a declaration for a static or external\n+   variable or static or external function.\n+   ASMSPEC, if not 0, is the string which the user specified\n+   as the assembler symbol name.\n+   TOP_LEVEL is nonzero if this is a file-scope variable.\n+   This is never called for PARM_DECLs.  */\n+void\n+bc_make_decl_rtl (decl, asmspec, top_level)\n+     tree decl;\n+     char *asmspec;\n+     int top_level;\n+{\n+  register char *name = TREE_STRING_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  if (DECL_RTL (decl) == 0)\n+    {\n+      /* Print an error message for register variables.  */\n+      if (DECL_REGISTER (decl) && TREE_CODE (decl) == FUNCTION_DECL)\n+\terror (\"function declared `register'\");\n+      else if (DECL_REGISTER (decl))\n+\terror (\"global register variables not supported in the interpreter\");\n+\n+      /* Handle ordinary static variables and functions.  */\n+      if (DECL_RTL (decl) == 0)\n+\t{\n+\t  /* Can't use just the variable's own name for a variable\n+\t     whose scope is less than the whole file.\n+\t     Concatenate a distinguishing number.  */\n+\t  if (!top_level && !DECL_EXTERNAL (decl) && asmspec == 0)\n+\t    {\n+\t      char *label;\n+\n+\t      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n+\t      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n+\t      var_labelno++;\n+\t    }\n+\n+\t  DECL_RTL (decl) = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n+\t}\n+    }\n+}\n+\n /* Given NAME, a putative register name, discard any customary prefixes.  */\n \n static char *\n@@ -301,7 +365,15 @@ make_decl_rtl (decl, asmspec, top_level)\n      int top_level;\n {\n   register char *name;\n-  int reg_number = decode_reg_name (asmspec);\n+  int reg_number;\n+\n+  if (output_bytecode)\n+    {\n+      bc_make_decl_rtl (decl, asmspec, top_level);\n+      return;\n+    }\n+\n+  reg_number = decode_reg_name (asmspec);\n \n   if (DECL_ASSEMBLER_NAME (decl) != NULL_TREE)\n     name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n@@ -465,6 +537,12 @@ void\n assemble_asm (string)\n      tree string;\n {\n+  if (output_bytecode)\n+    {\n+      error (\"asm statements not allowed in interpreter\");\n+      return;\n+    }\n+\n   app_enable ();\n \n   if (TREE_CODE (string) == ADDR_EXPR)\n@@ -576,7 +654,12 @@ assemble_start_function (decl, fnname)\n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n   if (align > 0)\n-    ASM_OUTPUT_ALIGN (asm_out_file, align);\n+    {\n+      if (output_bytecode)\n+\tBC_OUTPUT_ALIGN (asm_out_file, align);\n+      else\n+\tASM_OUTPUT_ALIGN (asm_out_file, align);\n+    }\n \n #ifdef ASM_OUTPUT_FUNCTION_PREFIX\n   ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);\n@@ -600,15 +683,21 @@ assemble_start_function (decl, fnname)\n     {\n       if (!first_global_object_name)\n \tSTRIP_NAME_ENCODING (first_global_object_name, fnname);\n-      ASM_GLOBALIZE_LABEL (asm_out_file, fnname);\n+      if (output_bytecode)\n+\tBC_GLOBALIZE_LABEL (asm_out_file, fnname);\n+      else\n+\tASM_GLOBALIZE_LABEL (asm_out_file, fnname);\n     }\n \n   /* Do any machine/system dependent processing of the function name */\n #ifdef ASM_DECLARE_FUNCTION_NAME\n   ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);\n #else\n   /* Standard thing is just output label for the function.  */\n-  ASM_OUTPUT_LABEL (asm_out_file, fnname);\n+  if (output_bytecode)\n+    BC_OUTPUT_LABEL (asm_out_file, fnname);\n+  else\n+    ASM_OUTPUT_LABEL (asm_out_file, fnname);\n #endif /* ASM_DECLARE_FUNCTION_NAME */\n }\n \n@@ -631,6 +720,12 @@ void\n assemble_zeros (size)\n      int size;\n {\n+  if (output_bytecode)\n+    {\n+      bc_emit_const_skip (size);\n+      return;\n+    }\n+\n #ifdef ASM_NO_SKIP_IN_TEXT\n   /* The `space' pseudo in the text section outputs nop insns rather than 0s,\n      so we must output 0s explicitly in the text section.  */\n@@ -664,7 +759,12 @@ assemble_zeros (size)\n   else\n #endif\n     if (size > 0)\n-      ASM_OUTPUT_SKIP (asm_out_file, size);\n+      {\n+\tif (output_bytecode)\n+\t  BC_OUTPUT_SKIP (asm_out_file, size);\n+\telse\n+\t  ASM_OUTPUT_SKIP (asm_out_file, size);\n+      }\n }\n \n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n@@ -688,6 +788,12 @@ assemble_string (p, size)\n   int pos = 0;\n   int maximum = 2000;\n \n+  if (output_bytecode)\n+    {\n+      bc_emit (p, size);\n+      return;\n+    }\n+\n   /* If the string is very long, split it up.  */\n \n   while (pos < size)\n@@ -696,7 +802,10 @@ assemble_string (p, size)\n       if (thissize > maximum)\n \tthissize = maximum;\n \n-      ASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n+      if (output_bytecode)\n+\tBC_OUTPUT_ASCII (asm_out_file, p, thissize);\n+      else\n+\tASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n \n       pos += thissize;\n       p += thissize;\n@@ -725,6 +834,9 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n   int reloc = 0;\n   enum in_section saved_in_section;\n \n+  if (output_bytecode)\n+    return;\n+\n   if (GET_CODE (DECL_RTL (decl)) == REG)\n     {\n       /* Do output symbol info for global register variables, but do nothing\n@@ -734,19 +846,22 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \treturn;\n       TREE_ASM_WRITTEN (decl) = 1;\n \n+      if (!output_bytecode)\n+\t{\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n-      /* File-scope global variables are output here.  */\n-      if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-\t  && top_level)\n-\tdbxout_symbol (decl, 0);\n+\t  /* File-scope global variables are output here.  */\n+\t  if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t      && top_level)\n+\t    dbxout_symbol (decl, 0);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n-      if (write_symbols == SDB_DEBUG && top_level\n-\t  /* Leave initialized global vars for end of compilation;\n-\t     see comment in compile_file.  */\n-\t  && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n-\tsdbout_symbol (decl, 0);\n+\t  if (write_symbols == SDB_DEBUG && top_level\n+\t      /* Leave initialized global vars for end of compilation;\n+\t\t see comment in compile_file.  */\n+\t      && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n+\t    sdbout_symbol (decl, 0);\n #endif\n+\t}\n \n       /* Don't output any DWARF debugging information for variables here.\n \t In the case of local variables, the information for them is output\n@@ -880,12 +995,17 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t    ASM_OUTPUT_SHARED_COMMON (asm_out_file, name, size, rounded);\n \t  else\n #endif\n+\t    if (output_bytecode)\n+\t      BC_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n+\t    else\n+\t      {\n #ifdef ASM_OUTPUT_ALIGNED_COMMON\n-\t    ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size,\n-\t\t\t\t       DECL_ALIGN (decl));\n+\t\tASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size,\n+\t\t\t\t\t   DECL_ALIGN (decl));\n #else\n-\t    ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n+\t\tASM_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n #endif\n+\t      }\n \t}\n       else\n \t{\n@@ -894,12 +1014,17 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t    ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);\n \t  else\n #endif\n+\t    if (output_bytecode)\n+\t      BC_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+\t    else\n+\t      {\n #ifdef ASM_OUTPUT_ALIGNED_LOCAL\n-\t    ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size,\n-\t\t\t\t      DECL_ALIGN (decl));\n+\t\tASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size,\n+\t\t\t\t\t  DECL_ALIGN (decl));\n #else\n-\t    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+\t\tASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n #endif\n+\t      }\n \t}\n       goto finish;\n     }\n@@ -1017,14 +1142,22 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n   DECL_ALIGN (decl) = align;\n \n   if (align > BITS_PER_UNIT)\n-    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+    {\n+      if (output_bytecode)\n+\tBC_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+      else\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+    }\n \n   /* Do any machine/system dependent processing of the object.  */\n #ifdef ASM_DECLARE_OBJECT_NAME\n   ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n #else\n   /* Standard thing is just output label for the object.  */\n-  ASM_OUTPUT_LABEL (asm_out_file, name);\n+  if (output_bytecode)\n+    BC_OUTPUT_LABEL (asm_out_file, name);\n+  else\n+    ASM_OUTPUT_LABEL (asm_out_file, name);\n #endif /* ASM_DECLARE_OBJECT_NAME */\n \n   if (!dont_output_data)\n@@ -1110,6 +1243,55 @@ contains_pointers_p (type)\n     }\n }\n \n+/* Output text storage for constructor CONSTR.  Returns rtx of\n+   storage. */\n+\n+rtx\n+bc_output_constructor (constr)\n+  tree constr;\n+{\n+  int i;\n+\n+  /* Must always be a literal; non-literal constructors are handled\n+     differently. */\n+\n+  if (!TREE_CONSTANT (constr))\n+    abort ();\n+\n+  /* Always const */\n+  text_section ();\n+\n+  /* Align */\n+  for (i = 0; TYPE_ALIGN (constr) >= BITS_PER_UNIT << (i + 1); i++);\n+  if (i > 0)\n+    BC_OUTPUT_ALIGN (asm_out_file, i);\n+\n+  /* Output data */\n+  output_constant (constr, int_size_in_bytes (TREE_TYPE (constr)));\n+}\n+\n+\n+/* Create storage for constructor CONSTR. */\n+\n+void\n+bc_output_data_constructor (constr)\n+    tree constr;\n+{\n+  int i;\n+\n+  /* Put in data section */\n+  data_section ();\n+\n+  /* Align */\n+  for (i = 0; TYPE_ALIGN (constr) >= BITS_PER_UNIT << (i + 1); i++);\n+  if (i > 0)\n+    BC_OUTPUT_ALIGN (asm_out_file, i);\n+\n+  /* The constructor is filled in at runtime. */\n+  BC_OUTPUT_SKIP (asm_out_file, int_size_in_bytes (TREE_TYPE (constr)));\n+}\n+\n+\n /* Output something to declare an external symbol to the assembler.\n    (Most assemblers don't need this, so we normally output nothing.)\n    Do nothing if DECL is not external.  */\n@@ -1118,6 +1300,9 @@ void\n assemble_external (decl)\n      tree decl;\n {\n+  if (output_bytecode)\n+    return;\n+\n #ifdef ASM_OUTPUT_EXTERNAL\n   if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n       && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))\n@@ -1142,11 +1327,14 @@ assemble_external_libcall (fun)\n      rtx fun;\n {\n #ifdef ASM_OUTPUT_EXTERNAL_LIBCALL\n-  /* Declare library function name external when first used, if nec.  */\n-  if (! SYMBOL_REF_USED (fun))\n+  if (!output_bytecode)\n     {\n-      SYMBOL_REF_USED (fun) = 1;\n-      ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n+      /* Declare library function name external when first used, if nec.  */\n+      if (! SYMBOL_REF_USED (fun))\n+\t{\n+\t  SYMBOL_REF_USED (fun) = 1;\n+\t  ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n+\t}\n     }\n #endif\n }\n@@ -1166,7 +1354,10 @@ void\n assemble_label (name)\n      char *name;\n {\n-  ASM_OUTPUT_LABEL (asm_out_file, name);\n+  if (output_bytecode)\n+    BC_OUTPUT_LABEL (asm_out_file, name);\n+  else\n+    ASM_OUTPUT_LABEL (asm_out_file, name);\n }\n \n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n@@ -1181,9 +1372,19 @@ assemble_name (file, name)\n      char *name;\n {\n   if (name[0] == '*')\n-    fputs (&name[1], file);\n+    {\n+      if (output_bytecode)\n+\tbc_emit_labelref (name);\n+      else\n+\tfputs (&name[1], file);\n+    }\n   else\n-    ASM_OUTPUT_LABELREF (file, name);\n+    {\n+      if (output_bytecode)\n+\tBC_OUTPUT_LABELREF (file, name);\n+      else\n+\tASM_OUTPUT_LABELREF (file, name);\n+    }\n }\n \n /* Allocate SIZE bytes writable static space with a gensym name\n@@ -1214,12 +1415,21 @@ assemble_static_space (size)\n \t\t\t\t       strlen (name) + 2);\n   strcpy (namestring, name);\n \n-  x = gen_rtx (SYMBOL_REF, Pmode, namestring);\n+  if (output_bytecode)\n+    x = bc_gen_rtx (namestring, 0, (struct bc_label *) 0);\n+  else\n+    x = gen_rtx (SYMBOL_REF, Pmode, namestring);\n+\n+  if (output_bytecode)\n+    BC_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+  else\n+    {\n #ifdef ASM_OUTPUT_ALIGNED_LOCAL\n-  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);\n+      ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);\n #else\n-  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+      ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n #endif\n+    }\n   return x;\n }\n \n@@ -1234,6 +1444,10 @@ assemble_trampoline_template ()\n   char *name;\n   int align;\n \n+  /* Shouldn't get here */\n+  if (output_bytecode)\n+    abort ();\n+\n   /* By default, put trampoline templates in read-only data section.  */\n \n #ifdef TRAMPOLINE_SECTION\n@@ -1683,9 +1897,13 @@ decode_addr_const (exp, value)\n       break;\n \n     case LABEL_DECL:\n-      x = gen_rtx (MEM, FUNCTION_MODE,\n-\t\t   gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t    label_rtx (TREE_OPERAND (exp, 0))));\n+      if (output_bytecode)\n+\t/* FIXME: this may not be correct, check it */\n+\tx = bc_gen_rtx (TREE_STRING_POINTER (target), 0, (struct bc_label *) 0);\n+      else\n+\tx = gen_rtx (MEM, FUNCTION_MODE,\n+\t\t     gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t      label_rtx (TREE_OPERAND (exp, 0))));\n       break;\n \n     case REAL_CST:\n@@ -1699,9 +1917,12 @@ decode_addr_const (exp, value)\n       abort ();\n     }\n \n-  if (GET_CODE (x) != MEM)\n-    abort ();\n-  x = XEXP (x, 0);\n+  if (!output_bytecode)\n+    {\n+      if (GET_CODE (x) != MEM)\n+\tabort ();\n+      x = XEXP (x, 0);\n+    }\n \n   value->base = x;\n   value->offset = offset;\n@@ -2171,47 +2392,57 @@ output_constant_def (exp)\n      to see if any of them describes EXP.  If yes, the descriptor records\n      the label number already assigned.  */\n \n-  hash = const_hash (exp) % MAX_HASH_TABLE;\n-\n-  for (desc = const_hash_table[hash]; desc; desc = desc->next)\n-    if (compare_constant (exp, desc))\n-      {\n-\tfound = desc->label;\n-\tbreak;\n-      }\n-\n-  if (found == 0)\n+  if (!output_bytecode)\n     {\n-      /* No constant equal to EXP is known to have been output.\n-\t Make a constant descriptor to enter EXP in the hash table.\n-\t Assign the label number and record it in the descriptor for\n-\t future calls to this function to find.  */\n-\n-      /* Create a string containing the label name, in LABEL.  */\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-\n-      desc = record_constant (exp);\n-      desc->next = const_hash_table[hash];\n-      desc->label\n-\t= (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n-      const_hash_table[hash] = desc;\n+      hash = const_hash (exp) % MAX_HASH_TABLE;\n+      \n+      for (desc = const_hash_table[hash]; desc; desc = desc->next)\n+\tif (compare_constant (exp, desc))\n+\t  {\n+\t    found = desc->label;\n+\t    break;\n+\t  }\n+      \n+      if (found == 0)\n+\t{\n+\t  /* No constant equal to EXP is known to have been output.\n+\t     Make a constant descriptor to enter EXP in the hash table.\n+\t     Assign the label number and record it in the descriptor for\n+\t     future calls to this function to find.  */\n+\t  \n+\t  /* Create a string containing the label name, in LABEL.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+\t  \n+\t  desc = record_constant (exp);\n+\t  desc->next = const_hash_table[hash];\n+\t  desc->label\n+\t    = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n+\t  const_hash_table[hash] = desc;\n+\t}\n+      else\n+\t{\n+\t  /* Create a string containing the label name, in LABEL.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+\t}\n     }\n-\n+  \n   /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n \n   push_obstacks_nochange ();\n   if (TREE_PERMANENT (exp))\n     end_temporary_allocation ();\n \n-  def = gen_rtx (SYMBOL_REF, Pmode, desc->label);\n-\n-  TREE_CST_RTL (exp)\n-    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)), def);\n-  RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n-  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-      || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n-    MEM_IN_STRUCT_P (TREE_CST_RTL (exp)) = 1;\n-\n+  if (!output_bytecode)\n+    {\n+      def = gen_rtx (SYMBOL_REF, Pmode, desc->label);\n+      \n+      TREE_CST_RTL (exp)\n+\t= gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)), def);\n+      RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n+      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n+\t  || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+\tMEM_IN_STRUCT_P (TREE_CST_RTL (exp)) = 1;\n+    }\n   pop_obstacks ();\n \n   /* Optionally set flags or add text to the name to record information\n@@ -2283,7 +2514,12 @@ output_constant_def_contents (exp, reloc, labelno)\n #endif\n \n   if (align > BITS_PER_UNIT)\n-    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+    {\n+      if (!output_bytecode)\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+      else\n+\tBC_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+    }\n \n   /* Output the label itself.  */\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", labelno);\n@@ -2891,6 +3127,22 @@ output_addressed_constants (exp)\n     }\n   return reloc;\n }\n+\n+\n+/* Output assembler for byte constant */\n+void\n+output_byte_asm (byte)\n+  int byte;\n+{\n+  if (output_bytecode)\n+    bc_emit_const ((char *) &byte, sizeof (char));\n+#ifdef ASM_OUTPUT_BYTE\n+  else\n+    {\n+      ASM_OUTPUT_BYTE (asm_out_file, byte);\n+    }\n+#endif\n+}\n \f\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n@@ -2925,7 +3177,10 @@ output_constant (exp, size)\n      This means to fill the space with zeros.  */\n   if (TREE_CODE (exp) == CONSTRUCTOR && CONSTRUCTOR_ELTS (exp) == 0)\n     {\n-      assemble_zeros (size);\n+      if (output_bytecode)\n+\tbc_emit_const_skip (size);\n+      else\n+\tassemble_zeros (size);\n       return;\n     }\n \n@@ -3005,6 +3260,101 @@ output_constant (exp, size)\n   if (size > 0)\n     assemble_zeros (size);\n }\n+\n+\n+/* Bytecode specific code to output assembler for integer. */\n+void\n+bc_assemble_integer (exp, size)\n+    tree exp;\n+    int size;\n+{\n+  tree const_part;\n+  tree addr_part;\n+  tree tmp;\n+\n+  /* FIXME: is this fold() business going to be as good as the\n+     expand_expr() using EXPAND_SUM above in the RTL case?  I\n+     hate RMS.\n+     FIXME: Copied as is from BC-GCC1; may need work. Don't hate. -bson */\n+  \n+  exp = fold (exp);\n+  \n+  while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR)\n+    exp = TREE_OPERAND (exp, 0);\n+  if (TREE_CODE (exp) == INTEGER_CST)\n+    {\n+      const_part = exp;\n+      addr_part = 0;\n+    }\n+  else if (TREE_CODE (exp) == PLUS_EXPR)\n+    {\n+      const_part = TREE_OPERAND (exp, 0);\n+      while (TREE_CODE (const_part) == NOP_EXPR\n+\t     || TREE_CODE (const_part) == CONVERT_EXPR)\n+\tconst_part = TREE_OPERAND (const_part, 0);\n+      addr_part = TREE_OPERAND (exp, 1);\n+      while (TREE_CODE (addr_part) == NOP_EXPR\n+\t     || TREE_CODE (addr_part) == CONVERT_EXPR)\n+\taddr_part = TREE_OPERAND (addr_part, 0);\n+      if (TREE_CODE (const_part) != INTEGER_CST)\n+\ttmp = const_part, const_part = addr_part, addr_part = tmp;\n+      if (TREE_CODE (const_part) != INTEGER_CST\n+\t  || TREE_CODE (addr_part) != ADDR_EXPR)\n+\tabort ();\t\t/* FIXME: we really haven't considered\n+\t\t\t\t   all the possible cases here.  */\n+    }\n+  else if (TREE_CODE (exp) == ADDR_EXPR)\n+    {\n+      const_part = integer_zero_node;\n+      addr_part = exp;\n+    }\n+  else\n+    abort ();\t\t/* FIXME: ditto previous.  */\n+  \n+  if (addr_part == 0)\n+    {\n+      if (size == 1)\n+\t{\n+\t  char c = TREE_INT_CST_LOW (const_part);\n+\t  bc_emit (&c, 1);\n+\t  size -= 1;\n+\t}\n+      else if (size == 2)\n+\t{\n+\t  short s = TREE_INT_CST_LOW (const_part);\n+\t  bc_emit ((char *) &s, 2);\n+\t  size -= 2;\n+\t}\n+      else if (size == 4)\n+\t{\n+\t  int i = TREE_INT_CST_LOW (const_part);\n+\t  bc_emit ((char *) &i, 4);\n+\t  size -= 4;\n+\t}\n+      else if (size == 8)\n+\t{\n+#if WORDS_BIG_ENDIAN\n+\t  int i = TREE_INT_CST_HIGH (const_part);\n+\t  bc_emit ((char *) &i, 4);\n+\t  i = TREE_INT_CST_LOW (const_part);\n+\t  bc_emit ((char *) &i, 4);\n+#else\n+\t  int i = TREE_INT_CST_LOW (const_part);\n+\t  bc_emit ((char *) &i, 4);\n+\t  i = TREE_INT_CST_HIGH (const_part);\n+\t  bc_emit ((char *) &i, 4);\n+#endif\n+\t  size -= 8;\n+\t}\n+    }\n+  else\n+    if (size == 4\n+\t&& TREE_CODE (TREE_OPERAND (addr_part, 0)) == VAR_DECL)\n+      bc_emit_labelref (DECL_ASSEMBLER_NAME (TREE_OPERAND (addr_part, 0)),\n+\t\t\tTREE_INT_CST_LOW (const_part));\n+    else\n+      abort ();\t\t/* FIXME: there may be more cases.  */\n+}\n \f\n /* Subroutine of output_constant, used for CONSTRUCTORs\n    (aggregate constants).\n@@ -3083,7 +3433,10 @@ output_constructor (exp, size)\n \t     if each element has the proper size.  */\n \t  if ((field != 0 || index != 0) && bitpos != total_bytes)\n \t    {\n-\t      assemble_zeros (bitpos - total_bytes);\n+\t      if (!output_bytecode)\n+\t\tassemble_zeros (bitpos - total_bytes);\n+\t      else\n+\t\tbc_emit_const_skip (bitpos - total_bytes);\n \t      total_bytes = bitpos;\n \t    }\n \n@@ -3254,3 +3607,42 @@ output_constructor (exp, size)\n   if (total_bytes < size)\n     assemble_zeros (size - total_bytes);\n }\n+\n+\n+/* Output asm to handle ``#pragma weak'' */\n+void\n+handle_pragma_weak (what, asm_out_file, name, value)\n+     enum pragma_state what;\n+     FILE *asm_out_file;\n+     char *name, *value;\n+{\n+  if (what == ps_name || what == ps_value)\n+    {\n+      fprintf (asm_out_file, \"\\t%s\\t\", WEAK_ASM_OP);\n+\n+      if (output_bytecode)\n+\tBC_OUTPUT_LABELREF (asm_out_file, name);\n+      else\n+\tASM_OUTPUT_LABELREF (asm_out_file, name);\n+\n+      fputc ('\\n', asm_out_file);\n+      if (what == ps_value)\n+\t{\n+\t  fprintf (asm_out_file, \"\\t%s\\t\", SET_ASM_OP);\n+\t  if (output_bytecode)\n+\t    BC_OUTPUT_LABELREF (asm_out_file, name);\n+\t  else\n+\t    ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\n+\t  fputc (',', asm_out_file);\n+\t  if (output_bytecode)\n+\t    BC_OUTPUT_LABELREF (asm_out_file, value);\n+\t  else\n+\t    ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+    }\n+  else if (! (what == ps_done || what == ps_start))\n+    warning (\"malformed `#pragma weak'\");\n+}"}]}