{"sha": "da55315a51eb6231f9ffa49528555884f6260a8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1NTMxNWE1MWViNjIzMWY5ZmZhNDk1Mjg1NTU4ODRmNjI2MGE4YQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-04T00:51:14Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-04T00:51:14Z"}, "message": "h8300.c, [...]: Follow spelling conventions.\n\n\t* config/h8300/h8300.c, config/h8300/h8300.h,\n\tconfig/h8300/h8300.md: Follow spelling conventions.\n\nFrom-SVN: r121562", "tree": {"sha": "0c04515384ec799f85831c86623ab9a595c3565f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c04515384ec799f85831c86623ab9a595c3565f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da55315a51eb6231f9ffa49528555884f6260a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da55315a51eb6231f9ffa49528555884f6260a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da55315a51eb6231f9ffa49528555884f6260a8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da55315a51eb6231f9ffa49528555884f6260a8a/comments", "author": null, "committer": null, "parents": [{"sha": "5e32a5cf7f15f8e6b4e992a1a2ec8c58d8e55bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e32a5cf7f15f8e6b4e992a1a2ec8c58d8e55bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e32a5cf7f15f8e6b4e992a1a2ec8c58d8e55bf6"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "3e5e30a5a80d23b26e375c9ad5fe727214807e76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da55315a51eb6231f9ffa49528555884f6260a8a", "patch": "@@ -1,3 +1,8 @@\n+2007-02-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/h8300/h8300.c, config/h8300/h8300.h,\n+\tconfig/h8300/h8300.md: Follow spelling conventions.\n+\n 2007-02-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/30667"}, {"sha": "efc32af194b3d60488a43b8e025a958f296b7aef", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=da55315a51eb6231f9ffa49528555884f6260a8a", "patch": "@@ -1321,20 +1321,20 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n        If this operand isn't a register, fall back to 'R' handling.\n    'Z' print int & 7.\n    'c' print the opcode corresponding to rtl\n-   'e' first word of 32 bit value - if reg, then least reg. if mem\n+   'e' first word of 32-bit value - if reg, then least reg. if mem\n        then least. if const then most sig word\n-   'f' second word of 32 bit value - if reg, then biggest reg. if mem\n+   'f' second word of 32-bit value - if reg, then biggest reg. if mem\n        then +2. if const then least sig word\n    'j' print operand as condition code.\n    'k' print operand as reverse condition code.\n    'm' convert an integer operand to a size suffix (.b, .w or .l)\n    'o' print an integer without a leading '#'\n-   's' print as low byte of 16 bit value\n-   't' print as high byte of 16 bit value\n-   'w' print as low byte of 32 bit value\n-   'x' print as 2nd byte of 32 bit value\n-   'y' print as 3rd byte of 32 bit value\n-   'z' print as msb of 32 bit value\n+   's' print as low byte of 16-bit value\n+   't' print as high byte of 16-bit value\n+   'w' print as low byte of 32-bit value\n+   'x' print as 2nd byte of 32-bit value\n+   'y' print as 3rd byte of 32-bit value\n+   'z' print as msb of 32-bit value\n */\n \n /* Return assembly language string which identifies a comparison type.  */\n@@ -1760,7 +1760,7 @@ print_operand_address (FILE *file, rtx addr)\n \n     case CONST_INT:\n       {\n-\t/* Since the H8/300 only has 16 bit pointers, negative values are also\n+\t/* Since the H8/300 only has 16-bit pointers, negative values are also\n \t   those >= 32768.  This happens for example with pointer minus a\n \t   constant.  We don't want to turn (char *p - 2) into\n \t   (char *p + 65534) because loop unrolling can build upon this"}, {"sha": "98a954b972cd83b8a7a4f7df0bd668432a4c4689", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=da55315a51eb6231f9ffa49528555884f6260a8a", "patch": "@@ -195,13 +195,13 @@ extern const char * const *h8_reg_names;\n #define FUNCTION_BOUNDARY 16\n \n /* Alignment of field after `int : 0' in a structure.  */\n-/* One can argue this should be 32 for -mint32, but since 32 bit ints only\n-   need 16 bit alignment, this is left as is so that -mint32 doesn't change\n+/* One can argue this should be 32 for -mint32, but since 32-bit ints only\n+   need 16-bit alignment, this is left as is so that -mint32 doesn't change\n    structure layouts.  */\n #define EMPTY_FIELD_BOUNDARY 16\n \n /* No data type wants to be aligned rounder than this.\n-   32 bit values are aligned as such on the H8/300H and H8S for speed.  */\n+   32-bit values are aligned as such on the H8/300H and H8S for speed.  */\n #define BIGGEST_ALIGNMENT \\\n (((TARGET_H8300H || TARGET_H8300S) && ! TARGET_ALIGN_300) ? 32 : 16)\n "}, {"sha": "8f0083ae8a109cfada29a591167d9e26570790b0", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da55315a51eb6231f9ffa49528555884f6260a8a/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=da55315a51eb6231f9ffa49528555884f6260a8a", "patch": "@@ -2826,15 +2826,15 @@\n ;; ----------------------------------------------------------------------\n ;;\n ;; We make some attempt to provide real efficient shifting.  One example is\n-;; doing an 8 bit shift of a 16 bit value by moving a byte reg into the other\n+;; doing an 8-bit shift of a 16-bit value by moving a byte reg into the other\n ;; reg and moving 0 into the former reg.\n ;;\n ;; We also try to achieve this in a uniform way.  IE: We don't try to achieve\n ;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would\n ;; give the optimizer more cracks at the code.  However, we wish to do things\n ;; like optimizing shifting the sign bit to bit 0 by rotating the other way.\n ;; There is rtl to handle this (rotate + and), but the H8/300 doesn't handle\n-;; 16 bit rotates.  Also, if we emit complicated rtl, combine may not be able\n+;; 16-bit rotates.  Also, if we emit complicated rtl, combine may not be able\n ;; to detect cases it can optimize.\n ;;\n ;; For these and other fuzzy reasons, I've decided to go the less pretty but"}]}