{"sha": "a141f2d86293dc202e35bd4d7f832756e1792cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0MWYyZDg2MjkzZGMyMDJlMzViZDRkN2Y4MzI3NTZlMTc5MmNkZg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2018-10-06T02:12:30Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-10-06T02:12:30Z"}, "message": "re PR rtl-optimization/86939 (IRA incorrectly creates an interference between a pseudo register and a hard register)\n\ngcc/\n\tPR rtl-optimization/86939\n\tPR rtl-optimization/87479\n\t* ira.h (non_conflicting_reg_copy_p): New prototype.\n\t* ira-lives.c (ignore_reg_for_conflicts): New static variable.\n\t(make_hard_regno_dead): Don't add conflicts for register\n\tignore_reg_for_conflicts.\n\t(make_object_dead): Likewise.\n\t(non_conflicting_reg_copy_p): New function.\n\t(process_bb_node_lives): Set ignore_reg_for_conflicts for copies.\n\tRemove special conflict handling of REAL_PIC_OFFSET_TABLE_REGNUM.\n\t* lra-lives.c (ignore_reg_for_conflicts): New static variable.\n\t(make_hard_regno_dead): Don't add conflicts for register\n\tignore_reg_for_conflicts.  Remove special conflict handling of\n\tREAL_PIC_OFFSET_TABLE_REGNUM.  Remove now unused argument\n\tcheck_pic_pseudo_p and update callers.\n\t(mark_pseudo_dead): Don't add conflicts for register\n\tignore_reg_for_conflicts.\n\t(process_bb_lives): Set ignore_reg_for_conflicts for copies.\n\ngcc/testsuite/\n\tPR rtl-optimization/86939\n\tPR rtl-optimization/87479\n\t* gcc.target/powerpc/pr86939.c: New test.\n\t* gcc/testsuite/gcc.target/i386/pr49095.c: Fix expected results.\n\nFrom-SVN: r264897", "tree": {"sha": "5c5f68081db774a0b61e0904e11d151bb12eab8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c5f68081db774a0b61e0904e11d151bb12eab8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a141f2d86293dc202e35bd4d7f832756e1792cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a141f2d86293dc202e35bd4d7f832756e1792cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a141f2d86293dc202e35bd4d7f832756e1792cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a141f2d86293dc202e35bd4d7f832756e1792cdf/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb6f9bbc754df7f410d0ae00e0cd8dc839203dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb6f9bbc754df7f410d0ae00e0cd8dc839203dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb6f9bbc754df7f410d0ae00e0cd8dc839203dc4"}], "stats": {"total": 207, "additions": 160, "deletions": 47}, "files": [{"sha": "73f26a936ecbe19a1e189434bb3e8cacf39cabc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -1,3 +1,24 @@\n+2018-10-05  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/86939\n+\tPR rtl-optimization/87479\n+\t* ira.h (non_conflicting_reg_copy_p): New prototype.\n+\t* ira-lives.c (ignore_reg_for_conflicts): New static variable.\n+\t(make_hard_regno_dead): Don't add conflicts for register\n+\tignore_reg_for_conflicts.\n+\t(make_object_dead): Likewise.\n+\t(non_conflicting_reg_copy_p): New function.\n+\t(process_bb_node_lives): Set ignore_reg_for_conflicts for copies.\n+\tRemove special conflict handling of REAL_PIC_OFFSET_TABLE_REGNUM.\n+\t* lra-lives.c (ignore_reg_for_conflicts): New static variable.\n+\t(make_hard_regno_dead): Don't add conflicts for register\n+\tignore_reg_for_conflicts.  Remove special conflict handling of\n+\tREAL_PIC_OFFSET_TABLE_REGNUM.  Remove now unused argument\n+\tcheck_pic_pseudo_p and update callers.\n+\t(mark_pseudo_dead): Don't add conflicts for register\n+\tignore_reg_for_conflicts.\n+\t(process_bb_lives): Set ignore_reg_for_conflicts for copies.\n+\n 2018-10-05  Andrew Waterman  <andrew@sifive.com>\n \t    Jim Wilson  <jimw@sifive.com>\n "}, {"sha": "dd8b334d58ec4a5acfeeeb8f49af3137003fabdc", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 69, "deletions": 28, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -84,6 +84,10 @@ static int *allocno_saved_at_call;\n    supplemental to recog_data.  */\n static alternative_mask preferred_alternatives;\n \n+/* If non-NULL, the source operand of a register to register copy for which\n+   we should not add a conflict with the copy's destination operand.  */\n+static rtx ignore_reg_for_conflicts;\n+\n /* Record hard register REGNO as now being live.  */\n static void\n make_hard_regno_live (int regno)\n@@ -101,6 +105,11 @@ make_hard_regno_dead (int regno)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n \n+      if (ignore_reg_for_conflicts != NULL_RTX\n+\t  && REGNO (ignore_reg_for_conflicts)\n+\t     == (unsigned int) ALLOCNO_REGNO (OBJECT_ALLOCNO (obj)))\n+\tcontinue;\n+\n       SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n       SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno);\n     }\n@@ -154,12 +163,38 @@ static void\n make_object_dead (ira_object_t obj)\n {\n   live_range_t lr;\n+  int ignore_regno = -1;\n+  int end_regno = -1;\n \n   sparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n \n+  /* Check whether any part of IGNORE_REG_FOR_CONFLICTS already conflicts\n+     with OBJ.  */\n+  if (ignore_reg_for_conflicts != NULL_RTX\n+      && REGNO (ignore_reg_for_conflicts) < FIRST_PSEUDO_REGISTER)\n+    {\n+      end_regno = END_REGNO (ignore_reg_for_conflicts);\n+      int src_regno = ignore_regno = REGNO (ignore_reg_for_conflicts);\n+\n+      while (src_regno < end_regno)\n+\t{\n+\t  if (TEST_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), src_regno))\n+\t    {\n+\t      ignore_regno = end_regno = -1;\n+\t      break;\n+\t    }\n+\t  src_regno++;\n+\t}\n+    }\n+\n   IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n   IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n \n+  /* If IGNORE_REG_FOR_CONFLICTS did not already conflict with OBJ, make\n+     sure it still doesn't.  */\n+  for (; ignore_regno < end_regno; ignore_regno++)\n+    CLEAR_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), ignore_regno);\n+\n   lr = OBJECT_LIVE_RANGES (obj);\n   ira_assert (lr != NULL);\n   lr->finish = curr_point;\n@@ -1022,6 +1057,38 @@ find_call_crossed_cheap_reg (rtx_insn *insn)\n   return cheap_reg;\n }  \n \n+/* Determine whether INSN is a register to register copy of the type where\n+   we do not need to make the source and destiniation registers conflict.\n+   If this is a copy instruction, then return the source reg.  Otherwise,\n+   return NULL_RTX.  */\n+rtx\n+non_conflicting_reg_copy_p (rtx_insn *insn)\n+{\n+  rtx set = single_set (insn);\n+\n+  /* Disallow anything other than a simple register to register copy\n+     that has no side effects.  */\n+  if (set == NULL_RTX\n+      || !REG_P (SET_DEST (set))\n+      || !REG_P (SET_SRC (set))\n+      || side_effects_p (set))\n+    return NULL_RTX;\n+\n+  int dst_regno = REGNO (SET_DEST (set));\n+  int src_regno = REGNO (SET_SRC (set));\n+  machine_mode mode = GET_MODE (SET_DEST (set));\n+\n+  /* Computing conflicts for register pairs is difficult to get right, so\n+     for now, disallow it.  */\n+  if ((dst_regno < FIRST_PSEUDO_REGISTER\n+       && hard_regno_nregs (dst_regno, mode) != 1)\n+      || (src_regno < FIRST_PSEUDO_REGISTER\n+\t  && hard_regno_nregs (src_regno, mode) != 1))\n+    return NULL_RTX;\n+\n+  return SET_SRC (set);\n+}\n+\n /* Process insns of the basic block given by its LOOP_TREE_NODE to\n    update allocno live ranges, allocno hard register conflicts,\n    intersected calls, and register pressure info for allocnos for the\n@@ -1107,22 +1174,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t     curr_point);\n \n \t  call_p = CALL_P (insn);\n-#ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n-\t  int regno;\n-\t  bool clear_pic_use_conflict_p = false;\n-\t  /* Processing insn usage in call insn can create conflict\n-\t     with pic pseudo and pic hard reg and that is wrong.\n-\t     Check this situation and fix it at the end of the insn\n-\t     processing.  */\n-\t  if (call_p && pic_offset_table_rtx != NULL_RTX\n-\t      && (regno = REGNO (pic_offset_table_rtx)) >= FIRST_PSEUDO_REGISTER\n-\t      && (a = ira_curr_regno_allocno_map[regno]) != NULL)\n-\t    clear_pic_use_conflict_p\n-\t\t= (find_regno_fusage (insn, USE, REAL_PIC_OFFSET_TABLE_REGNUM)\n-\t\t   && ! TEST_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS\n-\t\t\t\t\t   (ALLOCNO_OBJECT (a, 0)),\n-\t\t\t\t\t   REAL_PIC_OFFSET_TABLE_REGNUM));\n-#endif\n+\t  ignore_reg_for_conflicts = non_conflicting_reg_copy_p (insn);\n \n \t  /* Mark each defined value as live.  We need to do this for\n \t     unused values because they still conflict with quantities\n@@ -1276,20 +1328,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t}\n \t    }\n \n-#ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n-\t  if (clear_pic_use_conflict_p)\n-\t    {\n-\t      regno = REGNO (pic_offset_table_rtx);\n-\t      a = ira_curr_regno_allocno_map[regno];\n-\t      CLEAR_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (ALLOCNO_OBJECT (a, 0)),\n-\t\t\t\t  REAL_PIC_OFFSET_TABLE_REGNUM);\n-\t      CLEAR_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS\n-\t\t\t\t  (ALLOCNO_OBJECT (a, 0)),\n-\t\t\t\t  REAL_PIC_OFFSET_TABLE_REGNUM);\n-\t    }\n-#endif\n \t  curr_point++;\n \t}\n+      ignore_reg_for_conflicts = NULL_RTX;\n \n       if (bb_has_eh_pred (bb))\n \tfor (j = 0; ; ++j)"}, {"sha": "8a8e4605032daa8b0b7f9a36e79789bdfa8c803b", "filename": "gcc/ira.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -210,6 +210,9 @@ extern void ira_adjust_equiv_reg_cost (unsigned, int);\n /* ira-costs.c */\n extern void ira_costs_c_finalize (void);\n \n+/* ira-lives.c */\n+extern rtx non_conflicting_reg_copy_p (rtx_insn *);\n+\n /* Spilling static chain pseudo may result in generation of wrong\n    non-local goto code using frame-pointer to address saved stack\n    pointer value after restoring old frame pointer value.  The"}, {"sha": "0bf8cd06a302c8a6fcb914b94f953cdaa86597a2", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -96,6 +96,10 @@ static bitmap_head temp_bitmap;\n /* Pool for pseudo live ranges.\t */\n static object_allocator<lra_live_range> lra_live_range_pool (\"live ranges\");\n \n+/* If non-NULL, the source operand of a register to register copy for which\n+   we should not add a conflict with the copy's destination operand.  */\n+static rtx ignore_reg_for_conflicts;\n+\n /* Free live range list LR.  */\n static void\n free_live_range_list (lra_live_range_t lr)\n@@ -239,25 +243,22 @@ make_hard_regno_live (int regno)\n \n /* Process the definition of hard register REGNO.  This updates\n    hard_regs_live, START_DYING and conflict hard regs for living\n-   pseudos.  Conflict hard regs for the pic pseudo is not updated if\n-   REGNO is REAL_PIC_OFFSET_TABLE_REGNUM and CHECK_PIC_PSEUDO_P is\n-   true.  */\n+   pseudos.  */\n static void\n-make_hard_regno_dead (int regno, bool check_pic_pseudo_p ATTRIBUTE_UNUSED)\n+make_hard_regno_dead (int regno)\n {\n   lra_assert (regno < FIRST_PSEUDO_REGISTER);\n   if (! TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   sparseset_set_bit (start_dying, regno);\n   unsigned int i;\n   EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, i)\n-#ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n-    if (! check_pic_pseudo_p\n-\t|| regno != REAL_PIC_OFFSET_TABLE_REGNUM\n-\t|| pic_offset_table_rtx == NULL\n-\t|| i != REGNO (pic_offset_table_rtx))\n-#endif\n+    {\n+      if (ignore_reg_for_conflicts != NULL_RTX\n+\t  && REGNO (ignore_reg_for_conflicts) == i)\n+\tcontinue;\n       SET_HARD_REG_BIT (lra_reg_info[i].conflict_hard_regs, regno);\n+    }\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n   if (fixed_regs[regno] || TEST_HARD_REG_BIT (hard_regs_spilled_into, regno))\n     {\n@@ -294,14 +295,41 @@ static void\n mark_pseudo_dead (int regno, int point)\n {\n   lra_live_range_t p;\n+  int ignore_regno = -1;\n+  int end_regno = -1;\n \n   lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n   lra_assert (sparseset_bit_p (pseudos_live, regno));\n   sparseset_clear_bit (pseudos_live, regno);\n   sparseset_set_bit (start_dying, regno);\n \n+  /* Check whether any part of IGNORE_REG_FOR_CONFLICTS already conflicts\n+     with REGNO.  */\n+  if (ignore_reg_for_conflicts != NULL_RTX\n+      && REGNO (ignore_reg_for_conflicts) < FIRST_PSEUDO_REGISTER)\n+    {\n+      end_regno = END_REGNO (ignore_reg_for_conflicts);\n+      int src_regno = ignore_regno = REGNO (ignore_reg_for_conflicts);\n+\n+      while (src_regno < end_regno)\n+\t{\n+\t  if (TEST_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs,\n+\t\t\t\t src_regno))\n+\t    {\n+\t      ignore_regno = end_regno = -1;\n+\t      break;\n+\t    }\n+\t  src_regno++;\n+\t}\n+    }\n+\n   IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n \n+  /* If IGNORE_REG_FOR_CONFLICTS did not already conflict with REGNO, make\n+     sure it still doesn't.  */\n+  for (; ignore_regno < end_regno; ignore_regno++)\n+    CLEAR_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs, ignore_regno);\n+\n   if (complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n     {\n       p = lra_reg_info[regno].live_ranges;\n@@ -350,7 +378,7 @@ mark_regno_dead (int regno, machine_mode mode, int point)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       for (last = end_hard_regno (mode, regno); regno < last; regno++)\n-\tmake_hard_regno_dead (regno, false);\n+\tmake_hard_regno_dead (regno);\n     }\n   else\n     {\n@@ -747,6 +775,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t}\n \n       call_p = CALL_P (curr_insn);\n+      ignore_reg_for_conflicts = non_conflicting_reg_copy_p (curr_insn);\n       src_regno = (set != NULL_RTX && REG_P (SET_SRC (set))\n \t\t   ? REGNO (SET_SRC (set)) : -1);\n       dst_regno = (set != NULL_RTX && REG_P (SET_DEST (set))\n@@ -858,14 +887,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT\n \t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n-\t  make_hard_regno_dead (reg->regno, false);\n+\t  make_hard_regno_dead (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n \t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t    /* It is a clobber.  Don't create conflict of used\n-\t       REAL_PIC_OFFSET_TABLE_REGNUM and the pic pseudo.  */\n-\t    make_hard_regno_dead (regno - FIRST_PSEUDO_REGISTER, true);\n+\t    /* It is a clobber.  */\n+\t    make_hard_regno_dead (regno - FIRST_PSEUDO_REGISTER);\n \n       if (call_p)\n \t{\n@@ -926,8 +954,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t  make_hard_regno_live (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n-\t/* Make argument hard registers live.  Don't create conflict\n-\t   of used REAL_PIC_OFFSET_TABLE_REGNUM and the pic pseudo.  */\n+\t/* Make argument hard registers live.  */\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    make_hard_regno_live (regno);\n@@ -955,7 +982,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      if (reg2->type != OP_OUT && reg2->regno == reg->regno)\n \t\tbreak;\n \t    if (reg2 == NULL)\n-\t      make_hard_regno_dead (reg->regno, false);\n+\t      make_hard_regno_dead (reg->regno);\n \t  }\n \n       if (need_curr_point_incr)\n@@ -990,6 +1017,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       EXECUTE_IF_SET_IN_SPARSESET (unused_set, j)\n \tadd_reg_note (curr_insn, REG_UNUSED, regno_reg_rtx[j]);\n     }\n+  ignore_reg_for_conflicts = NULL_RTX;\n \n   if (bb_has_eh_pred (bb))\n     for (j = 0; ; ++j)"}, {"sha": "f34b1670a9388d352a8070ce25ba8d43b534076c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -1,3 +1,10 @@\n+2018-10-05  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/86939\n+\tPR rtl-optimization/87479\n+\t* gcc.target/powerpc/pr86939.c: New test.\n+\t* gcc/testsuite/gcc.target/i386/pr49095.c: Fix expected results.\n+\n 2018-10-05  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* gnat.dg/string_merge1.adb: Fix test expectations."}, {"sha": "20175e73f14aea9944ec8acfe5eb43112e7a1b82", "filename": "gcc/testsuite/gcc.target/i386/pr49095.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr49095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr49095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr49095.c?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -73,4 +73,5 @@ G (long)\n /* { dg-final { scan-assembler-not \"test\\[lq\\]\" } } */\n /* The {f,h}{char,short,int,long}xor functions aren't optimized into\n    a RMW instruction, so need load, modify and store.  FIXME eventually.  */\n-/* { dg-final { scan-assembler-times \"\\\\), %\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\\\), %\" 57 { target { ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"\\\\), %\" 45 { target { ! ia32 } } } } */"}, {"sha": "4bc9793ebbe37f36c2a7de72483ef5470b492ebb", "filename": "gcc/testsuite/gcc.target/powerpc/pr86939.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86939.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a141f2d86293dc202e35bd4d7f832756e1792cdf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86939.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86939.c?ref=a141f2d86293dc202e35bd4d7f832756e1792cdf", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef long (*fptr_t) (void);\n+long\n+func (fptr_t *p)\n+{\n+  if (p)\n+    return (*p) ();\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-not {mr %?r?12,} } } */"}]}