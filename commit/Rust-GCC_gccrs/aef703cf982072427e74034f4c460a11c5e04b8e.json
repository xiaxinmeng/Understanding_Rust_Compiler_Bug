{"sha": "aef703cf982072427e74034f4c460a11c5e04b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmNzAzY2Y5ODIwNzI0MjdlNzQwMzRmNGM0NjBhMTFjNWUwNGI4ZQ==", "commit": {"author": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-07-29T10:18:07Z"}, "committer": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-08-18T17:40:31Z"}, "message": "analyzer: detect and analyze calls via function pointer\n\n2021-07-29  Ankur Saini  <arsenic@sourceware.org>\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/100546\n\t* analysis-plan.cc (analysis_plan::use_summary_p): Don't use call\n\tsummaries if there is no callgraph edge\n\t* checker-path.cc (call_event::call_event): Handle calls events that\n\tare not represented by a supergraph call edge\n\t(return_event::return_event): Likewise.\n\t(call_event::get_desc): Work with new call_event structure.\n\t(return_event::get_desc): Likeise.\n\t* checker-path.h (call_event::m_src_snode): New field.\n\t(call_event::m_dest_snode): New field.\n\t(return_event::m_src_snode): New field.\n\t(return_event::m_dest_snode): New field.\n\t* diagnostic-manager.cc\n\t(diagnostic_manager::prune_for_sm_diagnostic)<case EK_CALL_EDGE>:\n\tRefactor to work with edges without callgraph edge.\n\t(diagnostic_manager::prune_for_sm_diagnostic)<case EK_RETURN_EDGE>:\n\tLikewise.\n\t* engine.cc (dynamic_call_info_t::update_model): New function.\n\t(dynamic_call_info_t::add_events_to_path): New function.\n\t(exploded_graph::create_dynamic_call): New function.\n\t(exploded_graph::process_node): Work with dynamically discovered calls.\n\t* exploded-graph.h (class dynamic_call_info_t): New class.\n\t(exploded_graph::create_dynamic_call): New decl.\n\t* program-point.cc (program_point::push_to_call_stack): New function.\n\t(program_point::pop_from_call_stack): New function.\n\t* program-point.h (program_point::push_to_call_stack): New decl.\n\t(program_point::pop_from_call_stack): New decl.\n\t* program-state.cc (program_state::push_call): New function.\n\t(program_state::returning_call): New function.\n\t* program-state.h (program_state::push_call): New decl.\n\t(program_state::returning_call): New decl.\n\t* region-model.cc (region_model::update_for_gcall) New function.\n\t(region_model::update_for_return_gcall): New function.\n\t(egion_model::update_for_call_superedge): Get the underlying gcall and\n\tupdate for gcall.\n\t(region_model::update_for_return_superedge): Likewise.\n\t* region-model.h (region_model::update_for_gcall): New decl.\n\t(region_model::update_for_return_gcall): New decl.\n\t* state-purge.cc (state_purge_per_ssa_name::process_point): Update to\n\twork with calls without underlying cgraph edge.\n\t* supergraph.cc (supergraph::supergraph) Split snodes at every callsite.\n\t* supergraph.h (supernode::get_returning_call) New accessor.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/100546\n\t* gcc.dg/analyzer/function-ptr-4.c: New test.\n\t* gcc.dg/analyzer/pr100546.c: New test.", "tree": {"sha": "f79867f503617cc38b2b7d3161217e766492e4d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f79867f503617cc38b2b7d3161217e766492e4d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef703cf982072427e74034f4c460a11c5e04b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef703cf982072427e74034f4c460a11c5e04b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef703cf982072427e74034f4c460a11c5e04b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef703cf982072427e74034f4c460a11c5e04b8e/comments", "author": null, "committer": null, "parents": [{"sha": "bb04a03c6f9bacc890118b9e12b657503093c2f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb04a03c6f9bacc890118b9e12b657503093c2f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb04a03c6f9bacc890118b9e12b657503093c2f8"}], "stats": {"total": 535, "additions": 481, "deletions": 54}, "files": [{"sha": "57a6dcb1f6e0d542c2192969187d02d0c669c5dc", "filename": "gcc/analyzer/analysis-plan.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fanalysis-plan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fanalysis-plan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalysis-plan.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -109,6 +109,10 @@ analysis_plan::use_summary_p (const cgraph_edge *edge) const\n   if (!flag_analyzer_call_summaries)\n     return false;\n \n+  /* Don't use call summaries if there is no callgraph edge */\n+  if (!edge || !edge->callee)\n+    return false;\n+\n   /* TODO: don't count callsites each time.  */\n   int num_call_sites = 0;\n   const cgraph_node *callee = edge->callee;"}, {"sha": "e132f003470eded1e644607d154bf67883d1134a", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -614,7 +614,11 @@ call_event::call_event (const exploded_edge &eedge,\n \t\t\tlocation_t loc, tree fndecl, int depth)\n : superedge_event (EK_CALL_EDGE, eedge, loc, fndecl, depth)\n {\n-  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CALL);\n+  if (eedge.m_sedge)\n+    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CALL);\n+\n+   m_src_snode = eedge.m_src->get_supernode ();\n+   m_dest_snode = eedge.m_dest->get_supernode ();\n }\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n@@ -638,8 +642,8 @@ call_event::get_desc (bool can_colorize) const\n       label_text custom_desc\n \t= m_pending_diagnostic->describe_call_with_state\n \t    (evdesc::call_with_state (can_colorize,\n-\t\t\t\t      m_sedge->m_src->m_fun->decl,\n-\t\t\t\t      m_sedge->m_dest->m_fun->decl,\n+\t\t\t\t      m_src_snode->m_fun->decl,\n+\t\t\t\t      m_dest_snode->m_fun->decl,\n \t\t\t\t      var,\n \t\t\t\t      m_critical_state));\n       if (custom_desc.m_buffer)\n@@ -648,8 +652,8 @@ call_event::get_desc (bool can_colorize) const\n \n   return make_label_text (can_colorize,\n \t\t\t  \"calling %qE from %qE\",\n-\t\t\t  m_sedge->m_dest->m_fun->decl,\n-\t\t\t  m_sedge->m_src->m_fun->decl);\n+\t\t\t  m_dest_snode->m_fun->decl,\n+\t\t\t  m_src_snode->m_fun->decl);\n }\n \n /* Override of checker_event::is_call_p for calls.  */\n@@ -668,7 +672,11 @@ return_event::return_event (const exploded_edge &eedge,\n \t\t\t    location_t loc, tree fndecl, int depth)\n : superedge_event (EK_RETURN_EDGE, eedge, loc, fndecl, depth)\n {\n-  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_RETURN);\n+  if (eedge.m_sedge)\n+    gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_RETURN);\n+\n+  m_src_snode = eedge.m_src->get_supernode ();\n+  m_dest_snode = eedge.m_dest->get_supernode ();\n }\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n@@ -694,16 +702,16 @@ return_event::get_desc (bool can_colorize) const\n       label_text custom_desc\n \t= m_pending_diagnostic->describe_return_of_state\n \t    (evdesc::return_of_state (can_colorize,\n-\t\t\t\t      m_sedge->m_dest->m_fun->decl,\n-\t\t\t\t      m_sedge->m_src->m_fun->decl,\n+\t\t\t\t      m_dest_snode->m_fun->decl,\n+\t\t\t\t      m_src_snode->m_fun->decl,\n \t\t\t\t      m_critical_state));\n       if (custom_desc.m_buffer)\n \treturn custom_desc;\n     }\n   return make_label_text (can_colorize,\n \t\t\t  \"returning to %qE from %qE\",\n-\t\t\t  m_sedge->m_dest->m_fun->decl,\n-\t\t\t  m_sedge->m_src->m_fun->decl);\n+\t\t\t  m_dest_snode->m_fun->decl,\n+\t\t\t  m_src_snode->m_fun->decl);\n }\n \n /* Override of checker_event::is_return_p for returns.  */"}, {"sha": "27634c20864217a78507af997a6b5f4340370d55", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -338,6 +338,9 @@ class call_event : public superedge_event\n   label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n \n   bool is_call_p () const FINAL OVERRIDE;\n+\n+  const supernode *m_src_snode;\n+  const supernode *m_dest_snode;\n };\n \n /* A concrete event subclass for an interprocedural return.  */\n@@ -351,6 +354,9 @@ class return_event : public superedge_event\n   label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n \n   bool is_return_p () const FINAL OVERRIDE;\n+\n+  const supernode *m_src_snode;\n+  const supernode *m_dest_snode;\n };\n \n /* A concrete event subclass for the start of a consolidated run of CFG"}, {"sha": "06e751033ac9c8985bcdd95f1b61de527da43ade", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -2093,18 +2093,13 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \tcase EK_CALL_EDGE:\n \t  {\n \t    call_event *event = (call_event *)base_event;\n-\t    const callgraph_superedge& cg_superedge\n-\t      = event->get_callgraph_superedge ();\n \t    const region_model *callee_model\n \t      = event->m_eedge.m_dest->get_state ().m_region_model;\n+\t    const region_model *caller_model\n+\t      = event->m_eedge.m_src->get_state ().m_region_model;\n \t    tree callee_var = callee_model->get_representative_tree (sval);\n-\t    /* We could just use caller_model->get_representative_tree (sval);\n-\t       to get the caller_var, but for now use\n-\t       map_expr_from_callee_to_caller so as to only record critical\n-\t       state for parms and the like.  */\n \t    callsite_expr expr;\n-\t    tree caller_var\n-\t      = cg_superedge.map_expr_from_callee_to_caller (callee_var, &expr);\n+\t    tree caller_var = caller_model->get_representative_tree (sval);\n \t    if (caller_var)\n \t      {\n \t\tif (get_logger ())\n@@ -2126,15 +2121,11 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t    if (sval)\n \t      {\n \t\treturn_event *event = (return_event *)base_event;\n-\t\tconst callgraph_superedge& cg_superedge\n-\t\t  = event->get_callgraph_superedge ();\n-\t\tconst region_model *caller_model\n-\t\t  = event->m_eedge.m_dest->get_state ().m_region_model;\n-\t\ttree caller_var = caller_model->get_representative_tree (sval);\n \t\tcallsite_expr expr;\n-\t\ttree callee_var\n-\t\t  = cg_superedge.map_expr_from_caller_to_callee (caller_var,\n-\t\t\t\t\t\t\t\t &expr);\n+\n+\t\tconst region_model *callee_model\n+\t      \t  = event->m_eedge.m_src->get_state ().m_region_model;\n+\t\ttree callee_var = callee_model->get_representative_tree (sval);\n \t\tif (callee_var)\n \t\t  {\n \t\t    if (get_logger ())"}, {"sha": "461de9cf77c76e56cb1972ad4bda42555e8a8ff3", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -1627,6 +1627,50 @@ exploded_node::dump_succs_and_preds (FILE *outf) const\n   }\n }\n \n+/* class dynamic_call_info_t : public exploded_edge::custom_info_t.  */\n+\n+/* Implementation of exploded_edge::custom_info_t::update_model vfunc\n+   for dynamic_call_info_t.\n+\n+   Update state for the dynamically discorverd calls */\n+\n+void\n+dynamic_call_info_t::update_model (region_model *model,\n+\t\t\t\t   const exploded_edge &eedge)\n+{\n+  const program_state &dest_state = eedge.m_dest->get_state ();\n+  *model = *dest_state.m_region_model;\n+}\n+\n+/* Implementation of exploded_edge::custom_info_t::add_events_to_path vfunc\n+   for dynamic_call_info_t.  */\n+\n+void\n+dynamic_call_info_t::add_events_to_path (checker_path *emission_path,\n+\t\t\t\t   const exploded_edge &eedge)\n+{\n+  const exploded_node *src_node = eedge.m_src;\n+  const program_point &src_point = src_node->get_point ();\n+  const int src_stack_depth = src_point.get_stack_depth ();\n+  const exploded_node *dest_node = eedge.m_dest;\n+  const program_point &dest_point = dest_node->get_point ();\n+  const int dest_stack_depth = dest_point.get_stack_depth ();\n+\n+  if (m_is_returning_call)\n+    emission_path->add_event (new return_event (eedge, (m_dynamic_call\n+\t                   \t\t\t        ? m_dynamic_call->location\n+\t           \t   \t\t                : UNKNOWN_LOCATION),\n+\t          \t      dest_point.get_fndecl (),\n+\t          \t      dest_stack_depth));\n+  else\n+    emission_path->add_event (new call_event (eedge, (m_dynamic_call\n+\t                   \t\t\t      ? m_dynamic_call->location\n+\t           \t   \t\t              : UNKNOWN_LOCATION),\n+\t          \t      src_point.get_fndecl (),\n+\t          \t      src_stack_depth));\n+\n+}\n+\n /* class rewind_info_t : public exploded_edge::custom_info_t.  */\n \n /* Implementation of exploded_edge::custom_info_t::update_model vfunc\n@@ -2980,6 +3024,61 @@ state_change_requires_new_enode_p (const program_state &old_state,\n   return false;\n }\n \n+/* Create enodes and eedges for the function calls that doesn't have an \n+   underlying call superedge.\n+\n+   Such case occurs when GCC's middle end didn't know which function to\n+   call but the analyzer does (with the help of current state).\n+\n+   Some example such calls are dynamically dispatched calls to virtual\n+   functions or calls that happen via function pointer.  */\n+\n+void\n+exploded_graph::create_dynamic_call (const gcall *call,\n+                                     tree fn_decl,\n+                                     exploded_node *node,\n+                                     program_state next_state,\n+                                     program_point &next_point,\n+                                     uncertainty_t *uncertainty,\n+                                     logger *logger)\n+{\n+  LOG_FUNC (logger);\n+\n+  const program_point *this_point = &node->get_point ();\n+  function *fun = DECL_STRUCT_FUNCTION (fn_decl);\n+  if (fun)\n+    {\n+      const supergraph &sg = this->get_supergraph ();\n+      supernode * sn_entry = sg.get_node_for_function_entry (fun);\n+      supernode * sn_exit = sg.get_node_for_function_exit (fun);\n+\n+      program_point new_point\n+        = program_point::before_supernode (sn_entry,\n+                                           NULL,\n+                                           this_point->get_call_string ());\n+\n+      new_point.push_to_call_stack (sn_exit,\n+                                    next_point.get_supernode());\n+      next_state.push_call (*this, node, call, uncertainty);\n+\n+      if (next_state.m_valid)\n+        {\n+          if (logger)\n+            logger->log (\"Discovered call to %s [SN: %i -> SN: %i]\",\n+                          function_name(fun),\n+                          this_point->get_supernode ()->m_index,\n+                          sn_entry->m_index);\n+\n+          exploded_node *enode = get_or_create_node (new_point,\n+                                                     next_state,\n+                                                     node);\n+          if (enode)\n+            add_edge (node,enode, NULL,\n+                      new dynamic_call_info_t (call));\n+        }\n+     }\n+}\n+\n /* The core of exploded_graph::process_worklist (the main analysis loop),\n    handling one node in the worklist.\n \n@@ -3174,10 +3273,13 @@ exploded_graph::process_node (exploded_node *node)\n       break;\n     case PK_AFTER_SUPERNODE:\n       {\n+        bool found_a_superedge = false;\n+        bool is_an_exit_block = false;\n \t/* If this is an EXIT BB, detect leaks, and potentially\n \t   create a function summary.  */\n \tif (point.get_supernode ()->return_p ())\n \t  {\n+\t    is_an_exit_block = true;\n \t    node->detect_leaks (*this);\n \t    if (flag_analyzer_call_summaries\n \t\t&& point.get_call_string ().empty_p ())\n@@ -3205,6 +3307,7 @@ exploded_graph::process_node (exploded_node *node)\n \tsuperedge *succ;\n \tFOR_EACH_VEC_ELT (point.get_supernode ()->m_succs, i, succ)\n \t  {\n+\t    found_a_superedge = true;\n \t    if (logger)\n \t      logger->log (\"considering SN: %i -> SN: %i\",\n \t\t\t   succ->m_src->m_index, succ->m_dest->m_index);\n@@ -3214,6 +3317,54 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t\t point.get_call_string ());\n \t    program_state next_state (state);\n \t    uncertainty_t uncertainty;\n+\n+            /* Make use the current state and try to discover and analyse\n+               indirect function calls (a call that doesn't have an underlying\n+               cgraph edge representing call).\n+\n+               Some examples of such calls are virtual function calls\n+               and calls that happen via a function pointer.  */\n+            if (succ->m_kind == SUPEREDGE_INTRAPROCEDURAL_CALL\n+            \t&& !(succ->get_any_callgraph_edge ()))\n+              {\n+                const gcall *call\n+                  = point.get_supernode ()->get_final_call ();\n+\n+                impl_region_model_context ctxt (*this,\n+                                                node,\n+                                                &state,\n+                                                &next_state,\n+                                                &uncertainty,\n+                                                point.get_stmt());\n+\n+                region_model *model = state.m_region_model;\n+\n+                if (tree fn_decl = model->get_fndecl_for_call(call,&ctxt))\n+                  create_dynamic_call (call,\n+                                       fn_decl,\n+                                       node,\n+                                       next_state,\n+                                       next_point,\n+                                       &uncertainty,\n+                                       logger);\n+                else\n+                  {\n+                     /* An unknown function was called at this point, in such\n+                        case, don't terminate the analysis of the current\n+                        function.\n+\n+                        The analyzer handles calls to unknown functions while\n+                        analysing the stmt itself, so the the function call\n+                        must have been handled by the anlyzer till now.  */\n+                     exploded_node *next\n+                       = get_or_create_node (next_point,\n+                                             next_state,\n+                                             node);\n+                     if (next)\n+                       add_edge (node, next, succ);\n+                  }\n+              }\n+\n \t    if (!node->on_edge (*this, succ, &next_point, &next_state,\n \t\t\t\t&uncertainty))\n \t      {\n@@ -3227,6 +3378,38 @@ exploded_graph::process_node (exploded_node *node)\n \t    if (next)\n \t      add_edge (node, next, succ);\n \t  }\n+\n+        /* Return from the calls which doesn't have a return superedge.\n+    \t   Such case occurs when GCC's middle end didn't knew which function to\n+    \t   call but analyzer did.  */\n+        if((is_an_exit_block && !found_a_superedge)\n+           && (!point.get_call_string ().empty_p ()))\n+          {\n+            const call_string cs = point.get_call_string ();\n+            program_point next_point\n+              = program_point::before_supernode (cs.get_caller_node (),\n+                                                 NULL,\n+                                                 cs);\n+            program_state next_state (state);\n+            uncertainty_t uncertainty;\n+\n+            const gcall *call\n+              = next_point.get_supernode ()->get_returning_call ();\n+\n+            if(call)\n+              next_state.returning_call (*this, node, call, &uncertainty);\n+\n+            if (next_state.m_valid)\n+              {\n+                next_point.pop_from_call_stack ();\n+                exploded_node *enode = get_or_create_node (next_point,\n+                                                           next_state,\n+                                                           node);\n+                if (enode)\n+                  add_edge (node, enode, NULL,\n+                            new dynamic_call_info_t (call, true));\n+              }\n+          }\n       }\n       break;\n     }"}, {"sha": "192a4b3c8f88f7bd5b53968c791a008224ad15b1", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -362,6 +362,37 @@ class exploded_edge : public dedge<eg_traits>\n   DISABLE_COPY_AND_ASSIGN (exploded_edge);\n };\n \n+/* Extra data for an exploded_edge that represents dynamic call info ( calls\n+   that doesn't have an underlying superedge representing the call ).  */\n+\n+class dynamic_call_info_t : public exploded_edge::custom_info_t\n+{\n+public:\n+  dynamic_call_info_t (const gcall *dynamic_call,\n+  \t\t       const bool is_returning_call = false)\n+  : m_dynamic_call (dynamic_call), \n+    m_is_returning_call (is_returning_call)\n+  {}\n+\n+  void print (pretty_printer *pp) FINAL OVERRIDE\n+  {\n+    if (m_is_returning_call)\n+      pp_string (pp, \"dynamic_return\");\n+    else\n+      pp_string (pp, \"dynamic_call\");\n+  }\n+\n+  void update_model (region_model *model,\n+\t\t     const exploded_edge &eedge) FINAL OVERRIDE;\n+\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &eedge) FINAL OVERRIDE;\n+private:\n+  const gcall *m_dynamic_call;\n+  const bool m_is_returning_call;\n+};\n+\n+\n /* Extra data for an exploded_edge that represents a rewind from a\n    longjmp to a setjmp (or from a siglongjmp to a sigsetjmp).  */\n \n@@ -785,6 +816,14 @@ class exploded_graph : public digraph<eg_traits>\n   bool maybe_process_run_of_before_supernode_enodes (exploded_node *node);\n   void process_node (exploded_node *node);\n \n+  void create_dynamic_call (const gcall *call,\n+                            tree fn_decl,\n+                            exploded_node *node,\n+                            program_state next_state,\n+                            program_point &next_point,\n+                            uncertainty_t *uncertainty,\n+                            logger *logger);\n+\n   exploded_node *get_or_create_node (const program_point &point,\n \t\t\t\t     const program_state &state,\n \t\t\t\t     exploded_node *enode_for_diag);"}, {"sha": "25d56af3191c5ad01a6272e177130ee6e6e94241", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -330,6 +330,24 @@ program_point::to_json () const\n   return point_obj;\n }\n \n+/* Update the callstack to represent a call from caller to callee.\n+\n+   Generally used to push a custom call to a perticular program point \n+   where we don't have a superedge representing the call.  */\n+void\n+program_point::push_to_call_stack (const supernode *caller,\n+\t\t\t\t   const supernode *callee)\n+{\n+  m_call_string.push_call (callee, caller);\n+}\n+\n+/* Pop the topmost call from the current callstack.  */\n+void\n+program_point::pop_from_call_stack ()\n+{\n+  m_call_string.pop ();\n+}\n+\n /* Generate a hash value for this program_point.  */\n \n hashval_t"}, {"sha": "6bae29b23e811cf0b8e2f59fc6b5fe75e88cccd5", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -293,7 +293,8 @@ class program_point\n   }\n \n   bool on_edge (exploded_graph &eg, const superedge *succ);\n-\n+  void push_to_call_stack (const supernode *caller, const supernode *callee);\n+  void pop_from_call_stack ();\n   void validate () const;\n \n   /* For before_stmt, go to next stmt.  */"}, {"sha": "ea53c61f497df568039f5c6a6fa030d6a11758f6", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -1034,6 +1034,50 @@ program_state::on_edge (exploded_graph &eg,\n   return true;\n }\n \n+/* Update this program_state to reflect a call to function\n+   represented by CALL_STMT.\n+   currently used only when the call doesn't have a superedge representing \n+   the call ( like call via a function pointer )  */\n+void\n+program_state::push_call (exploded_graph &eg,\n+                          exploded_node *enode,\n+                          const gcall *call_stmt,\n+                          uncertainty_t *uncertainty)\n+{\n+  /* Update state.  */\n+  const program_point &point = enode->get_point ();\n+  const gimple *last_stmt = point.get_supernode ()->get_last_stmt ();\n+\n+  impl_region_model_context ctxt (eg, enode,\n+                                  &enode->get_state (),\n+                                  this,\n+                                  uncertainty,\n+                                  last_stmt);\n+  m_region_model->update_for_gcall (call_stmt, &ctxt);\n+}\n+\n+/* Update this program_state to reflect a return from function\n+   call to which is represented by CALL_STMT.\n+   currently used only when the call doesn't have a superedge representing \n+   the return */\n+void\n+program_state::returning_call (exploded_graph &eg,\n+                               exploded_node *enode,\n+                               const gcall *call_stmt,\n+                               uncertainty_t *uncertainty)\n+{\n+  /* Update state.  */\n+  const program_point &point = enode->get_point ();\n+  const gimple *last_stmt = point.get_supernode ()->get_last_stmt ();\n+\n+  impl_region_model_context ctxt (eg, enode,\n+                                  &enode->get_state (),\n+                                  this,\n+                                  uncertainty,\n+                                  last_stmt);\n+  m_region_model->update_for_return_gcall (call_stmt, &ctxt);\n+}\n+\n /* Generate a simpler version of THIS, discarding state that's no longer\n    relevant at POINT.\n    The idea is that we're more likely to be able to consolidate"}, {"sha": "eb49006d7771878829b50e14c0a74a0a3929b030", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -218,6 +218,17 @@ class program_state\n   void push_frame (const extrinsic_state &ext_state, function *fun);\n   function * get_current_function () const;\n \n+  void push_call (exploded_graph &eg,\n+\t\t  exploded_node *enode,\n+\t\t  const gcall *call_stmt,\n+\t\t  uncertainty_t *uncertainty);\n+\n+  void returning_call (exploded_graph &eg,\n+\t\t       exploded_node *enode,\n+\t\t       const gcall *call_stmt,\n+\t\t       uncertainty_t *uncertainty);\n+\n+\n   bool on_edge (exploded_graph &eg,\n \t\texploded_node *enode,\n \t\tconst superedge *succ,"}, {"sha": "2316fbe5041dd7263a07175e7fdf8eebf27f262c", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -3172,12 +3172,11 @@ region_model::maybe_update_for_edge (const superedge &edge,\n    caller's frame.  */\n \n void\n-region_model::update_for_call_superedge (const call_superedge &call_edge,\n-\t\t\t\t\t region_model_context *ctxt)\n+region_model::update_for_gcall (const gcall *call_stmt,\n+\t\t\t\tregion_model_context *ctxt)\n {\n   /* Build a vec of argument svalues, using the current top\n      frame for resolving tree expressions.  */\n-  const gcall *call_stmt = call_edge.get_call_stmt ();\n   auto_vec<const svalue *> arg_svals (gimple_call_num_args (call_stmt));\n \n   for (unsigned i = 0; i < gimple_call_num_args (call_stmt); i++)\n@@ -3186,33 +3185,58 @@ region_model::update_for_call_superedge (const call_superedge &call_edge,\n       arg_svals.quick_push (get_rvalue (arg, ctxt));\n     }\n \n-  push_frame (call_edge.get_callee_function (), &arg_svals, ctxt);\n+  /* Get the function * from the call.  */\n+  tree fn_decl = get_fndecl_for_call (call_stmt,ctxt);\n+  function *fun = DECL_STRUCT_FUNCTION (fn_decl);\n+  push_frame (fun, &arg_svals, ctxt);\n }\n \n /* Pop the top-most frame_region from the stack, and copy the return\n    region's values (if any) into the region for the lvalue of the LHS of\n    the call (if any).  */\n+\n void\n-region_model::update_for_return_superedge (const return_superedge &return_edge,\n-\t\t\t\t\t   region_model_context *ctxt)\n+region_model::update_for_return_gcall (const gcall *call_stmt,\n+\t\t\t\t       region_model_context *ctxt)\n {\n   /* Get the region for the result of the call, within the caller frame.  */\n   const region *result_dst_reg = NULL;\n-  const gcall *call_stmt = return_edge.get_call_stmt ();\n   tree lhs = gimple_call_lhs (call_stmt);\n   if (lhs)\n     {\n       /* Normally we access the top-level frame, which is:\n-\t   path_var (expr, get_stack_depth () - 1)\n-\t whereas here we need the caller frame, hence \"- 2\" here.  */\n+         path_var (expr, get_stack_depth () - 1)\n+         whereas here we need the caller frame, hence \"- 2\" here.  */\n       gcc_assert (get_stack_depth () >= 2);\n       result_dst_reg = get_lvalue (path_var (lhs, get_stack_depth () - 2),\n-\t\t\t\t   ctxt);\n+           \t\t\t   ctxt);\n     }\n \n   pop_frame (result_dst_reg, NULL, ctxt);\n }\n \n+/* Extract calling information from the superedge and update the model for the \n+   call  */\n+\n+void\n+region_model::update_for_call_superedge (const call_superedge &call_edge,\n+\t\t\t\t\t region_model_context *ctxt)\n+{\n+  const gcall *call_stmt = call_edge.get_call_stmt ();\n+  update_for_gcall (call_stmt,ctxt);\n+}\n+\n+/* Extract calling information from the return superedge and update the model \n+   for the returning call */\n+\n+void\n+region_model::update_for_return_superedge (const return_superedge &return_edge,\n+\t\t\t\t\t   region_model_context *ctxt)\n+{\n+  const gcall *call_stmt = return_edge.get_call_stmt ();\n+  update_for_return_gcall (call_stmt, ctxt);\n+}\n+\n /* Update this region_model with a summary of the effect of calling\n    and returning from CG_SEDGE.\n "}, {"sha": "e40264e0eb0168a3c823e2799d6540fecfa0ad82", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -608,6 +608,12 @@ class region_model\n \t\t\t      region_model_context *ctxt,\n \t\t\t      rejected_constraint **out);\n \n+  void update_for_gcall (const gcall *call_stmt,\n+                         region_model_context *ctxt);\n+  \n+  void update_for_return_gcall (const gcall *call_stmt,\n+                                region_model_context *ctxt);\n+\n   const region *push_frame (function *fun, const vec<const svalue *> *arg_sids,\n \t\t\t    region_model_context *ctxt);\n   const frame_region *get_current_frame () const { return m_current_frame; }"}, {"sha": "880057004e268873defcd988f939b13af6e18057", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -383,18 +383,31 @@ state_purge_per_ssa_name::process_point (const function_point &point,\n \t  {\n \t    /* Add any intraprocedually edge for a call.  */\n \t    if (snode->m_returning_call)\n-\t      {\n-\t\tcgraph_edge *cedge\n+\t    {\n+\t      gcall *returning_call = snode->m_returning_call;\n+\t      cgraph_edge *cedge\n \t\t  = supergraph_call_edge (snode->m_fun,\n-\t\t\t\t\t  snode->m_returning_call);\n-\t\tgcc_assert (cedge);\n-\t\tsuperedge *sedge\n-\t\t  = map.get_sg ().get_intraprocedural_edge_for_call (cedge);\n-\t\tgcc_assert (sedge);\n-\t\tadd_to_worklist\n-\t\t  (function_point::after_supernode (sedge->m_src),\n-\t\t   worklist, logger);\n-\t      }\n+\t\t\t\t\t  returning_call);\n+\t      if(cedge)\n+\t        {\n+\t\t  superedge *sedge\n+\t\t    = map.get_sg ().get_intraprocedural_edge_for_call (cedge);\n+\t\t  gcc_assert (sedge);\n+\t\t  add_to_worklist \n+\t\t    (function_point::after_supernode (sedge->m_src),\n+\t\t     worklist, logger);\n+\t        }\n+\t      else\n+\t        {\n+\t          supernode *callernode \n+\t            = map.get_sg ().get_supernode_for_stmt (returning_call);\n+\n+\t          gcc_assert (callernode);\n+\t          add_to_worklist \n+\t            (function_point::after_supernode (callernode),\n+\t\t     worklist, logger);\n+\t         }\n+\t    }\n \t  }\n       }\n       break;"}, {"sha": "66ef765f4728538ce423d9320ac1f66470a92717", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -183,11 +183,33 @@ supergraph::supergraph (logger *logger)\n \t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n \t      m_stmt_uids.make_uid_unique (stmt);\n \t      if (cgraph_edge *edge = supergraph_call_edge (fun, stmt))\n-\t\t{\n-\t\t  m_cgraph_edge_to_caller_prev_node.put(edge, node_for_stmts);\n-\t\t  node_for_stmts = add_node (fun, bb, as_a <gcall *> (stmt), NULL);\n-\t\t  m_cgraph_edge_to_caller_next_node.put (edge, node_for_stmts);\n-\t\t}\n+    \t\t{\n+    \t\t  m_cgraph_edge_to_caller_prev_node.put(edge, node_for_stmts);\n+    \t\t  node_for_stmts = add_node (fun, bb, as_a <gcall *> (stmt),\n+    \t\t   \t\t\t     NULL);\n+    \t\t  m_cgraph_edge_to_caller_next_node.put (edge, node_for_stmts);\n+    \t\t}\n+\t       else\n+\t        {\n+\t          // maybe call is via a function pointer\n+\t          if (gcall *call = dyn_cast<gcall *> (stmt))\n+\t          {\n+\t            cgraph_edge *edge \n+\t\t      = cgraph_node::get (fun->decl)->get_edge (stmt);\n+\t            if (!edge || !edge->callee)\n+\t            {\n+\t              supernode *old_node_for_stmts = node_for_stmts;\n+\t              node_for_stmts = add_node (fun, bb, call, NULL);\n+\n+\t              superedge *sedge \n+\t                = new callgraph_superedge (old_node_for_stmts,\n+\t                  \t\t\t   node_for_stmts,\n+\t                  \t\t\t   SUPEREDGE_INTRAPROCEDURAL_CALL,\n+\t                  \t\t\t   NULL);\n+\t              add_edge (sedge);\n+\t            }\n+\t          }\n+\t        }\n \t    }\n \n \t  m_bb_to_final_node.put (bb, node_for_stmts);\n@@ -1139,6 +1161,17 @@ callgraph_superedge::get_callee_decl () const\n   return get_callee_function ()->decl;\n }\n \n+/* Get the gcall * of this interprocedural call/return edge.  */\n+\n+gcall *\n+callgraph_superedge::get_call_stmt () const\n+{\n+  if (m_cedge)\n+    return m_cedge->call_stmt;\n+  \n+  return m_src->get_final_call ();\n+}\n+\n /* Get the calling fndecl at this interprocedural call/return edge.  */\n \n tree"}, {"sha": "335f5133407ded31909805b6e0df4895a1077d07", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -268,6 +268,11 @@ class supernode : public dnode<supergraph_traits>\n     return i;\n   }\n \n+  gcall *get_returning_call () const\n+  {\n+    return m_returning_call;\n+  }\n+\n   gimple *get_last_stmt () const\n   {\n     if (m_stmts.length () == 0)\n@@ -400,7 +405,7 @@ class callgraph_superedge : public superedge\n   function *get_caller_function () const;\n   tree get_callee_decl () const;\n   tree get_caller_decl () const;\n-  gcall *get_call_stmt () const { return m_cedge->call_stmt; }\n+  gcall *get_call_stmt () const;\n   tree get_arg_for_parm (tree parm, callsite_expr *out) const;\n   tree get_parm_for_arg (tree arg, callsite_expr *out) const;\n   tree map_expr_from_caller_to_callee (tree caller_expr,"}, {"sha": "016351a83f6bf4800a8440c8e25dc5dc319e7ff9", "filename": "gcc/testsuite/gcc.dg/analyzer/function-ptr-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-4.c?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -0,0 +1,24 @@\n+/* Test to see if the analyzer detect and analyze calls via \n+   function pointers or not.  */\n+\n+#include <stdlib.h>\n+\n+void fun(int *int_ptr)\n+{\n+\tfree(int_ptr); /* { dg-warning \"double-'free' of 'int_ptr'\" } */\n+}\n+\n+void single_call()\n+{\n+\tint *int_ptr = (int*)malloc(sizeof(int));\n+\tvoid (*fun_ptr)(int *) = &fun;\n+\t(*fun_ptr)(int_ptr);\n+}\n+\n+void double_call()\n+{\n+\tint *int_ptr = (int*)malloc(sizeof(int));\n+\tvoid (*fun_ptr)(int *) = &fun;\n+\t(*fun_ptr)(int_ptr); /* { dg-message \"calling 'fun' from 'double_call'\" } */\n+\t(*fun_ptr)(int_ptr);\n+}"}, {"sha": "3349d4067af19bb072983275b2c622f55399b153", "filename": "gcc/testsuite/gcc.dg/analyzer/pr100546.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr100546.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef703cf982072427e74034f4c460a11c5e04b8e/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr100546.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr100546.c?ref=aef703cf982072427e74034f4c460a11c5e04b8e", "patch": "@@ -0,0 +1,17 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static void noReturn(const char *str) __attribute__((noreturn));\n+static void noReturn(const char *str) {\n+    printf(\"%s\\n\", str);\n+    exit(1);\n+}\n+\n+void (*noReturnPtr)(const char *str) = &noReturn;\n+\n+int main(int argc, char **argv) {\n+    char *str = 0;\n+    if (!str)\n+        noReturnPtr(__FILE__);\n+    return printf(\"%c\\n\", *str);\n+}"}]}