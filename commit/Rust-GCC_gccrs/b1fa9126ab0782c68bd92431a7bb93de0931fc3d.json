{"sha": "b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFmYTkxMjZhYjA3ODJjNjhiZDkyNDMxYTdiYjkzZGUwOTMxZmMzZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-07T11:38:06Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-07T11:38:06Z"}, "message": "exp_pakd.adb (Create_Packed_Array_Type): Always use a modular type if the size is small enough.\n\n\t* exp_pakd.adb (Create_Packed_Array_Type): Always use a modular type\n\tif the size is small enough.  Propagate the alignment if there is an\n\talignment clause on the original array type.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Subtype>\n\tDeal with under-aligned packed array types.  Copy the size onto the\n\tjustified modular type and don't lay it out again.  Likewise for the\n\tpadding type built for other under-aligned subtypes.\n\t* gcc-interface/utils.c (finish_record_type): Do not set a default mode\n\ton the type.\n\nFrom-SVN: r158056", "tree": {"sha": "ac0006f43531b02d2b839144ae3cd43264776aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac0006f43531b02d2b839144ae3cd43264776aeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/comments", "author": null, "committer": null, "parents": [{"sha": "19c846942984690edb7ef6ed29be08a0aae1868a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c846942984690edb7ef6ed29be08a0aae1868a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c846942984690edb7ef6ed29be08a0aae1868a"}], "stats": {"total": 165, "additions": 114, "deletions": 51}, "files": [{"sha": "c740fa82c20eea5c39087ba214cead1a98057192", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -1,3 +1,15 @@\n+2010-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_pakd.adb (Create_Packed_Array_Type): Always use a modular type\n+\tif the size is small enough.  Propagate the alignment if there is an\n+\talignment clause on the original array type.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Subtype>\n+\tDeal with under-aligned packed array types.  Copy the size onto the\n+\tjustified modular type and don't lay it out again.  Likewise for the\n+\tpadding type built for other under-aligned subtypes.\n+\t* gcc-interface/utils.c (finish_record_type): Do not set a default mode\n+\ton the type.\n+\n 2010-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Procedure>: Set default"}, {"sha": "c1d25c2d68f171fa2ca71fc9b6a283653844dc25", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -1134,16 +1134,6 @@ package body Exp_Pakd is\n                 (Len_Bits <= System_Word_Size\n                    or else (Len_Bits <= System_Max_Binary_Modulus_Power\n                               and then Support_Long_Shifts_On_Target))\n-\n-            --  Also test for alignment given. If an alignment is given which\n-            --  is smaller than the natural modular alignment, force the array\n-            --  of bytes representation to accommodate the alignment.\n-\n-              and then\n-                (No (Alignment_Clause (Typ))\n-                   or else\n-                 Alignment (Typ) >= ((Len_Bits + System_Storage_Unit)\n-                                             / System_Storage_Unit))\n             then\n                --  We can use the modular type, it has the form:\n \n@@ -1193,6 +1183,14 @@ package body Exp_Pakd is\n                end if;\n \n                Install_PAT;\n+\n+               --  Propagate a given alignment to the modular type. This can\n+               --  cause it to be under-aligned, but that's OK.\n+\n+               if Present (Alignment_Clause (Typ)) then\n+                  Set_Alignment (PAT, Alignment (Typ));\n+               end if;\n+\n                return;\n             end if;\n          end if;"}, {"sha": "6da9ce4a0ae6a3f213f8a5ef8ce9d3061e9dc254", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -1593,6 +1593,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t   gnat_to_gnu_type\n \t\t\t   (Original_Array_Type (gnat_entity)));\n \n+      /* We have to handle clauses that under-align the type specially.  */\n+      if ((Present (Alignment_Clause (gnat_entity))\n+\t   || (Is_Packed_Array_Type (gnat_entity)\n+\t       && Present\n+\t\t  (Alignment_Clause (Original_Array_Type (gnat_entity)))))\n+\t  && UI_Is_In_Int_Range (Alignment (gnat_entity)))\n+\t{\n+\t  align = UI_To_Int (Alignment (gnat_entity)) * BITS_PER_UNIT;\n+\t  if (align >= TYPE_ALIGN (gnu_type))\n+\t    align = 0;\n+\t}\n+\n       /* If the type we are dealing with represents a bit-packed array,\n \t we need to have the bits left justified on big-endian targets\n \t and right justified on little-endian targets.  We also need to\n@@ -1605,39 +1617,47 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t{\n \t  tree gnu_field_type, gnu_field;\n \n-\t  /* Set the RM size before wrapping up the type.  */\n+\t  /* Set the RM size before wrapping up the original type.  */\n \t  SET_TYPE_RM_SIZE (gnu_type,\n \t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n+\n+\t  /* Create a stripped-down declaration, mainly for debugging.  */\n+\t  create_type_decl (gnu_entity_name, gnu_type, NULL, true,\n+\t\t\t    debug_info_p, gnat_entity);\n+\n+\t  /* Now save it and build the enclosing record type.  */\n \t  gnu_field_type = gnu_type;\n \n \t  gnu_type = make_node (RECORD_TYPE);\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"JM\");\n-\n-\t  /* Propagate the alignment of the modular type to the record.\n-\t     This means that bit-packed arrays have \"ceil\" alignment for\n-\t     their size, which may seem counter-intuitive but makes it\n-\t     possible to easily overlay them on modular types.  */\n-\t  TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_field_type);\n \t  TYPE_PACKED (gnu_type) = 1;\n+\t  TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_field_type);\n+\t  TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_field_type);\n+\t  SET_TYPE_ADA_SIZE (gnu_type, TYPE_RM_SIZE (gnu_field_type));\n+\n+\t  /* Propagate the alignment of the modular type to the record type,\n+\t     unless there is an alignment clause that under-aligns the type.\n+\t     This means that bit-packed arrays are given \"ceil\" alignment for\n+\t     their size by default, which may seem counter-intuitive but makes\n+\t     it possible to overlay them on modular types easily.  */\n+\t  TYPE_ALIGN (gnu_type)\n+\t    = align > 0 ? align : TYPE_ALIGN (gnu_field_type);\n \n-\t  /* Create a stripped-down declaration of the original type, mainly\n-\t     for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_field_type, NULL, true,\n-\t\t\t    debug_info_p, gnat_entity);\n+\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n \t     bitfield.  */\n \t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n-\t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n+\t\t\t\t\t gnu_field_type, gnu_type, 1,\n+\t\t\t\t\t NULL_TREE, bitsize_zero_node, 0);\n \n \t  /* Do not emit debug info until after the parallel type is added.  */\n-\t  finish_record_type (gnu_type, gnu_field, 0, false);\n+\t  finish_record_type (gnu_type, gnu_field, 2, false);\n+\t  compute_record_mode (gnu_type);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \n-\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n-\n \t  if (debug_info_p)\n \t    {\n \t      /* Make the original array type a parallel type.  */\n@@ -1653,45 +1673,42 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* If the type we are dealing with has got a smaller alignment than the\n \t natural one, we need to wrap it up in a record type and under-align\n \t the latter.  We reuse the padding machinery for this purpose.  */\n-      else if (Present (Alignment_Clause (gnat_entity))\n-\t       && UI_Is_In_Int_Range (Alignment (gnat_entity))\n-\t       && (align = UI_To_Int (Alignment (gnat_entity)) * BITS_PER_UNIT)\n-\t       && align < TYPE_ALIGN (gnu_type))\n+      else if (align > 0)\n \t{\n \t  tree gnu_field_type, gnu_field;\n \n \t  /* Set the RM size before wrapping up the type.  */\n \t  SET_TYPE_RM_SIZE (gnu_type,\n \t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n+\n+\t  /* Create a stripped-down declaration, mainly for debugging.  */\n+\t  create_type_decl (gnu_entity_name, gnu_type, NULL, true,\n+\t\t\t    debug_info_p, gnat_entity);\n+\n+\t  /* Now save it and build the enclosing record type.  */\n \t  gnu_field_type = gnu_type;\n \n \t  gnu_type = make_node (RECORD_TYPE);\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"PAD\");\n-\n-\t  TYPE_ALIGN (gnu_type) = align;\n \t  TYPE_PACKED (gnu_type) = 1;\n-\n-\t  /* Create a stripped-down declaration of the original type, mainly\n-\t     for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_field_type, NULL, true,\n-\t\t\t    debug_info_p, gnat_entity);\n+\t  TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_field_type);\n+\t  TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_field_type);\n+\t  SET_TYPE_ADA_SIZE (gnu_type, TYPE_RM_SIZE (gnu_field_type));\n+\t  TYPE_ALIGN (gnu_type) = align;\n+\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n \t     bitfield.  */\n-\t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n-\t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n+\t  gnu_field = create_field_decl (get_identifier (\"F\"),\n+\t\t\t\t\t gnu_field_type, gnu_type, 1,\n+\t\t\t\t\t NULL_TREE, bitsize_zero_node, 0);\n \n-\t  finish_record_type (gnu_type, gnu_field, 0, debug_info_p);\n+\t  finish_record_type (gnu_type, gnu_field, 2, debug_info_p);\n+\t  compute_record_mode (gnu_type);\n \t  TYPE_PADDING_P (gnu_type) = 1;\n-\n-\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}\n \n-      /* Otherwise reset the alignment lest we computed it above.  */\n-      else\n-\talign = 0;\n-\n       break;\n \n     case E_Floating_Point_Type:"}, {"sha": "ecb0495356a7e7d98a5b9b3c8bb7aa7ad217c3a7", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -595,10 +595,10 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n   if (rep_level > 0)\n     {\n       TYPE_ALIGN (record_type) = MAX (BITS_PER_UNIT, TYPE_ALIGN (record_type));\n-      SET_TYPE_MODE (record_type, BLKmode);\n \n       if (!had_size_unit)\n \tTYPE_SIZE_UNIT (record_type) = size_zero_node;\n+\n       if (!had_size)\n \tTYPE_SIZE (record_type) = bitsize_zero_node;\n "}, {"sha": "5f8db2c80a3a6f45af8abb71db96b504e0d56ed4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -1,3 +1,9 @@\n+2010-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/bit_packed_array.ad[sb]: Rename into...\n+\t* gnat.dg/bit_packed_array1.ad[sb]: ...this.\n+\t* gnat.dg/bit_packed_array4.ad[sb]: New test.\n+\n 2010-04-07  Jie Zhang  <jie@codesourcery.com>\n \n \tPR c++/42556"}, {"sha": "10fd2921f542b7ac977e244dd8792da520ee4869", "filename": "gcc/testsuite/gnat.dg/bit_packed_array1.adb", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.adb?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -3,7 +3,7 @@\n \n -- { dg-do compile }\n \n-package body Bit_Packed_Array is\n+package body Bit_Packed_Array1 is\n \n   procedure Generate_Callforward is\n       Compiler_Crash : String :=\n@@ -13,4 +13,4 @@ package body Bit_Packed_Array is\n       null;\n   end Generate_Callforward;\n \n-end Bit_Packed_Array;\n+end Bit_Packed_Array1;", "previous_filename": "gcc/testsuite/gnat.dg/bit_packed_array.adb"}, {"sha": "a0d5ab7a8df73aad7b8a7a5f520aedd45722f193", "filename": "gcc/testsuite/gnat.dg/bit_packed_array1.ads", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array1.ads?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -1,13 +1,14 @@\n with Interfaces;\n \n-package Bit_Packed_Array is\n+package Bit_Packed_Array1 is\n \n    type laser_illuminator_code_group_t is (zero, one);\n    pragma Convention (C, laser_illuminator_code_group_t);\n \n    subtype lic_array_index_t is Interfaces.Unsigned_8 range 0 .. 3;\n \n-   type lic_array_t is array (lic_array_index_t) of laser_illuminator_code_group_t;\n+   type lic_array_t is array (lic_array_index_t)\n+    of laser_illuminator_code_group_t;\n    pragma Convention (C, lic_array_t);\n \n    type Eighty_Bytes_T is array (1 .. 80) of Interfaces.Unsigned_8;\n@@ -30,4 +31,4 @@ package Bit_Packed_Array is\n \n    procedure Generate_Callforward;\n \n-end Bit_Packed_Array; \n+end Bit_Packed_Array1;", "previous_filename": "gcc/testsuite/gnat.dg/bit_packed_array.ads"}, {"sha": "35088a7eba46b659657f005103a15c3db6699723", "filename": "gcc/testsuite/gnat.dg/bit_packed_array4.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.adb?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+package body Bit_Packed_Array4  is\n+\n+   procedure Process (M : Message_Type) is\n+      D : Data_Type;\n+   begin\n+      D := M.Data;\n+   end;\n+\n+end Bit_Packed_Array4;"}, {"sha": "7713e8f3e5b73239914bea5ba16b3ace762ecb8f", "filename": "gcc/testsuite/gnat.dg/bit_packed_array4.ads", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1fa9126ab0782c68bd92431a7bb93de0931fc3d/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array4.ads?ref=b1fa9126ab0782c68bd92431a7bb93de0931fc3d", "patch": "@@ -0,0 +1,18 @@\n+package Bit_Packed_Array4 is\n+\n+   type Data_Type is array (1 .. 39) of Boolean;\n+   pragma Pack (Data_Type);\n+   for Data_Type'Alignment use 1;\n+\n+   type Message_Type is record\n+      Valid : Boolean;\n+      Data  : Data_Type;\n+   end record;\n+   for Message_Type use record\n+      Valid at 0 range 0 .. 0;\n+      Data  at 0 range 1 .. 39;\n+   end record;\n+\n+   procedure Process (M : Message_Type);\n+\n+end Bit_Packed_Array4;"}]}