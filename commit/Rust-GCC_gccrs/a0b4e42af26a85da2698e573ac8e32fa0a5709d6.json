{"sha": "a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBiNGU0MmFmMjZhODVkYTI2OThlNTczYWM4ZTMyZmEwYTU3MDlkNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-08-25T09:50:48Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-08-25T09:52:06Z"}, "message": "middle-end: PR tree-optimization/21137: STRIP_NOPS avoids missed optimization.\n\nPR tree-optimization/21137 is now an old enhancement request pointing out\nthat an optimization I added back in 2006, to optimize \"((x>>31)&64) != 0\"\nas \"x < 0\", doesn't fire in the presence of unanticipated type conversions.\nThe fix is to call STRIP_NOPS at the appropriate point.\n\n2020-08-25  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR tree-optimization/21137\n\t* fold-const.c (fold_binary_loc) [NE_EXPR/EQ_EXPR]: Call\n\tSTRIP_NOPS when checking whether to simplify ((x>>C1)&C2) != 0.\n\ngcc/testsuite/ChangeLog\n\tPR tree-optimization/21137\n\t* gcc.dg/pr21137.c: New test.", "tree": {"sha": "596101b46ace339575d90d008a761964e7e71e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/596101b46ace339575d90d008a761964e7e71e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b4e42af26a85da2698e573ac8e32fa0a5709d6/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68e605c93d57c17f07edd50f7e1c80f9216befd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e605c93d57c17f07edd50f7e1c80f9216befd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e605c93d57c17f07edd50f7e1c80f9216befd2"}], "stats": {"total": 90, "additions": 59, "deletions": 31}, "files": [{"sha": "1f86163022573cc1ef175c8f94204af1c72e759a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b4e42af26a85da2698e573ac8e32fa0a5709d6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b4e42af26a85da2698e573ac8e32fa0a5709d6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "patch": "@@ -11609,45 +11609,53 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t C1 is a valid shift constant, and C2 is a power of two, i.e.\n \t a single bit.  */\n       if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == RSHIFT_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t     == INTEGER_CST\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n \t  && integer_zerop (arg1))\n \t{\n-\t  tree itype = TREE_TYPE (arg0);\n-\t  tree arg001 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 1);\n-\t  prec = TYPE_PRECISION (itype);\n-\n-\t  /* Check for a valid shift count.  */\n-\t  if (wi::ltu_p (wi::to_wide (arg001), prec))\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  STRIP_NOPS (arg00);\n+\t  if (TREE_CODE (arg00) == RSHIFT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (arg00, 1)) == INTEGER_CST)\n \t    {\n-\t      tree arg01 = TREE_OPERAND (arg0, 1);\n-\t      tree arg000 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t      unsigned HOST_WIDE_INT log2 = tree_log2 (arg01);\n-\t      /* If (C2 << C1) doesn't overflow, then ((X >> C1) & C2) != 0\n-\t\t can be rewritten as (X & (C2 << C1)) != 0.  */\n-\t      if ((log2 + TREE_INT_CST_LOW (arg001)) < prec)\n+\t      tree itype = TREE_TYPE (arg00);\n+\t      tree arg001 = TREE_OPERAND (arg00, 1);\n+\t      prec = TYPE_PRECISION (itype);\n+\n+\t      /* Check for a valid shift count.  */\n+\t      if (wi::ltu_p (wi::to_wide (arg001), prec))\n \t\t{\n-\t\t  tem = fold_build2_loc (loc, LSHIFT_EXPR, itype, arg01, arg001);\n-\t\t  tem = fold_build2_loc (loc, BIT_AND_EXPR, itype, arg000, tem);\n-\t\t  return fold_build2_loc (loc, code, type, tem,\n-\t\t\t\t\t  fold_convert_loc (loc, itype, arg1));\n-\t\t}\n-\t      /* Otherwise, for signed (arithmetic) shifts,\n-\t\t ((X >> C1) & C2) != 0 is rewritten as X < 0, and\n-\t\t ((X >> C1) & C2) == 0 is rewritten as X >= 0.  */\n-\t      else if (!TYPE_UNSIGNED (itype))\n-\t\treturn fold_build2_loc (loc, code == EQ_EXPR ? GE_EXPR : LT_EXPR, type,\n-\t\t\t\t    arg000, build_int_cst (itype, 0));\n-\t      /* Otherwise, of unsigned (logical) shifts,\n-\t\t ((X >> C1) & C2) != 0 is rewritten as (X,false), and\n-\t\t ((X >> C1) & C2) == 0 is rewritten as (X,true).  */\n-\t      else\n-\t\treturn omit_one_operand_loc (loc, type,\n+\t\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t\t  tree arg000 = TREE_OPERAND (arg00, 0);\n+\t\t  unsigned HOST_WIDE_INT log2 = tree_log2 (arg01);\n+\t\t  /* If (C2 << C1) doesn't overflow, then\n+\t\t     ((X >> C1) & C2) != 0 can be rewritten as\n+\t\t     (X & (C2 << C1)) != 0.  */\n+\t\t  if ((log2 + TREE_INT_CST_LOW (arg001)) < prec)\n+\t\t    {\n+\t\t      tem = fold_build2_loc (loc, LSHIFT_EXPR, itype,\n+\t\t\t\t\t     arg01, arg001);\n+\t\t      tem = fold_build2_loc (loc, BIT_AND_EXPR, itype,\n+\t\t\t\t\t     arg000, tem);\n+\t\t      return fold_build2_loc (loc, code, type, tem,\n+\t\t\t\tfold_convert_loc (loc, itype, arg1));\n+\t\t    }\n+\t\t  /* Otherwise, for signed (arithmetic) shifts,\n+\t\t     ((X >> C1) & C2) != 0 is rewritten as X < 0, and\n+\t\t     ((X >> C1) & C2) == 0 is rewritten as X >= 0.  */\n+\t\t  else if (!TYPE_UNSIGNED (itype))\n+\t\t    return fold_build2_loc (loc, code == EQ_EXPR ? GE_EXPR\n+\t\t\t\t\t\t\t\t : LT_EXPR,\n+\t\t\t\t\t    type, arg000,\n+\t\t\t\t\t    build_int_cst (itype, 0));\n+\t\t  /* Otherwise, of unsigned (logical) shifts,\n+\t\t     ((X >> C1) & C2) != 0 is rewritten as (X,false), and\n+\t\t     ((X >> C1) & C2) == 0 is rewritten as (X,true).  */\n+\t\t  else\n+\t\t    return omit_one_operand_loc (loc, type,\n \t\t\t\t\t code == EQ_EXPR ? integer_one_node\n \t\t\t\t\t\t\t : integer_zero_node,\n \t\t\t\t\t arg000);\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "6d73deaee6c0b69b26154f6676e5f5643edbb3e7", "filename": "gcc/testsuite/gcc.dg/pr21137.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b4e42af26a85da2698e573ac8e32fa0a5709d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21137.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b4e42af26a85da2698e573ac8e32fa0a5709d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21137.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr21137.c?ref=a0b4e42af26a85da2698e573ac8e32fa0a5709d6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void foo();\n+\n+void test5_1(int e)\n+{\n+  if ((e >> 31) & 64)\n+    foo();\n+}\n+\n+typedef int myint;\n+\n+void test5_2(myint e)\n+{\n+  if ((e >> 31) & 64)\n+    foo();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" < 0\" 2 \"optimized\" } } */"}]}