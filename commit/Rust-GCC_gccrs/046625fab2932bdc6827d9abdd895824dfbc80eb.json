{"sha": "046625fab2932bdc6827d9abdd895824dfbc80eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ2NjI1ZmFiMjkzMmJkYzY4MjdkOWFiZGQ4OTU4MjRkZmJjODBlYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-28T00:55:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-28T00:55:07Z"}, "message": "builtins.c (expand_builtin_copysign): New.\n\n        * builtins.c (expand_builtin_copysign): New.\n        (expand_builtin): Call it.\n        * genopinit.c (optabs): Add copysign_optab.\n        * optabs.c (init_optabs): Initialize it.\n        (expand_copysign): New.\n        * optabs.h (OTI_copysign, copysign_optab): New.\n        (expand_copysign): Declare.\n\n        * config/alpha/alpha.md (UNSPEC_COPYSIGN): New.\n        (copysignsf3, ncopysignsf3, copysigndf3, ncopysigndf3): New.\n\n        * config/i386/i386.c (ix86_build_signbit_mask): Split from ...\n        (ix86_expand_fp_absneg_operator): ... here.\n        (ix86_split_copysign): New.\n        * config/i386/i386-protos.h: Update.\n        * config/i386/i386.md (UNSPEC_COPYSIGN): New.\n        (copysignsf3, copysigndf3): New.\n\n        * config/ia64/ia64.md (UNSPEC_COPYSIGN): New.\n        (copysignsf3, ncopysignsf3): New.\n        (copysigndf3, ncopysigndf3): New.\n        (copysignxf3, ncopysignxf3): New.\n        * config/ia64/ia64.c (rtx_needs_barrier): Handle UNSPEC_COPYSIGN.\n\nFrom-SVN: r94357", "tree": {"sha": "3611918a36fd9acca7d65920e977e8e47fd831c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3611918a36fd9acca7d65920e977e8e47fd831c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/046625fab2932bdc6827d9abdd895824dfbc80eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046625fab2932bdc6827d9abdd895824dfbc80eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/046625fab2932bdc6827d9abdd895824dfbc80eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046625fab2932bdc6827d9abdd895824dfbc80eb/comments", "author": null, "committer": null, "parents": [{"sha": "17a7d6d75a9f752c68a64c1a4f1de8e11b8d3384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a7d6d75a9f752c68a64c1a4f1de8e11b8d3384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a7d6d75a9f752c68a64c1a4f1de8e11b8d3384"}], "stats": {"total": 547, "additions": 484, "deletions": 63}, "files": [{"sha": "469ebae808ececa8162a0740e800a0ac326fbaf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -1,3 +1,29 @@\n+2005-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (expand_builtin_copysign): New.\n+\t(expand_builtin): Call it.\n+\t* genopinit.c (optabs): Add copysign_optab.\n+\t* optabs.c (init_optabs): Initialize it.\n+\t(expand_copysign): New.\n+\t* optabs.h (OTI_copysign, copysign_optab): New.\n+\t(expand_copysign): Declare.\n+\n+\t* config/alpha/alpha.md (UNSPEC_COPYSIGN): New.\n+\t(copysignsf3, ncopysignsf3, copysigndf3, ncopysigndf3): New.\n+\n+\t* config/i386/i386.c (ix86_build_signbit_mask): Split from ...\n+\t(ix86_expand_fp_absneg_operator): ... here.\n+\t(ix86_split_copysign): New.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.md (UNSPEC_COPYSIGN): New.\n+\t(copysignsf3, copysigndf3): New.\n+\n+\t* config/ia64/ia64.md (UNSPEC_COPYSIGN): New.\n+\t(copysignsf3, ncopysignsf3): New.\n+\t(copysigndf3, ncopysigndf3): New.\n+\t(copysignxf3, ncopysignxf3): New.\n+\t* config/ia64/ia64.c (rtx_needs_barrier): Handle UNSPEC_COPYSIGN.\n+\n 2005-01-27  Arend Bayer  <arend.bayer@web.de>\n \t    Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "dada41ef84897b2a5e6576841d993ba7db61d8ce", "filename": "gcc/builtins.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -4436,6 +4436,29 @@ expand_builtin_fabs (tree arglist, rtx target, rtx subtarget)\n   return expand_abs (mode, op0, target, 0, safe_from_p (target, arg, 1));\n }\n \n+/* Expand a call to copysign, copysignf, or copysignl with arguments ARGLIST.\n+   Return NULL is a normal call should be emitted rather than expanding the\n+   function inline.  If convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing the operand.  */\n+\n+static rtx\n+expand_builtin_copysign (tree arglist, rtx target, rtx subtarget)\n+{\n+  rtx op0, op1;\n+  tree arg;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg = TREE_VALUE (arglist);\n+  op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n+\n+  arg = TREE_VALUE (TREE_CHAIN (arglist));\n+  op1 = expand_expr (arg, NULL, VOIDmode, 0);\n+\n+  return expand_copysign (op0, op1, target);\n+}\n+\n /* Create a new constant string literal and return a char* pointer to it.\n    The STRING_CST value is the LEN characters at STR.  */\n static tree\n@@ -5065,6 +5088,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n         return target;\n       break;\n \n+    case BUILT_IN_COPYSIGN:\n+    case BUILT_IN_COPYSIGNF:\n+    case BUILT_IN_COPYSIGNL:\n+      target = expand_builtin_copysign (arglist, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n       /* Just do a normal library call if we were unable to fold\n \t the values.  */\n     case BUILT_IN_CABS:"}, {"sha": "c643828acad54b0d853b5f3a8fe6b7a71932677f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -58,6 +58,7 @@\n    (UNSPEC_PERR\t\t26)\n    (UNSPEC_CTLZ\t\t27)\n    (UNSPEC_CTPOP\t28)\n+   (UNSPEC_COPYSIGN     29)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -2231,6 +2232,42 @@\n   [(const_int 0)]\n   \"alpha_split_tfmode_frobsign (operands, gen_xordi3); DONE;\")\n \n+(define_insn \"copysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"reg_or_0_operand\" \"fG\")\n+\t\t    (match_operand:SF 2 \"reg_or_0_operand\" \"fG\")]\n+\t\t   UNSPEC_COPYSIGN))]\n+  \"TARGET_FP\"\n+  \"cpys %R2,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"*ncopysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (unspec:SF [(match_operand:SF 1 \"reg_or_0_operand\" \"fG\")\n+\t\t\t    (match_operand:SF 2 \"reg_or_0_operand\" \"fG\")]\n+\t\t\t   UNSPEC_COPYSIGN)))]\n+  \"TARGET_FP\"\n+  \"cpysn %R2,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"copysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 1 \"reg_or_0_operand\" \"fG\")\n+\t\t    (match_operand:DF 2 \"reg_or_0_operand\" \"fG\")]\n+\t\t   UNSPEC_COPYSIGN))]\n+  \"TARGET_FP\"\n+  \"cpys %R2,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n+(define_insn \"*ncopysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (unspec:DF [(match_operand:DF 1 \"reg_or_0_operand\" \"fG\")\n+\t\t\t    (match_operand:DF 2 \"reg_or_0_operand\" \"fG\")]\n+\t\t\t   UNSPEC_COPYSIGN)))]\n+  \"TARGET_FP\"\n+  \"cpysn %R2,%R1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n+\n (define_insn \"*addsf_ieee\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(plus:SF (match_operand:SF 1 \"reg_or_0_operand\" \"%fG\")"}, {"sha": "fcbb822dd11cdc0d290f779fc50907c6e3c78b29", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -136,8 +136,10 @@ extern void ix86_expand_binary_operator (enum rtx_code,\n extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\trtx[]);\n+extern rtx ix86_build_signbit_mask (enum machine_mode, bool, bool);\n extern void ix86_expand_fp_absneg_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\t    rtx[]);\n+extern void ix86_split_copysign (rtx []);\n extern int ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern int ix86_match_ccmode (rtx, enum machine_mode);\n extern rtx ix86_expand_compare (enum rtx_code, rtx *, rtx *);"}, {"sha": "2bc334bd388878d54f07c8be2212ad640dc9bea8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 125, "deletions": 63, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -8000,6 +8000,56 @@ ix86_unary_operator_ok (enum rtx_code code ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n+/* A subroutine of ix86_expand_fp_absneg_operator and copysign expanders.\n+   Create a mask for the sign bit in MODE for an SSE register.  If VECT is\n+   true, then replicate the mask for all elements of the vector register.\n+   If INVERT is true, then create a mask excluding the sign bit.  */\n+\n+rtx\n+ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n+{\n+  enum machine_mode vec_mode;\n+  HOST_WIDE_INT hi, lo;\n+  int shift = 63;\n+  rtvec v;\n+  rtx mask;\n+\n+  /* Find the sign bit, sign extended to 2*HWI.  */\n+  if (mode == SFmode)\n+    lo = 0x80000000, hi = lo < 0;\n+  else if (HOST_BITS_PER_WIDE_INT >= 64)\n+    lo = (HOST_WIDE_INT)1 << shift, hi = -1;\n+  else\n+    lo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n+\n+  if (invert)\n+    lo = ~lo, hi = ~hi;\n+\n+  /* Force this value into the low part of a fp vector constant.  */\n+  mask = immed_double_const (lo, hi, mode == SFmode ? SImode : DImode);\n+  mask = gen_lowpart (mode, mask);\n+\n+  if (mode == SFmode)\n+    {\n+      if (vect)\n+\tv = gen_rtvec (4, mask, mask, mask, mask);\n+      else\n+\tv = gen_rtvec (4, mask, CONST0_RTX (SFmode),\n+\t\t       CONST0_RTX (SFmode), CONST0_RTX (SFmode));\n+      vec_mode = V4SFmode;\n+    }\n+  else\n+    {\n+      if (vect)\n+\tv = gen_rtvec (2, mask, mask);\n+      else\n+\tv = gen_rtvec (2, mask, CONST0_RTX (DFmode));\n+      vec_mode = V2DFmode;\n+    }\n+\n+  return force_reg (vec_mode, gen_rtx_CONST_VECTOR (vec_mode, v));\n+}\n+\n /* Generate code for floating point ABS or NEG.  */\n \n void\n@@ -8011,79 +8061,19 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, enum machine_mode mode,\n   bool use_sse = false;\n   bool vector_mode = VECTOR_MODE_P (mode);\n   enum machine_mode elt_mode = mode;\n-  enum machine_mode vec_mode = VOIDmode;\n \n   if (vector_mode)\n     {\n       elt_mode = GET_MODE_INNER (mode);\n-      vec_mode = mode;\n       use_sse = true;\n     }\n-  if (TARGET_SSE_MATH)\n-    {\n-      if (mode == SFmode)\n-\t{\n-\t  use_sse = true;\n-\t  vec_mode = V4SFmode;\n-\t}\n-      else if (mode == DFmode && TARGET_SSE2)\n-\t{\n-\t  use_sse = true;\n-\t  vec_mode = V2DFmode;\n-\t}\n-    }\n+  else if (TARGET_SSE_MATH)\n+    use_sse = SSE_REG_MODE_P (mode);\n \n   /* NEG and ABS performed with SSE use bitwise mask operations.\n      Create the appropriate mask now.  */\n   if (use_sse)\n-    {\n-      HOST_WIDE_INT hi, lo;\n-      int shift = 63;\n-      rtvec v;\n-\n-      /* Find the sign bit, sign extended to 2*HWI.  */\n-      if (elt_mode == SFmode)\n-        lo = 0x80000000, hi = lo < 0;\n-      else if (HOST_BITS_PER_WIDE_INT >= 64)\n-        lo = (HOST_WIDE_INT)1 << shift, hi = -1;\n-      else\n-        lo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n-\n-      /* If we're looking for the absolute value, then we want\n-\t the compliment.  */\n-      if (code == ABS)\n-        lo = ~lo, hi = ~hi;\n-\n-      /* Force this value into the low part of a fp vector constant.  */\n-      mask = immed_double_const (lo, hi, elt_mode == SFmode ? SImode : DImode);\n-      mask = gen_lowpart (elt_mode, mask);\n-\n-      switch (mode)\n-\t{\n-\tcase SFmode:\n-\t  v = gen_rtvec (4, mask, CONST0_RTX (SFmode),\n-\t\t\t CONST0_RTX (SFmode), CONST0_RTX (SFmode));\n-\t  break;\n-\n-\tcase DFmode:\n-\t  v = gen_rtvec (2, mask, CONST0_RTX (DFmode));\n-\t  break;\n-\n-\tcase V4SFmode:\n-\t  v = gen_rtvec (4, mask, mask, mask, mask);\n-\t  break;\n-\n-\tcase V4DFmode:\n-\t  v = gen_rtvec (2, mask, mask);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      mask = gen_rtx_CONST_VECTOR (vec_mode, v);\n-      mask = force_reg (vec_mode, mask);\n-    }\n+    mask = ix86_build_signbit_mask (elt_mode, vector_mode, code == ABS);\n   else\n     {\n       /* When not using SSE, we don't use the mask, but prefer to keep the\n@@ -8127,6 +8117,78 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, enum machine_mode mode,\n     emit_move_insn (operands[0], dst);\n }\n \n+/* Deconstruct a copysign operation into bit masks.  */\n+\n+void\n+ix86_split_copysign (rtx operands[])\n+{\n+  enum machine_mode mode, vmode;\n+  rtx dest, scratch, op0, op1, mask, nmask, x;\n+\n+  dest = operands[0];\n+  scratch = operands[1];\n+  op0 = operands[2];\n+  nmask = operands[3];\n+  op1 = operands[4];\n+  mask = operands[5];\n+\n+  mode = GET_MODE (dest);\n+  vmode = GET_MODE (mask);\n+\n+  if (rtx_equal_p (op0, op1))\n+    {\n+      /* Shouldn't happen often (it's useless, obviously), but when it does\n+\t we'd generate incorrect code if we continue below.  */\n+      emit_move_insn (dest, op0);\n+      return;\n+    }\n+\n+  if (REG_P (mask) && REGNO (dest) == REGNO (mask))\t/* alternative 0 */\n+    {\n+      gcc_assert (REGNO (op1) == REGNO (scratch));\n+\n+      x = gen_rtx_AND (vmode, scratch, mask);\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n+\n+      dest = mask;\n+      op0 = simplify_gen_subreg (vmode, op0, mode, 0);\n+      x = gen_rtx_NOT (vmode, dest);\n+      x = gen_rtx_AND (vmode, x, op0);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+  else\n+    {\n+      if (REGNO (op1) == REGNO (scratch))\t\t/* alternative 1,3 */\n+\t{\n+\t  x = gen_rtx_AND (vmode, scratch, mask);\n+\t}\n+      else\t\t\t\t\t\t/* alternative 2,4 */\n+\t{\n+          gcc_assert (REGNO (mask) == REGNO (scratch));\n+          op1 = simplify_gen_subreg (vmode, op1, mode, 0);\n+\t  x = gen_rtx_AND (vmode, scratch, op1);\n+\t}\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n+\n+      if (REGNO (op0) == REGNO (dest))\t\t\t/* alternative 1,2 */\n+\t{\n+\t  dest = simplify_gen_subreg (vmode, op0, mode, 0);\n+\t  x = gen_rtx_AND (vmode, dest, nmask);\n+\t}\n+      else\t\t\t\t\t\t/* alternative 3,4 */\n+\t{\n+          gcc_assert (REGNO (nmask) == REGNO (dest));\n+\t  dest = nmask;\n+\t  op0 = simplify_gen_subreg (vmode, op0, mode, 0);\n+\t  x = gen_rtx_AND (vmode, dest, op0);\n+\t}\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+\n+  x = gen_rtx_IOR (vmode, dest, scratch);\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+}\n+\n /* Return TRUE or FALSE depending on whether the first SET in INSN\n    has source and destination with matching CC modes, and that the\n    CC mode is at least as constrained as REQ_MODE.  */"}, {"sha": "d09a539ccb0ca6527d9ce8a2fa932f21bd40a778", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -145,6 +145,8 @@\n    (UNSPEC_REP\t\t\t75)\n \n    (UNSPEC_EH_RETURN\t\t76)\n+\n+   (UNSPEC_COPYSIGN\t\t100)\n   ])\n \n (define_constants\n@@ -9449,6 +9451,38 @@\n    && ix86_unary_operator_ok (GET_CODE (operands[3]), SFmode, operands)\"\n   \"#\")\n \n+(define_expand \"copysignsf3\"\n+  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t   (unspec:SF [(match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t       (match_dup 4)\n+\t\t\t       (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t\t       (match_dup 5)]\n+\t\t\t      UNSPEC_COPYSIGN))\n+\t      (clobber (match_scratch:V4SF 3 \"\"))])]\n+  \"TARGET_SSE_MATH\"\n+{\n+  operands[4] = ix86_build_signbit_mask (SFmode, 0, 1);\n+  operands[5] = ix86_build_signbit_mask (SFmode, 0, 0);\n+})\n+\n+(define_insn_and_split \"*copysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\"          \"=x, x, x, x,x\")\n+\t(unspec:SF\n+\t  [(match_operand:SF 2 \"register_operand\"       \" x, 0, 0, x,x\")\n+\t   (match_operand:V4SF 3 \"nonimmediate_operand\" \" X,xm,xm, 0,0\")\n+\t   (match_operand:SF 4 \"register_operand\"       \" 1, 1, x, 1,x\")\n+\t   (match_operand:V4SF 5 \"nonimmediate_operand\" \" 0,xm, 1,xm,1\")]\n+\t  UNSPEC_COPYSIGN))\n+   (clobber (match_scratch:V4SF 1\t\t\t\"=x, x, x, x,x\"))]\n+  \"TARGET_SSE_MATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  ix86_split_copysign (operands);\n+  DONE;\n+})\n+\n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n@@ -9491,6 +9525,38 @@\n    && ix86_unary_operator_ok (GET_CODE (operands[3]), DFmode, operands)\"\n   \"#\")\n \n+(define_expand \"copysigndf3\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t   (unspec:DF [(match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t       (match_dup 4)\n+\t\t\t       (match_operand:DF 2 \"register_operand\" \"\")\n+\t\t\t       (match_dup 5)]\n+\t\t\t      UNSPEC_COPYSIGN))\n+\t      (clobber (match_scratch:V2DF 3 \"\"))])]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+{\n+  operands[4] = ix86_build_signbit_mask (DFmode, 0, 1);\n+  operands[5] = ix86_build_signbit_mask (DFmode, 0, 0);\n+})\n+\n+(define_insn_and_split \"*copysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\"          \"=x, x, x, x,x\")\n+\t(unspec:DF\n+\t  [(match_operand:DF 2 \"register_operand\"       \" x, 0, 0, x,x\")\n+\t   (match_operand:V2DF 3 \"nonimmediate_operand\" \" X,xm,xm, 0,0\")\n+\t   (match_operand:DF 4 \"register_operand\"       \" 1, 1, x, 1,x\")\n+\t   (match_operand:V2DF 5 \"nonimmediate_operand\" \" 0,xm, 1,xm,1\")]\n+\t  UNSPEC_COPYSIGN))\n+   (clobber (match_scratch:V2DF 1\t\t\t\"=x, x, x, x,x\"))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  ix86_split_copysign (operands);\n+  DONE;\n+})\n+\n (define_expand \"negxf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n \t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]"}, {"sha": "4502a4600fb5959543f996008f7555630f09d968", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -5350,6 +5350,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \n \tcase UNSPEC_FR_RECIP_APPROX:\n \tcase UNSPEC_SHRP:\n+\tcase UNSPEC_COPYSIGN:\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);\n \t  break;"}, {"sha": "cb5dd10abc292a751fb3f93ea31c00834c58aa59", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -78,6 +78,7 @@\n    (UNSPEC_SETF_EXP             27)\n    (UNSPEC_FR_SQRT_RECIP_APPROX 28)\n    (UNSPEC_SHRP\t\t\t29)\n+   (UNSPEC_COPYSIGN\t\t30)\n   ])\n \n (define_constants\n@@ -2586,6 +2587,24 @@\n   \"fnegabs %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n+(define_insn \"copysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t   UNSPEC_COPYSIGN))]\n+  \"\"\n+  \"fmerge.s %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*ncopysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (unspec:SF [(match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t\t   UNSPEC_COPYSIGN)))]\n+  \"\"\n+  \"fmerge.ns %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n (define_insn \"sminsf3\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(smin:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n@@ -3000,6 +3019,24 @@\n   \"fnegabs %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n+(define_insn \"copysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t   UNSPEC_COPYSIGN))]\n+  \"\"\n+  \"fmerge.s %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*ncopysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (unspec:DF [(match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t\t   UNSPEC_COPYSIGN)))]\n+  \"\"\n+  \"fmerge.ns %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n (define_insn \"smindf3\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(smin:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n@@ -3556,6 +3593,24 @@\n   \"fnegabs %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n+(define_insn \"copysignxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(unspec:XF [(match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t   UNSPEC_COPYSIGN))]\n+  \"\"\n+  \"fmerge.s %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n+(define_insn \"*ncopysignxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(neg:XF (unspec:XF [(match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t\t   UNSPEC_COPYSIGN)))]\n+  \"\"\n+  \"fmerge.ns %0 = %F2, %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")])\n+\n (define_insn \"sminxf3\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n \t(smin:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")"}, {"sha": "f56f13c9a01bcc91dbb12e11535d64badaa7d967", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -116,6 +116,7 @@ static const char * const optabs[] =\n   \"absv_optab->handlers[$A].insn_code =\\n\\\n     abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$F$a2$)\",\n   \"absv_optab->handlers[$A].insn_code = CODE_FOR_$(absv$I$a2$)\",\n+  \"copysign_optab->handlers[$A].insn_code = CODE_FOR_$(copysign$F$a3$)\",\n   \"sqrt_optab->handlers[$A].insn_code = CODE_FOR_$(sqrt$a2$)\",\n   \"floor_optab->handlers[$A].insn_code = CODE_FOR_$(floor$a2$)\",\n   \"ceil_optab->handlers[$A].insn_code = CODE_FOR_$(ceil$a2$)\","}, {"sha": "d92cc907868b3c5c0d7ad209153e74333aeedf44", "filename": "gcc/optabs.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -2631,6 +2631,90 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n   OK_DEFER_POP;\n   return target;\n }\n+\n+/* Expand the C99 copysign operation.  OP0 and OP1 must be the same \n+   scalar floating point mode.  Return NULL if we do not know how to\n+   expand the operation inline.  */\n+\n+rtx\n+expand_copysign (rtx op0, rtx op1, rtx target)\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+  const struct real_format *fmt;\n+  enum machine_mode imode;\n+  int bitpos;\n+  HOST_WIDE_INT hi, lo;\n+  rtx last, temp;\n+\n+  gcc_assert (SCALAR_FLOAT_MODE_P (mode));\n+  gcc_assert (GET_MODE (op1) == mode);\n+\n+  /* First try to do it with a special instruction.  */\n+  temp = expand_binop (mode, copysign_optab, op0, op1,\n+\t\t       target, 0, OPTAB_DIRECT);\n+  if (temp)\n+    return temp;\n+\n+  /* Otherwise, use bit operations to move the sign from one to the other.  */\n+  if (GET_MODE_BITSIZE (mode) > 2 * HOST_BITS_PER_WIDE_INT)\n+    return NULL_RTX;\n+\n+  imode = int_mode_for_mode (mode);\n+  if (imode == BLKmode)\n+    return NULL_RTX;\n+\n+  fmt = REAL_MODE_FORMAT (mode);\n+  bitpos = (fmt != 0) ? fmt->signbit : -1;\n+  if (bitpos < 0)\n+    return NULL_RTX;\n+\n+  last = get_last_insn ();\n+\n+  /* Handle targets with different FP word orders.  */\n+  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    {\n+      int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+      int word = nwords - (bitpos / BITS_PER_WORD) - 1;\n+      bitpos = word * BITS_PER_WORD + bitpos % BITS_PER_WORD;\n+    }\n+\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+    {\n+      hi = 0;\n+      lo = (HOST_WIDE_INT) 1 << bitpos;\n+    }\n+  else\n+    {\n+      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n+      lo = 0;\n+    }\n+\n+  op0 = expand_binop (imode, and_optab,\n+\t\t      gen_lowpart (imode, op0),\n+\t\t      immed_double_const (~lo, ~hi, imode),\n+\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  op1 = expand_binop (imode, and_optab,\n+\t\t      gen_lowpart (imode, op1),\n+\t\t      immed_double_const (lo, hi, imode),\n+\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  if (op0 && op1)\n+    {\n+      target = expand_binop (imode, ior_optab, op0, op1, NULL,\n+\t\t\t     1, OPTAB_LIB_WIDEN);\n+      if (target)\n+\t{\n+\t  target = force_reg (imode, target);\n+\t  target = gen_lowpart (mode, target);\n+\t}\n+    }\n+  else\n+    target = NULL_RTX;\n+\n+  if (!target)\n+    delete_insns_since (last);\n+\n+  return target;\n+}\n \f\n /* Generate an instruction whose insn-code is INSN_CODE,\n    with two operands: an output TARGET and an input OP0.\n@@ -4776,6 +4860,8 @@ init_optabs (void)\n   log1p_optab = init_optab (UNKNOWN);\n   tan_optab = init_optab (UNKNOWN);\n   atan_optab = init_optab (UNKNOWN);\n+  copysign_optab = init_optab (UNKNOWN);\n+\n   strlen_optab = init_optab (UNKNOWN);\n   cbranch_optab = init_optab (UNKNOWN);\n   cmov_optab = init_optab (UNKNOWN);"}, {"sha": "a378a963c729f761cef8b436e136b4e6d5172a80", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -193,6 +193,8 @@ enum optab_index\n   OTI_tan,\n   /* Inverse tangent */\n   OTI_atan,\n+  /* Copy sign */\n+  OTI_copysign,\n \n   /* Compare insn; two operands.  */\n   OTI_cmp,\n@@ -311,6 +313,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define rint_optab (optab_table[OTI_rint])\n #define tan_optab (optab_table[OTI_tan])\n #define atan_optab (optab_table[OTI_atan])\n+#define copysign_optab (optab_table[OTI_copysign])\n \n #define cmp_optab (optab_table[OTI_cmp])\n #define ucmp_optab (optab_table[OTI_ucmp])\n@@ -450,6 +453,9 @@ extern rtx expand_unop (enum machine_mode, optab, rtx, rtx, int);\n extern rtx expand_abs_nojump (enum machine_mode, rtx, rtx, int);\n extern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);\n \n+/* Expand the copysign operation.  */\n+extern rtx expand_copysign (rtx, rtx, rtx);\n+\n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */\n extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);"}, {"sha": "3197d2e813b3ab72a26f10a76e60182b4d388f52", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/copysign1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046625fab2932bdc6827d9abdd895824dfbc80eb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fcopysign1.c?ref=046625fab2932bdc6827d9abdd895824dfbc80eb", "patch": "@@ -0,0 +1,48 @@\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define TEST(TYPE, EXT)\t\t\t\t\t\t\\\n+TYPE c##EXT (TYPE x, TYPE y)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  return __builtin_copysign##EXT (x, y);\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+struct D##EXT { TYPE x, y, z; };\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+static const struct D##EXT T##EXT[] = {\t\t\t\t\\\n+  { 1.0, 2.0, 1.0 },\t\t\t\t\t\t\\\n+  { 1.0, -2.0, -1.0 },\t\t\t\t\t\t\\\n+  { -1.0, -2.0, -1.0 },\t\t\t\t\t\t\\\n+  { 0.0, -2.0, -0.0 },\t\t\t\t\t\t\\\n+  { -0.0, -2.0, -0.0 },\t\t\t\t\t\t\\\n+  { -0.0, 2.0, 0.0 },\t\t\t\t\t\t\\\n+  { __builtin_inf##EXT (), -0.0, -__builtin_inf##EXT () },\t\\\n+  { -__builtin_nan##EXT (\"\"), __builtin_inf##EXT (),\t\t\\\n+    __builtin_nan##EXT (\"\") }\t\t\t\t\t\\\n+};\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+void test##EXT (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int i, n = sizeof (T##EXT) / sizeof (T##EXT[0]);\t\t\\\n+  TYPE r;\t\t\t\t\t\t\t\\\n+  /* Make sure to avoid comparing unused bits in the type.  */\t\\\n+  memset (&r, 0, sizeof r);\t\t\t\t\t\\\n+  for (i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      r = c##EXT (T##EXT[i].x, T##EXT[i].y);\t\t\t\\\n+      if (memcmp (&r, &T##EXT[i].z, sizeof r) != 0)\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+TEST(float, f)\n+TEST(double, )\n+TEST(long double, l)\n+\n+int main()\n+{\n+  testf();\n+  test();\n+  testl();\n+  return 0;\n+}"}]}