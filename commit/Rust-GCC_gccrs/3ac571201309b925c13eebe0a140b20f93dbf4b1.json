{"sha": "3ac571201309b925c13eebe0a140b20f93dbf4b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjNTcxMjAxMzA5YjkyNWMxM2VlYmUwYTE0MGIyMGY5M2RiZjRiMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-10-06T16:57:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-10-06T16:57:27Z"}, "message": "re PR tree-optimization/29330 (-O -ftree-loop-linear   -->  virtual memory exhausted)\n\n\tPR tree-optimization/29330\n\t* tree-data-ref.c (free_data_ref): Use DR_FREE_ACCESS_FNS macro.\n\t(initialize_data_dependence_relation): Clear DDR_LOOP_NEST pointer\n\ton newly allocated ddrs.\n\t(find_loop_nest_1, find_loop_nest): Change LOOP_NEST to a pointer\n\tto VEC (loop_p, heap) pointer.\n\t(compute_data_dependences_for_loop): Adjust caller.\n\t(free_dependence_relations): Free DDR_LOOP_NEST.\n\n\t* tree-loop-linear.c (linear_transform_loops): Don't forget to\n\tfree DEPENDENCE_RELATIONS and DATAREFS.\n\n\t* gcc.dg/pr29330.c: New test.\n\nFrom-SVN: r117509", "tree": {"sha": "ac2555c908e09e415f6469a5dbdd8f4a4c0500b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac2555c908e09e415f6469a5dbdd8f4a4c0500b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac571201309b925c13eebe0a140b20f93dbf4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac571201309b925c13eebe0a140b20f93dbf4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac571201309b925c13eebe0a140b20f93dbf4b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac571201309b925c13eebe0a140b20f93dbf4b1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c66475078ce85978489b9da5a19ebf21697f2b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66475078ce85978489b9da5a19ebf21697f2b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66475078ce85978489b9da5a19ebf21697f2b0d"}], "stats": {"total": 70, "additions": 55, "deletions": 15}, "files": [{"sha": "1e4b928d682b54c9c0fc35d5ea2154adc8171c9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ac571201309b925c13eebe0a140b20f93dbf4b1", "patch": "@@ -1,5 +1,17 @@\n 2006-10-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/29330\n+\t* tree-data-ref.c (free_data_ref): Use DR_FREE_ACCESS_FNS macro.\n+\t(initialize_data_dependence_relation): Clear DDR_LOOP_NEST pointer\n+\ton newly allocated ddrs.\n+\t(find_loop_nest_1, find_loop_nest): Change LOOP_NEST to a pointer\n+\tto VEC (loop_p, heap) pointer.\n+\t(compute_data_dependences_for_loop): Adjust caller.\n+\t(free_dependence_relations): Free DDR_LOOP_NEST.\n+\n+\t* tree-loop-linear.c (linear_transform_loops): Don't forget to\n+\tfree DEPENDENCE_RELATIONS and DATAREFS.\n+\n \tPR target/28924\n \t* builtins.c (expand_builtin_sync_operation,\n \texpand_builtin_compare_and_swap, expand_builtin_lock_test_and_set):"}, {"sha": "dad477eeee3c4bc70e243616ea0a8dc2e0c2c519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ac571201309b925c13eebe0a140b20f93dbf4b1", "patch": "@@ -1,5 +1,8 @@\n 2006-10-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/29330\n+\t* gcc.dg/pr29330.c: New test.\n+\n \tPR target/28924\n \t* gcc.c-torture/compile/20061005-1.c: New test.\n "}, {"sha": "e673b2166301d91b77e6e1366ac2a2003cc97881", "filename": "gcc/testsuite/gcc.dg/pr29330.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29330.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29330.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr29330.c?ref=3ac571201309b925c13eebe0a140b20f93dbf4b1", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/29330 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ftree-loop-linear\" } */\n+\n+int buf[2][2][2][2];\n+\n+void\n+f (void)\n+{\n+  for (int a = 0; a < 2; ++a)\n+    for (int b = 0; b < 2; ++b)\n+      for (int c = 0; c < 2; ++c)\n+\tfor (int d = 0; d < 2; ++d)\n+\t  buf[a][b][c][d] = 0;\n+}"}, {"sha": "2e47a25ac9094b24f3f9a8562d9bfde5ce87f065", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3ac571201309b925c13eebe0a140b20f93dbf4b1", "patch": "@@ -1913,11 +1913,7 @@ analyze_offset (tree offset, tree *invariant, tree *constant)\n static void\n free_data_ref (data_reference_p dr)\n {\n-  if (DR_TYPE(dr) == ARRAY_REF_TYPE)\n-    VEC_free (tree, heap, dr->object_info.access_fns);\n-  else\n-    VEC_free (tree, heap, dr->first_location.access_fns);\n-\n+  DR_FREE_ACCESS_FNS (dr);\n   free (dr);\n }\n \n@@ -2171,6 +2167,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n   res = XNEW (struct data_dependence_relation);\n   DDR_A (res) = a;\n   DDR_B (res) = b;\n+  DDR_LOOP_NEST (res) = NULL;\n \n   if (a == NULL || b == NULL)\n     {\n@@ -4205,7 +4202,7 @@ find_data_references_in_loop (struct loop *loop,\n /* Recursive helper function.  */\n \n static bool\n-find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n+find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n {\n   /* Inner loops of the nest should not contain siblings.  Example:\n      when there are two consecutive loops,\n@@ -4224,7 +4221,7 @@ find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n   if (loop->next)\n     return false;\n \n-  VEC_safe_push (loop_p, heap, loop_nest, loop);\n+  VEC_safe_push (loop_p, heap, *loop_nest, loop);\n   if (loop->inner)\n     return find_loop_nest_1 (loop->inner, loop_nest);\n   return true;\n@@ -4236,9 +4233,9 @@ find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n    appear in the classic distance vector.  */\n \n static bool\n-find_loop_nest (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n+find_loop_nest (struct loop *loop, VEC (loop_p, heap) **loop_nest)\n {\n-  VEC_safe_push (loop_p, heap, loop_nest, loop);\n+  VEC_safe_push (loop_p, heap, *loop_nest, loop);\n   if (loop->inner)\n     return find_loop_nest_1 (loop->inner, loop_nest);\n   return true;\n@@ -4265,7 +4262,7 @@ compute_data_dependences_for_loop (struct loop *loop,\n      is not computable, give up without spending time to compute other\n      dependences.  */\n   if (!loop_nest\n-      || !find_loop_nest (loop_nest, vloops)\n+      || !find_loop_nest (loop_nest, &vloops)\n       || find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n     {\n       struct data_dependence_relation *ddr;\n@@ -4435,10 +4432,22 @@ free_dependence_relations (VEC (ddr_p, heap) *dependence_relations)\n {\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n+  VEC (loop_p, heap) *loop_nest = NULL;\n \n   for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n-    free_dependence_relation (ddr);\n+    {\n+      if (ddr == NULL)\n+\tcontinue;\n+      if (loop_nest == NULL)\n+\tloop_nest = DDR_LOOP_NEST (ddr);\n+      else\n+\tgcc_assert (DDR_LOOP_NEST (ddr) == NULL\n+\t\t    || DDR_LOOP_NEST (ddr) == loop_nest);\n+      free_dependence_relation (ddr);\n+    }\n \n+  if (loop_nest)\n+    VEC_free (loop_p, heap, loop_nest);\n   VEC_free (ddr_p, heap, dependence_relations);\n }\n "}, {"sha": "2840e9be4b71b4858aaa96e953f82a2e02e0b90c", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac571201309b925c13eebe0a140b20f93dbf4b1/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=3ac571201309b925c13eebe0a140b20f93dbf4b1", "patch": "@@ -308,23 +308,23 @@ linear_transform_loops (struct loops *loops)\n \t{\n \t  if (dump_file)\n \t   fprintf (dump_file, \"Won't transform loop. Optimal transform is the identity transform\\n\");\n-\t  continue;\n+\t  goto free_and_continue;\n \t}\n \n       /* Check whether the transformation is legal.  */\n       if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Can't transform loop, transform is illegal:\\n\");\n-\t  continue;\n+\t  goto free_and_continue;\n \t}\n \n       before = gcc_loopnest_to_lambda_loopnest (loops, loop_nest, &oldivs,\n \t\t\t\t\t\t&invariants);\n \n       if (!before)\n-\tcontinue;\n-            \n+\tgoto free_and_continue;\n+\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Before:\\n\");\n@@ -346,6 +346,7 @@ linear_transform_loops (struct loops *loops)\n       if (dump_file)\n \tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n \n+    free_and_continue:\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }"}]}