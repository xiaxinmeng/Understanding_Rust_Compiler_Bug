{"sha": "d537b2ebb028550ea757435150937003fa9fe30a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzN2IyZWJiMDI4NTUwZWE3NTc0MzUxNTA5MzcwMDNmYTlmZTMwYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-02-09T02:36:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-02-09T02:36:33Z"}, "message": "re PR tree-optimization/21417 (Missed jump threading opportunity on trees)\n\n\n\tPR tree-optimization/21417\n\t* tree-ssa-threadedge.c (thread_across_edge): Reject threading\n\tacross a backedge if the control statement at the end of the\n\tblock is data dependent on other statements in the same block.\n\t(record_temporary_equivalences_from_stmts): Remove over-conservative\n\ttest for threading across backedges.\n\n\t* gcc.dg/tree-ssa/pr21417.c: New test.\n\nFrom-SVN: r110785", "tree": {"sha": "ba679982772c0b010e098d2e80744d59576e9883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba679982772c0b010e098d2e80744d59576e9883"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d537b2ebb028550ea757435150937003fa9fe30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d537b2ebb028550ea757435150937003fa9fe30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d537b2ebb028550ea757435150937003fa9fe30a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d537b2ebb028550ea757435150937003fa9fe30a/comments", "author": null, "committer": null, "parents": [{"sha": "0a180c0ee8779e656fd59c604a4a4443e242a7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a180c0ee8779e656fd59c604a4a4443e242a7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a180c0ee8779e656fd59c604a4a4443e242a7f7"}], "stats": {"total": 95, "additions": 86, "deletions": 9}, "files": [{"sha": "9aef9b8a0092c8566877292a169cb9b5b9196076", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d537b2ebb028550ea757435150937003fa9fe30a", "patch": "@@ -1,5 +1,12 @@\n 2006-02-08  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/21417\n+\t* tree-ssa-threadedge.c (thread_across_edge): Reject threading\n+\tacross a backedge if the control statement at the end of the\n+\tblock is data dependent on other statements in the same block.\n+\t(record_temporary_equivalences_from_stmts): Remove over-conservative\n+\ttest for threading across backedges.\n+\n \t* tree-ssa-dce.c (remove_dead_statement): When removing a dead\n \tcontrol statement, handle all three special cases in the same\n \tmanner as they all have the same desired solution.  No longer"}, {"sha": "ad136b3aeb194f4e9003c7abbf581b46173d4e3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d537b2ebb028550ea757435150937003fa9fe30a", "patch": "@@ -1,3 +1,7 @@\n+2006-02-08  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/pr21417.c: New test.\n+\n 2006-02-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* lib/scantree.exp (scan-tree-dump, scan-tree-dump-times,"}, {"sha": "e6320071daf1db67c06768d343b97bd542a9e2ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21417.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c?ref=d537b2ebb028550ea757435150937003fa9fe30a", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom3-details\" } */\n+\n+struct tree_common \n+{ \n+  int code; \n+}; \n+union tree_node \n+{ \n+  struct tree_common common; \n+}; \n+typedef union tree_node *tree; \n+ \n+extern tree test (tree, int, int); \n+extern tree foo (void); \n+extern void abort (void) __attribute__ ((__noreturn__)); \n+ \n+tree \n+test (tree expr, int t, int D17630) \n+{ \n+  int __i; \n+ \n+L0: \n+  if (expr->common.code != 142) goto L23; else goto L2; \n+ \n+L2: \n+  __i = 0; \n+  goto L10; \n+ \n+L10: \n+  __i = __i + 1; \n+  if (D17630 != __i) goto L8; else goto L19; \n+ \n+L8: \n+  if (t) goto L15; else goto L10; \n+ \n+L15: \n+  expr = foo (); \n+  if (expr->common.code != 142) goto L23; else goto L0; \n+ \n+L19: \n+  abort (); \n+ \n+L23: \n+  return expr; \n+} \n+\n+\n+/* We should thread the backedge to the top of the loop; ie we only\n+   execute the if (expr->common.code != 142) test once per loop\n+   iteration.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"dom3\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom3\" } } */\n+"}, {"sha": "b8d4b1301c635d3cc28c48b2058b400d60858bf5", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d537b2ebb028550ea757435150937003fa9fe30a/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=d537b2ebb028550ea757435150937003fa9fe30a", "patch": "@@ -231,15 +231,6 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (IS_EMPTY_STMT (stmt) || TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n-      /* Safely handle threading across loop backedges.  Only allowing\n-\t a conditional at the target of the backedge is over conservative,\n-\t but still allows us to capture the majority of the cases where\n-\t we can thread across a loop backedge.  */\n-      if ((e->flags & EDGE_DFS_BACK) != 0\n-\t  && TREE_CODE (stmt) != COND_EXPR\n-\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n-\treturn NULL;\n-\n       /* If the statement has volatile operands, then we assume we\n \t can not thread through this block.  This is overly\n \t conservative in some ways.  */\n@@ -496,6 +487,27 @@ thread_across_edge (tree dummy_cond,\n {\n   tree stmt;\n \n+  /* If E is a backedge, then we want to verify that the COND_EXPR,\n+     SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected\n+     by any statements in e->dest.  If it is affected, then it is not\n+     safe to thread this edge.  */\n+  if (e->flags & EDGE_DFS_BACK)\n+    {\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+      tree last = bsi_stmt (bsi_last (e->dest));\n+\n+      FOR_EACH_SSA_USE_OPERAND (use_p, last, iter, SSA_OP_USE | SSA_OP_VUSE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\n+          if (TREE_CODE (use) == SSA_NAME\n+\t      && TREE_CODE (SSA_NAME_DEF_STMT (use)) != PHI_NODE\n+\t      && bb_for_stmt (SSA_NAME_DEF_STMT (use)) == e->dest)\n+\t    goto fail;\n+\t}\n+    }\n+     \n   stmt_count = 0;\n \n   /* PHIs create temporary equivalences.  */"}]}