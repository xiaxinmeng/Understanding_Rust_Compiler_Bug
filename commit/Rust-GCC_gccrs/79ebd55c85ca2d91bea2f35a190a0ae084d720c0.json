{"sha": "79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllYmQ1NWM4NWNhMmQ5MWJlYTJmMzVhMTkwYTBhZTA4NGQ3MjBjMA==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-06-08T08:47:05Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2005-06-08T08:47:05Z"}, "message": "tree-data-ref.c (compute_estimated_nb_iterations, [...]): Fixed to use chrec_contains_undetermined to test the values of...\n\n\t* tree-data-ref.c (compute_estimated_nb_iterations,\n\tanalyze_array_indexes, compute_overlap_steps_for_affine_1_2,\n\tanalyze_subscript_affine_affine, find_data_references_in_loop):\n\tFixed to use chrec_contains_undetermined to test the values of\n\tloop->estimated_nb_iterations.\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop):\n\tCompute the estimation only when loop->estimated_nb_iterations\n\thas not yet been initialized.\n\t(convert_step_widening, scev_probably_wraps_p): Add a call to\n\testimate_numbers_of_iterations_loop.\n\t* tree-vrp.c (execute_vrp): Don't call estimate_numbers_of_iterations.\n\nFrom-SVN: r100749", "tree": {"sha": "89eb4489161f999fd07683ec4d1f769eb37fce8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89eb4489161f999fd07683ec4d1f769eb37fce8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216448c75d059b61f67ecd404aef3b6bfced8f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/216448c75d059b61f67ecd404aef3b6bfced8f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/216448c75d059b61f67ecd404aef3b6bfced8f88"}], "stats": {"total": 91, "additions": 56, "deletions": 35}, "files": [{"sha": "542b30d03fb08a4ec726e180b2cf7dd834abb02f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "patch": "@@ -1,3 +1,17 @@\n+2005-06-08  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-data-ref.c (compute_estimated_nb_iterations,\n+\tanalyze_array_indexes, compute_overlap_steps_for_affine_1_2,\n+\tanalyze_subscript_affine_affine, find_data_references_in_loop):\n+\tFixed to use chrec_contains_undetermined to test the values of\n+\tloop->estimated_nb_iterations.\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop):\n+\tCompute the estimation only when loop->estimated_nb_iterations\n+\thas not yet been initialized.\n+\t(convert_step_widening, scev_probably_wraps_p): Add a call to\n+\testimate_numbers_of_iterations_loop.\n+\t* tree-vrp.c (execute_vrp): Don't call estimate_numbers_of_iterations.\n+\n 2005-06-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR debug/21946"}, {"sha": "e4917df71af29f81d5e1ae9e95ffd0748289d520", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "patch": "@@ -447,32 +447,21 @@ dump_ddrs (FILE *file, varray_type ddrs)\n \n \f\n \n-/* Compute the lowest iteration bound for LOOP.  It is an\n-   INTEGER_CST.  */\n+/* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n+   approximation of the number of iterations for LOOP.  */\n \n static void\n compute_estimated_nb_iterations (struct loop *loop)\n {\n-  tree estimation;\n-  struct nb_iter_bound *bound, *next;\n-  \n-  for (bound = loop->bounds; bound; bound = next)\n-    {\n-      next = bound->next;\n-      estimation = bound->bound;\n-\n-      if (TREE_CODE (estimation) != INTEGER_CST)\n-\tcontinue;\n-\n-      if (loop->estimated_nb_iterations)\n-\t{\n-\t  /* Update only if estimation is smaller.  */\n-\t  if (tree_int_cst_lt (estimation, loop->estimated_nb_iterations))\n-\t    loop->estimated_nb_iterations = estimation;\n-\t}\n-      else\n-\tloop->estimated_nb_iterations = estimation;\n-    }\n+  struct nb_iter_bound *bound;\n+  \n+  for (bound = loop->bounds; bound; bound = bound->next)\n+    if (TREE_CODE (bound->bound) == INTEGER_CST\n+\t/* Update only when there is no previous estimation.  */\n+\t&& (chrec_contains_undetermined (loop->estimated_nb_iterations)\n+\t    /* Or when the current estimation is smaller.  */\n+\t    || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations)))\n+      loop->estimated_nb_iterations = bound->bound;\n }\n \n /* Estimate the number of iterations from the size of the data and the\n@@ -538,7 +527,7 @@ analyze_array_indexes (struct loop *loop,\n   access_fn = instantiate_parameters \n     (loop, analyze_scalar_evolution (loop, opnd1));\n \n-  if (loop->estimated_nb_iterations == NULL_TREE)\n+  if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n     estimate_niter_from_size_of_data (loop, opnd0, access_fn, stmt);\n   \n   VEC_safe_push (tree, heap, *access_fns, access_fn);\n@@ -1129,8 +1118,12 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n     numiter_z = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n       ->estimated_nb_iterations;\n \n-  if (numiter_x == NULL_TREE || numiter_y == NULL_TREE \n-      || numiter_z == NULL_TREE)\n+  if (chrec_contains_undetermined (numiter_x)\n+      || chrec_contains_undetermined (numiter_y)\n+      || chrec_contains_undetermined (numiter_z)\n+      || TREE_CODE (numiter_x) != INTEGER_CST\n+      || TREE_CODE (numiter_y) != INTEGER_CST\n+      || TREE_CODE (numiter_z) != INTEGER_CST)\n     {\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n@@ -1278,7 +1271,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n \t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n \t      ->estimated_nb_iterations;\n-\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t  if (chrec_contains_undetermined (numiter_a)\n+\t      || chrec_contains_undetermined (numiter_b)\n+\t      || TREE_CODE (numiter_a) != INTEGER_CST\n+\t      || TREE_CODE (numiter_b) != INTEGER_CST)\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n@@ -1379,7 +1375,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n \t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n \t      ->estimated_nb_iterations;\n-\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t  if (chrec_contains_undetermined (numiter_a)\n+\t      || chrec_contains_undetermined (numiter_b)\n+\t      || TREE_CODE (numiter_a) != INTEGER_CST\n+\t      || TREE_CODE (numiter_b) != INTEGER_CST)\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n@@ -2344,11 +2343,11 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \n \t  /* When there are no defs in the loop, the loop is parallel.  */\n \t  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n-\t    bb->loop_father->parallel_p = false;\n+\t    loop->parallel_p = false;\n \t}\n \n-      if (bb->loop_father->estimated_nb_iterations == NULL_TREE)\n-\tcompute_estimated_nb_iterations (bb->loop_father);\n+      if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n+\tcompute_estimated_nb_iterations (loop);\n     }\n \n   free (bbs);"}, {"sha": "73424ee098aac845e23cbe57ec9f98c29eb74816", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "patch": "@@ -1348,6 +1348,15 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   unsigned i, n_exits;\n   struct tree_niter_desc niter_desc;\n \n+  /* Give up if we already have tried to compute an estimation.  */\n+  if (loop->estimated_nb_iterations == chrec_dont_know\n+      /* Or when we already have an estimation.  */\n+      || (loop->estimated_nb_iterations != NULL_TREE\n+\t  && TREE_CODE (loop->estimated_nb_iterations) == INTEGER_CST))\n+    return;\n+  else\n+    loop->estimated_nb_iterations = chrec_dont_know;\n+\n   exits = get_loop_exit_edges (loop, &n_exits);\n   for (i = 0; i < n_exits; i++)\n     {\n@@ -1368,7 +1377,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   free (exits);\n   \n   /* Analyzes the bounds of arrays accessed in the loop.  */\n-  if (loop->estimated_nb_iterations == NULL_TREE)\n+  if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n     {\n       varray_type datarefs;\n       VARRAY_GENERIC_PTR_INIT (datarefs, 3, \"datarefs\");\n@@ -1581,6 +1590,7 @@ convert_step_widening (struct loop *loop, tree new_type, tree base, tree step,\n   valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type,\n \t\t\t     delta, step_abs);\n \n+  estimate_numbers_of_iterations_loop (loop);\n   for (bound = loop->bounds; bound; bound = bound->next)\n     if (proved_non_wrapping_p (at_stmt, bound, new_type, valid_niter))\n       return step_in_new_type;\n@@ -1649,6 +1659,7 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n   step_abs = fold_convert (unsigned_type, step_abs);\n   valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n \n+  estimate_numbers_of_iterations_loop (loop);\n   for (bound = loop->bounds; bound; bound = bound->next)\n     if (proved_non_wrapping_p (at_stmt, bound, type, valid_niter))\n       return false;"}, {"sha": "35f78f4b85526a6556db682a6f47a068e2e244de", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79ebd55c85ca2d91bea2f35a190a0ae084d720c0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=79ebd55c85ca2d91bea2f35a190a0ae084d720c0", "patch": "@@ -3509,10 +3509,7 @@ execute_vrp (void)\n \n   cfg_loops = loop_optimizer_init (NULL);\n   if (cfg_loops)\n-    {\n-      scev_initialize (cfg_loops);\n-      estimate_numbers_of_iterations (cfg_loops);\n-    }\n+    scev_initialize (cfg_loops);\n \n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);"}]}