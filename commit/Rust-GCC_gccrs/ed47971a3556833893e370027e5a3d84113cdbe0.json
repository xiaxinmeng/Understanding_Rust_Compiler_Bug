{"sha": "ed47971a3556833893e370027e5a3d84113cdbe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ0Nzk3MWEzNTU2ODMzODkzZTM3MDAyN2U1YTNkODQxMTNjZGJlMA==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2002-03-25T23:20:31Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2002-03-25T23:20:31Z"}, "message": "gcconfig.h: Change all likely references to linker script synthesized symbols to use this...\n\n\t* include/private/gcconfig.h: Change all likely references\n\tto linker script synthesized symbols to use this idiom:\n\textern int etext[]; etext\n\nFrom-SVN: r51352", "tree": {"sha": "f8307ad0aead6f27d5d3a07f8140cfecc3788766", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8307ad0aead6f27d5d3a07f8140cfecc3788766"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed47971a3556833893e370027e5a3d84113cdbe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed47971a3556833893e370027e5a3d84113cdbe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed47971a3556833893e370027e5a3d84113cdbe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed47971a3556833893e370027e5a3d84113cdbe0/comments", "author": null, "committer": null, "parents": [{"sha": "b7d5968dfcef942f1203a49152cfc26d4ea5cd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d5968dfcef942f1203a49152cfc26d4ea5cd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d5968dfcef942f1203a49152cfc26d4ea5cd2e"}], "stats": {"total": 290, "additions": 149, "deletions": 141}, "files": [{"sha": "3b97faed79843a3ce2a9bb4827c41c35c40b34ea", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed47971a3556833893e370027e5a3d84113cdbe0/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed47971a3556833893e370027e5a3d84113cdbe0/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=ed47971a3556833893e370027e5a3d84113cdbe0", "patch": "@@ -1,3 +1,9 @@\n+2002-03-25  Loren J. Rittle  <ljrittle@acm.org>\n+\n+\t* include/private/gcconfig.h: Change all likely references\n+\tto linker script synthesized symbols to use this idiom:\n+\textern int etext[]; etext\n+\n 2002-03-25  Jeff Sturm  <jsturm@one-point.com>\n \n \t* linux_threads.c (GC_get_nprocs): Close file descriptor."}, {"sha": "71cc504dfb1d1e56a7bd9b3139fc37122d0fda3d", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 143, "deletions": 141, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed47971a3556833893e370027e5a3d84113cdbe0/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed47971a3556833893e370027e5a3d84113cdbe0/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=ed47971a3556833893e370027e5a3d84113cdbe0", "patch": "@@ -450,7 +450,9 @@\n  * On UNIX systems, the collector will scan the area between DATASTART\n  * and DATAEND for root pointers.\n  *\n- * DATAEND, if not &end.\n+ * DATAEND, if not `end' where `end' is defined as ``extern int end[];''.\n+ * RTH suggests gaining access to linker script synth'd values with\n+ * this idiom instead of `&end' where `end' is defined as ``extern int end;'' .\n  *\n  * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n  * the pointer size.\n@@ -546,14 +548,14 @@\n #   ifdef OPENBSD\n #\tdefine OS_TYPE \"OPENBSD\"\n #\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)(etext))\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n #\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)(etext))\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n@@ -576,38 +578,38 @@\n                              /* contain large read-only data tables    */\n                              /* that we'd rather not scan.             */\n #\t     endif /* !GLIBC2 */\n-             extern int _end;\n-#            define DATAEND (&_end)\n+             extern int _end[];\n+#            define DATAEND (_end)\n #       else\n-             extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+             extern int etext[];\n+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       endif\n #   endif\n #   ifdef SUNOS4\n #\tdefine OS_TYPE \"SUNOS4\"\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)((((word) (etext)) + 0x1ffff) & ~0x1ffff))\n #\tdefine HEURISTIC1\t/* differs\t*/\n #\tdefine DYNAMIC_LOADING\n #   endif\n #   ifdef HP\n #\tdefine OS_TYPE \"HP\"\n-\textern char etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+\textern char etext[];\n+#       define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n \t\t\t      /* empirically determined.  seems to work. */\n #  \tinclude <unistd.h>\n #\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n #   endif\n #   ifdef SYSV\n #\tdefine OS_TYPE \"SYSV\"\n-\textern etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\textern etext[];\n+#   \tdefine DATASTART ((ptr_t)((((word) (etext)) + 0x3fffff) \\\n \t\t\t\t   & ~0x3fffff) \\\n-\t\t\t\t  +((word)&etext & 0x1fff))\n+\t\t\t\t  +((word)etext & 0x1fff))\n \t/* This only works for shared-text binaries with magic number 0413.\n \t   The other sorts of SysV binaries put the data at the end of the text,\n-\t   in which case the default of &etext would work.  Unfortunately,\n+\t   in which case the default of etext would work.  Unfortunately,\n \t   handling both would require having the magic-number available.\n \t   \t   \t\t-- Parag\n \t   */\n@@ -667,8 +669,8 @@\n #     define STACK_GRAN 0x10000000\n \t/* Stack usually starts at 0x80000000 */\n #     define LINUX_DATA_START\n-      extern int _end;\n-#     define DATAEND (&_end)\n+      extern int _end[];\n+#     define DATAEND (_end)\n #   endif\n #   ifdef MACOSX\n       /* There are reasons to suspect this may not be reliable. \t*/\n@@ -685,16 +687,16 @@\n #     define ALIGNMENT 4\n #     define OS_TYPE \"NETBSD\"\n #     define HEURISTIC2\n-      extern char etext;\n+      extern char etext[];\n #     define DATASTART GC_data_start\n #     define DYNAMIC_LOADING\n #   endif\n #   ifdef NOSYS\n #     define ALIGNMENT 4\n #     define OS_TYPE \"NOSYS\"\n-      extern void __end, __dso_handle;\n-#     define DATASTART (&__dso_handle)  /* OK, that's ugly.  */\n-#     define DATAEND (&__end)\n+      extern void __end[], __dso_handle[];\n+#     define DATASTART (__dso_handle)  /* OK, that's ugly.  */\n+#     define DATAEND (__end)\n \t/* Stack starts at 0xE0000000 for the simulator.  */\n #     undef STACK_GRAN\n #     define STACK_GRAN 0x10000000\n@@ -705,8 +707,8 @@\n # ifdef VAX\n #   define MACH_TYPE \"VAX\"\n #   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n-    extern char etext;\n-#   define DATASTART ((ptr_t)(&etext))\n+    extern char etext[];\n+#   define DATASTART ((ptr_t)(etext))\n #   ifdef BSD\n #\tdefine OS_TYPE \"BSD\"\n #\tdefine HEURISTIC1\n@@ -738,11 +740,11 @@\n #   define ALIGN_DOUBLE\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n-\textern int _etext;\n-\textern int _end;\n+\textern int _etext[];\n+\textern int _end[];\n \textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n+#\tdefine DATAEND (_end)\n #\tif !defined(USE_MMAP) && defined(REDIRECT_MALLOC)\n #\t    define USE_MMAP\n \t    /* Otherwise we now use calloc.  Mmap may result in the\t*/\n@@ -780,9 +782,9 @@\n #\tdefine OS_TYPE \"SUNOS4\"\n \t/* [If you have a weak stomach, don't read this.]\t\t*/\n \t/* We would like to use:\t\t\t\t\t*/\n-/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n+/* #       define DATASTART ((ptr_t)((((word) (etext)) + 0x1fff) & ~0x1fff)) */\n \t/* This fails occasionally, due to an ancient, but very \t*/\n-\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n+\t/* persistent ld bug.  etext is set 32 bytes too high.\t\t*/\n \t/* We instead read the text segment size from the a.out\t\t*/\n \t/* header, which happens to be mapped into our address space\t*/\n \t/* at the start of the text segment.  The detective work here\t*/\n@@ -798,8 +800,8 @@\n #   ifdef DRSNX\n #\tdefine OS_TYPE \"DRSNX\"\n \textern char * GC_SysVGetDataStart();\n-\textern int etext;\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+\textern int etext[];\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, etext)\n #\tdefine MPROTECT_VDB\n #       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n #\tdefine DYNAMIC_LOADING\n@@ -811,23 +813,23 @@\n #     else\n           Linux Sparc/a.out not supported\n #     endif\n-      extern int _end;\n-      extern int _etext;\n-#     define DATAEND (&_end)\n+      extern int _end[];\n+      extern int _etext[];\n+#     define DATAEND (_end)\n #     define SVR4\n #     ifdef __arch64__\n #       define STACKBOTTOM ((ptr_t) 0x80000000000ULL)\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, &_etext)\n+#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, _etext)\n #     else\n #       define STACKBOTTOM ((ptr_t) 0xf0000000)\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n #     endif\n #   endif\n #   ifdef OPENBSD\n #     define OS_TYPE \"OPENBSD\"\n #     define STACKBOTTOM ((ptr_t) 0xf8000000)\n-      extern int etext;\n-#     define DATASTART ((ptr_t)(&etext))\n+      extern int etext[];\n+#     define DATASTART ((ptr_t)(etext))\n #   endif\n #   ifdef NETBSD\n #     define OS_TYPE \"NETBSD\"\n@@ -836,8 +838,8 @@\n #\tdefine DATASTART GC_data_start\n #\tdefine DYNAMIC_LOADING\n #     else\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)(etext))\n #     endif\n #   endif\n # endif\n@@ -857,24 +859,24 @@\n #   endif\n #   ifdef SEQUENT\n #\tdefine OS_TYPE \"SEQUENT\"\n-\textern int etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+\textern int etext[];\n+#       define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n #   endif\n #   ifdef BEOS\n #     define OS_TYPE \"BEOS\"\n #     include <OS.h>\n #     define GETPAGESIZE() B_PAGE_SIZE\n-      extern int etext;\n-#     define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+      extern int etext[];\n+#     define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #   endif\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n-        extern int _etext, _end;\n+        extern int _etext[], _end[];\n   \textern char * GC_SysVGetDataStart();\n-#       define DATASTART GC_SysVGetDataStart(0x1000, &_etext)\n-#\tdefine DATAEND (&_end)\n-/*\t# define STACKBOTTOM ((ptr_t)(&_start)) worked through 2.7,  \t*/\n+#       define DATASTART GC_SysVGetDataStart(0x1000, _etext)\n+#\tdefine DATAEND (_end)\n+/*\t# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  \t*/\n /*      but reportedly breaks under 2.8.  It appears that the stack\t*/\n /* \tbase is a property of the executable, so this should not break\t*/\n /* \told executables.\t\t\t\t\t\t*/\n@@ -902,16 +904,16 @@\n #   endif\n #   ifdef SCO\n #\tdefine OS_TYPE \"SCO\"\n-\textern int etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\textern int etext[];\n+#   \tdefine DATASTART ((ptr_t)((((word) (etext)) + 0x3fffff) \\\n \t\t\t\t  & ~0x3fffff) \\\n-\t\t\t\t +((word)&etext & 0xfff))\n+\t\t\t\t +((word)etext & 0xfff))\n #\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n #   endif\n #   ifdef SCO_ELF\n #       define OS_TYPE \"SCO_ELF\"\n-        extern int etext;\n-#       define DATASTART ((ptr_t)(&etext))\n+        extern int etext[];\n+#       define DATASTART ((ptr_t)(etext))\n #       define STACKBOTTOM ((ptr_t) 0x08048000)\n #       define DYNAMIC_LOADING\n #\tdefine ELF_CLASS ELFCLASS32\n@@ -942,8 +944,8 @@\n #       ifdef __ELF__\n #            define DYNAMIC_LOADING\n #\t     ifdef UNDEFINED\t/* includes ro data */\n-\t       extern int _etext;\n-#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n+\t       extern int _etext[];\n+#              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))\n #\t     endif\n #\t     include <features.h>\n #\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n@@ -960,11 +962,11 @@\n \t\t\t      /* contain large read-only data tables    */\n \t\t\t      /* that we'd rather not scan.\t\t*/\n #\t     endif\n-\t     extern int _end;\n-#\t     define DATAEND (&_end)\n+\t     extern int _end[];\n+#\t     define DATAEND (_end)\n #\telse\n-\t     extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+\t     extern int etext[];\n+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       endif\n #\tifdef USE_I686_PREFETCH\n #\t  define PREFETCH(x) \\\n@@ -989,10 +991,10 @@\n #   endif\n #   ifdef CYGWIN32\n #       define OS_TYPE \"CYGWIN32\"\n-          extern int _data_start__;\n-          extern int _data_end__;\n-          extern int _bss_start__;\n-          extern int _bss_end__;\n+          extern int _data_start__[];\n+          extern int _data_end__[];\n+          extern int _bss_start__[];\n+          extern int _bss_end__[];\n   \t/* For binutils 2.9.1, we have\t\t\t*/\n   \t/*\tDATASTART   = _data_start__\t\t*/\n   \t/*\tDATAEND\t    = _bss_end__\t\t*/\n@@ -1003,8 +1005,8 @@\n   \t/* minumum/maximum of the two.\t\t\t*/\n #   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n #   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n-#       define DATASTART ((ptr_t) MIN(&_data_start__, &_bss_start__))\n-#       define DATAEND\t ((ptr_t) MAX(&_data_end__, &_bss_end__))\n+#       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))\n+#       define DATAEND\t ((ptr_t) MAX(_data_end__, _bss_end__))\n #\tundef STACK_GRAN\n #       define STACK_GRAN 0x10000\n #       define HEURISTIC1\n@@ -1033,10 +1035,10 @@\n #   ifdef DJGPP\n #       define OS_TYPE \"DJGPP\"\n #       include \"stubinfo.h\"\n-        extern int etext;\n+        extern int etext[];\n         extern int _stklen;\n         extern int __djgpp_stack_limit;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n+#       define DATASTART ((ptr_t)((((word) (etext)) + 0x1ff) & ~0x1ff))\n /* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n                                                      + _stklen)) */\n #       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))\n@@ -1056,8 +1058,8 @@\n #\tifdef __ELF__\n #\t    define DYNAMIC_LOADING\n #\tendif\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)(etext))\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -1071,8 +1073,8 @@\n #   if defined(OPENBSD) || defined(NETBSD) \\\n         || defined(THREE86BSD) || defined(BSDI)\n #\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+\textern char etext[];\n+#\tdefine DATASTART ((ptr_t)(etext))\n #   endif\n #   ifdef NEXT\n #\tdefine OS_TYPE \"NEXT\"\n@@ -1099,10 +1101,10 @@\n #     define OS_TYPE \"HURD\"\n #     define STACK_GROWS_DOWN\n #     define HEURISTIC2\n-      extern int  __data_start;\n-#     define DATASTART ( (ptr_t) (&__data_start))\n-      extern int   _end;\n-#     define DATAEND ( (ptr_t) (&_end))\n+      extern int  __data_start[];\n+#     define DATASTART ( (ptr_t) (__data_start))\n+      extern int   _end[];\n+#     define DATAEND ( (ptr_t) (_end))\n /* #     define MPROTECT_VDB  Not quite working yet? */\n #     define DYNAMIC_LOADING\n #   endif\n@@ -1126,8 +1128,8 @@\n       /* This was developed for a linuxce style platform.  Probably\t*/\n       /* needs to be tweaked for workstation class machines.\t\t*/\n #     define OS_TYPE \"LINUX\"\n-      extern int __data_start;\n-#     define DATASTART ((ptr_t)(&__data_start))\n+      extern int __data_start[];\n+#     define DATASTART ((ptr_t)(__data_start))\n #     define ALIGNMENT 4\n #     define USE_GENERIC_PUSH_REGS\n #     define STACKBOTTOM ((ptr_t)0x7fff8000)\n@@ -1145,15 +1147,15 @@\n #        define CPP_WORDSZ _MIPS_SZPTR\n #        define ALIGNMENT (_MIPS_SZPTR/8)\n #      else\n-         extern int etext, edata, end;\n-         extern int _DYNAMIC_LINKING, _gp;\n-#        define DATASTART ((ptr_t)((((word)&etext + 0x3ffff) & ~0x3ffff) \\\n-               + ((word)&etext & 0xffff)))\n-#        define DATAEND (&edata)\n-#        define DATASTART2 (&_DYNAMIC_LINKING \\\n-               ? (ptr_t)(((word)&_gp + 0x8000 + 0x3ffff) & ~0x3ffff) \\\n-               : (ptr_t)&edata)\n-#        define DATAEND2 (&end)\n+         extern int etext[], edata[], end[];\n+         extern int _DYNAMIC_LINKING[], _gp[];\n+#        define DATASTART ((ptr_t)((((word)etext + 0x3ffff) & ~0x3ffff) \\\n+               + ((word)etext & 0xffff)))\n+#        define DATAEND (edata)\n+#        define DATASTART2 (_DYNAMIC_LINKING \\\n+               ? (ptr_t)(((word)_gp + 0x8000 + 0x3ffff) & ~0x3ffff) \\\n+               : (ptr_t)edata)\n+#        define DATAEND2 (end)\n #        define ALIGNMENT 4\n #      endif\n #      define OS_TYPE \"EWS4800\"\n@@ -1175,8 +1177,8 @@\n #   endif\n #   ifdef IRIX5\n #\tdefine HEURISTIC2\n-        extern int _fdata;\n-#       define DATASTART ((ptr_t)(&_fdata))\n+        extern int _fdata[];\n+#       define DATASTART ((ptr_t)(_fdata))\n #       ifdef USE_MMAP\n #         define HEAP_START (ptr_t)0x30000000\n #       else\n@@ -1214,7 +1216,7 @@\n #     define HEURISTIC2\n #     define USE_GENERIC_PUSH_REGS\n #     ifdef __ELF__\n-        extern int etext;\n+        extern int etext[];\n #       define DATASTART GC_data_start\n #       define NEED_FIND_LIMIT\n #       define DYNAMIC_LOADING\n@@ -1234,9 +1236,9 @@\n #     define ALIGNMENT 4\n #     define CPP_WORDSZ 32\n #   endif\n-    extern int _data, _end;\n-#   define DATASTART ((ptr_t)((ulong)&_data))\n-#   define DATAEND ((ptr_t)((ulong)&_end))\n+    extern int _data[], _end[];\n+#   define DATASTART ((ptr_t)((ulong)_data))\n+#   define DATAEND ((ptr_t)((ulong)_end))\n     extern int errno;\n #   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n #   define USE_GENERIC_PUSH_REGS\n@@ -1270,8 +1272,8 @@\n #   define STACK_GROWS_UP\n #   ifdef HPUX\n #     define OS_TYPE \"HPUX\"\n-      extern int __data_start;\n-#     define DATASTART ((ptr_t)(&__data_start))\n+      extern int __data_start[];\n+#     define DATASTART ((ptr_t)(__data_start))\n #     if 0\n \t/* The following appears to work for 7xx systems running HP/UX\t*/\n \t/* 9.xx Furthermore, it might result in much faster\t\t*/\n@@ -1303,8 +1305,8 @@\n #     define LINUX_STACKBOTTOM\n #     define DYNAMIC_LOADING\n #     define LINUX_DATA_START\n-      extern int _end;\n-#     define DATAEND (&_end)\n+      extern int _end[];\n+#     define DATAEND (_end)\n #   endif /* LINUX */\n # endif /* HP_PA */\n \n@@ -1344,21 +1346,21 @@\n #\t    define DYNAMIC_LOADING\n #\tendif\n /* Handle unmapped hole alpha*-*-freebsd[45]* puts between etext and edata. */\n-\textern char etext;\n-\textern char edata;\n-\textern char end;\n+\textern char etext[];\n+\textern char edata[];\n+\textern char end[];\n #\tdefine NEED_FIND_LIMIT\n-#\tdefine DATASTART ((ptr_t)(&etext))\n+#\tdefine DATASTART ((ptr_t)(etext))\n #\tdefine DATAEND (GC_find_limit (DATASTART, TRUE))\n-#\tdefine DATASTART2 ((ptr_t)(&edata))\n-#\tdefine DATAEND2 ((ptr_t)(&end))\n+#\tdefine DATASTART2 ((ptr_t)(edata))\n+#\tdefine DATAEND2 ((ptr_t)(end))\n #\tdefine CPP_WORDSZ 64\n #   endif\n #   ifdef OSF1\n #\tdefine OS_TYPE \"OSF1\"\n #   \tdefine DATASTART ((ptr_t) 0x140000000)\n-\textern int _end;\n-#   \tdefine DATAEND ((ptr_t) &_end)\n+\textern int _end[];\n+#   \tdefine DATAEND ((ptr_t) _end)\n  \textern char ** environ;\n \t/* round up from the value of environ to the nearest page boundary */\n \t/* Probably breaks if putenv is called before collector \t   */\n@@ -1369,8 +1371,8 @@\n \t/* the text segment immediately follows the stack.\t\t*/\n \t/* Hence we give an upper pound.\t\t\t\t*/\n \t/* This is currently unused, since we disabled HEURISTIC2\t*/\n-    \textern int __start;\n-#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n+    \textern int __start[];\n+#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(__start) & ~(getpagesize()-1)))\n #   \tdefine CPP_WORDSZ 64\n #   \tdefine MPROTECT_VDB\n #   \tdefine DYNAMIC_LOADING\n@@ -1386,8 +1388,8 @@\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n #       endif\n-\textern int _end;\n-#\tdefine DATAEND (&_end)\n+\textern int _end[];\n+#\tdefine DATAEND (_end)\n #\tdefine MPROTECT_VDB\n \t\t/* Has only been superficially tested.  May not\t*/\n \t\t/* work on all versions.\t\t\t*/\n@@ -1420,8 +1422,8 @@\n #         define ALIGNMENT 8\n #       endif\n #       define OS_TYPE \"HPUX\"\t\n-        extern int __data_start;\n-#       define DATASTART ((ptr_t)(&__data_start))\n+        extern int __data_start[];\n+#       define DATASTART ((ptr_t)(__data_start))\n         /* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2\t*/\n         /* to this.  Note that the GC must be initialized before the\t*/\n     \t/* first putenv call.\t\t\t\t\t\t*/\n@@ -1469,8 +1471,8 @@\n #  \tendif\n #\tdefine MPROTECT_VDB\n \t\t/* Requires Linux 2.3.47 or later.\t*/\n-\textern int _end;\n-#\tdefine DATAEND (&_end)\n+\textern int _end[];\n+#\tdefine DATAEND (_end)\n #       ifdef __GNUC__\n #\t  define PREFETCH(x) \\\n \t    __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n@@ -1486,15 +1488,15 @@\n #   define MACH_TYPE \"M88K\"\n #   define ALIGNMENT 4\n #   define ALIGN_DOUBLE\n-    extern int etext;\n+    extern int etext[];\n #   ifdef CX_UX\n #\tdefine OS_TYPE \"CX_UX\"\n-#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n+#       define DATASTART ((((word)etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n #   endif\n #   ifdef  DGUX\n #\tdefine OS_TYPE \"DGUX\"\n \textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, etext)\n #   endif\n #   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n # endif\n@@ -1505,27 +1507,27 @@\n #   define USE_GENERIC_PUSH_REGS\n #   ifdef UTS4\n #       define OS_TYPE \"UTS4\"\n-        extern int etext;\n-\textern int _etext;\n-\textern int _end;\n+        extern int etext[];\n+\textern int _etext[];\n+\textern int _end[];\n \textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n+#\tdefine DATAEND (_end)\n #\tdefine HEURISTIC2\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define HEURISTIC1\n #       define DYNAMIC_LOADING\n-        extern int __data_start;\n-#       define DATASTART ((ptr_t)(&__data_start))\n+        extern int __data_start[];\n+#       define DATASTART ((ptr_t)(__data_start))\n #   endif\n # endif\n \n # if defined(PJ)\n #   define ALIGNMENT 4\n-    extern int _etext;\n-#   define DATASTART ((ptr_t)(&_etext))\n+    extern int _etext[];\n+#   define DATASTART ((ptr_t)(_etext))\n #   define HEURISTIC1\n # endif\n \n@@ -1536,8 +1538,8 @@\n #   ifdef NETBSD\n #       define OS_TYPE \"NETBSD\"\n #       define HEURISTIC2\n-        extern char etext;\n-#       define DATASTART ((ptr_t)(&etext))\n+        extern char etext[];\n+#       define DATASTART ((ptr_t)(etext))\n #       define USE_GENERIC_PUSH_REGS\n #   endif\n #   ifdef LINUX\n@@ -1563,11 +1565,11 @@\n \t\t\t      /* contain large read-only data tables    */\n \t\t\t      /* that we'd rather not scan.\t\t*/\n #\t     endif\n-\t     extern int _end;\n-#\t     define DATAEND (&_end)\n+\t     extern int _end[];\n+#\t     define DATAEND (_end)\n #\telse\n-\t     extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+\t     extern int etext[];\n+#            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       endif\n #   endif\n #   ifdef MSWINCE\n@@ -1576,8 +1578,8 @@\n #   endif\n #   ifdef NOSYS\n       /* __data_start is usually defined in the target linker script.  */\n-      extern int __data_start;\n-#     define DATASTART (ptr_t)(&__data_start)\n+      extern int __data_start[];\n+#     define DATASTART (ptr_t)(__data_start)\n #     define USE_GENERIC_PUSH_REGS\n       /* __stack_base__ is set in newlib/libc/sys/arm/crt0.S  */\n       extern void *__stack_base__;\n@@ -1598,8 +1600,8 @@\n #     define USE_GENERIC_PUSH_REGS\n #     define DYNAMIC_LOADING\n #     define LINUX_DATA_START\n-      extern int _end;\n-#     define DATAEND (&_end)\n+      extern int _end[];\n+#     define DATAEND (_end)\n #   endif\n # endif\n  \n@@ -1617,10 +1619,10 @@\n     /* case we lose.  Nonetheless, we try both, prefering __data_start.\t*/\n     /* We assume gcc.\t*/\n #   pragma weak __data_start\n-    extern int __data_start;\n+    extern int __data_start[];\n #   pragma weak data_start\n-    extern int data_start;\n-#   define DATASTART ((ptr_t)(&__data_start != 0? &__data_start : &data_start))\n+    extern int data_start[];\n+#   define DATASTART ((ptr_t)(__data_start != 0? __data_start : data_start))\n #endif\n \n #if defined(LINUX) && defined(REDIRECT_MALLOC)\n@@ -1644,8 +1646,8 @@\n # endif\n \n # ifndef DATAEND\n-    extern int end;\n-#   define DATAEND (&end)\n+    extern int end[];\n+#   define DATAEND (end)\n # endif\n \n # if defined(SVR4) && !defined(GETPAGESIZE)"}]}