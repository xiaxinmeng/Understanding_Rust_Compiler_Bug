{"sha": "467456d0548913eacaa4f0bcca37b34b6c90a657", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3NDU2ZDA1NDg5MTNlYWNhYTRmMGJjY2EzN2IzNGI2YzkwYTY1Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T18:10:29Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T18:10:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1572", "tree": {"sha": "ea9cf9af1b3e420fef280a3b7ed93a1a176fe24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea9cf9af1b3e420fef280a3b7ed93a1a176fe24a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/467456d0548913eacaa4f0bcca37b34b6c90a657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467456d0548913eacaa4f0bcca37b34b6c90a657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467456d0548913eacaa4f0bcca37b34b6c90a657", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467456d0548913eacaa4f0bcca37b34b6c90a657/comments", "author": null, "committer": null, "parents": [{"sha": "10f07067b55cd643a8072da1cfac6dd25b4b67e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f07067b55cd643a8072da1cfac6dd25b4b67e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f07067b55cd643a8072da1cfac6dd25b4b67e2"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "02ce0f975176b28e32dd3b39d7033a55b8aa205d", "filename": "gcc/function.c", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467456d0548913eacaa4f0bcca37b34b6c90a657/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467456d0548913eacaa4f0bcca37b34b6c90a657/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=467456d0548913eacaa4f0bcca37b34b6c90a657", "patch": "@@ -3507,6 +3507,137 @@ round_trampoline_addr (tramp)\n   return tramp;\n }\n \f\n+/* The functions identify_blocks and reorder_blocks provide a way to\n+   reorder the tree of BLOCK nodes, for optimizers that reshuffle or\n+   duplicate portions of the RTL code.  Call identify_blocks before\n+   changing the RTL, and call reorder_blocks after.  */\n+\n+static int all_blocks ();\n+static tree blocks_nreverse ();\n+\n+/* Put all this function's BLOCK nodes into a vector, and return it.\n+   Also store in each NOTE for the beginning or end of a block\n+   the index of that block in the vector.\n+   The arguments are TOP_BLOCK, the top-level block of the function,\n+   and INSNS, the insn chain of the function.  */\n+\n+tree *\n+identify_blocks (top_block, insns)\n+     tree top_block;\n+     rtx insns;\n+{\n+  int n_blocks = all_blocks (top_block, 0);\n+  tree *block_vector = (tree *) alloca (n_blocks * sizeof (tree));\n+  int *block_stack = (int *) alloca (n_blocks * sizeof (int));\n+  int depth = 0;\n+  int next_block_number = 0;\n+  int current_block_number = 0;\n+  rtx insn;\n+\n+  all_blocks (top_block, block_vector);\n+\n+  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\t  {\n+\t    block_stack[depth++] = current_block_number;\n+\t    current_block_number = next_block_number;\n+\t    SET_NOTE_BLOCK_NUMBER (insn, next_block_number++);\n+\t  }\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  {\n+\t    current_block_number = block_stack[--depth];\n+\t    SET_NOTE_BLOCK_NUMBER (insn, current_block_number);\n+\t  }\n+      }\n+\n+  return block_vector;\n+}\n+\n+/* Given BLOCK_VECTOR which was returned by identify_blocks,\n+   and a revised instruction chain, rebuild the tree structure\n+   of BLOCK nodes to correspond to the new order of RTL.\n+   Returns the current top-level block.  */\n+\n+tree\n+reorder_blocks (block_vector, insns)\n+     tree *block_vector;\n+     rtx insns;\n+{\n+  tree current_block = block_vector[0];\n+  rtx insn;\n+\n+  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\t  {\n+\t    tree block = block_vector[NOTE_BLOCK_NUMBER (insn)];\n+\t    /* If we have seen this block before, copy it.  */\n+\t    if (TREE_ASM_WRITTEN (block))\n+\t      block = copy_node (block);\n+\t    else\n+\t      BLOCK_SUBBLOCKS (block) = 0;\n+\t    TREE_ASM_WRITTEN (block) = 1;\n+\t    BLOCK_SUPERCONTEXT (block) = current_block; \n+\t    BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n+\t    BLOCK_SUBBLOCKS (current_block) = block;\n+\t    current_block = block;\n+\t    SET_NOTE_BLOCK_NUMBER (insn, 0);\n+\t  }\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  {\n+\t    BLOCK_SUBBLOCKS (current_block)\n+\t      = blocks_nreverse (BLOCK_SUBBLOCKS (current_block));\n+\t    current_block = BLOCK_SUPERCONTEXT (current_block);\n+\t    SET_NOTE_BLOCK_NUMBER (insn, 0);\n+\t  }\n+      }\n+\n+  return current_block;\n+}\n+\n+/* Reverse the order of elements in the chain T of blocks,\n+   and return the new head of the chain (old last element).  */\n+\n+static tree\n+blocks_nreverse (t)\n+     tree t;\n+{\n+  register tree prev = 0, decl, next;\n+  for (decl = t; decl; decl = next)\n+    {\n+      next = BLOCK_CHAIN (decl);\n+      BLOCK_CHAIN (decl) = prev;\n+      prev = decl;\n+    }\n+  return prev;\n+}\n+\n+/* Count the subblocks of BLOCK, and list them all into the vector VECTOR.\n+   Also clear TREE_ASM_WRITTEN in all blocks.  */\n+\n+static int\n+all_blocks (block, vector)\n+     tree block;\n+     tree *vector;\n+{\n+  int n_blocks = 1;\n+  tree subblocks; \n+\n+  TREE_ASM_WRITTEN (block) = 0;\n+  /* Record this block.  */\n+  vector[n_blocks++] = block;\n+\n+  /* Record the subblocks, and their subblocks.  */\n+  for (subblocks = BLOCK_SUBBLOCKS (block);\n+       subblocks; subblocks = BLOCK_CHAIN (subblocks))\n+    n_blocks += all_blocks (subblocks, vector + n_blocks);\n+\n+  return n_blocks;\n+}\n+\f\n /* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)\n    and initialize static variables for generating RTL for the statements\n    of the function.  */"}]}