{"sha": "86785830c3d253af451018ac69278bf6ba2e8fd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3ODU4MzBjM2QyNTNhZjQ1MTAxOGFjNjkyNzhiZjZiYTJlOGZkNg==", "commit": {"author": {"name": "Artjoms Sinkarovs", "email": "artyom.shinkaroff@gmail.com", "date": "2011-10-06T01:57:27Z"}, "committer": {"name": "Artjoms Sinkarovs", "email": "tema@gcc.gnu.org", "date": "2011-10-06T01:57:27Z"}, "message": "Fix bconstp-3.c failure in PR50607.\n\nFrom-SVN: r179588", "tree": {"sha": "53a37f41c70f7b3b8839d82647a848425545ca99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a37f41c70f7b3b8839d82647a848425545ca99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86785830c3d253af451018ac69278bf6ba2e8fd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86785830c3d253af451018ac69278bf6ba2e8fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86785830c3d253af451018ac69278bf6ba2e8fd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86785830c3d253af451018ac69278bf6ba2e8fd6/comments", "author": {"login": "ashinkarov", "id": 892232, "node_id": "MDQ6VXNlcjg5MjIzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/892232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashinkarov", "html_url": "https://github.com/ashinkarov", "followers_url": "https://api.github.com/users/ashinkarov/followers", "following_url": "https://api.github.com/users/ashinkarov/following{/other_user}", "gists_url": "https://api.github.com/users/ashinkarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashinkarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashinkarov/subscriptions", "organizations_url": "https://api.github.com/users/ashinkarov/orgs", "repos_url": "https://api.github.com/users/ashinkarov/repos", "events_url": "https://api.github.com/users/ashinkarov/events{/privacy}", "received_events_url": "https://api.github.com/users/ashinkarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57d1eadd79297e4642ee402a58690e98850cf649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d1eadd79297e4642ee402a58690e98850cf649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d1eadd79297e4642ee402a58690e98850cf649"}], "stats": {"total": 172, "additions": 97, "deletions": 75}, "files": [{"sha": "b8d1671d80deced638dc2f72ee586ef2e82340cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86785830c3d253af451018ac69278bf6ba2e8fd6", "patch": "@@ -1,3 +1,11 @@\n+2011-10-06  Artjoms Sinkarovs  <artyom.shinkaroff@gmail.com>\n+\t* c-tree.h (c_expr_t): New typedef for struct c_expr.\n+\t(C_EXPR_APPEND): New macro.\n+\t* c-parser.c (c_parser_get_builtin_args): Preserve \n+\toriginal_tree_code of c_expr structure. Fixes bconstp-3.c\n+\tfailure of PR50607.\n+\t(c_parser_postfix_expression): Adjust to the new function.\n+\n 2011-10-05  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* function.c (thread_prologue_and_epilogue_insns): Don't shrink-wrap"}, {"sha": "a1ed48d576f8da7e847fccba4c8135653149fc3b", "filename": "gcc/c-parser.c", "status": "modified", "additions": 73, "deletions": 75, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=86785830c3d253af451018ac69278bf6ba2e8fd6", "patch": "@@ -5993,16 +5993,16 @@ c_parser_alignof_expression (c_parser *parser)\n    for the middle-end nodes like COMPLEX_EXPR, VEC_SHUFFLE_EXPR and\n    others.  The name of the builtin is passed using BNAME parameter.\n    Function returns true if there were no errors while parsing and\n-   stores the arguments in EXPR_LIST.  List of original types can be\n-   obtained by passing non NULL value to ORIG_TYPES.  */\n+   stores the arguments in CEXPR_LIST.  */\n static bool\n c_parser_get_builtin_args (c_parser *parser, const char *bname,\n-\t\t\t   VEC(tree,gc) **expr_list,\n-\t\t\t   VEC(tree,gc) **orig_types)\n+\t\t\t   VEC(c_expr_t,gc) **ret_cexpr_list)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n-  *expr_list = NULL;\n+  VEC (c_expr_t,gc) *cexpr_list;\n+  c_expr_t expr;\n \n+  *ret_cexpr_list = NULL;\n   if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n     {\n       error_at (loc, \"cannot take address of %qs\", bname);\n@@ -6016,15 +6016,21 @@ c_parser_get_builtin_args (c_parser *parser, const char *bname,\n       c_parser_consume_token (parser);\n       return true;\n     }\n-    \n-  if (orig_types)\n-    *expr_list = c_parser_expr_list (parser, false, false, orig_types);\n-  else\n-    *expr_list = c_parser_expr_list (parser, false, false, NULL);\n+\n+  expr = c_parser_expr_no_commas (parser, NULL);\n+  cexpr_list = VEC_alloc (c_expr_t, gc, 1);\n+  C_EXPR_APPEND (cexpr_list, expr);\n+  while (c_parser_next_token_is (parser, CPP_COMMA))\n+    {\n+      c_parser_consume_token (parser);\n+      expr = c_parser_expr_no_commas (parser, NULL);\n+      C_EXPR_APPEND (cexpr_list, expr);\n+    }\n \n   if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n     return false;\n \n+  *ret_cexpr_list = cexpr_list;\n   return true;\n }\n \n@@ -6378,52 +6384,41 @@ c_parser_postfix_expression (c_parser *parser)\n \t  break;\n \tcase RID_CHOOSE_EXPR:\n \t  {\n-\t    VEC(tree,gc) *expr_list;\n-\t    VEC(tree,gc) *orig_types;\n-\t    tree e1value, e2value, e3value, c;\n+\t    VEC (c_expr_t, gc) *cexpr_list;\n+\t    c_expr_t *e1_p, *e2_p, *e3_p;\n+\t    tree c;\n \n \t    c_parser_consume_token (parser);\n \t    if (!c_parser_get_builtin_args (parser,\n \t\t\t\t\t    \"__builtin_choose_expr\",\n-\t\t\t\t\t    &expr_list, &orig_types))\n+\t\t\t\t\t    &cexpr_list))\n \t      {\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n \n-\t    if (VEC_length (tree, expr_list) != 3)\n+\t    if (VEC_length (c_expr_t, cexpr_list) != 3)\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n \t\t\t       \"%<__builtin_choose_expr%>\");\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n-\t    \n-\t    e1value = VEC_index (tree, expr_list, 0);\n-\t    e2value = VEC_index (tree, expr_list, 1);\n-\t    e3value = VEC_index (tree, expr_list, 2);\n-\n-\t    c = e1value;\n-\t    mark_exp_read (e2value);\n-\t    mark_exp_read (e3value);\n+\n+\t    e1_p = VEC_index (c_expr_t, cexpr_list, 0);\n+\t    e2_p = VEC_index (c_expr_t, cexpr_list, 1);\n+\t    e3_p = VEC_index (c_expr_t, cexpr_list, 2);\n+\n+\t    c = e1_p->value;\n+\t    mark_exp_read (e2_p->value);\n+\t    mark_exp_read (e3_p->value);\n \t    if (TREE_CODE (c) != INTEGER_CST\n \t\t|| !INTEGRAL_TYPE_P (TREE_TYPE (c)))\n \t      error_at (loc,\n \t\t\t\"first argument to %<__builtin_choose_expr%> not\"\n \t\t\t\" a constant\");\n \t    constant_expression_warning (c);\n-\t    \n-\t    if (integer_zerop (c))\n-\t      {\n-\t\texpr.value = e3value;\n-\t\texpr.original_type = VEC_index (tree, orig_types, 2);\n-\t      }\n-\t    else\n-\t      {\n-\t\texpr.value = e2value;\n-\t\texpr.original_type = VEC_index (tree, orig_types, 1);\n-\t      }\n-\n+\t    expr = integer_zerop (c) ? *e3_p : *e2_p;\n \t    break;\n \t  }\n \tcase RID_TYPES_COMPATIBLE_P:\n@@ -6464,50 +6459,50 @@ c_parser_postfix_expression (c_parser *parser)\n \t  }\n \t  break;\n \tcase RID_BUILTIN_COMPLEX:\n-\t  { \n-\t    VEC(tree,gc) *expr_list;\n-\t    tree e1value, e2value;\n-\t    \n+\t  {\n+\t    VEC(c_expr_t, gc) *cexpr_list;\n+\t    c_expr_t *e1_p, *e2_p;\n+\n \t    c_parser_consume_token (parser);\n \t    if (!c_parser_get_builtin_args (parser,\n \t\t\t\t\t    \"__builtin_complex\",\n-\t\t\t\t\t    &expr_list, NULL))\n+\t\t\t\t\t    &cexpr_list))\n \t      {\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n \n-\t    if (VEC_length (tree, expr_list) != 2)\n+\t    if (VEC_length (c_expr_t, cexpr_list) != 2)\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n \t\t\t       \"%<__builtin_complex%>\");\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n-\t    \n-\t    e1value = VEC_index (tree, expr_list, 0);\n-\t    e2value = VEC_index (tree, expr_list, 1);\n-\n-\t    mark_exp_read (e1value);\n-\t    if (TREE_CODE (e1value) == EXCESS_PRECISION_EXPR)\n-\t      e1value = convert (TREE_TYPE (e1value),\n-\t\t\t\t TREE_OPERAND (e1value, 0));\n-\t    mark_exp_read (e2value);\n-\t    if (TREE_CODE (e2value) == EXCESS_PRECISION_EXPR)\n-\t      e2value = convert (TREE_TYPE (e2value),\n-\t\t\t\t TREE_OPERAND (e2value, 0));\n-\t    if (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (e1value))\n-\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e1value))\n-\t\t|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (e2value))\n-\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e2value)))\n+\n+\t    e1_p = VEC_index (c_expr_t, cexpr_list, 0);\n+\t    e2_p = VEC_index (c_expr_t, cexpr_list, 1);\n+\n+\t    mark_exp_read (e1_p->value);\n+\t    if (TREE_CODE (e1_p->value) == EXCESS_PRECISION_EXPR)\n+\t      e1_p->value = convert (TREE_TYPE (e1_p->value),\n+\t\t\t\t     TREE_OPERAND (e1_p->value, 0));\n+\t    mark_exp_read (e2_p->value);\n+\t    if (TREE_CODE (e2_p->value) == EXCESS_PRECISION_EXPR)\n+\t      e2_p->value = convert (TREE_TYPE (e2_p->value),\n+\t\t\t\t     TREE_OPERAND (e2_p->value, 0));\n+\t    if (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (e1_p->value))\n+\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e1_p->value))\n+\t\t|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (e2_p->value))\n+\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e2_p->value)))\n \t      {\n \t\terror_at (loc, \"%<__builtin_complex%> operand \"\n \t\t\t  \"not of real binary floating-point type\");\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n-\t    if (TYPE_MAIN_VARIANT (TREE_TYPE (e1value))\n-\t\t!= TYPE_MAIN_VARIANT (TREE_TYPE (e2value)))\n+\t    if (TYPE_MAIN_VARIANT (TREE_TYPE (e1_p->value))\n+\t\t!= TYPE_MAIN_VARIANT (TREE_TYPE (e2_p->value)))\n \t      {\n \t\terror_at (loc,\n \t\t\t  \"%<__builtin_complex%> operands of different types\");\n@@ -6518,34 +6513,37 @@ c_parser_postfix_expression (c_parser *parser)\n \t      pedwarn (loc, OPT_pedantic,\n \t\t       \"ISO C90 does not support complex types\");\n \t    expr.value = build2 (COMPLEX_EXPR,\n-\t\t\t\t build_complex_type (TYPE_MAIN_VARIANT\n-\t\t\t\t\t\t     (TREE_TYPE (e1value))),\n-\t\t\t\t e1value, e2value);\n+\t\t\t\t build_complex_type\n+\t\t\t\t   (TYPE_MAIN_VARIANT\n+\t\t\t\t     (TREE_TYPE (e1_p->value))),\n+\t\t\t\t e1_p->value, e2_p->value);\n \t    break;\n \t  }\n \tcase RID_BUILTIN_SHUFFLE:\n \t  {\n-\t    VEC(tree,gc) *expr_list;\n-\t    \n+\t    VEC(c_expr_t,gc) *cexpr_list;\n+\n \t    c_parser_consume_token (parser);\n \t    if (!c_parser_get_builtin_args (parser,\n \t\t\t\t\t    \"__builtin_shuffle\",\n-\t\t\t\t\t    &expr_list, NULL))\n+\t\t\t\t\t    &cexpr_list))\n \t      {\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n \n-\t    if (VEC_length (tree, expr_list) == 2)\n-\t      expr.value = c_build_vec_shuffle_expr\n-\t\t\t\t(loc, VEC_index (tree, expr_list, 0),\n-\t\t\t\t NULL_TREE,\n-\t\t\t\t VEC_index (tree, expr_list, 1));\n-\t    else if (VEC_length (tree, expr_list) == 3)\n-\t      expr.value = c_build_vec_shuffle_expr\n-\t\t\t\t(loc, VEC_index (tree, expr_list, 0),\n-\t\t\t\t VEC_index (tree, expr_list, 1),\n-\t\t\t\t VEC_index (tree, expr_list, 2));\n+\t    if (VEC_length (c_expr_t, cexpr_list) == 2)\n+\t      expr.value =\n+\t\tc_build_vec_shuffle_expr\n+\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0)->value,\n+\t\t   NULL_TREE, VEC_index (c_expr_t, cexpr_list, 1)->value);\n+\n+\t    else if (VEC_length (c_expr_t, cexpr_list) == 3)\n+\t      expr.value =\n+\t\tc_build_vec_shuffle_expr\n+\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0)->value,\n+\t\t   VEC_index (c_expr_t, cexpr_list, 1)->value,\n+\t\t   VEC_index (c_expr_t, cexpr_list, 2)->value);\n \t    else\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \""}, {"sha": "0e465257c78d8e2d5b53d0a1bc08e68a1573bdaf", "filename": "gcc/c-tree.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86785830c3d253af451018ac69278bf6ba2e8fd6/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=86785830c3d253af451018ac69278bf6ba2e8fd6", "patch": "@@ -130,6 +130,22 @@ struct c_expr\n   tree original_type;\n };\n \n+/* Type alias for struct c_expr. This allows to use the structure\n+   inside the VEC types.  */\n+typedef struct c_expr c_expr_t;\n+\n+/* A varray of c_expr_t.  */\n+DEF_VEC_O (c_expr_t);\n+DEF_VEC_ALLOC_O (c_expr_t, gc);\n+DEF_VEC_ALLOC_O (c_expr_t, heap);\n+\n+/* Append a new c_expr_t element to V.  */\n+#define C_EXPR_APPEND(V, ELEM) \\\n+  do { \\\n+    c_expr_t *__elem_p = VEC_safe_push (c_expr_t, gc, V, NULL); \\\n+    *__elem_p = (ELEM); \\\n+  } while (0)\n+\n /* A kind of type specifier.  Note that this information is currently\n    only used to distinguish tag definitions, tag references and typeof\n    uses.  */"}]}