{"sha": "011d50d946a1c854e19d0be0aff69de6f97f6eaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDExZDUwZDk0NmExYzg1NGUxOWQwYmUwYWZmNjlkZTZmOTdmNmVhZg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-09-14T09:42:57Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-09-14T09:42:57Z"}, "message": "objc-act.c: Convert to ISO C90 prototypes.\n\n\t* objc/objc-act.c: Convert to ISO C90 prototypes.\n\t* objc/objc-act.h: Likewise.\n\nFrom-SVN: r71371", "tree": {"sha": "07f918f1202000fb205535af21723871acbb17da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07f918f1202000fb205535af21723871acbb17da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/011d50d946a1c854e19d0be0aff69de6f97f6eaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011d50d946a1c854e19d0be0aff69de6f97f6eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011d50d946a1c854e19d0be0aff69de6f97f6eaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011d50d946a1c854e19d0be0aff69de6f97f6eaf/comments", "author": null, "committer": null, "parents": [{"sha": "a56d737201475bd1c6625ee2624daa35760ed2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56d737201475bd1c6625ee2624daa35760ed2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56d737201475bd1c6625ee2624daa35760ed2f4"}], "stats": {"total": 1185, "additions": 471, "deletions": 714}, "files": [{"sha": "92fc97db56e8caa40365dce51a4b7473eedebe70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=011d50d946a1c854e19d0be0aff69de6f97f6eaf", "patch": "@@ -1,3 +1,12 @@\n+2003-09-14  Andreas Jaeger  <aj@suse.de>\n+\n+\t* objc/objc-act.c: Convert to ISO C90 prototypes.\n+\t* objc/objc-act.h: Likewise.\n+\n+2003-09-14  Olaf Hering  <olh@suse.de>\n+\n+\t* config/rs6000/rs6000.c: Fix typo: Remove extra ')'.\n+\n 2003-09-13  Andrew Pinski <pinskia@physics.uc.edu>\n \n \tPR target/12021"}, {"sha": "3532d481b1564627959435b00bb795cc380fedc8", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 420, "deletions": 672, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=011d50d946a1c854e19d0be0aff69de6f97f6eaf", "patch": "@@ -111,76 +111,71 @@ char *util_firstobj;\n #define PROTOCOL_VERSION 2\n \n /* (Decide if these can ever be validly changed.) */\n-#define OBJC_ENCODE_INLINE_DEFS \t0\n+#define OBJC_ENCODE_INLINE_DEFS\t0\n #define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n \n /*** Private Interface (procedures) ***/\n \n /* Used by compile_file.  */\n \n-static void init_objc\t\t\t\tPARAMS ((void));\n-static void finish_objc\t\t\t\tPARAMS ((void));\n+static void init_objc (void);\n+static void finish_objc (void);\n \n /* Code generation.  */\n \n-static void synth_module_prologue\t\tPARAMS ((void));\n-static tree objc_build_constructor\t\tPARAMS ((tree, tree));\n-static rtx build_module_descriptor\t\tPARAMS ((void));\n-static tree init_module_descriptor\t\tPARAMS ((tree));\n-static tree build_objc_method_call\t\tPARAMS ((int, tree, tree,\n-\t\t\t\t\t\t       tree, tree, tree));\n-static void generate_strings\t\t\tPARAMS ((void));\n-static tree get_proto_encoding \t\t\tPARAMS ((tree));\n-static void build_selector_translation_table\tPARAMS ((void));\n-\n-static tree objc_add_static_instance\t\tPARAMS ((tree, tree));\n-\n-static tree build_ivar_template\t\t\tPARAMS ((void));\n-static tree build_method_template\t\tPARAMS ((void));\n-static tree build_private_template\t\tPARAMS ((tree));\n-static void build_class_template\t\tPARAMS ((void));\n-static void build_selector_template\t\tPARAMS ((void));\n-static void build_category_template\t\tPARAMS ((void));\n-static tree build_super_template\t\tPARAMS ((void));\n-static tree build_category_initializer\t\tPARAMS ((tree, tree, tree,\n-\t\t\t\t\t\t       tree, tree, tree));\n-static tree build_protocol_initializer\t\tPARAMS ((tree, tree, tree,\n-\t\t\t\t\t\t       tree, tree));\n-\n-static void synth_forward_declarations\t\tPARAMS ((void));\n-static void generate_ivar_lists\t\t\tPARAMS ((void));\n-static void generate_dispatch_tables\t\tPARAMS ((void));\n-static void generate_shared_structures\t\tPARAMS ((void));\n-static tree generate_protocol_list\t\tPARAMS ((tree));\n-static void generate_forward_declaration_to_string_table PARAMS ((void));\n-static void build_protocol_reference\t\tPARAMS ((tree));\n-\n-static tree build_keyword_selector\t\tPARAMS ((tree));\n-static tree synth_id_with_class_suffix\t\tPARAMS ((const char *, tree));\n-\n-static void generate_static_references\t\tPARAMS ((void));\n-static int check_methods_accessible\t\tPARAMS ((tree, tree,\n-\t\t\t\t\t\t       int));\n-static void encode_aggregate_within\t\tPARAMS ((tree, int, int,\n-\t\t\t\t\t               int, int));\n-static const char *objc_demangle\t\tPARAMS ((const char *));\n-static void objc_expand_function_end            PARAMS ((void));\n+static void synth_module_prologue (void);\n+static tree objc_build_constructor (tree, tree);\n+static rtx build_module_descriptor (void);\n+static tree init_module_descriptor (tree);\n+static tree build_objc_method_call (int, tree, tree, tree, tree, tree);\n+static void generate_strings (void);\n+static tree get_proto_encoding (tree);\n+static void build_selector_translation_table (void);\n+\n+static tree objc_add_static_instance (tree, tree);\n+\n+static tree build_ivar_template (void);\n+static tree build_method_template (void);\n+static tree build_private_template (tree);\n+static void build_class_template (void);\n+static void build_selector_template (void);\n+static void build_category_template (void);\n+static tree build_super_template (void);\n+static tree build_category_initializer (tree, tree, tree, tree, tree, tree);\n+static tree build_protocol_initializer (tree, tree, tree, tree, tree);\n+\n+static void synth_forward_declarations (void);\n+static void generate_ivar_lists (void);\n+static void generate_dispatch_tables (void);\n+static void generate_shared_structures (void);\n+static tree generate_protocol_list (tree);\n+static void generate_forward_declaration_to_string_table (void);\n+static void build_protocol_reference (tree);\n+\n+static tree build_keyword_selector (tree);\n+static tree synth_id_with_class_suffix (const char *, tree);\n+\n+static void generate_static_references (void);\n+static int check_methods_accessible (tree, tree, int);\n+static void encode_aggregate_within (tree, int, int, int, int);\n+static const char *objc_demangle (const char *);\n+static void objc_expand_function_end (void);\n \n /* Hash tables to manage the global pool of method prototypes.  */\n \n hash *nst_method_hash_list = 0;\n hash *cls_method_hash_list = 0;\n \n-static size_t hash_func\t\t\t\tPARAMS ((tree));\n-static void hash_init\t\t\t\tPARAMS ((void));\n-static void hash_enter\t\t\t\tPARAMS ((hash *, tree));\n-static hash hash_lookup\t\t\t\tPARAMS ((hash *, tree));\n-static void hash_add_attr\t\t\tPARAMS ((hash, tree));\n-static tree lookup_method\t\t\tPARAMS ((tree, tree));\n-static tree lookup_instance_method_static\tPARAMS ((tree, tree));\n-static tree lookup_class_method_static\t\tPARAMS ((tree, tree));\n-static tree add_class\t\t\t\tPARAMS ((tree));\n-static void add_category\t\t\tPARAMS ((tree, tree));\n+static size_t hash_func (tree);\n+static void hash_init (void);\n+static void hash_enter (hash *, tree);\n+static hash hash_lookup (hash *, tree);\n+static void hash_add_attr (hash, tree);\n+static tree lookup_method (tree, tree);\n+static tree lookup_instance_method_static (tree, tree);\n+static tree lookup_class_method_static (tree, tree);\n+static tree add_class (tree);\n+static void add_category (tree, tree);\n \n enum string_section\n {\n@@ -189,113 +184,103 @@ enum string_section\n   meth_var_types\t/* method and variable type descriptors */\n };\n \n-static tree add_objc_string\t\t\tPARAMS ((tree,\n-\t\t\t\t\t\t       enum string_section));\n-static tree get_objc_string_decl\t\tPARAMS ((tree,\n-\t\t\t\t\t\t       enum string_section));\n-static tree build_objc_string_decl\t\tPARAMS ((enum string_section));\n-static tree build_selector_reference_decl\tPARAMS ((void));\n+static tree add_objc_string (tree, enum string_section);\n+static tree get_objc_string_decl (tree, enum string_section);\n+static tree build_objc_string_decl (enum string_section);\n+static tree build_selector_reference_decl (void);\n \n /* Protocol additions.  */\n \n-static tree add_protocol\t\t\tPARAMS ((tree));\n-static tree lookup_protocol\t\t\tPARAMS ((tree));\n-static void check_protocol_recursively\t\tPARAMS ((tree, tree));\n-static tree lookup_and_install_protocols\tPARAMS ((tree));\n+static tree add_protocol (tree);\n+static tree lookup_protocol (tree);\n+static void check_protocol_recursively (tree, tree);\n+static tree lookup_and_install_protocols (tree);\n \n /* Type encoding.  */\n \n-static void encode_type_qualifiers\t\tPARAMS ((tree));\n-static void encode_pointer\t\t\tPARAMS ((tree, int, int));\n-static void encode_array\t\t\tPARAMS ((tree, int, int));\n-static void encode_aggregate\t\t\tPARAMS ((tree, int, int));\n-static void encode_bitfield\t\t\tPARAMS ((int));\n-static void encode_type\t\t\t\tPARAMS ((tree, int, int));\n-static void encode_field_decl\t\t\tPARAMS ((tree, int, int));\n+static void encode_type_qualifiers (tree);\n+static void encode_pointer (tree, int, int);\n+static void encode_array (tree, int, int);\n+static void encode_aggregate (tree, int, int);\n+static void encode_bitfield (int);\n+static void encode_type (tree, int, int);\n+static void encode_field_decl (tree, int, int);\n \n-static void really_start_method\t\t\tPARAMS ((tree, tree));\n-static int comp_method_with_proto\t\tPARAMS ((tree, tree));\n-static int comp_proto_with_proto\t\tPARAMS ((tree, tree));\n-static tree get_arg_type_list\t\t\tPARAMS ((tree, int, int));\n-static tree objc_expr_last\t\t\tPARAMS ((tree));\n+static void really_start_method (tree, tree);\n+static int comp_method_with_proto (tree, tree);\n+static int comp_proto_with_proto (tree, tree);\n+static tree get_arg_type_list (tree, int, int);\n+static tree objc_expr_last (tree);\n \n /* Utilities for debugging and error diagnostics.  */\n \n-static void warn_with_method\t\t\tPARAMS ((const char *, int, tree));\n-static void error_with_ivar\t\t\tPARAMS ((const char *, tree, tree));\n-static char *gen_method_decl\t\t\tPARAMS ((tree, char *));\n-static char *gen_declaration\t\t\tPARAMS ((tree, char *));\n-static void gen_declaration_1\t\t\tPARAMS ((tree, char *));\n-static char *gen_declarator\t\t\tPARAMS ((tree, char *,\n-\t\t\t\t\t\t       const char *));\n-static int is_complex_decl\t\t\tPARAMS ((tree));\n-static void adorn_decl\t\t\t\tPARAMS ((tree, char *));\n-static void dump_interface\t\t\tPARAMS ((FILE *, tree));\n+static void warn_with_method (const char *, int, tree);\n+static void error_with_ivar (const char *, tree, tree);\n+static char *gen_method_decl (tree, char *);\n+static char *gen_declaration (tree, char *);\n+static void gen_declaration_1 (tree, char *);\n+static char *gen_declarator (tree, char *, const char *);\n+static int is_complex_decl (tree);\n+static void adorn_decl (tree, char *);\n+static void dump_interface (FILE *, tree);\n \n /* Everything else.  */\n \n-static tree define_decl\t\t\t\tPARAMS ((tree, tree));\n-static tree lookup_method_in_protocol_list\tPARAMS ((tree, tree, int));\n-static tree lookup_protocol_in_reflist\t\tPARAMS ((tree, tree));\n-static tree create_builtin_decl\t\t\tPARAMS ((enum tree_code,\n-\t\t\t\t\t\t       tree, const char *));\n-static void setup_string_decl\t\t\tPARAMS ((void));\n-static void build_string_class_template\t\tPARAMS ((void));\n-static tree my_build_string\t\t\tPARAMS ((int, const char *));\n-static void build_objc_symtab_template\t\tPARAMS ((void));\n-static tree init_def_list\t\t\tPARAMS ((tree));\n-static tree init_objc_symtab\t\t\tPARAMS ((tree));\n-static void forward_declare_categories\t\tPARAMS ((void));\n-static void generate_objc_symtab_decl\t\tPARAMS ((void));\n-static tree build_selector\t\t\tPARAMS ((tree));\n-static tree build_typed_selector_reference     \tPARAMS ((tree, tree));\n-static tree build_selector_reference\t\tPARAMS ((tree));\n-static tree build_class_reference_decl\t\tPARAMS ((void));\n-static void add_class_reference\t\t\tPARAMS ((tree));\n-static tree build_protocol_template\t\tPARAMS ((void));\n-static tree build_descriptor_table_initializer\tPARAMS ((tree, tree));\n-static tree build_method_prototype_list_template PARAMS ((tree, int));\n-static tree build_method_prototype_template\tPARAMS ((void));\n-static int forwarding_offset\t\t\tPARAMS ((tree));\n-static tree encode_method_prototype\t\tPARAMS ((tree, tree));\n-static tree generate_descriptor_table\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t       int, tree, tree));\n-static void generate_method_descriptors\t\tPARAMS ((tree));\n-static tree build_tmp_function_decl\t\tPARAMS ((void));\n-static void hack_method_prototype\t\tPARAMS ((tree, tree));\n-static void generate_protocol_references\tPARAMS ((tree));\n-static void generate_protocols\t\t\tPARAMS ((void));\n-static void check_ivars\t\t\t\tPARAMS ((tree, tree));\n-static tree build_ivar_list_template\t\tPARAMS ((tree, int));\n-static tree build_method_list_template\t\tPARAMS ((tree, int));\n-static tree build_ivar_list_initializer\t\tPARAMS ((tree, tree));\n-static tree generate_ivars_list\t\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t       int, tree));\n-static tree build_dispatch_table_initializer\tPARAMS ((tree, tree));\n-static tree generate_dispatch_table\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t       int, tree));\n-static tree build_shared_structure_initializer\tPARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t       tree, int, tree, tree,\n-\t\t\t\t\t\t       tree));\n-static void generate_category\t\t\tPARAMS ((tree));\n-static int is_objc_type_qualifier\t\tPARAMS ((tree));\n-static tree adjust_type_for_id_default\t\tPARAMS ((tree));\n-static tree check_duplicates\t\t\tPARAMS ((hash));\n-static tree receiver_is_class_object\t\tPARAMS ((tree));\n-static int check_methods\t\t\tPARAMS ((tree, tree, int));\n-static int conforms_to_protocol\t\t\tPARAMS ((tree, tree));\n-static void check_protocol\t\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t       const char *));\n-static void check_protocols\t\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t       const char *));\n-static tree encode_method_def\t\t\tPARAMS ((tree));\n-static void gen_declspecs\t\t\tPARAMS ((tree, char *, int));\n-static void generate_classref_translation_entry\tPARAMS ((tree));\n-static void handle_class_ref\t\t\tPARAMS ((tree));\n-static void generate_struct_by_value_array\tPARAMS ((void))\n+static tree define_decl (tree, tree);\n+static tree lookup_method_in_protocol_list (tree, tree, int);\n+static tree lookup_protocol_in_reflist (tree, tree);\n+static tree create_builtin_decl (enum tree_code, tree, const char *);\n+static void setup_string_decl (void);\n+static void build_string_class_template (void);\n+static tree my_build_string (int, const char *);\n+static void build_objc_symtab_template (void);\n+static tree init_def_list (tree);\n+static tree init_objc_symtab (tree);\n+static void forward_declare_categories (void);\n+static void generate_objc_symtab_decl (void);\n+static tree build_selector (tree);\n+static tree build_typed_selector_reference (tree, tree);\n+static tree build_selector_reference (tree);\n+static tree build_class_reference_decl (void);\n+static void add_class_reference (tree);\n+static tree build_protocol_template (void);\n+static tree build_descriptor_table_initializer (tree, tree);\n+static tree build_method_prototype_list_template (tree, int);\n+static tree build_method_prototype_template (void);\n+static int forwarding_offset (tree);\n+static tree encode_method_prototype (tree, tree);\n+static tree generate_descriptor_table (tree, const char *, int, tree, tree);\n+static void generate_method_descriptors (tree);\n+static tree build_tmp_function_decl (void);\n+static void hack_method_prototype (tree, tree);\n+static void generate_protocol_references (tree);\n+static void generate_protocols (void);\n+static void check_ivars (tree, tree);\n+static tree build_ivar_list_template (tree, int);\n+static tree build_method_list_template (tree, int);\n+static tree build_ivar_list_initializer (tree, tree);\n+static tree generate_ivars_list (tree, const char *, int, tree);\n+static tree build_dispatch_table_initializer (tree, tree);\n+static tree generate_dispatch_table (tree, const char *, int, tree);\n+static tree build_shared_structure_initializer (tree, tree, tree, tree, tree,\n+\t\t\t\t\t\tint, tree, tree, tree);\n+static void generate_category (tree);\n+static int is_objc_type_qualifier (tree);\n+static tree adjust_type_for_id_default (tree);\n+static tree check_duplicates (hash);\n+static tree receiver_is_class_object (tree);\n+static int check_methods (tree, tree, int);\n+static int conforms_to_protocol (tree, tree);\n+static void check_protocol (tree, const char *, const char *);\n+static void check_protocols (tree, const char *, const char *);\n+static tree encode_method_def (tree);\n+static void gen_declspecs (tree, char *, int);\n+static void generate_classref_translation_entry (tree);\n+static void handle_class_ref (tree);\n+static void generate_struct_by_value_array (void)\n      ATTRIBUTE_NORETURN;\n-static void encode_complete_bitfield\t\tPARAMS ((int, tree, int));\n-static void mark_referenced_methods\t\tPARAMS ((void));\n+static void encode_complete_bitfield (int, tree, int);\n+static void mark_referenced_methods (void);\n \n /*** Private Interface (data) ***/\n \n@@ -338,7 +323,7 @@ static const char *default_constant_string_class_name;\n /* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n \n-static void handle_impent\t\t\tPARAMS ((struct imp_entry *));\n+static void handle_impent (struct imp_entry *);\n \n struct imp_entry *imp_list = 0;\n int imp_count = 0;\t/* `@implementation' */\n@@ -374,7 +359,7 @@ static int generating_instance_variables = 0;\n    the transition point between the two possibilities.  */\n \n static void\n-generate_struct_by_value_array ()\n+generate_struct_by_value_array (void)\n {\n   tree type;\n   tree field_decl, field_decl_chain;\n@@ -405,12 +390,12 @@ generate_struct_by_value_array ()\n \t  chainon (field_decl_chain, field_decl);\n \t}\n       finish_struct (type, field_decl_chain, NULL_TREE);\n- \n+\n       aggregate_in_mem[i] = aggregate_value_p (type, 0);\n       if (!aggregate_in_mem[i])\n \tfound = 1;\n     }\n- \n+\n   /* We found some structures that are returned in registers instead of memory\n      so output the necessary data.  */\n   if (found)\n@@ -419,21 +404,21 @@ generate_struct_by_value_array ()\n \tif (!aggregate_in_mem[i])\n \t  break;\n       printf (\"#define OBJC_MAX_STRUCT_BY_VALUE %d\\n\\n\", i);\n- \n+\n       /* The first member of the structure is always 0 because we don't handle\n \t structures with 0 members */\n       printf (\"static int struct_forward_array[] = {\\n  0\");\n- \n+\n       for (j = 1; j <= i; j++)\n \tprintf (\", %d\", aggregate_in_mem[j]);\n       printf (\"\\n};\\n\");\n     }\n- \n+\n   exit (0);\n }\n \n bool\n-objc_init ()\n+objc_init (void)\n {\n   if (c_objc_common_init () == false)\n     return false;\n@@ -484,7 +469,7 @@ objc_init ()\n }\n \n void\n-finish_file ()\n+finish_file (void)\n {\n   mark_referenced_methods ();\n   c_objc_common_finish_file ();\n@@ -499,9 +484,7 @@ finish_file ()\n }\n \f\n static tree\n-define_decl (declarator, declspecs)\n-     tree declarator;\n-     tree declspecs;\n+define_decl (tree declarator, tree declspecs)\n {\n   tree decl = start_decl (declarator, declspecs, 0, NULL_TREE);\n   finish_decl (decl, NULL_TREE, NULL_TREE);\n@@ -521,10 +504,8 @@ define_decl (declarator, declspecs)\n    `a' and `b' are of class types A and B such that B is a descendant of A.  */\n \n static tree\n-lookup_method_in_protocol_list (rproto_list, sel_name, class_meth)\n-   tree rproto_list;\n-   tree sel_name;\n-   int class_meth;\n+lookup_method_in_protocol_list (tree rproto_list, tree sel_name,\n+\t\t\t\tint class_meth)\n {\n    tree rproto, p;\n    tree fnd = 0;\n@@ -556,9 +537,7 @@ lookup_method_in_protocol_list (rproto_list, sel_name, class_meth)\n }\n \n static tree\n-lookup_protocol_in_reflist (rproto_list, lproto)\n-     tree rproto_list;\n-     tree lproto;\n+lookup_protocol_in_reflist (tree rproto_list, tree lproto)\n {\n   tree rproto, p;\n \n@@ -611,10 +590,7 @@ lookup_protocol_in_reflist (rproto_list, lproto)\n */\n \n int\n-objc_comptypes (lhs, rhs, reflexive)\n-     tree lhs;\n-     tree rhs;\n-     int reflexive;\n+objc_comptypes (tree lhs, tree rhs, int reflexive)\n {\n   /* New clause for protocols.  */\n \n@@ -638,20 +614,20 @@ objc_comptypes (lhs, rhs, reflexive)\n \t  if (rhs_is_proto)\n \t    {\n \t      rproto_list = TYPE_PROTOCOL_LIST (rhs);\n-\t      \n+\n \t      if (!reflexive)\n \t\t{\n \t\t  /* An assignment between objects of type 'id\n \t\t     <Protocol>'; make sure the protocol on the lhs is\n \t\t     supported by the object on the rhs.  */\n-\t\t  for (lproto = lproto_list; lproto; \n+\t\t  for (lproto = lproto_list; lproto;\n \t\t       lproto = TREE_CHAIN (lproto))\n \t\t    {\n \t\t      p = TREE_VALUE (lproto);\n \t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n \n \t\t      if (!rproto)\n-\t\t\twarning \n+\t\t\twarning\n \t\t\t  (\"object does not conform to the `%s' protocol\",\n \t\t\t   IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n \t\t    }\n@@ -663,20 +639,20 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t     of type 'id <Protocol>'.  Check that either the\n \t\t     protocol on the lhs is supported by the object on\n \t\t     the rhs, or viceversa.  */\n-\t\t  \n+\n \t\t  /* Check if the protocol on the lhs is supported by the\n \t\t     object on the rhs.  */\n-\t\t  for (lproto = lproto_list; lproto; \n+\t\t  for (lproto = lproto_list; lproto;\n \t\t       lproto = TREE_CHAIN (lproto))\n \t\t    {\n \t\t      p = TREE_VALUE (lproto);\n \t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\t\t      \n+\n \t\t      if (!rproto)\n \t\t\t{\n \t\t\t  /* Check failed - check if the protocol on the rhs\n \t\t\t     is supported by the object on the lhs.  */\n-\t\t\t  for (rproto = rproto_list; rproto; \n+\t\t\t  for (rproto = rproto_list; rproto;\n \t\t\t       rproto = TREE_CHAIN (rproto))\n \t\t\t    {\n \t\t\t      p = TREE_VALUE (rproto);\n@@ -767,10 +743,10 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t  tree rname = TYPE_NAME (TREE_TYPE (lhs));\n \t\t  tree rinter;\n \t\t  tree rproto, rproto_list = TYPE_PROTOCOL_LIST (rhs);\n-\t\t  \n+\n \t\t  /* Make sure the protocol is supported by the object on\n \t\t     the lhs.  */\n-\t\t  for (rproto = rproto_list; rproto; \n+\t\t  for (rproto = rproto_list; rproto;\n \t\t       rproto = TREE_CHAIN (rproto))\n \t\t    {\n \t\t      tree p = TREE_VALUE (rproto);\n@@ -790,9 +766,9 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t\t     lhs.  */\n \t\t\t  if (!lproto)\n \t\t\t    {\n-\t\t\t      lproto_list = TYPE_PROTOCOL_LIST \n+\t\t\t      lproto_list = TYPE_PROTOCOL_LIST\n \t\t\t\t(TREE_TYPE (lhs));\n-\t\t\t      lproto = lookup_protocol_in_reflist \n+\t\t\t      lproto = lookup_protocol_in_reflist\n \t\t\t\t(lproto_list, p);\n \t\t\t    }\n \n@@ -805,14 +781,14 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t\t\t\t\t\t\t   p);\n \t\t\t      cat = CLASS_CATEGORY_LIST (cat);\n \t\t\t    }\n-\t\t\t  \n-\t\t\t  rinter = lookup_interface (CLASS_SUPER_NAME \n+\n+\t\t\t  rinter = lookup_interface (CLASS_SUPER_NAME\n \t\t\t\t\t\t     (rinter));\n \t\t\t}\n-\t\t      \n+\n \t\t      if (!lproto)\n \t\t\twarning (\"class `%s' does not implement the `%s' protocol\",\n-\t\t\t\t IDENTIFIER_POINTER (TYPE_NAME \n+\t\t\t\t IDENTIFIER_POINTER (TYPE_NAME\n \t\t\t\t\t\t     (TREE_TYPE (lhs))),\n \t\t\t\t IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n \t\t    }\n@@ -856,7 +832,7 @@ objc_comptypes (lhs, rhs, reflexive)\n     }\n \n   /* `id' = `<class> *' `<class> *' = `id': always allow it.\n-     Please note that \n+     Please note that\n      'Object *o = [[Object alloc] init]; falls\n      in the case <class> * = `id'.\n   */\n@@ -907,8 +883,7 @@ objc_comptypes (lhs, rhs, reflexive)\n /* Called from c-decl.c before all calls to rest_of_decl_compilation.  */\n \n void\n-objc_check_decl (decl)\n-     tree decl;\n+objc_check_decl (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -922,9 +897,7 @@ objc_check_decl (decl)\n /* Implement static typing.  At this point, we know we have an interface.  */\n \n tree\n-get_static_reference (interface, protocols)\n-     tree interface;\n-     tree protocols;\n+get_static_reference (tree interface, tree protocols)\n {\n   tree type = xref_tag (RECORD_TYPE, interface);\n \n@@ -955,8 +928,7 @@ get_static_reference (interface, protocols)\n }\n \n tree\n-get_object_reference (protocols)\n-     tree protocols;\n+get_object_reference (tree protocols)\n {\n   tree type_decl = lookup_name (objc_id_id);\n   tree type;\n@@ -1006,10 +978,8 @@ get_object_reference (protocols)\n    PROTO, the protocol to check, and LIST, a list of protocol it\n    conforms to.  */\n \n-static void \n-check_protocol_recursively (proto, list)\n-     tree proto;\n-     tree list;\n+static void\n+check_protocol_recursively (tree proto, tree list)\n {\n   tree p;\n \n@@ -1022,15 +992,14 @@ check_protocol_recursively (proto, list)\n \n       if (pp == proto)\n \tfatal_error (\"protocol `%s' has circular dependency\",\n-\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (pp)));      \n+\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (pp)));\n       if (pp)\n \tcheck_protocol_recursively (proto, PROTOCOL_LIST (pp));\n     }\n }\n \n static tree\n-lookup_and_install_protocols (protocols)\n-     tree protocols;\n+lookup_and_install_protocols (tree protocols)\n {\n   tree proto;\n   tree prev = NULL;\n@@ -1066,10 +1035,7 @@ lookup_and_install_protocols (protocols)\n    TYPE is its data type.  */\n \n static tree\n-create_builtin_decl (code, type, name)\n-     enum tree_code code;\n-     tree type;\n-     const char *name;\n+create_builtin_decl (enum tree_code code, tree type, const char *name)\n {\n   tree decl = build_decl (code, get_identifier (name), type);\n \n@@ -1087,7 +1053,7 @@ create_builtin_decl (code, type, name)\n /* Find the decl for the constant string class.  */\n \n static void\n-setup_string_decl ()\n+setup_string_decl (void)\n {\n   if (!string_class_decl)\n     {\n@@ -1102,14 +1068,14 @@ setup_string_decl ()\n \n    Model:\n \n- \ttype_spec--------->sc_spec\n- \t(tree_list)        (tree_list)\n- \t    |                  |\n- \t    |                  |\n- \tidentifier_node    identifier_node  */\n+\ttype_spec--------->sc_spec\n+\t(tree_list)        (tree_list)\n+\t    |                  |\n+\t    |                  |\n+\tidentifier_node    identifier_node  */\n \n static void\n-synth_module_prologue ()\n+synth_module_prologue (void)\n {\n   tree temp_type;\n   tree super_p;\n@@ -1239,15 +1205,15 @@ synth_module_prologue ()\n \n /* Predefine the following data type:\n \n-   struct STRING_OBJECT_CLASS_NAME \n+   struct STRING_OBJECT_CLASS_NAME\n    {\n      Object isa;\n      char *cString;\n      unsigned int length;\n    }; */\n \n static void\n-build_string_class_template ()\n+build_string_class_template (void)\n {\n   tree field_decl, field_decl_chain;\n \n@@ -1268,9 +1234,7 @@ build_string_class_template ()\n /* Custom build_string which sets TREE_TYPE!  */\n \n static tree\n-my_build_string (len, str)\n-     int len;\n-     const char *str;\n+my_build_string (int len, const char *str)\n {\n   return fix_string_type (build_string (len, str));\n }\n@@ -1283,8 +1247,7 @@ my_build_string (len, str)\n    class object.  */\n \n tree\n-build_objc_string_object (string)\n-     tree string;\n+build_objc_string_object (tree string)\n {\n   tree initlist, constructor;\n   int length;\n@@ -1347,8 +1310,7 @@ build_objc_string_object (string)\n \n static GTY(()) int num_static_inst;\n static tree\n-objc_add_static_instance (constructor, class_decl)\n-     tree constructor, class_decl;\n+objc_add_static_instance (tree constructor, tree class_decl)\n {\n   tree *chain, decl;\n   char buf[256];\n@@ -1387,8 +1349,7 @@ objc_add_static_instance (constructor, class_decl)\n    with type TYPE and elements ELTS.  */\n \n static tree\n-objc_build_constructor (type, elts)\n-     tree type, elts;\n+objc_build_constructor (tree type, tree elts)\n {\n   tree constructor, f, e;\n \n@@ -1432,7 +1393,7 @@ objc_build_constructor (type, elts)\n    }; */\n \n static void\n-build_objc_symtab_template ()\n+build_objc_symtab_template (void)\n {\n   tree field_decl, field_decl_chain, index;\n \n@@ -1487,8 +1448,7 @@ build_objc_symtab_template ()\n    This is a CONSTRUCTOR.  */\n \n static tree\n-init_def_list (type)\n-     tree type;\n+init_def_list (tree type)\n {\n   tree expr, initlist = NULL_TREE;\n   struct imp_entry *impent;\n@@ -1532,8 +1492,7 @@ init_def_list (type)\n /* Construct the initial value for all of _objc_symtab.  */\n \n static tree\n-init_objc_symtab (type)\n-     tree type;\n+init_objc_symtab (tree type)\n {\n   tree initlist;\n \n@@ -1578,7 +1537,7 @@ init_objc_symtab (type)\n    init_def_list can use them in a CONSTRUCTOR.  */\n \n static void\n-forward_declare_categories ()\n+forward_declare_categories (void)\n {\n   struct imp_entry *impent;\n   tree sav = objc_implementation_context;\n@@ -1602,7 +1561,7 @@ forward_declare_categories ()\n    and initialized appropriately.  */\n \n static void\n-generate_objc_symtab_decl ()\n+generate_objc_symtab_decl (void)\n {\n   tree sc_spec;\n \n@@ -1633,8 +1592,7 @@ generate_objc_symtab_decl ()\n }\n \f\n static tree\n-init_module_descriptor (type)\n-     tree type;\n+init_module_descriptor (tree type)\n {\n   tree initlist, expr;\n \n@@ -1672,7 +1630,7 @@ init_module_descriptor (type)\n    struct objc_module { ... } _OBJC_MODULE = { ... };   */\n \n static rtx\n-build_module_descriptor ()\n+build_module_descriptor (void)\n {\n   tree decl_specs, field_decl, field_decl_chain;\n \n@@ -1793,7 +1751,7 @@ build_module_descriptor ()\n /* extern const char _OBJC_STRINGS[]; */\n \n static void\n-generate_forward_declaration_to_string_table ()\n+generate_forward_declaration_to_string_table (void)\n {\n   tree sc_spec, decl_specs, expr_decl;\n \n@@ -1809,9 +1767,7 @@ generate_forward_declaration_to_string_table ()\n /* Return the DECL of the string IDENT in the SECTION.  */\n \n static tree\n-get_objc_string_decl (ident, section)\n-     tree ident;\n-     enum string_section section;\n+get_objc_string_decl (tree ident, enum string_section section)\n {\n   tree chain;\n \n@@ -1836,7 +1792,7 @@ get_objc_string_decl (ident, section)\n    for the array built.  */\n \n static void\n-generate_static_references ()\n+generate_static_references (void)\n {\n   tree decls = NULL_TREE, ident, decl_spec, expr_decl, expr = NULL_TREE;\n   tree class_name, class, decl, initlist;\n@@ -1912,7 +1868,7 @@ generate_static_references ()\n /* Output all strings.  */\n \n static void\n-generate_strings ()\n+generate_strings (void)\n {\n   tree sc_spec, decl_specs, expr_decl;\n   tree chain, string_expr;\n@@ -1966,7 +1922,7 @@ generate_strings ()\n \n static GTY(()) int selector_reference_idx;\n static tree\n-build_selector_reference_decl ()\n+build_selector_reference_decl (void)\n {\n   tree decl, ident;\n   char buf[256];\n@@ -1992,8 +1948,7 @@ build_selector_reference_decl ()\n /* Just a handy wrapper for add_objc_string.  */\n \n static tree\n-build_selector (ident)\n-     tree ident;\n+build_selector (tree ident)\n {\n   tree expr = add_objc_string (ident, meth_var_names);\n   if (flag_typed_selectors)\n@@ -2003,7 +1958,7 @@ build_selector (ident)\n }\n \n static void\n-build_selector_translation_table ()\n+build_selector_translation_table (void)\n {\n   tree sc_spec, decl_specs;\n   tree chain, initlist = NULL_TREE;\n@@ -2063,7 +2018,7 @@ build_selector_translation_table ()\n \n       if (flag_next_runtime)\n \tfinish_decl (decl, expr, NULL_TREE);\n-      else \n+      else\n \t{\n \t  if (flag_typed_selectors)\n \t    {\n@@ -2075,7 +2030,7 @@ build_selector_translation_table ()\n \t\t\t\t\t     nreverse (eltlist));\n \t    }\n \t  initlist = tree_cons (NULL_TREE, expr, initlist);\n-\t  \n+\n \t}\n     }\n \n@@ -2095,8 +2050,7 @@ build_selector_translation_table ()\n }\n \n static tree\n-get_proto_encoding (proto)\n-     tree proto;\n+get_proto_encoding (tree proto)\n {\n   tree encoding;\n   if (proto)\n@@ -2123,8 +2077,7 @@ get_proto_encoding (proto)\n    identifier_node that represent the selector.  */\n \n static tree\n-build_typed_selector_reference (ident, prototype)\n-     tree ident, prototype;\n+build_typed_selector_reference (tree ident, tree prototype)\n {\n   tree *chain = &sel_ref_chain;\n   tree expr;\n@@ -2150,8 +2103,7 @@ build_typed_selector_reference (ident, prototype)\n }\n \n static tree\n-build_selector_reference (ident)\n-     tree ident;\n+build_selector_reference (tree ident)\n {\n   tree *chain = &sel_ref_chain;\n   tree expr;\n@@ -2181,7 +2133,7 @@ build_selector_reference (ident)\n \n static GTY(()) int class_reference_idx;\n static tree\n-build_class_reference_decl ()\n+build_class_reference_decl (void)\n {\n   tree decl, ident;\n   char buf[256];\n@@ -2208,8 +2160,7 @@ build_class_reference_decl ()\n    it.  */\n \n static void\n-add_class_reference (ident)\n-     tree ident;\n+add_class_reference (tree ident)\n {\n   tree chain;\n \n@@ -2237,8 +2188,7 @@ add_class_reference (ident)\n    reference variable.  */\n \n tree\n-get_class_reference (ident)\n-     tree ident;\n+get_class_reference (tree ident)\n {\n   if (flag_next_runtime)\n     {\n@@ -2277,9 +2227,7 @@ get_class_reference (ident)\n    to decls for the strings.  */\n \n static tree\n-add_objc_string (ident, section)\n-     tree ident;\n-     enum string_section section;\n+add_objc_string (tree ident, enum string_section section)\n {\n   tree *chain, decl;\n \n@@ -2312,8 +2260,7 @@ static GTY(()) int meth_var_names_idx;\n static GTY(()) int meth_var_types_idx;\n \n static tree\n-build_objc_string_decl (section)\n-     enum string_section section;\n+build_objc_string_decl (enum string_section section)\n {\n   tree decl, ident;\n   char buf[256];\n@@ -2335,7 +2282,7 @@ build_objc_string_decl (section)\n   TREE_CONSTANT (decl) = 1;\n   DECL_CONTEXT (decl) = 0;\n   DECL_ARTIFICIAL (decl) = 1;\n- \n+\n   make_decl_rtl (decl, 0);\n   pushdecl_top_level (decl);\n \n@@ -2344,9 +2291,7 @@ build_objc_string_decl (section)\n \n \n void\n-objc_declare_alias (alias_ident, class_ident)\n-     tree alias_ident;\n-     tree class_ident;\n+objc_declare_alias (tree alias_ident, tree class_ident)\n {\n   if (is_class_name (class_ident) != class_ident)\n     warning (\"cannot find class `%s'\", IDENTIFIER_POINTER (class_ident));\n@@ -2357,8 +2302,7 @@ objc_declare_alias (alias_ident, class_ident)\n }\n \n void\n-objc_declare_class (ident_list)\n-     tree ident_list;\n+objc_declare_class (tree ident_list)\n {\n   tree list;\n \n@@ -2385,8 +2329,7 @@ objc_declare_class (ident_list)\n }\n \n tree\n-is_class_name (ident)\n-     tree ident;\n+is_class_name (tree ident)\n {\n   tree chain;\n \n@@ -2409,19 +2352,17 @@ is_class_name (ident)\n }\n \n tree\n-objc_is_id (ident)\n-     tree ident;\n+objc_is_id (tree ident)\n {\n   /* NB: This function may be called before the ObjC front-end\n      has been initialized, in which case ID_TYPE will be NULL. */\n-  return (id_type && ident && TYPE_P (ident) && IS_ID (ident)) \n-\t  ? id_type \n+  return (id_type && ident && TYPE_P (ident) && IS_ID (ident))\n+\t  ? id_type\n \t  : NULL_TREE;\n }\n \n tree\n-lookup_interface (ident)\n-     tree ident;\n+lookup_interface (tree ident)\n {\n   tree chain;\n \n@@ -2437,8 +2378,7 @@ lookup_interface (ident)\n    and for @defs constructs.  */\n \n tree\n-get_class_ivars (interface)\n-     tree interface;\n+get_class_ivars (tree interface)\n {\n   tree my_name, super_name, ivar_chain;\n \n@@ -2493,8 +2433,7 @@ get_class_ivars (interface)\n    };  */\n \n static tree\n-build_private_template (class)\n-     tree class;\n+build_private_template (tree class)\n {\n   tree ivar_context;\n \n@@ -2536,7 +2475,7 @@ build_private_template (class)\n    };  */\n \n static tree\n-build_protocol_template ()\n+build_protocol_template (void)\n {\n   tree decl_specs, field_decl, field_decl_chain;\n   tree template;\n@@ -2594,9 +2533,7 @@ build_protocol_template ()\n }\n \n static tree\n-build_descriptor_table_initializer (type, entries)\n-     tree type;\n-     tree entries;\n+build_descriptor_table_initializer (tree type, tree entries)\n {\n   tree initlist = NULL_TREE;\n \n@@ -2629,15 +2566,13 @@ build_descriptor_table_initializer (type, entries)\n /* struct objc_method_prototype_list {\n      int count;\n      struct objc_method_prototype {\n- \tSEL name;\n- \tchar *types;\n+\tSEL name;\n+\tchar *types;\n      } list[1];\n    };  */\n \n static tree\n-build_method_prototype_list_template (list_type, size)\n-     tree list_type;\n-     int size;\n+build_method_prototype_list_template (tree list_type, int size)\n {\n   tree objc_ivar_list_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -2667,7 +2602,7 @@ build_method_prototype_list_template (list_type, size)\n }\n \n static tree\n-build_method_prototype_template ()\n+build_method_prototype_template (void)\n {\n   tree proto_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -2697,8 +2632,7 @@ build_method_prototype_template ()\n static int offset_is_register;\n \n static int\n-forwarding_offset (parm)\n-      tree parm;\n+forwarding_offset (tree parm)\n {\n   int offset_in_bytes;\n \n@@ -2742,9 +2676,7 @@ forwarding_offset (parm)\n }\n \n static tree\n-encode_method_prototype (method_decl, func_decl)\n-      tree method_decl;\n-      tree func_decl;\n+encode_method_prototype (tree method_decl, tree func_decl)\n {\n   tree parms;\n   int stack_size, i;\n@@ -2788,7 +2720,7 @@ encode_method_prototype (method_decl, func_decl)\n         {\n \t  encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (user_args)));\n \t  user_args = TREE_CHAIN (user_args);\n- \t}\n+\t}\n \n       /* Type.  */\n       encode_type (TREE_TYPE (parms),\n@@ -2801,7 +2733,7 @@ encode_method_prototype (method_decl, func_decl)\n       /* Indicate register.  */\n       if (offset_is_register)\n \tobstack_1grow (&util_obstack, '+');\n-      \n+\n       obstack_grow (&util_obstack, buf, strlen (buf));\n     }\n \n@@ -2812,12 +2744,8 @@ encode_method_prototype (method_decl, func_decl)\n }\n \n static tree\n-generate_descriptor_table (type, name, size, list, proto)\n-     tree type;\n-     const char *name;\n-     int size;\n-     tree list;\n-     tree proto;\n+generate_descriptor_table (tree type, const char *name, int size, tree list,\n+\t\t\t   tree proto)\n {\n   tree sc_spec, decl_specs, decl, initlist;\n \n@@ -2838,8 +2766,7 @@ generate_descriptor_table (type, name, size, list, proto)\n }\n \n static void\n-generate_method_descriptors (protocol)\n-     tree protocol;\n+generate_method_descriptors (tree protocol)\n {\n   tree initlist, chain, method_list_template;\n   tree cast, variable_length_type;\n@@ -2862,7 +2789,7 @@ generate_method_descriptors (protocol)\n \t= build_method_prototype_list_template (objc_method_prototype_template,\n \t\t\t\t\t\tsize);\n \n-      initlist \n+      initlist\n \t= build_descriptor_table_initializer (objc_method_prototype_template,\n \t\t\t\t\t      chain);\n \n@@ -2902,12 +2829,12 @@ generate_method_descriptors (protocol)\n \n static GTY(()) int build_tmp_function_decl_xxx;\n static tree\n-build_tmp_function_decl ()\n+build_tmp_function_decl (void)\n {\n   tree decl_specs, expr_decl, parms;\n   char buffer[80];\n   tree tmp_decl;\n-  \n+\n   /* struct objc_object *objc_xxx (id, SEL, ...); */\n   pushlevel (0);\n   decl_specs = build_tree_list (NULL_TREE, objc_object_reference);\n@@ -2933,7 +2860,7 @@ build_tmp_function_decl ()\n \n   tmp_decl = define_decl (expr_decl, decl_specs);\n   DECL_SOURCE_LINE (tmp_decl) = 0;\n-  \n+\n   return tmp_decl;\n }\n \n@@ -2945,9 +2872,7 @@ build_tmp_function_decl ()\n    given.  */\n \n static void\n-hack_method_prototype (nst_methods, tmp_decl)\n-     tree nst_methods;\n-     tree tmp_decl;\n+hack_method_prototype (tree nst_methods, tree tmp_decl)\n {\n   tree parms;\n   tree parm;\n@@ -2997,8 +2922,7 @@ hack_method_prototype (nst_methods, tmp_decl)\n }\n \n static void\n-generate_protocol_references (plist)\n-     tree plist;\n+generate_protocol_references (tree plist)\n {\n   tree lproto;\n \n@@ -3030,7 +2954,7 @@ generate_protocol_references (plist)\n    @protocol() or from a class/category implementation).  These\n    statically allocated objects can be referred to via the static\n    (that is, private to this module) symbols _OBJC_PROTOCOL_n.\n-   \n+\n    The statically allocated Protocol objects that we generate here\n    need to be fixed up at runtime in order to be used: the 'isa'\n   pointer of the objects need to be set up to point to the 'Protocol'\n@@ -3057,7 +2981,7 @@ generate_protocol_references (plist)\n    and end up being fixed up multiple times at runtime inizialization.\n    But that doesn't hurt, it's just a little inefficient.  */\n static void\n-generate_protocols ()\n+generate_protocols (void)\n {\n   tree p, tmp_decl, encoding;\n   tree sc_spec, decl_specs, decl;\n@@ -3158,13 +3082,9 @@ generate_protocols ()\n }\n \n static tree\n-build_protocol_initializer (type, protocol_name, protocol_list,\n-\t\t\t    instance_methods, class_methods)\n-     tree type;\n-     tree protocol_name;\n-     tree protocol_list;\n-     tree instance_methods;\n-     tree class_methods;\n+build_protocol_initializer (tree type, tree protocol_name,\n+\t\t\t    tree protocol_list, tree instance_methods,\n+\t\t\t    tree class_methods)\n {\n   tree initlist = NULL_TREE, expr;\n   tree cast_type;\n@@ -3213,7 +3133,7 @@ build_protocol_initializer (type, protocol_name, protocol_list,\n    };   */\n \n static void\n-build_category_template ()\n+build_category_template (void)\n {\n   tree decl_specs, field_decl, field_decl_chain;\n \n@@ -3274,12 +3194,12 @@ build_category_template ()\n    }; */\n \n static void\n-build_selector_template ()\n+build_selector_template (void)\n {\n \n   tree decl_specs, field_decl, field_decl_chain;\n \n-  objc_selector_template \n+  objc_selector_template\n     = start_struct (RECORD_TYPE, get_identifier (UTAG_SELECTOR));\n \n   /* void *sel_id; */\n@@ -3320,7 +3240,7 @@ build_selector_template ()\n    };  */\n \n static void\n-build_class_template ()\n+build_class_template (void)\n {\n   tree decl_specs, field_decl, field_decl_chain;\n \n@@ -3429,7 +3349,7 @@ build_class_template ()\n \n   /* struct objc_protocol **protocol_list; */\n \n-  decl_specs = build_tree_list (NULL_TREE, \n+  decl_specs = build_tree_list (NULL_TREE,\n \t\t\t\txref_tag (RECORD_TYPE,\n \t\t\t\t\t  get_identifier (UTAG_PROTOCOL)));\n   field_decl\n@@ -3459,7 +3379,7 @@ build_class_template ()\n /* Generate appropriate forward declarations for an implementation.  */\n \n static void\n-synth_forward_declarations ()\n+synth_forward_declarations (void)\n {\n   tree sc_spec, decl_specs, an_id;\n \n@@ -3492,20 +3412,15 @@ synth_forward_declarations ()\n }\n \n static void\n-error_with_ivar (message, decl, rawdecl)\n-     const char *message;\n-     tree decl;\n-     tree rawdecl;\n+error_with_ivar (const char *message, tree decl, tree rawdecl)\n {\n   error (\"%H%s `%s'\", &DECL_SOURCE_LOCATION (decl),\n          message, gen_declaration (rawdecl, errbuf));\n \n }\n \n static void\n-check_ivars (inter, imp)\n-     tree inter;\n-     tree imp;\n+check_ivars (tree inter, tree imp)\n {\n   tree intdecls = CLASS_IVARS (inter);\n   tree impdecls = CLASS_IVARS (imp);\n@@ -3562,7 +3477,7 @@ check_ivars (inter, imp)\n    This needs to be done just once per compilation.  */\n \n static tree\n-build_super_template ()\n+build_super_template (void)\n {\n   tree record, decl_specs, field_decl, field_decl_chain;\n \n@@ -3602,7 +3517,7 @@ build_super_template ()\n    };  */\n \n static tree\n-build_ivar_template ()\n+build_ivar_template (void)\n {\n   tree objc_ivar_id, objc_ivar_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -3645,9 +3560,7 @@ build_ivar_template ()\n    };  */\n \n static tree\n-build_ivar_list_template (list_type, size)\n-     tree list_type;\n-     int size;\n+build_ivar_list_template (tree list_type, int size)\n {\n   tree objc_ivar_list_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -3683,9 +3596,7 @@ build_ivar_list_template (list_type, size)\n    };  */\n \n static tree\n-build_method_list_template (list_type, size)\n-     tree list_type;\n-     int size;\n+build_method_list_template (tree list_type, int size)\n {\n   tree objc_ivar_list_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -3696,7 +3607,7 @@ build_method_list_template (list_type, size)\n \n   decl_specs\n     = build_tree_list\n-      (NULL_TREE, \n+      (NULL_TREE,\n        xref_tag (RECORD_TYPE,\n \t\t get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n   field_decl\n@@ -3727,9 +3638,7 @@ build_method_list_template (list_type, size)\n }\n \n static tree\n-build_ivar_list_initializer (type, field_decl)\n-     tree type;\n-     tree field_decl;\n+build_ivar_list_initializer (tree type, tree field_decl)\n {\n   tree initlist = NULL_TREE;\n \n@@ -3764,7 +3673,7 @@ build_ivar_list_initializer (type, field_decl)\n \n       /* Set offset.  */\n       ivar = tree_cons (NULL_TREE, byte_position (field_decl), ivar);\n-      initlist = tree_cons (NULL_TREE, \n+      initlist = tree_cons (NULL_TREE,\n \t\t\t    objc_build_constructor (type, nreverse (ivar)),\n \t\t\t    initlist);\n \n@@ -3777,11 +3686,7 @@ build_ivar_list_initializer (type, field_decl)\n }\n \n static tree\n-generate_ivars_list (type, name, size, list)\n-     tree type;\n-     const char *name;\n-     int size;\n-     tree list;\n+generate_ivars_list (tree type, const char *name, int size, tree list)\n {\n   tree sc_spec, decl_specs, decl, initlist;\n \n@@ -3802,7 +3707,7 @@ generate_ivars_list (type, name, size, list)\n }\n \n static void\n-generate_ivar_lists ()\n+generate_ivar_lists (void)\n {\n   tree initlist, ivar_list_template, chain;\n   tree cast, variable_length_type;\n@@ -3858,9 +3763,7 @@ generate_ivar_lists ()\n }\n \n static tree\n-build_dispatch_table_initializer (type, entries)\n-     tree type;\n-     tree entries;\n+build_dispatch_table_initializer (tree type, tree entries)\n {\n   tree initlist = NULL_TREE;\n \n@@ -3882,12 +3785,12 @@ build_dispatch_table_initializer (type, entries)\n \t\t\t\t\t     meth_var_types),\n \t\t\t    elemlist);\n \n-      elemlist = tree_cons (NULL_TREE, \n+      elemlist = tree_cons (NULL_TREE,\n \t\t\t    build_unary_op (ADDR_EXPR,\n \t\t\t\t\t    METHOD_DEFINITION (entries), 1),\n \t\t\t    elemlist);\n \n-      initlist = tree_cons (NULL_TREE, \n+      initlist = tree_cons (NULL_TREE,\n \t\t\t    objc_build_constructor (type, nreverse (elemlist)),\n \t\t\t    initlist);\n \n@@ -3903,12 +3806,12 @@ build_dispatch_table_initializer (type, entries)\n    inane warnings, the definition of the dispatch table entries were\n    changed from:\n \n-   \tstruct objc_method { SEL _cmd; ...; id (*_imp)(); };\n+\tstruct objc_method { SEL _cmd; ...; id (*_imp)(); };\n    to:\n-   \tstruct objc_method { SEL _cmd; ...; void *_imp; };  */\n+\tstruct objc_method { SEL _cmd; ...; void *_imp; };  */\n \n static tree\n-build_method_template ()\n+build_method_template (void)\n {\n   tree _SLT_record;\n   tree decl_specs, field_decl, field_decl_chain;\n@@ -3945,11 +3848,7 @@ build_method_template ()\n \n \n static tree\n-generate_dispatch_table (type, name, size, list)\n-     tree type;\n-     const char *name;\n-     int size;\n-     tree list;\n+generate_dispatch_table (tree type, const char *name, int size, tree list)\n {\n   tree sc_spec, decl_specs, decl, initlist;\n \n@@ -3971,7 +3870,7 @@ generate_dispatch_table (type, name, size, list)\n }\n \n static void\n-mark_referenced_methods ()\n+mark_referenced_methods (void)\n {\n   struct imp_entry *impent;\n   tree chain;\n@@ -3995,7 +3894,7 @@ mark_referenced_methods ()\n }\n \n static void\n-generate_dispatch_tables ()\n+generate_dispatch_tables (void)\n {\n   tree initlist, chain, method_list_template;\n   tree cast, variable_length_type;\n@@ -4063,8 +3962,7 @@ generate_dispatch_tables ()\n }\n \n static tree\n-generate_protocol_list (i_or_p)\n-     tree i_or_p;\n+generate_protocol_list (tree i_or_p)\n {\n   tree initlist, decl_specs, sc_spec;\n   tree refs_decl, expr_decl, lproto, e, plist;\n@@ -4150,14 +4048,9 @@ generate_protocol_list (i_or_p)\n }\n \n static tree\n-build_category_initializer (type, cat_name, class_name,\n-\t\t\t    instance_methods, class_methods, protocol_list)\n-     tree type;\n-     tree cat_name;\n-     tree class_name;\n-     tree instance_methods;\n-     tree class_methods;\n-     tree protocol_list;\n+build_category_initializer (tree type, tree cat_name, tree class_name,\n+\t\t\t    tree instance_methods, tree class_methods,\n+\t\t\t    tree protocol_list)\n {\n   tree initlist = NULL_TREE, expr;\n \n@@ -4221,17 +4114,10 @@ build_category_initializer (type, cat_name, class_name,\n    };  */\n \n static tree\n-build_shared_structure_initializer (type, isa, super, name, size, status,\n-\t\t\t\t    dispatch_table, ivar_list, protocol_list)\n-     tree type;\n-     tree isa;\n-     tree super;\n-     tree name;\n-     tree size;\n-     int status;\n-     tree dispatch_table;\n-     tree ivar_list;\n-     tree protocol_list;\n+build_shared_structure_initializer (tree type, tree isa, tree super,\n+\t\t\t\t    tree name, tree size, int status,\n+\t\t\t\t    tree dispatch_table, tree ivar_list,\n+\t\t\t\t    tree protocol_list)\n {\n   tree initlist = NULL_TREE, expr;\n \n@@ -4314,8 +4200,7 @@ build_shared_structure_initializer (type, isa, super, name, size, status,\n /* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n \n static void\n-generate_category (cat)\n-     tree cat;\n+generate_category (tree cat)\n {\n   tree sc_spec, decl_specs, decl;\n   tree initlist, cat_name_expr, class_name_expr;\n@@ -4365,7 +4250,7 @@ generate_category (cat)\n    static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n \n static void\n-generate_shared_structures ()\n+generate_shared_structures (void)\n {\n   tree sc_spec, decl_specs, decl;\n   tree name_expr, super_expr, root_expr;\n@@ -4468,9 +4353,7 @@ generate_shared_structures ()\n }\n \n static tree\n-synth_id_with_class_suffix (preamble, ctxt)\n-     const char *preamble;\n-     tree ctxt;\n+synth_id_with_class_suffix (const char *preamble, tree ctxt)\n {\n   char *string;\n   if (TREE_CODE (ctxt) == CLASS_IMPLEMENTATION_TYPE\n@@ -4502,13 +4385,12 @@ synth_id_with_class_suffix (preamble, ctxt)\n     }\n   else\n     abort ();\n-  \n+\n   return get_identifier (string);\n }\n \n static int\n-is_objc_type_qualifier (node)\n-     tree node;\n+is_objc_type_qualifier (tree node)\n {\n   return (TREE_CODE (node) == IDENTIFIER_NODE\n \t  && (node == ridpointers [(int) RID_CONST]\n@@ -4525,8 +4407,7 @@ is_objc_type_qualifier (node)\n    type of id (otherwise grokdeclarator will default to int).  */\n \n static tree\n-adjust_type_for_id_default (type)\n-     tree type;\n+adjust_type_for_id_default (tree type)\n {\n   tree declspecs, chain;\n \n@@ -4542,7 +4423,7 @@ adjust_type_for_id_default (type)\n        chain = TREE_CHAIN (chain))\n     {\n       if (TYPED_OBJECT (TREE_VALUE (chain))\n-          && !(TREE_VALUE (type) \n+          && !(TREE_VALUE (type)\n                && TREE_CODE (TREE_VALUE (type)) == INDIRECT_REF))\n         error (\"can not use an object as parameter to a method\\n\");\n       if (!is_objc_type_qualifier (TREE_VALUE (chain)))\n@@ -4555,28 +4436,25 @@ adjust_type_for_id_default (type)\n }\n \n /*   Usage:\n-  \t\tkeyworddecl:\n-  \t\t\tselector ':' '(' typename ')' identifier\n-  \n+\t\tkeyworddecl:\n+\t\t\tselector ':' '(' typename ')' identifier\n+\n      Purpose:\n-  \t\tTransform an Objective-C keyword argument into\n-  \t\tthe C equivalent parameter declarator.\n-  \n+\t\tTransform an Objective-C keyword argument into\n+\t\tthe C equivalent parameter declarator.\n+\n      In:\tkey_name, an \"identifier_node\" (optional).\n-  \t\targ_type, a  \"tree_list\" (optional).\n-  \t\targ_name, an \"identifier_node\".\n-  \n+\t\targ_type, a  \"tree_list\" (optional).\n+\t\targ_name, an \"identifier_node\".\n+\n      Note:\tIt would be really nice to strongly type the preceding\n-  \t\targuments in the function prototype; however, then I\n-  \t\tcould not use the \"accessor\" macros defined in \"tree.h\".\n-  \n+\t\targuments in the function prototype; however, then I\n+\t\tcould not use the \"accessor\" macros defined in \"tree.h\".\n+\n      Out:\tan instance of \"keyword_decl\".  */\n \n tree\n-build_keyword_decl (key_name, arg_type, arg_name)\n-     tree key_name;\n-     tree arg_type;\n-     tree arg_name;\n+build_keyword_decl (tree key_name, tree arg_type, tree arg_name)\n {\n   tree keyword_decl;\n \n@@ -4595,8 +4473,7 @@ build_keyword_decl (key_name, arg_type, arg_name)\n /* Given a chain of keyword_decl's, synthesize the full keyword selector.  */\n \n static tree\n-build_keyword_selector (selector)\n-     tree selector;\n+build_keyword_selector (tree selector)\n {\n   int len = 0;\n   tree key_chain, key_name;\n@@ -4643,11 +4520,8 @@ build_keyword_selector (selector)\n /* Used for declarations and definitions.  */\n \n tree\n-build_method_decl (code, ret_type, selector, add_args)\n-     enum tree_code code;\n-     tree ret_type;\n-     tree selector;\n-     tree add_args;\n+build_method_decl (enum tree_code code, tree ret_type, tree selector,\n+\t\t   tree add_args)\n {\n   tree method_decl;\n \n@@ -4686,10 +4560,7 @@ build_method_decl (code, ret_type, selector, add_args)\n    the method call are done together.  */\n \n static tree\n-get_arg_type_list (meth, context, superflag)\n-     tree meth;\n-     int context;\n-     int superflag;\n+get_arg_type_list (tree meth, int context, int superflag)\n {\n   tree arglist, akey;\n \n@@ -4729,8 +4600,7 @@ get_arg_type_list (meth, context, superflag)\n }\n \n static tree\n-check_duplicates (hsh)\n-     hash hsh;\n+check_duplicates (hash hsh)\n {\n   tree meth = NULL_TREE;\n \n@@ -4761,8 +4631,7 @@ check_duplicates (hsh)\n    used.  */\n \n static tree\n-receiver_is_class_object (receiver)\n-      tree receiver;\n+receiver_is_class_object (tree receiver)\n {\n   tree chain, exp, arg;\n \n@@ -4773,7 +4642,7 @@ receiver_is_class_object (receiver)\n     {\n       return CLASS_NAME (objc_implementation_context);\n     }\n-  \n+\n   if (flag_next_runtime)\n     {\n       /* The receiver is a variable created by\n@@ -4789,7 +4658,7 @@ receiver_is_class_object (receiver)\n     {\n       /* The receiver is a function call that returns an id.  Check if\n \t it is a call to objc_getClass, if so, pick up the class name.  */\n-      if (TREE_CODE (receiver) == CALL_EXPR \n+      if (TREE_CODE (receiver) == CALL_EXPR\n \t  && (exp = TREE_OPERAND (receiver, 0))\n \t  && TREE_CODE (exp) == ADDR_EXPR\n \t  && (exp = TREE_OPERAND (exp, 0))\n@@ -4818,7 +4687,7 @@ receiver_is_class_object (receiver)\n static tree current_objc_message_selector = 0;\n \n tree\n-objc_message_selector ()\n+objc_message_selector (void)\n {\n   return current_objc_message_selector;\n }\n@@ -4831,8 +4700,7 @@ objc_message_selector ()\n    (*(<abstract_decl>(*)())_msgSuper)(receiver, selTransTbl[n], ...);  */\n \n tree\n-build_message_expr (mess)\n-     tree mess;\n+build_message_expr (tree mess)\n {\n   tree receiver = TREE_PURPOSE (mess);\n   tree sel_name;\n@@ -4882,15 +4750,14 @@ build_message_expr (mess)\n    'build_message_expr' for non-template functions.  In the case of\n    C++ template functions, it is called from 'build_expr_from_tree'\n    (in decl2.c) after RECEIVER and METHOD_PARAMS have been expanded.  */\n-   \n+\n tree\n-finish_message_expr (receiver, sel_name, method_params)\n-     tree receiver, sel_name, method_params; \n-{      \n+finish_message_expr (tree receiver, tree sel_name, tree method_params)\n+{\n   tree method_prototype = NULL_TREE, class_ident = NULL_TREE;\n   tree selector, self_object, retval;\n   int statically_typed = 0, statically_allocated = 0;\n-  \n+\n   /* Determine receiver type.  */\n   tree rtype = TREE_TYPE (receiver);\n   int super = IS_SUPER (rtype);\n@@ -5081,9 +4948,9 @@ finish_message_expr (receiver, sel_name, method_params)\n \n       /* We think we have an instance...loophole: extern id Object; */\n       hsh = hash_lookup (nst_method_hash_list, sel_name);\n-      \n+\n       if (!hsh)\n-\t/* For various loopholes */\t\n+\t/* For various loopholes */\n \thsh = hash_lookup (cls_method_hash_list, sel_name);\n \n       method_prototype = check_duplicates (hsh);\n@@ -5123,10 +4990,9 @@ finish_message_expr (receiver, sel_name, method_params)\n    If SUPER_FLAG is nonzero, we look up the superclass's method.  */\n \n static tree\n-build_objc_method_call (super_flag, method_prototype, lookup_object, object,\n-\t\t\tselector, method_params)\n-     int super_flag;\n-     tree method_prototype, lookup_object, object, selector, method_params;\n+build_objc_method_call (int super_flag, tree method_prototype,\n+\t\t\ttree lookup_object, tree object, tree selector,\n+\t\t\ttree method_params)\n {\n   tree sender = (super_flag ? umsg_super_decl : umsg_decl);\n   tree rcv_p = (super_flag\n@@ -5224,8 +5090,7 @@ build_objc_method_call (super_flag, method_prototype, lookup_object, object,\n }\n \f\n static void\n-build_protocol_reference (p)\n-     tree p;\n+build_protocol_reference (tree p)\n {\n   tree decl, ident, ptype;\n \n@@ -5257,8 +5122,7 @@ build_protocol_reference (p)\n /* This function is called by the parser when (and only when) a\n    @protocol() expression is found, in order to compile it.  */\n tree\n-build_protocol_expr (protoname)\n-     tree protoname;\n+build_protocol_expr (tree protoname)\n {\n   tree expr;\n   tree p = lookup_protocol (protoname);\n@@ -5295,10 +5159,10 @@ build_protocol_expr (protoname)\n       /* This type is a struct containing the fields of a Protocol\n         object.  (Cfr. protocol_type instead is the type of a pointer\n         to such a struct).  */\n-      tree protocol_struct_type = xref_tag \n+      tree protocol_struct_type = xref_tag\n        (RECORD_TYPE, get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n       tree *chain;\n-      \n+\n       /* Look for the list of Protocol statically allocated instances\n         to fixup at runtime.  Create a new list to hold Protocol\n         statically allocated instances, if the list is not found.  At\n@@ -5313,13 +5177,13 @@ build_protocol_expr (protoname)\n          add_objc_string (TYPE_NAME (protocol_struct_type),\n                           class_names);\n        }\n-      \n+\n       /* Add this statically allocated instance to the Protocol list.  */\n-      TREE_PURPOSE (*chain) = tree_cons (NULL_TREE, \n+      TREE_PURPOSE (*chain) = tree_cons (NULL_TREE,\n \t\t\t\t\t PROTOCOL_FORWARD_DECL (p),\n \t\t\t\t\t TREE_PURPOSE (*chain));\n     }\n-  \n+\n \n   return expr;\n }\n@@ -5328,8 +5192,7 @@ build_protocol_expr (protoname)\n    is found, in order to compile it.  It is only called by the parser\n    and only to compile a @selector().  */\n tree\n-build_selector_expr (selnamelist)\n-     tree selnamelist;\n+build_selector_expr (tree selnamelist)\n {\n   tree selname;\n \n@@ -5353,20 +5216,20 @@ build_selector_expr (selnamelist)\n \n       /* First try with instance methods.  */\n       hsh = hash_lookup (nst_method_hash_list, selname);\n-      \n+\n       /* If not found, try with class methods.  */\n       if (!hsh)\n \t{\n \t  hsh = hash_lookup (cls_method_hash_list, selname);\n \t}\n-      \n+\n       /* If still not found, print out a warning.  */\n       if (!hsh)\n \t{\n \t  warning (\"undeclared selector `%s'\", IDENTIFIER_POINTER (selname));\n \t}\n     }\n-  \n+\n \n   if (flag_typed_selectors)\n     return build_typed_selector_reference (selname, 0);\n@@ -5375,8 +5238,7 @@ build_selector_expr (selnamelist)\n }\n \n tree\n-build_encode_expr (type)\n-     tree type;\n+build_encode_expr (tree type)\n {\n   tree result;\n   const char *string;\n@@ -5393,8 +5255,7 @@ build_encode_expr (type)\n }\n \n tree\n-build_ivar_reference (id)\n-     tree id;\n+build_ivar_reference (tree id)\n {\n   if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n     {\n@@ -5418,20 +5279,19 @@ build_ivar_reference (id)\n /* Compute a hash value for a given method SEL_NAME.  */\n \n static size_t\n-hash_func (sel_name)\n-     tree sel_name;\n+hash_func (tree sel_name)\n {\n-  const unsigned char *s \n+  const unsigned char *s\n     = (const unsigned char *)IDENTIFIER_POINTER (sel_name);\n   size_t h = 0;\n-  \n+\n   while (*s)\n     h = h * 67 + *s++ - 113;\n-  return h;  \n+  return h;\n }\n-     \n+\n static void\n-hash_init ()\n+hash_init (void)\n {\n   nst_method_hash_list = ggc_calloc (SIZEHASHTABLE, sizeof (hash));\n   cls_method_hash_list = ggc_calloc (SIZEHASHTABLE, sizeof (hash));\n@@ -5443,9 +5303,7 @@ hash_init ()\n    entry's key (method) for comparison.  */\n \n static void\n-hash_enter (hashlist, method)\n-     hash *hashlist;\n-     tree method;\n+hash_enter (hash *hashlist, tree method)\n {\n   hash obj;\n   int slot = hash_func (METHOD_SEL_NAME (method)) % SIZEHASHTABLE;\n@@ -5459,9 +5317,7 @@ hash_enter (hashlist, method)\n }\n \n static hash\n-hash_lookup (hashlist, sel_name)\n-     hash *hashlist;\n-     tree sel_name;\n+hash_lookup (hash *hashlist, tree sel_name)\n {\n   hash target;\n \n@@ -5478,9 +5334,7 @@ hash_lookup (hashlist, sel_name)\n }\n \n static void\n-hash_add_attr (entry, value)\n-     hash entry;\n-     tree value;\n+hash_add_attr (hash entry, tree value)\n {\n   attr obj;\n \n@@ -5492,9 +5346,7 @@ hash_add_attr (entry, value)\n }\n \f\n static tree\n-lookup_method (mchain, method)\n-     tree mchain;\n-     tree method;\n+lookup_method (tree mchain, tree method)\n {\n   tree key;\n \n@@ -5514,9 +5366,7 @@ lookup_method (mchain, method)\n }\n \n static tree\n-lookup_instance_method_static (interface, ident)\n-     tree interface;\n-     tree ident;\n+lookup_instance_method_static (tree interface, tree ident)\n {\n   tree inter = interface;\n   tree chain = CLASS_NST_METHODS (inter);\n@@ -5567,9 +5417,7 @@ lookup_instance_method_static (interface, ident)\n }\n \n static tree\n-lookup_class_method_static (interface, ident)\n-     tree interface;\n-     tree ident;\n+lookup_class_method_static (tree interface, tree ident)\n {\n   tree inter = interface;\n   tree chain = CLASS_CLS_METHODS (inter);\n@@ -5626,9 +5474,7 @@ lookup_class_method_static (interface, ident)\n }\n \n tree\n-add_class_method (class, method)\n-     tree class;\n-     tree method;\n+add_class_method (tree class, tree method)\n {\n   tree mth;\n   hash hsh;\n@@ -5668,9 +5514,7 @@ add_class_method (class, method)\n }\n \f\n tree\n-add_instance_method (class, method)\n-     tree class;\n-     tree method;\n+add_instance_method (tree class, tree method)\n {\n   tree mth;\n   hash hsh;\n@@ -5710,8 +5554,7 @@ add_instance_method (class, method)\n }\n \n static tree\n-add_class (class)\n-     tree class;\n+add_class (tree class)\n {\n   /* Put interfaces on list in reverse order.  */\n   TREE_CHAIN (class) = interface_chain;\n@@ -5720,9 +5563,7 @@ add_class (class)\n }\n \n static void\n-add_category (class, category)\n-      tree class;\n-      tree category;\n+add_category (tree class, tree category)\n {\n   /* Put categories on list in reverse order.  */\n   tree cat = CLASS_CATEGORY_LIST (class);\n@@ -5746,12 +5587,8 @@ add_category (class, category)\n    PUBLIC is 1 for public, 0 for protected, and 2 for private.  */\n \n tree\n-add_instance_variable (class, public, declarator, declspecs, width)\n-     tree class;\n-     int public;\n-     tree declarator;\n-     tree declspecs;\n-     tree width;\n+add_instance_variable (tree class, int public, tree declarator,\n+\t\t       tree declspecs, tree width)\n {\n   tree field_decl, raw_decl;\n \n@@ -5796,9 +5633,7 @@ add_instance_variable (class, public, declarator, declspecs, width)\n }\n \f\n tree\n-is_ivar (decl_chain, ident)\n-     tree decl_chain;\n-     tree ident;\n+is_ivar (tree decl_chain, tree ident)\n {\n   for ( ; decl_chain; decl_chain = TREE_CHAIN (decl_chain))\n     if (DECL_NAME (decl_chain) == ident)\n@@ -5809,8 +5644,7 @@ is_ivar (decl_chain, ident)\n /* True if the ivar is private and we are not in its implementation.  */\n \n int\n-is_private (decl)\n-     tree decl;\n+is_private (tree decl)\n {\n   if (TREE_PRIVATE (decl)\n       && ! is_ivar (CLASS_IVARS (implementation_template), DECL_NAME (decl)))\n@@ -5826,9 +5660,7 @@ is_private (decl)\n /* We have an instance variable reference;, check to see if it is public.  */\n \n int\n-is_public (expr, identifier)\n-     tree expr;\n-     tree identifier;\n+is_public (tree expr, tree identifier)\n {\n   tree basetype = TREE_TYPE (expr);\n   enum tree_code code = TREE_CODE (basetype);\n@@ -5882,10 +5714,7 @@ is_public (expr, identifier)\n /* Make sure all entries in CHAIN are also in LIST.  */\n \n static int\n-check_methods (chain, list, mtype)\n-     tree chain;\n-     tree list;\n-     int mtype;\n+check_methods (tree chain, tree list, int mtype)\n {\n   int first = 1;\n \n@@ -5919,9 +5748,7 @@ check_methods (chain, list, mtype)\n /* Check if CLASS, or its superclasses, explicitly conforms to PROTOCOL.  */\n \n static int\n-conforms_to_protocol (class, protocol)\n-     tree class;\n-     tree protocol;\n+conforms_to_protocol (tree class, tree protocol)\n {\n    if (TREE_CODE (protocol) == PROTOCOL_INTERFACE_TYPE)\n      {\n@@ -5943,14 +5770,11 @@ conforms_to_protocol (class, protocol)\n    return 1;\n }\n \n-/* Make sure all methods in CHAIN are accessible as MTYPE methods in \n+/* Make sure all methods in CHAIN are accessible as MTYPE methods in\n    CONTEXT.  This is one of two mechanisms to check protocol integrity.  */\n \n static int\n-check_methods_accessible (chain, context, mtype)\n-     tree chain;\n-     tree context;\n-     int mtype;\n+check_methods_accessible (tree chain, tree context, int mtype)\n {\n   int first = 1;\n   tree list;\n@@ -5967,17 +5791,17 @@ check_methods_accessible (chain, context, mtype)\n \t    list = CLASS_NST_METHODS (context);\n \n \t  if (lookup_method (list, chain))\n-\t      break; \n+\t      break;\n \n \t  else if (TREE_CODE (context) == CLASS_IMPLEMENTATION_TYPE\n \t\t   || TREE_CODE (context) == CLASS_INTERFACE_TYPE)\n-\t    context = (CLASS_SUPER_NAME (context) \n+\t    context = (CLASS_SUPER_NAME (context)\n \t\t       ? lookup_interface (CLASS_SUPER_NAME (context))\n \t\t       : NULL_TREE);\n \n \t  else if (TREE_CODE (context) == CATEGORY_IMPLEMENTATION_TYPE\n \t\t   || TREE_CODE (context) == CATEGORY_INTERFACE_TYPE)\n-\t    context = (CLASS_NAME (context) \n+\t    context = (CLASS_NAME (context)\n \t\t       ? lookup_interface (CLASS_NAME (context))\n \t\t       : NULL_TREE);\n \t  else\n@@ -6012,12 +5836,9 @@ check_methods_accessible (chain, context, mtype)\n /* Check whether the current interface (accessible via\n    'objc_implementation_context') actually implements protocol P, along\n    with any protocols that P inherits.  */\n-   \n+\n static void\n-check_protocol (p, type, name)\n-     tree p;\n-     const char *type;\n-     const char *name;\n+check_protocol (tree p, const char *type, const char *name)\n {\n   if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n     {\n@@ -6047,15 +5868,15 @@ check_protocol (p, type, name)\n \twarning (\"%s `%s' does not fully implement the `%s' protocol\",\n \t\t type, name, IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n     }\n-    \n+\n   /* Check protocols recursively.  */\n   if (PROTOCOL_LIST (p))\n     {\n       tree subs = PROTOCOL_LIST (p);\n       tree super_class =\n \tlookup_interface (CLASS_SUPER_NAME (implementation_template));\n \n-      while (subs) \n+      while (subs)\n \t{\n \t  tree sub = TREE_VALUE (subs);\n \n@@ -6067,16 +5888,13 @@ check_protocol (p, type, name)\n \t}\n     }\n }\n-\t\n+\n /* Check whether the current interface (accessible via\n    'objc_implementation_context') actually implements the protocols listed\n    in PROTO_LIST.  */\n-   \n+\n static void\n-check_protocols (proto_list, type, name)\n-     tree proto_list;\n-     const char *type;\n-     const char *name;\n+check_protocols (tree proto_list, const char *type, const char *name)\n {\n   for ( ; proto_list; proto_list = TREE_CHAIN (proto_list))\n     {\n@@ -6092,11 +5910,8 @@ check_protocols (proto_list, type, name)\n    CATEGORY_INTERFACE_TYPE, or CATEGORY_IMPLEMENTATION_TYPE.  */\n \n tree\n-start_class (code, class_name, super_name, protocol_list)\n-     enum tree_code code;\n-     tree class_name;\n-     tree super_name;\n-     tree protocol_list;\n+start_class (enum tree_code code, tree class_name, tree super_name,\n+\t     tree protocol_list)\n {\n   tree class, decl;\n \n@@ -6180,7 +5995,7 @@ start_class (code, class_name, super_name, protocol_list)\n \n       else if (! super_name)\n \t{\n-\t  CLASS_SUPER_NAME (objc_implementation_context) \n+\t  CLASS_SUPER_NAME (objc_implementation_context)\n \t    = CLASS_SUPER_NAME (implementation_template);\n \t}\n     }\n@@ -6253,8 +6068,7 @@ start_class (code, class_name, super_name, protocol_list)\n }\n \n tree\n-continue_class (class)\n-     tree class;\n+continue_class (tree class)\n {\n   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE\n       || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n@@ -6317,8 +6131,7 @@ continue_class (class)\n /* This is called once we see the \"@end\" in an interface/implementation.  */\n \n void\n-finish_class (class)\n-     tree class;\n+finish_class (tree class)\n {\n   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)\n     {\n@@ -6384,8 +6197,7 @@ finish_class (class)\n }\n \n static tree\n-add_protocol (protocol)\n-     tree protocol;\n+add_protocol (tree protocol)\n {\n   /* Put protocol on list in reverse order.  */\n   TREE_CHAIN (protocol) = protocol_chain;\n@@ -6394,8 +6206,7 @@ add_protocol (protocol)\n }\n \n static tree\n-lookup_protocol (ident)\n-     tree ident;\n+lookup_protocol (tree ident)\n {\n   tree chain;\n \n@@ -6410,8 +6221,7 @@ lookup_protocol (ident)\n    they are already declared or defined, the function has no effect.  */\n \n void\n-objc_declare_protocols (names)\n-     tree names;\n+objc_declare_protocols (tree names)\n {\n   tree list;\n \n@@ -6434,10 +6244,7 @@ objc_declare_protocols (names)\n }\n \n tree\n-start_protocol (code, name, list)\n-     enum tree_code code;\n-     tree name;\n-     tree list;\n+start_protocol (enum tree_code code, tree name, tree list)\n {\n   tree protocol;\n \n@@ -6477,8 +6284,7 @@ start_protocol (code, name, list)\n }\n \n void\n-finish_protocol (protocol)\n-     tree protocol ATTRIBUTE_UNUSED;\n+finish_protocol (tree protocol ATTRIBUTE_UNUSED)\n {\n }\n \n@@ -6487,8 +6293,7 @@ finish_protocol (protocol)\n    ??? What is the FORMAT?  Someone please document this!  */\n \n static void\n-encode_type_qualifiers (declspecs)\n-     tree declspecs;\n+encode_type_qualifiers (tree declspecs)\n {\n   tree spec;\n \n@@ -6514,10 +6319,7 @@ encode_type_qualifiers (declspecs)\n /* Encode a pointer type.  */\n \n static void\n-encode_pointer (type, curtype, format)\n-     tree type;\n-     int curtype;\n-     int format;\n+encode_pointer (tree type, int curtype, int format)\n {\n   tree pointer_to = TREE_TYPE (type);\n \n@@ -6576,10 +6378,7 @@ encode_pointer (type, curtype, format)\n }\n \n static void\n-encode_array (type, curtype, format)\n-     tree type;\n-     int curtype;\n-     int format;\n+encode_array (tree type, int curtype, int format)\n {\n   tree an_int_cst = TYPE_SIZE (type);\n   tree array_of = TREE_TYPE (type);\n@@ -6603,12 +6402,8 @@ encode_array (type, curtype, format)\n }\n \f\n static void\n-encode_aggregate_within (type, curtype, format, left, right)\n-     tree type;\n-     int curtype;\n-     int format;\n-     int left;\n-     int right;\n+encode_aggregate_within (tree type, int curtype, int format, int left,\n+\t\t\t int right)\n {\n   /* The RECORD_TYPE may in fact be a typedef!  For purposes\n      of encoding, we need the real underlying enchilada.  */\n@@ -6724,10 +6519,7 @@ encode_aggregate_within (type, curtype, format, left, right)\n }\n \n static void\n-encode_aggregate (type, curtype, format)\n-     tree type;\n-     int curtype;\n-     int format;\n+encode_aggregate (tree type, int curtype, int format)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -6764,8 +6556,7 @@ encode_aggregate (type, curtype, format)\n    hand generating this string (which is tedious).  */\n \n static void\n-encode_bitfield (width)\n-     int width;\n+encode_bitfield (int width)\n {\n   char buffer[40];\n   sprintf (buffer, \"b%d\", width);\n@@ -6775,10 +6566,7 @@ encode_bitfield (width)\n /* FORMAT will be OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS.  */\n \n static void\n-encode_type (type, curtype, format)\n-     tree type;\n-     int curtype;\n-     int format;\n+encode_type (tree type, int curtype, int format)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -6851,10 +6639,7 @@ encode_type (type, curtype, format)\n }\n \n static void\n-encode_complete_bitfield (position, type, size)\n-     int position;\n-     tree type;\n-     int size;\n+encode_complete_bitfield (int position, tree type, int size)\n {\n   enum tree_code code = TREE_CODE (type);\n   char buffer[40];\n@@ -6910,10 +6695,7 @@ encode_complete_bitfield (position, type, size)\n }\n \n static void\n-encode_field_decl (field_decl, curtype, format)\n-     tree field_decl;\n-     int curtype;\n-     int format;\n+encode_field_decl (tree field_decl, int curtype, int format)\n {\n   tree type;\n \n@@ -6941,8 +6723,7 @@ encode_field_decl (field_decl, curtype, format)\n }\n \n static tree\n-objc_expr_last (complex_expr)\n-     tree complex_expr;\n+objc_expr_last (tree complex_expr)\n {\n   tree next;\n \n@@ -6957,8 +6738,7 @@ objc_expr_last (complex_expr)\n    - synthesize the first two arguments, \"self\" and \"_cmd\".  */\n \n void\n-start_method_def (method)\n-     tree method;\n+start_method_def (tree method)\n {\n   tree decl_specs;\n \n@@ -7042,10 +6822,7 @@ start_method_def (method)\n }\n \n static void\n-warn_with_method (message, mtype, method)\n-     const char *message;\n-     int mtype;\n-     tree method;\n+warn_with_method (const char *message, int mtype, tree method)\n {\n   /* Add a readable method name to the warning.  */\n   warning (\"%H%s `%c%s'\", &DECL_SOURCE_LOCATION (method),\n@@ -7055,8 +6832,7 @@ warn_with_method (message, mtype, method)\n /* Return 1 if METHOD is consistent with PROTO.  */\n \n static int\n-comp_method_with_proto (method, proto)\n-     tree method, proto;\n+comp_method_with_proto (tree method, tree proto)\n {\n   /* Create a function template node at most once.  */\n   if (!function1_template)\n@@ -7075,8 +6851,7 @@ comp_method_with_proto (method, proto)\n /* Return 1 if PROTO1 is consistent with PROTO2.  */\n \n static int\n-comp_proto_with_proto (proto0, proto1)\n-     tree proto0, proto1;\n+comp_proto_with_proto (tree proto0, tree proto1)\n {\n   /* Create a couple of function_template nodes at most once.  */\n   if (!function1_template)\n@@ -7102,8 +6877,7 @@ comp_proto_with_proto (proto0, proto1)\n    - If we have a prototype, check for type consistency.  */\n \n static void\n-really_start_method (method, parmlist)\n-     tree method, parmlist;\n+really_start_method (tree method, tree parmlist)\n {\n   tree sc_spec, ret_spec, ret_decl, decl_specs;\n   tree method_decl, method_id;\n@@ -7189,11 +6963,11 @@ really_start_method (method, parmlist)\n \n /* The following routine is always called...this \"architecture\" is to\n    accommodate \"old-style\" variable length selectors.\n- \n+\n    - a:a b:b // prototype  ; id c; id d; // old-style.  */\n \n void\n-continue_method_def ()\n+continue_method_def (void)\n {\n   tree parmlist;\n \n@@ -7215,7 +6989,7 @@ continue_method_def ()\n /* Called by the parser, from the `pushlevel' production.  */\n \n void\n-add_objc_decls ()\n+add_objc_decls (void)\n {\n   if (!UOBJC_SUPER_decl)\n     {\n@@ -7239,7 +7013,7 @@ add_objc_decls ()\n      }  */\n \n tree\n-get_super_receiver ()\n+get_super_receiver (void)\n {\n   if (objc_method_context)\n     {\n@@ -7288,7 +7062,7 @@ get_super_receiver ()\n \t\t   included <objc/objc-class.h>, leaving 'struct objc_class'\n \t\t   an incomplete type.  */\n \t\tsuper_class\n-\t\t  = build_component_ref (build_indirect_ref \n+\t\t  = build_component_ref (build_indirect_ref\n \t\t\t\t\t (build_c_cast (id_type, super_class), \"->\"),\n \t\t\t\t\t  get_identifier (\"isa\"));\n \t    }\n@@ -7326,8 +7100,7 @@ get_super_receiver ()\n }\n \n static tree\n-encode_method_def (func_decl)\n-      tree func_decl;\n+encode_method_def (tree func_decl)\n {\n   tree parms;\n   int stack_size;\n@@ -7383,13 +7156,13 @@ encode_method_def (func_decl)\n }\n \n static void\n-objc_expand_function_end ()\n+objc_expand_function_end (void)\n {\n   METHOD_ENCODING (objc_method_context) = encode_method_def (current_function_decl);\n }\n \n void\n-finish_method_def ()\n+finish_method_def (void)\n {\n   lang_expand_function_end = objc_expand_function_end;\n   finish_function ();\n@@ -7402,8 +7175,7 @@ finish_method_def ()\n \n #if 0\n int\n-lang_report_error_function (decl)\n-      tree decl;\n+lang_report_error_function (tree decl)\n {\n   if (objc_method_context)\n     {\n@@ -7418,8 +7190,7 @@ lang_report_error_function (decl)\n #endif\n \n static int\n-is_complex_decl (type)\n-     tree type;\n+is_complex_decl (tree type)\n {\n   return (TREE_CODE (type) == ARRAY_TYPE\n \t  || TREE_CODE (type) == FUNCTION_TYPE\n@@ -7432,9 +7203,7 @@ is_complex_decl (type)\n static char tmpbuf[256];\n \n static void\n-adorn_decl (decl, str)\n-     tree decl;\n-     char *str;\n+adorn_decl (tree decl, char *str)\n {\n   enum tree_code code = TREE_CODE (decl);\n \n@@ -7534,10 +7303,7 @@ adorn_decl (decl, str)\n }\n \n static char *\n-gen_declarator (decl, buf, name)\n-     tree decl;\n-     char *buf;\n-     const char *name;\n+gen_declarator (tree decl, char *buf, const char *name)\n {\n   if (decl)\n     {\n@@ -7626,10 +7392,7 @@ gen_declarator (decl, buf, name)\n }\n \n static void\n-gen_declspecs (declspecs, buf, raw)\n-     tree declspecs;\n-     char *buf;\n-     int raw;\n+gen_declspecs (tree declspecs, char *buf, int raw)\n {\n   if (raw)\n     {\n@@ -7870,7 +7633,7 @@ gen_declspecs (declspecs, buf, raw)\n \t      }\n \t  }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -7881,9 +7644,7 @@ gen_declspecs (declspecs, buf, raw)\n    buffer, overwriting the buffer.  */\n \n static char *\n-gen_declaration (atype_or_adecl, buf)\n-     tree atype_or_adecl;\n-     char *buf;\n+gen_declaration (tree atype_or_adecl, char *buf)\n {\n   buf[0] = '\\0';\n   gen_declaration_1 (atype_or_adecl, buf);\n@@ -7894,9 +7655,7 @@ gen_declaration (atype_or_adecl, buf)\n    given buffer.  */\n \n static void\n-gen_declaration_1 (atype_or_adecl, buf)\n-     tree atype_or_adecl;\n-     char *buf;\n+gen_declaration_1 (tree atype_or_adecl, char *buf)\n {\n   char declbuf[256];\n \n@@ -7985,9 +7744,7 @@ gen_declaration_1 (atype_or_adecl, buf)\n    buffer (overwriting) and return a pointer to the buffer.  */\n \n static char *\n-gen_method_decl (method, buf)\n-     tree method;\n-     char *buf;\n+gen_method_decl (tree method, char *buf)\n {\n   tree chain;\n \n@@ -8054,9 +7811,7 @@ gen_method_decl (method, buf)\n    prints out an @interface declaration of all classes compiled in\n    this run); potentially useful for debugging the compiler too.  */\n static void\n-dump_interface (fp, chain)\n-     FILE *fp;\n-     tree chain;\n+dump_interface (FILE *fp, tree chain)\n {\n   /* FIXME: A heap overflow here whenever a method (or ivar)\n      declaration is so long that it doesn't fit in the buffer.  The\n@@ -8070,13 +7825,13 @@ dump_interface (fp, chain)\n \n   fprintf (fp, \"\\n@interface %s\", my_name);\n \n-  /* CLASS_SUPER_NAME is used to store the superclass name for \n+  /* CLASS_SUPER_NAME is used to store the superclass name for\n      classes, and the category name for categories.  */\n   if (CLASS_SUPER_NAME (chain))\n     {\n       const char *name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));\n-      \n-      if (TREE_CODE (chain) == CATEGORY_IMPLEMENTATION_TYPE \n+\n+      if (TREE_CODE (chain) == CATEGORY_IMPLEMENTATION_TYPE\n \t  || TREE_CODE (chain) == CATEGORY_INTERFACE_TYPE)\n \t{\n \t  fprintf (fp, \" (%s)\\n\", name);\n@@ -8119,8 +7874,7 @@ dump_interface (fp, chain)\n \n /* Demangle function for Objective-C */\n static const char *\n-objc_demangle (mangled)\n-     const char *mangled;\n+objc_demangle (const char *mangled)\n {\n   char *demangled, *cp;\n \n@@ -8175,15 +7929,13 @@ objc_demangle (mangled)\n }\n \n const char *\n-objc_printable_name (decl, kind)\n-     tree decl;\n-     int kind ATTRIBUTE_UNUSED;\n+objc_printable_name (tree decl, int kind ATTRIBUTE_UNUSED)\n {\n   return objc_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)));\n }\n \n static void\n-init_objc ()\n+init_objc (void)\n {\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n@@ -8194,7 +7946,7 @@ init_objc ()\n }\n \f\n static void\n-finish_objc ()\n+finish_objc (void)\n {\n   struct imp_entry *impent;\n   tree chain;\n@@ -8230,7 +7982,7 @@ finish_objc ()\n \n       UOBJC_CLASS_decl = impent->class_decl;\n       UOBJC_METACLASS_decl = impent->meta_decl;\n-      \n+\n       /* Dump the @interface of each class as we compile it, if the\n \t -gen-decls option is in use.  TODO: Dump the classes in the\n          order they were found, rather than in reverse order as we\n@@ -8239,7 +7991,7 @@ finish_objc ()\n \t{\n \t  dump_interface (gen_declaration_file, objc_implementation_context);\n \t}\n-      \n+\n       if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \t{\n \t  /* all of the following reference the string pool...  */\n@@ -8337,8 +8089,7 @@ finish_objc ()\n /* Subroutines of finish_objc.  */\n \n static void\n-generate_classref_translation_entry (chain)\n-     tree chain;\n+generate_classref_translation_entry (tree chain)\n {\n   tree expr, name, decl_specs, decl, sc_spec;\n   tree type;\n@@ -8364,8 +8115,7 @@ generate_classref_translation_entry (chain)\n }\n \n static void\n-handle_class_ref (chain)\n-     tree chain;\n+handle_class_ref (tree chain)\n {\n   const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));\n   char *string = alloca (strlen (name) + 30);\n@@ -8405,8 +8155,7 @@ handle_class_ref (chain)\n }\n \n static void\n-handle_impent (impent)\n-     struct imp_entry *impent;\n+handle_impent (struct imp_entry *impent)\n {\n   char *string;\n \n@@ -8469,8 +8218,7 @@ handle_impent (impent)\n \f\n /* Look up ID as an instance variable.  */\n tree\n-lookup_objc_ivar (id)\n-     tree id;\n+lookup_objc_ivar (tree id)\n {\n   tree decl;\n "}, {"sha": "e167f8e551cddcd4d260a9da22aa82c17833faac", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d50d946a1c854e19d0be0aff69de6f97f6eaf/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=011d50d946a1c854e19d0be0aff69de6f97f6eaf", "patch": "@@ -24,54 +24,54 @@ Boston, MA 02111-1307, USA.  */\n \n /*** Public Interface (procedures) ***/\n \n-bool objc_init\t\t\t\t\tPARAMS ((void));\n-const char *objc_printable_name\t\t\tPARAMS ((tree, int));\n+bool objc_init (void);\n+const char *objc_printable_name (tree, int);\n \n /* used by yyparse */\n \n-void finish_file\t\t\t\tPARAMS ((void));\n-tree start_class\t\t\t\tPARAMS ((enum tree_code, tree, tree, tree));\n-tree continue_class\t\t\t\tPARAMS ((tree));\n-void finish_class\t\t\t\tPARAMS ((tree));\n-void start_method_def\t\t\t\tPARAMS ((tree));\n-void continue_method_def\t\t\tPARAMS ((void));\n-void finish_method_def\t\t\t\tPARAMS ((void));\n-tree start_protocol\t\t\t\tPARAMS ((enum tree_code, tree, tree));\n-void finish_protocol\t\t\t\tPARAMS ((tree));\n-void add_objc_decls\t\t\t\tPARAMS ((void));\n-\n-tree is_ivar\t\t\t\t\tPARAMS ((tree, tree));\n-int is_private\t\t\t\t\tPARAMS ((tree));\n-int is_public\t\t\t\t\tPARAMS ((tree, tree));\n-tree add_instance_variable\t\t\tPARAMS ((tree, int, tree, tree, tree));\n-tree add_class_method\t\t\t\tPARAMS ((tree, tree));\n-tree add_instance_method\t\t\tPARAMS ((tree, tree));\n-tree get_super_receiver\t\t\t\tPARAMS ((void));\n-tree get_class_ivars\t\t\t\tPARAMS ((tree));\n-tree get_class_reference\t\t\tPARAMS ((tree));\n-tree get_static_reference\t\t\tPARAMS ((tree, tree));\n-tree get_object_reference\t\t\tPARAMS ((tree));\n-tree build_message_expr\t\t\t\tPARAMS ((tree));\n-tree finish_message_expr\t\t\tPARAMS ((tree, tree, tree));\n-tree build_selector_expr\t\t\tPARAMS ((tree));\n-tree build_ivar_reference\t\t\tPARAMS ((tree));\n-tree build_keyword_decl\t\t\t\tPARAMS ((tree, tree, tree));\n-tree build_method_decl\t\t\t\tPARAMS ((enum tree_code, tree, tree, tree));\n-tree build_protocol_expr\t\t\tPARAMS ((tree));\n-tree build_objc_string_object\t\t\tPARAMS ((tree));\n-\n-void objc_declare_alias\t\t\t\tPARAMS ((tree, tree));\n-void objc_declare_class\t\t\t\tPARAMS ((tree));\n-void objc_declare_protocols\t\t\tPARAMS ((tree));\n+void finish_file (void);\n+tree start_class (enum tree_code, tree, tree, tree);\n+tree continue_class (tree);\n+void finish_class (tree);\n+void start_method_def (tree);\n+void continue_method_def (void);\n+void finish_method_def (void);\n+tree start_protocol (enum tree_code, tree, tree);\n+void finish_protocol (tree);\n+void add_objc_decls (void);\n+\n+tree is_ivar (tree, tree);\n+int is_private (tree);\n+int is_public (tree, tree);\n+tree add_instance_variable (tree, int, tree, tree, tree);\n+tree add_class_method (tree, tree);\n+tree add_instance_method (tree, tree);\n+tree get_super_receiver (void);\n+tree get_class_ivars (tree);\n+tree get_class_reference (tree);\n+tree get_static_reference (tree, tree);\n+tree get_object_reference (tree);\n+tree build_message_expr (tree);\n+tree finish_message_expr (tree, tree, tree);\n+tree build_selector_expr (tree);\n+tree build_ivar_reference (tree);\n+tree build_keyword_decl (tree, tree, tree);\n+tree build_method_decl (enum tree_code, tree, tree, tree);\n+tree build_protocol_expr (tree);\n+tree build_objc_string_object (tree);\n+\n+void objc_declare_alias (tree, tree);\n+void objc_declare_class (tree);\n+void objc_declare_protocols (tree);\n \n /* the following routines are used to implement statically typed objects */\n \n-int objc_comptypes\t\t\t\tPARAMS ((tree, tree, int));\n-void objc_check_decl\t\t\t\tPARAMS ((tree));\n+int objc_comptypes (tree, tree, int);\n+void objc_check_decl (tree);\n \n /* NeXT extensions */\n \n-tree build_encode_expr\t\t\t\tPARAMS ((tree));\n+tree build_encode_expr (tree);\n \n /* Objective-C structures */\n \n@@ -151,7 +151,7 @@ struct hashed_entry GTY(())\n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *nst_method_hash_list;\n extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_method_hash_list;\n \n-#define SIZEHASHTABLE \t\t257\n+#define SIZEHASHTABLE\t\t257\n \n /* Objective-C/Objective-C++ @implementation list.  */\n \n@@ -245,7 +245,7 @@ enum objc_tree_index\n     OCTI_CNST_STR_GLOB_ID,\n     OCTI_STRING_CLASS_DECL,\n     OCTI_SUPER_DECL,\n-    \n+\n     OCTI_MAX\n };\n \n@@ -349,7 +349,7 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \t\t\t\tobjc_global_trees[OCTI_METH_PROTO_TEMPL]\n #define function1_template\tobjc_global_trees[OCTI_FUNCTION1_TEMPL]\n #define function2_template\tobjc_global_trees[OCTI_FUNCTION2_TEMPL]\n-\t\t\t\t\n+\n #define objc_object_id\t\tobjc_global_trees[OCTI_OBJ_ID]\n #define objc_class_id\t\tobjc_global_trees[OCTI_CLS_ID]\n #define objc_id_id\t\tobjc_global_trees[OCTI_ID_ID]"}]}