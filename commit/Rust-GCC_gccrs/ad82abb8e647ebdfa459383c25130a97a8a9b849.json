{"sha": "ad82abb8e647ebdfa459383c25130a97a8a9b849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ4MmFiYjhlNjQ3ZWJkZmE0NTkzODNjMjUxMzBhOTdhOGE5Yjg0OQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-21T15:51:22Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-21T15:51:22Z"}, "message": "stmt.c: Don't include insn-codes.h.\n\n\t* stmt.c: Don't include insn-codes.h.\n\t(expand_end_case): Machine specific logic moved to expr.c.\n\tNo need to worry about __builtin_classify_type.\n\t(check_for_full_enumeration_handling, emit_case_nodes):\n\tKill #if 0 blocks.\n\n\t* builtins.o (expand_builtin_classify_type): Split up so code\n\tcan be shared with fold_builtin_classify_type.\n\t(type_to_class, fold_builtin_classify_type): New functions.\n\t(fold_builtins): Handle __builtin_classify_type.\n\n\t* expr.c (do_tablejump): Now static.\n\t(case_values_threshold, try_casesi, try_tablejump): New;\n\tcode mostly from stmt.c (expand_end_case).\n\t(expr.h): Update prototypes.\n\n\t* Makefile.in (stmt.o): Update dependencies.\n\nFrom-SVN: r45078", "tree": {"sha": "575699b686457410b32fd7f6c60e918c730b69ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/575699b686457410b32fd7f6c60e918c730b69ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad82abb8e647ebdfa459383c25130a97a8a9b849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad82abb8e647ebdfa459383c25130a97a8a9b849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad82abb8e647ebdfa459383c25130a97a8a9b849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad82abb8e647ebdfa459383c25130a97a8a9b849/comments", "author": null, "committer": null, "parents": [{"sha": "71038fd576e8551a8e46b99cabe7cd138571498a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71038fd576e8551a8e46b99cabe7cd138571498a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71038fd576e8551a8e46b99cabe7cd138571498a"}], "stats": {"total": 430, "additions": 223, "deletions": 207}, "files": [{"sha": "0615327dd8ca2b473040005a5c05d6762e709109", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -1,9 +1,29 @@\n+2001-08-21  Zack Weinberg  <zackw@panix.com>\n+\n+\t* stmt.c: Don't include insn-codes.h.\n+\t(expand_end_case): Machine specific logic moved to expr.c.\n+\tNo need to worry about __builtin_classify_type.\n+\t(check_for_full_enumeration_handling, emit_case_nodes):\n+\tKill #if 0 blocks.\n+\n+\t* builtins.o (expand_builtin_classify_type): Split up so code\n+\tcan be shared with fold_builtin_classify_type.\n+\t(type_to_class, fold_builtin_classify_type): New functions.\n+\t(fold_builtins): Handle __builtin_classify_type.\n+\n+\t* expr.c (do_tablejump): Now static.\n+\t(case_values_threshold, try_casesi, try_tablejump): New;\n+\tcode mostly from stmt.c (expand_end_case).\n+\t(expr.h): Update prototypes.\n+\n+\t* Makefile.in (stmt.o): Update dependencies.\n+\n 2001-08-21  Will Cohen  <wcohen@redhat.com>\n \n-        * configure/alpha/alpha.h (CONDITIONAL_REGISTER_USAGE): Added local\n-        declaration of variable i.\n-        * configure/rs6000/rs6000.h (CONDITIONAL_REGISTER_USAGE): Added local\n-        declaration of variable i.\n+\t* configure/alpha/alpha.h (CONDITIONAL_REGISTER_USAGE): Added local\n+\tdeclaration of variable i.\n+\t* configure/rs6000/rs6000.h (CONDITIONAL_REGISTER_USAGE): Added local\n+\tdeclaration of variable i.\n \n 2001-08-21  Richard Henderson  <rth@redhat.com>\n "}, {"sha": "478a10c6d2fba77a1e1f2740f90bef20fb67b4a5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -1383,7 +1383,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-codes.h $(EXPR_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h $(GGC_H) $(TM_P_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n-   insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n+   insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h $(EXPR_H) libfuncs.h integrate.h \\"}, {"sha": "2d92e0072585411163f999a8ff8712c11b4e4850", "filename": "gcc/builtins.c", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -91,6 +91,7 @@ static rtx expand_builtin_apply_args\tPARAMS ((void));\n static rtx expand_builtin_apply_args_1\tPARAMS ((void));\n static rtx expand_builtin_apply\t\tPARAMS ((rtx, rtx, rtx));\n static void expand_builtin_return\tPARAMS ((rtx));\n+static int type_to_class\t\tPARAMS ((tree));\n static rtx expand_builtin_classify_type\tPARAMS ((tree));\n static rtx expand_builtin_mathfn\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_constant_p\tPARAMS ((tree));\n@@ -142,6 +143,7 @@ static rtx expand_builtin_fputs\t\tPARAMS ((tree, int));\n static tree stabilize_va_list\t\tPARAMS ((tree, int));\n static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n static tree fold_builtin_constant_p\tPARAMS ((tree));\n+static tree fold_builtin_classify_type\tPARAMS ((tree));\n static tree build_function_call_expr\tPARAMS ((tree, tree));\n static int validate_arglist\t\tPARAMS ((tree, ...));\n \n@@ -1267,58 +1269,45 @@ expand_builtin_return (result)\n   expand_null_return ();\n }\n \n+/* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */\n+static enum type_class\n+type_to_class (type)\n+     tree type;\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\t   return void_type_class;\n+    case INTEGER_TYPE:\t   return integer_type_class;\n+    case CHAR_TYPE:\t   return char_type_class;\n+    case ENUMERAL_TYPE:\t   return enumeral_type_class;\n+    case BOOLEAN_TYPE:\t   return boolean_type_class;\n+    case POINTER_TYPE:\t   return pointer_type_class;\n+    case REFERENCE_TYPE:   return reference_type_class;\n+    case OFFSET_TYPE:\t   return offset_type_class;\n+    case REAL_TYPE:\t   return real_type_class;\n+    case COMPLEX_TYPE:\t   return complex_type_class;\n+    case FUNCTION_TYPE:\t   return function_type_class;\n+    case METHOD_TYPE:\t   return method_type_class;\n+    case RECORD_TYPE:\t   return record_type_class;\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:  return union_type_class;\n+    case ARRAY_TYPE:\t   return (TYPE_STRING_FLAG (type)\n+\t\t\t\t   ? string_type_class : array_type_class);\n+    case SET_TYPE:\t   return set_type_class;\n+    case FILE_TYPE:\t   return file_type_class;\n+    case LANG_TYPE:\t   return lang_type_class;\n+    default:\t\t   return no_type_class;\n+    }\n+}\n+  \n /* Expand a call to __builtin_classify_type with arguments found in\n    ARGLIST.  */\n static rtx\n expand_builtin_classify_type (arglist)\n      tree arglist;\n {\n   if (arglist != 0)\n-    {\n-      tree type = TREE_TYPE (TREE_VALUE (arglist));\n-      enum tree_code code = TREE_CODE (type);\n-      if (code == VOID_TYPE)\n-\treturn GEN_INT (void_type_class);\n-      if (code == INTEGER_TYPE)\n-\treturn GEN_INT (integer_type_class);\n-      if (code == CHAR_TYPE)\n-\treturn GEN_INT (char_type_class);\n-      if (code == ENUMERAL_TYPE)\n-\treturn GEN_INT (enumeral_type_class);\n-      if (code == BOOLEAN_TYPE)\n-\treturn GEN_INT (boolean_type_class);\n-      if (code == POINTER_TYPE)\n-\treturn GEN_INT (pointer_type_class);\n-      if (code == REFERENCE_TYPE)\n-\treturn GEN_INT (reference_type_class);\n-      if (code == OFFSET_TYPE)\n-\treturn GEN_INT (offset_type_class);\n-      if (code == REAL_TYPE)\n-\treturn GEN_INT (real_type_class);\n-      if (code == COMPLEX_TYPE)\n-\treturn GEN_INT (complex_type_class);\n-      if (code == FUNCTION_TYPE)\n-\treturn GEN_INT (function_type_class);\n-      if (code == METHOD_TYPE)\n-\treturn GEN_INT (method_type_class);\n-      if (code == RECORD_TYPE)\n-\treturn GEN_INT (record_type_class);\n-      if (code == UNION_TYPE || code == QUAL_UNION_TYPE)\n-\treturn GEN_INT (union_type_class);\n-      if (code == ARRAY_TYPE)\n-\t{\n-\t  if (TYPE_STRING_FLAG (type))\n-\t    return GEN_INT (string_type_class);\n-\t  else\n-\t    return GEN_INT (array_type_class);\n-\t}\n-      if (code == SET_TYPE)\n-\treturn GEN_INT (set_type_class);\n-      if (code == FILE_TYPE)\n-\treturn GEN_INT (file_type_class);\n-      if (code == LANG_TYPE)\n-\treturn GEN_INT (lang_type_class);\n-    }\n+    return GEN_INT (type_to_class (TREE_TYPE (TREE_VALUE (arglist))));\n   return GEN_INT (no_type_class);\n }\n \n@@ -3806,6 +3795,17 @@ fold_builtin_constant_p (arglist)\n   return 0;\n }\n \n+/* Fold a call to __builtin_classify_type.  */\n+static tree\n+fold_builtin_classify_type (arglist)\n+     tree arglist;\n+{\n+  if (arglist == 0)\n+    return build_int_2 (no_type_class, 0);\n+\n+  return build_int_2 (type_to_class (TREE_TYPE (TREE_VALUE (arglist))), 0);\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -3825,6 +3825,9 @@ fold_builtin (exp)\n     case BUILT_IN_CONSTANT_P:\n       return fold_builtin_constant_p (arglist);\n \n+    case BUILT_IN_CLASSIFY_TYPE:\n+      return fold_builtin_classify_type (arglist);\n+\n     case BUILT_IN_STRLEN:\n       if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n \t{"}, {"sha": "ffb46cb59c18889de8af120d0d023ab4bf4ae92c", "filename": "gcc/expr.c", "status": "modified", "additions": 134, "deletions": 5, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -177,6 +177,7 @@ static rtx do_store_flag\tPARAMS ((tree, rtx, enum machine_mode, int));\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn PARAMS ((enum machine_mode, rtx, tree));\n #endif\n+static void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -10717,11 +10718,112 @@ do_store_flag (exp, target, mode, only_cheap)\n   return target;\n }\n \f\n-/* Generate a tablejump instruction (used for switch statements).  */\n \n-#ifdef HAVE_tablejump\n+/* Stubs in case we haven't got a casesi insn.  */\n+#ifndef HAVE_casesi\n+# define HAVE_casesi 0\n+# define gen_casesi(a, b, c, d, e) (0)\n+# define CODE_FOR_casesi CODE_FOR_nothing\n+#endif\n+\n+/* If the machine does not have a case insn that compares the bounds,\n+   this means extra overhead for dispatch tables, which raises the\n+   threshold for using them.  */\n+#ifndef CASE_VALUES_THRESHOLD\n+#define CASE_VALUES_THRESHOLD (HAVE_casesi ? 4 : 5)\n+#endif /* CASE_VALUES_THRESHOLD */\n+\n+unsigned int\n+case_values_threshold ()\n+{\n+  return CASE_VALUES_THRESHOLD;\n+}\n+\n+/* Attempt to generate a casesi instruction.  Returns 1 if successful,\n+   0 otherwise (i.e. if there is no casesi instruction).  */\n+int\n+try_casesi (index_type, index_expr, minval, range,\n+\t    table_label, default_label)\n+     tree index_type, index_expr, minval, range;\n+     rtx table_label ATTRIBUTE_UNUSED;\n+     rtx default_label;\n+{\n+  enum machine_mode index_mode = SImode;\n+  int index_bits = GET_MODE_BITSIZE (index_mode);\n+  rtx op1, op2, index;\n+  enum machine_mode op_mode;\n+\n+  if (! HAVE_casesi)\n+    return 0;\n+\n+  /* Convert the index to SImode.  */\n+  if (GET_MODE_BITSIZE (TYPE_MODE (index_type)) > GET_MODE_BITSIZE (index_mode))\n+    {\n+      enum machine_mode omode = TYPE_MODE (index_type);\n+      rtx rangertx = expand_expr (range, NULL_RTX, VOIDmode, 0);\n+\n+      /* We must handle the endpoints in the original mode.  */\n+      index_expr = build (MINUS_EXPR, index_type,\n+\t\t\t  index_expr, minval);\n+      minval = integer_zero_node;\n+      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n+      emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n+\t\t\t       omode, 1, 0, default_label);\n+      /* Now we can safely truncate.  */\n+      index = convert_to_mode (index_mode, index, 0);\n+    }\n+  else\n+    {\n+      if (TYPE_MODE (index_type) != index_mode)\n+\t{\n+\t  index_expr = convert (type_for_size (index_bits, 0),\n+\t\t\t\tindex_expr);\n+\t  index_type = TREE_TYPE (index_expr);\n+\t}\n+\n+      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n+    }\n+  emit_queue ();\n+  index = protect_from_queue (index, 0);\n+  do_pending_stack_adjust ();\n+\n+  op_mode = insn_data[(int) CODE_FOR_casesi].operand[0].mode;\n+  if (! (*insn_data[(int) CODE_FOR_casesi].operand[0].predicate)\n+      (index, op_mode))\n+    index = copy_to_mode_reg (op_mode, index);\n \n-/* INDEX is the value being switched on, with the lowest value\n+  op1 = expand_expr (minval, NULL_RTX, VOIDmode, 0);\n+\n+  op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n+  op1 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (minval)),\n+\t\t       op1, TREE_UNSIGNED (TREE_TYPE (minval)));\n+  if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n+      (op1, op_mode))\n+    op1 = copy_to_mode_reg (op_mode, op1);\n+\n+  op2 = expand_expr (range, NULL_RTX, VOIDmode, 0);\n+\n+  op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n+  op2 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (range)),\n+\t\t       op2, TREE_UNSIGNED (TREE_TYPE (range)));\n+  if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n+      (op2, op_mode))\n+    op2 = copy_to_mode_reg (op_mode, op2);\n+\n+  emit_jump_insn (gen_casesi (index, op1, op2,\n+\t\t\t      table_label, default_label));\n+  return 1;\n+}\n+\n+/* Attempt to generate a tablejump instruction; same concept.  */\n+#ifndef HAVE_tablejump\n+#define HAVE_tablejump 0\n+#define gen_tablejump(x, y) (0)\n+#endif\n+\n+/* Subroutine of the next function.\n+\n+   INDEX is the value being switched on, with the lowest value\n    in the table already subtracted.\n    MODE is its expected mode (needed if INDEX is constant).\n    RANGE is the length of the jump table.\n@@ -10730,7 +10832,7 @@ do_store_flag (exp, target, mode, only_cheap)\n    DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the\n    index value is out of range.  */\n \n-void\n+static void\n do_tablejump (index, mode, range, table_label, default_label)\n      rtx index, range, table_label, default_label;\n      enum machine_mode mode;\n@@ -10792,4 +10894,31 @@ do_tablejump (index, mode, range, table_label, default_label)\n     emit_barrier ();\n }\n \n-#endif /* HAVE_tablejump  */\n+int\n+try_tablejump (index_type, index_expr, minval, range,\n+\t       table_label, default_label)\n+     tree index_type, index_expr, minval, range;\n+     rtx table_label, default_label;\n+{\n+  rtx index;\n+\n+  if (! HAVE_tablejump)\n+    return 0;\n+\n+  index_expr = fold (build (MINUS_EXPR, index_type,\n+\t\t\t    convert (index_type, index_expr),\n+\t\t\t    convert (index_type, minval)));\n+  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n+  emit_queue ();\n+  index = protect_from_queue (index, 0);\n+  do_pending_stack_adjust ();\n+\n+  do_tablejump (index, TYPE_MODE (index_type),\n+\t\tconvert_modes (TYPE_MODE (index_type),\n+\t\t\t       TYPE_MODE (TREE_TYPE (range)),\n+\t\t\t       expand_expr (range, NULL_RTX,\n+\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t       TREE_UNSIGNED (TREE_TYPE (range))),\n+\t\ttable_label, default_label);\n+  return 1;\n+}"}, {"sha": "22e537d62fc7da1a7c647aab45cba9b3e65d1c72", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -540,8 +540,14 @@ extern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n \t\t\t\t\t     enum machine_mode, rtx,\n \t\t\t\t\t     unsigned int, rtx, rtx));\n \n-/* Generate a tablejump instruction (used for switch statements).  */\n-extern void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n+/* Two different ways of generating switch statements.  */\n+extern int try_casesi    PARAMS ((tree, tree, tree, tree, rtx, rtx));\n+extern int try_tablejump PARAMS ((tree, tree, tree, tree, rtx, rtx));\n+\n+/* Smallest number of adjacent cases before we use a jump table.\n+   XXX Should be a target hook.  */\n+extern unsigned int case_values_threshold PARAMS ((void));\n+\n \f\n #ifdef TREE_CODE\n /* rtl.h and tree.h were included.  */"}, {"sha": "d4b4e0400cd6f4b4156cef1de91b865e7a81cfc8", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 150, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82abb8e647ebdfa459383c25130a97a8a9b849/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ad82abb8e647ebdfa459383c25130a97a8a9b849", "patch": "@@ -43,7 +43,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"insn-config.h\"\n-#include \"insn-codes.h\"\n #include \"expr.h\"\n #include \"libfuncs.h\"\n #include \"hard-reg-set.h\"\n@@ -5021,10 +5020,6 @@ check_for_full_enumeration_handling (type)\n {\n   register struct case_node *n;\n   register tree chain;\n-#if 0  /* variable used by 'if 0'ed  code below.  */\n-  register struct case_node **l;\n-  int all_values = 1;\n-#endif\n \n   /* True iff the selector type is a numbered set mode.  */\n   int sparseness = 0;\n@@ -5122,28 +5117,6 @@ check_for_full_enumeration_handling (type)\n \t      }\n \t  }\n       }\n-\n-#if 0\n-  /* ??? This optimization is disabled because it causes valid programs to\n-     fail.  ANSI C does not guarantee that an expression with enum type\n-     will have a value that is the same as one of the enumeration literals.  */\n-\n-  /* If all values were found as case labels, make one of them the default\n-     label.  Thus, this switch will never fall through.  We arbitrarily pick\n-     the last one to make the default since this is likely the most\n-     efficient choice.  */\n-\n-  if (all_values)\n-    {\n-      for (l = &case_stack->data.case_stmt.case_list;\n-\t   (*l)->right != 0;\n-\t   l = &(*l)->right)\n-\t;\n-\n-      case_stack->data.case_stmt.default_label = (*l)->code_label;\n-      *l = 0;\n-    }\n-#endif /* 0 */\n }\n \n /* Free CN, and its children.  */\n@@ -5161,6 +5134,7 @@ free_case_nodes (cn)\n }\n \n \f\n+\n /* Terminate a case (Pascal) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n    Generate the code to test it and jump to the right place.  */\n@@ -5289,18 +5263,7 @@ expand_end_case (orig_index)\n \t If the switch-index is a constant, do it this way\n \t because we can optimize it.  */\n \n-#ifndef CASE_VALUES_THRESHOLD\n-#ifdef HAVE_casesi\n-#define CASE_VALUES_THRESHOLD (HAVE_casesi ? 4 : 5)\n-#else\n-      /* If machine does not have a case insn that compares the\n-\t bounds, this means extra overhead for dispatch tables\n-\t which raises the threshold for using them.  */\n-#define CASE_VALUES_THRESHOLD 5\n-#endif /* HAVE_casesi */\n-#endif /* CASE_VALUES_THRESHOLD */\n-\n-      else if (count < CASE_VALUES_THRESHOLD\n+      else if (count < case_values_threshold ()\n \t       || compare_tree_int (range, 10 * count) > 0\n \t       /* RANGE may be signed, and really large ranges will show up\n \t\t  as negative numbers.  */\n@@ -5309,12 +5272,6 @@ expand_end_case (orig_index)\n \t       || flag_pic\n #endif\n \t       || TREE_CODE (index_expr) == INTEGER_CST\n-\t       /* These will reduce to a constant.  */\n-\t       || (TREE_CODE (index_expr) == CALL_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (index_expr, 0)) == ADDR_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == FUNCTION_DECL\n-\t\t   && DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == BUILT_IN_NORMAL\n-\t\t   && DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == BUILT_IN_CLASSIFY_TYPE)\n \t       || (TREE_CODE (index_expr) == COMPOUND_EXPR\n \t\t   && TREE_CODE (TREE_OPERAND (index_expr, 1)) == INTEGER_CST))\n \t{\n@@ -5399,100 +5356,15 @@ expand_end_case (orig_index)\n \t}\n       else\n \t{\n-\t  int win = 0;\n-#ifdef HAVE_casesi\n-\t  if (HAVE_casesi)\n-\t    {\n-\t      enum machine_mode index_mode = SImode;\n-\t      int index_bits = GET_MODE_BITSIZE (index_mode);\n-\t      rtx op1, op2;\n-\t      enum machine_mode op_mode;\n-\n-\t      /* Convert the index to SImode.  */\n-\t      if (GET_MODE_BITSIZE (TYPE_MODE (index_type))\n-\t\t  > GET_MODE_BITSIZE (index_mode))\n-\t\t{\n-\t\t  enum machine_mode omode = TYPE_MODE (index_type);\n-\t\t  rtx rangertx = expand_expr (range, NULL_RTX, VOIDmode, 0);\n-\n-\t\t  /* We must handle the endpoints in the original mode.  */\n-\t\t  index_expr = build (MINUS_EXPR, index_type,\n-\t\t\t\t      index_expr, minval);\n-\t\t  minval = integer_zero_node;\n-\t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-\t\t  emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n-\t\t\t\t\t   omode, 1, 0, default_label);\n-\t\t  /* Now we can safely truncate.  */\n-\t\t  index = convert_to_mode (index_mode, index, 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (TYPE_MODE (index_type) != index_mode)\n-\t\t    {\n-\t\t      index_expr = convert (type_for_size (index_bits, 0),\n-\t\t\t\t\t    index_expr);\n-\t\t      index_type = TREE_TYPE (index_expr);\n-\t\t    }\n-\n-\t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-\t\t}\n-\t      emit_queue ();\n-\t      index = protect_from_queue (index, 0);\n-\t      do_pending_stack_adjust ();\n-\n-\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[0].mode;\n-\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[0].predicate)\n-\t\t  (index, op_mode))\n-\t\tindex = copy_to_mode_reg (op_mode, index);\n-\n-\t      op1 = expand_expr (minval, NULL_RTX, VOIDmode, 0);\n-\n-\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n-\t      op1 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (minval)),\n-\t\t\t\t   op1, TREE_UNSIGNED (TREE_TYPE (minval)));\n-\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n-\t\t  (op1, op_mode))\n-\t\top1 = copy_to_mode_reg (op_mode, op1);\n-\n-\t      op2 = expand_expr (range, NULL_RTX, VOIDmode, 0);\n-\n-\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n-\t      op2 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (range)),\n-\t\t\t\t   op2, TREE_UNSIGNED (TREE_TYPE (range)));\n-\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n-\t\t  (op2, op_mode))\n-\t\top2 = copy_to_mode_reg (op_mode, op2);\n-\n-\t      emit_jump_insn (gen_casesi (index, op1, op2,\n-\t\t\t\t\t  table_label, default_label));\n-\t      win = 1;\n-\t    }\n-#endif\n-#ifdef HAVE_tablejump\n-\t  if (! win && HAVE_tablejump)\n+\t  if (! try_casesi (index_type, index_expr, minval, range,\n+\t\t\t    table_label, default_label))\n \t    {\n \t      index_type = thiscase->data.case_stmt.nominal_type;\n-\t      index_expr = fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t\tconvert (index_type, index_expr),\n-\t\t\t\t\tconvert (index_type, minval)));\n-\t      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-\t      emit_queue ();\n-\t      index = protect_from_queue (index, 0);\n-\t      do_pending_stack_adjust ();\n-\n-\t      do_tablejump (index, TYPE_MODE (index_type),\n-\t\t\t    convert_modes (TYPE_MODE (index_type),\n-\t\t\t\t\t   TYPE_MODE (TREE_TYPE (range)),\n-\t\t\t\t\t   expand_expr (range, NULL_RTX,\n-\t\t\t\t\t\t\tVOIDmode, 0),\n-\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (range))),\n-\t\t\t    table_label, default_label);\n-\t      win = 1;\n+\t      if (! try_tablejump (index_type, index_expr, minval, range,\n+\t\t\t\t   table_label, default_label))\n+\t\tabort ();\n \t    }\n-#endif\n-\t  if (! win)\n-\t    abort ();\n-\n+\t  \n \t  /* Get table of labels to jump to, in order of case index.  */\n \n \t  ncases = TREE_INT_CST_LOW (range) + 1;\n@@ -6133,20 +6005,6 @@ emit_case_nodes (index, node, default_label, index_type)\n       else if (node->right == 0 && node->left != 0)\n \t{\n \t  /* Just one subtree, on the left.  */\n-\n-#if 0 /* The following code and comment were formerly part\n-\t of the condition here, but they didn't work\n-\t and I don't understand what the idea was.  -- rms.  */\n-\t  /* If our \"most probable entry\" is less probable\n-\t     than the default label, emit a jump to\n-\t     the default label using condition codes\n-\t     already lying around.  With no right branch,\n-\t     a branch-greater-than will get us to the default\n-\t     label correctly.  */\n-\t  if (use_cost_table\n-\t      && COST_TABLE (TREE_INT_CST_LOW (node->high)) < 12)\n-\t    ;\n-#endif /* 0 */\n \t  if (node->left->left || node->left->right\n \t      || !tree_int_cst_equal (node->left->low, node->left->high))\n \t    {"}]}