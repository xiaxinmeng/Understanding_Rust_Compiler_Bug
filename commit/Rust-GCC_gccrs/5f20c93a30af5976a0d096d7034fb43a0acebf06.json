{"sha": "5f20c93a30af5976a0d096d7034fb43a0acebf06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyMGM5M2EzMGFmNTk3NmEwZDA5NmQ3MDM0ZmI0M2EwYWNlYmYwNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-06T22:56:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-06T22:56:39Z"}, "message": "re PR fortran/26107 (ICE after error message on invalid code)\n\n2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26107\n\t* resolve.c (resolve_function): Add name after test for pureness.\n\n\tPR fortran/19546\n\t* trans-expr.c (gfc_conv_variable): Detect reference to parent result,\n\tstore current_function_decl, replace with parent, whilst calls are\n\tmade to gfc_get_fake_result_decl, and restore afterwards. Signal this\n\tto gfc_get_fake_result_decl with a new argument, parent_flag.\n\t* trans-stmt.c (gfc_trans_return): gfc_get_fake_result_decl 2nd arg\n\tis set to zero.\n\t* trans.h: Add parent_flag to gfc_get_fake_result_decl prototype.\n\t* trans-decl.c (gfc_get_fake_result_decl): On parent_flag, being set,\n\tadd decl to parent function. Replace refs to current_fake_result_decl\n\twith refs to this_result_decl.\n\t(gfc_generate_function_code): Null parent_fake_result_decl before the\n\ttranslation of code for contained procedures. Set parent_flag to zero\n\tin call to gfc_get_fake_result_decl.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_len): The same.\n\n2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26107\n\t* pure_dummy_length_1.f90: New test.\n\n\tPR fortran/19546\n\t* gfortran.dg/parent_result_ref_1.f90: New test.\n\t* gfortran.dg/parent_result_ref_2.f90: New test.\n\t* gfortran.dg/parent_result_ref_3.f90: New test.\n\t* gfortran.dg/parent_result_ref_4.f90: New test.\n\nFrom-SVN: r111793", "tree": {"sha": "ad8e6e07b196abe43de18b2f58d813f554c6e2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad8e6e07b196abe43de18b2f58d813f554c6e2ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f20c93a30af5976a0d096d7034fb43a0acebf06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f20c93a30af5976a0d096d7034fb43a0acebf06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f20c93a30af5976a0d096d7034fb43a0acebf06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f20c93a30af5976a0d096d7034fb43a0acebf06/comments", "author": null, "committer": null, "parents": [{"sha": "9202989a98f7f0b7244cc4fe6efcb4e78833ad3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9202989a98f7f0b7244cc4fe6efcb4e78833ad3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9202989a98f7f0b7244cc4fe6efcb4e78833ad3d"}], "stats": {"total": 368, "additions": 303, "deletions": 65}, "files": [{"sha": "dcc3c59c00c74ecaeb1a4dca1e72d5bee0100f82", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -1,8 +1,29 @@\n+2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26107\n+\t* resolve.c (resolve_function): Add name after test for pureness.\n+\n+\tPR fortran/19546\n+\t* trans-expr.c (gfc_conv_variable): Detect reference to parent result,\n+\tstore current_function_decl, replace with parent, whilst calls are\n+\tmade to gfc_get_fake_result_decl, and restore afterwards. Signal this\n+\tto gfc_get_fake_result_decl with a new argument, parent_flag.\n+\t* trans-stmt.c (gfc_trans_return): gfc_get_fake_result_decl 2nd arg\n+\tis set to zero.\n+\t* trans.h: Add parent_flag to gfc_get_fake_result_decl prototype.\n+\t* trans-decl.c (gfc_get_fake_result_decl): On parent_flag, being set,\n+\tadd decl to parent function. Replace refs to current_fake_result_decl\n+\twith refs to this_result_decl.\n+\t(gfc_generate_function_code): Null parent_fake_result_decl before the\n+\ttranslation of code for contained procedures. Set parent_flag to zero\n+\tin call to gfc_get_fake_result_decl.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_len): The same.\n+\n 2006-03-05  Steven G. Kargl  <kargls@comcast.net>\n \n \t* simplify.c (gfc_simplify_verify):  Fix return when SET=''.\n \n-2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/16136\n \t* symbol.c (conf_std): New macro.\n@@ -180,7 +201,7 @@\n \t* intrinsic.c (gfc_convert_type_warn): Call\n \tgfc_intrinsic_symbol() on the newly created symbol.\n \n-2005-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+2006-02-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25054\n \t* resolve.c (is_non_constant_shape_array): New function.\n@@ -232,7 +253,7 @@\n \t* openmp.c (resolve_omp_clauses): Add a dummy case label to workaround\n \tPR middle-end/26316.\n \n-2005-02-16  Paul Thomas  <pault@gcc.gnu.org>\n+2006-02-16  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24557\n \t* trans-expr.c (gfc_add_interface_mapping): Use the actual argument\n@@ -767,7 +788,7 @@\n \t* trans-decl.c (gfc_generate_function_code): Add new argument,\n \tpedantic, to set_std call.\n \n-2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+2006-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/23815\n \t* gfortran.texi: Document the GFORTRAN_CONVERT_UNIT environment\n@@ -929,7 +950,7 @@\n \tfor checking arguments array and mask.\n \t(check_reduction):  Likewise.\n \n-2005-01-30  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-01-30  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/24266\n \t* trans-io.c (set_internal_unit): Check the rank of the\n@@ -958,7 +979,7 @@\n \t* gfortran.h: Add prototype for gfc_dep_compare_expr.\n \t* dependency.h: Remove prototype for gfc_dep_compare_expr.\n \n-2005-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25964\n \t* resolve.c (resolve_function): Add GFC_ISYM_LOC to the list of\n@@ -986,12 +1007,12 @@\n \t* lang-specs.h: Pass -fpreprocessed to f951 if preprocessing\n \tsources.\n \n-2005-01-27  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-01-27  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \t* symbol.c (free_old_symbol): Fix confusing comment, and add code\n \t  to free old_symbol->formal.\n \n-2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-26  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25964\n \t* resolve.c (resolve_function): Exclude statement functions from\n@@ -1023,7 +1044,7 @@\n \ttemporary from \"parm\" to \"ifm\" to avoid clash with temp coming from\n \ttrans-array.c.\n \n-2005-01-25  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-01-25  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25716\n \t* symbol.c (free_old_symbol): New function.\n@@ -1038,7 +1059,7 @@\n \t* resolve.c (gfc_resolve_index): Make sure typespec is\n \tproperly initialized.\n \n-2005-01-23  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25901\n \t* decl.c (get_proc_name): Replace subroutine and function attributes\n@@ -1057,7 +1078,7 @@\n \t* gfortranspec.c (lang_specific_driver): Update copyright notice\n \tdate.\n \n-2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25124\n \tPR fortran/25625\n@@ -1210,7 +1231,7 @@\n \t* scanner.c (load_line): use maxlen to determine the line-length used\n \tfor padding lines in fixed form.\n \n-2005-01-11  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-11  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25730\n \t* trans-types.c (copy_dt_decls_ifequal): Copy backend decl for\n@@ -1248,13 +1269,13 @@\n \t(gfc_simplify_ichar): Get the result from unsinged char and in the\n \trange 0 to UCHAR_MAX instead of CHAR_MIN to CHAR_MAX.\n \n-2005-01-08  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-01-08  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25093\n \t* resolve.c (resolve_fntype): Check that PUBLIC functions\n \taren't of PRIVATE type.\n \n-2005-01-07  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+2006-01-07  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* decl.c (gfc_match_function_decl): Correctly error out in case of\n \tomitted function argument list."}, {"sha": "3e7eb9dcea3940ccbca63db91c727bd1248278b6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -1357,7 +1357,7 @@ resolve_function (gfc_expr * expr)\n \n   need_full_assumed_size = temp;\n \n-  if (!pure_function (expr, &name))\n+  if (!pure_function (expr, &name) && name)\n     {\n       if (forall_flag)\n \t{"}, {"sha": "daa452e74c1acd83231c965d7e4fdb4f33a8d327", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -50,6 +50,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Holds the result of the function if no result variable specified.  */\n \n static GTY(()) tree current_fake_result_decl;\n+static GTY(()) tree parent_fake_result_decl;\n \n static GTY(()) tree current_function_return_label;\n \n@@ -1733,28 +1734,49 @@ gfc_create_function_decl (gfc_namespace * ns)\n   create_function_arglist (ns->proc_name);\n }\n \n-/* Return the decl used to hold the function return value.  */\n+/* Return the decl used to hold the function return value.  If\n+   parent_flag is set, the context is the parent_scope*/\n \n tree\n-gfc_get_fake_result_decl (gfc_symbol * sym)\n+gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n {\n-  tree decl, length;\n+  tree decl;\n+  tree length;\n+  tree this_fake_result_decl;\n+  tree this_function_decl;\n \n   char name[GFC_MAX_SYMBOL_LEN + 10];\n \n+  if (parent_flag)\n+    {\n+      this_fake_result_decl = parent_fake_result_decl;\n+      this_function_decl = DECL_CONTEXT (current_function_decl);\n+    }\n+  else\n+    {\n+      this_fake_result_decl = current_fake_result_decl;\n+      this_function_decl = current_function_decl;\n+    }\n+\n   if (sym\n-      && sym->ns->proc_name->backend_decl == current_function_decl\n+      && sym->ns->proc_name->backend_decl == this_function_decl\n       && sym->ns->proc_name->attr.entry_master\n       && sym != sym->ns->proc_name)\n     {\n       tree t = NULL, var;\n-      if (current_fake_result_decl != NULL)\n-\tfor (t = TREE_CHAIN (current_fake_result_decl); t; t = TREE_CHAIN (t))\n+      if (this_fake_result_decl != NULL)\n+\tfor (t = TREE_CHAIN (this_fake_result_decl); t; t = TREE_CHAIN (t))\n \t  if (strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)), sym->name) == 0)\n \t    break;\n       if (t)\n \treturn TREE_VALUE (t);\n-      decl = gfc_get_fake_result_decl (sym->ns->proc_name);\n+      decl = gfc_get_fake_result_decl (sym->ns->proc_name, parent_flag);\n+\n+      if (parent_flag)\n+\tthis_fake_result_decl = parent_fake_result_decl;\n+      else\n+\tthis_fake_result_decl = current_fake_result_decl;\n+\n       if (decl && sym->ns->proc_name->attr.mixed_entry_master)\n \t{\n \t  tree field;\n@@ -1769,18 +1791,24 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \t  decl = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field,\n \t\t\t NULL_TREE);\n \t}\n-      var = gfc_create_var (TREE_TYPE (decl), sym->name);\n-      GFC_DECL_RESULT (var) = 1;\n+\n+      var = create_tmp_var_raw (TREE_TYPE (decl), sym->name);\n+      if (parent_flag)\n+\tgfc_add_decl_to_parent_function (var);\n+      else\n+\tgfc_add_decl_to_function (var);\n+\n       SET_DECL_VALUE_EXPR (var, decl);\n       DECL_HAS_VALUE_EXPR_P (var) = 1;\n-      TREE_CHAIN (current_fake_result_decl)\n-\t= tree_cons (get_identifier (sym->name), var,\n-\t\t     TREE_CHAIN (current_fake_result_decl));\n+\n+      TREE_CHAIN (this_fake_result_decl)\n+\t  = tree_cons (get_identifier (sym->name), var,\n+\t\t       TREE_CHAIN (this_fake_result_decl));\n       return var;\n     }\n \n-  if (current_fake_result_decl != NULL_TREE)\n-    return TREE_VALUE (current_fake_result_decl);\n+  if (this_fake_result_decl != NULL_TREE)\n+    return TREE_VALUE (this_fake_result_decl);\n \n   /* Only when gfc_get_fake_result_decl is called by gfc_trans_return,\n      sym is NULL.  */\n@@ -1800,9 +1828,9 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \n   if (gfc_return_by_reference (sym))\n     {\n-      decl = DECL_ARGUMENTS (current_function_decl);\n+      decl = DECL_ARGUMENTS (this_function_decl);\n \n-      if (sym->ns->proc_name->backend_decl == current_function_decl\n+      if (sym->ns->proc_name->backend_decl == this_function_decl\n \t  && sym->ns->proc_name->attr.entry_master)\n \tdecl = TREE_CHAIN (decl);\n \n@@ -1813,10 +1841,10 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n   else\n     {\n       sprintf (name, \"__result_%.20s\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+\t       IDENTIFIER_POINTER (DECL_NAME (this_function_decl)));\n \n       decl = build_decl (VAR_DECL, get_identifier (name),\n-\t\t\t TREE_TYPE (TREE_TYPE (current_function_decl)));\n+\t\t\t TREE_TYPE (TREE_TYPE (this_function_decl)));\n \n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_EXTERNAL (decl) = 0;\n@@ -1826,10 +1854,16 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \n       layout_decl (decl, 0);\n \n-      gfc_add_decl_to_function (decl);\n+      if (parent_flag)\n+\tgfc_add_decl_to_parent_function (decl);\n+      else\n+\tgfc_add_decl_to_function (decl);\n     }\n \n-  current_fake_result_decl = build_tree_list (NULL, decl);\n+  if (parent_flag)\n+    parent_fake_result_decl = build_tree_list (NULL, decl);\n+  else\n+    current_fake_result_decl = build_tree_list (NULL, decl);\n \n   return decl;\n }\n@@ -2834,12 +2868,24 @@ gfc_generate_function_code (gfc_namespace * ns)\n   /* Translate COMMON blocks.  */\n   gfc_trans_common (ns);\n \n+  /* Null the parent fake result declaration if this namespace is\n+     a module function or an external procedures.  */\n+  if ((ns->parent && ns->parent->proc_name->attr.flavor == FL_MODULE)\n+\t|| ns->parent == NULL)\n+    parent_fake_result_decl = NULL_TREE;\n+\n   gfc_generate_contained_functions (ns);\n \n   generate_local_vars (ns);\n   \n-  /* Will be created as needed.  */\n-  current_fake_result_decl = NULL_TREE;\n+  /* Keep the parent fake result declaration in module functions\n+     or external procedures.  */\n+  if ((ns->parent && ns->parent->proc_name->attr.flavor == FL_MODULE)\n+\t|| ns->parent == NULL)\n+    current_fake_result_decl = parent_fake_result_decl;\n+  else\n+    current_fake_result_decl = NULL_TREE;\n+\n   current_function_return_label = NULL;\n \n   /* Now generate the code for the body of this function.  */\n@@ -2901,7 +2947,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n       && sym->attr.subroutine)\n     {\n       tree alternate_return;\n-      alternate_return = gfc_get_fake_result_decl (sym);\n+      alternate_return = gfc_get_fake_result_decl (sym, 0);\n       gfc_add_modify_expr (&body, alternate_return, integer_zero_node);\n     }\n "}, {"sha": "4be54594225272ece5f121e9c4a985b7ab81ed25", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -296,6 +296,11 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ref *ref;\n   gfc_symbol *sym;\n+  tree parent_decl;\n+  int parent_flag;\n+  bool return_value;\n+  bool alternate_entry;\n+  bool entry_master;\n \n   sym = expr->symtree->n.sym;\n   if (se->ss != NULL)\n@@ -317,32 +322,51 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \n       se->expr = gfc_get_symbol_decl (sym);\n \n+      /* Deal with references to a parent results or entries by storing\n+\t the current_function_decl and moving to the parent_decl.  */\n+      parent_flag = 0;\n+\n+      return_value = sym->attr.function && sym->result == sym;\n+      alternate_entry = sym->attr.function && sym->attr.entry\n+\t\t\t  && sym->result == sym;\n+      entry_master = sym->attr.result\n+\t\t\t&& sym->ns->proc_name->attr.entry_master\n+\t\t\t&& !gfc_return_by_reference (sym->ns->proc_name);\n+      parent_decl = DECL_CONTEXT (current_function_decl);\n+\n+      if ((se->expr == parent_decl && return_value)\n+\t    || (sym->ns  && sym->ns->proc_name\n+\t\t  && sym->ns->proc_name->backend_decl == parent_decl\n+\t\t  && (alternate_entry || entry_master)))\n+\tparent_flag = 1;\n+      else\n+\tparent_flag = 0;\n+\n       /* Special case for assigning the return value of a function.\n \t Self recursive functions must have an explicit return value.  */\n-      if (se->expr == current_function_decl && sym->attr.function\n-\t  && (sym->result == sym))\n-\tse_expr = gfc_get_fake_result_decl (sym);\n+      if (sym->attr.function && sym->result == sym\n+\t    && (se->expr == current_function_decl || parent_flag))\n+\tse_expr = gfc_get_fake_result_decl (sym, parent_flag);\n \n       /* Similarly for alternate entry points.  */\n-      else if (sym->attr.function && sym->attr.entry\n-\t       && (sym->result == sym)\n-\t       && sym->ns->proc_name->backend_decl == current_function_decl)\n+      else if (alternate_entry \n+\t\t && (sym->ns->proc_name->backend_decl == current_function_decl\n+\t\t        || parent_flag))\n \t{\n \t  gfc_entry_list *el = NULL;\n \n \t  for (el = sym->ns->entries; el; el = el->next)\n \t    if (sym == el->sym)\n \t      {\n-\t\tse_expr = gfc_get_fake_result_decl (sym);\n+\t\tse_expr = gfc_get_fake_result_decl (sym, parent_flag);\n \t\tbreak;\n \t      }\n \t}\n \n-      else if (sym->attr.result\n-\t       && sym->ns->proc_name->backend_decl == current_function_decl\n-\t       && sym->ns->proc_name->attr.entry_master\n-\t       && !gfc_return_by_reference (sym->ns->proc_name))\n-\tse_expr = gfc_get_fake_result_decl (sym);\n+      else if (entry_master\n+\t\t && (sym->ns->proc_name->backend_decl == current_function_decl\n+\t\t\t|| parent_flag))\n+\tse_expr = gfc_get_fake_result_decl (sym, parent_flag);\n \n       if (se_expr)\n \tse->expr = se_expr;"}, {"sha": "6ec0a5107be0a4d092ea40e7ea719338e87f4395", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -2269,7 +2269,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n \t    decl = gfc_get_symbol_decl (sym);\n \t    if (decl == current_function_decl && sym->attr.function\n \t\t&& (sym->result == sym))\n-\t      decl = gfc_get_fake_result_decl (sym);\n+\t      decl = gfc_get_fake_result_decl (sym, 0);\n \n \t    len = sym->ts.cl->backend_decl;\n \t    gcc_assert (len);"}, {"sha": "df8723b29b5368e515610bcf9940bd61c3a252e4", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -182,6 +182,9 @@ gfc_trans_add_clause (tree node, tree tail)\n   return node;\n }\n \n+/* TODO make references to parent function results, as done in\n+   gfc_conv_variable.  */\n+\n static tree\n gfc_trans_omp_variable (gfc_symbol *sym)\n {\n@@ -191,7 +194,7 @@ gfc_trans_omp_variable (gfc_symbol *sym)\n      Self recursive functions must have an explicit return value.  */\n   if (t == current_function_decl && sym->attr.function\n       && (sym->result == sym))\n-    t = gfc_get_fake_result_decl (sym);\n+    t = gfc_get_fake_result_decl (sym, 0);\n \n   /* Similarly for alternate entry points.  */\n   else if (sym->attr.function && sym->attr.entry\n@@ -203,7 +206,7 @@ gfc_trans_omp_variable (gfc_symbol *sym)\n       for (el = sym->ns->entries; el; el = el->next)\n \tif (sym == el->sym)\n \t  {\n-\t    t = gfc_get_fake_result_decl (sym);\n+\t    t = gfc_get_fake_result_decl (sym, 0);\n \t    break;\n \t  }\n     }\n@@ -212,7 +215,7 @@ gfc_trans_omp_variable (gfc_symbol *sym)\n \t   && sym->ns->proc_name->backend_decl == current_function_decl\n \t   && sym->ns->proc_name->attr.entry_master\n \t   && !gfc_return_by_reference (sym->ns->proc_name))\n-    t = gfc_get_fake_result_decl (sym);\n+    t = gfc_get_fake_result_decl (sym, 0);\n \n   return t;\n }"}, {"sha": "b3141ca84c740c010dde23b58188a12556dc854d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -309,7 +309,7 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n          in a subroutine and current_fake_result_decl has already\n \t been generated.  */\n \n-      result = gfc_get_fake_result_decl (NULL);\n+      result = gfc_get_fake_result_decl (NULL, 0);\n       if (!result)\n         {\n           gfc_warning (\"An alternate return at %L without a * dummy argument\","}, {"sha": "e571df9d3a9cea327a99e5e4384d6dab00540d56", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -361,7 +361,7 @@ tree gfc_build_label_decl (tree);\n \n /* Return the decl used to hold the function return value.\n    Do not use if the function has an explicit result variable.  */\n-tree gfc_get_fake_result_decl (gfc_symbol *);\n+tree gfc_get_fake_result_decl (gfc_symbol *, int);\n \n /* Get the return label for the current function.  */\n tree gfc_get_return_label (void);"}, {"sha": "b1d03cfa6a3207f698ddfaad6431380e42111901", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -1,3 +1,14 @@\n+2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26107\n+\t* pure_dummy_length_1.f90: New test.\n+\n+\tPR fortran/19546\n+\t* gfortran.dg/parent_result_ref_1.f90: New test.\n+\t* gfortran.dg/parent_result_ref_2.f90: New test.\n+\t* gfortran.dg/parent_result_ref_3.f90: New test.\n+\t* gfortran.dg/parent_result_ref_4.f90: New test.\n+\n 2006-03-06  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.dg/verify_2.f90: New test.\n@@ -29,7 +40,7 @@\n \tPR c++/15759\n \t* g++.dg/other/default4.C: New test.\n \n-2005-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-03-05  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/16136\n \t* allocatable_dummy_1.f90: New.\n@@ -300,7 +311,7 @@\n \tPR fortran/26201\n \t* gfortran.dg/convert_1.f90: New.\n \n-2005-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+2006-02-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25054\n \t* gfortran.dg/namelist_5.f90: New test.\n@@ -396,7 +407,7 @@\n \tvect-reduc-pattern-1a.c, vect-reduc-pattern-1b.c and\n \tvect-reduc-pattern-1c.c\n \n-2005-02-16  Paul Thomas  <pault@gcc.gnu.org>\n+2006-02-16  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24557\n         * gfortran.dg/assumed_charlen_needed_1.f90: New test.\n@@ -710,7 +721,7 @@\n \t* g++.old-deja/g++.pt/ttp26.C: Likewise.\n \t* g++.old-deja/g++.pt/ttp36.C: Likewise.\n \n-2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+2006-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/23815\n \t* unf_io_convert_4.f90:  New test.\n@@ -876,7 +887,7 @@\n \t* gcc.target/i386/sselibm-4.c: Likewise.\n \t* gcc.target/i386/sselibm-5.c: Likewise.\n \n-2005-01-30  Erik Edelmann  <eedelman@gcc.gnu.org>\n+2006-01-30  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/24266\n \t* gfortran.dg/arrayio_derived_2.f90: New.\n@@ -971,7 +982,7 @@\n \n \t* gcc.dg/pragma-re-4.c: New test.\n \n-2005-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25964\n \t* gfortran.dg/assumed_size_refs_3.f90: New test.\n@@ -989,7 +1000,7 @@\n \t* ada/acats/tests/c9/c97305c.ada: Likewise.\n \t* ada/acats/tests/c9/c99004a.ada: Likewise.\n \n-2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-26  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25964\n \t* gfortran.dg/global_references_2.f90: New test.\n@@ -1112,7 +1123,7 @@\n \t* gcc.dg/torture/pr25654.c: New testcase.\n \t* gcc.target/i386/pr25654.c: Likewise.\n \n-2005-01-23  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25901\n \t* gfortran.dg/internal references_2.f90: New test.\n@@ -1142,7 +1153,7 @@\n \tPR c++/25858\n \t* g++.dg/template/crash44.C: New test.\n \n-2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+2006-01-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25124\n \tPR fortran/25625"}, {"sha": "c1c7c3d76ec05558c691ae4c98081e5ee62bac3d", "filename": "gcc/testsuite/gfortran.dg/parent_result_ref_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_1.f90?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\r\n+! Tests the fix for PR19546 in which an ICE would result from\r\n+! setting the parent result in a contained procedure. \r\n+! From the testcase of Francois-Xavier Coudert/Tobias Schlueter\r\n+! \r\n+function f()\r\n+  integer :: f\r\n+  f = 42\r\n+  call sub ()\r\n+  if (f.eq.1) f = f + 1\r\n+contains\r\n+  subroutine sub\r\n+    if (f.eq.42) f = f - 41\r\n+  end subroutine sub\r\n+end function f\r\n+\r\n+  integer, external :: f\r\n+  if (f ().ne.2) call abort ()\r\n+end\r"}, {"sha": "2409cb4685f44f25283fa5a718b16c92b22ed870", "filename": "gcc/testsuite/gfortran.dg/parent_result_ref_2.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_2.f90?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\r\n+! Tests the fix for PR19546 in which an ICE would result from\r\n+! setting the parent result in a contained procedure. \r\n+! This case tests character results.\r\n+! \r\n+function f()\n+  character(4) :: f\n+  f = \"efgh\"\n+  call sub ()\n+  if (f.eq.\"iklm\") f = \"abcd\"\n+  call sub ()\n+contains\n+  subroutine sub\n+    f = \"wxyz\"\n+    if (f.eq.\"efgh\") f = \"iklm\"\n+  end subroutine sub\n+end function f\n+\n+function g()              ! { dg-warning \"is obsolescent in fortran 95\" }\n+  character(*) :: g\n+  g = \"efgh\"\n+  call sub ()\n+  if (g.eq.\"iklm\") g = \"ABCD\"\n+  call sub ()\n+contains\n+  subroutine sub\n+    g = \"WXYZ\"\n+    if (g.eq.\"efgh\") g = \"iklm\"\n+  end subroutine sub\n+end function g\n+\n+  character(4), external :: f, g\r\n+  if (f ().ne.\"wxyz\") call abort ()\n+  if (g ().ne.\"WXYZ\") call abort ()\n+end\r"}, {"sha": "f8e93ff80dc1c91021909f924234e0ab356c0ad1", "filename": "gcc/testsuite/gfortran.dg/parent_result_ref_3.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_3.f90?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\r\n+! Tests the fix for PR19546 in which an ICE would result from\r\n+! setting the parent result in a contained procedure. \r\n+! Check that parent alternate entry results can be referenced.\r\n+! \r\n+function f()\r\n+  integer :: f, g\r\n+  f = 42\r\n+  call sub1 ()\r\n+  if (f.eq.1) f = 2\r\n+  return\r\n+entry g()\r\n+  g = 99\r\n+  call sub2 ()\n+  if (g.eq.77) g = 33\r\n+contains\r\n+  subroutine sub1\r\n+    if (f.eq.42) f = 1\r\n+  end subroutine sub1\r\n+  subroutine sub2\r\n+    if (g.eq.99) g = g - 22\r\n+  end subroutine sub2\r\n+end function f\r\n+\r\n+  integer, external :: f, g\r\n+  if (f ().ne.2) call abort ()\n+  if (g ().ne.33) call abort ()\r\n+end\r"}, {"sha": "d8c84e7cd6bd184346ba07979c88a9447bae8f7a", "filename": "gcc/testsuite/gfortran.dg/parent_result_ref_4.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fparent_result_ref_4.f90?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\r\n+! Tests the fix for PR19546 in which an ICE would result from\r\n+! setting the parent result in a contained procedure. \r\n+! Check that parent function results can be referenced in modules.\r\n+!\n+module m\n+contains\r\n+  function f()\r\n+    integer :: f\r\n+    f = 42\r\n+    call sub ()\r\n+    if (f.eq.1) f = f + 1\r\n+  contains\r\n+    subroutine sub\r\n+     if (f.eq.42) f = f - 41\r\n+    end subroutine sub\r\n+  end function f\n+end module m\r\n+\r\n+  use m\r\n+  if (f ().ne.2) call abort ()\r\n+end\r"}, {"sha": "4b0b8ae7e17b5870aac321d9bf5a5ec832b512ce", "filename": "gcc/testsuite/gfortran.dg/pure_dummy_length_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f20c93a30af5976a0d096d7034fb43a0acebf06/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpure_dummy_length_1.f90?ref=5f20c93a30af5976a0d096d7034fb43a0acebf06", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\r\n+! Tests fix for PR26107 in which an ICE would occur after the second\r\n+! error message below.  This resulted from a spurious attempt to\r\n+! produce the third error message, without the name of the function.\r\n+!\r\n+! This is an expanded version of the testcase in the PR.\r\n+!\r\n+   pure function equals(self, &     ! { dg-error \"must be INTENT\" }\r\n+                        string, ignore_case) result(same)\r\n+         character(*), intent(in) :: string\r\n+         integer(4), intent(in) :: ignore_case\r\n+         integer(4) :: same\r\n+         if (len (self) < 1) return ! { dg-error \"Type of argument\" }\r\n+         same = 1\r\n+   end function\r\n+\r\n+   function impure(self) result(ival)\r\n+         character(*), intent(in) :: self\r\n+         ival = 1\r\n+   end function\r\n+\r\n+   pure function purity(self, string, ignore_case) result(same)\r\n+         character(*), intent(in) :: self\r\n+         character(*), intent(in) :: string\r\n+         integer(4), intent(in) :: ignore_case\r\n+         integer i\r\n+         if (end > impure (self)) & ! { dg-error \"non-PURE procedure\" }\r\n+           return\r\n+   end function\r"}]}