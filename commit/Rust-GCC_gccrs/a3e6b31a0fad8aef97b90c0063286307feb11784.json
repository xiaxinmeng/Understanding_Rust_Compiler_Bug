{"sha": "a3e6b31a0fad8aef97b90c0063286307feb11784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNlNmIzMWEwZmFkOGFlZjk3YjkwYzAwNjMyODYzMDdmZWIxMTc4NA==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-09-17T12:58:07Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-09-17T12:58:07Z"}, "message": "for_each.h: Fixed comment/doxygen markup typos.\n\n2007-09-17  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/for_each.h: Fixed comment/doxygen markup typos.\n        * include/parallel/base.h: Same.\n        * include/parallel/numeric: Same.\n        * include/parallel/quicksort.h: Same.\n        * include/parallel/compiletime_settings.h: Same.\n        * include/parallel/random_shuffle.h: Same.\n        * include/parallel/balanced_quicksort.h: Same.\n        * include/parallel/tree.h: Same.\n        * include/parallel/settings.h: Same.\n        * include/parallel/search.h: Same.\n        * include/parallel/partition.h: Same.\n        * include/parallel/partial_sum.h: Same.\n\nFrom-SVN: r128545", "tree": {"sha": "e16f2fd24fbf946a5ac6fa15d99b56a77df92def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e16f2fd24fbf946a5ac6fa15d99b56a77df92def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3e6b31a0fad8aef97b90c0063286307feb11784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3e6b31a0fad8aef97b90c0063286307feb11784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3e6b31a0fad8aef97b90c0063286307feb11784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3e6b31a0fad8aef97b90c0063286307feb11784/comments", "author": null, "committer": null, "parents": [{"sha": "d483feaa8419e6385fa5a2cfdfef47779dd56284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d483feaa8419e6385fa5a2cfdfef47779dd56284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d483feaa8419e6385fa5a2cfdfef47779dd56284"}], "stats": {"total": 102, "additions": 58, "deletions": 44}, "files": [{"sha": "a5ac39f13b8c5b3c8805d0093239ba8e34347160", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -1,3 +1,18 @@\n+2007-09-17  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/for_each.h: Fixed comment/doxygen markup typos.\n+        * include/parallel/base.h: Same.\n+        * include/parallel/numeric: Same.\n+        * include/parallel/quicksort.h: Same.\n+        * include/parallel/compiletime_settings.h: Same.\n+        * include/parallel/random_shuffle.h: Same.\n+        * include/parallel/balanced_quicksort.h: Same.\n+        * include/parallel/tree.h: Same.\n+        * include/parallel/settings.h: Same.\n+        * include/parallel/search.h: Same.\n+        * include/parallel/partition.h: Same.\n+        * include/parallel/partial_sum.h: Same.\n+\n 2007-09-17  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1_impl/type_traitsfwd.h (aligned_storage): Remove"}, {"sha": "881099cb37fa3394cfdea6ee4d52729a62efc13a", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -277,7 +277,7 @@ namespace __gnu_parallel\n \t\t|| (end - split_pos1) < (n >> 7))\n \t      {\n \t\t// Very unequal split, one part smaller than one 128th\n-\t\t// elements not stricly larger than the pivot.\n+\t\t// elements not strictly larger than the pivot.\n \t\t__gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n \n \t\t// Find other end of pivot-equal range."}, {"sha": "12bba0455fc8de8be42fd46f6f555f406d259194", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -49,7 +49,7 @@ namespace __gnu_parallel\n   // XXX remove std::duplicates from here if possible,\n   // XXX but keep minimal dependencies.\n \n-  /** @brief Calculates the rounded-down logrithm of @c n for base 2.\n+  /** @brief Calculates the rounded-down logarithm of @c n for base 2.\n    *  @param n Argument.\n    *  @return Returns 0 for argument 0.\n    */\n@@ -107,7 +107,6 @@ namespace __gnu_parallel\n \n     bool operator()(const T1& a, const T2& b)\n     {\n-      // FIXME: wrong in general (T1 != T2)\n       return !comp(a, b) && !comp(b, a);\n     }\n   };"}, {"sha": "717bda56f6fd2def20215f8bb94b6ba8d1ccd16e", "filename": "libstdc++-v3/include/parallel/compiletime_settings.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -69,7 +69,7 @@\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB 0\n \n /** @brief First copy the data, sort it locally, and merge it back\n- * (0); or copy it back after everyting is done (1).\n+ * (0); or copy it back after everything is done (1).\n  *\n  *  Recommendation: 0 */\n #define _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST 0"}, {"sha": "ef950d1f924ee8adc857e7695939337fa041d56b", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -29,7 +29,7 @@\n // Public License.\n \n /** @file parallel/for_each.h\n- *  @brief Main interface for embarassingly parallel functions.\n+ *  @brief Main interface for embarrassingly parallel functions.\n  *\n  *  The explicit implementation are in other header files, like\n  *  workstealing.h, par_loop.h, omp_loop.h, and omp_loop_static.h."}, {"sha": "4d71b8f1588e0ed382f79c82078bde1f8f2fc717", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -31,7 +31,7 @@\n /**\n  * @file parallel/numeric\n *\n- * @brief Parallel STL fucntion calls corresponding to stl_numeric.h.\n+ * @brief Parallel STL function calls corresponding to stl_numeric.h.\n  * The functions defined here mainly do case switches and\n  * call the actual parallelized versions in other files.\n  * Inlining policy: Functions that basically only contain one function call,"}, {"sha": "5a1a43e31a4e36d27e99fcbc9f4e4f177c67379c", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -75,7 +75,7 @@ namespace __gnu_parallel\n     return result;\n   }\n \n-  /** @brief Parallel partial sum implmenetation, two-phase approach,\n+  /** @brief Parallel partial sum implementation, two-phase approach,\n       no recursion.\n       *  @param begin Begin iterator of input sequence.\n       *  @param end End iterator of input sequence."}, {"sha": "790685bf0a5698badafbec16f3d28a615ddb2117", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -102,7 +102,7 @@ namespace __gnu_parallel\n \t  difference_type thread_left, thread_left_border, thread_right, thread_right_border;\n \t  thread_left = left + 1;\n \n-\t  // Just to satify the condition below.\n+\t  // Just to satisfy the condition below.\n \t  thread_left_border = thread_left - 1;\n \t  thread_right = n - 1;\n \t  thread_right_border = thread_right + 1;"}, {"sha": "305c8defa7438f082566cd404a73610ffae18a81", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -48,7 +48,7 @@ namespace __gnu_parallel\n    *  @param end End iterator of subsequence.\n    *  @param comp Comparator.\n    *  @param pivot_rank Desired rank of the pivot.\n-   *  @param num_samples Chosse pivot from that many samples.\n+   *  @param num_samples Choose pivot from that many samples.\n    *  @param num_threads Number of threads that are allowed to work on\n    *  this part.\n    */"}, {"sha": "fa546512a4019c90ef70790c512b5e35dcd1836a", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -131,7 +131,7 @@ namespace __gnu_parallel\n   }\n \n   /** @brief Random shuffle code executed by each thread.\n-   *  @param pus Arary of thread-local data records. */\n+   *  @param pus Array of thread-local data records. */\n   template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* pus)\n   {"}, {"sha": "af6bd8541f68515e25a62bb195c14d6e61716d1f", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -100,7 +100,7 @@ namespace __gnu_parallel\n     // Last point to start search.\n     difference_type input_length = (end1 - begin1) - pattern_length;\n \n-    // Where is first occurence of pattern? defaults to end.\n+    // Where is first occurrence of pattern? defaults to end.\n     difference_type res = (end1 - begin1);\n \n     // Pattern too long.\n@@ -128,7 +128,7 @@ namespace __gnu_parallel\n \t{\n \t  // Get new value of res.\n #pragma omp flush(res)\n-\t  // No chance for this thread to find first occurence.\n+\t  // No chance for this thread to find first occurrence.\n \t  if (res < start)\n \t    break;\n \t  while (pred(begin1[start + pos_in_pattern], begin2[pos_in_pattern]))"}, {"sha": "97de007a374633faee6a8aed87eb97604b9e7fe2", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -152,7 +152,7 @@ namespace\n     static volatile bool force_sequential;\n \n     /** @brief Force all algorithms to be executed in parallel.\n-     * This setting can be overriden by __gnu_parallel::sequential_tag\n+     * This setting can be overridden by __gnu_parallel::sequential_tag\n      * (compile-time), and force_sequential (run-time). */\n     static volatile bool force_parallel;\n \n@@ -171,7 +171,7 @@ namespace\n \t(quicksort). */\n     static volatile unsigned int sort_qs_num_samples_preset;\n \n-    /** @brief Maximal subsequence length to swtich to unbalanced\n+    /** @brief Maximal subsequence length to switch to unbalanced\n      * base case.  Applies to std::sort with dynamically\n      * load-balanced quicksort. */\n     static volatile sequence_index_t sort_qsb_base_case_maximal_n;"}, {"sha": "a89dc62cb7bb1e635cce3fcebaaac6be39cec955", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3e6b31a0fad8aef97b90c0063286307feb11784/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=a3e6b31a0fad8aef97b90c0063286307feb11784", "patch": "@@ -396,9 +396,9 @@ namespace __gnu_parallel\n \t// 1. Convert n to n', where n' will be its rank if the tree\n \t//    was complete\n \t// 2. Calculate neighbours for n'\n-\t// 3. Convert the neighbours n1', n2' and n3' to their\n-\t//    appropiate values n1, n2, n3. Note that it must be\n-\t//    checked that this neighbours reallly exist.\n+\t// 3. Convert the neighbors n1', n2' and n3' to their\n+\t//    appropriate values n1, n2, n3. Note that it must be\n+\t//    checked that these neighbors actually exist.\n \tcalculate_shifts_pos_level(mod_pos, zero, l_s, r_s, p_s);\n \tif (l_s > splitting_point)\n \t  {\n@@ -534,7 +534,7 @@ namespace __gnu_parallel\n       /** @brief Search for the first 0 bit (growing the weight) using\n        * binary search\n        *\n-       * Binary search can be used instead of a na\u00efve loop using the\n+       * Binary search can be used instead of a naive loop using the\n        * masks in mask array\n        * @param x Binary number (corresponding to a rank in the tree)\n        * whose first 0 bit must be calculated\n@@ -638,7 +638,7 @@ namespace __gnu_parallel\n \t  considering valid nodes and gaps\n        * @param pos Rank in the array of nodes considering only valid nodes\n        * @param index Partition which the rank is most likely to\n-       * belong to (ie. the corresponding if there were no gaps)\n+       * belong to (i. e. the corresponding if there were no gaps)\n        * @pre 0 <= @c pos <= number_of_distinct_elements\n        * @return Rank in the array of nodes considering valid nodes and gaps\n        * @post 0 <= @c return <= number_of_elements\n@@ -746,14 +746,14 @@ namespace __gnu_parallel\n     /** @brief Helper comparator class: Passed as a parameter of\n \tlist_partition to check that a sequence is sorted\n      * @param _InputIterator Iterator to the elements to compare\n-     * @param _CompIsSorted  Comparator to check for sortedness */\n+     * @param _CompIsSorted  Comparator to check for sortednesss */\n     template<typename _InputIterator, typename _CompIsSorted>\n     class is_sorted_functor\n     {\n       /** @brief Element to compare with (first parameter of comp) */\n       _InputIterator prev;\n \n-      /** @brief Comparator to check for sortedness */\n+      /** @brief Comparator to check for sortednesss */\n       const _CompIsSorted comp;\n \n       /** @brief Sum up the history of the operator() of this\n@@ -767,7 +767,7 @@ namespace __gnu_parallel\n        * Sorted is set to true\n        * @param first Element to compare with the first time the\n        * operator() is called\n-       * @param c  Comparator to check for sortednes */\n+       * @param c  Comparator to check for sortedness */\n       is_sorted_functor(const _InputIterator first, const _CompIsSorted c)\n       : prev(first), comp(c), sorted(true) { }\n \n@@ -891,15 +891,15 @@ namespace __gnu_parallel\n     template<typename S>\n     struct Opposite\n     {\n-      /** @brief Obtain the conceptual left child of a node, inversing\n+      /** @brief Obtain the conceptual left child of a node, inverting\n \t  the symmetry\n        * @param parent Node whose child must be obtained\n        * @return Reference to the child node */\n       static _Rb_tree_node_base*& left(_Rb_tree_node_base* parent)\n       { return S::right(parent);}\n \n       /** @brief Obtain the conceptual right child of a node,\n-\t  inversing the symmetry\n+\t  inverting the symmetry\n        * @param parent Node whose child must be obtained\n        * @return Reference to the child node */\n       static _Rb_tree_node_base*& right(_Rb_tree_node_base* parent)\n@@ -1140,7 +1140,7 @@ namespace __gnu_parallel\n \t  be inserted into @c t */\n       size_type pos_beg;\n \n-      /** @brief Positition of the first node in the array of nodes\n+      /** @brief Position of the first node in the array of nodes\n \t  that won't be inserted into @c t */\n       size_type pos_end;\n \n@@ -1189,7 +1189,7 @@ namespace __gnu_parallel\n      * The input sequence is preprocessed so that the bulk\n      * construction or insertion can be performed\n      * efficiently. Essentially, the sequence is checked for\n-     * sortedness and iterators to the middle of the structure are\n+     * sortednesss and iterators to the middle of the structure are\n      * saved so that afterwards the sequence can be processed\n      * effectively in parallel. */\n     template<typename _InputIterator, typename StrictlyLessOrLessEqual>\n@@ -1249,7 +1249,7 @@ namespace __gnu_parallel\n      * The elements are copied, according to the copy policy, in order\n      * to be sorted. Then the\n      * _M_not_sorted_bulk_insertion_construction() method is called\n-     * appropiately\n+     * appropriately\n      * @param access Array of iterators of size @c num_threads +\n      * 1. Each position contains the first element in each subsequence\n      * to be added into the tree.\n@@ -1401,7 +1401,7 @@ namespace __gnu_parallel\n     }\n \n \n-    /** @brief Allocation of an array of nodes and initilization of\n+    /** @brief Allocation of an array of nodes and initialization of\n \ttheir value fields from an input sequence. Done in parallel.\n      * @param access Array of iterators of size @c num_threads +\n      * 1. Each position contains the first value in the subsequence to\n@@ -1442,7 +1442,7 @@ namespace __gnu_parallel\n     }\n \n \n-    /** @brief Allocation of an array of nodes and initilization of\n+    /** @brief Allocation of an array of nodes and initialization of\n      * their value fields from an input sequence. Done in\n      * parallel. Besides, the sequence is checked for uniqueness while\n      * copying the elements, and if there are repetitions, gaps within\n@@ -1570,7 +1570,7 @@ namespace __gnu_parallel\n \n     }\n \n-    /** @brief Allocation of an array of nodes and initilization of\n+    /** @brief Allocation of an array of nodes and initialization of\n      * their value fields from an input sequence.\n      *\n      * The allocation and initialization is done in parallel. Besides,\n@@ -1734,7 +1734,7 @@ namespace __gnu_parallel\n \n       t.tic(\"bulk allocation and initialization\");\n \n-      // Link the tree appropiately.\n+      // Link the tree appropriately.\n       // Dealing with repetitions (EFFICIENCY ISSUE).\n       ranker_gaps rank(beg_partition, rank_shift, num_threads);\n       nodes_initializer<ranker_gaps> nodes_init(r, n - rank_shift[num_threads], num_threads, rank);\n@@ -1772,7 +1772,7 @@ namespace __gnu_parallel\n \t      }\n \t  }\n       }\n-      // If the execution reachs this point, there has been no\n+      // If the execution reaches this point, there has been no\n       // exception, and so the structure can be initialized.\n \n       // Join the tree laid on the array of ptrs with the header node.\n@@ -1870,7 +1870,7 @@ namespace __gnu_parallel\n \n       //2. Split the tree according to access in num_threads parts\n       //Initialize upper concat_problems\n-      //Allocate them dinamically because they are afterwards so erased\n+      //Allocate them dynamically because they are afterwards so erased\n       for (int i=0; i < (2*num_threads-1); ++i)\n \t{\n \t  conc[i] = new concat_problem ();\n@@ -2048,13 +2048,13 @@ namespace __gnu_parallel\n     /** @brief Divide a tree according to the splitter elements of a\n      * given sequence.\n      *\n-     * The tree of the intial recursive call is divided in exactly\n+     * The tree of the initial recursive call is divided in exactly\n      * num_threads partitions, some of which may be empty. Besides,\n      * some nodes may be extracted from it to afterwards concatenate\n      * the subtrees resulting from inserting the elements into it.\n      * This is done sequentially. It could be done in parallel but the\n      * performance is much worse.\n-     * @param t Root of the tree to be splitted\n+     * @param t Root of the tree to be split\n      * @param r Array of nodes to be inserted into the tree (here only\n      * used to look up its elements)\n      * @param access Array of iterators of size @c num_threads +\n@@ -2184,7 +2184,7 @@ namespace __gnu_parallel\n      *  sequentially.\n      * @param r Array of nodes containing the nodes to added into the tree\n      * @param ins_problems Pointer to a queue of insertion\n-     * problems. The calling thread owns this queue, i.e. it is the\n+     * problems. The calling thread owns this queue, i. e. it is the\n      * only one to push elements, but other threads could pop elements\n      * from it in other methods.\n      * @param ip Current insertion problem to be solved\n@@ -2475,7 +2475,7 @@ namespace __gnu_parallel\n       is_sorted_functor<_InputIterator, _Compare> sorted(__first, base_type::_M_impl._M_key_compare);\n       dist = list_partition(__first, __last, access,  (beg_partition+1),  num_pieces, sorted,  0);\n \n-      // Calculate the rank of the begining each partition from the\n+      // Calculate the rank of the beginning each partition from the\n       // sequence sizes (what is stored at this point in beg_partition\n       // array).\n       beg_partition[0] = 0;\n@@ -2489,7 +2489,7 @@ namespace __gnu_parallel\n \n     /** @brief Make a full copy of the elements of a sequence\n      *\n-     *  The unitialized_copy method from the stl is called in parallel\n+     *  The uninitialized_copy method from the STL is called in parallel\n      *  using the access array to point to the beginning of each\n      *  partition\n      *  @param access Array of size @c num_threads + 1 that defines @c\n@@ -2551,7 +2551,7 @@ namespace __gnu_parallel\n      *  @param pos_beg_right Position of the first node in the\n      *  resulting right partition (out)\n      *  @param existing Number of existing elements before dividing\n-     *  (in) and after (out). Specificically, the counter is\n+     *  (in) and after (out). Specifically, the counter is\n      *  incremented by one for unique containers if the splitting key\n      *  was already in the array of nodes.\n      *  @param strictly_less_or_less_equal Comparator to deal\n@@ -2866,10 +2866,10 @@ namespace __gnu_parallel\n     }\n \n     /** @brief Split a tree according to key in three parts: a left\n-     * child, a right child and an intermediate node.\n+     *  child, a right child and an intermediate node.\n      *\n      *  Trees are concatenated once the recursive call returns. That\n-     *  is, from bottom to top (ie. smaller to larger), so the cost\n+     *  is, from bottom to top (i. e. smaller to larger), so the cost\n      *  bounds for split hold.\n      *  @param t Root of the tree to split.\n      *  @param key Key to split according to.\n@@ -3032,7 +3032,7 @@ namespace __gnu_parallel\n     }\n \n     /** @brief Split the tree in two parts: the minimum element from a\n-\ttree (i.e. leftmost) and the rest (right subtree)\n+\ttree (i. e. leftmost) and the rest (right subtree)\n      *  @param t Root of the tree\n      *  @param root Minimum element (out)\n      *  @param r Right subtree: @c t - {@c root}\n@@ -3080,7 +3080,7 @@ namespace __gnu_parallel\n \n \n     /** @brief Split the tree in two parts: the greatest element from\n-\ta tree (i.e. rightmost) and the rest (left subtree)\n+\ta tree (i. e. rightmost) and the rest (left subtree)\n      *  @param t Root of the tree\n      *  @param root Maximum element (out)\n      *  @param l Left subtree: @c t - {@c root}\n@@ -3128,7 +3128,7 @@ namespace __gnu_parallel\n      * and a right subtree\n      *\n      *  Trees are concatenated once the recursive call returns. That\n-     *  is, from bottom to top (ie. smaller to larger), so the cost\n+     *  is, from bottom to top (i. e. smaller to larger), so the cost\n      *  bounds for split hold.\n      *  @param t Root of the tree to split.\n      *  @param key Key to split according to."}]}