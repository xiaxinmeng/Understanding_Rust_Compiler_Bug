{"sha": "f6672e8e52276dcaf1a27e636247383f316ce221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY2NzJlOGU1MjI3NmRjYWYxYTI3ZTYzNjI0NzM4M2YzMTZjZTIyMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-11-18T01:19:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-11-18T01:19:10Z"}, "message": "dwarf2out.c (dw_cfi_oprnd_struct): Reduce dw_cfi_reg_num to int.\n\n        * dwarf2out.c (dw_cfi_oprnd_struct): Reduce dw_cfi_reg_num to int.\n        (lookup_cfa_1): Apply data alignment to DW_CFA_def_cfa_offset_sf\n        and DW_CFA_def_cfa_sf.\n        (def_cfa_1): Use DW_CFA_def_cfa_offset_sf with negative values.\n        (dbx_reg_number): Don't assert particular registers here.\n        (based_loc_descr): ... do it here instead.  Fold in ...\n        (eliminate_reg_to_offset): ... this function.\n        (compute_frame_pointer_to_cfa_displacement): Fold in the effects\n        of eliminate_reg_to_offset; use FRAME_POINTER_CFA_OFFSET.\n        * unwind-dw2.c (execute_cfa_program): Apply data align factor\n        to DW_CFA_def_cfa_offset_sf and DW_CFA_def_cfa_sf.\n        * function.c (instantiate_new_reg): Use FRAME_POINTER_CFA_OFFSET.\n        (instantiate_virtual_regs): Likewise.\n        * var-tracking.c (adjust_stack_reference): Likewise.\n        * doc/tm.texi (FRAME_POINTER_CFA_OFFSET): New.\n\nFrom-SVN: r107154", "tree": {"sha": "c03bdda31c81403f3bcd5fcf610248b9f27ee02a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c03bdda31c81403f3bcd5fcf610248b9f27ee02a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6672e8e52276dcaf1a27e636247383f316ce221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6672e8e52276dcaf1a27e636247383f316ce221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6672e8e52276dcaf1a27e636247383f316ce221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6672e8e52276dcaf1a27e636247383f316ce221/comments", "author": null, "committer": null, "parents": [{"sha": "ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9e049bc145ae985bc0e2dd6079dacdd51717ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9e049bc145ae985bc0e2dd6079dacdd51717ac"}], "stats": {"total": 181, "additions": 129, "deletions": 52}, "files": [{"sha": "ca612fb0fe624e91f3d1f5677981f5d8d142f9dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -1,3 +1,21 @@\n+2005-11-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (dw_cfi_oprnd_struct): Reduce dw_cfi_reg_num to int.\n+\t(lookup_cfa_1): Apply data alignment to DW_CFA_def_cfa_offset_sf\n+\tand DW_CFA_def_cfa_sf.\n+\t(def_cfa_1): Use DW_CFA_def_cfa_offset_sf with negative values.\n+\t(dbx_reg_number): Don't assert particular registers here.\n+\t(based_loc_descr): ... do it here instead.  Fold in ...\n+\t(eliminate_reg_to_offset): ... this function.\n+\t(compute_frame_pointer_to_cfa_displacement): Fold in the effects\n+\tof eliminate_reg_to_offset; use FRAME_POINTER_CFA_OFFSET.\n+\t* unwind-dw2.c (execute_cfa_program): Apply data align factor\n+\tto DW_CFA_def_cfa_offset_sf and DW_CFA_def_cfa_sf.\n+\t* function.c (instantiate_new_reg): Use FRAME_POINTER_CFA_OFFSET.\n+\t(instantiate_virtual_regs): Likewise.\n+\t* var-tracking.c (adjust_stack_reference): Likewise.\n+\t* doc/tm.texi (FRAME_POINTER_CFA_OFFSET): New.\n+\n 2005-11-17  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/elf.h (STARTFILE_SPEC): Add \"crtlibid%O%s\""}, {"sha": "b229ee823ddc4f84afc146e4f9a0290aa59defa0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -2926,6 +2926,21 @@ want to support call frame debugging information like that provided by\n DWARF 2.\n @end defmac\n \n+@defmac FRAME_POINTER_CFA_OFFSET (@var{fundecl})\n+If defined, a C expression whose value is an integer giving the offset\n+in bytes from the frame pointer to the canonical frame address (cfa).\n+The final value should conincide with that calculated by\n+@code{INCOMING_FRAME_SP_OFFSET}.\n+\n+Normally the CFA is calculated as an offset from the argument pointer,\n+via @code{ARG_POINTER_CFA_OFFSET}, but if the argument pointer is \n+variable due to the ABI, this may not be possible.  If this macro is\n+defined, it imples that the virtual register instantiation should be\n+based on the frame pointer instead of the argument pointer.  Only one\n+of @code{FRAME_POINTER_CFA_OFFSET} and @code{ARG_POINTER_CFA_OFFSET}\n+should be defined.\n+@end defmac\n+\n @node Exception Handling\n @subsection Exception Handling Support\n @cindex exception handling"}, {"sha": "60a7d558084fb3f75cb73ee7cdb61b2581012bc4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 76, "deletions": 50, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -214,7 +214,7 @@ enum dw_cfi_oprnd_type {\n \n typedef union dw_cfi_oprnd_struct GTY(())\n {\n-  unsigned long GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n+  unsigned int GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n   HOST_WIDE_INT GTY ((tag (\"dw_cfi_oprnd_offset\"))) dw_cfi_offset;\n   const char * GTY ((tag (\"dw_cfi_oprnd_addr\"))) dw_cfi_addr;\n   struct dw_loc_descr_struct * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n@@ -671,13 +671,22 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc)\n     case DW_CFA_def_cfa_offset:\n       loc->offset = cfi->dw_cfi_oprnd1.dw_cfi_offset;\n       break;\n+    case DW_CFA_def_cfa_offset_sf:\n+      loc->offset\n+\t= cfi->dw_cfi_oprnd1.dw_cfi_offset * DWARF_CIE_DATA_ALIGNMENT;\n+      break;\n     case DW_CFA_def_cfa_register:\n       loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n       break;\n     case DW_CFA_def_cfa:\n       loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n       loc->offset = cfi->dw_cfi_oprnd2.dw_cfi_offset;\n       break;\n+    case DW_CFA_def_cfa_sf:\n+      loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      loc->offset\n+\t= cfi->dw_cfi_oprnd2.dw_cfi_offset * DWARF_CIE_DATA_ALIGNMENT;\n+      break;\n     case DW_CFA_def_cfa_expression:\n       get_cfa_from_loc_descr (loc, cfi->dw_cfi_oprnd1.dw_cfi_loc);\n       break;\n@@ -775,11 +784,21 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n \n   if (loc.reg == old_cfa.reg && !loc.indirect)\n     {\n-      /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction,\n-\t indicating the CFA register did not change but the offset\n-\t did.  */\n-      cfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n-      cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n+      /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n+\t the CFA register did not change but the offset did.  */\n+      if (loc.offset < 0)\n+\t{\n+\t  HOST_WIDE_INT f_offset = loc.offset / DWARF_CIE_DATA_ALIGNMENT;\n+\t  gcc_assert (f_offset * DWARF_CIE_DATA_ALIGNMENT == loc.offset);\n+\n+\t  cfi->dw_cfi_opc = DW_CFA_def_cfa_offset_sf;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_offset = f_offset;\n+\t}\n+      else\n+\t{\n+\t  cfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n+\t}\n     }\n \n #ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n@@ -800,9 +819,21 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n       /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n \t indicating the CFA register has changed to <register> with\n \t the specified offset.  */\n-      cfi->dw_cfi_opc = DW_CFA_def_cfa;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = loc.offset;\n+      if (loc.offset < 0)\n+\t{\n+\t  HOST_WIDE_INT f_offset = loc.offset / DWARF_CIE_DATA_ALIGNMENT;\n+\t  gcc_assert (f_offset * DWARF_CIE_DATA_ALIGNMENT == loc.offset);\n+\n+\t  cfi->dw_cfi_opc = DW_CFA_def_cfa_sf;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n+\t  cfi->dw_cfi_oprnd2.dw_cfi_offset = f_offset;\n+\t}\n+      else\n+\t{\n+\t  cfi->dw_cfi_opc = DW_CFA_def_cfa;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n+\t  cfi->dw_cfi_oprnd2.dw_cfi_offset = loc.offset;\n+\t}\n     }\n   else\n     {\n@@ -8460,12 +8491,6 @@ dbx_reg_number (rtx rtl)\n {\n   unsigned regno = REGNO (rtl);\n \n-  /* We do not want to see registers that should have been eliminated.  */\n-  gcc_assert (HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n-\t      || rtl != arg_pointer_rtx);\n-  gcc_assert (HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n-\t      || rtl != frame_pointer_rtx);\n-\n   gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n #ifdef LEAF_REG_REMAP\n@@ -8619,55 +8644,41 @@ int_loc_descriptor (HOST_WIDE_INT i)\n   return new_loc_descr (op, i, 0);\n }\n \n-/* Return an offset from an eliminable register to the post-prologue\n-   frame pointer.  */\n-\n-static HOST_WIDE_INT\n-eliminate_reg_to_offset (rtx reg)\n-{\n-  HOST_WIDE_INT offset = 0;\n-\n-  reg = eliminate_regs (reg, VOIDmode, NULL_RTX);\n-  if (GET_CODE (reg) == PLUS)\n-    {\n-      offset = INTVAL (XEXP (reg, 1));\n-      reg = XEXP (reg, 0);\n-    }\n-  gcc_assert (reg == (frame_pointer_needed ? hard_frame_pointer_rtx\n-\t\t      : stack_pointer_rtx));\n-\n-  return offset;\n-}\n-\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n based_loc_descr (rtx reg, HOST_WIDE_INT offset)\n {\n-  dw_loc_descr_ref loc_result;\n+  unsigned int regno;\n \n   /* We only use \"frame base\" when we're sure we're talking about the\n      post-prologue local stack frame.  We do this by *not* running\n      register elimination until this point, and recognizing the special\n      argument pointer and soft frame pointer rtx's.  */\n   if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)\n     {\n-      offset += eliminate_reg_to_offset (reg);\n-      offset += frame_pointer_cfa_offset;\n+      rtx elim = eliminate_regs (reg, VOIDmode, NULL_RTX);\n \n-      loc_result = new_loc_descr (DW_OP_fbreg, offset, 0);\n-    }\n-  else\n-    {\n-      unsigned int regno = dbx_reg_number (reg);\n+      if (elim != reg)\n+\t{\n+\t  if (GET_CODE (elim) == PLUS)\n+\t    {\n+\t      offset += INTVAL (XEXP (elim, 1));\n+\t      elim = XEXP (elim, 0);\n+\t    }\n+\t  gcc_assert (elim == (frame_pointer_needed ? hard_frame_pointer_rtx\n+\t\t      : stack_pointer_rtx));\n+          offset += frame_pointer_cfa_offset;\n \n-      if (regno <= 31)\n-\tloc_result = new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n-      else\n-\tloc_result = new_loc_descr (DW_OP_bregx, regno, offset);\n+          return new_loc_descr (DW_OP_fbreg, offset, 0);\n+\t}\n     }\n \n-  return loc_result;\n+  regno = dbx_reg_number (reg);\n+  if (regno <= 31)\n+    return new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n+  else\n+    return new_loc_descr (DW_OP_bregx, regno, offset);\n }\n \n /* Return true if this RTL expression describes a base+offset calculation.  */\n@@ -10406,9 +10417,24 @@ static void\n compute_frame_pointer_to_cfa_displacement (void)\n {\n   HOST_WIDE_INT offset;\n+  rtx reg, elim;\n+\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+  reg = frame_pointer_rtx;\n+  offset = FRAME_POINTER_CFA_OFFSET (current_function_decl);\n+#else\n+  reg = arg_pointer_rtx;\n+  offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n+#endif\n \n-  offset = eliminate_reg_to_offset (arg_pointer_rtx);\n-  offset += ARG_POINTER_CFA_OFFSET (current_function_decl);\n+  elim = eliminate_regs (reg, VOIDmode, NULL_RTX);\n+  if (GET_CODE (elim) == PLUS)\n+    {\n+      offset += INTVAL (XEXP (elim, 1));\n+      elim = XEXP (elim, 0);\n+    }\n+  gcc_assert (elim == (frame_pointer_needed ? hard_frame_pointer_rtx\n+\t\t       : stack_pointer_rtx));\n \n   frame_pointer_cfa_offset = -offset;\n }"}, {"sha": "c0339b8950e54b84fa2ea37feb10e9a014522de5", "filename": "gcc/function.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -1246,7 +1246,14 @@ instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n   else if (x == virtual_outgoing_args_rtx)\n     new = stack_pointer_rtx, offset = out_arg_offset;\n   else if (x == virtual_cfa_rtx)\n-    new = arg_pointer_rtx, offset = cfa_offset;\n+    {\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+      new = frame_pointer_rtx;\n+#else\n+      new = arg_pointer_rtx;\n+#endif\n+      offset = cfa_offset;\n+    }\n   else\n     return NULL_RTX;\n \n@@ -1632,7 +1639,11 @@ instantiate_virtual_regs (void)\n   var_offset = STARTING_FRAME_OFFSET;\n   dynamic_offset = STACK_DYNAMIC_OFFSET (current_function_decl);\n   out_arg_offset = STACK_POINTER_OFFSET;\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+  cfa_offset = FRAME_POINTER_CFA_OFFSET (current_function_decl);\n+#else\n   cfa_offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n+#endif\n \n   /* Initialize recognition, indicating that volatile is OK.  */\n   init_recog ();"}, {"sha": "930f02f37992003479123d4a757b504c744f30ab", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -902,7 +902,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr += utmp;\n \t  break;\n \n-\t  /* From the 2.1 draft.  */\n+\t  /* From the dwarf3 draft.  */\n \tcase DW_CFA_offset_extended_sf:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n@@ -916,10 +916,12 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);\n \t  fs->cfa_how = CFA_REG_OFFSET;\n+\t  fs->cfa_offset *= fs->data_align;\n \t  break;\n \n \tcase DW_CFA_def_cfa_offset_sf:\n \t  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);\n+\t  fs->cfa_offset *= fs->data_align;\n \t  /* cfa_how deliberately not set.  */\n \t  break;\n "}, {"sha": "fb4a1813218fe7d1e3bed25c16e220eb905de9c4", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6672e8e52276dcaf1a27e636247383f316ce221/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f6672e8e52276dcaf1a27e636247383f316ce221", "patch": "@@ -557,8 +557,13 @@ adjust_stack_reference (rtx mem, HOST_WIDE_INT adjustment)\n {\n   rtx addr, cfa, tmp;\n \n+#ifdef FRAME_POINTER_CFA_OFFSET\n+  adjustment -= FRAME_POINTER_CFA_OFFSET (current_function_decl);\n+  cfa = plus_constant (frame_pointer_rtx, adjustment);\n+#else\n   adjustment -= ARG_POINTER_CFA_OFFSET (current_function_decl);\n   cfa = plus_constant (arg_pointer_rtx, adjustment);\n+#endif\n \n   addr = replace_rtx (copy_rtx (XEXP (mem, 0)), stack_pointer_rtx, cfa);\n   tmp = simplify_rtx (addr);"}]}