{"sha": "e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlMDI4Y2IxZjU2ZjVmNzA2OGI3OGVmOGNhYjZlN2FlOGYyMTFkNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2009-04-16T12:41:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-16T12:41:38Z"}, "message": "s-intman-susv3.adb: New file.\n\n2009-04-16  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-intman-susv3.adb: New file.\n\n\t* init.c, s-osinte-darwin.ads: Fix stack checking in tasking mode\n\nFrom-SVN: r146179", "tree": {"sha": "630f3b21d444eb12ee9417639d119ed8165a6852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/630f3b21d444eb12ee9417639d119ed8165a6852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dd11e511bf310aeacb6172dc766d1cb57043917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd11e511bf310aeacb6172dc766d1cb57043917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd11e511bf310aeacb6172dc766d1cb57043917"}], "stats": {"total": 191, "additions": 181, "deletions": 10}, "files": [{"sha": "3ec924723d2c934ce453e9439e6795bd0450f1fa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "patch": "@@ -168,7 +168,7 @@\n \n \t* rtsfind.ads: Add entries for s-conca? routines\n \n-2009-04-15  Arnaud Charlet  <charlet@adacore.com>\n+2009-04-16  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies.\n "}, {"sha": "e86a975d2370de406ff99591e0bfea6a9959e3b6", "filename": "gcc/ada/init.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "patch": "@@ -2117,6 +2117,7 @@ __gnat_error_handler (int sig, siginfo_t * si, void * uc)\n   switch (sig)\n     {\n     case SIGSEGV:\n+    case SIGBUS:\n       /* FIXME: we need to detect the case of a *real* SIGSEGV.  */\n       exception = &storage_error;\n       msg = \"stack overflow or erroneous memory access\";\n@@ -2125,11 +2126,6 @@ __gnat_error_handler (int sig, siginfo_t * si, void * uc)\n       sigreturn (NULL, UC_RESET_ALT_STACK);\n       break;\n \n-    case SIGBUS:\n-      exception = &constraint_error;\n-      msg = \"SIGBUS\";\n-      break;\n-\n     case SIGFPE:\n       exception = &constraint_error;\n       msg = \"SIGFPE\";\n@@ -2172,12 +2168,12 @@ __gnat_install_handler (void)\n     sigaction (SIGFPE,  &act, NULL);\n   if (__gnat_get_interrupt_state (SIGILL) != 's')\n     sigaction (SIGILL,  &act, NULL);\n-  if (__gnat_get_interrupt_state (SIGBUS) != 's')\n-    sigaction (SIGBUS,  &act, NULL);\n \n   act.sa_flags |= SA_ONSTACK;\n   if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n     sigaction (SIGSEGV, &act, NULL);\n+  if (__gnat_get_interrupt_state (SIGBUS) != 's')\n+    sigaction (SIGBUS,  &act, NULL);\n \n   __gnat_handler_installed = 1;\n }"}, {"sha": "864d7e1d2dd5cca56c619a44d6073a6c7fda2e1c", "filename": "gcc/ada/s-intman-susv3.adb", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Fs-intman-susv3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Fs-intman-susv3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-susv3.adb?ref=e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "patch": "@@ -0,0 +1,170 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the SuSV3 threads version of this package\n+\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n+--  the lookout for special signals that may be used by the thread library.\n+\n+--  Since this is a multi target file, the signal <-> exception mapping\n+--  is simple minded. If you need a more precise and target specific\n+--  signal handling, create a new s-intman.adb that will fit your needs.\n+\n+--  This file assumes that:\n+\n+--    SIGINT exists and will be kept unmasked unless the pragma\n+--     Unreserve_All_Interrupts is specified anywhere in the application.\n+\n+--    System.OS_Interface contains the following:\n+--      SIGADAABORT: the signal that will be used to abort tasks.\n+--      Unmasked: the OS specific set of signals that should be unmasked in\n+--                all the threads. SIGADAABORT is unmasked by\n+--                default\n+--      Reserved: the OS specific set of signals that are reserved.\n+\n+package body System.Interrupt_Management is\n+\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function State (Int : Interrupt_ID) return Character;\n+   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+   --  Get interrupt state. Defined in init.c The input argument is the\n+   --  interrupt number, and the result is one of the following:\n+\n+   User    : constant Character := 'u';\n+   Runtime : constant Character := 'r';\n+   Default : constant Character := 's';\n+   --    'n'   this interrupt not set by any Interrupt_State pragma\n+   --    'u'   Interrupt_State pragma set state to User\n+   --    'r'   Interrupt_State pragma set state to Runtime\n+   --    's'   Interrupt_State pragma set state to System (use \"default\"\n+   --           system handler)\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+\n+   procedure Initialize is\n+   begin\n+      if Initialized then\n+         return;\n+      end if;\n+\n+      Initialized := True;\n+\n+      --  Need to call pthread_init very early because it is doing signal\n+      --  initializations.\n+\n+      pthread_init;\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n+      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n+\n+      --  Process state of exception signals\n+\n+      for J in Exception_Signals'Range loop\n+         declare\n+            Sig : constant Signal := Exception_Signals (J);\n+            Id : constant Interrupt_ID := Interrupt_ID (Sig);\n+         begin\n+            if State (Id) /= User then\n+               Keep_Unmasked (Id) := True;\n+               Reserve (Id) := True;\n+            end if;\n+         end;\n+      end loop;\n+\n+      if State (Abort_Task_Interrupt) /= User then\n+         Keep_Unmasked (Abort_Task_Interrupt) := True;\n+         Reserve (Abort_Task_Interrupt) := True;\n+      end if;\n+\n+      --  Set SIGINT to unmasked state as long as it is not in \"User\" state.\n+      --  Check for Unreserve_All_Interrupts last.\n+\n+      if State (SIGINT) /= User then\n+         Keep_Unmasked (SIGINT) := True;\n+         Reserve (SIGINT) := True;\n+      end if;\n+\n+      --  Check all signals for state that requires keeping them unmasked and\n+      --  reserved.\n+\n+      for J in Interrupt_ID'Range loop\n+         if State (J) = Default or else State (J) = Runtime then\n+            Keep_Unmasked (J) := True;\n+            Reserve (J) := True;\n+         end if;\n+      end loop;\n+\n+      --  Add the set of signals that must always be unmasked for this target\n+\n+      for J in Unmasked'Range loop\n+         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n+         Reserve (Interrupt_ID (Unmasked (J))) := True;\n+      end loop;\n+\n+      --  Add target-specific reserved signals\n+\n+      for J in Reserved'Range loop\n+         Reserve (Interrupt_ID (Reserved (J))) := True;\n+      end loop;\n+\n+      --  Process pragma Unreserve_All_Interrupts. This overrides any settings\n+      --  due to pragma Interrupt_State:\n+\n+      if Unreserve_All_Interrupts /= 0 then\n+         Keep_Unmasked (SIGINT) := False;\n+         Reserve (SIGINT) := False;\n+      end if;\n+\n+      --  We do not really have Signal 0. We just use this value to identify\n+      --  non-existent signals (see s-intnam.ads). Therefore, Signal should not\n+      --  be used in all signal related operations hence mark it as reserved.\n+\n+      Reserve (0) := True;\n+   end Initialize;\n+\n+end System.Interrupt_Management;"}, {"sha": "27a7860522fa214a4247f280ee2ffbf8ea477777", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=e8e028cb1f56f5f7068b78ef8cab6e7ae8f211d7", "patch": "@@ -117,10 +117,15 @@ package System.OS_Interface is\n    type Signal_Set is array (Natural range <>) of Signal;\n \n    Unmasked : constant Signal_Set :=\n-     (SIGTTIN, SIGTTOU, SIGSTOP, SIGTSTP);\n+                (SIGTTIN, SIGTTOU, SIGSTOP, SIGTSTP);\n \n    Reserved : constant Signal_Set :=\n-     (SIGKILL, SIGSTOP);\n+                (SIGKILL, SIGSTOP);\n+\n+   Exception_Signals : constant Signal_Set :=\n+                         (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n+   --  These signals (when runtime or system) will be caught and converted\n+   --  into an Ada exception.\n \n    type sigset_t is private;\n "}]}