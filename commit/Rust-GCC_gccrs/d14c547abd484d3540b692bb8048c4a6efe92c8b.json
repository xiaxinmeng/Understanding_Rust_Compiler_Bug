{"sha": "d14c547abd484d3540b692bb8048c4a6efe92c8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0YzU0N2FiZDQ4NGQzNTQwYjY5MmJiODA0OGM0YTZlZmU5MmM4Yg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-28T19:13:28Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-28T19:18:28Z"}, "message": "Add -Wstringop-overread for reading past the end by string functions.\n\ngcc/ChangeLog:\n\n\t* attribs.c (init_attr_rdwr_indices): Use global access_mode.\n\t* attribs.h (struct attr_access): Same.\n\t* builtins.c (fold_builtin_strlen): Add argument.\n\t(compute_objsize): Declare.\n\t(get_range): Declare.\n\t(check_read_access): New function.\n\t(access_ref::access_ref): Define ctor.\n\t(warn_string_no_nul): Add arguments.  Handle -Wstrintop-overread.\n\t(check_nul_terminated_array): Handle source strings of different\n\tranges of sizes.\n\t(expand_builtin_strlen): Remove warning code, call check_read_access\n\tinstead.  Declare locals closer to their initialization.\n\t(expand_builtin_strnlen): Same.\n\t(maybe_warn_for_bound): New function.\n\t(warn_for_access): Remove argument.  Handle -Wstrintop-overread.\n\t(inform_access): Change argument type.\n\t(get_size_range): New function.\n\t(check_access): Remove unused arguments.  Add new arguments.  Handle\n\t-Wstrintop-overread.  Move warning code to helpers and call them.\n\tCall check_nul_terminated_array.\n\t(check_memop_access): Remove unnecessary and provide additional\n\targuments in calls.\n\t(expand_builtin_memchr): Call check_read_access.\n\t(expand_builtin_strcat): Remove unnecessary and provide additional\n\targuments in calls.\n\t(expand_builtin_strcpy): Same.\n\t(expand_builtin_strcpy_args): Same.  Avoid testing no-warning bit.\n\t(expand_builtin_stpcpy_1): Remove unnecessary and provide additional\n\targuments in calls.\n\t(expand_builtin_stpncpy): Same.\n\t(check_strncat_sizes): Same.\n\t(expand_builtin_strncat): Remove unnecessary and provide additional\n\targuments in calls.  Adjust comments.\n\t(expand_builtin_strncpy): Remove unnecessary and provide additional\n\targuments in calls.\n\t(expand_builtin_memcmp): Remove warning code.  Call check_access.\n\t(expand_builtin_strcmp): Call check_access instead of\n\tcheck_nul_terminated_array.\n\t(expand_builtin_strncmp): Handle -Wstrintop-overread.\n\t(expand_builtin_fork_or_exec): Call check_access instead of\n\tcheck_nul_terminated_array.\n\t(expand_builtin): Same.\n\t(fold_builtin_1): Pass additional argument.\n\t(fold_builtin_n): Same.\n\t(fold_builtin_strpbrk): Remove calls to check_nul_terminated_array.\n\t(expand_builtin_memory_chk): Add comments.\n\t(maybe_emit_chk_warning): Remove unnecessary and provide additional\n\targuments in calls.\n\t(maybe_emit_sprintf_chk_warning): Same.  Adjust comments.\n\t* builtins.h (warn_string_no_nul): Add arguments.\n\t(struct access_ref): Add member and ctor argument.\n\t(struct access_data): Add members and ctor.\n\t(check_access): Adjust signature.\n\t* calls.c (maybe_warn_nonstring_arg): Return an indication of\n\twhether a warning was issued.  Issue -Wstrintop-overread instead\n\tof -Wstringop-overflow.\n\t(append_attrname): Adjust to naming changes.\n\t(maybe_warn_rdwr_sizes): Same.  Remove unnecessary and provide\n\tadditional arguments in calls.\n\t* calls.h (maybe_warn_nonstring_arg): Return bool.\n\t* doc/invoke.texi (-Wstringop-overread): Document new option.\n\t* gimple-fold.c (gimple_fold_builtin_strcpy): Provide an additional\n\targument in call.\n\t(gimple_fold_builtin_stpcpy): Same.\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Adjust to naming\n\tchanges.\n\t* tree.h (enum access_mode): New type.\n\ngcc/c-family/ChangeLog:\n\n\t* c.opt (Wstringop-overread): New option.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Warray-bounds-7.c: Adjust expected warnings.\n\t* c-c++-common/Wrestrict.c: Remove xfail.\n\t* c-c++-common/attr-nonstring-3.c: Adjust text of expected warnings.\n\t* c-c++-common/attr-nonstring-6.c: Suppress -Wstringop-overread\n\tinstead of -Wstringop-overflow.\n\t* c-c++-common/attr-nonstring-8.c: Adjust text of expected warnings.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Also suppress\n\t -Wstringop-overread.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Same.\n\t* gcc.dg/Warray-bounds-39.c: Adjust expected warnings.\n\t* gcc.dg/Warray-bounds-40.c: Also suppress -Wstringop-overread.\n\t* gcc.dg/Warray-bounds-58.c: Remove xfail.  Also expect\n\t-Wstringop-overread.  Adjust text of expected warnings.\n\t* gcc.dg/Wsizeof-pointer-memaccess1.c: Also suppress\n\t -Wstringop-overread.\n\t* gcc.dg/Wstringop-overflow-22.c: Adjust text of expected warnings.\n\t* gcc.dg/Wstringop-overflow-33.c: Expect -Wstringop-overread.\n\t* gcc.dg/Wstringop-overflow-9.c: Expect -Wstringop-overread.\n\t* gcc.dg/attr-nonstring-2.c: Adjust text of expected warnings.\n\t* gcc.dg/attr-nonstring-3.c: Same.\n\t* gcc.dg/attr-nonstring-4.c: Same.\n\t* gcc.dg/attr-nonstring.c: Expect -Wstringop-overread.\n\t* gcc.dg/builtin-stringop-chk-5.c: Adjust comment.\n\t* gcc.dg/builtin-stringop-chk-8.c: Enable -Wstringop-overread instead\n\tof -Wstringop-overflow.\n\t* gcc.dg/pr78902.c: Also expect -Wstringop-overread.\n\t* gcc.dg/pr79214.c: Adjust text of expected warnings.\n\t* gcc.dg/strcmpopt_10.c: Suppress valid -Wno-stringop-overread.\n\t* gcc.dg/strlenopt-57.c: Also expect -Wstringop-overread.\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Also suppress valid\n\t-Wno-stringop-overread.\n\t* gcc.dg/tree-ssa/builtins-folding-gimple-ub.c: Same.\n\t* gcc.dg/uninit-33.c: Same.\n\t* gcc.dg/warn-strnlen-no-nul-2.c: Adjust text of expected warning.\n\t* gcc.dg/warn-strnlen-no-nul.c: Same.\n\t* gcc.target/i386/strcmpopt_6.c: Suppress -Wstringop-overread.\n\t* gcc.dg/Wstringop-overread-2.c: New test.\n\t* gcc.dg/Wstringop-overread.c: New test.", "tree": {"sha": "d3ba650daec2ba98a7b37f8f98ca5ef42c994ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3ba650daec2ba98a7b37f8f98ca5ef42c994ae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d14c547abd484d3540b692bb8048c4a6efe92c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14c547abd484d3540b692bb8048c4a6efe92c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14c547abd484d3540b692bb8048c4a6efe92c8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14c547abd484d3540b692bb8048c4a6efe92c8b/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26c24398d3615aef43e599f87911c1ecc3bd2841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c24398d3615aef43e599f87911c1ecc3bd2841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26c24398d3615aef43e599f87911c1ecc3bd2841"}], "stats": {"total": 2469, "additions": 1793, "deletions": 676}, "files": [{"sha": "7c0c18ff108219ed038d19b4f395cfa9ac59fc91", "filename": "gcc/attribs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -2045,10 +2045,10 @@ init_attr_rdwr_indices (rdwr_map *rwm, tree fntype)\n \n \t  switch (*m)\n \t    {\n-\t    case 'r': acc.mode = acc.read_only; break;\n-\t    case 'w': acc.mode = acc.write_only; break;\n-\t    case 'x': acc.mode = acc.read_write; break;\n-\t    case '-': acc.mode = acc.none; break;\n+\t    case 'r': acc.mode = access_read_only; break;\n+\t    case 'w': acc.mode = access_write_only; break;\n+\t    case 'x': acc.mode = access_read_write; break;\n+\t    case '-': acc.mode = access_none; break;\n \t    default: gcc_unreachable ();\n \t    }\n "}, {"sha": "6d0a9e48a8cd97707c5a470c366e2f52e0790623", "filename": "gcc/attribs.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -234,7 +234,6 @@ struct attr_access\n   unsigned sizarg;\n \n   /* The access mode.  */\n-  enum access_mode { none, read_only, write_only, read_write };\n   access_mode mode;\n };\n "}, {"sha": "df121f98b95333c603c8b184bb766f85c352f3a5", "filename": "gcc/builtins.c", "status": "modified", "additions": 583, "deletions": 389, "changes": 972, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -156,7 +156,7 @@ static rtx expand_builtin_expect (tree, rtx);\n static rtx expand_builtin_expect_with_probability (tree, rtx);\n static tree fold_builtin_constant_p (tree);\n static tree fold_builtin_classify_type (tree);\n-static tree fold_builtin_strlen (location_t, tree, tree);\n+static tree fold_builtin_strlen (location_t, tree, tree, tree);\n static tree fold_builtin_inf (location_t, tree, int);\n static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n@@ -183,6 +183,9 @@ static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n+static tree compute_objsize (tree, int, access_ref *, const vr_values * = NULL);\n+static bool get_range (tree, signop, offset_int[2], const vr_values * = NULL);\n+static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n \n unsigned HOST_WIDE_INT target_newline;\n unsigned HOST_WIDE_INT target_percent;\n@@ -195,6 +198,26 @@ static tree do_mpfr_remquo (tree, tree, tree);\n static tree do_mpfr_lgamma_r (tree, tree, tree);\n static void expand_builtin_sync_synchronize (void);\n \n+access_ref::access_ref (tree bound /* = NULL_TREE */,\n+\t\t\tbool minaccess /* = false */)\n+  : ref ()\n+{\n+  /* Set to valid.  */\n+  offrng[0] = offrng[1] = 0;\n+  /* Invalidate.   */\n+  sizrng[0] = sizrng[1] = -1;\n+\n+  /* Set the default bounds of the access and adjust below.  */\n+  bndrng[0] = minaccess ? 1 : 0;\n+  bndrng[1] = HOST_WIDE_INT_M1U;\n+\n+  /* When BOUND is nonnull and a range can be extracted from it,\n+     set the bounds of the access to reflect both it and MINACCESS.\n+     BNDRNG[0] is the size of the minimum access.  */\n+  if (bound && get_range (bound, UNSIGNED, bndrng))\n+    bndrng[0] = bndrng[0] > 0 && minaccess ? 1 : 0;\n+}\n+\n /* Return true if NAME starts with __builtin_ or __sync_.  */\n \n static bool\n@@ -543,38 +566,132 @@ string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n   return n;\n }\n \n-/* For a call at LOC to a function FN that expects a string in the argument\n-   ARG, issue a diagnostic due to it being a called with an argument\n-   declared at NONSTR that is a character array with no terminating NUL.  */\n+/* For a call EXPR at LOC to a function FNAME that expects a string\n+   in the argument ARG, issue a diagnostic due to it being a called\n+   with an argument that is a character array with no terminating\n+   NUL.  SIZE is the EXACT size of the array, and BNDRNG the number\n+   of characters in which the NUL is expected.  Either EXPR or FNAME\n+   may be null but noth both.  SIZE may be null when BNDRNG is null.  */\n \n void\n-warn_string_no_nul (location_t loc, const char *fn, tree arg, tree decl)\n+warn_string_no_nul (location_t loc, tree expr, const char *fname,\n+\t\t    tree arg, tree decl, tree size /* = NULL_TREE */,\n+\t\t    bool exact /* = false */,\n+\t\t    const wide_int bndrng[2] /* = NULL */)\n {\n-  if (TREE_NO_WARNING (arg))\n+  if ((expr && TREE_NO_WARNING (expr)) || TREE_NO_WARNING (arg))\n     return;\n \n   loc = expansion_point_location_if_in_system_header (loc);\n+  bool warned;\n+\n+  /* Format the bound range as a string to keep the nuber of messages\n+     from exploding.  */\n+  char bndstr[80];\n+  *bndstr = 0;\n+  if (bndrng)\n+    {\n+      if (bndrng[0] == bndrng[1])\n+\tsprintf (bndstr, \"%llu\", (unsigned long long) bndrng[0].to_uhwi ());\n+      else\n+\tsprintf (bndstr, \"[%llu, %llu]\",\n+\t\t (unsigned long long) bndrng[0].to_uhwi (),\n+\t\t (unsigned long long) bndrng[1].to_uhwi ());\n+    }\n+\n+  const tree maxobjsize = max_object_size ();\n+  const wide_int maxsiz = wi::to_wide (maxobjsize);\n+  if (expr)\n+    {\n+      tree func = get_callee_fndecl (expr);\n+      if (bndrng)\n+\t{\n+\t  if (wi::ltu_p (maxsiz, bndrng[0]))\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%K%qD specified bound %s exceeds \"\n+\t\t\t\t \"maximum object size %E\",\n+\t\t\t\t expr, func, bndstr, maxobjsize);\n+\t  else\n+\t    {\n+\t      bool maybe = wi::to_wide (size) == bndrng[0];\n+\t      warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t   exact\n+\t\t\t\t   ? G_(\"%K%qD specified bound %s exceeds \"\n+\t\t\t\t\t\"the size %E of unterminated array\")\n+\t\t\t\t   : (maybe\n+\t\t\t\t      ? G_(\"%K%qD specified bound %s may \"\n+\t\t\t\t\t   \"exceed the size of at most %E \"\n+\t\t\t\t\t   \"of unterminated array\")\n+\t\t\t\t      : G_(\"%K%qD specified bound %s exceeds \"\n+\t\t\t\t\t   \"the size of at most %E \"\n+\t\t\t\t\t   \"of unterminated array\")),\n+\t\t\t\t   expr, func, bndstr, size);\n+\t    }\n+\t}\n+      else\n+\twarned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t     \"%K%qD argument missing terminating nul\",\n+\t\t\t     expr, func);\n+    }\n+  else\n+    {\n+      if (bndrng)\n+\t{\n+\t  if (wi::ltu_p (maxsiz, bndrng[0]))\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qs specified bound %s exceeds \"\n+\t\t\t\t \"maximum object size %E\",\n+\t\t\t\t fname, bndstr, maxobjsize);\n+\t  else\n+\t    {\n+\t      bool maybe = wi::to_wide (size) == bndrng[0];\n+\t      warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t   exact\n+\t\t\t\t   ? G_(\"%qs specified bound %s exceeds \"\n+\t\t\t\t\t\"the size %E of unterminated array\")\n+\t\t\t\t   : (maybe\n+\t\t\t\t      ? G_(\"%qs specified bound %s may \"\n+\t\t\t\t\t   \"exceed the size of at most %E \"\n+\t\t\t\t\t   \"of unterminated array\")\n+\t\t\t\t      : G_(\"%qs specified bound %s exceeds \"\n+\t\t\t\t\t   \"the size of at most %E \"\n+\t\t\t\t\t   \"of unterminated array\")),\n+\t\t\t\t   fname, bndstr, size);\n+\t    }\n+\t}\n+      else\n+\twarned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t     \"%qsargument missing terminating nul\",\n+\t\t\t     fname);\n+    }\n \n-  if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%qs argument missing terminating nul\", fn))\n+  if (warned)\n     {\n       inform (DECL_SOURCE_LOCATION (decl),\n \t      \"referenced argument declared here\");\n       TREE_NO_WARNING (arg) = 1;\n+      if (expr)\n+\tTREE_NO_WARNING (expr) = 1;\n     }\n }\n \n /* For a call EXPR (which may be null) that expects a string argument\n-   and SRC as the argument, returns false if SRC is a character array\n-   with no terminating NUL.  When nonnull, BOUND is the number of\n-   characters in which to expect the terminating NUL.\n-   When EXPR is nonnull also issues a warning.  */\n+   SRC as an argument, returns false if SRC is a character array with\n+   no terminating NUL.  When nonnull, BOUND is the number of characters\n+   in which to expect the terminating NUL.  RDONLY is true for read-only\n+   accesses such as strcmp, false for read-write such as strcpy.  When\n+   EXPR is also issues a warning.  */\n \n bool\n-check_nul_terminated_array (tree expr, tree src, tree bound /* = NULL_TREE */)\n+check_nul_terminated_array (tree expr, tree src,\n+\t\t\t    tree bound /* = NULL_TREE */)\n {\n+  /* The constant size of the array SRC points to.  The actual size\n+     may be less of EXACT is true, but not more.  */\n   tree size;\n+  /* True if SRC involves a non-constant offset into the array.  */\n   bool exact;\n+  /* The unterminated constant array SRC points to.  */\n   tree nonstr = unterminated_array (src, &size, &exact);\n   if (!nonstr)\n     return true;\n@@ -583,28 +700,30 @@ check_nul_terminated_array (tree expr, tree src, tree bound /* = NULL_TREE */)\n      is the constant size of the array in bytes.  EXACT is true when\n      SIZE is exact.  */\n \n+  wide_int bndrng[2];\n   if (bound)\n     {\n-      wide_int min, max;\n       if (TREE_CODE (bound) == INTEGER_CST)\n-\tmin = max = wi::to_wide (bound);\n+\tbndrng[0] = bndrng[1] = wi::to_wide (bound);\n       else\n \t{\n-\t  value_range_kind rng = get_range_info (bound, &min, &max);\n+\t  value_range_kind rng = get_range_info (bound, bndrng, bndrng + 1);\n \t  if (rng != VR_RANGE)\n \t    return true;\n \t}\n \n-      if (wi::leu_p (min, wi::to_wide (size)))\n+      if (exact)\n+\t{\n+\t  if (wi::leu_p (bndrng[0], wi::to_wide (size)))\n+\t    return true;\n+\t}\n+      else if (wi::lt_p (bndrng[0], wi::to_wide (size), UNSIGNED))\n \treturn true;\n     }\n \n-  if (expr && !TREE_NO_WARNING (expr))\n-    {\n-      tree fndecl = get_callee_fndecl (expr);\n-      const char *fname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n-      warn_string_no_nul (EXPR_LOCATION (expr), fname, src, nonstr);\n-    }\n+  if (expr)\n+    warn_string_no_nul (EXPR_LOCATION (expr), expr, NULL, src, nonstr,\n+\t\t\tsize, exact, bound ? bndrng : NULL);\n \n   return false;\n }\n@@ -2998,40 +3117,35 @@ expand_builtin_strlen (tree exp, rtx target,\n   if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-  class expand_operand ops[4];\n-  rtx pat;\n-  tree len;\n   tree src = CALL_EXPR_ARG (exp, 0);\n-  rtx src_reg;\n-  rtx_insn *before_strlen;\n-  machine_mode insn_mode;\n-  enum insn_code icode = CODE_FOR_nothing;\n-  unsigned int align;\n+  if (!check_read_access (exp, src))\n+    return NULL_RTX;\n \n   /* If the length can be computed at compile-time, return it.  */\n-  len = c_strlen (src, 0);\n-  if (len)\n+  if (tree len = c_strlen (src, 0))\n     return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n \n   /* If the length can be computed at compile-time and is constant\n      integer, but there are side-effects in src, evaluate\n      src for side-effects, then return len.\n      E.g. x = strlen (i++ ? \"xfoo\" + 1 : \"bar\");\n      can be optimized into: i++; x = 3;  */\n-  len = c_strlen (src, 1);\n+  tree len = c_strlen (src, 1);\n   if (len && TREE_CODE (len) == INTEGER_CST)\n     {\n       expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n       return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n     }\n \n-  align = get_pointer_alignment (src) / BITS_PER_UNIT;\n+  unsigned int align = get_pointer_alignment (src) / BITS_PER_UNIT;\n \n   /* If SRC is not a pointer type, don't do this operation inline.  */\n   if (align == 0)\n     return NULL_RTX;\n \n   /* Bail out if we can't compute strlen in the right mode.  */\n+  machine_mode insn_mode;\n+  enum insn_code icode = CODE_FOR_nothing;\n   FOR_EACH_MODE_FROM (insn_mode, target_mode)\n     {\n       icode = optab_handler (strlen_optab, insn_mode);\n@@ -3044,12 +3158,13 @@ expand_builtin_strlen (tree exp, rtx target,\n   /* Make a place to hold the source address.  We will not expand\n      the actual source until we are sure that the expansion will\n      not fail -- there are trees that cannot be expanded twice.  */\n-  src_reg = gen_reg_rtx (Pmode);\n+  rtx src_reg = gen_reg_rtx (Pmode);\n \n   /* Mark the beginning of the strlen sequence so we can emit the\n      source operand later.  */\n-  before_strlen = get_last_insn ();\n+  rtx_insn *before_strlen = get_last_insn ();\n \n+  class expand_operand ops[4];\n   create_output_operand (&ops[0], target, insn_mode);\n   create_fixed_operand (&ops[1], gen_rtx_MEM (BLKmode, src_reg));\n   create_integer_operand (&ops[2], 0);\n@@ -3064,7 +3179,7 @@ expand_builtin_strlen (tree exp, rtx target,\n \n   /* Now that we are assured of success, expand the source.  */\n   start_sequence ();\n-  pat = expand_expr (src, src_reg, Pmode, EXPAND_NORMAL);\n+  rtx pat = expand_expr (src, src_reg, Pmode, EXPAND_NORMAL);\n   if (pat != src_reg)\n     {\n #ifdef POINTERS_EXTEND_UNSIGNED\n@@ -3108,13 +3223,12 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n   if (!bound)\n     return NULL_RTX;\n \n+  check_read_access (exp, src, bound);\n+\n   location_t loc = UNKNOWN_LOCATION;\n   if (EXPR_HAS_LOCATION (exp))\n     loc = EXPR_LOCATION (exp);\n \n-  tree maxobjsize = max_object_size ();\n-  tree func = get_callee_fndecl (exp);\n-\n   /* FIXME: Change c_strlen() to return sizetype instead of ssizetype\n      so these conversions aren't necessary.  */\n   c_strlen_data lendata = { };\n@@ -3124,48 +3238,6 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \n   if (TREE_CODE (bound) == INTEGER_CST)\n     {\n-      if (!TREE_NO_WARNING (exp)\n-\t  && tree_int_cst_lt (maxobjsize, bound)\n-\t  && warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t \"%K%qD specified bound %E \"\n-\t\t\t \"exceeds maximum object size %E\",\n-\t\t\t exp, func, bound, maxobjsize))\n-\tTREE_NO_WARNING (exp) = true;\n-\n-      bool exact = true;\n-      if (!len || TREE_CODE (len) != INTEGER_CST)\n-\t{\n-\t  /* Clear EXACT if LEN may be less than SRC suggests,\n-\t     such as in\n-\t       strnlen (&a[i], sizeof a)\n-\t     where the value of i is unknown.  Unless i's value is\n-\t     zero, the call is unsafe because the bound is greater. */\n-\t  lendata.decl = unterminated_array (src, &len, &exact);\n-\t  if (!lendata.decl)\n-\t    return NULL_RTX;\n-\t}\n-\n-      if (lendata.decl && (tree_int_cst_lt (len, bound) || !exact))\n-\t{\n-\t  location_t warnloc\n-\t    = expansion_point_location_if_in_system_header (loc);\n-\n-\t  if (!TREE_NO_WARNING (exp)\n-\t      && warning_at (warnloc, OPT_Wstringop_overflow_,\n-\t\t\t     exact\n-\t\t\t     ? G_(\"%K%qD specified bound %E exceeds the size \"\n-\t\t\t\t  \"%E of unterminated array\")\n-\t\t\t     : G_(\"%K%qD specified bound %E may exceed the \"\n-\t\t\t\t  \"size of at most %E of unterminated array\"),\n-\t\t\t     exp, func, bound, len))\n-\t    {\n-\t      inform (DECL_SOURCE_LOCATION (lendata.decl),\n-\t\t      \"referenced argument declared here\");\n-\t      TREE_NO_WARNING (exp) = true;\n-\t    }\n-\t  return NULL_RTX;\n-\t}\n-\n       if (!len)\n \treturn NULL_RTX;\n \n@@ -3181,44 +3253,14 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n   if (rng != VR_RANGE)\n     return NULL_RTX;\n \n-  if (!TREE_NO_WARNING (exp)\n-      && wi::ltu_p (wi::to_wide (maxobjsize, min.get_precision ()), min)\n-      && warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t     \"%K%qD specified bound [%wu, %wu] \"\n-\t\t     \"exceeds maximum object size %E\",\n-\t\t     exp, func, min.to_uhwi (), max.to_uhwi (), maxobjsize))\n-    TREE_NO_WARNING (exp) = true;\n-\n-  bool exact = true;\n   if (!len || TREE_CODE (len) != INTEGER_CST)\n     {\n+      bool exact;\n       lendata.decl = unterminated_array (src, &len, &exact);\n       if (!lendata.decl)\n \treturn NULL_RTX;\n     }\n \n-  if (lendata.decl\n-      && !TREE_NO_WARNING (exp)\n-      && (wi::ltu_p (wi::to_wide (len), min)\n-\t  || !exact))\n-    {\n-      location_t warnloc\n-\t= expansion_point_location_if_in_system_header (loc);\n-\n-      if (warning_at (warnloc, OPT_Wstringop_overflow_,\n-\t\t      exact\n-\t\t      ? G_(\"%K%qD specified bound [%wu, %wu] exceeds \"\n-\t\t\t   \"the size %E of unterminated array\")\n-\t\t      : G_(\"%K%qD specified bound [%wu, %wu] may exceed \"\n-\t\t\t   \"the size of at most %E of unterminated array\"),\n-\t\t      exp, func, min.to_uhwi (), max.to_uhwi (), len))\n-\t{\n-\t  inform (DECL_SOURCE_LOCATION (lendata.decl),\n-\t\t  \"referenced argument declared here\");\n-\t  TREE_NO_WARNING (exp) = true;\n-\t}\n-    }\n-\n   if (lendata.decl)\n     return NULL_RTX;\n \n@@ -3305,11 +3347,148 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n+/* Issue a warning OPT for a bounded call EXP with a bound in RANGE\n+   accessing an object with SIZE.  */\n+\n+static bool\n+maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n+\t\t      tree bndrng[2], tree size, const access_data *pad = NULL)\n+{\n+  if (!bndrng[0] || TREE_NO_WARNING (exp))\n+    return false;\n+\n+  tree maxobjsize = max_object_size ();\n+\n+  bool warned = false;\n+\n+  if (opt == OPT_Wstringop_overread)\n+    {\n+      if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n+\t{\n+\t  if (bndrng[0] == bndrng[1])\n+\t    warned = (func\n+\t\t      ? warning_at (loc, opt,\n+\t\t\t\t    \"%K%qD specified bound %E \"\n+\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    exp, func, bndrng[0], maxobjsize)\n+\t\t      : warning_at (loc, opt,\n+\t\t\t\t    \"%Kspecified bound %E \"\n+\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    exp, bndrng[0], maxobjsize));\n+\t  else\n+\t    warned = (func\n+\t\t      ? warning_at (loc, opt,\n+\t\t\t\t    \"%K%qD specified bound [%E, %E] \"\n+\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    exp, func,\n+\t\t\t\t    bndrng[0], bndrng[1], maxobjsize)\n+\t\t      : warning_at (loc, opt,\n+\t\t\t\t    \"%Kspecified bound [%E, %E] \"\n+\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    exp, bndrng[0], bndrng[1], maxobjsize));\n+\t}\n+      else if (!size || tree_int_cst_le (bndrng[0], size))\n+\treturn false;\n+      else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified bound %E exceeds \"\n+\t\t\t\t\"source size %E\",\n+\t\t\t\texp, func, bndrng[0], size)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified bound %E exceeds \"\n+\t\t\t\t\"source size %E\",\n+\t\t\t\texp, bndrng[0], size));\n+      else\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t\t\"source size %E\",\n+\t\t\t\texp, func, bndrng[0], bndrng[1], size)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t\t\"source size %E\",\n+\t\t\t\texp, bndrng[0], bndrng[1], size));\n+      if (warned)\n+\t{\n+\t  if (pad && pad->src.ref)\n+\t    {\n+\t      if (DECL_P (pad->src.ref))\n+\t\tinform (DECL_SOURCE_LOCATION (pad->src.ref),\n+\t\t\t\"source object declared here\");\n+\t      else if (EXPR_HAS_LOCATION (pad->src.ref))\n+\t\tinform (EXPR_LOCATION (pad->src.ref),\n+\t\t\t\"source object allocated here\");\n+\t    }\n+\t  TREE_NO_WARNING (exp) = true;\n+\t}\n+\n+      return warned;\n+    }\n+\n+  if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n+    {\n+      if (bndrng[0] == bndrng[1])\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified size %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, func, bndrng[0], maxobjsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified size %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, bndrng[0], maxobjsize));\n+      else\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified size between %E and %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, func,\n+\t\t\t\tbndrng[0], bndrng[1], maxobjsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified size between %E and %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, bndrng[0], bndrng[1], maxobjsize));\n+    }\n+  else if (!size || tree_int_cst_le (bndrng[0], size))\n+    return false;\n+  else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n+    warned = (func\n+\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%K%qD specified bound %E exceeds \"\n+\t\t\t    \"destination size %E\",\n+\t\t\t    exp, func, bndrng[0], size)\n+\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%Kspecified bound %E exceeds \"\n+\t\t\t    \"destination size %E\",\n+\t\t\t    exp, bndrng[0], size));\n+  else\n+    warned = (func\n+\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t    \"destination size %E\",\n+\t\t\t    exp, func, bndrng[0], bndrng[1], size)\n+\t      : warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t    \"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t    \"destination size %E\",\n+\t\t\t    exp, bndrng[0], bndrng[1], size));\n+\n+  if (warned)\n+    {\n+      if (pad && pad->dst.ref)\n+\tinform (DECL_SOURCE_LOCATION (pad->dst.ref),\n+\t\t\"destination object declared here\");\n+      TREE_NO_WARNING (exp) = true;\n+    }\n+\n+  return warned;\n+}\n+\n /* For an expression EXP issue an access warning controlled by option OPT\n    with access to a region SLEN bytes in size in the RANGE of sizes.  */\n \n static bool\n-warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n+warn_for_access (location_t loc, tree func, tree exp, tree range[2],\n \t\t tree slen, bool access)\n {\n   bool warned = false;\n@@ -3318,82 +3497,93 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n     {\n       if (tree_int_cst_equal (range[0], range[1]))\n \twarned = (func\n-\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t  ? warning_n (loc, OPT_Wstringop_overread,\n+\t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n \t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\n \t\t\t       exp, func, range[0], slen)\n-\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t  : warning_n (loc, OPT_Wstringop_overread,\n+\t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       \"%Kreading %E byte from a region of size %E\",\n \t\t\t       \"%Kreading %E bytes from a region of size %E\",\n \t\t\t       exp, range[0], slen));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n-\t\t    ? warning_at (loc, opt,\n+\t\t    ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t  \"%K%qD reading %E or more bytes from a region \"\n \t\t\t\t  \"of size %E\",\n \t\t\t\t  exp, func, range[0], slen)\n-\t\t    : warning_at (loc, opt,\n+\t\t    : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t  \"%Kreading %E or more bytes from a region \"\n \t\t\t\t  \"of size %E\",\n \t\t\t\t  exp, range[0], slen));\n \t}\n       else\n \twarned = (func\n-\t\t  ? warning_at (loc, opt,\n+\t\t  ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n \t\t\t\t\"a region of size %E\",\n \t\t\t\texp, func, range[0], range[1], slen)\n-\t\t  : warning_at (loc, opt,\n+\t\t  : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t\"%Kreading between %E and %E bytes from \"\n \t\t\t\t\"a region of size %E\",\n \t\t\t\texp, range[0], range[1], slen));\n \n+      if (warned)\n+\tTREE_NO_WARNING (exp) = true;\n+\n       return warned;\n     }\n \n   if (tree_int_cst_equal (range[0], range[1]))\n     warned = (func\n-\t      ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t      ? warning_n (loc, OPT_Wstringop_overread,\n+\t\t\t   tree_to_uhwi (range[0]),\n \t\t\t   \"%K%qD epecting %E byte in a region of size %E\",\n \t\t\t   \"%K%qD expecting %E bytes in a region of size %E\",\n \t\t\t   exp, func, range[0], slen)\n-\t      : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t      : warning_n (loc, OPT_Wstringop_overread,\n+\t\t\t   tree_to_uhwi (range[0]),\n \t\t\t   \"%Kexpecting %E byte in a region of size %E\",\n \t\t\t   \"%Kexpecting %E bytes in a region of size %E\",\n \t\t\t   exp, range[0], slen));\n   else if (tree_int_cst_sign_bit (range[1]))\n     {\n       /* Avoid printing the upper bound if it's invalid.  */\n       warned = (func\n-\t\t? warning_at (loc, opt,\n+\t\t? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t      \"%K%qD expecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n \t\t\t      exp, func, range[0], slen)\n-\t\t: warning_at (loc, opt,\n+\t\t: warning_at (loc, OPT_Wstringop_overread,\n \t\t\t      \"%Kexpecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n \t\t\t      exp, range[0], slen));\n     }\n   else\n     warned = (func\n-\t      ? warning_at (loc, opt,\n+\t      ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t    \"%K%qD expecting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n \t\t\t    exp, func, range[0], range[1], slen)\n-\t      : warning_at (loc, opt,\n+\t      : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t    \"%Kexpectting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n \t\t\t    exp, range[0], range[1], slen));\n+\n+  if (warned)\n+    TREE_NO_WARNING (exp) = true;\n+\n   return warned;\n }\n \n /* Issue an inform message describing the target of an access REF.\n    WRITE is set for a write access and clear for a read access.  */\n \n static void\n-inform_access (const access_ref &ref, bool write)\n+inform_access (const access_ref &ref, access_mode mode)\n {\n   if (!ref.ref)\n     return;\n@@ -3443,7 +3633,7 @@ inform_access (const access_ref &ref, bool write)\n   else\n     loc = DECL_SOURCE_LOCATION (ref.ref);\n \n-  if (write)\n+  if (mode == access_read_write || mode == access_write_only)\n     {\n       if (DECL_P (ref.ref))\n \t{\n@@ -3513,6 +3703,34 @@ inform_access (const access_ref &ref, bool write)\n \t    minoff, maxoff, sizestr, allocfn);\n }\n \n+/* Helper to set RANGE to the range of BOUND if it's nonnull, bounded\n+   by BNDRNG if nonnull and valid.  */\n+\n+static void\n+get_size_range (tree bound, tree range[2], const offset_int bndrng[2])\n+{\n+  if (bound)\n+    get_size_range (bound, range);\n+\n+  if (!bndrng || (bndrng[0] == 0 && bndrng[1] == HOST_WIDE_INT_M1U))\n+    return;\n+\n+  if (range[0] && TREE_CODE (range[0]) == INTEGER_CST)\n+    {\n+      offset_int r[] =\n+\t{ wi::to_offset (range[0]), wi::to_offset (range[1]) };\n+      if (r[0] < bndrng[0])\n+\trange[0] = wide_int_to_tree (sizetype, bndrng[0]);\n+      if (bndrng[1] < r[1])\n+\trange[1] = wide_int_to_tree (sizetype, bndrng[1]);\n+    }\n+  else\n+    {\n+      range[0] = wide_int_to_tree (sizetype, bndrng[0]);\n+      range[1] = wide_int_to_tree (sizetype, bndrng[1]);\n+    }\n+}\n+\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow or read past the end.\n@@ -3531,10 +3749,7 @@ inform_access (const access_ref &ref, bool write)\n    like memcpy).  As an exception, SRCSTR can also be an integer denoting\n    the precomputed size of the source string or object (for functions like\n    memcpy).\n-   DSTSIZE is the size of the destination object specified by the last\n-   argument to the _chk builtins, typically resulting from the expansion\n-   of __builtin_object_size (such as in __builtin___strcpy_chk(DST, SRC,\n-   DSTSIZE).\n+   DSTSIZE is the size of the destination object.\n \n    When DSTWRITE is null LEN is checked to verify that it doesn't exceed\n    SIZE_MAX.\n@@ -3548,21 +3763,22 @@ inform_access (const access_ref &ref, bool write)\n    return false.  */\n \n bool\n-check_access (tree exp, tree, tree, tree dstwrite,\n+check_access (tree exp, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n-\t      bool access /* = true */,\n-\t      const access_data *pad /* = NULL */)\n+\t      access_mode mode, const access_data *pad /* = NULL */)\n {\n-  int opt = OPT_Wstringop_overflow_;\n-\n   /* The size of the largest object is half the address space, or\n      PTRDIFF_MAX.  (This is way too permissive.)  */\n   tree maxobjsize = max_object_size ();\n \n-  /* Either the length of the source string for string functions or\n-     the size of the source object for raw memory functions.  */\n+  /* Either an approximate/minimum the length of the source string for\n+     string functions or the size of the source object for raw memory\n+     functions.  */\n   tree slen = NULL_TREE;\n \n+  /* The range of the access in bytes; first set to the write access\n+     for functions that write and then read for those that also (or\n+     just) read.  */\n   tree range[2] = { NULL_TREE, NULL_TREE };\n \n   /* Set to true when the exact number of bytes written by a string\n@@ -3575,6 +3791,8 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t it can be an integer denoting the length of a string.  */\n       if (POINTER_TYPE_P (TREE_TYPE (srcstr)))\n \t{\n+\t  if (!check_nul_terminated_array (exp, srcstr, maxread))\n+\t    return false;\n \t  /* Try to determine the range of lengths the source string\n \t     refers to.  If it can be determined and is less than\n \t     the upper bound given by MAXREAD add one to it for\n@@ -3584,7 +3802,10 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t  get_range_strlen (srcstr, &lendata, /* eltsize = */ 1);\n \t  range[0] = lendata.minlen;\n \t  range[1] = lendata.maxbound ? lendata.maxbound : lendata.maxlen;\n-\t  if (range[0] && (!maxread || TREE_CODE (maxread) == INTEGER_CST))\n+\t  if (range[0]\n+\t      && TREE_CODE (range[0]) == INTEGER_CST\n+\t      && TREE_CODE (range[1]) == INTEGER_CST\n+\t      && (!maxread || TREE_CODE (maxread) == INTEGER_CST))\n \t    {\n \t      if (maxread && tree_int_cst_le (maxread, range[0]))\n \t\trange[0] = range[1] = maxread;\n@@ -3626,8 +3847,9 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   if (!dstsize)\n     dstsize = maxobjsize;\n \n-  if (dstwrite)\n-    get_size_range (dstwrite, range);\n+  /* Set RANGE to that of DSTWRITE if non-null, bounded by PAD->DST.BNDRNG\n+     if valid.  */\n+  get_size_range (dstwrite, range, pad ? pad->dst.bndrng : NULL);\n \n   tree func = get_callee_fndecl (exp);\n \n@@ -3637,37 +3859,11 @@ check_access (tree exp, tree, tree, tree dstwrite,\n       && TREE_CODE (range[0]) == INTEGER_CST\n       && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n-      if (TREE_NO_WARNING (exp))\n-\treturn false;\n-\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n-      bool warned;\n-      if (range[0] == range[1])\n-\twarned = (func\n-\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified size %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\texp, func, range[0], maxobjsize)\n-\t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified size %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\texp, range[0], maxobjsize));\n-      else\n-\twarned = (func\n-\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified size between %E and %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\texp, func,\n-\t\t\t\trange[0], range[1], maxobjsize)\n-\t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified size between %E and %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\texp, range[0], range[1], maxobjsize));\n-      if (warned)\n-\tTREE_NO_WARNING (exp) = true;\n-\n+      maybe_warn_for_bound (OPT_Wstringop_overflow_, loc, exp, func, range,\n+\t\t\t    NULL_TREE, pad);\n       return false;\n     }\n \n@@ -3687,7 +3883,8 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t\t  && tree_fits_uhwi_p (dstwrite)\n \t\t  && tree_int_cst_lt (dstwrite, range[0]))))\n \t{\n-\t  if (TREE_NO_WARNING (exp))\n+\t  if (TREE_NO_WARNING (exp)\n+\t      || (pad && pad->dst.ref && TREE_NO_WARNING (pad->dst.ref)))\n \t    return false;\n \n \t  location_t loc = tree_nonartificial_location (exp);\n@@ -3700,26 +3897,28 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t\t and a source of unknown length.  The call will write\n \t\t at least one byte past the end of the destination.  */\n \t      warned = (func\n-\t\t\t? warning_at (loc, opt,\n+\t\t\t? warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t      \"%K%qD writing %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, func, range[0], dstsize)\n-\t\t\t: warning_at (loc, opt,\n+\t\t\t: warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t      \"%Kwriting %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, range[0], dstsize));\n \t    }\n \t  else if (tree_int_cst_equal (range[0], range[1]))\n \t    warned = (func\n-\t\t      ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t      ? warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t   tree_to_uhwi (range[0]),\n \t\t\t\t   \"%K%qD writing %E byte into a region \"\n \t\t\t\t   \"of size %E overflows the destination\",\n \t\t\t\t   \"%K%qD writing %E bytes into a region \"\n \t\t\t\t   \"of size %E overflows the destination\",\n \t\t\t\t   exp, func, range[0], dstsize)\n-\t\t      : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t      : warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t   tree_to_uhwi (range[0]),\n \t\t\t\t   \"%Kwriting %E byte into a region \"\n \t\t\t\t   \"of size %E overflows the destination\",\n \t\t\t\t   \"%Kwriting %E bytes into a region \"\n@@ -3729,26 +3928,26 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t    {\n \t      /* Avoid printing the upper bound if it's invalid.  */\n \t      warned = (func\n-\t\t\t? warning_at (loc, opt,\n+\t\t\t? warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t      \"%K%qD writing %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, func, range[0], dstsize)\n-\t\t\t: warning_at (loc, opt,\n+\t\t\t: warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t      \"%Kwriting %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, range[0], dstsize));\n \t    }\n \t  else\n \t    warned = (func\n-\t\t      ? warning_at (loc, opt,\n+\t\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t    \"%K%qD writing between %E and %E bytes \"\n \t\t\t\t    \"into a region of size %E overflows \"\n \t\t\t\t    \"the destination\",\n \t\t\t\t    exp, func, range[0], range[1],\n \t\t\t\t    dstsize)\n-\t\t      : warning_at (loc, opt,\n+\t\t      : warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t    \"%Kwriting between %E and %E bytes \"\n \t\t\t\t    \"into a region of size %E overflows \"\n \t\t\t\t    \"the destination\",\n@@ -3758,7 +3957,7 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t    {\n \t      TREE_NO_WARNING (exp) = true;\n \t      if (pad)\n-\t\tinform_access (pad->dst, true);\n+\t\tinform_access (pad->dst, pad->mode);\n \t    }\n \n \t  /* Return error when an overflow has been detected.  */\n@@ -3771,113 +3970,95 @@ check_access (tree exp, tree, tree, tree dstwrite,\n      of an object.  */\n   if (maxread)\n     {\n-      get_size_range (maxread, range);\n-      if (range[0] && dstsize && tree_fits_uhwi_p (dstsize))\n-\t{\n-\t  location_t loc = tree_nonartificial_location (exp);\n-\t  loc = expansion_point_location_if_in_system_header (loc);\n+      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n+\t PAD is nonnull and BNDRNG is valid.  */\n+      get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n+\n+      location_t loc = tree_nonartificial_location (exp);\n+      loc = expansion_point_location_if_in_system_header (loc);\n \n+      tree size = dstsize;\n+      if (pad && pad->mode == access_read_only)\n+\tsize = wide_int_to_tree (sizetype, pad->src.sizrng[1]);\n+\n+      if (range[0] && maxread && tree_fits_uhwi_p (size))\n+\t{\n \t  if (tree_int_cst_lt (maxobjsize, range[0]))\n \t    {\n-\t      if (TREE_NO_WARNING (exp))\n-\t\treturn false;\n-\n-\t      bool warned = false;\n-\n-\t      /* Warn about crazy big sizes first since that's more\n-\t\t likely to be meaningful than saying that the bound\n-\t\t is greater than the object size if both are big.  */\n-\t      if (range[0] == range[1])\n-\t\twarned = (func\n-\t\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\t\"%K%qD specified bound %E \"\n-\t\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\t\texp, func, range[0], maxobjsize)\n-\t\t\t  : warning_at (loc, opt,\n-\t\t\t\t\t\"%Kspecified bound %E \"\n-\t\t\t\t\t\"exceeds maximum object size %E\",\n-\t\t\t\t\texp, range[0], maxobjsize));\n-\t      else\n-\t\twarned = (func\n-\t\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\t\"%K%qD specified bound between \"\n-\t\t\t\t\t\"%E and %E exceeds maximum object \"\n-\t\t\t\t\t\"size %E\",\n-\t\t\t\t\texp, func,\n-\t\t\t\t\trange[0], range[1], maxobjsize)\n-\t\t\t  : warning_at (loc, opt,\n-\t\t\t\t\t\"%Kspecified bound between \"\n-\t\t\t\t\t\"%E and %E exceeds maximum object \"\n-\t\t\t\t\t\"size %E\",\n-\t\t\t\t\texp, range[0], range[1], maxobjsize));\n-\t      if (warned)\n-\t\tTREE_NO_WARNING (exp) = true;\n-\n+\t      maybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n+\t\t\t\t    range, size, pad);\n \t      return false;\n \t    }\n \n-\t  if (dstsize != maxobjsize && tree_int_cst_lt (dstsize, range[0]))\n+\t  if (size != maxobjsize && tree_int_cst_lt (size, range[0]))\n \t    {\n-\t      if (TREE_NO_WARNING (exp))\n-\t\treturn false;\n-\n-\t      bool warned = false;\n-\n-\t      if (tree_int_cst_equal (range[0], range[1]))\n-\t\twarned = (func\n-\t\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\t\"%K%qD specified bound %E \"\n-\t\t\t\t\t\"exceeds destination size %E\",\n-\t\t\t\t\texp, func,\n-\t\t\t\t\trange[0], dstsize)\n-\t\t\t  : warning_at (loc, opt,\n-\t\t\t\t\t\"%Kspecified bound %E \"\n-\t\t\t\t\t\"exceeds destination size %E\",\n-\t\t\t\t\texp, range[0], dstsize));\n-\t      else\n-\t\twarned = (func\n-\t\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\t\"%K%qD specified bound between %E \"\n-\t\t\t\t\t\"and %E exceeds destination size %E\",\n-\t\t\t\t\texp, func,\n-\t\t\t\t\trange[0], range[1], dstsize)\n-\t\t\t  : warning_at (loc, opt,\n-\t\t\t\t\t\"%Kspecified bound between %E \"\n-\t\t\t\t\t\"and %E exceeds destination size %E\",\n-\t\t\t\t\texp,\n-\t\t\t\t\trange[0], range[1], dstsize));\n-\t      if (warned)\n-\t\tTREE_NO_WARNING (exp) = true;\n-\n+\t      int opt = (dstwrite || mode != access_read_only\n+\t\t\t ? OPT_Wstringop_overflow_\n+\t\t\t : OPT_Wstringop_overread);\n+\t      maybe_warn_for_bound (opt, loc, exp, func, range, size, pad);\n \t      return false;\n \t    }\n \t}\n+\n+      maybe_warn_nonstring_arg (func, exp);\n     }\n \n   /* Check for reading past the end of SRC.  */\n-  if (slen\n-      && slen == srcstr\n-      && dstwrite && range[0]\n-      && tree_int_cst_lt (slen, range[0]))\n+  bool overread = (slen\n+\t\t   && slen == srcstr\n+\t\t   && dstwrite\n+\t\t   && range[0]\n+\t\t   && TREE_CODE (slen) == INTEGER_CST\n+\t\t   && tree_int_cst_lt (slen, range[0]));\n+\n+  if (!overread && pad && pad->src.sizrng[1] >= 0 && pad->src.offrng[0] >= 0)\n     {\n-      if (TREE_NO_WARNING (exp))\n+      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n+\t PAD is nonnull and BNDRNG is valid.  */\n+      get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n+      /* Set OVERREAD for reads starting just past the end of an object.  */\n+      overread = pad->src.sizrng[1] - pad->src.offrng[0] < pad->src.bndrng[0];\n+      range[0] = wide_int_to_tree (sizetype, pad->src.bndrng[0]);\n+      slen = size_zero_node;\n+    }\n+\n+  if (overread)\n+    {\n+      if (TREE_NO_WARNING (exp)\n+\t  || (srcstr && TREE_NO_WARNING (srcstr))\n+\t  || (pad && pad->src.ref && TREE_NO_WARNING (pad->src.ref)))\n \treturn false;\n \n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n-      if (warn_for_access (loc, func, exp, opt, range, slen, access))\n-\t{\n-\t  TREE_NO_WARNING (exp) = true;\n-\t  if (pad)\n-\t    inform_access (pad->src, false);\n-\t}\n+      if (warn_for_access (loc, func, exp, range, slen, mode)\n+\t  && pad)\n+\tinform_access (pad->src, access_read_only);\n+\n       return false;\n     }\n \n   return true;\n }\n \n+/* A convenience wrapper for check_access above to check access\n+   by a read-only function like puts.  */\n+\n+static bool\n+check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n+\t\t   int ost /* = 1 */)\n+{\n+  if (!warn_stringop_overread)\n+    return true;\n+\n+  access_data data (exp, access_read_only, NULL_TREE, false, bound, true);\n+  compute_objsize (src, ost, &data.src);\n+  return check_access (exp, /*dstwrite=*/ NULL_TREE, /*maxread=*/ bound,\n+\t\t       /*srcstr=*/ src, /*dstsize=*/ NULL_TREE, data.mode,\n+\t\t       &data);\n+}\n+\n /* If STMT is a call to an allocation function, returns the constant\n    size of the object allocated by the call represented as sizetype.\n    If nonnull, sets RNG1[] to the range of the size.  */\n@@ -4216,7 +4397,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n static tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t const vr_values *rvals = NULL)\n+\t\t const vr_values *rvals /* = NULL */)\n {\n   bitmap visited = NULL;\n \n@@ -4280,12 +4461,12 @@ check_memop_access (tree exp, tree dest, tree src, tree size)\n      try to determine the size of the largest source and destination\n      object using type-0 Object Size regardless of the object size\n      type specified by the option.  */\n-  access_data data;\n+  access_data data (exp, access_read_write);\n   tree srcsize = src ? compute_objsize (src, 0, &data.src) : NULL_TREE;\n   tree dstsize = compute_objsize (dest, 0, &data.dst);\n \n-  return check_access (exp, dest, src, size, /*maxread=*/NULL_TREE,\n-\t\t       srcsize, dstsize, true, &data);\n+  return check_access (exp, size, /*maxread=*/NULL_TREE,\n+\t\t       srcsize, dstsize, data.mode, &data);\n }\n \n /* Validate memchr arguments without performing any expansion.\n@@ -4301,16 +4482,7 @@ expand_builtin_memchr (tree exp, rtx)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  /* Diagnose calls where the specified length exceeds the size\n-     of the object.  */\n-  if (warn_stringop_overflow)\n-    {\n-      access_data data;\n-      tree size = compute_objsize (arg1, 0, &data.src);\n-      check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n-\t\t    /*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE,\n-\t\t    true, &data);\n-    }\n+  check_read_access (exp, arg1, len, 0);\n \n   return NULL_RTX;\n }\n@@ -4580,20 +4752,18 @@ expand_builtin_strcat (tree exp)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree src = CALL_EXPR_ARG (exp, 1);\n \n-  /* Detect unterminated source (only).  */\n-  if (!check_nul_terminated_array (exp, src))\n-    return NULL_RTX;\n-\n   /* There is no way here to determine the length of the string in\n      the destination to which the SRC string is being appended so\n      just diagnose cases when the souce string is longer than\n      the destination object.  */\n+  access_data data (exp, access_read_write, NULL_TREE, true,\n+\t\t    NULL_TREE, true);\n+  const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+  compute_objsize (src, ost, &data.src);\n+  tree destsize = compute_objsize (dest, ost, &data.dst);\n \n-  access_data data;\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n-\n-  check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE, src,\n-\t\tdestsize, true, &data);\n+  check_access (exp, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n+\t\tsrc, destsize, data.mode, &data);\n \n   return NULL_RTX;\n }\n@@ -4614,11 +4784,14 @@ expand_builtin_strcpy (tree exp, rtx target)\n \n   if (warn_stringop_overflow)\n     {\n-      access_data data;\n-      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1,\n-\t\t\t\t       &data.dst);\n-      check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\t    src, destsize, true, &data);\n+      access_data data (exp, access_read_write, NULL_TREE, true,\n+\t\t\tNULL_TREE, true);\n+      const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+      compute_objsize (src, ost, &data.src);\n+      tree dstsize = compute_objsize (dest, ost, &data.dst);\n+      check_access (exp, /*dstwrite=*/ NULL_TREE,\n+\t\t    /*maxread=*/ NULL_TREE, /*srcstr=*/ src,\n+\t\t    dstsize, data.mode, &data);\n     }\n \n   if (rtx ret = expand_builtin_strcpy_args (exp, dest, src, target))\n@@ -4644,11 +4817,13 @@ static rtx\n expand_builtin_strcpy_args (tree exp, tree dest, tree src, rtx target)\n {\n   /* Detect strcpy calls with unterminated arrays..  */\n-  if (tree nonstr = unterminated_array (src))\n+  tree size;\n+  bool exact;\n+  if (tree nonstr = unterminated_array (src, &size, &exact))\n     {\n       /* NONSTR refers to the non-nul terminated constant array.  */\n-      if (!TREE_NO_WARNING (exp))\n-\twarn_string_no_nul (EXPR_LOCATION (exp), \"strcpy\", src, nonstr);\n+      warn_string_no_nul (EXPR_LOCATION (exp), exp, NULL, src, nonstr,\n+\t\t\t  size, exact);\n       return NULL_RTX;\n     }\n \n@@ -4674,11 +4849,11 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \n   if (warn_stringop_overflow)\n     {\n-      access_data data;\n+      access_data data (exp, access_read_write);\n       tree destsize = compute_objsize (dst, warn_stringop_overflow - 1,\n \t\t\t\t       &data.dst);\n-      check_access (exp, dst, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\t    src, destsize, true, &data);\n+      check_access (exp, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n+\t\t    src, destsize, data.mode, &data);\n     }\n \n   /* If return value is ignored, transform stpcpy into strcpy.  */\n@@ -4703,8 +4878,8 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \treturn expand_movstr (dst, src, target,\n \t\t\t      /*retmode=*/ RETURN_END_MINUS_ONE);\n \n-      if (lendata.decl && !TREE_NO_WARNING (exp))\n-\twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, lendata.decl);\n+      if (lendata.decl)\n+\twarn_string_no_nul (EXPR_LOCATION (exp), exp, NULL, src, lendata.decl);\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n@@ -4784,15 +4959,10 @@ expand_builtin_stpncpy (tree exp, rtx)\n \n   /* The exact number of bytes to write (not the maximum).  */\n   tree len = CALL_EXPR_ARG (exp, 2);\n-  if (!check_nul_terminated_array (exp, src, len))\n-    return NULL_RTX;\n-\n-  access_data data;\n+  access_data data (exp, access_read_write);\n   /* The size of the destination object.  */\n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n-\n-  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src, destsize,\n-\t\ttrue, &data);\n+  check_access (exp, len, /*maxread=*/len, src, destsize, data.mode, &data);\n \n   return NULL_RTX;\n }\n@@ -4832,7 +5002,7 @@ check_strncat_sizes (tree exp, tree objsize)\n   /* Try to verify that the destination is big enough for the shortest\n      string.  */\n \n-  access_data data;\n+  access_data data (exp, access_read_write, maxread, true);\n   if (!objsize && warn_stringop_overflow)\n     {\n       /* If it hasn't been provided by __strncat_chk, try to determine\n@@ -4871,8 +5041,8 @@ check_strncat_sizes (tree exp, tree objsize)\n \n   /* The number of bytes to write is LEN but check_access will alsoa\n      check SRCLEN if LEN's value isn't known.  */\n-  return check_access (exp, dest, src, /*size=*/NULL_TREE, maxread, srclen,\n-\t\t       objsize, true, &data);\n+  return check_access (exp, /*dstwrite=*/NULL_TREE, maxread, srclen,\n+\t\t       objsize, data.mode, &data);\n }\n \n /* Similar to expand_builtin_strcat, do some very basic size validation\n@@ -4910,7 +5080,7 @@ expand_builtin_strncat (tree exp, rtx)\n       maxlen = lendata.maxbound;\n     }\n \n-  access_data data;\n+  access_data data (exp, access_read_write);\n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n@@ -4944,8 +5114,8 @@ expand_builtin_strncat (tree exp, rtx)\n \t  && tree_int_cst_lt (maxread, srclen)))\n     srclen = maxread;\n \n-  check_access (exp, dest, src, NULL_TREE, maxread, srclen, destsize,\n-\t\ttrue, &data);\n+  check_access (exp, /*dstwrite=*/NULL_TREE, maxread, srclen,\n+\t\tdestsize, data.mode, &data);\n \n   return NULL_RTX;\n }\n@@ -4966,22 +5136,19 @@ expand_builtin_strncpy (tree exp, rtx target)\n   /* The number of bytes to write (not the maximum).  */\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  if (!check_nul_terminated_array (exp, src, len))\n-    return NULL_RTX;\n-\n   /* The length of the source sequence.  */\n   tree slen = c_strlen (src, 1);\n \n   if (warn_stringop_overflow)\n     {\n-      access_data data;\n-      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1,\n-\t\t\t\t       &data.dst);\n-\n+      access_data data (exp, access_read_write, len, true, len, true);\n+      const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+      compute_objsize (src, ost, &data.src);\n+      tree dstsize = compute_objsize (dest, ost, &data.dst);\n       /* The number of bytes to write is LEN but check_access will also\n \t check SLEN if LEN's value isn't known.  */\n-      check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src,\n-\t\t    destsize, true, &data);\n+      check_access (exp, /*dstwrite=*/len,\n+\t\t    /*maxread=*/len, src, dstsize, data.mode, &data);\n     }\n \n   /* We must be passed a constant len and src parameter.  */\n@@ -5289,34 +5456,17 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (get_callee_fndecl (exp));\n-  bool no_overflow = true;\n \n   /* Diagnose calls where the specified length exceeds the size of either\n      object.  */\n-  access_data data;\n-  tree size = compute_objsize (arg1, 0, &data.src);\n-  no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n-\t\t\t      len, /*maxread=*/NULL_TREE, size,\n-\t\t\t      /*objsize=*/NULL_TREE, true, &data);\n-  if (no_overflow)\n-    {\n-      access_data data;\n-      size = compute_objsize (arg2, 0, &data.src);\n-      no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n-\t\t\t\t  len,  /*maxread=*/NULL_TREE, size,\n-\t\t\t\t  /*objsize=*/NULL_TREE, true, &data);\n-    }\n-\n-  /* If the specified length exceeds the size of either object, \n-     call the function.  */\n-  if (!no_overflow)\n+  if (!check_read_access (exp, arg1, len, 0)\n+      || !check_read_access (exp, arg2, len, 0))\n     return NULL_RTX;\n \n   /* Due to the performance benefit, always inline the calls first\n      when result_eq is false.  */\n   rtx result = NULL_RTX;\n-\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (get_callee_fndecl (exp));\n   if (!result_eq && fcode != BUILT_IN_BCMP)\n     {\n       result = inline_expand_builtin_bytecmp (exp, target);\n@@ -5405,8 +5555,8 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n \n-  if (!check_nul_terminated_array (exp, arg1)\n-      || !check_nul_terminated_array (exp, arg2))\n+  if (!check_read_access (exp, arg1)\n+      || !check_read_access (exp, arg2))\n     return NULL_RTX;\n \n   /* Due to the performance benefit, always inline the calls first.  */\n@@ -5514,8 +5664,8 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n }\n \n /* Expand expression EXP, which is a call to the strncmp builtin. Return\n-   NULL_RTX if we failed the caller should emit a normal call, otherwise try to get\n-   the result in TARGET, if convenient.  */\n+   NULL_RTX if we failed the caller should emit a normal call, otherwise\n+   try to get the result in TARGET, if convenient.  */\n \n static rtx\n expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n@@ -5533,6 +5683,56 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n       || !check_nul_terminated_array (exp, arg2, arg3))\n     return NULL_RTX;\n \n+  location_t loc = tree_nonartificial_location (exp);\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  tree len1 = c_strlen (arg1, 1);\n+  tree len2 = c_strlen (arg2, 1);\n+\n+  if (!len1 || !len2)\n+    {\n+      /* Check to see if the argument was declared attribute nonstring\n+\t and if so, issue a warning since at this point it's not known\n+\t to be nul-terminated.  */\n+      if (!maybe_warn_nonstring_arg (get_callee_fndecl (exp), exp)\n+\t  && !len1 && !len2)\n+\t{\n+\t  /* A strncmp read is constrained not just by the bound but\n+\t     also by the length of the shorter string.  Specifying\n+\t     a bound that's larger than the size of either array makes\n+\t     no sense and is likely a bug.  When the length of neither\n+\t     of the two strings is known but the sizes of both of\n+\t     the arrays they are stored in is, issue a warning if\n+\t     the bound is larger than than the size of the larger\n+\t     of the two arrays.  */\n+\n+\t  access_ref ref1 (arg3, true);\n+\t  access_ref ref2 (arg3, true);\n+\n+\t  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n+\t  get_size_range (arg3, bndrng, ref1.bndrng);\n+\n+\t  tree size1 = compute_objsize (arg1, 1, &ref1);\n+\t  tree size2 = compute_objsize (arg2, 1, &ref2);\n+\t  tree func = get_callee_fndecl (exp);\n+\n+\t  if (size1 && size2)\n+\t    {\n+\t      tree maxsize = tree_int_cst_le (size1, size2) ? size2 : size1;\n+\n+\t      if (tree_int_cst_lt (maxsize, bndrng[0]))\n+\t\tmaybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n+\t\t\t\t      bndrng, maxsize);\n+\t    }\n+\t  else if (bndrng[0]\n+\t\t   && !integer_zerop (bndrng[0])\n+\t\t   && ((size1 && integer_zerop (size1))\n+\t\t       || (size2 && integer_zerop (size2))))\n+\t    maybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n+\t\t\t\t  bndrng, integer_zero_node);\n+\t}\n+    }\n+\n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n   result = inline_expand_builtin_bytecmp (exp, target);\n@@ -5551,11 +5751,6 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n   unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n   unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n \n-  tree len1 = c_strlen (arg1, 1);\n-  tree len2 = c_strlen (arg2, 1);\n-\n-  location_t loc = EXPR_LOCATION (exp);\n-\n   if (len1)\n     len1 = size_binop_loc (loc, PLUS_EXPR, ssize_int (1), len1);\n   if (len2)\n@@ -5607,11 +5802,6 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n   tree fndecl = get_callee_fndecl (exp);\n   if (result)\n     {\n-      /* Check to see if the argument was declared attribute nonstring\n-\t and if so, issue a warning since at this point it's not known\n-\t to be nul-terminated.  */\n-      maybe_warn_nonstring_arg (fndecl, exp);\n-\n       /* Return the value in the proper mode for this function.  */\n       mode = TYPE_MODE (TREE_TYPE (exp));\n       if (GET_MODE (result) == mode)\n@@ -5624,10 +5814,12 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n   /* Expand the library call ourselves using a stabilized argument\n      list to avoid re-evaluating the function's arguments twice.  */\n-  tree fn = build_call_nofold_loc (loc, fndecl, 3, arg1, arg2, len);\n-  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n-  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n-  return expand_call (fn, target, target == const0_rtx);\n+  tree call = build_call_nofold_loc (loc, fndecl, 3, arg1, arg2, len);\n+  if (TREE_NO_WARNING (exp))\n+    TREE_NO_WARNING (call) = true;\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (call) = CALL_EXPR_TAILCALL (exp);\n+  return expand_call (call, target, target == const0_rtx);\n }\n \n /* Expand a call to __builtin_saveregs, generating the result in TARGET,\n@@ -6544,8 +6736,9 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n \n   if (DECL_FUNCTION_CODE (fn) != BUILT_IN_FORK)\n     {\n+      tree path = CALL_EXPR_ARG (exp, 0);\n       /* Detect unterminated path.  */\n-      if (!check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0)))\n+      if (!check_read_access (exp, path))\n \treturn NULL_RTX;\n \n       /* Also detect unterminated first argument.  */\n@@ -6554,7 +6747,7 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n \tcase BUILT_IN_EXECL:\n \tcase BUILT_IN_EXECLE:\n \tcase BUILT_IN_EXECLP:\n-\t  if (!check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0)))\n+\t  if (!check_read_access (exp, path))\n \t    return NULL_RTX;\n \tdefault:\n \t  break;\n@@ -8262,36 +8455,37 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     case BUILT_IN_PUTS_UNLOCKED:\n     case BUILT_IN_STRDUP:\n       if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n-\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n       break;\n \n     case BUILT_IN_INDEX:\n     case BUILT_IN_RINDEX:\n     case BUILT_IN_STRCHR:\n     case BUILT_IN_STRRCHR:\n       if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n       break;\n \n     case BUILT_IN_FPUTS:\n     case BUILT_IN_FPUTS_UNLOCKED:\n       if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n       break;\n \n     case BUILT_IN_STRNDUP:\n       if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-\tcheck_nul_terminated_array (exp,\n-\t\t\t\t    CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t    CALL_EXPR_ARG (exp, 1));\n+\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0), CALL_EXPR_ARG (exp, 1));\n       break;\n \n     case BUILT_IN_STRCASECMP:\n+    case BUILT_IN_STRPBRK:\n+    case BUILT_IN_STRSPN:\n+    case BUILT_IN_STRCSPN:\n     case BUILT_IN_STRSTR:\n       if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n \t{\n-\t  check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n-\t  check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 1));\n+\t  check_read_access (exp, CALL_EXPR_ARG (exp, 0));\n+\t  check_read_access (exp, CALL_EXPR_ARG (exp, 1));\n \t}\n       break;\n \n@@ -9321,10 +9515,11 @@ fold_builtin_classify_type (tree arg)\n   return build_int_cst (integer_type_node, type_to_class (TREE_TYPE (arg)));\n }\n \n-/* Fold a call to __builtin_strlen with argument ARG.  */\n+/* Fold a call EXPR (which may be null) to __builtin_strlen with argument\n+   ARG.  */\n \n static tree\n-fold_builtin_strlen (location_t loc, tree type, tree arg)\n+fold_builtin_strlen (location_t loc, tree expr, tree type, tree arg)\n {\n   if (!validate_arg (arg, POINTER_TYPE))\n     return NULL_TREE;\n@@ -9345,7 +9540,7 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n \t    loc = EXPR_LOCATION (arg);\n \t  else if (loc == UNKNOWN_LOCATION)\n \t    loc = input_location;\n-\t  warn_string_no_nul (loc, \"strlen\", arg, lendata.decl);\n+\t  warn_string_no_nul (loc, expr, \"strlen\", arg, lendata.decl);\n \t}\n \n       return NULL_TREE;\n@@ -10234,7 +10429,7 @@ fold_builtin_0 (location_t loc, tree fndecl)\n    This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n-fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n+fold_builtin_1 (location_t loc, tree expr, tree fndecl, tree arg0)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10264,7 +10459,7 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n       return fold_builtin_classify_type (arg0);\n \n     case BUILT_IN_STRLEN:\n-      return fold_builtin_strlen (loc, type, arg0);\n+      return fold_builtin_strlen (loc, expr, type, arg0);\n \n     CASE_FLT_FN (BUILT_IN_FABS):\n     CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):\n@@ -10531,7 +10726,7 @@ fold_builtin_n (location_t loc, tree expr, tree fndecl, tree *args,\n       ret = fold_builtin_0 (loc, fndecl);\n       break;\n     case 1:\n-      ret = fold_builtin_1 (loc, fndecl, args[0]);\n+      ret = fold_builtin_1 (loc, expr, fndecl, args[0]);\n       break;\n     case 2:\n       ret = fold_builtin_2 (loc, expr, fndecl, args[0], args[1]);\n@@ -10822,16 +11017,12 @@ readonly_data_expr (tree exp)\n    form of the builtin function call.  */\n \n static tree\n-fold_builtin_strpbrk (location_t loc, tree expr, tree s1, tree s2, tree type)\n+fold_builtin_strpbrk (location_t loc, tree, tree s1, tree s2, tree type)\n {\n   if (!validate_arg (s1, POINTER_TYPE)\n       || !validate_arg (s2, POINTER_TYPE))\n     return NULL_TREE;\n \n-  if (!check_nul_terminated_array (expr, s1)\n-      || !check_nul_terminated_array (expr, s2))\n-    return NULL_TREE;\n-\n   tree fn;\n   const char *p1, *p2;\n \n@@ -11134,8 +11325,9 @@ expand_builtin_memory_chk (tree exp, rtx target, machine_mode mode,\n   tree len = CALL_EXPR_ARG (exp, 2);\n   tree size = CALL_EXPR_ARG (exp, 3);\n \n-  bool sizes_ok = check_access (exp, dest, src, len, /*maxread=*/NULL_TREE,\n-\t\t\t\t/*str=*/NULL_TREE, size);\n+  /* FIXME: Set access mode to write only for memset et al.  */\n+  bool sizes_ok = check_access (exp, len, /*maxread=*/NULL_TREE,\n+\t\t\t\t/*srcstr=*/NULL_TREE, size, access_read_write);\n \n   if (!tree_fits_uhwi_p (size))\n     return NULL_RTX;\n@@ -11236,7 +11428,7 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n {\n   /* The source string.  */\n   tree srcstr = NULL_TREE;\n-  /* The size of the destination object.  */\n+  /* The size of the destination object returned by __builtin_object_size.  */\n   tree objsize = NULL_TREE;\n   /* The string that is being concatenated with (as in __strcat_chk)\n      or null if it isn't.  */\n@@ -11247,6 +11439,9 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n   tree maxread = NULL_TREE;\n   /* The exact size of the access (such as in __strncpy_chk).  */\n   tree size = NULL_TREE;\n+  /* The access by the function that's checked.  Except for snprintf\n+     both writing and reading is checked.  */\n+  access_mode mode = access_read_write;\n \n   switch (fcode)\n     {\n@@ -11282,6 +11477,8 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n     case BUILT_IN_VSNPRINTF_CHK:\n       maxread = CALL_EXPR_ARG (exp, 1);\n       objsize = CALL_EXPR_ARG (exp, 3);\n+      /* The only checked access the write to the destination.  */\n+      mode = access_write_only;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -11296,10 +11493,7 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n       return;\n     }\n \n-  /* The destination argument is the first one for all built-ins above.  */\n-  tree dst = CALL_EXPR_ARG (exp, 0);\n-\n-  check_access (exp, dst, srcstr, size, maxread, srcstr, objsize);\n+  check_access (exp, size, maxread, srcstr, objsize, mode);\n }\n \n /* Emit warning if a buffer overflow is detected at compile time\n@@ -11356,8 +11550,8 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n   /* Add one for the terminating nul.  */\n   len = fold_build2 (PLUS_EXPR, TREE_TYPE (len), len, size_one_node);\n \n-  check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, /*size=*/NULL_TREE,\n-\t\t/*maxread=*/NULL_TREE, len, size);\n+  check_access (exp, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE, len, size,\n+\t\taccess_write_only);\n }\n \n /* Emit warning if a free is called with address of a variable.  */"}, {"sha": "94ff96b1292258b131b74eabdfc9d3cc3ef14e97", "filename": "gcc/builtins.h", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -153,38 +153,56 @@ extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);\n \n extern bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n-extern void warn_string_no_nul (location_t, const char *, tree, tree);\n+extern void warn_string_no_nul (location_t, tree, const char *, tree,\n+\t\t\t\ttree, tree = NULL_TREE, bool = false,\n+\t\t\t\tconst wide_int[2] = NULL);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);\n \n /* Describes a reference to an object used in an access.  */\n struct access_ref\n {\n-  access_ref (): ref ()\n-  {\n-    /* Set to valid.  */\n-    offrng[0] = offrng[1] = 0;\n-    /* Invalidate.   */\n-    sizrng[0] = sizrng[1] = -1;\n-  }\n-\n-  /* Reference to the object.  */\n+  /* Set the bounds of the reference to at most as many bytes\n+     as the first argument or unknown when null, and at least\n+     one when the second argument is true unless the first one\n+     is a constant zero.  */\n+  access_ref (tree = NULL_TREE, bool = false);\n+\n+  /* Reference to the accessed object(s).  */\n   tree ref;\n \n-  /* Range of offsets into and sizes of the object(s).  */\n+  /* Range of byte offsets into and sizes of the object(s).  */\n   offset_int offrng[2];\n   offset_int sizrng[2];\n+  /* Range of the bound of the access: denotes that the access\n+     is at least BNDRNG[0] bytes but no more than BNDRNG[1].\n+     For string functions the size of the actual access is\n+     further constrained by the length of the string.  */\n+  offset_int bndrng[2];\n };\n \n /* Describes a pair of references used in an access by built-in\n    functions like memcpy.  */\n struct access_data\n {\n+  /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n+     at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n+  access_data (tree expr, access_mode mode,\n+\t       tree maxwrite = NULL_TREE, bool minwrite = false,\n+\t       tree maxread = NULL_TREE, bool minread = false)\n+    : call (expr),\n+      dst (maxwrite, minwrite), src (maxread, minread), mode (mode) { }\n+\n+  /* Built-in function call.  */\n+  tree call;\n   /* Destination and source of the access.  */\n   access_ref dst, src;\n+  /* Read-only for functions like memcmp or strlen, write-only\n+     for memset, read-write for memcpy or strcat.  */\n+  access_mode mode;\n };\n \n-extern bool check_access (tree, tree, tree, tree, tree, tree, tree,\n-\t\t\t  bool = true, const access_data * = NULL);\n+extern bool check_access (tree, tree, tree, tree, tree,\n+\t\t\t  access_mode, const access_data * = NULL);\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "c1d8fd336e88136fbf09164289a47cb62dd1dea5", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -823,6 +823,10 @@ C ObjC C++ LTO ObjC++ Joined RejectNegative UInteger Var(warn_stringop_overflow)\n Under the control of Object Size type, warn about buffer overflow in string\n manipulation functions like memcpy and strcpy.\n \n+Wstringop-overread\n+C ObjC C++ LTO ObjC++ Var(warn_stringop_overread) Init(1) Warning LangEnabledBy(C ObjC C++ LTO ObjC++, Wall)\n+Warn about reading past the end of a source array in string manipulation functions like memchr and memcpy.\n+\n Wstringop-truncation\n C ObjC C++ LTO ObjC++ Var(warn_stringop_truncation) Warning Init (1) LangEnabledBy(C ObjC C++ LTO ObjC++, Wall)\n Warn about truncation in string manipulation functions like strncat and strncpy."}, {"sha": "8ac94db68176f6dd2d00a59432b972c02460419b", "filename": "gcc/calls.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1274,7 +1274,7 @@ get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n   if (range_type == VR_VARYING)\n     {\n       if (integral)\n-\t{\n+\t{\t\n \t  /* Use the full range of the type of the expression when\n \t     no value range information is available.  */\n \t  range[0] = TYPE_MIN_VALUE (exptype);\n@@ -1559,22 +1559,23 @@ get_attr_nonstring_decl (tree expr, tree *ref)\n   return NULL_TREE;\n }\n \n-/* Warn about passing a non-string array/pointer to a function that\n-   expects a nul-terminated string argument.  */\n+/* Warn about passing a non-string array/pointer to a built-in function\n+   that expects a nul-terminated string argument.  Returns true if\n+   a warning has been issued.*/\n \n-void\n+bool\n maybe_warn_nonstring_arg (tree fndecl, tree exp)\n {\n   if (!fndecl || !fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n-    return;\n+    return false;\n \n-  if (TREE_NO_WARNING (exp) || !warn_stringop_overflow)\n-    return;\n+  if (TREE_NO_WARNING (exp) || !warn_stringop_overread)\n+    return false;\n \n   /* Avoid clearly invalid calls (more checking done below).  */\n   unsigned nargs = call_expr_nargs (exp);\n   if (!nargs)\n-    return;\n+    return false;\n \n   /* The bound argument to a bounded string function like strncpy.  */\n   tree bound = NULL_TREE;\n@@ -1666,22 +1667,27 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \n   if (bndrng[0])\n     {\n-      /* Diagnose excessive bound prior the adjustment below and\n+      /* Diagnose excessive bound prior to the adjustment below and\n \t regardless of attribute nonstring.  */\n       tree maxobjsize = max_object_size ();\n       if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n \t{\n+\t  bool warned = false;\n \t  if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n-\t    warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\"%K%qD specified bound %E \"\n-\t\t\t\"exceeds maximum object size %E\",\n-\t\t\texp, fndecl, bndrng[0], maxobjsize);\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%K%qD specified bound %E \"\n+\t\t\t\t \"exceeds maximum object size %E\",\n+\t\t\t\t exp, fndecl, bndrng[0], maxobjsize);\n \t  else\n-\t    warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\"%K%qD specified bound [%E, %E] \"\n-\t\t\t\"exceeds maximum object size %E\",\n-\t\t\texp, fndecl, bndrng[0], bndrng[1], maxobjsize);\n-\t  return;\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%K%qD specified bound [%E, %E] \"\n+\t\t\t\t \"exceeds maximum object size %E\",\n+\t\t\t\t exp, fndecl, bndrng[0], bndrng[1],\n+\t\t\t\t maxobjsize);\n+\t  if (warned)\n+\t    TREE_NO_WARNING (exp) = true;\n+\n+\t  return warned;\n \t}\n     }\n \n@@ -1710,6 +1716,7 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t}\n     }\n \n+  bool any_arg_warned = false;\n   /* Iterate over the built-in function's formal arguments and check\n      each const char* against the actual argument.  If the actual\n      argument is declared attribute non-string issue a warning unless\n@@ -1820,19 +1827,19 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n       if (wi::ltu_p (asize, wibnd))\n \t{\n \t  if (bndrng[0] == bndrng[1])\n-\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t \"%qD argument %i declared attribute \"\n \t\t\t\t \"%<nonstring%> is smaller than the specified \"\n \t\t\t\t \"bound %wu\",\n \t\t\t\t fndecl, argno + 1, wibnd.to_uhwi ());\n \t  else if (wi::ltu_p (asize, wi::to_offset (bndrng[0])))\n-\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t \"%qD argument %i declared attribute \"\n \t\t\t\t \"%<nonstring%> is smaller than \"\n \t\t\t\t \"the specified bound [%E, %E]\",\n \t\t\t\t fndecl, argno + 1, bndrng[0], bndrng[1]);\n \t  else\n-\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t \"%qD argument %i declared attribute \"\n \t\t\t\t \"%<nonstring%> may be smaller than \"\n \t\t\t\t \"the specified bound [%E, %E]\",\n@@ -1842,14 +1849,22 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t; /* Avoid warning for calls to strncat() when the bound\n \t     is equal to the size of the non-string argument.  */\n       else if (!bound)\n-\twarned = warning_at (loc, OPT_Wstringop_overflow_,\n+\twarned = warning_at (loc, OPT_Wstringop_overread,\n \t\t\t     \"%qD argument %i declared attribute %<nonstring%>\",\n \t\t\t     fndecl, argno + 1);\n \n       if (warned)\n-\tinform (DECL_SOURCE_LOCATION (decl),\n-\t\t\"argument %qD declared here\", decl);\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"argument %qD declared here\", decl);\n+\t  any_arg_warned = true;\n+\t}\n     }\n+\n+  if (any_arg_warned)\n+    TREE_NO_WARNING (exp) = true;\n+\n+  return any_arg_warned;\n }\n \n /* Issue an error if CALL_EXPR was flagged as requiring\n@@ -1896,11 +1911,11 @@ append_attrname (const std::pair<int, attr_access> &access,\n   size_t len = strlen (attrstr);\n \n   const char* const atname\n-    = (access.second.mode == attr_access::read_only\n+    = (access.second.mode == access_read_only\n        ? \"read_only\"\n-       : (access.second.mode == attr_access::write_only\n+       : (access.second.mode == access_write_only\n \t  ? \"write_only\"\n-\t  : (access.second.mode == attr_access::read_write\n+\t  : (access.second.mode == access_read_write\n \t     ? \"read_write\" : \"none\")));\n \n   const char *sep = len ? \", \" : \"\";\n@@ -2045,7 +2060,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n       tree objsize = compute_objsize (ptr, 0);\n \n       tree srcsize;\n-      if (access.second.mode == attr_access::write_only)\n+      if (access.second.mode == access_write_only)\n \t{\n \t  /* For a write-only argument there is no source.  */\n \t  srcsize = NULL_TREE;\n@@ -2055,8 +2070,8 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t  /* For read-only and read-write attributes also set the source\n \t     size.  */\n \t  srcsize = objsize;\n-\t  if (access.second.mode == attr_access::read_only\n-\t      || access.second.mode == attr_access::none)\n+\t  if (access.second.mode == access_read_only\n+\t      || access.second.mode == access_none)\n \t    {\n \t      /* For a read-only attribute there is no destination so\n \t\t clear OBJSIZE.  This emits \"reading N bytes\" kind of\n@@ -2070,8 +2085,8 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t iteration so that accesses via different arguments are\n \t diagnosed.  */\n       TREE_NO_WARNING (exp) = false;\n-      check_access (exp, NULL_TREE, NULL_TREE, size, /*maxread=*/ NULL_TREE,\n-\t\t    srcsize, objsize, access.second.mode != attr_access::none);\n+      check_access (exp, size, /*maxread=*/ NULL_TREE, srcsize, objsize,\n+\t\t    access.second.mode);\n \n       if (TREE_NO_WARNING (exp))\n \t/* If check_access issued a warning above, append the relevant"}, {"sha": "dfb951ca45b94e2545463fefead41db673e4596c", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -132,7 +132,7 @@ extern bool reference_callee_copied (CUMULATIVE_ARGS *,\n \t\t\t\t     const function_arg_info &);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n-extern void maybe_warn_nonstring_arg (tree, tree);\n+extern bool maybe_warn_nonstring_arg (tree, tree);\n extern bool get_size_range (tree, tree[2], bool = false);\n extern rtx rtx_for_static_chain (const_tree, bool);\n extern bool cxx17_empty_base_field_p (const_tree);"}, {"sha": "5d29a7fa23c07250a664a0dfd4ac56b8dca68df1", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -366,7 +366,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wstack-protector  -Wstack-usage=@var{byte-size}  -Wstrict-aliasing @gol\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n -Wstring-compare @gol\n--Wstringop-overflow=@var{n}  -Wno-stringop-truncation @gol\n+-Wno-stringop-overflow -Wno-stringop-overread @gol\n+-Wno-stringop-truncation @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n -Wswitch  -Wno-switch-bool  -Wswitch-default  -Wswitch-enum @gol\n -Wno-switch-outside-range  -Wno-switch-unreachable  -Wsync-nand @gol\n@@ -6754,6 +6755,7 @@ void f (char *d)\n \n @option{-Wstring-compare} is enabled by @option{-Wextra}.\n \n+@item -Wno-stringop-overflow\n @item -Wstringop-overflow\n @itemx -Wstringop-overflow=@var{type}\n @opindex Wstringop-overflow\n@@ -6795,6 +6797,15 @@ const char* f (enum Color clr)\n \n Option @option{-Wstringop-overflow=2} is enabled by default.\n \n+@item -Wno-stringop-overread\n+@opindex Wstringop-overread\n+@opindex Wno-stringop-overread\n+Warn for calls to string manipulation functions such as @code{memchr},\n+@code{strcpy} that are determined to read past the end of the source\n+sequence. \n+\n+Option @option{-Wstringop-overread} is enabled by default.\n+\n @table @gcctabopt\n @item -Wstringop-overflow\n @itemx -Wstringop-overflow=1\n@@ -7502,8 +7513,12 @@ This warning is also enabled by @option{-Wshadow=local}.\n Warn whenever an object is defined whose size exceeds @var{byte-size}.\n @option{-Wlarger-than=}@samp{PTRDIFF_MAX} is enabled by default.\n Warnings controlled by the option can be disabled either by specifying\n-@var{byte-size} of @samp{SIZE_MAX} or more or by\n-@option{-Wno-larger-than}.\n+@var{byte-size} of @samp{SIZE_MAX} or more or by @option{-Wno-larger-than}.\n+\n+Also warn for calls to bounded functions such as @code{memchr} or\n+@code{strnlen} that specify a bound greater than the largest possible\n+object, which is @samp{PTRDIFF_MAX} bytes by default.  These warnings\n+can only be disabled by @option{-Wno-larger-than}.\n \n @item -Wno-larger-than\n @opindex Wno-larger-than"}, {"sha": "c3fa4cb7cc1b9097b521964604387392910b1139", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1875,7 +1875,7 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n       if (!gimple_no_warning_p (stmt))\n-\twarn_string_no_nul (loc, \"strcpy\", src, nonstr);\n+\twarn_string_no_nul (loc, NULL_TREE, \"strcpy\", src, nonstr);\n       gimple_set_no_warning (stmt, true);\n       return false;\n     }\n@@ -3074,11 +3074,16 @@ gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n \n   /* Set to non-null if ARG refers to an unterminated array.  */\n   c_strlen_data data = { };\n+  /* The size of the unterminated array if SRC referes to one.  */\n+  tree size;\n+  /* True if the size is exact/constant, false if it's the lower bound\n+     of a range.  */\n+  bool exact;\n   tree len = c_strlen (src, 1, &data, 1);\n   if (!len\n       || TREE_CODE (len) != INTEGER_CST)\n     {\n-      data.decl = unterminated_array (src);\n+      data.decl = unterminated_array (src, &size, &exact);\n       if (!data.decl)\n \treturn false;\n     }\n@@ -3087,7 +3092,8 @@ gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n       if (!gimple_no_warning_p (stmt))\n-\twarn_string_no_nul (loc, \"stpcpy\", src, data.decl);\n+\twarn_string_no_nul (loc, NULL_TREE, \"stpcpy\", src, data.decl, size,\n+\t\t\t    exact);\n       gimple_set_no_warning (stmt, true);\n       return false;\n     }"}, {"sha": "131645406dd42ff7039dc2703c83cda1bbfacadf", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-7.c", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -29,79 +29,78 @@ void sink (unsigned);\n \n void test_zero_length_array (void)\n {\n-  T (a0.a);                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a);                   // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a0.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (a0_0.a);                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   T (a0_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a0_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (a0_0_.a);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   T (a0_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a0_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a0_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a0_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n void test_one_element_array (void)\n {\n   T (a1.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a1.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (a1_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a1_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (a1_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (a1_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (a1_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (a1_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n void test_flexible_array_member (void)\n {\n   T (ax.a);                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   T (ax.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (ax.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (ax_0.a);                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   T (ax_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (ax_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   T (ax_0_.a);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   T (ax_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  T (ax_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  T (ax_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n   T (ax_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n-"}, {"sha": "3b019c8a80ebfd5b3a1ed654c30a185bb6317de0", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -637,9 +637,7 @@ void test_strcpy_cst (ptrdiff_t i)\n   T (\"012\", a, a + 1);            /* { dg-warning \"accessing 3 bytes at offsets 0 and 1 overlaps 2 bytes at offset 1\" \"strcpy\" } */\n   T (\"012\", a, a + 2);\n   T (\"012\", a, a + 3);\n-  /* The following doesn't overlap but it should trigger -Wstringop-overflow\n-     for reading past the end.  */\n-  T (\"012\", a, a + sizeof a);     /* { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr81437\" { xfail *-*-* } } */\n+  T (\"012\", a, a + sizeof a);     /* { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr81437\" } */\n \n   /* The terminating nul written to d[2] overwrites s[0].  */\n   T (\"0123\", a, a + 2);           /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" } */"}, {"sha": "e3ceabd0836a977820d69130685313ae63ef69bb", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -379,9 +379,9 @@ void test_stnrdup_warn (struct MemArrays *p)\n   T (strndup (p->arr, N));\n \n \n-  T (strndup (arr, N + 1));     /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (strndup (arr, N + 1));     /* { dg-warning \"specified bound 5 exceeds source size 4\" } */\n   T (strndup (parr, N + 1));\n-  T (strndup (p->arr, N + 1));  /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (strndup (p->arr, N + 1));  /* { dg-warning \"specified bound 5 exceeds source size 4\" } */\n   T (strndup (p->parr, N + 1));\n }\n "}, {"sha": "4b804b3f10751f3d640a72f361c3a2ab5e015c98", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-6.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,7 +1,7 @@\n /* PR 85623 - strncmp() warns about attribute 'nonstring' incorrectly\n    in -Wstringop-overflow\n   { dg-do compile }\n-  { dg-options \"-O2 -Wstringop-overflow -ftrack-macro-expansion=0\" } */\n+  { dg-options \"-O2 -Wstringop-overread -ftrack-macro-expansion=0\" } */\n \n #include \"../gcc.dg/range.h\"\n \n@@ -41,15 +41,15 @@ void test_strcmp_cst (void)\n   T (strcmp (S (1), a3));\n   T (strcmp (S (2), a3));\n   /* The following reads a3[3].  */\n-  T (strcmp (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n   /* The following also reads past the end of a3.  */\n-  T (strcmp (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strcmp (a3, S (0)));\n   T (strcmp (a3, S (1)));\n   T (strcmp (a3, S (2)));\n-  T (strcmp (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcmp (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcmp (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n \n@@ -62,16 +62,16 @@ void test_strcmp_range (const char *s)\n   T (strcmp (a3, s));\n \n   s = signed_value () < 0 ? S (0) : S (3);\n-  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   s = signed_value () < 0 ? S (1) : S (2);\n   T (strcmp (a3, s));\n \n   s = signed_value () < 0 ? S (1) : S (3);\n-  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   s = signed_value () < 0 ? S (3) : S (4);\n-  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n \n@@ -81,21 +81,21 @@ void test_strncmp_cst (void)\n   T (strncmp (S (1), a3, 2));\n   T (strncmp (S (2), a3, 3));\n   T (strncmp (S (3), a3, 3));\n-  T (strncmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncmp (S (9), a3, 3));\n-  T (strncmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strncmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strncmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncmp (a3, S (0), 1));\n   T (strncmp (a3, S (1), 2));\n   T (strncmp (a3, S (2), 3));\n   T (strncmp (a3, S (3), 3));\n-  T (strncmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncmp (a3, S (9), 3));\n-  T (strncmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strncmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strncmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n void test_strncmp_range (const char *s)\n@@ -110,8 +110,8 @@ void test_strncmp_range (const char *s)\n   T (strncmp (a3, S (5), UR (1, 4)));\n   T (strncmp (a3, S (5), UR (2, 5)));\n   T (strncmp (a3, S (5), UR (3, 6)));\n-  T (strncmp (a3, S (5), UR (4, 7)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strncmp (a3, S (5), UR (7, 9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, S (5), UR (4, 7)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strncmp (a3, S (5), UR (7, 9)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   s = signed_value () < 0 ? S (0) : S (1);\n   T (strncmp (a3, s, UR (1, 3)));\n@@ -124,7 +124,7 @@ void test_strncmp_range (const char *s)\n   T (strncmp (a3, s, UR (1, 4)));\n   T (strncmp (a3, s, UR (2, 5)));\n   T (strncmp (a3, s, UR (3, 6)));\n-  T (strncmp (a3, s, UR (4, 7)));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, s, UR (4, 7)));       /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n void test_strncasecmp (void)\n@@ -133,53 +133,53 @@ void test_strncasecmp (void)\n   T (strncasecmp (S (1), a3, 2));\n   T (strncasecmp (S (2), a3, 3));\n   T (strncasecmp (S (3), a3, 3));\n-  T (strncasecmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncasecmp (S (9), a3, 3));\n-  T (strncasecmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strncasecmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strncasecmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncasecmp (a3, S (0), 1));\n   T (strncasecmp (a3, S (1), 2));\n   T (strncasecmp (a3, S (2), 3));\n   T (strncasecmp (a3, S (3), 3));\n-  T (strncasecmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   T (strncasecmp (a3, S (9), 3));\n-  T (strncasecmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strncasecmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strncasecmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n void test_strspn (void)\n {\n   /* strspn must traverse all characters in the second argument except\n      when the first string is empty. */\n   T (strspn (S (0), a3));\n-  T (strspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n \n   /* Similarly, strspn must traverse all characters in the first argument\n      except when the second string is empty. */\n   T (strspn (a3, S (0)));\n-  T (strspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }\n \n void test_strcspn (void)\n {\n   T (strcspn (S (0), a3));\n-  T (strcspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-\n-  T (strcspn (a3, S (0)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n-  T (strcspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+\n+  T (strcspn (a3, S (0)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n+  T (strcspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overread\" } */\n }"}, {"sha": "9ad33425b27a22e09fb74220731cad150fbc18eb", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -85,7 +85,7 @@ void test_strncat_nonstring_var (char *d, size_t n)\n   T (strncat (nd3, ns5, UR (1, 2)));\n   T (strncat (nd3, ns5, UR (2, 3)));\n   T (strncat (nd3, ns5, UR (3, 4)));\n-  T (strncat (nd3, ns5, UR (4, 5)));  /* { dg-warning \"specified bound between 4 and 5 exceeds destination size 3\" } */\n+  T (strncat (nd3, ns5, UR (4, 5)));  /* { dg-warning \"specified bound \\\\\\[4, 5] exceeds destination size 3\" } */\n \n   T (strncat (nd5, ns3, UR (0, 1)));\n   T (strncat (nd5, ns3, UR (1, 2)));"}, {"sha": "d283cbfd596794f5be2aa4532ac733496706856a", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n+// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-overread -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }"}, {"sha": "fe24cddfeaa5f7146ae53769a2b2a9f8585c937b", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n+// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-overread -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified,\n // suppressing buffer overflow warnings.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }"}, {"sha": "83176564bc3541512bc55ef2a4bb5a63c2b6bd36", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-39.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -21,65 +21,65 @@ char d[4];\n \n void* test_memcpy_s0_1 (void *d)\n {\n-  return memcpy (d, s0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_s0_2 (void *d)\n {\n-  return memcpy (d, s0, 2);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0, 2);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_s0_0_1 (void *d)\n {\n-  return memcpy (d, s0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_s0_0_2 (void *d)\n {\n-  return memcpy (d, s0_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n void* test_memcpy_s0_1_1 (void *d)\n {\n-  return memcpy (d, s0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_s0_1_2 (void *d)\n {\n-  return memcpy (d, s0_1, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s0_1, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n void* test_memcpy_s1_0_1 (void *d)\n {\n-  return memcpy (d, s1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_s1_0_2 (void *d)\n {\n-  return memcpy (d, s1_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, s1_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n void* test_memmove_s0_1 (void *d)\n {\n-  return memmove (d, s0, 1);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memmove (d, s0, 1);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memmove_s0_2 (void *d)\n {\n-  return memmove (d, s0, 2);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memmove (d, s0, 2);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memmove_s0_0_1 (void *d)\n {\n-  return memmove (d, s0_0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memmove (d, s0_0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memmove_s0_0_2 (void *d)\n {\n-  return memmove (d, s0_0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memmove (d, s0_0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n@@ -92,57 +92,57 @@ const struct Empty e1_0[1][0] = { };\n \n void* test_memcpy_e_1 (void *d)\n {\n-  return memcpy (d, &e, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, &e, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_e0_1 (void *d)\n {\n-  return memcpy (d, e0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, e0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_e0_0_1 (void *d)\n {\n-  return memcpy (d, e0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, e0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_e0_1_1 (void *d)\n {\n-  return memcpy (d, e0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, e0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n void* test_memcpy_e1_0_1 (void *d)\n {\n-  return memcpy (d, e1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return memcpy (d, e1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n char* test_strcpy_s0 (char *d)\n {\n-  return strcpy (d, s0);          /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strcpy (d, s0);          /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n char* test_strcpy_s0_0 (char *d)\n {\n-  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n char* test_strncpy_s0_1 (char *d)\n {\n-  return strncpy (d, s0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strncpy (d, s0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n char* test_strncpy_s0_2 (char *d)\n {\n-  return strncpy (d, s0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strncpy (d, s0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n char* test_strncpy_s0_0_1 (char *d)\n {\n-  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n char* test_strncpy_s0_0_2 (char *d)\n {\n-  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n+  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }"}, {"sha": "c389d96a98b02ba30bf24b6e52d81d4f4f0f2dd0", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-40.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-40.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -3,7 +3,7 @@\n    functions when -Wstringop-overflow is disabled is -Warray-bounds\n    with the right wording.\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wno-stringop-overflow\" } */\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow -Wno-stringop-overread\" } */\n \n #define PTRDIFF_MAX   __PTRDIFF_MAX__\n #define SIZE_MAX      __SIZE_MAX__"}, {"sha": "7c469e2aefc6a454d714b255fa5204a7fe0ceca9", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-58.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -15,8 +15,8 @@ void fa0_extern (void)\n {\n   sink (strlen (ea0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ea0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ea0.a));        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ea0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ea0.a));        // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ea0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }\n \n static struct A0 sa0 = { 0 };\n@@ -25,8 +25,8 @@ void fa0_static (void)\n {\n   sink (strlen (sa0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (sa0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (sa0.a));        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (sa0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (sa0.a));        // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (sa0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }\n \n \n@@ -52,30 +52,30 @@ void fax_static (void)\n   sink (strlen (ax0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax0.a));\n-  sink (strlen (ax0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ax0.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax0.a + 1));    // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax0.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax1.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax1.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax1.a));\n   sink (strlen (ax1.a + 1));\n-  sink (strlen (ax1.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ax1.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax1.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax1.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax2.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax2.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax2.a));\n   sink (strlen (ax2.a + 1));\n   sink (strlen (ax2.a + 2));\n-  sink (strlen (ax2.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ax2.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax2.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax2.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax3.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax3.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax3.a));\n   sink (strlen (ax3.a + 1));\n   sink (strlen (ax3.a + 2));\n   sink (strlen (ax3.a + 3));\n-  sink (strlen (ax3.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ax3.a + 5));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (strlen (ax3.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax3.a + 5));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }"}, {"sha": "5aea89a08791a30b90b2d73175af1720e73aa92e", "filename": "gcc/testsuite/gcc.dg/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-overread\" } */\n /* { dg-require-effective-target alloca } */\n \n typedef __SIZE_TYPE__ size_t;"}, {"sha": "8eaaa71327573741b3e41958ca81ab591ffaa851", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-22.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -48,11 +48,18 @@ T (rindex, b + 4, '4');     // { dg-warning \"missing terminating nul\" \"rindex\" }\n T (stpcpy, d, a);           // { dg-warning \"missing terminating nul\" \"stpcpy\" }\n \n T (stpncpy, d, a, 4);\n-T (stpncpy, d, a, 5);       // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+T (stpncpy, d, a, 5);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"stpncpy\" }\n T (stpncpy, d, a, n);\n \n-T (stpncpy, d, a + n, 4);\n-T (stpncpy, d, a + n, 5);   // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+/* When the offset into an unterminated array isn't known and the bound\n+   is less than the size of the array it suggests the access may be\n+   constrained just right.  When the bound is exactly equal to the size\n+   of the array, then the offset would have to be zero for the access to\n+   be safe, so a warning is justified.  Otherwise, the bound is too small\n+   and the access is definitely unsafe.  */\n+T (stpncpy, d, a + n, 3);\n+T (stpncpy, d, a + n, 4);   // { dg-warning \"specified bound 4 may exceed the size of at most 4 of unterminated array\" \"stpncpy\" }\n+T (stpncpy, d, a + n, 5);   // { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" \"stpncpy\" }\n \n T (stpncpy, d, b, 4);\n T (stpncpy, d, b, 5);\n@@ -67,7 +74,7 @@ T (stpncpy, d, b + 3, 5);\n T (stpncpy, d, b + 3, n);\n \n T (stpncpy, d, b + 4, 1);\n-T (stpncpy, d, b + 4, 2);   // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+T (stpncpy, d, b + 4, 2);   // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"stpncpy\" }\n T (stpncpy, d, b + 4, n);\n /* The following might be worth warning about since it's only safe with\n    n < 4.  */\n@@ -84,7 +91,7 @@ T (strcasecmp, b, b + 4);   // { dg-warning \"missing terminating nul\" \"strcasecm\n T (strcat, d, a);           // { dg-warning \"missing terminating nul\" \"strcat\" }\n \n T (strncat, d, a, 4);\n-T (strncat, d, a, 5);       // { dg-warning \"missing terminating nul\" \"strncat\" }\n+T (strncat, d, a, 5);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strncat\" }\n T (strncat, d, a, n);\n \n T (strncat, d, b, n);\n@@ -93,7 +100,7 @@ T (strncat, d, b + 2, n);\n T (strncat, d, b + 3, n);\n T (strncat, d, b + 4, 0);\n T (strncat, d, b + 4, 1);\n-T (strncat, d, b + 4, 2);   // { dg-warning \"missing terminating nul\" \"strncat\" }\n+T (strncat, d, b + 4, 2);   // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"strncat\" }\n /* The following should probably trigger a warning since it's only safe\n    when n < 2, makes little sense with n == 0, and not much more with\n    n == 1.  */\n@@ -122,8 +129,8 @@ T (strncmp, s, a, 4);\n /* The warning below is not issued because GCC folds strncmp calls with\n    the same arguments to zero before it checks for the missing nul.  */\n T (strncmp, a, a, 5);       // { dg-warning \"missing terminating nul\" \"pr92624\" { xfail *-*-*} }\n-T (strncmp, a, s, 5);       // { dg-warning \"missing terminating nul\" \"strcmp\" }\n-T (strncmp, s, a, 5);       // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+T (strncmp, a, s, 5);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strcmp\" }\n+T (strncmp, s, a, 5);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strcmp\" }\n \n T (strcpy, d, a);           // { dg-warning \"missing terminating nul\" \"strcpy\" }\n \n@@ -136,10 +143,10 @@ T (strspn, s, a);           // { dg-warning \"missing terminating nul\" \"strcspn\"\n T (strdup, a);              // { dg-warning \"missing terminating nul\" \"strdup\" }\n \n T (strndup, a, 4);\n-T (strndup, a, 5);          // { dg-warning \"missing terminating nul\" \"strndup\" }\n+T (strndup, a, 5);          // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strndup\" }\n T (strndup, b + 3, 2);\n T (strndup, b + 4, 1);\n-T (strndup, b + 4, 2);      // { dg-warning \"missing terminating nul\" \"strndup\" }\n+T (strndup, b + 4, 2);      // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"strndup\" }\n \n T (strlen, a);              // { dg-warning \"missing terminating nul\" \"strlen\" }\n \n@@ -161,11 +168,12 @@ T (__stpcpy_chk, d, a, -1);           // { dg-warning \"missing terminating nul\"\n \n \n T (__stpncpy_chk, d, a, 4, -1);\n-T (__stpncpy_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, a, 5, -1);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"stpncpy_chk\" }\n T (__stpncpy_chk, d, a, n, -1);\n \n-T (__stpncpy_chk, d, a + n, 4, -1);\n-T (__stpncpy_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, a + n, 3, -1);\n+T (__stpncpy_chk, d, a + n, 4, -1);   // { dg-warning \"specified bound 4 may exceed the size of at most 4 of unterminated array\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, a + n, 5, -1);   // { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" \"stpncpy_chk\" }\n \n T (__stpncpy_chk, d, b, 4, -1);\n T (__stpncpy_chk, d, b, 5, -1);\n@@ -180,16 +188,17 @@ T (__stpncpy_chk, d, b + 3, 5, -1);\n T (__stpncpy_chk, d, b + 3, n, -1);\n \n T (__stpncpy_chk, d, b + 4, 1, -1);\n-T (__stpncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"stpncpy_chk\" }\n T (__stpncpy_chk, d, b + 4, n, -1);\n \n \n T (__strncat_chk, d, a, 4, -1);\n-T (__strncat_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+T (__strncat_chk, d, a, 5, -1);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strncat_chk\" }\n T (__strncat_chk, d, a, n, -1);\n \n-T (__strncat_chk, d, a + n, 4, -1);\n-T (__strncat_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+T (__strncat_chk, d, a + n, 3, -1);\n+T (__strncat_chk, d, a + n, 4, -1);   // { dg-warning \"specified bound 4 may exceed the size of at most 4 of unterminated array\" \"strncat_chk\" }\n+T (__strncat_chk, d, a + n, 5, -1);   // { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" \"strncat_chk\" }\n \n T (__strncat_chk, d, b, 4, -1);\n T (__strncat_chk, d, b, 5, -1);\n@@ -204,16 +213,17 @@ T (__strncat_chk, d, b + 3, 5, -1);\n T (__strncat_chk, d, b + 3, n, -1);\n \n T (__strncat_chk, d, b + 4, 1, -1);\n-T (__strncat_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+T (__strncat_chk, d, b + 4, 2, -1);   // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"strncat_chk\" }\n T (__strncat_chk, d, b + 4, n, -1);\n \n \n T (__strncpy_chk, d, a, 4, -1);\n-T (__strncpy_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"strncpy_chk\" }\n+T (__strncpy_chk, d, a, 5, -1);       // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strncpy_chk\" }\n T (__strncpy_chk, d, a, n, -1);\n \n-T (__strncpy_chk, d, a + n, 4, -1);\n-T (__strncpy_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"strncpy_chk\" }\n+T (__strncpy_chk, d, a + n, 3, -1);\n+T (__strncpy_chk, d, a + n, 4, -1);   // { dg-warning \"specified bound 4 may exceed the size of at most 4 of unterminated array\" \"strncpy_chk\" }\n+T (__strncpy_chk, d, a + n, 5, -1);   // { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" \"strncpy_chk\" }\n \n T (__strncpy_chk, d, b, 4, -1);\n T (__strncpy_chk, d, b, 5, -1);\n@@ -228,7 +238,7 @@ T (__strncpy_chk, d, b + 3, 5, -1);\n T (__strncpy_chk, d, b + 3, n, -1);\n \n T (__strncpy_chk, d, b + 4, 1, -1);\n-T (__strncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"strncpy\" }\n+T (__strncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"specified bound 2 exceeds the size 1 of unterminated array\" \"strncpy\" }\n T (__strncpy_chk, d, b + 4, n, -1);\n \n "}, {"sha": "d4f7956c42db7f706b871fe5c381e9ad974b2e6c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-33.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -7,7 +7,7 @@ void fcst (char *d)\n {\n   char a[2] = \"0\";\n \n-  __builtin_strcpy (d, a + 3);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+  __builtin_strcpy (d, a + 3);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overread)\" }\n }\n \n void frng (char *d, int i)\n@@ -17,14 +17,14 @@ void frng (char *d, int i)\n   if (i < 3)\n     i = 3;\n \n-  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overread)\" }\n }\n \n void gcst (char *d)\n {\n   char a[2] = \"0\";\n \n-  __builtin_strcpy (d, a + 2);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+  __builtin_strcpy (d, a + 2);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overread)\" }\n }\n \n void grng (char *d, int i)\n@@ -34,7 +34,7 @@ void grng (char *d, int i)\n   if (i < 2)\n     i = 2;\n \n-  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overread)\" }\n }\n \n /* { dg-prune-output \"-Wuninitialized\" } */"}, {"sha": "2df84b2bbd91138a3d262897e25e5172b7ac4ec4", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-9.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -63,10 +63,10 @@ void test_strncpy (void)\n \n char* test_strndup (void)\n {\n-  return strndup (s, SIZE_MAX - 5);   /* { dg-warning \".strndup. specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+ \\\\\\[-Wstringop-overflow=\\\\\\]\" } */\n+  return strndup (s, SIZE_MAX - 5);   /* { dg-warning \".strndup. specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+ \\\\\\[-Wstringop-overread\" } */\n }\n \n size_t test_strnlen (void)\n {\n-  return strnlen (s, SIZE_MAX - 6);   /* { dg-warning \".strnlen. specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+ \\\\\\[-Wstringop-overflow=\\\\\\]\" } */\n+  return strnlen (s, SIZE_MAX - 6);   /* { dg-warning \".strnlen. specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+ \\\\\\[-Wstringop-overread\" } */\n }"}, {"sha": "16dc06d968bf8d1596a5884a993531a77c70b953", "filename": "gcc/testsuite/gcc.dg/Wstringop-overread-2.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-2.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -0,0 +1,117 @@\n+/* Verify -Wstringop-overread is issued for reading more than the maximum\n+   object size but not for writing.\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n+\n+#define PTRDIFF_MAX   __PTRDIFF_MAX__\n+#define SIZE_MAX      __SIZE_MAX__\n+\n+#define NOIPA         __attribute__ ((noipa))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memchr (const void*, int, size_t);\n+int memcmp (const void*, const void*, size_t);\n+void* memcpy (const void*, const void*, size_t);\n+\n+int strncmp (const char*, const char*, size_t);\n+char* strncat (char*, const char*, size_t);\n+char* strncpy (char*, const char*, size_t);\n+size_t strnlen (const char*, size_t);\n+\n+void sink (int, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+#define T(exp)   sink (exp)\n+\n+NOIPA void test_memchr (const void *p, int x)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (memchr (p, x, dmax));\n+\n+  T (memchr (p, x, dmax + 1));     // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (memchr (p, x, dmax * 2));     // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (memchr (p, x, smax));         // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+}\n+\n+\n+NOIPA void test_memcmp (const void *p, const void *q)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (memcmp (p, q, dmax));\n+\n+  T (memcmp (p, q, dmax + 1));     // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (memcmp (p, q, dmax * 2));     // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (memcmp (p, q, smax));         // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+}\n+\n+\n+NOIPA void test_memcpy (void *p, const void *q)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (memcpy (p, q, dmax));\n+\n+  T (memcpy (p, q, dmax + 1));    // -Wstringop-overflow disabled\n+  T (memcpy (p, q, dmax * 2));    // ditto\n+  T (memcpy (p, q, smax));        // ditto\n+}\n+\n+\n+NOIPA void test_strncmp (const char *p, const char *q)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (strncmp (p, q, dmax));\n+\n+  T (strncmp (p, q, dmax + 1));   // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" \"strncmp\" }\n+  T (strncmp (p, q, dmax * 2));   // { dg-warning \"\\\\\\[-Wstringop-overread\" \"strncmp\" }\n+  T (strncmp (p, q, smax));       // { dg-warning \"\\\\\\[-Wstringop-overread\" \"strncmp\" }\n+}\n+\n+NOIPA void test_strncat (char *p, const char *q)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (strncat (p, q, dmax));\n+\n+  T (strncat (p, q, dmax + 1));   // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (strncat (p, q, dmax * 2));   // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+  T (strncat (p, q, smax));       // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+}\n+\n+NOIPA void test_strncpy (char *p, const char *q)\n+{\n+#if 0\n+  /* Disabled: strncpy calls with an excissve bound trigger both\n+     -Wstringop-overflow and, when the former option is disabled,\n+     -Wstringop-overread.  The latter should probably not trigger.  */\n+\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (strncpy (p, q, dmax));\n+\n+  T (strncpy (p, q, dmax + 1));    // -Wstringop-overflow disabled\n+  T (strncpy (p, q, dmax * 2));    // ditto\n+  T (strncpy (p, q, smax));        // ditto\n+#endif\n+}\n+\n+NOIPA void test_strnlen (const char *p)\n+{\n+  size_t dmax = PTRDIFF_MAX;\n+  size_t smax = SIZE_MAX;\n+\n+  T (strnlen (p, dmax));\n+\n+  T (strnlen (p, dmax + 1));      // { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size\" }\n+  T (strnlen (p, dmax * 2));      // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+  T (strnlen (p, smax));          // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+}"}, {"sha": "0343e43cce47e937ca216dc5bf41a9ce0ca45014", "filename": "gcc/testsuite/gcc.dg/Wstringop-overread.c", "status": "added", "additions": 716, "deletions": 0, "changes": 716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -0,0 +1,716 @@\n+/* Verify -Wstringop-overread is issued appropriately.\n+  { dg-do compile }\n+  { dg-options \"-O2 -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+// <libint.h> functions.\n+\n+char* gettext (const char *);\n+\n+// <stdio.h> functions.\n+\n+int puts (const char*);\n+int puts_unlocked (const char*);\n+\n+// <string.h> functions.\n+\n+char* strchr (const char*, int);\n+\n+int strcmp (const char*, const char*);\n+int strncmp (const char*, const char*, size_t);\n+\n+char* strcat (char*, const char*);\n+char* strcpy (char*, const char*);\n+char* strncpy (char*, const char*, size_t);\n+char* strdup (const char*);\n+char* strndup (const char*, size_t);\n+\n+char* strpbrk (char*, const char*);\n+size_t strcspn (const char*, const char*);\n+size_t strspn (const char*, const char*);\n+char* strstr (char*, const char*);\n+\n+size_t strlen (const char*);\n+size_t strnlen (const char*, size_t);\n+\n+\n+void sink (int, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+extern char *d;\n+extern char a0[0];              // { dg-message \"source object 'a0'\" }\n+extern char a1[1];              // { dg-message \"source object 'a1'\" }\n+extern char a2[2];              // { dg-message \"source object 'a2'\" }\n+\n+extern char b1[1];\n+extern char b2[2];\n+extern char bx[];\n+\n+const char s0[0] = { };         // { dg-message \"source object 's0'\" }\n+const char s1[1] = \"\";          // { dg-message \"source object 's1'\" }\n+const char s2[2] = \"1\";         // { dg-message \"source object 's2'\" }\n+\n+#define T(x) sink (0, (x))\n+\n+\n+void test_strcat_array (const char *s, int i, int i0)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strcat (d, a0));           // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, a0 + i));       // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, a0 + i + 1));   // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcat (d, a0 + i0));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcat (d, a1));\n+  T (strcat (d, a1 + 1));       // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, a1 + i));\n+  T (strcat (d, a1 + i + 1));\n+\n+  T (strcat (d, a1 + i0));\n+  T (strcat (d, a1 + i0 + 1));  // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcat (d, a2));\n+  T (strcat (d, a2 + 1));\n+  T (strcat (d, a2 + 2));       // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, a2 + i));\n+  T (strcat (d, a2 + i + 2));\n+\n+  T (strcat (d, a2 + i0));\n+  T (strcat (d, a2 + i0 + 1));\n+  T (strcat (d, a2 + i0 + 2));  // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strcat (a0, s));           // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+  T (strcat (a0 + i, s));       // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+  T (strcat (a0 + i + 1, s));   // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+\n+  T (strcat (a0 + i0, s));      // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+\n+  T (strcat (a1, s));\n+  T (strcat (a1 + 1, s));       // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+  T (strcat (a1 + i, s));\n+  T (strcat (a1 + i + 1, s));\n+\n+  T (strcat (a1 + i0, s));\n+  T (strcat (a1 + i0 + 1, s));  // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+\n+  T (strcat (a2, s));\n+  T (strcat (a2 + 1, s));\n+  T (strcat (a2 + 2, s));       // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+  T (strcat (a2 + i, s));\n+  T (strcat (a2 + i + 2, s));\n+\n+  T (strcat (a2 + i0, s));\n+  T (strcat (a2 + i0 + 1, s));\n+  T (strcat (a2 + i0 + 2, s));  // { dg-warning \"'strcat' writing 1 or more bytes into a region of size 0\" }\n+}\n+\n+void test_strcat_literal (int i)\n+{\n+  T (strcat (d, \"\"));\n+  T (strcat (d, \"\" + 0));\n+  T (strcat (d, \"\" + i));\n+\n+  T (strcat (d, \"1\"));\n+  T (strcat (d, \"1\" + 1));\n+  T (strcat (d, \"1\" + 2));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, \"1\" + i));\n+\n+  T (strcat (d, \"12\"));\n+  T (strcat (d, \"12\" + 1));\n+  T (strcat (d, \"12\" + 2));\n+  T (strcat (d, \"12\" + 3));     // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, \"12\" + i));\n+}\n+\n+void test_strcat_string (int i)\n+{\n+  T (strcat (d, s0));           // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s0 + 1));       // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s0 + i));       // { dg-warning \"'strcat' (reading 1 or more bytes from a region of size 0|argument missing terminating nul)\" }\n+\n+  T (strcat (d, s1));\n+  T (strcat (d, s1 + 1));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s1 + 2));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s1 + i));\n+\n+  T (strcat (d, s2));\n+  T (strcat (d, s2 + 1));\n+  T (strcat (d, s2 + 2));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s2 + 3));      // { dg-warning \"'strcat' reading 1 or more bytes from a region of size 0\" }\n+  T (strcat (d, s2 + i));\n+}\n+\n+\n+void test_strcpy_array (int i, int i0)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strcpy (d, a0));           // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, a0 + i));       // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, a0 + i + 1));   // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcpy (d, a0 + i0));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcpy (d, a1));\n+  T (strcpy (d, a1 + 1));       // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, a1 + i));\n+  T (strcpy (d, a1 + i + 1));\n+\n+  T (strcpy (d, a1 + i0));\n+  T (strcpy (d, a1 + i0 + 1));  // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcpy (d, a2));\n+  T (strcpy (d, a2 + 1));\n+  T (strcpy (d, a2 + 2));       // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, a2 + i));\n+  T (strcpy (d, a2 + i + 2));\n+\n+  T (strcpy (d, a2 + i0));\n+  T (strcpy (d, a2 + i0 + 1));\n+  T (strcpy (d, a2 + i0 + 2));  // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+}\n+\n+void test_strcpy_literal (int i)\n+{\n+  T (strcpy (d, \"\"));\n+  T (strcpy (d, \"\" + 0));\n+  T (strcpy (d, \"\" + i));\n+\n+  T (strcpy (d, \"1\"));\n+  T (strcpy (d, \"1\" + 1));\n+  T (strcpy (d, \"1\" + 2));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, \"1\" + i));\n+\n+  T (strcpy (d, \"12\"));\n+  T (strcpy (d, \"12\" + 1));\n+  T (strcpy (d, \"12\" + 2));\n+  T (strcpy (d, \"12\" + 3));     // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, \"12\" + i));\n+}\n+\n+void test_strcpy_string (int i)\n+{\n+  T (strcpy (d, s0));           // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s0 + 1));       // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s0 + i));       // { dg-warning \"'strcpy' (reading 1 or more bytes from a region of size 0|argument missing terminating nul)\" }\n+\n+  T (strcpy (d, s1));\n+  T (strcpy (d, s1 + 1));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s1 + 2));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s1 + i));\n+\n+  T (strcpy (d, s2));\n+  T (strcpy (d, s2 + 1));\n+  T (strcpy (d, s2 + 2));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s2 + 3));      // { dg-warning \"'strcpy' reading 1 or more bytes from a region of size 0\" }\n+  T (strcpy (d, s2 + i));\n+}\n+\n+\n+void test_strncpy_array (int i)\n+{\n+  T (strncpy (d, a0, 0));\n+  T (strncpy (d, a0, 1));       // { dg-warning \"'strncpy' reading 1 byte from a region of size 0\" }\n+  T (strncpy (d, a0 + i, 0));\n+  T (strncpy (d, a0 + i, 1));   // { dg-warning \"'strncpy' reading 1 byte from a region of size 0\" }\n+\n+  T (strncpy (d, a1, 0));\n+  T (strncpy (d, a1, 1));\n+  T (strncpy (d, a1 + 1, 0));\n+  T (strncpy (d, a1 + 1, 1));   // { dg-warning \"'strncpy' reading 1 byte from a region of size 0\" }\n+  T (strncpy (d, a1 + i, 0));\n+  T (strncpy (d, a1 + i, 1));\n+  T (strncpy (d, a1 + i, 2));\n+}\n+\n+\n+void test_strncpy_literal (int i, int i0)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strncpy (d, \"\", 0));\n+  T (strncpy (d, \"\", 1));\n+  T (strncpy (d, \"\", 2));\n+\n+  T (strncpy (d, \"\" + i, 0));\n+  T (strncpy (d, \"\" + i, 1));\n+  T (strncpy (d, \"\" + i0, 1));\n+  T (strncpy (d, \"\" + i0, 1));\n+\n+  T (strncpy (d, \"\" + 1, 0));\n+  T (strncpy (d, \"\" + 1, 1));   // { dg-warning \"'strncpy' reading 1 byte from a region of size 0\" }\n+\n+  T (strncpy (d, \"1\", 0));\n+  T (strncpy (d, \"1\" + 1, 0));\n+  T (strncpy (d, \"1\" + 1, 1));\n+  T (strncpy (d, \"1\" + 1, 2));\n+  T (strncpy (d, \"1\" + i, 2));\n+\n+  T (strncpy (d, \"1\" + 2, 0));\n+  T (strncpy (d, \"1\" + 2, 1));  // { dg-warning \"'strncpy' reading 1 byte from a region of size 0\" }\n+}\n+\n+\n+void test_strlen_array (int i, int i0)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strlen (a0));              // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+  T (strlen (a0 + i));          // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+  T (strlen (a0 + i + 1));      // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strlen (a0 + i0));         // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strlen (a1));\n+  T (strlen (a1 + 1));          // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+  T (strlen (a1 + i));\n+  T (strlen (a1 + i + 1));\n+\n+  T (strlen (a1 + i0));\n+  T (strlen (a1 + i0 + 1));     // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strlen (a2));\n+  T (strlen (a2 + 1));\n+  T (strlen (a2 + 2));          // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+  T (strlen (a2 + i));\n+  T (strlen (a2 + i + 2));\n+\n+  T (strlen (a2 + i0));\n+  T (strlen (a2 + i0 + 1));\n+  T (strlen (a2 + i0 + 2));     // { dg-warning \"'strlen' reading 1 or more bytes from a region of size 0\" }\n+}\n+\n+\n+void test_strnlen_array (int i, int i0, unsigned n)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strnlen (a0, 0));\n+  T (strnlen (a0, 1));          // { dg-warning \"'strnlen' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strnlen (a0, i0));\n+  T (strnlen (a0, i0 + 1));     // { dg-warning \"'strnlen' (reading between 1 and \\[0-9\\]+ bytes from a region of size 0|specified bound \\\\\\[1, \\[0-9\\]+\\\\\\] exceeds source size 0)\" }\n+  T (strnlen (a0, n));\n+  T (strnlen (a0 + i, 0));\n+  T (strnlen (a0 + i, 1));      // { dg-warning \"'strnlen' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strnlen (a0 + i, i0));\n+  T (strnlen (a0 + i, n));\n+  T (strnlen (a0 + i + 1, 0));\n+  T (strnlen (a0 + i + 1, 1));  // { dg-warning \"'strnlen' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+\n+  T (strnlen (a0 + i0, 0));\n+  T (strnlen (a0 + i0, 1));     // { dg-warning \"'strnlen' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strnlen (a0 + i0, n));\n+\n+  T (strnlen (a1, 0));\n+  T (strnlen (a1, 1));\n+  T (strnlen (a1, 2));          // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" \"pr87492\" { xfail *-*-* } }\n+  T (strnlen (a1, n));\n+\n+  T (strnlen (a1 + 1, 0));\n+  T (strnlen (a1 + 1, 1));      // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a1 + 1, i0));\n+  T (strnlen (a1 + 1, i0 + 1)); // { dg-warning \"'strnlen' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strnlen (a1 + 1, n));\n+  T (strnlen (a1 + i, 0));\n+  T (strnlen (a1 + i, 1));\n+  T (strnlen (a1 + i, 2));      // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" }\n+  T (strnlen (a1 + i, n));\n+  T (strnlen (a1 + i + 1, 0));\n+  T (strnlen (a1 + i + 1, 1));\n+  T (strnlen (a1 + i + 1, 2));  // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" }\n+  T (strnlen (a1 + i + 1, n));\n+\n+  T (strnlen (a1 + i0, 0));\n+  T (strnlen (a1 + i0, 1));\n+  T (strnlen (a1 + i0, 2));     // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" }\n+  T (strnlen (a1 + i0, n));\n+  T (strnlen (a1 + i0 + 1, 0));\n+  T (strnlen (a1 + i0 + 1, 1)); // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a1 + i0 + 1, n));\n+\n+  T (strnlen (a2, 0));\n+  T (strnlen (a2, 1));\n+  T (strnlen (a2, 2));\n+  T (strnlen (a2, n));\n+  T (strnlen (a2 + 1, 0));\n+  T (strnlen (a2 + 1, 1));\n+  T (strnlen (a2 + 1, 2));      // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\"  \"pr87492\" { xfail *-*-* } }\n+  T (strnlen (a2 + 1, n));\n+  T (strnlen (a2 + 2, 0));\n+  T (strnlen (a2 + 2, 1));      // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a2 + 2, n));\n+  T (strnlen (a2 + i, 0));\n+  T (strnlen (a2 + i, 1));\n+  T (strnlen (a2 + i, 2));\n+  T (strnlen (a2 + i + 2, 0));\n+  T (strnlen (a2 + i + 2, 1));\n+  T (strnlen (a2 + i + 2, 2));\n+  T (strnlen (a2 + i + 2, n));\n+\n+  T (strnlen (a2 + i0, 0));\n+  T (strnlen (a2 + i0, 1));\n+  T (strnlen (a2 + i0, 2));\n+  T (strnlen (a2 + i0, 3));     // { dg-warning \"'strnlen' specified bound 3 exceeds source size 2\" }\n+  T (strnlen (a2 + i0, n));\n+\n+  T (strnlen (a2 + i0 + 1, 0));\n+  T (strnlen (a2 + i0 + 1, 1));\n+  T (strnlen (a2 + i0 + 1, 2));\n+  T (strnlen (a2 + i0 + 1, n));\n+\n+  T (strnlen (a2 + i0 + 2, 0));\n+  T (strnlen (a2 + i0 + 2, 1)); // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a2 + i0 + 2, i0));\n+  T (strnlen (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strnlen' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strnlen (a2 + i0 + 2, n));\n+}\n+\n+\n+void test_strcmp_array (const char *s, int i)\n+{\n+  T (strcmp (a0, \"\"));        // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  T (strcmp (a0, s));         // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+  T (strcmp (a0 + i, s));     // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcmp (a1, s));\n+  T (strcmp (a1 + 1, s));     // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+  T (strcmp (a1 + i, s));\n+  T (strcmp (a1 + i + 1, s));\n+\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strcmp (\"\", a0));         // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-*} }\n+\n+  T (strcmp (s, a0));         // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+  T (strcmp (s, a0 + i));     // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcmp (s, a1));\n+  T (strcmp (s, a1 + 1));     // { dg-warning \"'strcmp' reading 1 or more bytes from a region of size 0\" }\n+  T (strcmp (s, a1 + i));\n+  T (strcmp (s, a1 + i + 1));\n+}\n+\n+/* The number of characters read is considered to be bounded not just\n+   by the third argument to strncmp but also by the length of the shorter\n+   of the two strings.  When the string length is unknowm, verify that\n+   a warning is only issued for certain reading past the end but not\n+   otherwise.  */\n+\n+void test_strncmp_array (const char *s, int i)\n+{\n+  T (strncmp (a0, a0, 0));\n+\n+  T (strncmp (a0, s, 0));\n+  T (strncmp (a0, s, 1));       // { dg-warning \"'strncmp' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  T (strncmp (a0, s, 2));       // { dg-warning \"'strncmp' (reading between 1 and 2 bytes from a region of size 0|specified bound 2 exceeds source size 0)\" }\n+  T (strncmp (a1, s, 0));\n+  T (strncmp (a1, s, 1));\n+  T (strncmp (a1 + 1, s, 1));   // { dg-warning \"'strncmp' reading 1 byte from a region of size 0\" \"pr?????\" { xfail *-*-*} }\n+  T (strncmp (a1, s, 1));\n+  T (strncmp (a1 + 1, s, 2));   // { dg-warning \"'strncmp' (reading between 1 and 2 bytes from a region of size 0|specified bound 2 exceeds source size 0)\" }\n+\n+  T (strncmp (a2, s, 1));\n+  T (strncmp (a2, s, 2));\n+  T (strncmp (a2, s, 3));\n+\n+  T (strncmp (a2 + 1, s, 1));\n+  T (strncmp (a2 + 2, s, 2));   // { dg-warning \"'strncmp' (reading between 1 and 2 bytes from a region of size 0|specified bound 2 exceeds source size 0)\" }\n+\n+  T (strncmp (a1, b1, 0));\n+  T (strncmp (a1, b1, 1));\n+  T (strncmp (a1, b1, 2));      // { dg-warning \"'strncmp' specified bound 2 exceeds source size 1\" }\n+}\n+\n+\n+void test_strncmp_literal (const char *s, int i)\n+{\n+  T (strncmp (a0, \"\", 0));\n+  T (strncmp (a0, \"1\", 0));\n+  T (strncmp (a0, \"12\", 0));\n+\n+  /* The calls with a bound in excess of the length of the literal are\n+     folded early (most into strcmp) so the warning doesn't trigger.  */\n+  T (strncmp (s, \"\", 0));\n+\n+  T (strncmp (s, \"1\", 0));\n+  T (strncmp (s, \"1\", 1));\n+  T (strncmp (s, \"1\", 2));      // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93665\" { xfail *-*-* } }\n+\n+  T (strncmp (s, \"12\", 0));\n+  T (strncmp (s, \"12\", 1));\n+  T (strncmp (s, \"12\", 2));\n+  T (strncmp (s, \"12\", 3));     // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93665\" { xfail *-*-* } }\n+\n+  T (strncmp (s, \"123\", 0));\n+  T (strncmp (s, \"123\", 1));\n+  T (strncmp (s, \"123\", 2));\n+  T (strncmp (s, \"123\", 3));\n+  T (strncmp (s, \"123\", 4));    // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93665\" { xfail *-*-* } }\n+}\n+\n+\n+void test_strchr_array (int x, int i)\n+{\n+  T (strchr (a0, x));         // { dg-warning \"'strchr' reading 1 or more bytes from a region of size 0\" }\n+  T (strchr (a0 + i, x));     // { dg-warning \"'strchr' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strchr (a1, x));\n+  T (strchr (a1 + 1, x));     // { dg-warning \"'strchr' reading 1 or more bytes from a region of size 0\" }\n+  T (strchr (a1 + i, x));\n+  T (strchr (a1 + i + 1, x));\n+}\n+\n+\n+void test_strdup_array (int i)\n+{\n+  T (strdup (a0));            // { dg-warning \"'strdup' reading 1 or more bytes from a region of size 0\" }\n+  T (strdup (a0 + i));        // { dg-warning \"'strdup' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strdup (a1));\n+  T (strdup (a1 + 1));        // { dg-warning \"'strdup' reading 1 or more bytes from a region of size 0\" }\n+  T (strdup (a1 + i));\n+  T (strdup (a1 + i + 1));\n+}\n+\n+\n+void test_strndup_array (int i, int i0, unsigned n)\n+{\n+  if (i0 < 0)\n+    i0 = 0;\n+\n+  T (strndup (a0, 0));\n+  T (strndup (a0, 1));          // { dg-warning \"'strndup' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strndup (a0, i0));\n+  T (strndup (a0, i0 + 1));     // { dg-warning \"'strndup' (reading between 1 and \\[0-9\\]+ bytes from a region of size 0|specified bound \\\\\\[1, \\[0-9\\]+\\\\\\] exceeds source size 0)\" }\n+  T (strndup (a0, n));\n+  T (strndup (a0 + i, 0));\n+  T (strndup (a0 + i, 1));      // { dg-warning \"'strndup' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strndup (a0 + i, i0));\n+  T (strndup (a0 + i, n));\n+  T (strndup (a0 + i + 1, 0));\n+  T (strndup (a0 + i + 1, 1));  // { dg-warning \"'strndup' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+\n+  T (strndup (a0 + i0, 0));\n+  T (strndup (a0 + i0, 1));     // { dg-warning \"'strndup' (reading 1 byte from a region of size 0|specified bound 1 exceeds source size 0)\" }\n+  T (strndup (a0 + i0, n));\n+\n+  T (strndup (a1, 0));\n+  T (strndup (a1, 1));\n+  T (strndup (a1, 2));          // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n+  T (strndup (a1, n));\n+  T (strndup (a1 + 1, 0));\n+  T (strndup (a1 + 1, 1));      // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a1 + 1, i0));\n+  T (strndup (a1 + 1, i0 + 1)); // { dg-warning \"'strndup' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strndup (a1 + 1, n));\n+  T (strndup (a1 + i, 0));\n+  T (strndup (a1 + i, 1));\n+  T (strndup (a1 + i, 2));      // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n+  T (strndup (a1 + i, n));\n+  T (strndup (a1 + i + 1, 0));\n+  T (strndup (a1 + i + 1, 1));\n+  T (strndup (a1 + i + 1, 2));  // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n+  T (strndup (a1 + i + 1, n));\n+\n+  T (strndup (a1 + i0, 0));\n+  T (strndup (a1 + i0, 1));\n+  T (strndup (a1 + i0, n));\n+  T (strndup (a1 + i0 + 1, 0));\n+  T (strndup (a1 + i0 + 1, 1)); // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a1 + i0 + 1, n));\n+\n+  T (strndup (a2, 0));\n+  T (strndup (a2, 1));\n+  T (strndup (a2, 2));\n+  T (strndup (a2, n));\n+  T (strndup (a2 + 1, 0));\n+  T (strndup (a2 + 1, 1));\n+  T (strndup (a2 + 1, 2));\n+  T (strndup (a2 + 1, n));\n+  T (strndup (a2 + 2, 0));\n+  T (strndup (a2 + 2, 1));      // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a2 + 2, n));\n+  T (strndup (a2 + i, 0));\n+  T (strndup (a2 + i, 1));\n+  T (strndup (a2 + i, 2));\n+  T (strndup (a2 + i + 2, 0));\n+  T (strndup (a2 + i + 2, 1));\n+  T (strndup (a2 + i + 2, 2));\n+  T (strndup (a2 + i + 2, n));\n+\n+  T (strndup (a2 + i0, 0));\n+  T (strndup (a2 + i0, 1));\n+  T (strndup (a2 + i0, 2));\n+  T (strndup (a2 + i0, 3));     // { dg-warning \"'strndup' specified bound 3 exceeds source size 2\" }\n+  T (strndup (a2 + i0, n));\n+\n+  T (strndup (a2 + i0 + 1, 0));\n+  T (strndup (a2 + i0 + 1, 1));\n+  T (strndup (a2 + i0 + 1, 2));\n+  T (strndup (a2 + i0 + 1, n));\n+\n+  T (strndup (a2 + i0 + 2, 0));\n+  T (strndup (a2 + i0 + 2, 1)); // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a2 + i0 + 2, i0));\n+  T (strndup (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strndup' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strndup (a2 + i0 + 2, n));\n+}\n+\n+\n+void test_strpbrk_array (char *s, int i)\n+{\n+  T (strpbrk (a0, \"\"));       // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  T (strpbrk (a0, s));        // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+  T (strpbrk (a0 + i, s));    // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strpbrk (a1, s));\n+  T (strpbrk (a1 + 1, s));    // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+  T (strpbrk (a1 + i, s));\n+  T (strpbrk (a1 + i + 1, s));\n+\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strpbrk (\"\", a0));       // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strpbrk (s, a0));        // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+  T (strpbrk (s, a0 + i));    // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strpbrk (s, a1));\n+  T (strpbrk (s, a1 + 1));    // { dg-warning \"'strpbrk' reading 1 or more bytes from a region of size 0\" }\n+  T (strpbrk (s, a1 + i));\n+  T (strpbrk (s, a1 + i + 1));\n+}\n+\n+\n+void test_strspn_array (const char *s, int i)\n+{\n+  T (strspn (a0, \"\"));        // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  T (strspn (a0, s));         // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strspn (a0 + i, s));     // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strspn (a1, s));\n+  T (strspn (a1 + 1, s));     // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strspn (a1 + i, s));\n+  T (strspn (a1 + i + 1, s));\n+\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strspn (\"\", a0));         // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-*} }\n+\n+  T (strspn (s, a0));         // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strspn (s, a0 + i));     // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strspn (s, a1));\n+  T (strspn (s, a1 + 1));     // { dg-warning \"'strspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strspn (s, a1 + i));\n+  T (strspn (s, a1 + i + 1));\n+}\n+\n+\n+void test_strcspn_array (const char *s, int i)\n+{\n+  /* The call below is tranformed to strlen() so the warning references\n+     the latter function instead of strcspn.  Avoid testing that aspect.  */\n+  T (strcspn (a0, \"\"));       // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcspn (a0, s));        // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strcspn (a0 + i, s));    // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcspn (a1, s));\n+  T (strcspn (a1 + 1, s));    // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strcspn (a1 + i, s));\n+  T (strcspn (a1 + i + 1, s));\n+\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strcspn (\"\", a0));       // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-*} }\n+\n+  T (strcspn (s, a0));        // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strcspn (s, a0 + i));    // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strcspn (s, a1));\n+  T (strcspn (s, a1 + 1));    // { dg-warning \"'strcspn' reading 1 or more bytes from a region of size 0\" }\n+  T (strcspn (s, a1 + i));\n+  T (strcspn (s, a1 + i + 1));\n+}\n+\n+\n+void test_strstr_array (char *s, int i)\n+{\n+  T (strstr (a0, \"\"));        // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  T (strstr (a0, s));         // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+  T (strstr (a0 + i, s));     // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strstr (a1, s));\n+  T (strstr (a1 + 1, s));     // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+  T (strstr (a1 + i, s));\n+  T (strstr (a1 + i + 1, s));\n+\n+\n+  // Repeat the above with the arguments reversed.\n+\n+  T (strstr (\"\", a0));        // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strstr (s, a0));         // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+  T (strstr (s, a0 + i));     // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (strstr (s, a1));\n+  T (strstr (s, a1 + 1));     // { dg-warning \"'strstr' reading 1 or more bytes from a region of size 0\" }\n+  T (strstr (s, a1 + i));\n+  T (strstr (s, a1 + i + 1));\n+}\n+\n+\n+void test_puts_array (int i)\n+{\n+  T (puts (a0));              // { dg-warning \"'puts' reading 1 or more bytes from a region of size 0\" }\n+  T (puts (a0 + i));          // { dg-warning \"'puts' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (puts (a1));\n+  T (puts (a1 + 1));          // { dg-warning \"'puts' reading 1 or more bytes from a region of size 0\" }\n+  T (puts (a1 + i));\n+  T (puts (a1 + i + 1));\n+}\n+\n+\n+void test_puts_unlocked_array (int i)\n+{\n+  T (puts_unlocked (a0));     // { dg-warning \"'puts_unlocked' reading 1 or more bytes from a region of size 0\" }\n+  T (puts_unlocked (a0 + i)); // { dg-warning \"'puts_unlocked' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (puts_unlocked (a1));\n+  T (puts_unlocked (a1 + 1)); // { dg-warning \"'puts_unlocked' reading 1 or more bytes from a region of size 0\" }\n+  T (puts_unlocked (a1 + i));\n+  T (puts_unlocked (a1 + i + 1));\n+}\n+\n+\n+void test_gettext_array (int i)\n+{\n+  T (gettext (a0));           // { dg-warning \"'gettext' reading 1 or more bytes from a region of size 0\" }\n+  T (gettext (a0 + i));       // { dg-warning \"'gettext' reading 1 or more bytes from a region of size 0\" }\n+\n+  T (gettext (a1));\n+  T (gettext (a1 + 1));       // { dg-warning \"'gettext' reading 1 or more bytes from a region of size 0\" }\n+  T (gettext (a1 + i));\n+  T (gettext (a1 + i + 1));\n+}"}, {"sha": "ba4757d673fbcd56b4ae2938ba0e481f56cadcb7", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-2.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -26,8 +26,8 @@ void test_strnlen_array_cst (void)\n   T (strnlen (ns3, 1));\n   T (strnlen (ns3, 2));\n   T (strnlen (ns3, 3));\n-  T (strnlen (ns3, 4));             /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n-  T (strnlen (ns3, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\[0-9\\]+\" } */\n+  T (strnlen (ns3, 4));             /* { dg-warning \"specified bound 4 exceeds source size 3\" } */\n+  T (strnlen (ns3, DIFF_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size\" } */\n   T (strnlen (ns3, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   NONSTRING char ns5[5];\n@@ -37,8 +37,8 @@ void test_strnlen_array_cst (void)\n   T (strnlen (ns5, 1));\n   T (strnlen (ns5, 2));\n   T (strnlen (ns5, 3));\n-  T (strnlen (ns5, 6));             /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 6\" } */\n-  T (strnlen (ns5, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\[0-9\\]+\" } */\n+  T (strnlen (ns5, 6));             /* { dg-warning \"specified bound 6 exceeds source size 5\" } */\n+  T (strnlen (ns5, DIFF_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size 5\" } */\n   T (strnlen (ns5, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n }\n \n@@ -52,8 +52,8 @@ void test_strnlen_array_range (void)\n   T (strnlen (ns3, UR (0, 9)));\n   T (strnlen (ns3, UR (3, 4)));\n   T (strnlen (ns3, UR (3, DIFF_MAX)));\n-  T (strnlen (ns3, UR (4, 5)));     /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" } */\n-  T (strnlen (ns3, UR (DIFF_MAX, SIZE_MAX)));  /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller \" } */\n+  T (strnlen (ns3, UR (4, 5)));     /* { dg-warning \"specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n+  T (strnlen (ns3, UR (DIFF_MAX, SIZE_MAX)));  /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 3 \" } */\n }\n \n \n@@ -73,8 +73,8 @@ void test_strnlen_string_cst (void)\n   T (3, \"12\",  3, 1);\n   T (3, \"12\",  3, 9);\n   T (3, \"123\", 3, 1);\n-  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n-  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" } */\n+  T (3, \"123\", 3, 4);               /* { dg-warning \"specified bound 4 exceeds source size 3\" } */\n+  T (3, \"123\", 3, 9);               /* { dg-warning \"specified bound 9 exceeds source size 3\" } */\n \n   T (5, \"1\",   2, 1);\n   T (5, \"1\",   2, 2);\n@@ -84,7 +84,7 @@ void test_strnlen_string_cst (void)\n   T (5, \"12\",  3, 9);\n   T (5, \"123\", 3, 1);\n   T (5, \"123\", 3, 5);\n-  T (5, \"123\", 3, 6);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 6\" } */\n+  T (5, \"123\", 3, 6);               /* { dg-warning \"specified bound 6 exceeds source size 5\" } */\n \n   /* Strnlen shouldn't trigger a warning for arrays of unknown size\n      (except for accesses to uninitialized elements when those are\n@@ -110,6 +110,6 @@ void test_strnlen_string_range (void)\n {\n   T (3, \"1\",   2, UR (0, 1));\n   T (3, \"1\",   2, UR (3, 9));\n-  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" } */\n-  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[5, 9]\" } */\n+  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n+  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"specified bound \\\\\\[5, 9] exceeds source size 3\" } */\n }"}, {"sha": "34f31fb6aa736ac3e02c959549d94837e8981af9", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-3.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -37,15 +37,21 @@ void strncmp_cst (void)\n   T (STR, /* [] */, STR, /* [] */, n);\n   T (STR, /* [] */, STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (STR, 1, STR, /* [] */, 1);\n   T (STR, 1, STR, /* [] */, n);\n   T (STR, 2, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (STR, /* [] */, STR, 3, 3);\n   T (STR, /* [] */, STR, 3, n);\n   T (STR, /* [] */, STR, 4, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (STR, /* [] */, NS, /* [] */, 3);\n   T (STR, /* [] */, NS, /* [] */, n);\n   T (STR, /* [] */, NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (STR, 5, NS, /* [] */, 4);\n+  T (STR, 5, NS, /* [] */, 5);\n+  T (STR, 5, NS, /* [] */, 6);\n   T (STR, 5, NS, /* [] */, n);\n   T (STR, 6, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n@@ -56,19 +62,22 @@ void strncmp_cst (void)\n   T (NS, /* [] */, STR, /* [] */, n);\n   T (NS, /* [] */, STR, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 9, STR, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 9, STR, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\[0-9\\]+\" } */\n   T (NS, 10, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (NS, /* [] */, STR, 11, 11);\n   T (NS, /* [] */, STR, 11, n);\n   T (NS, /* [] */, STR, 12, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (NS, /* [] */, NS, /* [] */, n);\n   T (NS, /* [] */, NS, /* [] */, n + 1);      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 13, NS, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 13, NS, /* [] */, 13);\n+  T (NS, 13, NS, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\[0-9\\]+\" } */\n   T (NS, 14, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, /* [] */, NS, 15, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, /* [] */, NS, 15, 15);\n+  T (NS, /* [] */, NS, 15, 16);               /* { dg-warning \"argument 2 declared attribute 'nonstring' is smaller than the specified bound 16\" } */\n   T (NS, /* [] */, NS, 16, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n }\n \n@@ -81,6 +90,7 @@ void strncmp_range (void)\n   T (STR, /* [] */, STR, /* [] */, n);\n   T (STR, /* [] */, STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n+  T (STR, 1, STR, /* [] */, 1);\n   T (STR, 1, STR, /* [] */, n);\n   T (STR, 2, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n@@ -93,7 +103,7 @@ void strncmp_range (void)\n   T (STR, 5, NS, /* [] */, n);\n   T (STR, 6, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (STR, /* [] */, NS, 7, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (STR, /* [] */, NS, 7, n);                /* { dg-warning \"argument 2 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+]\" } */\n \n   T (STR, /* [] */, NS, 8, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n "}, {"sha": "f2416c16e83c6f24345868719df7311698b7f4d9", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -40,7 +40,7 @@ void strnlen_cst (void)\n   T (NS, /* [] */, n);\n   T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 9, n);                /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size 9\" } */\n   T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n }\n \n@@ -53,12 +53,12 @@ void strnlen_range (void)\n   T (STR, /* [] */, n);\n   T (STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (STR, 1, n);\n+  T (STR, 1, n);               /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 1\" } */\n   T (STR, 2, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (NS, /* [] */, n);\n   T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 9, n);                /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 9\" } */\n   T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n }"}, {"sha": "d93e93ca6766055646b8764fe7ba70dbd133f0e4", "filename": "gcc/testsuite/gcc.dg/attr-nonstring.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -44,80 +44,80 @@ int strcmp_nonstring_1 (NONSTRING const char *a, const char *b)\n      no good on its own.  Use dg-regexp instead to verify that just\n      one instance of the warning is issued.  See gcc.dg/pr64223-1\n      for a different approach.  */\n-  return strcmp (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcmp. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strcmp\" } */\n+  return strcmp (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcmp. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strcmp\" } */\n }\n \n int strcmp_nonstring_2 (const char *a, NONSTRING const char *b)\n {\n-  return strcmp (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcmp. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strcmp\" } */\n+  return strcmp (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcmp. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strcmp\" } */\n }\n \n int strncmp_nonstring_1 (const char *s)\n {\n-  return strncmp (s, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncmp. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overflow=]\" \"strncmp\" } */\n+  return strncmp (s, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncmp. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strncmp\" } */\n }\n \n int strncmp_nonstring_2 (const char *s)\n {\n-  return strncmp (ns5, s, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncmp. argument 1 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overflow=]\" \"strncmp\" } */\n+  return strncmp (ns5, s, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncmp. argument 1 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strncmp\" } */\n }\n \n char* stpcpy_nonstring (char *d, NONSTRING const char *s)\n {\n-  return stpcpy (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .stpcpy. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"stpcpy\" } */\n+  return stpcpy (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .stpcpy. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"stpcpy\" } */\n }\n \n char* stpncpy_nonstring (char *d)\n {\n-  return stpncpy (d, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .stpncpy. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overflow=]\" \"stpncpy\" } */\n+  return stpncpy (d, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .stpncpy. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"stpncpy\" } */\n }\n \n char* strchr_nonstring (NONSTRING const char *s, int c)\n {\n-  return strchr (s, c);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strchr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strchr\" } */\n+  return strchr (s, c);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strchr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strchr\" } */\n }\n \n char* strrchr_nonstring (NONSTRING const char *s, int c)\n {\n-  return strrchr (s, c);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strrchr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strrchr\" } */\n+  return strrchr (s, c);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strrchr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strrchr\" } */\n }\n \n char* strcpy_nonstring (char *d, NONSTRING const char *s)\n {\n-  return strcpy (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcpy. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strcpy\" } */\n+  return strcpy (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strcpy. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strcpy\" } */\n }\n \n char* strncpy_nonstring (char *d)\n {\n-  return strncpy (d, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncpy. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overflow=]\" \"strncpy\" } */\n+  return strncpy (d, ns5, sizeof ns5 + 1);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strncpy. argument 2 declared attribute .nonstring. \\[^\\n\\r\\]+ \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strncpy\" } */\n }\n \n char* strstr_nonstring_1 (NONSTRING const char *a, const char *b)\n {\n-  return strstr (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strstr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strstr\" } */\n+  return strstr (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strstr. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strstr\" } */\n }\n \n char* strstr_nonstring_2 (const char *a, NONSTRING const char *b)\n {\n-  return strstr (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strstr. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strstr\" } */\n+  return strstr (a, b);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strstr. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strstr\" } */\n }\n \n char* stdup_nonstring (NONSTRING const char *s)\n {\n-  return strdup (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strdup. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strdup\" } */\n+  return strdup (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strdup. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strdup\" } */\n }\n \n size_t strlen_nonstring (NONSTRING const char *s)\n {\n-  return strlen (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strlen. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"strlen\" } */\n+  return strlen (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .strlen. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"strlen\" } */\n }\n \n int printf_nonstring (NONSTRING const char *s)\n {\n-  return printf (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .printf. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"printf\" } */\n+  return printf (s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .printf. argument 1 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"printf\" } */\n }\n \n int sprintf_nonstring_2 (char *d, NONSTRING const char *s)\n {\n-  return sprintf (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .sprintf. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overflow=]\" \"sprintf\" } */\n+  return sprintf (d, s);  /* { dg-regexp \"\\[^\\n\\r\\]+: warning: .sprintf. argument 2 declared attribute .nonstring. \\\\\\[-Wstringop-overread\\[^\\n\\r\\]*\" \"sprintf\" } */\n }"}, {"sha": "7d5b03b9c270f09fa90d39453b9144fcf9b95c14", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -87,7 +87,7 @@ void test_memop_warn_local (const void *src)\n   memset (&b->d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" } */\n   escape (b);\n \n-  /* Same as above but clearing just elements of the second element\n+  /* Same as above but clearing just members of the second element\n      of the array.  */\n   memset (&b[1].a.b, 0, offsetfrom (struct B, b[1], a.b) + 1);   /* { dg-warning \"writing 4 bytes into a region of size 3\" } */\n   escape (b);"}, {"sha": "f2e9c481172f8168cfeb4cab9e5202a3f6a816eb", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-8.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,6 +1,6 @@\n-/* Test exercising -Wstringop-overflow warnings for reading past the end.  */\n+/* Test exercising -Wstringop-overread warnings for reading past the end.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wstringop-overflow=1 -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-O2 -Wstringop-overread -ftrack-macro-expansion=0\" } */\n \n #define PTRDIFF_MAX   __PTRDIFF_MAX__\n #define SIZE_MAX      __SIZE_MAX__\n@@ -73,22 +73,22 @@ void test_memop_warn_local (void *p, const void *q)\n \n   /* Verify memchr/memcmp.  */\n   int i = R (0, 255);\n-  memchr (\"\", i, 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n-  memchr (\"\", i, 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n-  memchr (\"123\", i, 5);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n-  memchr (a, i, sizeof a + 1);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+  memchr (\"\", i, 2);   /* { dg-warning \"specified bound 2 exceeds source size 1\" \"memchr\" } */\n+  memchr (\"\", i, 2);   /* { dg-warning \"specified bound 2 exceeds source size 1\" \"memchr\" } */\n+  memchr (\"123\", i, 5);   /* { dg-warning \"specified bound 5 exceeds source size 4\" \"memchr\" } */\n+  memchr (a, i, sizeof a + 1);   /* { dg-warning \"specified bound 5 exceeds source size 4\" \"memchr\" } */\n \n-  memcmp (p, \"\", 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n-  memcmp (p, \"123\", 5);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n-  memcmp (p, a, sizeof a + 1);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+  memcmp (p, \"\", 2);   /* { dg-warning \"specified bound 2 exceeds source size 1\" \"memcmp\" } */\n+  memcmp (p, \"123\", 5);   /* { dg-warning \"specified bound 5 exceeds source size 4\" \"memcmp\" } */\n+  memcmp (p, a, sizeof a + 1);   /* { dg-warning \"specified bound 5 exceeds source size 4\" \"memcmp\" } */\n \n   size_t n = PTRDIFF_MAX + (size_t)1;\n-  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" } */\n-  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" \"memchr\" } */\n+  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" \"memcmp\" } */\n \n   n = SIZE_MAX;\n-  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" } */\n-  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" \"memchr\" } */\n+  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" \"memcmp\" } */\n }\n \n /* Verify that reading beyond the end of a dynamically allocated array\n@@ -117,8 +117,8 @@ void test_memop_warn_alloc (void *p)\n   /* Verify memchr/memcmp.  */\n   n = sizeof *b * 2 + 1;\n \n-  memchr (b, 1, n);   /* { dg-warning \"reading 9 bytes from a region of size 8\" \"memcmp from allocated\" } */\n-  memcmp (p, b, n);   /* { dg-warning \"reading 9 bytes from a region of size 8\" \"memcmp from allocated\" } */\n+  memchr (b, 1, n);   /* { dg-warning \"specified bound 9 exceeds source size 8\" \"memchr from allocated\" } */\n+  memcmp (p, b, n);   /* { dg-warning \"specified bound 9 exceeds source size 8\" \"memcmp from allocated\" } */\n }\n \n "}, {"sha": "a9a617cde23908f5672e889faefbe3a7858e3890", "filename": "gcc/testsuite/gcc.dg/pr78902.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78902.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -12,4 +12,5 @@ void foo(void)\n  __builtin_aligned_alloc (10, 16); /* { dg-warning \"ignoring return value of '__builtin_aligned_alloc' declared with attribute 'warn_unused_result'\" } */\n  __builtin_strdup (\"pes\"); /* { dg-warning \"ignoring return value of '__builtin_strdup' declared with attribute 'warn_unused_result'\" } */\n  __builtin_strndup (\"pes\", 10); /* { dg-warning \"ignoring return value of '__builtin_strndup' declared with attribute 'warn_unused_result'\" } */\n+ /* { dg-warning \"\\\\\\[-Wstringop-overread\" \"strndup excessive bound\" { target *-*-* } .-1 } */\n }"}, {"sha": "3f5d935d712de229f5760a5d210810ecd08ea535", "filename": "gcc/testsuite/gcc.dg/pr79214.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -84,5 +84,5 @@ char* test_strncat (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return strncat (d, s, range ());   /* { dg-warning \".__builtin_strncat. specified bound between 4 and \\[0-9\\]+\" } */\n+  return strncat (d, s, range ());   /* { dg-warning \".__builtin_strncat. specified bound \\\\\\[4, \\[0-9\\]+] exceeds destination size 3\" } */\n }"}, {"sha": "d7f94ac4d528b32db9ab628f555252d0e4fbb820", "filename": "gcc/testsuite/gcc.dg/strcmpopt_10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_10.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -3,7 +3,7 @@\n    when the pointer pointed to by the enclosing object references an object\n    sufficiently large to store a string of equal length.\n   { dg-do compile }\n-  { dg-options \"-O2 -Wall -Wextra -fdump-tree-optimized\" } */\n+  { dg-options \"-O2 -Wall -Wextra -Wno-stringop-overread -fdump-tree-optimized\" } */\n \n void init (void*);\n "}, {"sha": "2f67babec882aafcc8d4ab55aa8bf03f6b8ecfa8", "filename": "gcc/testsuite/gcc.dg/strlenopt-57.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -21,9 +21,9 @@ void test_var_flexarray_cst_off (void)\n {\n   /* Use arbitrary constants greater than 16 in case GCC ever starts\n      unrolling strlen() calls with small array arguments.  */\n-  a[0] = 17 < strlen (a0.a + 1);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n-  a[1] = 19 < strlen (a1.a + 1);\n-  a[2] = 23 < strlen (a9.a + 9);\n+  a[0] = 17 < strlen (a0.a + 1);        // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n+  a[1] = 19 < strlen (a1.a + 1);        // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n+  a[2] = 23 < strlen (a9.a + 9);        // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n   a[3] = 29 < strlen (ax.a + 3);\n }\n "}, {"sha": "12e6f255bf5270126589c45856060cc2a3b06d76", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-overread -Wno-stringop-truncation\" } */\n /* Test just twice, once with -O0 non-fortified, once with -O2 fortified.  */\n /* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } } */\n /* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } } */"}, {"sha": "3946a8ca18c0ee678a6681090a7d377b7ad53970", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtins-folding-gimple-ub.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -14,13 +14,13 @@ main (void)\n   /* MEMCHR.  */\n   if (__builtin_memchr (\"\", 'x', 1000)) /* Not folded away.  */\n     {\n-      /* { dg-warning \"reading 1000 bytes from a region of size 1\" \"\" { target *-*-* } .-2 } */\n+      /* { dg-warning \"\\\\\\[-Wstringop-overread\" \"\" { target *-*-* } .-2 } */\n       __builtin_abort ();\n     }\n \n   if (__builtin_memchr (foo1, 'x', 1000)) /* Not folded away.  */\n     {\n-      /* { dg-warning \"reading 1000 bytes from a region of size 1\" \"\" { target *-*-* } .-2 } */\n+      /* { dg-warning \"\\\\\\[-Wstringop-overread\" \"\" { target *-*-* } .-2 } */\n       __builtin_abort ();\n     }\n "}, {"sha": "732d33e006ddf42eb1b186d18a98856b9bee4492", "filename": "gcc/testsuite/gcc.dg/uninit-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -27,7 +27,7 @@ void nowarn_scalar_plus_fpri (void)\n   int i;\n   /* This gets a -Wstringop-overflow for reading past the end but not\n      -Wuninitialized because there's nothing to initialize there.  */\n-  fpri (&i + 1);              // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  fpri (&i + 1);              // { dg-warning \"\\\\\\[-Wstringop-overread\" }\n }\n \n void nowarn_array_assign_fpcri (void)"}, {"sha": "76180a3f5da8e0cb0ded6bdbac521be9b2a74d26", "filename": "gcc/testsuite/gcc.dg/warn-strnlen-no-nul-2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul-2.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -62,5 +62,11 @@ void test (int n0)\n \n   int n = n0 < n1 ? n1 : n0;\n \n-  sink (strnlen (c + n, n + 1));    /* { dg-warning \"specified bound \\\\\\[5, \\[0-9\\]+] may exceed the size of at most 4 of unterminated array\" } */\n+  /* N is at least 4 and c[4] is out-of-bounds.  This could trigger\n+     either -Warray-bounds or -Wstringop-overread.  -Warray-bounds\n+     only diagnoses past-the-end accesses by modifying functions\n+     (in gimple-ssa-warn-restrict.c) and even for those, either\n+     -Wstringop-overflow or -Wstringop-overread would be more\n+     appropriate.  */\n+  sink (strnlen (c + n, n + 1));    /* { dg-warning \"specified bound \\\\\\[5, \\[0-9\\]+] exceeds the size of at most 4 of unterminated array\" } */\n }"}, {"sha": "02f6f3d5342c2fda4db32378fe2f6b6e7640238a", "filename": "gcc/testsuite/gcc.dg/warn-strnlen-no-nul.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -35,7 +35,7 @@ T (&a[1], asz - 1);\n T (&a[v0], asz);               /* { dg-warning \"specified bound 5 may exceed the size of at most 5 of unterminated array\" } */\n T (&a[v0] + 1, asz);           /* { dg-warning \"specified bound 5 may exceed the size of at most 5 of unterminated array\" } */\n \n-T (a, asz + 1);                /* { dg-warning \"specified bound 6 exceeds the size 5 \" } */\n+T (a, asz + 1);                /* { dg-warning \"specified bound 6 exceeds the size 5 of unterminated array\" } */\n T (&a[0], asz + 1);            /* { dg-warning \"unterminated\" } */\n T (&a[0] + 1, asz - 1);\n T (&a[0] + 1, asz + 1);        /* { dg-warning \"unterminated\" } */\n@@ -110,7 +110,7 @@ T (&b[3][1] + i1, bsz);           /* { dg-warning \"unterminated\" } */\n T (&b[3][1] + i1, bsz - i1);      /* { dg-warning \"unterminated\" } */\n T (&b[3][1] + i1, bsz - i2);\n T (&b[3][v0], bsz);\n-T (&b[3][1] + v0, bsz);           /* { dg-warning \"specified bound 5 may exceed the size of at most 4 of unterminated array\" } */\n+T (&b[3][1] + v0, bsz);           /* { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" } */\n T (&b[3][v0] + v1, bsz);          /* { dg-warning \"specified bound 5 may exceed the size of at most 4 of unterminated array\" \"pr?????\" { xfail *-*-* } } */\n \n T (&b[3][1], bsz + 1);            /* { dg-warning \"unterminated\" } */\n@@ -124,7 +124,7 @@ T (&b[i3][i1], bsz);              /* { dg-warning \"unterminated\" } */\n T (&b[i3][i1] + 1, bsz);          /* { dg-warning \"unterminated\" } */\n T (&b[i3][i1] + i1, bsz);         /* { dg-warning \"specified bound 5 exceeds the size 3 of unterminated array\" } */\n T (&b[i3][v0], bsz);\n-T (&b[i3][i1] + v0, bsz);         /* { dg-warning \"specified bound 5 may exceed the size of at most 4 of unterminated array\" } */\n+T (&b[i3][i1] + v0, bsz);         /* { dg-warning \"specified bound 5 exceeds the size of at most 4 of unterminated array\" } */\n T (&b[i3][v0] + v1, bsz);\n \n T (&b[i3][i1], bsz + 1);          /* { dg-warning \"unterminated\" } */\n@@ -212,10 +212,10 @@ T (&s.a[i1] + v0, asz);\n T (s.a, asz + 1);\n T (&s.a[0], asz + 1);\n T (&s.a[0] + 1, asz + 1);\n-T (&s.a[0] + v0, asz + 1);\n+T (&s.a[0] + v0, asz + 1);        /* { dg-warning \"specified bound 6 exceeds source size 5 \" } */\n T (&s.a[1], asz + 1);\n T (&s.a[1] + 1, asz + 1);\n-T (&s.a[1] + v0, asz + 1);\n+T (&s.a[1] + v0, asz + 1);        /* { dg-bogus \"specified bound 6 exceeds source size 5\" \"pr95794\" { xfail *-*-* } } */\n \n T (&s.a[i0], asz + 1);\n T (&s.a[i0] + i1, asz + 1);\n@@ -266,10 +266,10 @@ const struct B ba[] = {\n T (ba[0].a[0].a, asz + 1);\n T (&ba[0].a[0].a[0], asz + 1);\n T (&ba[0].a[0].a[0] + 1, asz + 1);\n-T (&ba[0].a[0].a[0] + v0, asz + 1);\n+T (&ba[0].a[0].a[0] + v0, asz + 1);   /* { dg-bogus \"specified bound 6 exceeds source size 5\" pr95794\" { xfail *-*-* } } */\n T (&ba[0].a[0].a[1], asz + 1);\n T (&ba[0].a[0].a[1] + 1, asz + 1);\n-T (&ba[0].a[0].a[1] + v0, asz + 1);\n+T (&ba[0].a[0].a[1] + v0, asz + 1);   /* { dg-bogus \"specified bound 6 exceeds source size 5\" pr95794\" { xfail *-*-* } } */\n \n T (ba[0].a[0].b, bsz);\n T (&ba[0].a[0].b[0], bsz);\n@@ -302,10 +302,10 @@ T (&ba[0].a[1].a[1] + v0, asz + 1);   /* { dg-warning \"unterminated\" } */\n T (ba[0].a[1].b, bsz + 1);\n T (&ba[0].a[1].b[0], bsz + 1);\n T (&ba[0].a[1].b[0] + 1, bsz + 1);\n-T (&ba[0].a[1].b[0] + v0, bsz + 1);\n+T (&ba[0].a[1].b[0] + v0, bsz + 1);   /* { dg-bogus \"specified bound 6 exceeds source size 5\" pr95794\" { xfail *-*-* } } */\n T (&ba[0].a[1].b[1], bsz + 1);\n T (&ba[0].a[1].b[1] + 1, bsz + 1);\n-T (&ba[0].a[1].b[1] + v0, bsz + 1);\n+T (&ba[0].a[1].b[1] + v0, bsz + 1);   /* { dg-bogus \"specified bound 6 exceeds source size 5\" pr95794\" { xfail *-*-* } } */\n \n T (ba[1].a[0].a, asz);\n T (&ba[1].a[0].a[0], asz);"}, {"sha": "d73086646dc9b994b077e4f705153c7faf376b30", "filename": "gcc/testsuite/gcc.target/i386/strcmpopt_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstrcmpopt_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstrcmpopt_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstrcmpopt_6.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -1,23 +1,23 @@\n-/* When the specified length exceeds one of the arguments of the call to memcmp, \n+/* When the specified length exceeds one of the arguments of the call to memcmp,\n    the call to memcmp should NOT be inlined.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wno-stringop-overflow\" } */\n+/* { dg-options \"-O2 -Wno-stringop-overread\" } */\n \n typedef struct { char s[8]; int x; } S;\n \n __attribute__ ((noinline)) int\n f1 (S * s)\n {\n   int result = 0;\n-  result += __builtin_memcmp (s->s, \"a\", 3); \n+  result += __builtin_memcmp (s->s, \"a\", 3);\n   return result;\n }\n \n __attribute__ ((noinline)) int\n f2 (char *p)\n {\n   int result = 0;\n-  result += __builtin_memcmp (p, \"a\", 3); \n+  result += __builtin_memcmp (p, \"a\", 3);\n   return result;\n }\n "}, {"sha": "7eddca397b3a43e7f1b78ffe820f90c8150db688", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -489,10 +489,10 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n       attr_access *access = rdwr_idx.get (argno - 1);\n       if (access)\n \t{\n-\t  if (access->mode == attr_access::none\n-\t      || access->mode == attr_access::write_only)\n+\t  if (access->mode == access_none\n+\t      || access->mode == access_write_only)\n \t    continue;\n-\t  if (save_always_executed && access->mode == attr_access::read_only)\n+\t  if (save_always_executed && access->mode == access_read_only)\n \t    /* Attribute read_only arguments imply read access.  */\n \t    wlims.always_executed = true;\n \t  else\n@@ -524,7 +524,7 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n \n       if (access)\n \t{\n-\t  const char* const mode = (access->mode == attr_access::read_only\n+\t  const char* const mode = (access->mode == access_read_only\n \t\t\t\t    ? \"read_only\" : \"read_write\");\n \t  char attrstr[80];\n \t  int n = sprintf (attrstr, \"access (%s, %u\", mode, argno);"}, {"sha": "910f4aa54066c70ac1abb3f9fe070546547cd512", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c547abd484d3540b692bb8048c4a6efe92c8b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d14c547abd484d3540b692bb8048c4a6efe92c8b", "patch": "@@ -5340,6 +5340,15 @@ canonical_type_used_p (const_tree t)\n \t   || TREE_CODE (t) == VECTOR_TYPE);\n }\n \n+/* Kinds of access to pass-by-reference arguments to functions.  */\n+enum access_mode\n+{\n+  access_none = 0,\n+  access_read_only = 1,\n+  access_write_only = 2,\n+  access_read_write = access_read_only | access_write_only\n+};\n+\n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);\n #define tree_map_marked_p tree_map_base_marked_p"}]}