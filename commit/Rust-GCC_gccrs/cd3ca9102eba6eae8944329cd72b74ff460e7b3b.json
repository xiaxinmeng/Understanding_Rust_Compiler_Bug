{"sha": "cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzY2E5MTAyZWJhNmVhZTg5NDQzMjljZDcyYjc0ZmY0NjBlN2IzYg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-08-01T15:03:01Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-08-01T15:03:01Z"}, "message": "tree-vrp (zero_nonzero_bits_from_bounds): Rename to...\n\n\t* tree-vrp (zero_nonzero_bits_from_bounds): Rename to...\n\t(wide_int_set_zero_nonzero_bits): ...this.\n\t(zero_nonzero_bits_from_vr): Rename to...\n\t(vrp_set_zero_nonzero_bits): ...this.\n\t(extract_range_from_multiplicative_op_1): Abstract wide int\n\tcode...\n\t(wide_int_range_multiplicative_op): ...here.\n\t(extract_range_from_binary_expr_1): Extract wide int binary\n\toperations into their own functions.\n\t(wide_int_range_lshift): New.\n\t(wide_int_range_can_optimize_bit_op): New.\n\t(wide_int_range_shift_undefined_p): New.\n\t(wide_int_range_bit_xor): New.\n\t(wide_int_range_bit_ior): New.\n\t(wide_int_range_bit_and): New.\n\t(wide_int_range_trunc_mod): New.\n\t(extract_range_into_wide_ints): New.\n\t(vrp_shift_undefined_p): New.\n\t(extract_range_from_multiplicative_op): New.\n\t(vrp_can_optimize_bit_op): New.\n\t* tree-vrp.h (value_range::dump): New.\n\t(wide_int_range_multiplicative_op): New.\n\t(wide_int_range_lshift):New.\n\t(wide_int_range_shift_undefined_p): New.\n\t(wide_int_range_bit_xor): New.\n\t(wide_int_range_bit_ior): New.\n\t(wide_int_range_bit_and): New.\n\t(wide_int_range_trunc_mod): New.\n\t(zero_nonzero_bits_from_bounds): Rename to...\n\t(wide_int_set_zero_nonzero_bits): ...this.\n\t(zero_nonzero_bits_from_vr): Rename to...\n\t(vrp_set_zero_nonzero_bits): ...this.\n\t(range_easy_mask_min_max): Rename to...\n\t(wide_int_range_can_optimize_bit_op): this.\n\nFrom-SVN: r263218", "tree": {"sha": "917504501ffa1f0fd294f1546c81c4595a11e5a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/917504501ffa1f0fd294f1546c81c4595a11e5a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "211cd1e2358d52d3863f727b650c65650dd5ce89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211cd1e2358d52d3863f727b650c65650dd5ce89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211cd1e2358d52d3863f727b650c65650dd5ce89"}], "stats": {"total": 1006, "additions": 656, "deletions": 350}, "files": [{"sha": "a0552f8c60d8f3ac7c2a0424a465441d0a2e6ecc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "patch": "@@ -1,3 +1,42 @@\n+2018-08-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp (zero_nonzero_bits_from_bounds): Rename to...\n+\t(wide_int_set_zero_nonzero_bits): ...this.\n+\t(zero_nonzero_bits_from_vr): Rename to...\n+\t(vrp_set_zero_nonzero_bits): ...this.\n+\t(extract_range_from_multiplicative_op_1): Abstract wide int\n+\tcode...\n+\t(wide_int_range_multiplicative_op): ...here.\n+\t(extract_range_from_binary_expr_1): Extract wide int binary\n+\toperations into their own functions.\n+\t(wide_int_range_lshift): New.\n+\t(wide_int_range_can_optimize_bit_op): New.\n+\t(wide_int_range_shift_undefined_p): New.\n+\t(wide_int_range_bit_xor): New.\n+\t(wide_int_range_bit_ior): New.\n+\t(wide_int_range_bit_and): New.\n+\t(wide_int_range_trunc_mod): New.\n+\t(extract_range_into_wide_ints): New.\n+\t(vrp_shift_undefined_p): New.\n+\t(extract_range_from_multiplicative_op): New.\n+\t(vrp_can_optimize_bit_op): New.\n+\t* tree-vrp.h (value_range::dump): New.\n+\t(wide_int_range_multiplicative_op): New.\n+\t(wide_int_range_lshift):New.\n+\t(wide_int_range_shift_undefined_p): New.\n+\t(wide_int_range_bit_xor): New.\n+\t(wide_int_range_bit_ior): New.\n+\t(wide_int_range_bit_and): New.\n+\t(wide_int_range_trunc_mod): New.\n+\t(zero_nonzero_bits_from_bounds): Rename to...\n+\t(wide_int_set_zero_nonzero_bits): ...this.\n+\t(zero_nonzero_bits_from_vr): Rename to...\n+\t(vrp_set_zero_nonzero_bits): ...this.\n+\t(range_easy_mask_min_max): Rename to...\n+\t(wide_int_range_can_optimize_bit_op): this.\n+\t* vr-values.c (simplify_bit_ops_using_ranges): Rename\n+\tzero_nonzero_bits_from_vr into vrp_set_zero_nonzero_bits.\n+\n 2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_orig_stmt): New function."}, {"sha": "d18c72d0a021ce3773ffe47e01dae69aa98da8fd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 547, "deletions": 341, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "patch": "@@ -1008,45 +1008,54 @@ wide_int_binop_overflow (wide_int &res,\n   return !overflow;\n }\n \n-/* For range [LB, UB] compute two wide_int bitmasks.  In *MAY_BE_NONZERO\n-   bitmask, if some bit is unset, it means for all numbers in the range\n-   the bit is 0, otherwise it might be 0 or 1.  In *MUST_BE_NONZERO\n-   bitmask, if some bit is set, it means for all numbers in the range\n-   the bit is 1, otherwise it might be 0 or 1.  */\n+/* For range [LB, UB] compute two wide_int bit masks.\n+\n+   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n+   for all numbers in the range the bit is 0, otherwise it might be 0\n+   or 1.\n+\n+   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n+   for all numbers in the range the bit is 1, otherwise it might be 0\n+   or 1.  */\n \n void\n-zero_nonzero_bits_from_bounds (signop sign,\n-\t\t\t       const wide_int &lb, const wide_int &ub,\n-\t\t\t       wide_int *may_be_nonzero,\n-\t\t\t       wide_int *must_be_nonzero)\n+wide_int_set_zero_nonzero_bits (signop sign,\n+\t\t\t\tconst wide_int &lb, const wide_int &ub,\n+\t\t\t\twide_int &may_be_nonzero,\n+\t\t\t\twide_int &must_be_nonzero)\n {\n-  *may_be_nonzero = wi::minus_one (lb.get_precision ());\n-  *must_be_nonzero = wi::zero (lb.get_precision ());\n+  may_be_nonzero = wi::minus_one (lb.get_precision ());\n+  must_be_nonzero = wi::zero (lb.get_precision ());\n \n   if (wi::eq_p (lb, ub))\n     {\n-      *may_be_nonzero = lb;\n-      *must_be_nonzero = *may_be_nonzero;\n+      may_be_nonzero = lb;\n+      must_be_nonzero = may_be_nonzero;\n     }\n   else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n     {\n       wide_int xor_mask = lb ^ ub;\n-      *may_be_nonzero = lb | ub;\n-      *must_be_nonzero = lb & ub;\n+      may_be_nonzero = lb | ub;\n+      must_be_nonzero = lb & ub;\n       if (xor_mask != 0)\n \t{\n \t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n-\t\t\t\t    may_be_nonzero->get_precision ());\n-\t  *may_be_nonzero = *may_be_nonzero | mask;\n-\t  *must_be_nonzero = wi::bit_and_not (*must_be_nonzero, mask);\n+\t\t\t\t    may_be_nonzero.get_precision ());\n+\t  may_be_nonzero = may_be_nonzero | mask;\n+\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n \t}\n     }\n }\n \n-/* Like zero_nonzero_bits_from_bounds, but use the range in value_range VR.  */\n+/* Value range wrapper for wide_int_set_zero_nonzero_bits.\n+\n+   Compute MAY_BE_NONZERO and MUST_BE_NONZERO bit masks for range in VR.\n+\n+   Return TRUE if VR was a constant range and we were able to compute\n+   the bit masks.  */\n \n bool\n-zero_nonzero_bits_from_vr (const tree expr_type,\n+vrp_set_zero_nonzero_bits (const tree expr_type,\n \t\t\t   value_range *vr,\n \t\t\t   wide_int *may_be_nonzero,\n \t\t\t   wide_int *must_be_nonzero)\n@@ -1057,10 +1066,9 @@ zero_nonzero_bits_from_vr (const tree expr_type,\n       *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n       return false;\n     }\n-\n-  zero_nonzero_bits_from_bounds (TYPE_SIGN (expr_type),\n+  wide_int_set_zero_nonzero_bits (TYPE_SIGN (expr_type),\n \t\t\t\t wi::to_wide (vr->min), wi::to_wide (vr->max),\n-\t\t\t\t may_be_nonzero, must_be_nonzero);\n+\t\t\t\t *may_be_nonzero, *must_be_nonzero);\n   return true;\n }\n \n@@ -1177,7 +1185,9 @@ wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n      [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]\n \n    This is basically fancy code so we don't drop to varying with an\n-   unsigned [-3,-1]*[-3,-1].  */\n+   unsigned [-3,-1]*[-3,-1].\n+\n+   Return TRUE if we were able to perform the operation.  */\n \n bool\n wide_int_range_mult_wrapping (wide_int &res_lb,\n@@ -1249,13 +1259,27 @@ wide_int_range_mult_wrapping (wide_int &res_lb,\n   return true;\n }\n \n-/* Helper to extract a value-range *VR for a multiplicative operation\n-   *VR0 CODE *VR1.  */\n+/* Perform multiplicative operation CODE on two ranges:\n \n-static void\n-extract_range_from_multiplicative_op_1 (value_range *vr,\n-\t\t\t\t\tenum tree_code code,\n-\t\t\t\t\tvalue_range *vr0, value_range *vr1)\n+     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] .CODE. [VR1_LB, VR1_LB]\n+\n+   Return TRUE if we were able to perform the operation.\n+\n+   NOTE: If code is MULT_EXPR and TYPE_OVERFLOW_WRAPS, the resulting\n+   range must be canonicalized by the caller because its components\n+   may be swapped.  */\n+\n+bool\n+wide_int_range_multiplicative_op (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t  enum tree_code code,\n+\t\t\t\t  signop sign,\n+\t\t\t\t  unsigned prec,\n+\t\t\t\t  const wide_int &vr0_lb,\n+\t\t\t\t  const wide_int &vr0_ub,\n+\t\t\t\t  const wide_int &vr1_lb,\n+\t\t\t\t  const wide_int &vr1_ub,\n+\t\t\t\t  bool overflow_undefined,\n+\t\t\t\t  bool overflow_wraps)\n {\n   /* Multiplications, divisions and shifts are a bit tricky to handle,\n      depending on the mix of signs we have in the two ranges, we\n@@ -1269,62 +1293,131 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n      (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n      MAX1) and then figure the smallest and largest values to form\n      the new range.  */\n-  gcc_assert (code == MULT_EXPR\n-\t      || code == TRUNC_DIV_EXPR\n-\t      || code == FLOOR_DIV_EXPR\n-\t      || code == CEIL_DIV_EXPR\n-\t      || code == EXACT_DIV_EXPR\n-\t      || code == ROUND_DIV_EXPR\n-\t      || code == RSHIFT_EXPR\n-\t      || code == LSHIFT_EXPR);\n-  gcc_assert (vr0->type == VR_RANGE\n-\t      && vr0->type == vr1->type);\n+  if (code == MULT_EXPR && overflow_wraps)\n+    return wide_int_range_mult_wrapping (res_lb, res_ub,\n+\t\t\t\t\t sign, prec,\n+\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub);\n+  return wide_int_range_cross_product (res_lb, res_ub,\n+\t\t\t\t       code, sign,\n+\t\t\t\t       vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n+\t\t\t\t       overflow_undefined);\n+}\n \n-  tree type = TREE_TYPE (vr0->min);\n-  wide_int res_lb, res_ub;\n-  wide_int vr0_lb = wi::to_wide (vr0->min);\n-  wide_int vr0_ub = wi::to_wide (vr0->max);\n-  wide_int vr1_lb = wi::to_wide (vr1->min);\n-  wide_int vr1_ub = wi::to_wide (vr1->max);\n-  bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr0->min));\n+/* Perform a left shift operation on two ranges:\n \n-  if (!wide_int_range_cross_product (res_lb, res_ub,\n-\t\t\t\t     code, TYPE_SIGN (type),\n-\t\t\t\t     vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n-\t\t\t\t     overflow_undefined))\n+     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] << [VR1_LB, VR1_LB]\n+\n+   Return TRUE if we were able to perform the operation.\n+\n+   NOTE: The resulting range must be canonicalized by the caller\n+   because its contents components may be swapped.  */\n+\n+bool\n+wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n+\t\t       signop sign, unsigned prec,\n+\t\t       const wide_int &vr0_lb, const wide_int &vr0_ub,\n+\t\t       const wide_int &vr1_lb, const wide_int &vr1_ub,\n+\t\t       bool overflow_undefined, bool overflow_wraps)\n+{\n+  /* Transform left shifts by constants into multiplies.  */\n+  if (wi::eq_p (vr1_lb, vr1_ub))\n     {\n-      set_value_range_to_varying (vr);\n-      return;\n+      int shift = wi::extract_uhwi (vr1_ub, 0, vr1_ub.get_precision ());\n+      wide_int tmp = wi::set_bit_in_zero (shift, prec);\n+      return wide_int_range_multiplicative_op (res_lb, res_ub,\n+\t\t\t\t\t       MULT_EXPR, sign, prec,\n+\t\t\t\t\t       vr0_lb, vr0_ub, tmp, tmp,\n+\t\t\t\t\t       overflow_undefined,\n+\t\t\t\t\t       /*overflow_wraps=*/true);\n+    }\n+\n+  int overflow_pos = prec;\n+  if (sign == SIGNED)\n+    overflow_pos -= 1;\n+  int bound_shift = overflow_pos - vr1_ub.to_shwi ();\n+  /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n+     overflow.  However, for that to happen, vr1.max needs to be\n+     zero, which means vr1 is a singleton range of zero, which\n+     means it should be handled by the previous LSHIFT_EXPR\n+     if-clause.  */\n+  wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n+  wide_int complement = ~(bound - 1);\n+  wide_int low_bound, high_bound;\n+  bool in_bounds = false;\n+  if (sign == UNSIGNED)\n+    {\n+      low_bound = bound;\n+      high_bound = complement;\n+      if (wi::ltu_p (vr0_ub, low_bound))\n+\t{\n+\t  /* [5, 6] << [1, 2] == [10, 24].  */\n+\t  /* We're shifting out only zeroes, the value increases\n+\t     monotonically.  */\n+\t  in_bounds = true;\n+\t}\n+      else if (wi::ltu_p (high_bound, vr0_lb))\n+\t{\n+\t  /* [0xffffff00, 0xffffffff] << [1, 2]\n+\t     == [0xfffffc00, 0xfffffffe].  */\n+\t  /* We're shifting out only ones, the value decreases\n+\t     monotonically.  */\n+\t  in_bounds = true;\n+\t}\n     }\n-  set_value_range (vr, VR_RANGE,\n-\t\t   wide_int_to_tree (type, res_lb),\n-\t\t   wide_int_to_tree (type, res_ub), NULL);\n+  else\n+    {\n+      /* [-1, 1] << [1, 2] == [-4, 4].  */\n+      low_bound = complement;\n+      high_bound = bound;\n+      if (wi::lts_p (vr0_ub, high_bound)\n+\t  && wi::lts_p (low_bound, vr0_lb))\n+\t{\n+\t  /* For non-negative numbers, we're shifting out only\n+\t     zeroes, the value increases monotonically.\n+\t     For negative numbers, we're shifting out only ones, the\n+\t     value decreases monotomically.  */\n+\t  in_bounds = true;\n+\t}\n+    }\n+  if (in_bounds)\n+    return wide_int_range_multiplicative_op (res_lb, res_ub,\n+\t\t\t\t\t     LSHIFT_EXPR, sign, prec,\n+\t\t\t\t\t     vr0_lb, vr0_ub,\n+\t\t\t\t\t     vr1_lb, vr1_ub,\n+\t\t\t\t\t     overflow_undefined,\n+\t\t\t\t\t     overflow_wraps);\n+  return false;\n }\n \n-/* For op & or | attempt to optimize:\n+/* Return TRUE if a bit operation on two ranges can be easily\n+   optimized in terms of a mask.\n+\n+   Basically, for BIT_AND_EXPR or BIT_IOR_EXPR see if we can optimize:\n \n \t[LB, UB] op Z\n    into:\n \t[LB op Z, UB op Z]\n \n-   if Z is a constant which (for op | its bitwise not) has n\n-   consecutive least significant bits cleared followed by m 1\n-   consecutive bits set immediately above it and either\n-   m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n-\n-   The least significant n bits of all the values in the range are\n-   cleared or set, the m bits above it are preserved and any bits\n-   above these are required to be the same for all values in the\n-   range.\n-\n-   Return TRUE if the min and max can simply be folded.  */\n+   It is up to the caller to perform the actual folding above.  */\n \n bool\n-range_easy_mask_min_max (tree_code code,\n-\t\t\t const wide_int &lb, const wide_int &ub,\n-\t\t\t const wide_int &mask)\n+wide_int_range_can_optimize_bit_op (tree_code code,\n+\t\t\t\t    const wide_int &lb, const wide_int &ub,\n+\t\t\t\t    const wide_int &mask)\n \n {\n+  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR)\n+    return false;\n+  /* If Z is a constant which (for op | its bitwise not) has n\n+     consecutive least significant bits cleared followed by m 1\n+     consecutive bits set immediately above it and either\n+     m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n+\n+     The least significant n bits of all the values in the range are\n+     cleared or set, the m bits above it are preserved and any bits\n+     above these are required to be the same for all values in the\n+     range.  */\n+\n   wide_int w = mask;\n   int m = 0, n = 0;\n   if (code == BIT_IOR_EXPR)\n@@ -1347,6 +1440,307 @@ range_easy_mask_min_max (tree_code code,\n   return false;\n }\n \n+/* Return TRUE if shifting by range [MIN, MAX] is undefined behavior.\n+\n+   FIXME: Make this inline when it moves outside of tree-vrp.  */\n+\n+bool\n+wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n+\t\t\t\t  const wide_int &min, const wide_int &max)\n+{\n+  /* ?? Note: The original comment said this only applied to\n+     RSHIFT_EXPR, but it was being applied to both left and right\n+     shifts.  Is this OK?  */\n+\n+  /* Shifting by any values outside [0..prec-1], gets undefined\n+     behavior from the shift operation.  We cannot even trust\n+     SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n+     shifts, and the operation at the tree level may be widened.  */\n+  return wi::lt_p (min, 0, sign) || wi::ge_p (max, prec, sign);\n+}\n+\n+/* Calculate the XOR of two ranges and store the result in [WMIN,WMAX].\n+   The two input ranges are described by their MUST_BE_NONZERO and\n+   MAY_BE_NONZERO bit masks.\n+\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tunsigned prec,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n+\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n+  wide_int result_one_bits\n+    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n+       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n+  wmax = ~result_zero_bits;\n+  wmin = result_one_bits;\n+  /* If the range has all positive or all negative values, the result\n+     is better than VARYING.  */\n+  if (wi::lt_p (wmin, 0, sign) || wi::ge_p (wmax, 0, sign))\n+    return true;\n+  wmin = wi::min_value (prec, sign);\n+  wmax = wi::max_value (prec, sign);\n+  return false;\n+}\n+\n+/* Calculate the IOR of two ranges and store the result in [WMIN,WMAX].\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tconst wide_int &vr0_min,\n+\t\t\tconst wide_int &vr0_max,\n+\t\t\tconst wide_int &vr1_min,\n+\t\t\tconst wide_int &vr1_max,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wmin = must_be_nonzero0 | must_be_nonzero1;\n+  wmax = may_be_nonzero0 | may_be_nonzero1;\n+  /* If the input ranges contain only positive values we can\n+     truncate the minimum of the result range to the maximum\n+     of the input range minima.  */\n+  if (wi::ge_p (vr0_min, 0, sign)\n+      && wi::ge_p (vr1_min, 0, sign))\n+    {\n+      wmin = wi::max (wmin, vr0_min, sign);\n+      wmin = wi::max (wmin, vr1_min, sign);\n+    }\n+  /* If either input range contains only negative values\n+     we can truncate the minimum of the result range to the\n+     respective minimum range.  */\n+  if (wi::lt_p (vr0_max, 0, sign))\n+    wmin = wi::max (wmin, vr0_min, sign);\n+  if (wi::lt_p (vr1_max, 0, sign))\n+    wmin = wi::max (wmin, vr1_min, sign);\n+  /* If the limits got swapped around, indicate error so we can adjust\n+     the range to VARYING.  */\n+  if (wi::gt_p (wmin, wmax,sign))\n+    return false;\n+  return true;\n+}\n+\n+/* Calculate the bitwise AND of two ranges and store the result in [WMIN,WMAX].\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tunsigned prec,\n+\t\t\tconst wide_int &vr0_min,\n+\t\t\tconst wide_int &vr0_max,\n+\t\t\tconst wide_int &vr1_min,\n+\t\t\tconst wide_int &vr1_max,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wmin = must_be_nonzero0 & must_be_nonzero1;\n+  wmax = may_be_nonzero0 & may_be_nonzero1;\n+  /* If both input ranges contain only negative values we can\n+     truncate the result range maximum to the minimum of the\n+     input range maxima.  */\n+  if (wi::lt_p (vr0_max, 0, sign) && wi::lt_p (vr1_max, 0, sign))\n+    {\n+      wmax = wi::min (wmax, vr0_max, sign);\n+      wmax = wi::min (wmax, vr1_max, sign);\n+    }\n+  /* If either input range contains only non-negative values\n+     we can truncate the result range maximum to the respective\n+     maximum of the input range.  */\n+  if (wi::ge_p (vr0_min, 0, sign))\n+    wmax = wi::min (wmax, vr0_max, sign);\n+  if (wi::ge_p (vr1_min, 0, sign))\n+    wmax = wi::min (wmax, vr1_max, sign);\n+  /* PR68217: In case of signed & sign-bit-CST should\n+     result in [-INF, 0] instead of [-INF, INF].  */\n+  if (wi::gt_p (wmin, wmax, sign))\n+    {\n+      wide_int sign_bit = wi::set_bit_in_zero (prec - 1, prec);\n+      if (sign == SIGNED\n+\t  && ((wi::eq_p (vr0_min, vr0_max)\n+\t       && !wi::cmps (vr0_min, sign_bit))\n+\t      || (wi::eq_p (vr1_min, vr1_max)\n+\t\t  && !wi::cmps (vr1_min, sign_bit))))\n+\t{\n+\t  wmin = wi::min_value (prec, sign);\n+\t  wmax = wi::zero (prec);\n+\t}\n+    }\n+  /* If the limits got swapped around, indicate error so we can adjust\n+     the range to VARYING.  */\n+  if (wi::gt_p (wmin, wmax,sign))\n+    return false;\n+  return true;\n+}\n+\n+/* Calculate TRUNC_MOD_EXPR on two ranges and store the result in\n+   [WMIN,WMAX].  */\n+\n+void\n+wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n+\t\t\t  signop sign,\n+\t\t\t  unsigned prec,\n+\t\t\t  const wide_int &vr0_min,\n+\t\t\t  const wide_int &vr0_max,\n+\t\t\t  const wide_int &vr1_min,\n+\t\t\t  const wide_int &vr1_max)\n+{\n+  wide_int tmp;\n+\n+  /* ABS (A % B) < ABS (B) and either\n+     0 <= A % B <= A or A <= A % B <= 0.  */\n+  wmax = vr1_max - 1;\n+  if (sign == SIGNED)\n+    {\n+      tmp = -1 - vr1_min;\n+      wmax = wi::smax (wmax, tmp);\n+    }\n+\n+  if (sign == UNSIGNED)\n+    wmin = wi::zero (prec);\n+  else\n+    {\n+      wmin = -wmax;\n+      tmp = vr0_min;\n+      if (wi::gts_p (tmp, 0))\n+\ttmp = wi::zero (prec);\n+      wmin = wi::smax (wmin, tmp);\n+    }\n+  tmp = vr0_max;\n+  if (sign == SIGNED && wi::neg_p (tmp))\n+    tmp = wi::zero (prec);\n+  wmax = wi::min (wmax, tmp, sign);\n+}\n+\n+/* Extract the components of a value range into a pair of wide ints in\n+   [WMIN, WMAX].\n+\n+   If the value range is anything but a VR_RANGE of constants, the\n+   resulting wide ints are set to [-MIN, +MAX] for the type.  */\n+\n+static void inline\n+extract_range_into_wide_ints (value_range *vr,\n+\t\t\t      signop sign, unsigned prec,\n+\t\t\t      wide_int *wmin, wide_int *wmax)\n+{\n+  if (range_int_cst_p (vr))\n+    {\n+      *wmin = wi::to_wide (vr->min);\n+      *wmax = wi::to_wide (vr->max);\n+    }\n+  else\n+    {\n+      *wmin = wi::min_value (prec, sign);\n+      *wmax = wi::max_value (prec, sign);\n+    }\n+}\n+\n+/* Value range wrapper for wide_int_range_shift_undefined_p.  */\n+\n+static inline bool\n+vrp_shift_undefined_p (const value_range &shifter, unsigned prec)\n+{\n+  tree type = TREE_TYPE (shifter.min);\n+  return wide_int_range_shift_undefined_p (TYPE_SIGN (type), prec,\n+\t\t\t\t\t   wi::to_wide (shifter.min),\n+\t\t\t\t\t   wi::to_wide (shifter.max));\n+}\n+\n+/* Value range wrapper for wide_int_range_multiplicative_op:\n+\n+     *VR = *VR0 .CODE. *VR1.  */\n+\n+static void\n+extract_range_from_multiplicative_op (value_range *vr,\n+\t\t\t\t      enum tree_code code,\n+\t\t\t\t      value_range *vr0, value_range *vr1)\n+{\n+  gcc_assert (code == MULT_EXPR\n+\t      || code == TRUNC_DIV_EXPR\n+\t      || code == FLOOR_DIV_EXPR\n+\t      || code == CEIL_DIV_EXPR\n+\t      || code == EXACT_DIV_EXPR\n+\t      || code == ROUND_DIV_EXPR\n+\t      || code == RSHIFT_EXPR\n+\t      || code == LSHIFT_EXPR);\n+  gcc_assert (vr0->type == VR_RANGE && vr0->type == vr1->type);\n+\n+  tree type = TREE_TYPE (vr0->min);\n+  wide_int res_lb, res_ub;\n+  wide_int vr0_lb = wi::to_wide (vr0->min);\n+  wide_int vr0_ub = wi::to_wide (vr0->max);\n+  wide_int vr1_lb = wi::to_wide (vr1->min);\n+  wide_int vr1_ub = wi::to_wide (vr1->max);\n+  bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (type);\n+  bool overflow_wraps = TYPE_OVERFLOW_WRAPS (type);\n+  unsigned prec = TYPE_PRECISION (type);\n+\n+  if (wide_int_range_multiplicative_op (res_lb, res_ub,\n+\t\t\t\t\t code, TYPE_SIGN (type), prec,\n+\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n+\t\t\t\t\t overflow_undefined, overflow_wraps))\n+    set_and_canonicalize_value_range (vr, VR_RANGE,\n+\t\t\t\t      wide_int_to_tree (type, res_lb),\n+\t\t\t\t      wide_int_to_tree (type, res_ub), NULL);\n+  else\n+    set_value_range_to_varying (vr);\n+}\n+\n+/* Value range wrapper for wide_int_range_can_optimize_bit_op.\n+\n+   If a bit operation on two ranges can be easily optimized in terms\n+   of a mask, store the optimized new range in VR and return TRUE.  */\n+\n+static bool\n+vrp_can_optimize_bit_op (value_range *vr, enum tree_code code,\n+\t\t\t value_range *vr0, value_range *vr1)\n+{\n+  tree lower_bound, upper_bound, mask;\n+  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR)\n+    return false;\n+  if (range_int_cst_singleton_p (vr1))\n+    {\n+      if (!range_int_cst_p (vr0))\n+\treturn false;\n+      mask = vr1->min;\n+      lower_bound = vr0->min;\n+      upper_bound = vr0->max;\n+    }\n+  else if (range_int_cst_singleton_p (vr0))\n+    {\n+      if (!range_int_cst_p (vr1))\n+\treturn false;\n+      mask = vr0->min;\n+      lower_bound = vr1->min;\n+      upper_bound = vr1->max;\n+    }\n+  else\n+    return false;\n+  if (wide_int_range_can_optimize_bit_op (code,\n+\t\t\t\t\t  wi::to_wide (lower_bound),\n+\t\t\t\t\t  wi::to_wide (upper_bound),\n+\t\t\t\t\t  wi::to_wide (mask)))\n+    {\n+      tree min = int_const_binop (code, lower_bound, mask);\n+      tree max = int_const_binop (code, upper_bound, mask);\n+      set_value_range (vr, VR_RANGE, min, max, NULL);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* If BOUND will include a symbolic bound, adjust it accordingly,\n    otherwise leave it as is.\n \n@@ -1522,6 +1916,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t\t\t  enum tree_code code, tree expr_type,\n \t\t\t\t  value_range *vr0_, value_range *vr1_)\n {\n+  signop sign = TYPE_SIGN (expr_type);\n+  unsigned int prec = TYPE_PRECISION (expr_type);\n   value_range vr0 = *vr0_, vr1 = *vr1_;\n   value_range vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n   enum value_range_type type;\n@@ -1845,40 +2241,14 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n-      if (TYPE_OVERFLOW_WRAPS (expr_type))\n-\t{\n-\t  signop sign = TYPE_SIGN (expr_type);\n-\t  unsigned int prec = TYPE_PRECISION (expr_type);\n-\t  wide_int res_lb, res_ub;\n-\t  if (!wide_int_range_mult_wrapping (res_lb, res_ub,\n-\t\t\t\t\t     sign, prec,\n-\t\t\t\t\t     wi::to_wide (vr0.min),\n-\t\t\t\t\t     wi::to_wide (vr0.max),\n-\t\t\t\t\t     wi::to_wide (vr1.min),\n-\t\t\t\t\t     wi::to_wide (vr1.max)))\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n-\t  min = wide_int_to_tree (expr_type, res_lb);\n-\t  max = wide_int_to_tree (expr_type, res_ub);\n-\t  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n-\t  return;\n-\t}\n-      extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+      extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n       return;\n     }\n   else if (code == RSHIFT_EXPR\n \t   || code == LSHIFT_EXPR)\n     {\n-      /* If we have a RSHIFT_EXPR with any shift values outside [0..prec-1],\n-\t then drop to VR_VARYING.  Outside of this range we get undefined\n-\t behavior from the shift operation.  We cannot even trust\n-\t SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n-\t shifts, and the operation at the tree level may be widened.  */\n       if (range_int_cst_p (&vr1)\n-\t  && compare_tree_int (vr1.min, 0) >= 0\n-\t  && compare_tree_int (vr1.max, TYPE_PRECISION (expr_type)) == -1)\n+\t  && !vrp_shift_undefined_p (vr1, prec))\n \t{\n \t  if (code == RSHIFT_EXPR)\n \t    {\n@@ -1891,91 +2261,25 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t  vr0.min = vrp_val_min (expr_type);\n \t\t  vr0.max = vrp_val_max (expr_type);\n \t\t}\n-\t      extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n-\t      return;\n-\t    }\n-\t  /* We can map lshifts by constants to MULT_EXPR handling.  */\n-\t  else if (code == LSHIFT_EXPR\n-\t\t   && range_int_cst_singleton_p (&vr1))\n-\t    {\n-\t      bool saved_flag_wrapv;\n-\t      value_range vr1p = VR_INITIALIZER;\n-\t      vr1p.type = VR_RANGE;\n-\t      vr1p.min = (wide_int_to_tree\n-\t\t\t  (expr_type,\n-\t\t\t   wi::set_bit_in_zero (tree_to_shwi (vr1.min),\n-\t\t\t\t\t\tTYPE_PRECISION (expr_type))));\n-\t      vr1p.max = vr1p.min;\n-\t      /* We have to use a wrapping multiply though as signed overflow\n-\t\t on lshifts is implementation defined in C89.  */\n-\t      saved_flag_wrapv = flag_wrapv;\n-\t      flag_wrapv = 1;\n-\t      extract_range_from_binary_expr_1 (vr, MULT_EXPR, expr_type,\n-\t\t\t\t\t\t&vr0, &vr1p);\n-\t      flag_wrapv = saved_flag_wrapv;\n+\t      extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n \t      return;\n \t    }\n \t  else if (code == LSHIFT_EXPR\n \t\t   && range_int_cst_p (&vr0))\n \t    {\n-\t      int prec = TYPE_PRECISION (expr_type);\n-\t      int overflow_pos = prec;\n-\t      int bound_shift;\n-\t      wide_int low_bound, high_bound;\n-\t      bool uns = TYPE_UNSIGNED (expr_type);\n-\t      bool in_bounds = false;\n-\n-\t      if (!uns)\n-\t\toverflow_pos -= 1;\n-\n-\t      bound_shift = overflow_pos - tree_to_shwi (vr1.max);\n-\t      /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n-\t\t overflow.  However, for that to happen, vr1.max needs to be\n-\t\t zero, which means vr1 is a singleton range of zero, which\n-\t\t means it should be handled by the previous LSHIFT_EXPR\n-\t\t if-clause.  */\n-\t      wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n-\t      wide_int complement = ~(bound - 1);\n-\n-\t      if (uns)\n-\t\t{\n-\t\t  low_bound = bound;\n-\t\t  high_bound = complement;\n-\t\t  if (wi::ltu_p (wi::to_wide (vr0.max), low_bound))\n-\t\t    {\n-\t\t      /* [5, 6] << [1, 2] == [10, 24].  */\n-\t\t      /* We're shifting out only zeroes, the value increases\n-\t\t\t monotonically.  */\n-\t\t      in_bounds = true;\n-\t\t    }\n-\t\t  else if (wi::ltu_p (high_bound, wi::to_wide (vr0.min)))\n-\t\t    {\n-\t\t      /* [0xffffff00, 0xffffffff] << [1, 2]\n-\t\t         == [0xfffffc00, 0xfffffffe].  */\n-\t\t      /* We're shifting out only ones, the value decreases\n-\t\t\t monotonically.  */\n-\t\t      in_bounds = true;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* [-1, 1] << [1, 2] == [-4, 4].  */\n-\t\t  low_bound = complement;\n-\t\t  high_bound = bound;\n-\t\t  if (wi::lts_p (wi::to_wide (vr0.max), high_bound)\n-\t\t      && wi::lts_p (low_bound, wi::to_wide (vr0.min)))\n-\t\t    {\n-\t\t      /* For non-negative numbers, we're shifting out only\n-\t\t\t zeroes, the value increases monotonically.\n-\t\t\t For negative numbers, we're shifting out only ones, the\n-\t\t\t value decreases monotomically.  */\n-\t\t      in_bounds = true;\n-\t\t    }\n-\t\t}\n-\n-\t      if (in_bounds)\n+\t      wide_int res_lb, res_ub;\n+\t      if (wide_int_range_lshift (res_lb, res_ub, sign, prec,\n+\t\t\t\t\t wi::to_wide (vr0.min),\n+\t\t\t\t\t wi::to_wide (vr0.max),\n+\t\t\t\t\t wi::to_wide (vr1.min),\n+\t\t\t\t\t wi::to_wide (vr1.max),\n+\t\t\t\t\t TYPE_OVERFLOW_UNDEFINED (expr_type),\n+\t\t\t\t\t TYPE_OVERFLOW_WRAPS (expr_type)))\n \t\t{\n-\t\t  extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+\t\t  min = wide_int_to_tree (expr_type, res_lb);\n+\t\t  max = wide_int_to_tree (expr_type, res_ub);\n+\t\t  set_and_canonicalize_value_range (vr, VR_RANGE,\n+\t\t\t\t\t\t    min, max, NULL);\n \t\t  return;\n \t\t}\n \t    }\n@@ -2089,7 +2393,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t}\n       else if (range_int_cst_p (&vr0) && range_int_cst_p (&vr1))\n \t{\n-\t  extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+\t  extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n \t  return;\n \t}\n     }\n@@ -2100,187 +2404,83 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  set_value_range_to_undefined (vr);\n \t  return;\n \t}\n-      /* ABS (A % B) < ABS (B) and either\n-\t 0 <= A % B <= A or A <= A % B <= 0.  */\n-      type = VR_RANGE;\n-      signop sgn = TYPE_SIGN (expr_type);\n-      unsigned int prec = TYPE_PRECISION (expr_type);\n       wide_int wmin, wmax, tmp;\n-      if (vr1.type == VR_RANGE && !symbolic_range_p (&vr1))\n-\t{\n-\t  wmax = wi::to_wide (vr1.max) - 1;\n-\t  if (sgn == SIGNED)\n-\t    {\n-\t      tmp = -1 - wi::to_wide (vr1.min);\n-\t      wmax = wi::smax (wmax, tmp);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  wmax = wi::max_value (prec, sgn);\n-\t  /* X % INT_MIN may be INT_MAX.  */\n-\t  if (sgn == UNSIGNED)\n-\t    wmax = wmax - 1;\n-\t}\n-\n-      if (sgn == UNSIGNED)\n-\twmin = wi::zero (prec);\n-      else\n-\t{\n-\t  wmin = -wmax;\n-\t  if (vr0.type == VR_RANGE && TREE_CODE (vr0.min) == INTEGER_CST)\n-\t    {\n-\t      tmp = wi::to_wide (vr0.min);\n-\t      if (wi::gts_p (tmp, 0))\n-\t\ttmp = wi::zero (prec);\n-\t      wmin = wi::smax (wmin, tmp);\n-\t    }\n-\t}\n-\n-      if (vr0.type == VR_RANGE && TREE_CODE (vr0.max) == INTEGER_CST)\n-\t{\n-\t  tmp = wi::to_wide (vr0.max);\n-\t  if (sgn == SIGNED && wi::neg_p (tmp))\n-\t    tmp = wi::zero (prec);\n-\t  wmax = wi::min (wmax, tmp, sgn);\n-\t}\n-\n+      wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n+      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      wide_int_range_trunc_mod (wmin, wmax, sign, prec,\n+\t\t\t\tvr0_min, vr0_max, vr1_min, vr1_max);\n       min = wide_int_to_tree (expr_type, wmin);\n       max = wide_int_to_tree (expr_type, wmax);\n+      set_value_range (vr, VR_RANGE, min, max, NULL);\n+      return;\n     }\n   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)\n     {\n-      bool int_cst_range0, int_cst_range1;\n+      if (vrp_can_optimize_bit_op (vr, code, &vr0, &vr1))\n+\treturn;\n+\n       wide_int may_be_nonzero0, may_be_nonzero1;\n       wide_int must_be_nonzero0, must_be_nonzero1;\n-\n-      int_cst_range0 = zero_nonzero_bits_from_vr (expr_type, &vr0,\n-\t\t\t\t\t\t  &may_be_nonzero0,\n-\t\t\t\t\t\t  &must_be_nonzero0);\n-      int_cst_range1 = zero_nonzero_bits_from_vr (expr_type, &vr1,\n-\t\t\t\t\t\t  &may_be_nonzero1,\n-\t\t\t\t\t\t  &must_be_nonzero1);\n-\n-      if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n-\t{\n-\t  value_range *vr0p = NULL, *vr1p = NULL;\n-\t  if (range_int_cst_singleton_p (&vr1))\n-\t    {\n-\t      vr0p = &vr0;\n-\t      vr1p = &vr1;\n-\t    }\n-\t  else if (range_int_cst_singleton_p (&vr0))\n+      wide_int wmin, wmax;\n+      wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n+      vrp_set_zero_nonzero_bits (expr_type, &vr0,\n+\t\t\t\t &may_be_nonzero0, &must_be_nonzero0);\n+      vrp_set_zero_nonzero_bits (expr_type, &vr1,\n+\t\t\t\t &may_be_nonzero1, &must_be_nonzero1);\n+      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      if (code == BIT_AND_EXPR)\n+\t{\n+\t  if (wide_int_range_bit_and (wmin, wmax, sign, prec,\n+\t\t\t\t      vr0_min, vr0_max,\n+\t\t\t\t      vr1_min, vr1_max,\n+\t\t\t\t      must_be_nonzero0,\n+\t\t\t\t      may_be_nonzero0,\n+\t\t\t\t      must_be_nonzero1,\n+\t\t\t\t      may_be_nonzero1))\n \t    {\n-\t      vr0p = &vr1;\n-\t      vr1p = &vr0;\n-\t    }\n-\t  /* For op & or | attempt to optimize:\n-\t     [x, y] op z into [x op z, y op z].  */\n-\t  if (vr0p && range_int_cst_p (vr0p)\n-\t      && range_easy_mask_min_max (code, wi::to_wide (vr0p->min),\n-\t\t\t\t\t  wi::to_wide (vr0p->max),\n-\t\t\t\t\t  wi::to_wide (vr1p->min)))\n-\t    {\n-\t      min = int_const_binop (code, vr0p->min, vr1p->min);\n-\t      max = int_const_binop (code, vr0p->max, vr1p->min);\n-\t    }\n-\t}\n-\n-      type = VR_RANGE;\n-      if (min && max)\n-\t/* Optimized above already.  */;\n-      else if (code == BIT_AND_EXPR)\n-\t{\n-\t  min = wide_int_to_tree (expr_type,\n-\t\t\t\t  must_be_nonzero0 & must_be_nonzero1);\n-\t  wide_int wmax = may_be_nonzero0 & may_be_nonzero1;\n-\t  /* If both input ranges contain only negative values we can\n-\t     truncate the result range maximum to the minimum of the\n-\t     input range maxima.  */\n-\t  if (int_cst_range0 && int_cst_range1\n-\t      && tree_int_cst_sgn (vr0.max) < 0\n-\t      && tree_int_cst_sgn (vr1.max) < 0)\n-\t    {\n-\t      wmax = wi::min (wmax, wi::to_wide (vr0.max),\n-\t\t\t      TYPE_SIGN (expr_type));\n-\t      wmax = wi::min (wmax, wi::to_wide (vr1.max),\n-\t\t\t      TYPE_SIGN (expr_type));\n-\t    }\n-\t  /* If either input range contains only non-negative values\n-\t     we can truncate the result range maximum to the respective\n-\t     maximum of the input range.  */\n-\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n-\t    wmax = wi::min (wmax, wi::to_wide (vr0.max),\n-\t\t\t    TYPE_SIGN (expr_type));\n-\t  if (int_cst_range1 && tree_int_cst_sgn (vr1.min) >= 0)\n-\t    wmax = wi::min (wmax, wi::to_wide (vr1.max),\n-\t\t\t    TYPE_SIGN (expr_type));\n-\t  max = wide_int_to_tree (expr_type, wmax);\n-\t  cmp = compare_values (min, max);\n-\t  /* PR68217: In case of signed & sign-bit-CST should\n-\t     result in [-INF, 0] instead of [-INF, INF].  */\n-\t  if (cmp == -2 || cmp == 1)\n-\t    {\n-\t      wide_int sign_bit\n-\t\t= wi::set_bit_in_zero (TYPE_PRECISION (expr_type) - 1,\n-\t\t\t\t       TYPE_PRECISION (expr_type));\n-\t      if (!TYPE_UNSIGNED (expr_type)\n-\t\t  && ((int_cst_range0\n-\t\t       && value_range_constant_singleton (&vr0)\n-\t\t       && !wi::cmps (wi::to_wide (vr0.min), sign_bit))\n-\t\t      || (int_cst_range1\n-\t\t\t  && value_range_constant_singleton (&vr1)\n-\t\t\t  && !wi::cmps (wi::to_wide (vr1.min), sign_bit))))\n-\t\t{\n-\t\t  min = TYPE_MIN_VALUE (expr_type);\n-\t\t  max = build_int_cst (expr_type, 0);\n-\t\t}\n+\t      min = wide_int_to_tree (expr_type, wmin);\n+\t      max = wide_int_to_tree (expr_type, wmax);\n+\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n \t    }\n+\t  else\n+\t    set_value_range_to_varying (vr);\n+\t  return;\n \t}\n       else if (code == BIT_IOR_EXPR)\n \t{\n-\t  max = wide_int_to_tree (expr_type,\n-\t\t\t\t  may_be_nonzero0 | may_be_nonzero1);\n-\t  wide_int wmin = must_be_nonzero0 | must_be_nonzero1;\n-\t  /* If the input ranges contain only positive values we can\n-\t     truncate the minimum of the result range to the maximum\n-\t     of the input range minima.  */\n-\t  if (int_cst_range0 && int_cst_range1\n-\t      && tree_int_cst_sgn (vr0.min) >= 0\n-\t      && tree_int_cst_sgn (vr1.min) >= 0)\n+\t  if (wide_int_range_bit_ior (wmin, wmax, sign,\n+\t\t\t\t      vr0_min, vr0_max,\n+\t\t\t\t      vr1_min, vr1_max,\n+\t\t\t\t      must_be_nonzero0,\n+\t\t\t\t      may_be_nonzero0,\n+\t\t\t\t      must_be_nonzero1,\n+\t\t\t\t      may_be_nonzero1))\n \t    {\n-\t      wmin = wi::max (wmin, wi::to_wide (vr0.min),\n-\t\t\t      TYPE_SIGN (expr_type));\n-\t      wmin = wi::max (wmin, wi::to_wide (vr1.min),\n-\t\t\t      TYPE_SIGN (expr_type));\n+\t      min = wide_int_to_tree (expr_type, wmin);\n+\t      max = wide_int_to_tree (expr_type, wmax);\n+\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n \t    }\n-\t  /* If either input range contains only negative values\n-\t     we can truncate the minimum of the result range to the\n-\t     respective minimum range.  */\n-\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.max) < 0)\n-\t    wmin = wi::max (wmin, wi::to_wide (vr0.min),\n-\t\t\t    TYPE_SIGN (expr_type));\n-\t  if (int_cst_range1 && tree_int_cst_sgn (vr1.max) < 0)\n-\t    wmin = wi::max (wmin, wi::to_wide (vr1.min),\n-\t\t\t    TYPE_SIGN (expr_type));\n-\t  min = wide_int_to_tree (expr_type, wmin);\n+\t  else\n+\t    set_value_range_to_varying (vr);\n+\t  return;\n \t}\n       else if (code == BIT_XOR_EXPR)\n \t{\n-\t  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n-\t\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n-\t  wide_int result_one_bits\n-\t    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n-\t       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n-\t  max = wide_int_to_tree (expr_type, ~result_zero_bits);\n-\t  min = wide_int_to_tree (expr_type, result_one_bits);\n-\t  /* If the range has all positive or all negative values the\n-\t     result is better than VARYING.  */\n-\t  if (tree_int_cst_sgn (min) < 0\n-\t      || tree_int_cst_sgn (max) >= 0)\n-\t    ;\n+\t  if (wide_int_range_bit_xor (wmin, wmax, sign, prec,\n+\t\t\t\t      must_be_nonzero0,\n+\t\t\t\t      may_be_nonzero0,\n+\t\t\t\t      must_be_nonzero1,\n+\t\t\t\t      may_be_nonzero1))\n+\t    {\n+\t      min = wide_int_to_tree (expr_type, wmin);\n+\t      max = wide_int_to_tree (expr_type, wmax);\n+\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n+\t    }\n \t  else\n-\t    max = min = NULL_TREE;\n+\t    set_value_range_to_varying (vr);\n+\t  return;\n \t}\n     }\n   else\n@@ -2608,6 +2808,12 @@ debug_value_range (value_range *vr)\n   fprintf (stderr, \"\\n\");\n }\n \n+void\n+value_range::dump ()\n+{\n+  debug_value_range (this);\n+}\n+\n \n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n    create a new SSA name N and return the assertion assignment"}, {"sha": "8cac7daada7a964f09ada4d4a5108feeb8e7cfbd", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "patch": "@@ -49,6 +49,9 @@ struct GTY((for_user)) value_range\n   /* Set of SSA names whose value ranges are equivalent to this one.\n      This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n   bitmap equiv;\n+\n+  /* Dump value range to stderr.  */\n+  void dump ();\n };\n \n extern void vrp_intersect_ranges (value_range *vr0, value_range *vr1);\n@@ -115,6 +118,70 @@ extern bool wide_int_range_mult_wrapping (wide_int &res_lb,\n \t\t\t\t\t  const wide_int &max0_,\n \t\t\t\t\t  const wide_int &min1_,\n \t\t\t\t\t  const wide_int &max1_);\n+extern bool wide_int_range_multiplicative_op (wide_int &res_lb,\n+\t\t\t\t\t      wide_int &res_ub,\n+\t\t\t\t\t      enum tree_code code,\n+\t\t\t\t\t      signop sign,\n+\t\t\t\t\t      unsigned prec,\n+\t\t\t\t\t      const wide_int &vr0_lb,\n+\t\t\t\t\t      const wide_int &vr0_ub,\n+\t\t\t\t\t      const wide_int &vr1_lb,\n+\t\t\t\t\t      const wide_int &vr1_ub,\n+\t\t\t\t\t      bool overflow_undefined,\n+\t\t\t\t\t      bool overflow_wraps);\n+extern bool wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t   signop sign, unsigned prec,\n+\t\t\t\t   const wide_int &, const wide_int &,\n+\t\t\t\t   const wide_int &, const wide_int &,\n+\t\t\t\t   bool overflow_undefined,\n+\t\t\t\t   bool overflow_wraps);\n+extern bool wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n+\t\t\t\t\t      const wide_int &min,\n+\t\t\t\t\t      const wide_int &max);\n+extern void wide_int_set_zero_nonzero_bits (signop,\n+\t\t\t\t\t    const wide_int &lb,\n+\t\t\t\t\t    const wide_int &ub,\n+\t\t\t\t\t    wide_int &may_be_nonzero,\n+\t\t\t\t\t    wide_int &must_be_nonzero);\n+extern bool wide_int_range_can_optimize_bit_op (tree_code,\n+\t\t\t\t\t\tconst wide_int &lb,\n+\t\t\t\t\t\tconst wide_int &ub,\n+\t\t\t\t\t\tconst wide_int &mask);\n+extern bool wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    unsigned prec,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern bool wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    const wide_int &vr0_min,\n+\t\t\t\t    const wide_int &vr0_max,\n+\t\t\t\t    const wide_int &vr1_min,\n+\t\t\t\t    const wide_int &vr1_max,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern bool wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    unsigned prec,\n+\t\t\t\t    const wide_int &vr0_min,\n+\t\t\t\t    const wide_int &vr0_max,\n+\t\t\t\t    const wide_int &vr1_min,\n+\t\t\t\t    const wide_int &vr1_max,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern void wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t      signop sign,\n+\t\t\t\t      unsigned prec,\n+\t\t\t\t      const wide_int &vr0_min,\n+\t\t\t\t      const wide_int &vr0_max,\n+\t\t\t\t      const wide_int &vr1_min,\n+\t\t\t\t      const wide_int &vr1_max);\n extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n \t\t\t\t\t      tree, value_range *,\n \t\t\t\t\t      value_range *);\n@@ -125,14 +192,8 @@ extern bool range_int_cst_p (value_range *);\n extern int operand_less_p (tree, tree);\n extern bool find_case_label_range (gswitch *, tree, tree, size_t *, size_t *);\n extern bool find_case_label_index (gswitch *, size_t, tree, size_t *);\n-extern void zero_nonzero_bits_from_bounds (signop, const wide_int&,\n-\t\t\t\t\t   const wide_int&, wide_int *,\n-\t\t\t\t\t   wide_int *);\n-extern bool zero_nonzero_bits_from_vr (const tree, value_range *,\n+extern bool vrp_set_zero_nonzero_bits (const tree, value_range *,\n \t\t\t\t       wide_int *, wide_int *);\n-extern bool range_easy_mask_min_max (tree_code,\n-\t\t\t\t     const wide_int &lb, const wide_int &ub,\n-\t\t\t\t     const wide_int &mask);\n extern bool overflow_comparison_p (tree_code, tree, tree, bool, tree *);\n extern bool range_int_cst_singleton_p (value_range *);\n extern int value_inside_range (tree, tree, tree);"}, {"sha": "33335f3da31da025c61fec40865404f56413f2da", "filename": "gcc/vr-values.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3ca9102eba6eae8944329cd72b74ff460e7b3b/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=cd3ca9102eba6eae8944329cd72b74ff460e7b3b", "patch": "@@ -3300,10 +3300,10 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n   else\n     return false;\n \n-  if (!zero_nonzero_bits_from_vr (TREE_TYPE (op0), &vr0, &may_be_nonzero0,\n+  if (!vrp_set_zero_nonzero_bits (TREE_TYPE (op0), &vr0, &may_be_nonzero0,\n \t\t\t\t  &must_be_nonzero0))\n     return false;\n-  if (!zero_nonzero_bits_from_vr (TREE_TYPE (op1), &vr1, &may_be_nonzero1,\n+  if (!vrp_set_zero_nonzero_bits (TREE_TYPE (op1), &vr1, &may_be_nonzero1,\n \t\t\t\t  &must_be_nonzero1))\n     return false;\n "}]}