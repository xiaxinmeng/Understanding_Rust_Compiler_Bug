{"sha": "bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM2Njg4YjQwZWY2Y2MxMmU4OGEyNDk4ZjgyZGJiMmNkNTJlZTQ0Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-05-21T01:16:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-05-21T01:16:33Z"}, "message": "gcse.c (cprop_jump): Make use of REG_EQUAL notes on both setcc and jump, if they exist.\n\n\n\t* gcse.c (cprop_jump):  Make use of REG_EQUAL notes on both\n\tsetcc and jump, if they exist.  If substituted instruction\n\tfails to validate, store current effort in a REG_EQUAL note.\n\t(cprop_insn): Don't attempt further substitutions if the\n\tcurrent instruction has been deleted.\n\t(local_cprop_pass): Likewise.\n\n\t* jump.c (redirect_jump):  Also update REG_EQUAL note, if\n\tone is attached to the jump instruction.\n\t(invert_jump): Delete REG_EQUAL note on jump, if one exists.\n\nCo-Authored-By: Joern Rennecke <joern.rennecke@superh.com>\nCo-Authored-By: Kazu Hirata <kazu@cs.umass.edu>\n\nFrom-SVN: r67054", "tree": {"sha": "f28f48b34144fa1f8eece6d07edcd6abcef71a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f28f48b34144fa1f8eece6d07edcd6abcef71a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/comments", "author": null, "committer": null, "parents": [{"sha": "fc351800ecc6c2583d0e7be9d18eed6b0934563e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc351800ecc6c2583d0e7be9d18eed6b0934563e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc351800ecc6c2583d0e7be9d18eed6b0934563e"}], "stats": {"total": 108, "additions": 93, "deletions": 15}, "files": [{"sha": "7eaa2e7614938e67df0fee404a875f35575dd67c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "patch": "@@ -1,3 +1,18 @@\n+2003-05-20  Roger Sayle  <roger@eyesopen.com>\n+\t    Kazu Hirata  <kazu@cs.umass.edu>\n+\t    Joern Rennecke  <joern.rennecke@superh.com>\n+\n+\t* gcse.c (cprop_jump):  Make use of REG_EQUAL notes on both\n+\tsetcc and jump, if they exist.  If substituted instruction\n+\tfails to validate, store current effort in a REG_EQUAL note.\n+\t(cprop_insn): Don't attempt further substitutions if the\n+\tcurrent instruction has been deleted.\n+\t(local_cprop_pass): Likewise.\n+\n+\t* jump.c (redirect_jump):  Also update REG_EQUAL note, if\n+\tone is attached to the jump instruction.\n+\t(invert_jump): Delete REG_EQUAL note on jump, if one exists.\n+\n 2003-05-21  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR c++/9738"}, {"sha": "8050dd13c73dbe9e74ff9799b2e48b54cce65211", "filename": "gcc/gcse.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "patch": "@@ -4089,28 +4089,42 @@ cprop_jump (bb, setcc, jump, from, src)\n      rtx from;\n      rtx src;\n {\n-  rtx new, new_set;\n+  rtx new, set_src, note_src;\n   rtx set = pc_set (jump);\n+  rtx note = find_reg_equal_equiv_note (jump);\n \n-  /* First substitute in the INSN condition as the SET_SRC of the JUMP,\n-     then substitute that given values in this expanded JUMP.  */\n-  if (setcc != NULL\n+  if (note)\n+    {\n+      note_src = XEXP (note, 0);\n+      if (GET_CODE (note_src) == EXPR_LIST)\n+\tnote_src = NULL_RTX;\n+    }\n+  else note_src = NULL_RTX;\n+\n+  /* Prefer REG_EQUAL notes except those containing EXPR_LISTs.  */\n+  set_src = note_src ? note_src : SET_SRC (set);\n+\n+  /* First substitute the SETCC condition into the JUMP instruction,\n+     then substitute that given values into this expanded JUMP.  */\n+  if (setcc != NULL_RTX\n       && !modified_between_p (from, setcc, jump)\n       && !modified_between_p (src, setcc, jump))\n     {\n+      rtx setcc_src;\n       rtx setcc_set = single_set (setcc);\n-      new_set = simplify_replace_rtx (SET_SRC (set),\n-\t\t\t\t      SET_DEST (setcc_set),\n-\t\t\t\t      SET_SRC (setcc_set));\n+      rtx setcc_note = find_reg_equal_equiv_note (setcc);\n+      setcc_src = (setcc_note && GET_CODE (XEXP (setcc_note, 0)) != EXPR_LIST)\n+\t\t? XEXP (setcc_note, 0) : SET_SRC (setcc_set);\n+      set_src = simplify_replace_rtx (set_src, SET_DEST (setcc_set),\n+\t\t\t\t      setcc_src);\n     }\n   else\n-    new_set = set;\n+    setcc = NULL_RTX;\n \n-  new = simplify_replace_rtx (new_set, from, src);\n+  new = simplify_replace_rtx (set_src, from, src);\n \n-  /* If no simplification can be made, then try the next\n-     register.  */\n-  if (rtx_equal_p (new, new_set) || rtx_equal_p (new, SET_SRC (set)))\n+  /* If no simplification can be made, then try the next register.  */\n+  if (rtx_equal_p (new, SET_SRC (set)))\n     return 0;\n \n   /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n@@ -4120,11 +4134,27 @@ cprop_jump (bb, setcc, jump, from, src)\n     {\n       /* Ensure the value computed inside the jump insn to be equivalent\n          to one computed by setcc.  */\n-      if (setcc \n-\t  && modified_in_p (new, setcc))\n+      if (setcc && modified_in_p (new, setcc))\n \treturn 0;\n       if (! validate_change (jump, &SET_SRC (set), new, 0))\n-\treturn 0;\n+\t{\n+\t  /* When (some) constants are not valid in a comparison, and there\n+\t     are two registers to be replaced by constants before the entire\n+\t     comparison can be folded into a constant, we need to keep\n+\t     intermediate information in REG_EQUAL notes.  For targets with\n+\t     separate compare insns, such notes are added by try_replace_reg.\n+\t     When we have a combined compare-and-branch instruction, however,\n+\t     we need to attach a note to the branch itself to make this\n+\t     optimization work.  */\n+\n+\t  if (!rtx_equal_p (new, note_src))\n+\t    set_unique_reg_note (jump, REG_EQUAL, copy_rtx (new));\n+\t  return 0;\n+\t}\n+\n+      /* Remove REG_EQUAL note after simplification.  */\n+      if (note_src)\n+\tremove_note (jump, note);\n \n       /* If this has turned into an unconditional jump,\n \t then put a barrier after it so that the unreachable\n@@ -4261,6 +4291,8 @@ cprop_insn (insn, alter_jumps)\n \t\t  print_rtl (gcse_file, src);\n \t\t  fprintf (gcse_file, \"\\n\");\n \t\t}\n+\t      if (INSN_DELETED_P (insn))\n+\t\treturn 1;\n \t    }\n \t}\n       else if (GET_CODE (src) == REG\n@@ -4503,6 +4535,8 @@ local_cprop_pass (alter_jumps)\n \t\t    changed = true;\n \t\t    break;\n \t\t  }\n+\t      if (INSN_DELETED_P (insn))\n+\t\tbreak;\n \t    }\n \t  while (reg_use_count);\n \t}"}, {"sha": "f15e2abae107d66e240f802f65d7d57790e3d09c", "filename": "gcc/jump.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6688b40ef6cc12e88a2498f82dbb2cd52ee443/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=bc6688b40ef6cc12e88a2498f82dbb2cd52ee443", "patch": "@@ -2074,6 +2074,7 @@ redirect_jump (jump, nlabel, delete_unused)\n      int delete_unused;\n {\n   rtx olabel = JUMP_LABEL (jump);\n+  rtx note;\n \n   if (nlabel == olabel)\n     return 1;\n@@ -2085,6 +2086,29 @@ redirect_jump (jump, nlabel, delete_unused)\n   if (nlabel)\n     ++LABEL_NUSES (nlabel);\n \n+  /* Update labels in any REG_EQUAL note.  */\n+  if ((note = find_reg_note (jump, REG_EQUAL, NULL_RTX)) != NULL_RTX)\n+    {\n+      if (nlabel && olabel)\n+\t{\n+\t  rtx dest = XEXP (note, 0);\n+\n+\t  if (GET_CODE (dest) == IF_THEN_ELSE)\n+\t    {\n+\t      if (GET_CODE (XEXP (dest, 1)) == LABEL_REF\n+\t\t  && XEXP (XEXP (dest, 1), 0) == olabel)\n+\t\tXEXP (XEXP (dest, 1), 0) = nlabel;\n+\t      if (GET_CODE (XEXP (dest, 2)) == LABEL_REF\n+\t\t  && XEXP (XEXP (dest, 2), 0) == olabel)\n+\t\tXEXP (XEXP (dest, 2), 0) = nlabel;\n+\t    }\n+\t  else\n+\t    remove_note (jump, note);\n+\t}\n+      else\n+        remove_note (jump, note);\n+    }\n+\n   /* If we're eliding the jump over exception cleanups at the end of a\n      function, move the function end note so that -Wreturn-type works.  */\n   if (olabel && nlabel\n@@ -2201,6 +2225,11 @@ invert_jump (jump, nlabel, delete_unused)\n \n   if (redirect_jump (jump, nlabel, delete_unused))\n     {\n+      /* Remove REG_EQUAL note if we have one.  */\n+      rtx note = find_reg_note (jump, REG_EQUAL, NULL_RTX);\n+      if (note)\n+\tremove_note (jump, note);\n+\n       invert_br_probabilities (jump);\n \n       return 1;"}]}