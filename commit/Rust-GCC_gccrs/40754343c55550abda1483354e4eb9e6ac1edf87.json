{"sha": "40754343c55550abda1483354e4eb9e6ac1edf87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA3NTQzNDNjNTU1NTBhYmRhMTQ4MzM1NGU0ZWI5ZTZhYzFlZGY4Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T19:10:13Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T19:10:13Z"}, "message": "Initial revision\n\nFrom-SVN: r250", "tree": {"sha": "9bb85d0bcdcbd992498d2ea86aa40339e93ebb10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb85d0bcdcbd992498d2ea86aa40339e93ebb10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40754343c55550abda1483354e4eb9e6ac1edf87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40754343c55550abda1483354e4eb9e6ac1edf87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40754343c55550abda1483354e4eb9e6ac1edf87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40754343c55550abda1483354e4eb9e6ac1edf87/comments", "author": null, "committer": null, "parents": [{"sha": "8697bba18b46ca8449a4611ba67cc7f4719c4ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8697bba18b46ca8449a4611ba67cc7f4719c4ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8697bba18b46ca8449a4611ba67cc7f4719c4ee3"}], "stats": {"total": 288, "additions": 288, "deletions": 0}, "files": [{"sha": "1c680be4027219df8fcc8ccdfd61c8ab738b3ab9", "filename": "gcc/c-tree.h", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40754343c55550abda1483354e4eb9e6ac1edf87/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40754343c55550abda1483354e4eb9e6ac1edf87/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=40754343c55550abda1483354e4eb9e6ac1edf87", "patch": "@@ -0,0 +1,288 @@\n+/* Definitions for C parsing and type checking.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Language-dependent contents of an identifier.  */\n+\n+struct lang_identifier\n+{\n+  struct tree_identifier ignore;\n+  tree global_value, local_value, label_value, implicit_decl;\n+  tree error_locus;\n+};\n+\n+/* Macros for access to language-specific slots in an identifier.  */\n+\n+#define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->global_value)\n+#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->local_value)\n+#define IDENTIFIER_LABEL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->label_value)\n+#define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->implicit_decl)\n+#define IDENTIFIER_ERROR_LOCUS(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->error_locus)\n+\n+/* In identifiers, C uses the following fields in a special way:\n+   TREE_PUBLIC        to record that there was a previous local extern decl.\n+   TREE_USED          to record that such a decl was used.\n+   TREE_ADDRESSABLE   to record that the address of such a decl was used.  */\n+\n+/* Nonzero means reject anything that ANSI standard C forbids.  */\n+extern int pedantic;\n+\n+/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n+#define C_TYPE_FIELDS_READONLY(type) TREE_LANG_FLAG_1 (type)\n+\n+/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n+#define C_TYPE_FIELDS_VOLATILE(type) TREE_LANG_FLAG_2 (type)\n+\n+/* In a RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE\n+   nonzero if the definition of the type has already started.  */\n+#define C_TYPE_BEING_DEFINED(type) TYPE_LANG_FLAG_0 (type)\n+\n+/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n+struct lang_type\n+{\n+  int len;\n+  tree elts[1];\n+};\n+\n+/* Mark which labels are explicitly declared.\n+   These may be shadowed, and may be referenced from nested functions.  */\n+#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n+\n+/* Record whether a type or decl was written with nonconstant size.\n+   Note that TYPE_SIZE may have simplified to a constant.  */\n+#define C_TYPE_VARIABLE_SIZE(type) TYPE_LANG_FLAG_1 (type)\n+#define C_DECL_VARIABLE_SIZE(type) DECL_LANG_FLAG_0 (type)\n+\n+/* Record in each node resulting from a binary operator\n+   what operator was specified for it.  */\n+#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n+\n+#if 0 /* Not used.  */\n+/* Record whether a decl for a function or function pointer has\n+   already been mentioned (in a warning) because it was called\n+   but didn't have a prototype.  */\n+#define C_MISSING_PROTOTYPE_WARNED(decl) DECL_LANG_FLAG_2(decl)\n+#endif\n+\n+/* Store a value in that field.  */\n+#define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n+  (TREE_COMPLEXITY (exp) = (int)(code))\n+\n+/* Record whether a typedef for type `int' was actually `signed int'.  */\n+#define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n+\n+/* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n+   TYPE_ARG_TYPES for functions with prototypes, but created for functions\n+   without prototypes.  */\n+#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_NONCOPIED_PARTS (NODE)\n+\f\n+/* in c-typecheck.c */\n+extern tree build_component_ref (), build_conditional_expr (), build_compound_expr ();\n+extern tree build_unary_op (), build_binary_op (), build_function_call ();\n+extern tree parser_build_binary_op ();\n+extern tree build_indirect_ref (), build_array_ref (), build_c_cast ();\n+extern tree build_modify_expr ();\n+extern tree c_sizeof (), c_alignof (), c_alignof_expr ();\n+extern void store_init_value ();\n+extern tree digest_init ();\n+extern tree c_expand_start_case ();\n+extern tree default_conversion ();\n+\n+/* Given two integer or real types, return the type for their sum.\n+   Given two compatible ANSI C types, returns the merged type.  */\n+\n+extern tree common_type ();\n+\n+/* in c-decl.c */\n+extern tree build_label ();\n+\n+extern int start_function ();\n+extern void finish_function ();\n+extern void store_parm_decls ();\n+extern tree get_parm_info ();\n+extern tree combine_parm_decls ();\n+\n+extern void pushlevel ();\n+extern tree poplevel ();\n+\n+extern tree groktypename (), lookup_name ();\n+\n+extern tree lookup_label (), define_label (), shadow_label ();\n+\n+extern tree implicitly_declare (), getdecls (), gettags ();\n+\n+extern tree start_decl ();\n+extern void finish_decl ();\n+\n+extern tree start_struct (), finish_struct (), xref_tag ();\n+extern tree grokfield ();\n+\n+extern tree start_enum (), finish_enum ();\n+extern tree build_enumerator ();\n+\n+extern tree make_index_type ();\n+\n+/* Add qualifiers to a type, in the fashion for C.  */\n+extern tree c_build_type_variant ();\n+\n+/* Functions in c-common.c: */\n+\n+/* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n+extern tree combine_strings ();\n+\n+/* Validate the expression after `case' and apply default promotions.  */\n+extern tree check_case_value ();\n+\n+/* Print an error message for invalid operands to arith operation CODE.\n+   NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n+\n+extern void binary_op_error ();\n+\n+/* Subroutine of build_binary_op, used for comparison operations.\n+   See if the operands have both been converted from subword integer types\n+   and, if so, perhaps change them both back to their original type.  */\n+\n+extern tree shorten_compare ();\n+\n+/* Read the rest of the current #-directive line.  */\n+extern char *get_directive_line ();\n+\n+extern int maybe_objc_comptypes ();\n+extern tree maybe_building_objc_message_expr ();\n+\f\n+/* Standard named or nameless data types of the C compiler.  */\n+\n+extern tree short_integer_type_node, integer_type_node;\n+extern tree long_integer_type_node, long_long_integer_type_node;\n+extern tree short_unsigned_type_node, unsigned_type_node;\n+extern tree long_unsigned_type_node, long_long_unsigned_type_node;\n+extern tree ptrdiff_type_node;\n+extern tree unsigned_char_type_node, signed_char_type_node, char_type_node;\n+extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n+extern tree float_type_node, double_type_node, long_double_type_node;\n+extern tree void_type_node, ptr_type_node, const_ptr_type_node;\n+extern tree string_type_node, const_string_type_node;\n+extern tree char_array_type_node, int_array_type_node, wchar_array_type_node;\n+extern tree default_function_type;\n+extern tree double_ftype_double, double_ftype_double_double;\n+extern tree int_ftype_int, long_ftype_long;\n+extern tree void_ftype_ptr_ptr_int, int_ftype_ptr_ptr_int;\n+extern tree void_ftype_ptr_int_int, string_ftype_ptr_ptr;\n+extern tree int_ftype_string_string, int_ftype_cptr_cptr_sizet;\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement that specifies a return value is seen.  */\n+\n+extern int current_function_returns_value;\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement with no argument is seen.  */\n+\n+extern int current_function_returns_null;\n+\n+/* Nonzero means `$' can be in an identifier.  */\n+\n+extern int dollars_in_ident;\n+\n+/* Nonzero means allow type mismatches in conditional expressions;\n+   just make their values `void'.   */\n+\n+extern int flag_cond_mismatch;\n+\n+/* Nonzero means don't recognize the keyword `asm'.  */\n+\n+extern int flag_no_asm;\n+\n+/* Nonzero means ignore `#ident' directives.  */\n+\n+extern int flag_no_ident;\n+\n+/* Nonzero means warn about implicit declarations.  */\n+\n+extern int warn_implicit;\n+\n+/* Nonzero means give string constants the type `const char *'\n+   to get extra warnings from them.  These warnings will be too numerous\n+   to be useful, except in thoroughly ANSIfied programs.  */\n+\n+extern int warn_write_strings;\n+\n+/* Nonzero means warn about sizeof (function) or addition/subtraction\n+   of function pointers.  */\n+\n+extern int warn_pointer_arith;\n+\n+/* Nonzero means warn for all old-style non-prototype function decls.  */\n+\n+extern int warn_strict_prototypes;\n+\n+/* Nonzero means warn about multiple (redundant) decls for the same single\n+   variable or function.  */\n+\n+extern int warn_redundant_decls;\n+\n+/* Nonzero means warn about extern declarations of objects not at\n+   file-scope level and about *all* declarations of functions (whether\n+   extern or static) not at file-scope level.  Note that we exclude\n+   implicit function declarations.  To get warnings about those, use\n+   -Wimplicit.  */\n+\n+extern int warn_nested_externs;\n+\n+/* Nonzero means warn about pointer casts that can drop a type qualifier\n+   from the pointer target type.  */\n+\n+extern int warn_cast_qual;\n+\n+/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n+\n+extern int warn_traditional;\n+\n+/* Warn about *printf or *scanf format/argument anomalies. */\n+\n+extern int warn_format;\n+\n+/* Warn about a subscript that has type char.  */\n+\n+extern int warn_char_subscripts;\n+\n+/* Warn if a type conversion is done that might have confusing results.  */\n+\n+extern int warn_conversion;\n+\n+/* Nonzero means do some things the same way PCC does.  */\n+\n+extern int flag_traditional;\n+\n+/* Nonzero means warn about suggesting putting in ()'s.  */\n+\n+extern int warn_parentheses;\n+\n+/* Nonzero means this is a function to call to perform comptypes\n+   on two record types.  */\n+\n+extern int (*comptypes_record_hook) ();\n+\n+/* Nonzero means we are reading code that came from a system header file.  */\n+\n+extern int system_header_p;"}]}