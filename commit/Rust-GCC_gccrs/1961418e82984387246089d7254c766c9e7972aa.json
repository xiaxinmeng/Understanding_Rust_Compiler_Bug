{"sha": "1961418e82984387246089d7254c766c9e7972aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk2MTQxOGU4Mjk4NDM4NzI0NjA4OWQ3MjU0Yzc2NmM5ZTc5NzJhYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-28T18:29:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-28T18:29:04Z"}, "message": "tree-ssa-pre.c (insert_into_preds_of_block): Remove dead code.\n\n2008-07-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (insert_into_preds_of_block): Remove dead code.\n\t(insert_fake_stores): Remove.\n\t(realify_fake_stores): Likewise.\n\t(execute_pre): Remove dead code.\n\t* tree-ssa-structalias.c (get_constraint_for_1): Remove tcc_unary\n\tcase.\n\t(find_func_aliases): Deal with it here instead.\n\tRe-enable gcc_unreachable call.\n\nFrom-SVN: r138213", "tree": {"sha": "82ea529b81e1a3235c5b280bbbbe8df66346b1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82ea529b81e1a3235c5b280bbbbe8df66346b1e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1961418e82984387246089d7254c766c9e7972aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1961418e82984387246089d7254c766c9e7972aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1961418e82984387246089d7254c766c9e7972aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1961418e82984387246089d7254c766c9e7972aa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "806b3528b9a34fd7bff1424a65d34907a19ab467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806b3528b9a34fd7bff1424a65d34907a19ab467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806b3528b9a34fd7bff1424a65d34907a19ab467"}], "stats": {"total": 176, "additions": 17, "deletions": 159}, "files": [{"sha": "40511deb9b16041fd37aa6e06675358d7d1a2a39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1961418e82984387246089d7254c766c9e7972aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1961418e82984387246089d7254c766c9e7972aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1961418e82984387246089d7254c766c9e7972aa", "patch": "@@ -1,3 +1,14 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (insert_into_preds_of_block): Remove dead code.\n+\t(insert_fake_stores): Remove.\n+\t(realify_fake_stores): Likewise.\n+\t(execute_pre): Remove dead code.\n+\t* tree-ssa-structalias.c (get_constraint_for_1): Remove tcc_unary\n+\tcase.\n+\t(find_func_aliases): Deal with it here instead.\n+\tRe-enable gcc_unreachable call.\n+\n 2008-07-28  Richard Guenther  <rguenther@suse.de>\n \n \tMerge from gimple-tuples-branch."}, {"sha": "c772ff2bdaff9e56013644e69f4711689ae97eab", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 131, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1961418e82984387246089d7254c766c9e7972aa/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1961418e82984387246089d7254c766c9e7972aa/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1961418e82984387246089d7254c766c9e7972aa", "patch": "@@ -2991,8 +2991,6 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t    }\n \t\t\t  gsi_insert_seq_on_edge (pred, stmts);\n \t\t\t}\n-\t\t      /* FIXME tuples\n-\t\t      gimple_set_plf (forcedexpr, NECESSARY, false); */\n \t\t      avail[bprime->index] = get_or_alloc_expr_for_name (forcedexpr);\n \t\t    }\n \t\t}\n@@ -3032,8 +3030,6 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t    }\n \t\t  gsi_insert_seq_on_edge (pred, stmts);\n \t\t}\n-\t      /* FIXME tuples\n-\t      gimple_set_plf (forcedexpr, NECESSARY, false); */\n \t      avail[bprime->index] = get_or_alloc_expr_for_name (forcedexpr);\n \t    }\n \t}\n@@ -3452,120 +3448,6 @@ add_to_exp_gen (basic_block block, tree op)\n     }\n }\n \n-/* FIXME tuples */\n-#if 0\n-/* For each real store operation of the form\n-   *a = <value> that we see, create a corresponding fake store of the\n-   form storetmp_<version> = *a.\n-\n-   This enables AVAIL computation to mark the results of stores as\n-   available.  Without this, you'd need to do some computation to\n-   mark the result of stores as ANTIC and AVAIL at all the right\n-   points.\n-   To save memory, we keep the store\n-   statements pool allocated until we decide whether they are\n-   necessary or not.  */\n-\n-static void\n-insert_fake_stores (void)\n-{\n-  basic_block block;\n-\n-  FOR_ALL_BB (block)\n-    {\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (block); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  /* We can't generate SSA names for stores that are complex\n-\t     or aggregate.  We also want to ignore things whose\n-\t     virtual uses occur in abnormal phis.  */\n-\n-\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t      && (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == INDIRECT_REF\n-\t\t  || handled_component_p (GIMPLE_STMT_OPERAND (stmt, 0)))\n-\t      && !AGGREGATE_TYPE_P (TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0))))\n-\t    {\n-\t      ssa_op_iter iter;\n-\t      def_operand_p defp;\n-\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t      tree new_tree, new_lhs;\n-\t      bool notokay = false;\n-\n-\t      FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n-\t\t{\n-\t\t  tree defvar = DEF_FROM_PTR (defp);\n-\t\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (defvar))\n-\t\t    {\n-\t\t      notokay = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      if (notokay)\n-\t\tcontinue;\n-\n-\t      if (!storetemp || TREE_TYPE (rhs) != TREE_TYPE (storetemp))\n-\t\t{\n-\t\t  storetemp = create_tmp_var (TREE_TYPE (rhs), \"storetmp\");\n-\t\t  if (TREE_CODE (TREE_TYPE (storetemp)) == VECTOR_TYPE\n-\t\t      || TREE_CODE (TREE_TYPE (storetemp)) == COMPLEX_TYPE)\n-\t\t    DECL_GIMPLE_REG_P (storetemp) = 1;\n-\t\t  get_var_ann (storetemp);\n-\t\t}\n-\n-\t      new_tree = build_gimple_modify_stmt (NULL_TREE, lhs);\n-\t      new_lhs = make_ssa_name (storetemp, new_tree);\n-\t      GIMPLE_STMT_OPERAND (new_tree, 0) = new_lhs;\n-\t      create_ssa_artificial_load_stmt (new_tree, stmt, false);\n-\n-\t      gimple_set_plf (new_tree, NECESSARY, false);\n-\t      VEC_safe_push (gimple, heap, inserted_exprs, new_tree);\n-\t      VEC_safe_push (gimple, heap, need_creation, new_tree);\n-\t      bsi_insert_after (&bsi, new_tree, BSI_NEW_STMT);\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Turn the pool allocated fake stores that we created back into real\n-   GC allocated ones if they turned out to be necessary to PRE some\n-   expressions.  */\n-\n-static void\n-realify_fake_stores (void)\n-{\n-  unsigned int i;\n-  tree stmt;\n-\n-  for (i = 0; VEC_iterate (gimple, need_creation, i, stmt); i++)\n-    {\n-      if (gimple_plf (stmt, NECESSARY))\n-\t{\n-\t  block_stmt_iterator bsi, bsi2;\n-\t  tree rhs;\n-\n-\t  /* Mark the temp variable as referenced */\n-\t  add_referenced_var (SSA_NAME_VAR (GIMPLE_STMT_OPERAND (stmt, 0)));\n-\n-\t  /* Put the statement before the store in the IR stream\n-\t     as a plain ssa name copy.  */\n-\t  bsi = bsi_for_stmt (stmt);\n-\t  bsi_prev (&bsi);\n-\t  rhs = GIMPLE_STMT_OPERAND (bsi_stmt (bsi), 1);\n-\t  GIMPLE_STMT_OPERAND (stmt, 1) = rhs;\n-\t  bsi2 = bsi_for_stmt (stmt);\n-\t  bsi_remove (&bsi2, true);\n-\t  bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n-\t}\n-      else\n-\trelease_defs (stmt);\n-    }\n-}\n-#endif\n-\n /* Create value ids for PHI in BLOCK.  */\n \n static void\n@@ -4266,11 +4148,6 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n      loop_optimizer_init may create new phis, etc.  */\n   if (!do_fre)\n     loop_optimizer_init (LOOPS_NORMAL);\n-  /* FIXME tuples */\n-#if 0\n-  if (0 && !do_fre)\n-    insert_fake_stores ();\n-#endif\n \n   if (!run_scc_vn (do_fre))\n     {\n@@ -4326,14 +4203,7 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n   clear_expression_ids ();\n   free_scc_vn ();\n   if (!do_fre)\n-    {\n-      remove_dead_inserted_code ();\n-  /* FIXME tuples */\n-#if 0\n-      if (0)\n-\trealify_fake_stores ();\n-#endif\n-    }\n+    remove_dead_inserted_code ();\n \n   fini_pre ();\n "}, {"sha": "6fb9bdd9168cbdcd8e04595aa96eac6dd3d2948b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1961418e82984387246089d7254c766c9e7972aa/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1961418e82984387246089d7254c766c9e7972aa/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=1961418e82984387246089d7254c766c9e7972aa", "patch": "@@ -3131,31 +3131,6 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t  }\n \tbreak;\n       }\n-    case tcc_unary:\n-      {\n-\t/* FIXME tuples: this won't trigger, instead get_constraint_for\n-\t   needs to be fed with piecewise trees.  */\n-\tswitch (TREE_CODE (t))\n-\t  {\n-\t  CASE_CONVERT:\n-\t    {\n-\t      tree op = TREE_OPERAND (t, 0);\n-\n-\t      /* Cast from non-pointer to pointers are bad news for us.\n-\t\t Anything else, we see through */\n-\t      if (!(POINTER_TYPE_P (TREE_TYPE (t))\n-\t\t    && ! POINTER_TYPE_P (TREE_TYPE (op))))\n-\t\t{\n-\t\t  get_constraint_for_1 (op, results, address_p);\n-\t\t  return;\n-\t\t}\n-\n-\t      /* FALLTHRU  */\n-\t    }\n-\t  default:;\n-\t  }\n-\tbreak;\n-      }\n     case tcc_exceptional:\n       {\n \tswitch (TREE_CODE (t))\n@@ -3877,7 +3852,10 @@ find_func_aliases (gimple origt)\n \t  if (gimple_assign_rhs_code (t) == POINTER_PLUS_EXPR)\n \t    get_constraint_for_ptr_offset (gimple_assign_rhs1 (t),\n \t\t\t\t\t   gimple_assign_rhs2 (t), &rhsc);\n-\t  else if (rhsop)\n+\t  else if ((IS_CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (t))\n+\t\t    && !(POINTER_TYPE_P (gimple_expr_type (t))\n+\t\t\t && !POINTER_TYPE_P (TREE_TYPE (rhsop))))\n+\t\t   || gimple_assign_single_p (t))\n \t    get_constraint_for (rhsop, &rhsc);\n \t  else\n \t    {\n@@ -3924,9 +3902,8 @@ find_func_aliases (gimple origt)\n \t  if (could_have_pointers (gimple_assign_rhs1 (t)))\n \t    make_escape_constraint (gimple_assign_rhs1 (t));\n \t}\n-      /* FIXME tuples\n       else\n-\tgcc_unreachable ();  */\n+\tgcc_unreachable ();\n     }\n   else if (stmt_escape_type == ESCAPE_BAD_CAST)\n     {"}]}