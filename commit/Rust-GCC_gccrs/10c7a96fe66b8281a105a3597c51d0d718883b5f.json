{"sha": "10c7a96fe66b8281a105a3597c51d0d718883b5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjN2E5NmZlNjZiODI4MWExMDVhMzU5N2M1MWQwZDcxODg4M2I1Zg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-03-23T11:09:24Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-23T11:09:24Z"}, "message": "convert.c (convert): Replace fold (buildN (...)) with fold_buildN.\n\n\t* convert.c (convert): Replace fold (buildN (...)) with fold_buildN.\n\t* trans-array.c (gfc_trans_allocate_array_storage,\n\tgfc_trans_allocate_temp_array gfc_trans_array_constructor_value,\n\tgfc_conv_array_index_ref, gfc_trans_array_bound_check,\n\tgfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n\tgfc_conv_array_ref, gfc_trans_preloop_setup, gfc_conv_ss_startstride,\n\tgfc_conv_loop_setup, gfc_array_init_size, gfc_trans_array_bounds,\n\tgfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias,\n\tgfc_conv_expr_descriptor): Likewise.\n\t* trans-expr.c (gfc_conv_powi, gfc_conv_string_tmp,\n\tgfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n\t* trans-intrinsic.c (build_round_expr, gfc_conv_intrinsic_bound,\n\tgfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_sign,\n\tgfc_conv_intrinsic_minmaxloc, gfc_conv_intrinsic_minmaxval,\n\tgfc_conv_intrinsic_btest, gfc_conv_intrinsic_bitop,\n\tgfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ibits,\n\tgfc_conv_intrinsic_ishft, gfc_conv_intrinsic_ishftc,\n\tgfc_conv_intrinsic_merge, prepare_arg_info,\n\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_repeat): Likewise.\n\t* trans-stmt.c (gfc_trans_simple_do, gfc_trans_do, gfc_trans_do_while,\n\tgfc_trans_forall_loop, gfc_do_allocate, generate_loop_for_temp_to_lhs,\n\tgenerate_loop_for_rhs_to_temp, compute_inner_temp_size,\n\tallocate_temp_for_forall_nest, gfc_trans_pointer_assign_need_temp,\n\tgfc_trans_forall_1, gfc_evaluate_where_mask, gfc_trans_where_assign):\n\tLikewise.\n\t* trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds): Likewise.\n\t* trans.c (gfc_add_modify_expr): Likewise.\n\nFrom-SVN: r96926", "tree": {"sha": "4fd68cf88db134610d6dfe0cb8b84a5c634ca886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd68cf88db134610d6dfe0cb8b84a5c634ca886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c7a96fe66b8281a105a3597c51d0d718883b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c7a96fe66b8281a105a3597c51d0d718883b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c7a96fe66b8281a105a3597c51d0d718883b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c7a96fe66b8281a105a3597c51d0d718883b5f/comments", "author": null, "committer": null, "parents": [{"sha": "2bc3f466b5d2ec73ab7aabd980584204fd6ba96a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc3f466b5d2ec73ab7aabd980584204fd6ba96a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc3f466b5d2ec73ab7aabd980584204fd6ba96a"}], "stats": {"total": 505, "additions": 267, "deletions": 238}, "files": [{"sha": "aa990eb616a35107c262f9a6e5185afd23efbc48", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -1,3 +1,33 @@\n+2005-03-23  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* convert.c (convert): Replace fold (buildN (...)) with fold_buildN.\n+\t* trans-array.c (gfc_trans_allocate_array_storage,\n+\tgfc_trans_allocate_temp_array gfc_trans_array_constructor_value,\n+\tgfc_conv_array_index_ref, gfc_trans_array_bound_check,\n+\tgfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n+\tgfc_conv_array_ref, gfc_trans_preloop_setup, gfc_conv_ss_startstride,\n+\tgfc_conv_loop_setup, gfc_array_init_size, gfc_trans_array_bounds,\n+\tgfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias,\n+\tgfc_conv_expr_descriptor): Likewise.\n+\t* trans-expr.c (gfc_conv_powi, gfc_conv_string_tmp,\n+\tgfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n+\t* trans-intrinsic.c (build_round_expr, gfc_conv_intrinsic_bound,\n+\tgfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_sign,\n+\tgfc_conv_intrinsic_minmaxloc, gfc_conv_intrinsic_minmaxval,\n+\tgfc_conv_intrinsic_btest, gfc_conv_intrinsic_bitop,\n+\tgfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ibits,\n+\tgfc_conv_intrinsic_ishft, gfc_conv_intrinsic_ishftc,\n+\tgfc_conv_intrinsic_merge, prepare_arg_info,\n+\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_repeat): Likewise.\n+\t* trans-stmt.c (gfc_trans_simple_do, gfc_trans_do, gfc_trans_do_while,\n+\tgfc_trans_forall_loop, gfc_do_allocate, generate_loop_for_temp_to_lhs,\n+\tgenerate_loop_for_rhs_to_temp, compute_inner_temp_size,\n+\tallocate_temp_for_forall_nest, gfc_trans_pointer_assign_need_temp,\n+\tgfc_trans_forall_1, gfc_evaluate_where_mask, gfc_trans_where_assign):\n+\tLikewise.\n+\t* trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds): Likewise.\n+\t* trans.c (gfc_add_modify_expr): Likewise.\n+\n 2005-03-22  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* check.c (gfc_check_chdir, gfc_check_chdir_sub, gfc_check_kill,"}, {"sha": "a0298f22784725024551f46277613393bac1fe89", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -81,7 +81,7 @@ convert (tree type, tree expr)\n     return expr;\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold (build1 (NOP_EXPR, type, expr));\n+    return fold_build1 (NOP_EXPR, type, expr);\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n   if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n@@ -106,9 +106,9 @@ convert (tree type, tree expr)\n       /* If we have a NOP_EXPR, we must fold it here to avoid\n          infinite recursion between fold () and convert ().  */\n       if (TREE_CODE (e) == NOP_EXPR)\n-\treturn fold (build1 (NOP_EXPR, type, TREE_OPERAND (e, 0)));\n+\treturn fold_build1 (NOP_EXPR, type, TREE_OPERAND (e, 0));\n       else\n-\treturn fold (build1 (NOP_EXPR, type, e));\n+\treturn fold_build1 (NOP_EXPR, type, e);\n     }\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));"}, {"sha": "2d0bff8c07020a67597c25d386d502276d9a1527", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -429,8 +429,8 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n       if (onstack)\n \t{\n \t  /* Make a temporary variable to hold the data.  */\n-\t  tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n-\t\t\t      integer_one_node));\n+\t  tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n+\t\t\t     integer_one_node);\n \t  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t\t  tmp);\n \t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n@@ -508,8 +508,8 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \t{\n \t  /* Callee allocated arrays may not have a known bound yet.  */\n           if (loop->to[n])\n-              loop->to[n] = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t\t  loop->to[n], loop->from[n]));\n+              loop->to[n] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t\t loop->to[n], loop->from[n]);\n \t  loop->from[n] = gfc_index_zero_node;\n \t}\n \n@@ -569,18 +569,18 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n       tmp = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]);\n       gfc_add_modify_expr (&loop->pre, tmp, loop->to[n]);\n \n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  loop->to[n], gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t loop->to[n], gfc_index_one_node);\n \n-      size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n       size = gfc_evaluate_now (size, &loop->pre);\n     }\n \n   /* Get the size of the array.  */\n   nelem = size;\n   if (size)\n-    size = fold (build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n+    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n   gfc_trans_allocate_array_storage (loop, info, size, nelem);\n \n@@ -765,8 +765,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      gfc_trans_array_ctor_element (&body, pointer, *poffset, &se,\n \t\t\t\t\t    c->expr);\n \n-\t      *poffset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t       *poffset, gfc_index_one_node));\n+\t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      *poffset, gfc_index_one_node);\n \t    }\n \t  else\n \t    {\n@@ -832,8 +832,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t\t     tmp);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n-\t      *poffset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t       *poffset, bound));\n+\t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      *poffset, bound);\n \t    }\n \t  if (!INTEGER_CST_P (*poffset))\n             {\n@@ -1399,9 +1399,9 @@ gfc_conv_array_index_ref (gfc_se * se, tree pointer, tree * indices,\n     {\n       /* index = index + stride[n]*indices[n] */\n       tmp = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, indices[n], tmp));\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, indices[n], tmp);\n \n-      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n     }\n \n   /* Result = data[index].  */\n@@ -1429,11 +1429,11 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n)\n   index = gfc_evaluate_now (index, &se->pre);\n   /* Check lower bound.  */\n   tmp = gfc_conv_array_lbound (descriptor, n);\n-  fault = fold (build2 (LT_EXPR, boolean_type_node, index, tmp));\n+  fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp);\n   /* Check upper bound.  */\n   tmp = gfc_conv_array_ubound (descriptor, n);\n-  cond = fold (build2 (GT_EXPR, boolean_type_node, index, tmp));\n-  fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);\n+  fault = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond);\n \n   gfc_trans_runtime_check (fault, gfc_strconst_fault, &se->pre);\n \n@@ -1528,10 +1528,10 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \n           /* Multiply the loop variable by the stride and delta.  */\n \t  index = se->loop->loopvar[i];\n-\t  index = fold (build2 (MULT_EXPR, gfc_array_index_type, index,\n-\t\t\t\tinfo->stride[i]));\n-\t  index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index,\n-\t\t\t\tinfo->delta[i]));\n+\t  index = fold_build2 (MULT_EXPR, gfc_array_index_type, index,\n+\t\t\t       info->stride[i]);\n+\t  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index,\n+\t\t\t       info->delta[i]);\n \n \t  if (ar->dimen_type[dim] == DIMEN_VECTOR)\n \t    {\n@@ -1552,12 +1552,12 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       gcc_assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n       if (!integer_zerop (info->delta[i]))\n-\tindex = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      index, info->delta[i]));\n+\tindex = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     index, info->delta[i]);\n     }\n \n   /* Multiply by the stride.  */\n-  index = fold (build2 (MULT_EXPR, gfc_array_index_type, index, stride));\n+  index = fold_build2 (MULT_EXPR, gfc_array_index_type, index, stride);\n \n   return index;\n }\n@@ -1583,7 +1583,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t\t\t\t       info->stride0);\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n-  index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset));\n+  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset);\n \n   tmp = gfc_build_indirect_ref (info->data);\n   se->expr = gfc_build_array_ref (tmp, index);\n@@ -1643,33 +1643,33 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t  indexse.expr = gfc_evaluate_now (indexse.expr, &se->pre);\n \n \t  tmp = gfc_conv_array_lbound (se->expr, n);\n-\t  cond = fold (build2 (LT_EXPR, boolean_type_node, \n-\t\t\t       indexse.expr, tmp));\n+\t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n+\t\t\t      indexse.expr, tmp);\n \t  fault =\n-\t    fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+\t    fold_build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond);\n \n \t  tmp = gfc_conv_array_ubound (se->expr, n);\n-\t  cond = fold (build2 (GT_EXPR, boolean_type_node, \n-\t\t\t       indexse.expr, tmp));\n+\t  cond = fold_build2 (GT_EXPR, boolean_type_node, \n+\t\t\t      indexse.expr, tmp);\n \t  fault =\n-\t    fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+\t    fold_build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond);\n \t}\n \n       /* Multiply the index by the stride.  */\n       stride = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, indexse.expr,\n-\t\t\t  stride));\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, indexse.expr,\n+\t\t\t stride);\n \n       /* And add it to the total.  */\n-      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n     }\n \n   if (flag_bounds_check)\n     gfc_trans_runtime_check (fault, gfc_strconst_fault, &se->pre);\n \n   tmp = gfc_conv_array_offset (se->expr);\n   if (!integer_zerop (tmp))\n-    index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n       \n   /* Access the calculated element.  */\n   tmp = gfc_conv_array_data (se->expr);\n@@ -1730,8 +1730,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t\t\t\t\t\t       stride);\n \t\t  gfc_add_block_to_block (pblock, &se.pre);\n \n-\t\t  info->offset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t\t       info->offset, index));\n+\t\t  info->offset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t\t      info->offset, index);\n \t\t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t\t}\n \n@@ -1769,8 +1769,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t  index = gfc_conv_array_index_offset (&se, info, info->dim[i], i,\n \t\t\t\t\t       ar, stride);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  info->offset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t       info->offset, index));\n+\t  info->offset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      info->offset, index);\n \t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t}\n \n@@ -2168,28 +2168,28 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      /* Check lower bound.  */\n \t      bound = gfc_conv_array_lbound (desc, dim);\n \t      tmp = info->start[n];\n-\t      tmp = fold (build2 (LT_EXPR, boolean_type_node, tmp, bound));\n-\t      fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n-\t\t\t\t    tmp));\n+\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, tmp, bound);\n+\t      fault = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n+\t\t\t\t   tmp);\n \n \t      /* Check the upper bound.  */\n \t      bound = gfc_conv_array_ubound (desc, dim);\n \t      end = gfc_conv_section_upper_bound (ss, n, &block);\n-\t      tmp = fold (build2 (GT_EXPR, boolean_type_node, end, bound));\n-\t      fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n-\t\t\t\t    tmp));\n+\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, end, bound);\n+\t      fault = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n+\t\t\t\t   tmp);\n \n \t      /* Check the section sizes match.  */\n-\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t  info->start[n]));\n-\t      tmp = fold (build2 (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t  info->stride[n]));\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\t\t\t\t info->start[n]);\n+\t      tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n+\t\t\t\t info->stride[n]);\n \t      /* We remember the size of the first section, and check all the\n \t         others against this.  */\n \t      if (size[n])\n \t\t{\n \t\t  tmp =\n-\t\t    fold (build2 (NE_EXPR, boolean_type_node, tmp, size[n]));\n+\t\t    fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n \t\t  fault =\n \t\t    build2 (TRUTH_OR_EXPR, boolean_type_node, fault, tmp);\n \t\t}\n@@ -2467,10 +2467,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  /* To = from + (size - 1) * stride.  */\n \t  tmp = gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);\n \t  if (!integer_onep (info->stride[n]))\n-\t    tmp = fold (build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\ttmp, info->stride[n]));\n-\t  loop->to[n] = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      loop->from[n], tmp));\n+\t    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t       tmp, info->stride[n]);\n+\t  loop->to[n] = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t     loop->from[n], tmp);\n \t}\n       else\n \t{\n@@ -2508,10 +2508,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t     with start = 0, this simplifies to\n \t     last = end / step;\n \t     for (i = 0; i<=last; i++){...};  */\n-\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t      loop->to[n], loop->from[n]));\n-\t  tmp = fold (build2 (TRUNC_DIV_EXPR, gfc_array_index_type, \n-\t\t\t      tmp, info->stride[n]));\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     loop->to[n], loop->from[n]);\n+\t  tmp = fold_build2 (TRUNC_DIV_EXPR, gfc_array_index_type, \n+\t\t\t     tmp, info->stride[n]);\n \t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t  /* Make the loop variable start at 0.  */\n \t  loop->from[n] = gfc_index_zero_node;\n@@ -2563,12 +2563,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t    {\n \t      /* Calculate the offset relative to the loop variable.\n \t         First multiply by the stride.  */\n-\t      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t  loop->from[n], info->stride[n]));\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t loop->from[n], info->stride[n]);\n \n \t      /* Then subtract this from our starting value.  */\n-\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t  info->start[n], tmp));\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t info->start[n], tmp);\n \n \t      info->delta[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t    }\n@@ -2650,8 +2650,8 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       gfc_add_modify_expr (pblock, tmp, se.expr);\n \n       /* Work out the offset for this component.  */\n-      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride));\n-      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride);\n+      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n       /* Start the calculation for the size of this dimension.  */\n       size = build2 (MINUS_EXPR, gfc_array_index_type,\n@@ -2671,17 +2671,17 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       gfc_add_modify_expr (pblock, tmp, stride);\n \n       /* Calculate the size of this dimension.  */\n-      size = fold (build2 (PLUS_EXPR, gfc_array_index_type, se.expr, size));\n+      size = fold_build2 (PLUS_EXPR, gfc_array_index_type, se.expr, size);\n \n       /* Multiply the stride by the number of elements in this dimension.  */\n-      stride = fold (build2 (MULT_EXPR, gfc_array_index_type, stride, size));\n+      stride = fold_build2 (MULT_EXPR, gfc_array_index_type, stride, size);\n       stride = gfc_evaluate_now (stride, pblock);\n     }\n \n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold (build2 (MULT_EXPR, gfc_array_index_type, stride, tmp));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, stride, tmp);\n \n   if (poffset != NULL)\n     {\n@@ -2957,8 +2957,8 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           gfc_add_modify_expr (pblock, ubound, se.expr);\n         }\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n-      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, size));\n-      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, size);\n+      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (dim + 1 < as->rank)\n@@ -2969,10 +2969,10 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n       if (ubound != NULL_TREE && !(stride && INTEGER_CST_P (stride)))\n         {\n           /* Calculate stride = size * (ubound + 1 - lbound).  */\n-          tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t      gfc_index_one_node, lbound));\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, ubound, tmp));\n-          tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n+          tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_index_one_node, lbound);\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, tmp);\n+          tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n           if (stride)\n             gfc_add_modify_expr (pblock, stride, tmp);\n           else\n@@ -3045,7 +3045,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   /* The size is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n \n   /* Allocate memory to hold the data.  */\n   tmp = gfc_chainon_list (NULL_TREE, size);\n@@ -3203,7 +3203,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       partial = gfc_create_var (boolean_type_node, \"partial\");\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride (dumdesc, gfc_rank_cst[0]);\n-      tmp = fold (build2 (EQ_EXPR, boolean_type_node, tmp, integer_one_node));\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, integer_one_node);\n       gfc_add_modify_expr (&block, partial, tmp);\n     }\n   else\n@@ -3304,11 +3304,11 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t    {\n \t      /* Check (ubound(a) - lbound(a) == ubound(b) - lbound(b)).  */\n \n-\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t  ubound, lbound));\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t ubound, lbound);\n               stride = build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t       dubound, dlbound);\n-              tmp = fold (build2 (NE_EXPR, gfc_array_index_type, tmp, stride));\n+              tmp = fold_build2 (NE_EXPR, gfc_array_index_type, tmp, stride);\n \t      gfc_trans_runtime_check (tmp, gfc_strconst_bounds, &block);\n \t    }\n \t}\n@@ -3317,12 +3317,12 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t  /* For assumed shape arrays move the upper bound by the same amount\n \t     as the lower bound.  */\n           tmp = build2 (MINUS_EXPR, gfc_array_index_type, dubound, dlbound);\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n           gfc_add_modify_expr (&block, ubound, tmp);\n \t}\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n-      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, stride));\n-      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, stride);\n+      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (n + 1 < sym->as->rank)\n@@ -3343,12 +3343,12 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n               else\n                 {\n                   /* Calculate stride = size * (ubound + 1 - lbound).  */\n-                  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      gfc_index_one_node, lbound));\n-                  tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      ubound, tmp));\n-                  size = fold (build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t       size, tmp));\n+                  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t     gfc_index_one_node, lbound);\n+                  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t     ubound, tmp);\n+                  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t      size, tmp);\n                   stmt_packed = size;\n                 }\n \n@@ -3759,10 +3759,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \n \t  tmp = gfc_conv_array_lbound (desc, n);\n-\t  tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (tmp), start, tmp));\n+\t  tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), start, tmp);\n \n-\t  tmp = fold (build2 (MULT_EXPR, TREE_TYPE (tmp), tmp, stride));\n-\t  offset = fold (build2 (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp));\n+\t  tmp = fold_build2 (MULT_EXPR, TREE_TYPE (tmp), tmp, stride);\n+\t  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp);\n \n \t  if (info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n@@ -3779,9 +3779,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n           if (!integer_onep (from))\n \t    {\n \t      /* Make sure the new section starts at 1.  */\n-\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_index_one_node, from));\n-\t      to = fold (build2 (PLUS_EXPR, gfc_array_index_type, to, tmp));\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, from);\n+\t      to = fold_build2 (PLUS_EXPR, gfc_array_index_type, to, tmp);\n \t      from = gfc_index_one_node;\n \t    }\n \t  tmp = gfc_conv_descriptor_lbound (parm, gfc_rank_cst[dim]);\n@@ -3793,12 +3793,12 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n \t  /* Multiply the stride by the section stride to get the\n \t     total stride.  */\n-\t  stride = fold (build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t stride, info->stride[dim]));\n+\t  stride = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\tstride, info->stride[dim]);\n \n \t  if (se->direct_byref)\n-\t    base = fold (build2 (MINUS_EXPR, TREE_TYPE (base),\n-\t\t\t\t base, stride));\n+\t    base = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n+\t\t\t\tbase, stride);\n \n \t  /* Store the new stride.  */\n \t  tmp = gfc_conv_descriptor_stride (parm, gfc_rank_cst[dim]);"}, {"sha": "2db5fbdc7bbfa31a108b2839bdeb130be3ad7187", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -513,7 +513,7 @@ gfc_conv_powi (gfc_se * se, int n, tree * tmpvar)\n       op1 = op0;\n     }\n \n-  tmp = fold (build2 (MULT_EXPR, TREE_TYPE (op0), op0, op1));\n+  tmp = fold_build2 (MULT_EXPR, TREE_TYPE (op0), op0, op1);\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   if (n < POWI_TABLE_SIZE)\n@@ -738,9 +738,8 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n   if (gfc_can_put_var_on_stack (len))\n     {\n       /* Create a temporary variable to hold the result.  */\n-      tmp = fold (build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n-\t\t\t  convert (gfc_charlen_type_node,\n-\t\t\t\t   integer_one_node)));\n+      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n+\t\t\t convert (gfc_charlen_type_node, integer_one_node));\n       tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n       tmp = build_array_type (gfc_character1_type_node, tmp);\n       var = gfc_create_var (tmp, \"str\");\n@@ -797,8 +796,8 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   len = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n   if (len == NULL_TREE)\n     {\n-      len = fold (build2 (PLUS_EXPR, TREE_TYPE (lse.string_length),\n-\t\t\t  lse.string_length, rse.string_length));\n+      len = fold_build2 (PLUS_EXPR, TREE_TYPE (lse.string_length),\n+\t\t\t lse.string_length, rse.string_length);\n     }\n \n   type = build_pointer_type (type);\n@@ -990,11 +989,11 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n   if (lop)\n     {\n       /* The result of logical ops is always boolean_type_node.  */\n-      tmp = fold (build2 (code, type, lse.expr, rse.expr));\n+      tmp = fold_build2 (code, type, lse.expr, rse.expr);\n       se->expr = convert (type, tmp);\n     }\n   else\n-    se->expr = fold (build2 (code, type, lse.expr, rse.expr));\n+    se->expr = fold_build2 (code, type, lse.expr, rse.expr);\n \n   /* Add the post blocks.  */\n   gfc_add_block_to_block (&se->post, &rse.post);"}, {"sha": "45581745b44ddc3267f5ccd4ab42495b415df958", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -264,11 +264,11 @@ build_round_expr (stmtblock_t * pblock, tree arg, tree type)\n   neg = build_real (argtype, r);\n \n   tmp = gfc_build_const (argtype, integer_zero_node);\n-  cond = fold (build2 (GT_EXPR, boolean_type_node, arg, tmp));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node, arg, tmp);\n \n-  tmp = fold (build3 (COND_EXPR, argtype, cond, pos, neg));\n-  tmp = fold (build2 (PLUS_EXPR, argtype, arg, tmp));\n-  return fold (build1 (FIX_TRUNC_EXPR, type, tmp));\n+  tmp = fold_build3 (COND_EXPR, argtype, cond, pos, neg);\n+  tmp = fold_build2 (PLUS_EXPR, argtype, arg, tmp);\n+  return fold_build1 (FIX_TRUNC_EXPR, type, tmp);\n }\n \n \n@@ -645,8 +645,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       gcc_assert (se->ss->expr == expr);\n       gfc_advance_se_ss_chain (se);\n       bound = se->loop->loopvar[0];\n-      bound = fold (build2 (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t    se->loop->from[0]));\n+      bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t   se->loop->from[0]);\n     }\n   else\n     {\n@@ -657,8 +657,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       bound = argse.expr;\n       /* Convert from one based to zero based.  */\n-      bound = fold (build2 (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t    gfc_index_one_node));\n+      bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t   gfc_index_one_node);\n     }\n \n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n@@ -683,11 +683,11 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       if (flag_bounds_check)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n-          cond = fold (build2 (LT_EXPR, boolean_type_node,\n-\t\t\t       bound, build_int_cst (TREE_TYPE (bound), 0)));\n+          cond = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t      bound, build_int_cst (TREE_TYPE (bound), 0));\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n-          tmp = fold (build2 (GE_EXPR, boolean_type_node, bound, tmp));\n-          cond = fold(build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp));\n+          tmp = fold_build2 (GE_EXPR, boolean_type_node, bound, tmp);\n+          cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n           gfc_trans_runtime_check (cond, gfc_strconst_fault, &se->pre);\n         }\n     }\n@@ -765,7 +765,7 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n   else\n     imag = build_real_from_int_cst (TREE_TYPE (type), integer_zero_node);\n \n-  se->expr = fold (build2 (COMPLEX_EXPR, type, real, imag));\n+  se->expr = fold_build2 (COMPLEX_EXPR, type, real, imag);\n }\n \n /* Remainder function MOD(A, P) = A - INT(A / P) * P\n@@ -903,11 +903,11 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n   zero = gfc_build_const (type, integer_zero_node);\n \n-  testa = fold (build2 (GE_EXPR, boolean_type_node, arg, zero));\n-  testb = fold (build2 (GE_EXPR, boolean_type_node, arg2, zero));\n-  tmp = fold (build2 (TRUTH_XOR_EXPR, boolean_type_node, testa, testb));\n-  se->expr = fold (build3 (COND_EXPR, type, tmp,\n-\t\t\t   build1 (NEGATE_EXPR, type, arg), arg));\n+  testa = fold_build2 (GE_EXPR, boolean_type_node, arg, zero);\n+  testb = fold_build2 (GE_EXPR, boolean_type_node, arg2, zero);\n+  tmp = fold_build2 (TRUTH_XOR_EXPR, boolean_type_node, testa, testb);\n+  se->expr = fold_build3 (COND_EXPR, type, tmp,\n+\t\t\t  build1 (NEGATE_EXPR, type, arg), arg);\n }\n \n \n@@ -1433,7 +1433,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Most negative(+HUGE) for maxval, most negative (-HUGE) for minval.  */\n   if (op == GT_EXPR)\n-    tmp = fold (build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp));\n+    tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n   gfc_add_modify_expr (&se->pre, limit, tmp);\n \n   /* Initialize the scalarizer.  */\n@@ -1452,12 +1452,12 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n      size we need to return zero.  Otherwise use the first element of the\n      array, in case all elements are equal to the limit.\n      i.e. pos = (ubound >= lbound) ? lbound, lbound - 1;  */\n-  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t      loop.from[0], gfc_index_one_node));\n-  cond = fold (build2 (GE_EXPR, boolean_type_node,\n-\t\t       loop.to[0], loop.from[0]));\n-  tmp = fold (build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t      loop.from[0], tmp));\n+  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t     loop.from[0], gfc_index_one_node);\n+  cond = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t      loop.to[0], loop.from[0]);\n+  tmp = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t     loop.from[0], tmp);\n   gfc_add_modify_expr (&loop.pre, pos, tmp);\n \n   gfc_mark_ss_chain_used (arrayss, 1);\n@@ -1521,9 +1521,9 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   gfc_cleanup_loop (&loop);\n \n   /* Return a value in the range 1..SIZE(array).  */\n-  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n-\t\t      gfc_index_one_node));\n-  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, pos, tmp));\n+  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n+\t\t     gfc_index_one_node);\n+  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, pos, tmp);\n   /* And convert to the required type.  */\n   se->expr = convert (type, tmp);\n }\n@@ -1573,7 +1573,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Most negative(-HUGE) for maxval, most positive (-HUGE) for minval.  */\n   if (op == GT_EXPR)\n-    tmp = fold (build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp));\n+    tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n   gfc_add_modify_expr (&se->pre, limit, tmp);\n \n   /* Walk the arguments.  */\n@@ -1670,8 +1670,8 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n \n   tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n   tmp = build2 (BIT_AND_EXPR, type, arg, tmp);\n-  tmp = fold (build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\t      build_int_cst (type, 0)));\n+  tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n+\t\t     build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, tmp);\n }\n@@ -1689,7 +1689,7 @@ gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, int op)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  se->expr = fold (build2 (op, type, arg, arg2));\n+  se->expr = fold_build2 (op, type, arg, arg2);\n }\n \n /* Bitwise not.  */\n@@ -1719,15 +1719,15 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  tmp = fold (build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2));\n+  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n   if (set)\n     op = BIT_IOR_EXPR;\n   else\n     {\n       op = BIT_AND_EXPR;\n-      tmp = fold (build1 (BIT_NOT_EXPR, type, tmp));\n+      tmp = fold_build1 (BIT_NOT_EXPR, type, tmp);\n     }\n-  se->expr = fold (build2 (op, type, arg, tmp));\n+  se->expr = fold_build2 (op, type, arg, tmp);\n }\n \n /* Extract a sequence of bits.\n@@ -1755,7 +1755,7 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n \n   tmp = build2 (RSHIFT_EXPR, type, arg, arg2);\n \n-  se->expr = fold (build2 (BIT_AND_EXPR, type, tmp, mask));\n+  se->expr = fold_build2 (BIT_AND_EXPR, type, tmp, mask);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n@@ -1782,10 +1782,10 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n   utype = gfc_unsigned_type (type);\n \n-  width = fold (build1 (ABS_EXPR, TREE_TYPE (arg2), arg2));\n+  width = fold_build1 (ABS_EXPR, TREE_TYPE (arg2), arg2);\n \n   /* Left shift if positive.  */\n-  lshift = fold (build2 (LSHIFT_EXPR, type, arg, width));\n+  lshift = fold_build2 (LSHIFT_EXPR, type, arg, width);\n \n   /* Right shift if negative.\n      We convert to an unsigned type because we want a logical shift.\n@@ -1795,18 +1795,18 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   rshift = fold_convert (type, build2 (RSHIFT_EXPR, utype, \n \t\t\t\t       convert (utype, arg), width));\n \n-  tmp = fold (build2 (GE_EXPR, boolean_type_node, arg2,\n-\t\t      build_int_cst (TREE_TYPE (arg2), 0)));\n-  tmp = fold (build3 (COND_EXPR, type, tmp, lshift, rshift));\n+  tmp = fold_build2 (GE_EXPR, boolean_type_node, arg2,\n+\t\t     build_int_cst (TREE_TYPE (arg2), 0));\n+  tmp = fold_build3 (COND_EXPR, type, tmp, lshift, rshift);\n \n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (arg2), TYPE_PRECISION (type));\n-  cond = fold (build2 (GE_EXPR, boolean_type_node, width, num_bits));\n+  cond = fold_build2 (GE_EXPR, boolean_type_node, width, num_bits);\n \n-  se->expr = fold (build3 (COND_EXPR, type, cond,\n-\t\t\t   build_int_cst (type, 0), tmp));\n+  se->expr = fold_build3 (COND_EXPR, type, cond,\n+\t\t\t  build_int_cst (type, 0), tmp);\n }\n \n /* Circular shift.  AKA rotate or barrel shift.  */\n@@ -1872,19 +1872,19 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n \n   /* Rotate left if positive.  */\n-  lrot = fold (build2 (LROTATE_EXPR, type, arg, arg2));\n+  lrot = fold_build2 (LROTATE_EXPR, type, arg, arg2);\n \n   /* Rotate right if negative.  */\n-  tmp = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2));\n-  rrot = fold (build2 (RROTATE_EXPR, type, arg, tmp));\n+  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n+  rrot = fold_build2 (RROTATE_EXPR, type, arg, tmp);\n \n   zero = build_int_cst (TREE_TYPE (arg2), 0);\n-  tmp = fold (build2 (GT_EXPR, boolean_type_node, arg2, zero));\n-  rrot = fold (build3 (COND_EXPR, type, tmp, lrot, rrot));\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, arg2, zero);\n+  rrot = fold_build3 (COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = fold (build2 (EQ_EXPR, boolean_type_node, arg2, zero));\n-  se->expr = fold (build3 (COND_EXPR, type, tmp, arg, rrot));\n+  tmp = fold_build2 (EQ_EXPR, boolean_type_node, arg2, zero);\n+  se->expr = fold_build3 (COND_EXPR, type, tmp, arg, rrot);\n }\n \n /* The length of a character string.  */\n@@ -2037,7 +2037,7 @@ gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n       se->string_length = len;\n     }\n   type = TREE_TYPE (tsource);\n-  se->expr = fold (build3 (COND_EXPR, type, mask, tsource, fsource));\n+  se->expr = fold_build3 (COND_EXPR, type, mask, tsource, fsource);\n }\n \n \n@@ -2374,18 +2374,18 @@ prepare_arg_info (gfc_se * se, gfc_expr * expr,\n    rcs->fdigits = convert (masktype, tmp);\n    wbits = build_int_cst (NULL_TREE, TYPE_PRECISION (rcs->type) - 1);\n    wbits = convert (masktype, wbits);\n-   rcs->edigits = fold (build2 (MINUS_EXPR, masktype, wbits, tmp));\n+   rcs->edigits = fold_build2 (MINUS_EXPR, masktype, wbits, tmp);\n \n    /* Form masks for exponent/fraction/sign  */\n    one = gfc_build_const (masktype, integer_one_node);\n-   rcs->smask = fold (build2 (LSHIFT_EXPR, masktype, one, wbits));\n-   rcs->f1 = fold (build2 (LSHIFT_EXPR, masktype, one, rcs->fdigits));\n-   rcs->emask = fold (build2 (MINUS_EXPR, masktype, rcs->smask, rcs->f1));\n-   rcs->fmask = fold (build2 (MINUS_EXPR, masktype, rcs->f1, one));\n+   rcs->smask = fold_build2 (LSHIFT_EXPR, masktype, one, wbits);\n+   rcs->f1 = fold_build2 (LSHIFT_EXPR, masktype, one, rcs->fdigits);\n+   rcs->emask = fold_build2 (MINUS_EXPR, masktype, rcs->smask, rcs->f1);\n+   rcs->fmask = fold_build2 (MINUS_EXPR, masktype, rcs->f1, one);\n    /* Form bias.  */\n-   tmp = fold (build2 (MINUS_EXPR, masktype, rcs->edigits, one));\n-   tmp = fold (build2 (LSHIFT_EXPR, masktype, one, tmp));\n-   rcs->bias = fold (build2 (MINUS_EXPR, masktype, tmp ,one));\n+   tmp = fold_build2 (MINUS_EXPR, masktype, rcs->edigits, one);\n+   tmp = fold_build2 (LSHIFT_EXPR, masktype, one, tmp);\n+   rcs->bias = fold_build2 (MINUS_EXPR, masktype, tmp ,one);\n \n    if (all)\n      {\n@@ -2510,7 +2510,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n    fraction = rcs.frac;\n    one = gfc_build_const (masktype, integer_one_node);\n    zero = gfc_build_const (masktype, integer_zero_node);\n-   t2 = fold (build2 (PLUS_EXPR, masktype, rcs.edigits, one));\n+   t2 = fold_build2 (PLUS_EXPR, masktype, rcs.edigits, one);\n \n    t1 = call_builtin_clz (masktype, fraction);\n    tmp = build2 (PLUS_EXPR, masktype, t1, one);\n@@ -2519,8 +2519,8 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n    cond = build2 (EQ_EXPR, boolean_type_node, rcs.expn, zero);\n    fraction = build3 (COND_EXPR, masktype, cond, tmp, fraction);\n \n-   tmp = fold (build2 (PLUS_EXPR, masktype, rcs.bias, fdigits));\n-   tmp = fold (build2 (LSHIFT_EXPR, masktype, tmp, fdigits));\n+   tmp = fold_build2 (PLUS_EXPR, masktype, rcs.bias, fdigits);\n+   tmp = fold_build2 (LSHIFT_EXPR, masktype, tmp, fdigits);\n    tmp = build2 (BIT_IOR_EXPR, masktype, tmp, fraction);\n \n    cond2 = build2 (EQ_EXPR, boolean_type_node, rcs.frac, zero);\n@@ -2634,7 +2634,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   len = TREE_VALUE (args);\n   tmp = gfc_advance_chain (args, 2);\n   ncopies = TREE_VALUE (tmp);\n-  len = fold (build2 (MULT_EXPR, gfc_int4_type_node, len, ncopies));\n+  len = fold_build2 (MULT_EXPR, gfc_int4_type_node, len, ncopies);\n   type = gfc_get_character_type (expr->ts.kind, expr->ts.cl);\n   var = gfc_conv_string_tmp (se, build_pointer_type (type), len);\n "}, {"sha": "3adf86879e9389ed6f23f801c7e9f838404e7c3e", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -587,9 +587,9 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \n   /* Only execute the loop if the number of iterations is positive.  */\n   if (tree_int_cst_sgn (step) > 0)\n-    cond = fold (build2 (LE_EXPR, boolean_type_node, dovar, to));\n+    cond = fold_build2 (LE_EXPR, boolean_type_node, dovar, to);\n   else\n-    cond = fold (build2 (GE_EXPR, boolean_type_node, dovar, to));\n+    cond = fold_build2 (GE_EXPR, boolean_type_node, dovar, to);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (pblock, tmp);\n \n@@ -685,20 +685,20 @@ gfc_trans_do (gfc_code * code)\n   /* Initialize loop count. This code is executed before we enter the\n      loop body. We generate: count = (to + step - from) / step.  */\n \n-  tmp = fold (build2 (MINUS_EXPR, type, step, from));\n-  tmp = fold (build2 (PLUS_EXPR, type, to, tmp));\n+  tmp = fold_build2 (MINUS_EXPR, type, step, from);\n+  tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n   if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      tmp = fold (build2 (TRUNC_DIV_EXPR, type, tmp, step));\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n       count = gfc_create_var (type, \"count\");\n     }\n   else\n     {\n       /* TODO: We could use the same width as the real type.\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n-      tmp = fold (build2 (RDIV_EXPR, type, tmp, step));\n-      tmp = fold (build1 (FIX_TRUNC_EXPR, gfc_array_index_type, tmp));\n+      tmp = fold_build2 (RDIV_EXPR, type, tmp, step);\n+      tmp = fold_build1 (FIX_TRUNC_EXPR, gfc_array_index_type, tmp);\n       count = gfc_create_var (gfc_array_index_type, \"count\");\n     }\n   gfc_add_modify_expr (&block, count, tmp);\n@@ -810,7 +810,7 @@ gfc_trans_do_while (gfc_code * code)\n   gfc_init_se (&cond, NULL);\n   gfc_conv_expr_val (&cond, code->expr);\n   gfc_add_block_to_block (&block, &cond.pre);\n-  cond.expr = fold (build1 (TRUTH_NOT_EXPR, boolean_type_node, cond.expr));\n+  cond.expr = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond.expr);\n \n   /* Build \"IF (! cond) GOTO exit_label\".  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n@@ -1388,9 +1388,9 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n       gfc_add_modify_expr (&block, var, start);\n \n       /* Initialize the loop counter.  */\n-      tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (var), step, start));\n-      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp));\n-      tmp = fold (build2 (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step));\n+      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), step, start);\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp);\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step);\n       gfc_add_modify_expr (&block, count, tmp);\n \n       /* The loop expression.  */\n@@ -1479,8 +1479,8 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n \n   if (INTEGER_CST_P (size))\n     {\n-      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t  gfc_index_one_node));\n+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t\t gfc_index_one_node);\n     }\n   else\n     tmp = NULL_TREE;\n@@ -1548,7 +1548,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_add_block_to_block (&block, &lse.post);\n \n       /* Increment the count1.  */\n-      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n       gfc_add_modify_expr (&block, count1, tmp);\n       tmp = gfc_finish_block (&block);\n     }\n@@ -1582,8 +1582,8 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       /* Form the expression of the temporary.  */\n       if (lss != gfc_ss_terminator)\n         {\n-          index = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\tcount1, count2));\n+          index = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       count1, count2);\n           rse.expr = gfc_build_array_ref (tmp1, index);\n         }\n       /* Translate expr.  */\n@@ -1610,15 +1610,15 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_add_expr_to_block (&body, tmp);\n \n       /* Increment count2.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count2, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count2, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      count3, gfc_index_one_node));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count3, gfc_index_one_node);\n           gfc_add_modify_expr (&body, count3, tmp);\n         }\n \n@@ -1629,7 +1629,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_cleanup_loop (&loop1);\n \n       /* Increment count1.  */\n-      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n       gfc_add_modify_expr (&block, count1, tmp);\n       tmp = gfc_finish_block (&block);\n     }\n@@ -1689,7 +1689,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n       gfc_conv_expr (&rse, expr2);\n \n       /* Form the expression of the temporary.  */\n-      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, count1, count2));\n+      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, count1, count2);\n       lse.expr = gfc_build_array_ref (tmp1, index);\n     }\n \n@@ -1720,15 +1720,15 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n   else\n     {\n       /* Increment count2.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count2, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count2, gfc_index_one_node);\n       gfc_add_modify_expr (&body1, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      count3, gfc_index_one_node));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count3, gfc_index_one_node);\n           gfc_add_modify_expr (&body1, count3, tmp);\n         }\n \n@@ -1743,7 +1743,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n          as tree nodes in SS may not be valid in different scope.  */\n     }\n   /* Increment count1.  */\n-  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n   gfc_add_modify_expr (&block, count1, tmp);\n \n   tmp = gfc_finish_block (&block);\n@@ -1800,11 +1800,11 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n       /* Figure out how many elements we need.  */\n       for (i = 0; i < loop.dimen; i++)\n         {\n-\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t      gfc_index_one_node, loop.from[i]));\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      tmp, loop.to[i]));\n-          size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_index_one_node, loop.from[i]);\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, loop.to[i]);\n+          size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n         }\n       gfc_add_block_to_block (pblock, &loop.pre);\n       size = gfc_evaluate_now (size, pblock);\n@@ -1868,7 +1868,7 @@ allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n   size = compute_overall_iter_number (nested_forall_info, inner_size, block);\n \n   unit = TYPE_SIZE_UNIT (type);\n-  bytesize = fold (build2 (MULT_EXPR, gfc_array_index_type, size, unit));\n+  bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size, unit);\n \n   *ptemp1 = NULL;\n   temp1 = gfc_do_allocate (bytesize, size, ptemp1, block, type);\n@@ -2033,8 +2033,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &rse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2078,8 +2078,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify_expr (&body, lse.expr, rse.expr);\n       gfc_add_block_to_block (&body, &lse.post);\n       /* Increment count.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n@@ -2122,8 +2122,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2167,8 +2167,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2345,14 +2345,14 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \tlenvar = NULL_TREE;\n \n       /* size = (end + step - start) / step.  */\n-      tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (start[n]), \n-\t\t\t  step[n], start[n]));\n-      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (end[n]), end[n], tmp));\n+      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (start[n]), \n+\t\t\t step[n], start[n]);\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (end[n]), end[n], tmp);\n \n-      tmp = fold (build2 (FLOOR_DIV_EXPR, TREE_TYPE (tmp), tmp, step[n]));\n+      tmp = fold_build2 (FLOOR_DIV_EXPR, TREE_TYPE (tmp), tmp, step[n]);\n       tmp = convert (gfc_array_index_type, tmp);\n \n-      size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n     }\n \n   /* Record the nvar and size of current forall level.  */\n@@ -2376,8 +2376,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   if (code->expr)\n     {\n       /* Allocate the mask temporary.  */\n-      bytesize = fold (build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t       TYPE_SIZE_UNIT (boolean_type_node)));\n+      bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\t      TYPE_SIZE_UNIT (boolean_type_node));\n \n       mask = gfc_do_allocate (bytesize, size, &pmask, &block, boolean_type_node);\n \n@@ -2658,8 +2658,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   else\n     {\n       /* Increment count.  */\n-      tmp1 = fold (build2 (PLUS_EXPR, gfc_array_index_type, count,\n-                          gfc_index_one_node));\n+      tmp1 = fold_build2 (PLUS_EXPR, gfc_array_index_type, count,\n+                          gfc_index_one_node);\n       gfc_add_modify_expr (&body1, count, tmp1);\n \n       /* Generate the copying loops.  */\n@@ -2825,8 +2825,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n   if (lss == gfc_ss_terminator)\n     {\n       /* Increment count1.  */\n-      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  count1, gfc_index_one_node));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count1, gfc_index_one_node);\n       gfc_add_modify_expr (&body, count1, tmp);\n \n       /* Use the scalar assignment as is.  */\n@@ -2841,8 +2841,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n         {\n           /* Increment count1 before finish the main body of a scalarized\n              expression.  */\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      count1, gfc_index_one_node));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count1, gfc_index_one_node);\n           gfc_add_modify_expr (&body, count1, tmp);\n           gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n@@ -2884,15 +2884,15 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n           gfc_add_expr_to_block (&body, tmp);\n \n           /* Increment count2.  */\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      count2, gfc_index_one_node));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count2, gfc_index_one_node);\n           gfc_add_modify_expr (&body, count2, tmp);\n         }\n       else\n         {\n           /* Increment count1.  */\n-          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      count1, gfc_index_one_node));\n+          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count1, gfc_index_one_node);\n           gfc_add_modify_expr (&body, count1, tmp);\n         }\n "}, {"sha": "b64f868dbaddf836a8f56a6c52959e450226951a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -926,8 +926,8 @@ gfc_get_dtype (tree type)\n   if (size && !INTEGER_CST_P (size))\n     {\n       tmp = build_int_cst (gfc_array_index_type, GFC_DTYPE_SIZE_SHIFT);\n-      tmp  = fold (build2 (LSHIFT_EXPR, gfc_array_index_type, size, tmp));\n-      dtype = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp, dtype));\n+      tmp  = fold_build2 (LSHIFT_EXPR, gfc_array_index_type, size, tmp);\n+      dtype = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, dtype);\n     }\n   /* If we don't know the size we leave it as zero.  This should never happen\n      for anything that is actually used.  */\n@@ -1160,11 +1160,11 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \n       if (upper != NULL_TREE && lower != NULL_TREE && stride != NULL_TREE)\n \t{\n-\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, upper, lower));\n-\t  tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t      gfc_index_one_node));\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, upper, lower);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n+\t\t\t     gfc_index_one_node);\n \t  stride =\n-\t    fold (build2 (MULT_EXPR, gfc_array_index_type, tmp, stride));\n+\t    fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, stride);\n \t  /* Check the folding worked.  */\n \t  gcc_assert (INTEGER_CST_P (stride));\n \t}"}, {"sha": "70630cbecabab59f42550e209dd672ce443b9d63", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c7a96fe66b8281a105a3597c51d0d718883b5f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=10c7a96fe66b8281a105a3597c51d0d718883b5f", "patch": "@@ -152,7 +152,7 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n-  tmp = fold (build2_v (MODIFY_EXPR, lhs, rhs));\n+  tmp = fold_build2 (MODIFY_EXPR, void_type_node, lhs, rhs);\n   gfc_add_expr_to_block (pblock, tmp);\n }\n "}]}