{"sha": "325217edf0332af8e5e52a32eb9b3cd862646375", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1MjE3ZWRmMDMzMmFmOGU1ZTUyYTMyZWI5YjNjZDg2MjY0NjM3NQ==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-08-08T22:29:12Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-08-08T22:29:12Z"}, "message": "tree.def (FIXED_POINT_TYPE): New type.\n\n\t* tree.def (FIXED_POINT_TYPE): New type.\n\t(FIXED_CST): New constant.\n\t(FIXED_CONVERT_EXPR): New expr.\n\t* doc/c-tree.texi (Types): Document FIXED_POINT_TYPE.\n\t(Expressions): Document FIXED_CST and FIXED_CONVERT_EXPR.\n\t* tree.h (struct tree_base): Add saturating_flag.\n\tRemove one bit of spare for saturating_flag.\n\t(NUMERICAL_TYPE_CHECK): Support FIXED_POINT_TYPE.\n\t(NON_SAT_FIXED_POINT_TYPE_P, SAT_FIXED_POINT_TYPE_P,\n\tFIXED_POINT_TYPE_P): Define.\n\t(TYPE_SATURATING): Define.\n\t(TREE_FIXED_CST_PTR, TREE_FIXED_CST): Define.\n\t(struct tree_fixed_cst): New.\n\t(TYPE_IBIT, TYPE_FBIT): Define.\n\t(tree_node): Add fixed_cst.\n\t(enum tree_index): Add new enumeration values of\n\tTI_SAT_SFRACT_TYPE, TI_SAT_FRACT_TYPE, TI_SAT_LFRACT_TYPE,\n\tTI_SAT_LLFRACT_TYPE, TI_SAT_USFRACT_TYPE, TI_SAT_UFRACT_TYPE,\n\tTI_SAT_ULFRACT_TYPE, TI_SAT_ULLFRACT_TYPE, TI_SFRACT_TYPE,\n\tTI_FRACT_TYPE, TI_LFRACT_TYPE, TI_LLFRACT_TYPE, TI_USFRACT_TYPE,\n\tTI_UFRACT_TYPE, TI_ULFRACT_TYPE, TI_ULLFRACT_TYPE,\n\tTI_SAT_SACCUM_TYPE, TI_SAT_ACCUM_TYPE, TI_SAT_LACCUM_TYPE,\n\tTI_SAT_LLACCUM_TYPE, TI_SAT_USACCUM_TYPE, TI_SAT_UACCUM_TYPE,\n\tTI_SAT_ULACCUM_TYPE, TI_SAT_ULLACCUM_TYPE, TI_SACCUM_TYPE,\n\tTI_ACCUM_TYPE, TI_LACCUM_TYPE, TI_LLACCUM_TYPE, TI_USACCUM_TYPE,\n\tTI_UACCUM_TYPE, TI_ULACCUM_TYPE, TI_ULLACCUM_TYPE,\n\tTI_QQ_TYPE, TI_HQ_TYPE,_TYPE, TI_SQ_TYPE, TI_DQ_TYPE, TI_TQ_TYPE,\n\tTI_UQQ_TYPE, TI_UHQ_TYPE, TI_USQ_TYPE, TI_UDQ_TYPE, TI_UTQ_TYPE,\n\tTI_SAT_QQ_TYPE, TI_SAT_HQ_TYPE, TI_SAT_SQ_TYPE, TI_SAT_DQ_TYPE,\n\tTI_SAT_TQ_TYPE, TI_SAT_UQQ_TYPE, TI_SAT_UHQ_TYPE, TI_SAT_USQ_TYPE,\n\tTI_SAT_UDQ_TYPE, TI_SAT_UTQ_TYPE, TI_HA_TYPE, TI_SA_TYPE, TI_DA_TYPE,\n\tTI_TA_TYPE, TI_UHA_TYPE, TI_USA_TYPE, TI_UDA_TYPE, TI_UTA_TYPE,\n\tTI_SAT_HA_TYPE, TI_SAT_SA_TYPE, TI_SAT_DA_TYPE, TI_SAT_TA_TYPE,\n\tTI_SAT_UHA_TYPE, TI_SAT_USA_TYPE, TI_SAT_UDA_TYPE, TI_SAT_UTA_TYPE.\n\t(sat_short_fract_type_node, sat_fract_type_node,\n\tsat_long_fract_type_node, sat_long_long_fract_type_node,\n\tsat_unsigned_short_fract_type_node, sat_unsigned_fract_type_node,\n\tsat_unsigned_long_fract_type_node,\n\tsat_unsigned_long_long_fract_type_node, short_fract_type_node,\n\tfract_type_node, long_fract_type_node, long_long_fract_type_node,\n\tunsigned_short_fract_type_node, unsigned_fract_type_node,\n\tunsigned_long_fract_type_node, unsigned_long_long_fract_type_node,\n\tsat_short_accum_type_node, sat_accum_type_node,\n\tsat_long_accum_type_node, sat_long_long_accum_type_node,\n\tsat_unsigned_short_accum_type_node, sat_unsigned_accum_type_node,\n\tsat_unsigned_long_accum_type_node,\n\tsat_unsigned_long_long_accum_type_node, short_accum_type_node,\n\taccum_type_node, long_accum_type_node, long_long_accum_type_node,\n\tunsigned_short_accum_type_node, unsigned_accum_type_node,\n\tunsigned_long_accum_type_node, unsigned_long_long_accum_type_node,\n\tqq_type_node, hq_type_node, sq_type_node, dq_type_node, tq_type_node,\n\tuqq_type_node, uhq_type_node, usq_type_node, udq_type_node,\n\tutq_type_node, sat_qq_type_node, sat_hq_type_node, sat_sq_type_node,\n\tsat_dq_type_node, sat_tq_type_node, sat_uqq_type_node,\n\tsat_uhq_type_node, sat_usq_type_node, sat_udq_type_node,\n\tsat_utq_type_node, ha_type_node, sa_type_node, da_type_node,\n\tta_type_node, uha_type_node, usa_type_node, uda_type_node,\n\tuta_type_node, sat_ha_type_node, sat_sa_type_node, sat_da_type_node,\n\tsat_ta_type_node, sat_uha_type_node, sat_usa_type_node,\n\tsat_uda_type_node, sat_uta_type_node): New macro.\n\t(make_fract_type, make_accum_type): Declare.\n\t(make_signed_fract_type, make_unsigned_fract_type,\n\tmake_sat_signed_fract_type, make_sat_unsigned_fract_type,\n\tmake_signed_accum_type, make_unsigned_accum_type,\n\tmake_sat_signed_accum_type, make_sat_unsigned_accum_type,\n\tmake_or_reuse_signed_fract_type, make_or_reuse_unsigned_fract_type,\n\tmake_or_reuse_sat_signed_fract_type,\n\tmake_or_reuse_sat_unsigned_fract_type, make_or_reuse_signed_accum_type,\n\tmake_or_reuse_unsigned_accum_type, make_or_reuse_sat_signed_accum_type,\n\tmake_or_reuse_sat_unsigned_accum_type): New macro.\n\t(fixed_zerop): Declare.\n\t* defaults.h (SHORT_FRACT_TYPE_SIZE, FRACT_TYPE_SIZE,\n\tLONG_FRACT_TYPE_SIZE, LONG_LONG_FRACT_TYPE_SIZE,\n\tSHORT_ACCUM_TYPE_SIZE, ACCUM_TYPE_SIZE, LONG_ACCUM_TYPE_SIZE,\n\tLONG_LONG_ACCUM_TYPE_SIZE): Define.\n\t* treestruct.def: Add TS_FIXED_CST.\n\t* Makefile.in (c-pretty-print.o): Add dependence on fixed-value.h.\n\t(tree.o): Likewise.\n\t(tree-dump.o): Likewise.\n\t(print-tree.o): Likewise.\n\t(tree-pretty-print.o): Likewise.\n\t(fold-const.o): Likewise.\n\t* tree-complex.c (some_nonzerop): Handle FIXED_CST.\n\t* tree-gimple.c (is_gimple_formal_tmp_rhs): Handle FIXED_CST.\n\t(is_gimple_min_invariant): Handle FIXED_CST.\n\t* stor-layout.c (int_mode_for_mode): Handle MODE_FRACT, MODE_UFRACT,\n\tMODE_ACCUM, MODE_UACCUM, MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT,\n\tMODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\t(layout_type): Handle FIXED_POINT_TYPE.\n\t(make_fract_type, make_accum_type): New functions.\n\t* tree-browser.c (browse_tree): Handle FIXED_POINT_TYPE.\n\t* tree-dump.c (fixed-value.h): New include.\n\t(dump_fixed): New function.\n\t(dequeue_and_dump): Handle FIXED_POINT_TYPE and FIXED_CST.\n\t* tree-inline.c (remap_type_1): Handle FIXED_POINT_TYPE.\n\t(estimate_num_insns_1): Handle FIXED_CST and FIXED_CONVERT_EXPR.\n\t* tree-pretty-print.c (fixed-value.h): New include.\n\t(dump_generic_node): Handle FIXED_POINT_TYPE, FIXED_CST, and\n\tFIXED_CONVERT_EXPR.\n\t* tree-scalar-evolution.c (get_scalar_evolution): Handle FIXED_CST.\n\t* tree-ssa-loop-im.c (for_each_index): Handle FIXED_CST.\n\t* tree-ssa-pre.c (poolify_tree): Handle FIXED_CST.\n\t* tree-ssa-reassoc.c (break_up_subtract_bb): We can do reassociation\n\tfor non-saturating fixed-point types.\n\t(reassociate_bb): Likewise.\n\t* emit-rtl.c (fixed-value.h): New include.\n\t(fconst0, fconst1): New array.\n\t(init_emit_once): Initialize fconst0 and fconst1 for fixed-point modes.\n\t* tree-vect-generic.c expand_vector_operation): Support\n\tMODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, and\n\tMODE_VECTOR_UACCUM.\n\t(type_for_widest_vector_mode): Add one parameter for the \n\tsaturating flag.\n\tCheck scalar FRACT, UFRACT, ACCUM, and UACCUM mode to select their\n\tvector mode.\n\tPass the satp parameter to type_for_mode for fixed-point types.\n\t(expand_vector_operations_1): Pass the saturating flag to\n\ttype_for_widest_vector_mode.\n\tSupport MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n\tand MODE_VECTOR_UACCUM.\n\t* tree-vect-transform.c (vect_is_simple_cond): Support FIXED_CST.\n\t(vectorizable_condition): Likewise.\n\t* tree.c (fixed-value.h): New include.\n\t(tree_code_size): Support FIXED_CST.\n\t(build_fixed): New function.\n\t(build_one_cst): Support FIXED_POINT_TYPE for accum types.\n\t(fixed_zerop): New function.\n\t(tree_node_structure): Support FIXED_CST.\n\t(type_contains_placeholder_1): Support FIXED_POINT_TYPE.\n\t(build_type_attribute_qual_variant): Handle FIXED_POINT_TYPE.\n\t(type_hash_eq): Handle FIXED_POINT_TYPE.\n\t(simple_cst_equal): Support FIXED_CST.\n\t(iterative_hash_expr): Handle FIXED_CST.\n\t(get_unwidened): Make sure type is not FIXED_POINT_TYPE.\n\t(get_narrower): Likewise.\n\t(variably_modified_type_p): Handle FIXED_POINT_TYPE.\n\t(make_or_reuse_fract_type, make_or_reuse_accum_type): New functions.\n\t(build_common_tree_nodes_2): Use MAKE_FIXED_TYPE_NODE_FAMILY and\n\tMAKE_FIXED_MODE_NODE macros to initialize fixed-point type\n\tnodes.\n\t(build_vector_type_for_mode): Handle MODE_VECTOR_FRACT,\n\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\t(initializer_zerop): Support FIXED_CST.\n\t(walk_tree): Handle FIXED_CST and FIXED_POINT_TYPE.\n\t* dwarf2out.c (base_type_die): Use DW_ATE_signed_fixed or\n\tDW_ATE_unsigned_fixed to describe FIXED_POINT_TYPE.\n\t(is_base_type): Handle FIXED_POINT_TYPE.\n\t(add_type_attribute): Handle FIXED_POINT_TYPE.\n\t(gen_type_die_with_usage): Handle FIXED_POINT_TYPE.\n\t* print-tree.c (fixed-value.h): New include.\n\t(print_node_brief): Support FIXED_CST.\n\t(print_node): Support FIXED_POINT_TYPE and FIXED_CST.\n\t* c-pretty-print.c (fixed-value.h): New include.\n\t(pp_c_type_specifier): Handle FIXED_POINT_TYPE.  Need to pass\n\tTYPE_SATURATING to c_common_type_for_mode for fixed-point modes.\n\t(pp_c_direct_abstract_declarator): Handle FIXED_POINT_TYPE.\n\tSupport fixed-point types for inner items in VECTOR_TYPE.\n\t(pp_c_direct_declarator): Likewise.\n\t(pp_c_declarator): Likewise.\n\t(pp_c_fixed_constant): New function.\n\t(pp_c_constant): Handle FIXED_CST.\n\t(pp_c_primary_expression): Likewise.\n\t(pp_c_expression): Likewise.\n\t* fold-const.c (fixed-value.h): New include.\n\t(negate_expr_p): Return true for FIXED_CST.\n\t(fold_negate_expr): Support FIXED_CST.\n\t(split_tree): Support FIXED_CST.\n\t(const_binop): Support FIXED_CST.\n\t(fold_convert_const_int_from_fixed): New function to convert from\n\tfixed to int.\n\t(fold_convert_const_real_from_fixed): New function to convert from\n\tfixed to real.\n\t(fold_convert_const_fixed_from_fixed): New function to convert from\n\tfixed to another fixed.\n\t(fold_convert_const_fixed_from_int): New function to convert from\n\tint to fixed.\n\t(fold_convert_const_fixed_from_real): New function to convert from\n\treal to fixed.\n\t(fold_convert_const): Support conversions from fixed to int, from\n\tfixed to real, from fixed to fixed, from int to fixed, and from real\n\tto fixed.\n\t(fold_convert): Support FIXED_CST and FIXED_POINT_TYPE.\n\t(operand_equal_p): Support FIXED_CST.\n\t(make_range): For fixed-point modes, we need to pass the\n\tsaturating flag as the 2nd parameter.\n\t(tree_swap_operands_p): Handle FIXED_CST.\n\t(fold_plusminus_mult_expr): For fract modes, we cannot generate\n\tconstant 1.\n\t(fold_unary): Support FIXED_CONVERT_EXPR.\n\t(fold_binary): Handle FIXED_CST.\n\tMake sure the type is not saturating, before associating operations.\n\tEx: A + B + C, A * B * C, (A1 * C1) +/- (A2 * C2).\n\t(tree_expr_nonnegative_warnv_p): Handle FIXED_CST.\n\t(fold_negate_const): Support FIXED_CST.\n\t(fold_relational_const): Support FIXED_CST.\n\t* gimplify.c (omp_firstprivatize_type_sizes): Handle FIXED_POINT_TYPE.\n\t(gimplify_expr): Handle FIXED_CST.\n\t(gimplify_type_sizes): Handle FIXED_POINT_TYPE.\n\t* ipa-prop.c (ipa_callsite_compute_param): Support FIXED_CST.\n\t* ipa-type-escape.c (type_to_consider): Handle FIXED_POINT_TYPE.\n\t* doc/tm.texi (Type Layout): Document SHORT_FRACT_TYPE_SIZE,\n\tFRACT_TYPE_SIZE, LONG_FRACT_TYPE_SIZE, LONG_LONG_FRACT_TYPE_SIZE,\n\tSHORT_ACCUM_TYPE_SIZE, ACCUM_TYPE_SIZE, LONG_ACCUM_TYPE_SIZE,\n\tLONG_LONG_ACCUM_TYPE_SIZE.\n\t* dbxout.c (dbxout_type): Handle FIXED_POINT_TYPE.\n\t* c-aux-info.c (gen_type): Handle FIXED_POINT_TYPE.\n\t* tree-sra.c (is_sra_scalar_type): Support FIXED_POINT_TYPE.\n\t* expmed.c (extract_bit_field): Support MODE_FRACT, MODE_UFRACT,\n\tMODE_ACCUM, and MODE_UACCUM.\n\t* tree-vectorizer.c (vect_is_simple_reduction): Check for saturating\n\tfixed-point types to disable reduction.\n\t* explow.c (promote_mode): Support FIXED_POINT_TYPE.\n\nFrom-SVN: r127306", "tree": {"sha": "844eff658d57c57ce2ecfa8982a6e96a0c7c3392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/844eff658d57c57ce2ecfa8982a6e96a0c7c3392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/325217edf0332af8e5e52a32eb9b3cd862646375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325217edf0332af8e5e52a32eb9b3cd862646375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/325217edf0332af8e5e52a32eb9b3cd862646375", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325217edf0332af8e5e52a32eb9b3cd862646375/comments", "author": null, "committer": null, "parents": [{"sha": "ad10fdc2b781c481fe7793dc9eb735d0bb493921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad10fdc2b781c481fe7793dc9eb735d0bb493921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad10fdc2b781c481fe7793dc9eb735d0bb493921"}], "stats": {"total": 1463, "additions": 1419, "deletions": 44}, "files": [{"sha": "0f67a798c2e87756c64abe04c81b6bb930efb7fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1,3 +1,218 @@\n+2007-08-08  Chao-ying Fu  <fu@mips.com>\n+\n+\t* tree.def (FIXED_POINT_TYPE): New type.\n+\t(FIXED_CST): New constant.\n+\t(FIXED_CONVERT_EXPR): New expr.\n+\t* doc/c-tree.texi (Types): Document FIXED_POINT_TYPE.\n+\t(Expressions): Document FIXED_CST and FIXED_CONVERT_EXPR.\n+\t* tree.h (struct tree_base): Add saturating_flag.\n+\tRemove one bit of spare for saturating_flag.\n+\t(NUMERICAL_TYPE_CHECK): Support FIXED_POINT_TYPE.\n+\t(NON_SAT_FIXED_POINT_TYPE_P, SAT_FIXED_POINT_TYPE_P,\n+\tFIXED_POINT_TYPE_P): Define.\n+\t(TYPE_SATURATING): Define.\n+\t(TREE_FIXED_CST_PTR, TREE_FIXED_CST): Define.\n+\t(struct tree_fixed_cst): New.\n+\t(TYPE_IBIT, TYPE_FBIT): Define.\n+\t(tree_node): Add fixed_cst.\n+\t(enum tree_index): Add new enumeration values of\n+\tTI_SAT_SFRACT_TYPE, TI_SAT_FRACT_TYPE, TI_SAT_LFRACT_TYPE,\n+\tTI_SAT_LLFRACT_TYPE, TI_SAT_USFRACT_TYPE, TI_SAT_UFRACT_TYPE,\n+\tTI_SAT_ULFRACT_TYPE, TI_SAT_ULLFRACT_TYPE, TI_SFRACT_TYPE,\n+\tTI_FRACT_TYPE, TI_LFRACT_TYPE, TI_LLFRACT_TYPE, TI_USFRACT_TYPE,\n+\tTI_UFRACT_TYPE, TI_ULFRACT_TYPE, TI_ULLFRACT_TYPE,\n+\tTI_SAT_SACCUM_TYPE, TI_SAT_ACCUM_TYPE, TI_SAT_LACCUM_TYPE,\n+\tTI_SAT_LLACCUM_TYPE, TI_SAT_USACCUM_TYPE, TI_SAT_UACCUM_TYPE,\n+\tTI_SAT_ULACCUM_TYPE, TI_SAT_ULLACCUM_TYPE, TI_SACCUM_TYPE,\n+\tTI_ACCUM_TYPE, TI_LACCUM_TYPE, TI_LLACCUM_TYPE, TI_USACCUM_TYPE,\n+\tTI_UACCUM_TYPE, TI_ULACCUM_TYPE, TI_ULLACCUM_TYPE,\n+\tTI_QQ_TYPE, TI_HQ_TYPE,_TYPE, TI_SQ_TYPE, TI_DQ_TYPE, TI_TQ_TYPE,\n+\tTI_UQQ_TYPE, TI_UHQ_TYPE, TI_USQ_TYPE, TI_UDQ_TYPE, TI_UTQ_TYPE,\n+\tTI_SAT_QQ_TYPE, TI_SAT_HQ_TYPE, TI_SAT_SQ_TYPE, TI_SAT_DQ_TYPE,\n+\tTI_SAT_TQ_TYPE, TI_SAT_UQQ_TYPE, TI_SAT_UHQ_TYPE, TI_SAT_USQ_TYPE,\n+\tTI_SAT_UDQ_TYPE, TI_SAT_UTQ_TYPE, TI_HA_TYPE, TI_SA_TYPE, TI_DA_TYPE,\n+\tTI_TA_TYPE, TI_UHA_TYPE, TI_USA_TYPE, TI_UDA_TYPE, TI_UTA_TYPE,\n+\tTI_SAT_HA_TYPE, TI_SAT_SA_TYPE, TI_SAT_DA_TYPE, TI_SAT_TA_TYPE,\n+\tTI_SAT_UHA_TYPE, TI_SAT_USA_TYPE, TI_SAT_UDA_TYPE, TI_SAT_UTA_TYPE.\n+\t(sat_short_fract_type_node, sat_fract_type_node,\n+\tsat_long_fract_type_node, sat_long_long_fract_type_node,\n+\tsat_unsigned_short_fract_type_node, sat_unsigned_fract_type_node,\n+\tsat_unsigned_long_fract_type_node,\n+\tsat_unsigned_long_long_fract_type_node, short_fract_type_node,\n+\tfract_type_node, long_fract_type_node, long_long_fract_type_node,\n+\tunsigned_short_fract_type_node, unsigned_fract_type_node,\n+\tunsigned_long_fract_type_node, unsigned_long_long_fract_type_node,\n+\tsat_short_accum_type_node, sat_accum_type_node,\n+\tsat_long_accum_type_node, sat_long_long_accum_type_node,\n+\tsat_unsigned_short_accum_type_node, sat_unsigned_accum_type_node,\n+\tsat_unsigned_long_accum_type_node,\n+\tsat_unsigned_long_long_accum_type_node, short_accum_type_node,\n+\taccum_type_node, long_accum_type_node, long_long_accum_type_node,\n+\tunsigned_short_accum_type_node, unsigned_accum_type_node,\n+\tunsigned_long_accum_type_node, unsigned_long_long_accum_type_node,\n+\tqq_type_node, hq_type_node, sq_type_node, dq_type_node, tq_type_node,\n+\tuqq_type_node, uhq_type_node, usq_type_node, udq_type_node,\n+\tutq_type_node, sat_qq_type_node, sat_hq_type_node, sat_sq_type_node,\n+\tsat_dq_type_node, sat_tq_type_node, sat_uqq_type_node,\n+\tsat_uhq_type_node, sat_usq_type_node, sat_udq_type_node,\n+\tsat_utq_type_node, ha_type_node, sa_type_node, da_type_node,\n+\tta_type_node, uha_type_node, usa_type_node, uda_type_node,\n+\tuta_type_node, sat_ha_type_node, sat_sa_type_node, sat_da_type_node,\n+\tsat_ta_type_node, sat_uha_type_node, sat_usa_type_node,\n+\tsat_uda_type_node, sat_uta_type_node): New macro.\n+\t(make_fract_type, make_accum_type): Declare.\n+\t(make_signed_fract_type, make_unsigned_fract_type,\n+\tmake_sat_signed_fract_type, make_sat_unsigned_fract_type,\n+\tmake_signed_accum_type, make_unsigned_accum_type,\n+\tmake_sat_signed_accum_type, make_sat_unsigned_accum_type,\n+\tmake_or_reuse_signed_fract_type, make_or_reuse_unsigned_fract_type,\n+\tmake_or_reuse_sat_signed_fract_type,\n+\tmake_or_reuse_sat_unsigned_fract_type, make_or_reuse_signed_accum_type,\n+\tmake_or_reuse_unsigned_accum_type, make_or_reuse_sat_signed_accum_type,\n+\tmake_or_reuse_sat_unsigned_accum_type): New macro.\n+\t(fixed_zerop): Declare.\n+\t* defaults.h (SHORT_FRACT_TYPE_SIZE, FRACT_TYPE_SIZE,\n+\tLONG_FRACT_TYPE_SIZE, LONG_LONG_FRACT_TYPE_SIZE,\n+\tSHORT_ACCUM_TYPE_SIZE, ACCUM_TYPE_SIZE, LONG_ACCUM_TYPE_SIZE,\n+\tLONG_LONG_ACCUM_TYPE_SIZE): Define.\n+\t* treestruct.def: Add TS_FIXED_CST.\n+\t* Makefile.in (c-pretty-print.o): Add dependence on fixed-value.h.\n+\t(tree.o): Likewise.\n+\t(tree-dump.o): Likewise.\n+\t(print-tree.o): Likewise.\n+\t(tree-pretty-print.o): Likewise.\n+\t(fold-const.o): Likewise.\n+\t* tree-complex.c (some_nonzerop): Handle FIXED_CST.\n+\t* tree-gimple.c (is_gimple_formal_tmp_rhs): Handle FIXED_CST.\n+\t(is_gimple_min_invariant): Handle FIXED_CST.\n+\t* stor-layout.c (int_mode_for_mode): Handle MODE_FRACT, MODE_UFRACT,\n+\tMODE_ACCUM, MODE_UACCUM, MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT,\n+\tMODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\t(layout_type): Handle FIXED_POINT_TYPE.\n+\t(make_fract_type, make_accum_type): New functions.\n+\t* tree-browser.c (browse_tree): Handle FIXED_POINT_TYPE.\n+\t* tree-dump.c (fixed-value.h): New include.\n+\t(dump_fixed): New function.\n+\t(dequeue_and_dump): Handle FIXED_POINT_TYPE and FIXED_CST.\n+\t* tree-inline.c (remap_type_1): Handle FIXED_POINT_TYPE.\n+\t(estimate_num_insns_1): Handle FIXED_CST and FIXED_CONVERT_EXPR.\n+\t* tree-pretty-print.c (fixed-value.h): New include.\n+\t(dump_generic_node): Handle FIXED_POINT_TYPE, FIXED_CST, and\n+\tFIXED_CONVERT_EXPR.\n+\t* tree-scalar-evolution.c (get_scalar_evolution): Handle FIXED_CST.\n+\t* tree-ssa-loop-im.c (for_each_index): Handle FIXED_CST.\n+\t* tree-ssa-pre.c (poolify_tree): Handle FIXED_CST.\n+\t* tree-ssa-reassoc.c (break_up_subtract_bb): We can do reassociation\n+\tfor non-saturating fixed-point types.\n+\t(reassociate_bb): Likewise.\n+\t* emit-rtl.c (fixed-value.h): New include.\n+\t(fconst0, fconst1): New array.\n+\t(init_emit_once): Initialize fconst0 and fconst1 for fixed-point modes.\n+\t* tree-vect-generic.c expand_vector_operation): Support\n+\tMODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, and\n+\tMODE_VECTOR_UACCUM.\n+\t(type_for_widest_vector_mode): Add one parameter for the \n+\tsaturating flag.\n+\tCheck scalar FRACT, UFRACT, ACCUM, and UACCUM mode to select their\n+\tvector mode.\n+\tPass the satp parameter to type_for_mode for fixed-point types.\n+\t(expand_vector_operations_1): Pass the saturating flag to\n+\ttype_for_widest_vector_mode.\n+\tSupport MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n+\tand MODE_VECTOR_UACCUM.\n+\t* tree-vect-transform.c (vect_is_simple_cond): Support FIXED_CST.\n+\t(vectorizable_condition): Likewise.\n+\t* tree.c (fixed-value.h): New include.\n+\t(tree_code_size): Support FIXED_CST.\n+\t(build_fixed): New function.\n+\t(build_one_cst): Support FIXED_POINT_TYPE for accum types.\n+\t(fixed_zerop): New function.\n+\t(tree_node_structure): Support FIXED_CST.\n+\t(type_contains_placeholder_1): Support FIXED_POINT_TYPE.\n+\t(build_type_attribute_qual_variant): Handle FIXED_POINT_TYPE.\n+\t(type_hash_eq): Handle FIXED_POINT_TYPE.\n+\t(simple_cst_equal): Support FIXED_CST.\n+\t(iterative_hash_expr): Handle FIXED_CST.\n+\t(get_unwidened): Make sure type is not FIXED_POINT_TYPE.\n+\t(get_narrower): Likewise.\n+\t(variably_modified_type_p): Handle FIXED_POINT_TYPE.\n+\t(make_or_reuse_fract_type, make_or_reuse_accum_type): New functions.\n+\t(build_common_tree_nodes_2): Use MAKE_FIXED_TYPE_NODE_FAMILY and\n+\tMAKE_FIXED_MODE_NODE macros to initialize fixed-point type\n+\tnodes.\n+\t(build_vector_type_for_mode): Handle MODE_VECTOR_FRACT,\n+\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\t(initializer_zerop): Support FIXED_CST.\n+\t(walk_tree): Handle FIXED_CST and FIXED_POINT_TYPE.\n+\t* dwarf2out.c (base_type_die): Use DW_ATE_signed_fixed or\n+\tDW_ATE_unsigned_fixed to describe FIXED_POINT_TYPE.\n+\t(is_base_type): Handle FIXED_POINT_TYPE.\n+\t(add_type_attribute): Handle FIXED_POINT_TYPE.\n+\t(gen_type_die_with_usage): Handle FIXED_POINT_TYPE.\n+\t* print-tree.c (fixed-value.h): New include.\n+\t(print_node_brief): Support FIXED_CST.\n+\t(print_node): Support FIXED_POINT_TYPE and FIXED_CST.\n+\t* c-pretty-print.c (fixed-value.h): New include.\n+\t(pp_c_type_specifier): Handle FIXED_POINT_TYPE.  Need to pass\n+\tTYPE_SATURATING to c_common_type_for_mode for fixed-point modes.\n+\t(pp_c_direct_abstract_declarator): Handle FIXED_POINT_TYPE.\n+\tSupport fixed-point types for inner items in VECTOR_TYPE.\n+\t(pp_c_direct_declarator): Likewise.\n+\t(pp_c_declarator): Likewise.\n+\t(pp_c_fixed_constant): New function.\n+\t(pp_c_constant): Handle FIXED_CST.\n+\t(pp_c_primary_expression): Likewise.\n+\t(pp_c_expression): Likewise.\n+\t* fold-const.c (fixed-value.h): New include.\n+\t(negate_expr_p): Return true for FIXED_CST.\n+\t(fold_negate_expr): Support FIXED_CST.\n+\t(split_tree): Support FIXED_CST.\n+\t(const_binop): Support FIXED_CST.\n+\t(fold_convert_const_int_from_fixed): New function to convert from\n+\tfixed to int.\n+\t(fold_convert_const_real_from_fixed): New function to convert from\n+\tfixed to real.\n+\t(fold_convert_const_fixed_from_fixed): New function to convert from\n+\tfixed to another fixed.\n+\t(fold_convert_const_fixed_from_int): New function to convert from\n+\tint to fixed.\n+\t(fold_convert_const_fixed_from_real): New function to convert from\n+\treal to fixed.\n+\t(fold_convert_const): Support conversions from fixed to int, from\n+\tfixed to real, from fixed to fixed, from int to fixed, and from real\n+\tto fixed.\n+\t(fold_convert): Support FIXED_CST and FIXED_POINT_TYPE.\n+\t(operand_equal_p): Support FIXED_CST.\n+\t(make_range): For fixed-point modes, we need to pass the\n+\tsaturating flag as the 2nd parameter.\n+\t(tree_swap_operands_p): Handle FIXED_CST.\n+\t(fold_plusminus_mult_expr): For fract modes, we cannot generate\n+\tconstant 1.\n+\t(fold_unary): Support FIXED_CONVERT_EXPR.\n+\t(fold_binary): Handle FIXED_CST.\n+\tMake sure the type is not saturating, before associating operations.\n+\tEx: A + B + C, A * B * C, (A1 * C1) +/- (A2 * C2).\n+\t(tree_expr_nonnegative_warnv_p): Handle FIXED_CST.\n+\t(fold_negate_const): Support FIXED_CST.\n+\t(fold_relational_const): Support FIXED_CST.\n+\t* gimplify.c (omp_firstprivatize_type_sizes): Handle FIXED_POINT_TYPE.\n+\t(gimplify_expr): Handle FIXED_CST.\n+\t(gimplify_type_sizes): Handle FIXED_POINT_TYPE.\n+\t* ipa-prop.c (ipa_callsite_compute_param): Support FIXED_CST.\n+\t* ipa-type-escape.c (type_to_consider): Handle FIXED_POINT_TYPE.\n+\t* doc/tm.texi (Type Layout): Document SHORT_FRACT_TYPE_SIZE,\n+\tFRACT_TYPE_SIZE, LONG_FRACT_TYPE_SIZE, LONG_LONG_FRACT_TYPE_SIZE,\n+\tSHORT_ACCUM_TYPE_SIZE, ACCUM_TYPE_SIZE, LONG_ACCUM_TYPE_SIZE,\n+\tLONG_LONG_ACCUM_TYPE_SIZE.\n+\t* dbxout.c (dbxout_type): Handle FIXED_POINT_TYPE.\n+\t* c-aux-info.c (gen_type): Handle FIXED_POINT_TYPE.\n+\t* tree-sra.c (is_sra_scalar_type): Support FIXED_POINT_TYPE.\n+\t* expmed.c (extract_bit_field): Support MODE_FRACT, MODE_UFRACT,\n+\tMODE_ACCUM, and MODE_UACCUM.\n+\t* tree-vectorizer.c (vect_is_simple_reduction): Check for saturating\n+\tfixed-point types to disable reduction.\n+\t* explow.c (promote_mode): Support FIXED_POINT_TYPE.\n+\n 2007-08-08  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/x-rs6000: New file."}, {"sha": "7dafff67015b359550e5da5568adfb9946e82304", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1772,7 +1772,7 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \n c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n \t$(C_TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(REAL_H) \\\n-\t$(DIAGNOSTIC_H) tree-iterator.h\n+\t$(DIAGNOSTIC_H) tree-iterator.h fixed-value.h\n \n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h langhooks.h\t\t\\\n@@ -1932,18 +1932,18 @@ tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n    toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n    $(REAL_H) gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n-   $(OBSTACK_H) pointer-set.h\n+   $(OBSTACK_H) pointer-set.h fixed-value.h\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h toplev.h $(SPLAY_TREE_H) $(TREE_DUMP_H) \\\n-   tree-iterator.h tree-pass.h $(DIAGNOSTIC_H) $(REAL_H)\n+   tree-iterator.h tree-pass.h $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h insn-config.h \\\n    $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n    langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) intl.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n    debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n    ipa-prop.h value-prof.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h\n+   $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h fixed-value.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n@@ -2267,10 +2267,10 @@ tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n    $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h \\\n-   value-prof.h\n+   value-prof.h fixed-value.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(REAL_H) toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n-   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h\n+   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h fixed-value.h\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) input.h toplev.h intl.h \\\n    $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h"}, {"sha": "28da8e0e441e3f516ca4218d02be3d33f78ad892", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -426,6 +426,7 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  break;\n \n \tcase INTEGER_TYPE:\n+\tcase FIXED_POINT_TYPE:\n \t  data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n \t  /* Normally, `unsigned' is part of the deal.  Not so if it comes\n \t     with a type qualifier.  */"}, {"sha": "e11d83c36c690377a2c5fe092d60d13268052b1f", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n #include \"c-pretty-print.h\"\n #include \"c-tree.h\"\n #include \"tree-iterator.h\"\n@@ -312,6 +313,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n     case BOOLEAN_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n       if (TYPE_NAME (t))\n \t{\n \t  t = TYPE_NAME (t);\n@@ -320,7 +322,10 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       else\n \t{\n \t  int prec = TYPE_PRECISION (t);\n-\t  t = c_common_type_for_mode (TYPE_MODE (t), TYPE_UNSIGNED (t));\n+\t  if (ALL_FIXED_POINT_MODE_P (TYPE_MODE (t)))\n+\t    t = c_common_type_for_mode (TYPE_MODE (t), TYPE_SATURATING (t));\n+\t  else\n+\t    t = c_common_type_for_mode (TYPE_MODE (t), TYPE_UNSIGNED (t));\n \t  if (TYPE_NAME (t))\n \t    {\n \t      pp_c_type_specifier (pp, t);\n@@ -342,6 +347,9 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n \t\tcase REAL_TYPE:\n \t\t  pp_string (pp, \"<unnamed-float:\");\n \t\t  break;\n+\t\tcase FIXED_POINT_TYPE:\n+\t\t  pp_string (pp, \"<unnamed-fixed:\");\n+\t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -539,6 +547,7 @@ pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n     case BOOLEAN_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -656,6 +665,7 @@ pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case UNION_TYPE:\n     case RECORD_TYPE:\n@@ -678,6 +688,7 @@ pp_c_declarator (c_pretty_printer *pp, tree t)\n     {\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case UNION_TYPE:\n     case RECORD_TYPE:\n@@ -925,6 +936,16 @@ pp_c_floating_constant (c_pretty_printer *pp, tree r)\n     pp_string (pp, \"df\");\n }\n \n+/* Print out a FIXED value as a decimal-floating-constant.  */\n+\n+static void\n+pp_c_fixed_constant (c_pretty_printer *pp, tree r)\n+{\n+  fixed_to_decimal (pp_buffer (pp)->digit_buffer, &TREE_FIXED_CST (r),\n+\t\t   sizeof (pp_buffer (pp)->digit_buffer));\n+  pp_string (pp, pp_buffer(pp)->digit_buffer);\n+}\n+\n /* Pretty-print a compound literal expression.  GNU extensions include\n    vector constants.  */\n \n@@ -953,6 +974,7 @@ pp_c_compound_literal (c_pretty_printer *pp, tree e)\n /* constant:\n       integer-constant\n       floating-constant\n+      fixed-point-constant\n       enumeration-constant\n       character-constant   */\n \n@@ -982,6 +1004,10 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n       pp_c_floating_constant (pp, e);\n       break;\n \n+    case FIXED_CST:\n+      pp_c_fixed_constant (pp, e);\n+      break;\n+\n     case STRING_CST:\n       pp_c_string_literal (pp, e);\n       break;\n@@ -1037,6 +1063,7 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n \n     case INTEGER_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case STRING_CST:\n       pp_c_constant (pp, e);\n       break;\n@@ -1842,6 +1869,10 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n       pp_c_floating_constant (pp, e);\n       break;\n \n+    case FIXED_CST:\n+      pp_c_fixed_constant (pp, e);\n+      break;\n+\n     case STRING_CST:\n       pp_c_string_literal (pp, e);\n       break;"}, {"sha": "9657120b29b2968fd4d74e89272cfff09a89823c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1906,6 +1906,7 @@ dbxout_type (tree type, int full)\n       break;\n \n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n       stabstr_C ('r');"}, {"sha": "698438f920d3ccdf0bc8af2739a164145d731758", "filename": "gcc/defaults.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -454,6 +454,38 @@ along with GCC; see the file COPYING3.  If not see\n #define DECIMAL128_TYPE_SIZE 128\n #endif\n \n+#ifndef SHORT_FRACT_TYPE_SIZE\n+#define SHORT_FRACT_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef FRACT_TYPE_SIZE\n+#define FRACT_TYPE_SIZE (BITS_PER_UNIT * 2)\n+#endif\n+\n+#ifndef LONG_FRACT_TYPE_SIZE\n+#define LONG_FRACT_TYPE_SIZE (BITS_PER_UNIT * 4)\n+#endif\n+\n+#ifndef LONG_LONG_FRACT_TYPE_SIZE\n+#define LONG_LONG_FRACT_TYPE_SIZE (BITS_PER_UNIT * 8)\n+#endif\n+\n+#ifndef SHORT_ACCUM_TYPE_SIZE\n+#define SHORT_ACCUM_TYPE_SIZE (SHORT_FRACT_TYPE_SIZE * 2)\n+#endif\n+\n+#ifndef ACCUM_TYPE_SIZE\n+#define ACCUM_TYPE_SIZE (FRACT_TYPE_SIZE * 2)\n+#endif\n+\n+#ifndef LONG_ACCUM_TYPE_SIZE\n+#define LONG_ACCUM_TYPE_SIZE (LONG_FRACT_TYPE_SIZE * 2)\n+#endif\n+\n+#ifndef LONG_LONG_ACCUM_TYPE_SIZE\n+#define LONG_LONG_ACCUM_TYPE_SIZE (LONG_LONG_FRACT_TYPE_SIZE * 2)\n+#endif\n+\n /* Width in bits of a pointer.  Mind the value of the macro `Pmode'.  */\n #ifndef POINTER_SIZE\n #define POINTER_SIZE BITS_PER_WORD"}, {"sha": "a53329a7a6b8a5d558c27207d5d6ce8961be5117", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -271,6 +271,7 @@ The elements are indexed from zero.\n @tindex TYPE_MIN_VALUE\n @tindex TYPE_MAX_VALUE\n @tindex REAL_TYPE\n+@tindex FIXED_POINT_TYPE\n @tindex COMPLEX_TYPE\n @tindex ENUMERAL_TYPE\n @tindex BOOLEAN_TYPE\n@@ -498,6 +499,19 @@ Used to represent the @code{float}, @code{double}, and @code{long\n double} types.  The number of bits in the floating-point representation\n is given by @code{TYPE_PRECISION}, as in the @code{INTEGER_TYPE} case.\n \n+@item FIXED_POINT_TYPE\n+Used to represent the @code{short _Fract}, @code{_Fract}, @code{long\n+_Fract}, @code{long long _Fract}, @code{short _Accum}, @code{_Accum},\n+@code{long _Accum}, and @code{long long _Accum} types.  The number of bits\n+in the fixed-point representation is given by @code{TYPE_PRECISION},\n+as in the @code{INTEGER_TYPE} case.  There may be padding bits, fractional\n+bits and integral bits.  The number of fractional bits is given by\n+@code{TYPE_FBIT}, and the number of integral bits is given by @code{TYPE_IBIT}.\n+The fixed-point type is unsigned if @code{TYPE_UNSIGNED} holds; otherwise,\n+it is signed.\n+The fixed-point type is saturating if @code{TYPE_SATURATING} holds; otherwise,\n+it is not saturating.\n+\n @item COMPLEX_TYPE\n Used to represent GCC built-in @code{__complex__} data types.  The\n @code{TREE_TYPE} is the type of the real and imaginary parts.\n@@ -1879,6 +1893,7 @@ This macro returns the attributes on the type @var{type}.\n @findex tree_int_cst_lt\n @findex tree_int_cst_equal\n @tindex REAL_CST\n+@tindex FIXED_CST\n @tindex COMPLEX_CST\n @tindex VECTOR_CST\n @tindex STRING_CST\n@@ -1907,6 +1922,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex NON_LVALUE_EXPR\n @tindex NOP_EXPR\n @tindex CONVERT_EXPR\n+@tindex FIXED_CONVERT_EXPR\n @tindex THROW_EXPR\n @tindex LSHIFT_EXPR\n @tindex RSHIFT_EXPR\n@@ -2080,6 +2096,15 @@ its bit-pattern.\n FIXME: Talk about how to obtain representations of this constant, do\n comparisons, and so forth.\n \n+@item FIXED_CST\n+\n+These nodes represent fixed-point constants.  The type of these constants\n+is obtained with @code{TREE_TYPE}.  @code{TREE_FIXED_CST_PTR} points to\n+to struct fixed_value;  @code{TREE_FIXED_CST} returns the structure itself.\n+Struct fixed_value contains @code{data} with the size of two\n+HOST_BITS_PER_WIDE_INT and @code{mode} as the associated fixed-point\n+machine mode for @code{data}.\n+\n @item COMPLEX_CST\n These nodes are used to represent complex number constants, that is a\n @code{__complex__} whose parts are constant nodes.  The\n@@ -2246,6 +2271,13 @@ cases are always indicated explicitly.  Similarly, a user-defined\n conversion is never represented by a @code{CONVERT_EXPR}; instead, the\n function calls are made explicit.\n \n+@item FIXED_CONVERT_EXPR\n+These nodes are used to represent conversions that involve fixed-point\n+values.  For example, from a fixed-point value to another fixed-point value,\n+from an integer to a fixed-point value, from a fixed-point value to an\n+integer, from a floating-point value to a fixed-point value, or from\n+a fixed-point value to a floating-point value.\n+\n @item THROW_EXPR\n These nodes represent @code{throw} expressions.  The single operand is\n an expression for the code that should be executed to throw the"}, {"sha": "bf6859d2c39366570b454016fd94860fb908ecf0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1605,6 +1605,54 @@ the target machine.  If you don't define this, the default is two\n words.\n @end defmac\n \n+@defmac SHORT_FRACT_TYPE_SIZE\n+A C expression for the size in bits of the type @code{short _Fract} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT}.\n+@end defmac\n+\n+@defmac FRACT_TYPE_SIZE\n+A C expression for the size in bits of the type @code{_Fract} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 2}.\n+@end defmac\n+\n+@defmac LONG_FRACT_TYPE_SIZE\n+A C expression for the size in bits of the type @code{long _Fract} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 4}.\n+@end defmac\n+\n+@defmac LONG_LONG_FRACT_TYPE_SIZE\n+A C expression for the size in bits of the type @code{long long _Fract} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 8}.\n+@end defmac\n+\n+@defmac SHORT_ACCUM_TYPE_SIZE\n+A C expression for the size in bits of the type @code{short _Accum} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 2}.\n+@end defmac\n+\n+@defmac ACCUM_TYPE_SIZE\n+A C expression for the size in bits of the type @code{_Accum} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 4}.\n+@end defmac\n+\n+@defmac LONG_ACCUM_TYPE_SIZE\n+A C expression for the size in bits of the type @code{long _Accum} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 8}.\n+@end defmac\n+\n+@defmac LONG_LONG_ACCUM_TYPE_SIZE\n+A C expression for the size in bits of the type @code{long long _Accum} on\n+the target machine.  If you don't define this, the default is\n+@code{BITS_PER_UNIT * 16}.\n+@end defmac\n+\n @defmac LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n Define this macro if @code{LONG_DOUBLE_TYPE_SIZE} is not constant or\n if you want routines in @file{libgcc2.a} for a size other than"}, {"sha": "dc352b1e5b49d6b223ad02e432ae5ec3e8993c2a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -8396,6 +8396,13 @@ base_type_die (tree type)\n \tencoding = DW_ATE_float;\n       break;\n \n+    case FIXED_POINT_TYPE:\n+      if (TYPE_UNSIGNED (type))\n+\tencoding = DW_ATE_signed_fixed;\n+      else\n+\tencoding = DW_ATE_unsigned_fixed;\n+      break;\n+\n       /* Dwarf2 doesn't know anything about complex ints, so use\n \t a user defined type for it.  */\n     case COMPLEX_TYPE:\n@@ -8440,6 +8447,7 @@ is_base_type (tree type)\n     case VOID_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n       return 1;\n@@ -11401,11 +11409,11 @@ add_type_attribute (dw_die_ref object_die, tree type, int decl_const,\n   enum tree_code code  = TREE_CODE (type);\n   dw_die_ref type_die  = NULL;\n \n-  /* ??? If this type is an unnamed subrange type of an integral or\n-     floating-point type, use the inner type.  This is because we have no\n+  /* ??? If this type is an unnamed subrange type of an integral, floating-point\n+     or fixed-point type, use the inner type.  This is because we have no\n      support for unnamed types in base_type_die.  This can happen if this is\n      an Ada subrange type.  Correct solution is emit a subrange type die.  */\n-  if ((code == INTEGER_TYPE || code == REAL_TYPE)\n+  if ((code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE)\n       && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)\n     type = TREE_TYPE (type), code = TREE_CODE (type);\n \n@@ -13082,6 +13090,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case VOID_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n       /* No DIEs needed for fundamental types.  */"}, {"sha": "803f740168228ea921ac10cb6a64289437ce55a1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n #include \"bitmap.h\"\n #include \"basic-block.h\"\n #include \"ggc.h\"\n@@ -108,6 +109,10 @@ REAL_VALUE_TYPE dconstthird;\n REAL_VALUE_TYPE dconstsqrt2;\n REAL_VALUE_TYPE dconste;\n \n+/* Record fixed-point constant 0 and 1.  */\n+FIXED_VALUE_TYPE fconst0[MAX_FCONST0];\n+FIXED_VALUE_TYPE fconst1[MAX_FCONST1];\n+\n /* All references to the following fixed hard registers go through\n    these unique rtl objects.  On machines where the frame-pointer and\n    arg-pointer are the same register, they use the same unique object.\n@@ -5256,6 +5261,62 @@ init_emit_once (int line_numbers)\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n     }\n \n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FRACT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      FCONST0(mode).data.high = 0;\n+      FCONST0(mode).data.low = 0;\n+      FCONST0(mode).mode = mode;\n+    }\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_UFRACT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      FCONST0(mode).data.high = 0;\n+      FCONST0(mode).data.low = 0;\n+      FCONST0(mode).mode = mode;\n+    }\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_ACCUM);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      FCONST0(mode).data.high = 0;\n+      FCONST0(mode).data.low = 0;\n+      FCONST0(mode).mode = mode;\n+\n+      /* We store the value 1.  */\n+      FCONST1(mode).data.high = 0;\n+      FCONST1(mode).data.low = 0;\n+      FCONST1(mode).mode = mode;\n+      lshift_double (1, 0, GET_MODE_FBIT (mode),\n+                     2 * HOST_BITS_PER_WIDE_INT,\n+                     &FCONST1(mode).data.low,\n+\t\t     &FCONST1(mode).data.high,\n+                     SIGNED_FIXED_POINT_MODE_P (mode));\n+    }\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_UACCUM);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      FCONST0(mode).data.high = 0;\n+      FCONST0(mode).data.low = 0;\n+      FCONST0(mode).mode = mode;\n+\n+      /* We store the value 1.  */\n+      FCONST1(mode).data.high = 0;\n+      FCONST1(mode).data.low = 0;\n+      FCONST1(mode).mode = mode;\n+      lshift_double (1, 0, GET_MODE_FBIT (mode),\n+                     2 * HOST_BITS_PER_WIDE_INT,\n+                     &FCONST1(mode).data.low,\n+\t\t     &FCONST1(mode).data.high,\n+                     SIGNED_FIXED_POINT_MODE_P (mode));\n+    }\n+\n   for (i = (int) CCmode; i < (int) MAX_MACHINE_MODE; ++i)\n     if (GET_MODE_CLASS ((enum machine_mode) i) == MODE_CC)\n       const_tiny_rtx[0][i] = const0_rtx;"}, {"sha": "636dcb98a2723ec194379853b70be06843429994", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -793,7 +793,7 @@ promote_mode (tree type, enum machine_mode mode, int *punsignedp,\n     {\n #ifdef PROMOTE_FUNCTION_MODE\n     case INTEGER_TYPE:   case ENUMERAL_TYPE:   case BOOLEAN_TYPE:\n-    case REAL_TYPE:      case OFFSET_TYPE:\n+    case REAL_TYPE:      case OFFSET_TYPE:     case FIXED_POINT_TYPE:\n #ifdef PROMOTE_MODE\n       if (for_call)\n \t{"}, {"sha": "061fbbbd44810749a0ef05f1a5abf36a7b6f1afd", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1182,6 +1182,14 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       if (GET_MODE_CLASS (tmode) == MODE_FLOAT)\n \tnew_mode = MIN_MODE_VECTOR_FLOAT;\n+      else if (GET_MODE_CLASS (tmode) == MODE_FRACT)\n+\tnew_mode = MIN_MODE_VECTOR_FRACT;\n+      else if (GET_MODE_CLASS (tmode) == MODE_UFRACT)\n+\tnew_mode = MIN_MODE_VECTOR_UFRACT;\n+      else if (GET_MODE_CLASS (tmode) == MODE_ACCUM)\n+\tnew_mode = MIN_MODE_VECTOR_ACCUM;\n+      else if (GET_MODE_CLASS (tmode) == MODE_UACCUM)\n+\tnew_mode = MIN_MODE_VECTOR_UACCUM;\n       else\n \tnew_mode = MIN_MODE_VECTOR_INT;\n "}, {"sha": "eadcb97f7ce263ae0f124c0f5a848cdae85b46fc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 334, "deletions": 12, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"tm_p.h\"\n@@ -1127,6 +1128,7 @@ negate_expr_p (tree t)\n       return (INTEGRAL_TYPE_P (type)\n \t      && TYPE_OVERFLOW_WRAPS (type));\n \n+    case FIXED_CST:\n     case REAL_CST:\n     case NEGATE_EXPR:\n       return true;\n@@ -1257,6 +1259,10 @@ fold_negate_expr (tree t)\n \treturn tem;\n       break;\n \n+    case FIXED_CST:\n+      tem = fold_negate_const (t, type);\n+      return tem;\n+\n     case COMPLEX_CST:\n       {\n \ttree rpart = negate_expr (TREE_REALPART (t));\n@@ -1479,10 +1485,12 @@ split_tree (tree in, enum tree_code code, tree *conp, tree *litp,\n   /* Strip any conversions that don't change the machine mode or signedness.  */\n   STRIP_SIGN_NOPS (in);\n \n-  if (TREE_CODE (in) == INTEGER_CST || TREE_CODE (in) == REAL_CST)\n+  if (TREE_CODE (in) == INTEGER_CST || TREE_CODE (in) == REAL_CST\n+      || TREE_CODE (in) == FIXED_CST)\n     *litp = in;\n   else if (TREE_CODE (in) == code\n \t   || (! FLOAT_TYPE_P (TREE_TYPE (in))\n+\t       && ! SAT_FIXED_POINT_TYPE_P (TREE_TYPE (in))\n \t       /* We can associate addition and subtraction together (even\n \t\t  though the C standard doesn't say so) for integers because\n \t\t  the value is not affected.  For reals, the value might be\n@@ -1496,9 +1504,11 @@ split_tree (tree in, enum tree_code code, tree *conp, tree *litp,\n       int neg_litp_p = 0, neg_conp_p = 0, neg_var_p = 0;\n \n       /* First see if either of the operands is a literal, then a constant.  */\n-      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST)\n+      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST\n+\t  || TREE_CODE (op0) == FIXED_CST)\n \t*litp = op0, op0 = 0;\n-      else if (TREE_CODE (op1) == INTEGER_CST || TREE_CODE (op1) == REAL_CST)\n+      else if (TREE_CODE (op1) == INTEGER_CST || TREE_CODE (op1) == REAL_CST\n+\t       || TREE_CODE (op1) == FIXED_CST)\n \t*litp = op1, neg_litp_p = neg1_p, op1 = 0;\n \n       if (op0 != 0 && TREE_CONSTANT (op0))\n@@ -1886,6 +1896,52 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       return t;\n     }\n \n+  if (TREE_CODE (arg1) == FIXED_CST)\n+    {\n+      FIXED_VALUE_TYPE f1;\n+      FIXED_VALUE_TYPE f2;\n+      FIXED_VALUE_TYPE result;\n+      tree t, type;\n+      int sat_p;\n+      bool overflow_p;\n+\n+      /* The following codes are handled by fixed_arithmetic.  */\n+      switch (code)\n+        {\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\tcase MULT_EXPR:\n+\tcase TRUNC_DIV_EXPR:\n+\t  f2 = TREE_FIXED_CST (arg2);\n+\t  break;\n+\n+\tcase LSHIFT_EXPR:\n+\tcase RSHIFT_EXPR:\n+\t  f2.data.high = TREE_INT_CST_HIGH (arg2);\n+\t  f2.data.low = TREE_INT_CST_LOW (arg2);\n+\t  f2.mode = SImode;\n+\t  break;\n+\n+        default:\n+\t  return NULL_TREE;\n+        }\n+\n+      f1 = TREE_FIXED_CST (arg1);\n+      type = TREE_TYPE (arg1);\n+      sat_p = TYPE_SATURATING (type);\n+      overflow_p = fixed_arithmetic (&result, code, &f1, &f2, sat_p);\n+      t = build_fixed (type, result);\n+      /* Propagate overflow flags.  */\n+      if (overflow_p | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2))\n+\t{\n+\t  TREE_OVERFLOW (t) = 1;\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t}\n+      else if (TREE_CONSTANT_OVERFLOW (arg1) | TREE_CONSTANT_OVERFLOW (arg2))\n+\tTREE_CONSTANT_OVERFLOW (t) = 1;\n+      return t;\n+    }\n+\n   if (TREE_CODE (arg1) == COMPLEX_CST)\n     {\n       tree type = TREE_TYPE (arg1);\n@@ -2151,6 +2207,61 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n   return t;\n }\n \n+/* A subroutine of fold_convert_const handling conversions of a\n+   FIXED_CST to an integer type.  */\n+\n+static tree\n+fold_convert_const_int_from_fixed (tree type, tree arg1)\n+{\n+  tree t;\n+  double_int temp, temp_trunc;\n+  unsigned int mode;\n+\n+  /* Right shift FIXED_CST to temp by fbit.  */\n+  temp = TREE_FIXED_CST (arg1).data;\n+  mode = TREE_FIXED_CST (arg1).mode;\n+  if (GET_MODE_FBIT (mode) < 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+      lshift_double (temp.low, temp.high,\n+\t\t     - GET_MODE_FBIT (mode), 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp.low, &temp.high, SIGNED_FIXED_POINT_MODE_P (mode));\n+\n+      /* Left shift temp to temp_trunc by fbit.  */\n+      lshift_double (temp.low, temp.high,\n+\t\t     GET_MODE_FBIT (mode), 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp_trunc.low, &temp_trunc.high,\n+\t\t     SIGNED_FIXED_POINT_MODE_P (mode));\n+    }\n+  else\n+    {\n+      temp.low = 0;\n+      temp.high = 0;\n+      temp_trunc.low = 0;\n+      temp_trunc.high = 0;\n+    }\n+\n+  /* If FIXED_CST is negative, we need to round the value toward 0.\n+     By checking if the fractional bits are not zero to add 1 to temp.  */\n+  if (SIGNED_FIXED_POINT_MODE_P (mode) && temp_trunc.high < 0\n+      && !double_int_equal_p (TREE_FIXED_CST (arg1).data, temp_trunc))\n+    {\n+      double_int one;\n+      one.low = 1;\n+      one.high = 0;\n+      temp = double_int_add (temp, one);\n+    }\n+\n+  /* Given a fixed-point constant, make new constant with new type,\n+     appropriately sign-extended or truncated.  */\n+  t = force_fit_type_double (type, temp.low, temp.high, -1,\n+\t\t\t     (temp.high < 0\n+\t\t \t      && (TYPE_UNSIGNED (type)\n+\t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t\t     | TREE_OVERFLOW (arg1));\n+\n+  return t;\n+}\n+\n /* A subroutine of fold_convert_const handling conversions a REAL_CST\n    to another floating point type.  */\n \n@@ -2167,6 +2278,102 @@ fold_convert_const_real_from_real (tree type, tree arg1)\n   return t;\n }\n \n+/* A subroutine of fold_convert_const handling conversions a FIXED_CST\n+   to a floating point type.  */\n+\n+static tree\n+fold_convert_const_real_from_fixed (tree type, tree arg1)\n+{\n+  REAL_VALUE_TYPE value;\n+  tree t;\n+\n+  real_convert_from_fixed (&value, TYPE_MODE (type), &TREE_FIXED_CST (arg1));\n+  t = build_real (type, value);\n+\n+  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n+  TREE_CONSTANT_OVERFLOW (t)\n+    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+  return t;\n+}\n+\n+/* A subroutine of fold_convert_const handling conversions a FIXED_CST\n+   to another fixed-point type.  */\n+\n+static tree\n+fold_convert_const_fixed_from_fixed (tree type, tree arg1)\n+{\n+  FIXED_VALUE_TYPE value;\n+  tree t;\n+  bool overflow_p;\n+\n+  overflow_p = fixed_convert (&value, TYPE_MODE (type), &TREE_FIXED_CST (arg1),\n+\t\t\t      TYPE_SATURATING (type));\n+  t = build_fixed (type, value);\n+\n+  /* Propagate overflow flags.  */\n+  if (overflow_p | TREE_OVERFLOW (arg1))\n+    {\n+      TREE_OVERFLOW (t) = 1;\n+      TREE_CONSTANT_OVERFLOW (t) = 1;\n+    }\n+  else if (TREE_CONSTANT_OVERFLOW (arg1))\n+    TREE_CONSTANT_OVERFLOW (t) = 1;\n+  return t;\n+}\n+\n+/* A subroutine of fold_convert_const handling conversions an INTEGER_CST\n+   to a fixed-point type.  */\n+\n+static tree\n+fold_convert_const_fixed_from_int (tree type, tree arg1)\n+{\n+  FIXED_VALUE_TYPE value;\n+  tree t;\n+  bool overflow_p;\n+\n+  overflow_p = fixed_convert_from_int (&value, TYPE_MODE (type),\n+\t\t\t\t       TREE_INT_CST (arg1),\n+\t\t\t\t       TYPE_UNSIGNED (TREE_TYPE (arg1)),\n+\t\t\t\t       TYPE_SATURATING (type));\n+  t = build_fixed (type, value);\n+\n+  /* Propagate overflow flags.  */\n+  if (overflow_p | TREE_OVERFLOW (arg1))\n+    {\n+      TREE_OVERFLOW (t) = 1;\n+      TREE_CONSTANT_OVERFLOW (t) = 1;\n+    }\n+  else if (TREE_CONSTANT_OVERFLOW (arg1))\n+    TREE_CONSTANT_OVERFLOW (t) = 1;\n+  return t;\n+}\n+\n+/* A subroutine of fold_convert_const handling conversions a REAL_CST\n+   to a fixed-point type.  */\n+\n+static tree\n+fold_convert_const_fixed_from_real (tree type, tree arg1)\n+{\n+  FIXED_VALUE_TYPE value;\n+  tree t;\n+  bool overflow_p;\n+\n+  overflow_p = fixed_convert_from_real (&value, TYPE_MODE (type),\n+\t\t\t\t\t&TREE_REAL_CST (arg1),\n+\t\t\t\t\tTYPE_SATURATING (type));\n+  t = build_fixed (type, value);\n+\n+  /* Propagate overflow flags.  */\n+  if (overflow_p | TREE_OVERFLOW (arg1))\n+    {\n+      TREE_OVERFLOW (t) = 1;\n+      TREE_CONSTANT_OVERFLOW (t) = 1;\n+    }\n+  else if (TREE_CONSTANT_OVERFLOW (arg1))\n+    TREE_CONSTANT_OVERFLOW (t) = 1;\n+  return t;\n+}\n+\n /* Attempt to fold type conversion operation CODE of expression ARG1 to\n    type TYPE.  If no simplification can be done return NULL_TREE.  */\n \n@@ -2182,13 +2389,26 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \treturn fold_convert_const_int_from_int (type, arg1);\n       else if (TREE_CODE (arg1) == REAL_CST)\n \treturn fold_convert_const_int_from_real (code, type, arg1);\n+      else if (TREE_CODE (arg1) == FIXED_CST)\n+\treturn fold_convert_const_int_from_fixed (type, arg1);\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n     {\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \treturn build_real_from_int_cst (type, arg1);\n-      if (TREE_CODE (arg1) == REAL_CST)\n+      else if (TREE_CODE (arg1) == REAL_CST)\n \treturn fold_convert_const_real_from_real (type, arg1);\n+      else if (TREE_CODE (arg1) == FIXED_CST)\n+\treturn fold_convert_const_real_from_fixed (type, arg1);\n+    }\n+  else if (TREE_CODE (type) == FIXED_POINT_TYPE)\n+    {\n+      if (TREE_CODE (arg1) == FIXED_CST)\n+\treturn fold_convert_const_fixed_from_fixed (type, arg1);\n+      else if (TREE_CODE (arg1) == INTEGER_CST)\n+\treturn fold_convert_const_fixed_from_int (type, arg1);\n+      else if (TREE_CODE (arg1) == REAL_CST)\n+\treturn fold_convert_const_fixed_from_real (type, arg1);\n     }\n   return NULL_TREE;\n }\n@@ -2300,6 +2520,12 @@ fold_convert (tree type, tree arg)\n \t  if (tem != NULL_TREE)\n \t    return tem;\n \t}\n+      else if (TREE_CODE (arg) == FIXED_CST)\n+\t{\n+\t  tem = fold_convert_const (FIXED_CONVERT_EXPR, type, arg);\n+\t  if (tem != NULL_TREE)\n+\t    return tem;\n+\t}\n \n       switch (TREE_CODE (orig))\n \t{\n@@ -2311,6 +2537,35 @@ fold_convert (tree type, tree arg)\n \tcase REAL_TYPE:\n \t  return fold_build1 (NOP_EXPR, type, arg);\n \n+\tcase FIXED_POINT_TYPE:\n+\t  return fold_build1 (FIXED_CONVERT_EXPR, type, arg);\n+\n+\tcase COMPLEX_TYPE:\n+\t  tem = fold_build1 (REALPART_EXPR, TREE_TYPE (orig), arg);\n+\t  return fold_convert (type, tem);\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+    case FIXED_POINT_TYPE:\n+      if (TREE_CODE (arg) == FIXED_CST || TREE_CODE (arg) == INTEGER_CST\n+\t  || TREE_CODE (arg) == REAL_CST)\n+\t{\n+\t  tem = fold_convert_const (FIXED_CONVERT_EXPR, type, arg);\n+\t  if (tem != NULL_TREE)\n+\t    return tem;\n+\t}\n+\n+      switch (TREE_CODE (orig))\n+\t{\n+\tcase FIXED_POINT_TYPE:\n+\tcase INTEGER_TYPE:\n+\tcase ENUMERAL_TYPE:\n+\tcase BOOLEAN_TYPE:\n+\tcase REAL_TYPE:\n+\t  return fold_build1 (FIXED_CONVERT_EXPR, type, arg);\n+\n \tcase COMPLEX_TYPE:\n \t  tem = fold_build1 (REALPART_EXPR, TREE_TYPE (orig), arg);\n \t  return fold_convert (type, tem);\n@@ -2326,6 +2581,7 @@ fold_convert (tree type, tree arg)\n \tcase BOOLEAN_TYPE: case ENUMERAL_TYPE:\n \tcase POINTER_TYPE: case REFERENCE_TYPE:\n \tcase REAL_TYPE:\n+\tcase FIXED_POINT_TYPE:\n \t  return build2 (COMPLEX_EXPR, type,\n \t\t\t fold_convert (TREE_TYPE (type), arg),\n \t\t\t fold_convert (TREE_TYPE (type), integer_zero_node));\n@@ -2808,6 +3064,10 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       case INTEGER_CST:\n \treturn tree_int_cst_equal (arg0, arg1);\n \n+      case FIXED_CST:\n+\treturn FIXED_VALUES_IDENTICAL (TREE_FIXED_CST (arg0),\n+\t\t\t\t       TREE_FIXED_CST (arg1));\n+\n       case REAL_CST:\n \tif (REAL_VALUES_IDENTICAL (TREE_REAL_CST (arg0),\n \t\t\t\t   TREE_REAL_CST (arg1)))\n@@ -4265,8 +4525,16 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n \t  if (!TYPE_UNSIGNED (exp_type) && TYPE_UNSIGNED (arg0_type))\n \t    {\n \t      tree high_positive;\n-\t      tree equiv_type = lang_hooks.types.type_for_mode\n-\t\t(TYPE_MODE (arg0_type), 1);\n+\t      tree equiv_type;\n+\t      /* For fixed-point modes, we need to pass the saturating flag\n+\t\t as the 2nd parameter.  */\n+\t      if (ALL_FIXED_POINT_MODE_P (TYPE_MODE (arg0_type)))\n+\t\tequiv_type = lang_hooks.types.type_for_mode\n+\t\t\t     (TYPE_MODE (arg0_type),\n+\t\t\t      TYPE_SATURATING (arg0_type));\n+\t      else\n+\t\tequiv_type = lang_hooks.types.type_for_mode\n+\t\t\t     (TYPE_MODE (arg0_type), 1);\n \n \t      /* A range without an upper bound is, naturally, unbounded.\n \t\t Since convert would have cropped a very large value, use\n@@ -6737,6 +7005,11 @@ tree_swap_operands_p (const_tree arg0, const_tree arg1, bool reorder)\n   if (TREE_CODE (arg0) == REAL_CST)\n     return 1;\n \n+  if (TREE_CODE (arg1) == FIXED_CST)\n+    return 0;\n+  if (TREE_CODE (arg0) == FIXED_CST)\n+    return 1;\n+\n   if (TREE_CODE (arg1) == COMPLEX_CST)\n     return 0;\n   if (TREE_CODE (arg0) == COMPLEX_CST)\n@@ -7136,6 +7409,9 @@ fold_plusminus_mult_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n     }\n   else\n     {\n+      /* We cannot generate constant 1 for fract.  */\n+      if (ALL_FRACT_MODE_P (TYPE_MODE (type)))\n+\treturn NULL_TREE;\n       arg00 = arg0;\n       arg01 = build_one_cst (type);\n     }\n@@ -7151,6 +7427,9 @@ fold_plusminus_mult_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n     }\n   else\n     {\n+      /* We cannot generate constant 1 for fract.  */\n+      if (ALL_FRACT_MODE_P (TYPE_MODE (type)))\n+\treturn NULL_TREE;\n       arg10 = arg1;\n       arg11 = build_one_cst (type);\n     }\n@@ -8011,6 +8290,10 @@ fold_unary (enum tree_code code, tree type, tree op0)\n       tem = fold_convert_const (code, type, op0);\n       return tem ? tem : NULL_TREE;\n \n+    case FIXED_CONVERT_EXPR:\n+      tem = fold_convert_const (code, type, arg0);\n+      return tem ? tem : NULL_TREE;\n+\n     case VIEW_CONVERT_EXPR:\n       if (TREE_TYPE (op0) == type)\n \treturn op0;\n@@ -9114,11 +9397,18 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n      constant but we can't do arithmetic on them.  */\n   if ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n       || (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n+      || (TREE_CODE (arg0) == FIXED_CST && TREE_CODE (arg1) == FIXED_CST)\n+      || (TREE_CODE (arg0) == FIXED_CST && TREE_CODE (arg1) == INTEGER_CST)\n       || (TREE_CODE (arg0) == COMPLEX_CST && TREE_CODE (arg1) == COMPLEX_CST)\n       || (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST))\n     {\n       if (kind == tcc_binary)\n-\ttem = const_binop (code, arg0, arg1, 0);\n+\t{\n+\t  /* Make sure type and arg0 have the same saturating flag.  */\n+\t  gcc_assert (TYPE_SATURATING (type)\n+\t\t      == TYPE_SATURATING (TREE_TYPE (arg0)));\n+\t  tem = const_binop (code, arg0, arg1, 0);\n+\t}\n       else if (kind == tcc_comparison)\n \ttem = fold_relational_const (code, type, arg0, arg1);\n       else\n@@ -9323,9 +9613,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n \n       /* Handle (A1 * C1) + (A2 * C2) with A1, A2 or C1, C2 being the\n-\t same or one.  */\n+\t same or one.  Make sure type is not saturating.  */\n       if ((TREE_CODE (arg0) == MULT_EXPR\n \t   || TREE_CODE (arg1) == MULT_EXPR)\n+\t  && !TYPE_SATURATING (type)\n \t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n         {\n \t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n@@ -9569,9 +9860,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       /* In most languages, can't associate operations on floats through\n \t parentheses.  Rather than remember where the parentheses were, we\n \t don't associate floats at all, unless the user has specified\n-\t -funsafe-math-optimizations.  */\n+\t -funsafe-math-optimizations.\n+\t And, we need to make sure type is not saturating.  */\n \n-      if (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+      if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+\t  && !TYPE_SATURATING (type))\n \t{\n \t  tree var0, con0, lit0, minus_lit0;\n \t  tree var1, con1, lit1, minus_lit1;\n@@ -9874,9 +10167,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \treturn tem;\n \n       /* Handle (A1 * C1) - (A2 * C2) with A1, A2 or C1, C2 being the\n-\t same or one.  */\n+\t same or one.  Make sure type is not saturating.  */\n       if ((TREE_CODE (arg0) == MULT_EXPR\n \t   || TREE_CODE (arg1) == MULT_EXPR)\n+\t  && !TYPE_SATURATING (type)\n \t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n         {\n \t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n@@ -13480,6 +13774,9 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case REAL_CST:\n       return ! REAL_VALUE_NEGATIVE (TREE_REAL_CST (t));\n \n+    case FIXED_CST:\n+      return ! FIXED_VALUE_NEGATIVE (TREE_FIXED_CST (t));\n+\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (t)))\n@@ -14082,7 +14379,7 @@ fold_read_from_constant_string (tree exp)\n }\n \n /* Return the tree for neg (ARG0) when ARG0 is known to be either\n-   an integer constant or real constant.\n+   an integer constant, real, or fixed-point constant.\n \n    TYPE is the type of the result.  */\n \n@@ -14110,6 +14407,24 @@ fold_negate_const (tree arg0, tree type)\n       t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n       break;\n \n+    case FIXED_CST:\n+      {\n+        FIXED_VALUE_TYPE f;\n+        bool overflow_p = fixed_arithmetic (&f, NEGATE_EXPR,\n+\t\t\t\t\t    &(TREE_FIXED_CST (arg0)), NULL,\n+\t\t\t\t\t    TYPE_SATURATING (type));\n+\tt = build_fixed (type, f);\n+\t/* Propagate overflow flags.  */\n+\tif (overflow_p | TREE_OVERFLOW (arg0))\n+\t  {\n+\t    TREE_OVERFLOW (t) = 1;\n+\t    TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t  }\n+\telse if (TREE_CONSTANT_OVERFLOW (arg0))\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\tbreak;\n+      }\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -14240,6 +14555,13 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n       return constant_boolean_node (real_compare (code, c0, c1), type);\n     }\n \n+  if (TREE_CODE (op0) == FIXED_CST && TREE_CODE (op1) == FIXED_CST)\n+    {\n+      const FIXED_VALUE_TYPE *c0 = TREE_FIXED_CST_PTR (op0);\n+      const FIXED_VALUE_TYPE *c1 = TREE_FIXED_CST_PTR (op1);\n+      return constant_boolean_node (fixed_compare (code, c0, c1), type);\n+    }\n+\n   /* Handle equality/inequality of complex constants.  */\n   if (TREE_CODE (op0) == COMPLEX_CST && TREE_CODE (op1) == COMPLEX_CST)\n     {"}, {"sha": "c6c0788d721527696e9147d93cec24d4efda39a4", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -4488,6 +4488,7 @@ omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n       omp_firstprivatize_variable (ctx, TYPE_MIN_VALUE (type));\n       omp_firstprivatize_variable (ctx, TYPE_MAX_VALUE (type));\n       break;\n@@ -5728,6 +5729,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  /* Constants need not be gimplified.  */\n \tcase INTEGER_CST:\n \tcase REAL_CST:\n+\tcase FIXED_CST:\n \tcase STRING_CST:\n \tcase COMPLEX_CST:\n \tcase VECTOR_CST:\n@@ -6271,6 +6273,7 @@ gimplify_type_sizes (tree type, tree *list_p)\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n       gimplify_one_sizepos (&TYPE_MIN_VALUE (type), list_p);\n       gimplify_one_sizepos (&TYPE_MAX_VALUE (type), list_p);\n "}, {"sha": "76e2d3b7b5063a5ebc01625c9c587b6092e7c998", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -481,7 +481,8 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n          we store CONST_IPATYPE and its value as the jump function \n          of this argument.  */\n       else if (TREE_CODE (arg) == INTEGER_CST\n-\t       || TREE_CODE (arg) == REAL_CST)\n+\t       || TREE_CODE (arg) == REAL_CST\n+\t       || TREE_CODE (arg) == FIXED_CST)\n \t{\n \t  ipa_callsite_param_set_type (cs, arg_num, CONST_IPATYPE);\n \t  ipa_callsite_param_set_info_type (cs, arg_num, arg);\n@@ -495,7 +496,8 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n \t{\n \t  cst_decl = TREE_OPERAND (arg, 0);\n \t  if (TREE_CODE (DECL_INITIAL (cst_decl)) == INTEGER_CST\n-\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST)\n+\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST\n+\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == FIXED_CST)\n \t    {\n \t      ipa_callsite_param_set_type (cs, arg_num,\n \t\t\t\t\t   CONST_IPATYPE_REF);"}, {"sha": "5303e79ec269da2172ec861150d365a0b0cd5b66", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -274,6 +274,7 @@ type_to_consider (tree type)\n     case INTEGER_TYPE:\n     case QUAL_UNION_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case VECTOR_TYPE:"}, {"sha": "55efdf4cc4f7e8f60e2b0c60be049e798241a0a7", "filename": "gcc/print-tree.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"tree-iterator.h\"\n@@ -147,6 +148,18 @@ print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n \t  fprintf (file, \" %s\", string);\n \t}\n     }\n+  if (TREE_CODE (node) == FIXED_CST)\n+    {\n+      FIXED_VALUE_TYPE f;\n+      char string[60];\n+\n+      if (TREE_OVERFLOW (node))\n+\tfprintf (file, \" overflow\");\n+\n+      f = TREE_FIXED_CST (node);\n+      fixed_to_decimal (string, &f, sizeof (string));\n+      fprintf (file, \" %s\", string);\n+    }\n \n   fprintf (file, \">\");\n }\n@@ -610,7 +623,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       \n       print_node (file, \"attributes\", TYPE_ATTRIBUTES (node), indent + 4);\n \n-      if (INTEGRAL_TYPE_P (node) || TREE_CODE (node) == REAL_TYPE)\n+      if (INTEGRAL_TYPE_P (node) || TREE_CODE (node) == REAL_TYPE\n+\t  || TREE_CODE (node) == FIXED_POINT_TYPE)\n \t{\n \t  fprintf (file, \" precision %d\", TYPE_PRECISION (node));\n \t  print_node_brief (file, \"min\", TYPE_MIN_VALUE (node), indent + 4);\n@@ -755,6 +769,20 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  }\n \t  break;\n \n+\tcase FIXED_CST:\n+\t  {\n+\t    FIXED_VALUE_TYPE f;\n+\t    char string[64];\n+\n+\t    if (TREE_OVERFLOW (node))\n+\t      fprintf (file, \" overflow\");\n+\n+\t    f = TREE_FIXED_CST (node);\n+\t    fixed_to_decimal (string, &f, sizeof (string));\n+\t    fprintf (file, \" %s\", string);\n+\t  }\n+\t  break;\n+\n \tcase VECTOR_CST:\n \t  {\n \t    tree vals = TREE_VECTOR_CST_ELTS (node);"}, {"sha": "ea658a86aa0f85147b320c89b3aa95ce56a1ff7f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -236,6 +236,14 @@ int_mode_for_mode (enum machine_mode mode)\n     case MODE_DECIMAL_FLOAT:\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n+    case MODE_FRACT:\n+    case MODE_ACCUM:\n+    case MODE_UFRACT:\n+    case MODE_UACCUM:\n+    case MODE_VECTOR_FRACT:\n+    case MODE_VECTOR_ACCUM:\n+    case MODE_VECTOR_UFRACT:\n+    case MODE_VECTOR_UACCUM:\n       mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n       break;\n \n@@ -1602,6 +1610,12 @@ layout_type (tree type)\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n+   case FIXED_POINT_TYPE:\n+     /* TYPE_MODE (type) has been set already.  */\n+     TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+     TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n+     break;\n+\n     case COMPLEX_TYPE:\n       TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n       TYPE_MODE (type)\n@@ -1629,6 +1643,14 @@ layout_type (tree type)\n \t    /* First, look for a supported vector type.  */\n \t    if (SCALAR_FLOAT_MODE_P (innermode))\n \t      mode = MIN_MODE_VECTOR_FLOAT;\n+\t    else if (SCALAR_FRACT_MODE_P (innermode))\n+\t      mode = MIN_MODE_VECTOR_FRACT;\n+\t    else if (SCALAR_UFRACT_MODE_P (innermode))\n+\t      mode = MIN_MODE_VECTOR_UFRACT;\n+\t    else if (SCALAR_ACCUM_MODE_P (innermode))\n+\t      mode = MIN_MODE_VECTOR_ACCUM;\n+\t    else if (SCALAR_UACCUM_MODE_P (innermode))\n+\t      mode = MIN_MODE_VECTOR_UACCUM;\n \t    else\n \t      mode = MIN_MODE_VECTOR_INT;\n \n@@ -1650,6 +1672,7 @@ layout_type (tree type)\n \t      TYPE_MODE (type) = mode;\n \t  }\n \n+\tTYPE_SATURATING (type) = TYPE_SATURATING (TREE_TYPE (type));\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n \tTYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n \t\t\t\t\t         TYPE_SIZE_UNIT (innertype),\n@@ -1905,6 +1928,58 @@ make_unsigned_type (int precision)\n   return type;\n }\n \f\n+/* Create and return a type for fract of PRECISION bits, UNSIGNEDP,\n+   and SATP.  */\n+\n+tree\n+make_fract_type (int precision, int unsignedp, int satp)\n+{\n+  tree type = make_node (FIXED_POINT_TYPE);\n+\n+  TYPE_PRECISION (type) = precision;\n+\n+  if (satp)\n+    TYPE_SATURATING (type) = 1;\n+\n+  /* Lay out the type: set its alignment, size, etc.  */\n+  if (unsignedp)\n+    {\n+      TYPE_UNSIGNED (type) = 1;\n+      TYPE_MODE (type) = mode_for_size (precision, MODE_UFRACT, 0);\n+    }\n+  else\n+    TYPE_MODE (type) = mode_for_size (precision, MODE_FRACT, 0);\n+  layout_type (type);\n+\n+  return type;\n+}\n+\n+/* Create and return a type for accum of PRECISION bits, UNSIGNEDP,\n+   and SATP.  */\n+\n+tree\n+make_accum_type (int precision, int unsignedp, int satp)\n+{\n+  tree type = make_node (FIXED_POINT_TYPE);\n+\n+  TYPE_PRECISION (type) = precision;\n+\n+  if (satp)\n+    TYPE_SATURATING (type) = 1;\n+\n+  /* Lay out the type: set its alignment, size, etc.  */\n+  if (unsignedp)\n+    {\n+      TYPE_UNSIGNED (type) = 1;\n+      TYPE_MODE (type) = mode_for_size (precision, MODE_UACCUM, 0);\n+    }\n+  else\n+    TYPE_MODE (type) = mode_for_size (precision, MODE_ACCUM, 0);\n+  layout_type (type);\n+\n+  return type;\n+}\n+\n /* Initialize sizetype and bitsizetype to a reasonable and temporary\n    value to enable integer types to be created.  */\n "}, {"sha": "89c3bf3a307c8e713fbc5e0710963d22eb2f9fd7", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -162,15 +162,17 @@ browse_tree (tree begin)\n \n \tcase TB_MAX:\n \t  if (head && (INTEGRAL_TYPE_P (head)\n-\t\t       || TREE_CODE (head) == REAL_TYPE))\n+\t\t       || TREE_CODE (head) == REAL_TYPE\n+\t\t       || TREE_CODE (head) == FIXED_POINT_TYPE))\n \t    TB_SET_HEAD (TYPE_MAX_VALUE (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_MIN:\n \t  if (head && (INTEGRAL_TYPE_P (head)\n-\t\t       || TREE_CODE (head) == REAL_TYPE))\n+\t\t       || TREE_CODE (head) == REAL_TYPE\n+\t\t       || TREE_CODE (head) == FIXED_POINT_TYPE))\n \t    TB_SET_HEAD (TYPE_MIN_VALUE (head));\n \t  else\n \t    TB_WF;"}, {"sha": "693c8c99347b388591b878828949e6c334554ca7", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -96,6 +96,8 @@ some_nonzerop (tree t)\n \n   if (TREE_CODE (t) == REAL_CST)\n     zerop = REAL_VALUES_IDENTICAL (TREE_REAL_CST (t), dconst0);\n+  else if (TREE_CODE (t) == FIXED_CST)\n+    zerop = fixed_zerop (t);\n   else if (TREE_CODE (t) == INTEGER_CST)\n     zerop = integer_zerop (t);\n "}, {"sha": "f370bcd738e7d62467b81ff08e6aecb75f03e197", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-iterator.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n \n static unsigned int queue (dump_info_p, tree, int);\n static void dump_index (dump_info_p, unsigned int);\n@@ -191,6 +192,18 @@ dump_real (dump_info_p di, const char *field, const REAL_VALUE_TYPE *r)\n   di->column += strlen (buf) + 7;\n }\n \n+/* Dump the fixed-point value F, using FIELD to identify it.  */\n+\n+static void\n+dump_fixed (dump_info_p di, const char *field, const FIXED_VALUE_TYPE *f)\n+{\n+  char buf[32];\n+  fixed_to_decimal (buf, f, sizeof (buf));\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %s \", field, buf);\n+  di->column += strlen (buf) + 7;\n+}\n+\n \n /* Dump the string S.  */\n \n@@ -453,6 +466,13 @@ dequeue_and_dump (dump_info_p di)\n       dump_int (di, \"prec\", TYPE_PRECISION (t));\n       break;\n \n+    case FIXED_POINT_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      dump_string_field (di, \"sign\", TYPE_UNSIGNED (t) ? \"unsigned\": \"signed\");\n+      dump_string_field (di, \"saturating\",\n+\t\t\t TYPE_SATURATING (t) ? \"saturating\": \"non-saturating\");\n+      break;\n+\n     case POINTER_TYPE:\n       dump_child (\"ptd\", TREE_TYPE (t));\n       break;\n@@ -549,6 +569,10 @@ dequeue_and_dump (dump_info_p di)\n       dump_real (di, \"valu\", TREE_REAL_CST_PTR (t));\n       break;\n \n+    case FIXED_CST:\n+      dump_fixed (di, \"valu\", TREE_FIXED_CST_PTR (t));\n+      break;\n+\n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:"}, {"sha": "def2b124136bf92d42dbd05bd1d1d83d5d55ee70", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -67,6 +67,7 @@ is_gimple_formal_tmp_rhs (tree t)\n     case COMPLEX_EXPR:\n     case INTEGER_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case STRING_CST:\n     case COMPLEX_CST:\n     case VECTOR_CST:\n@@ -178,6 +179,7 @@ is_gimple_min_invariant (const_tree t)\n \n     case INTEGER_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case STRING_CST:\n     case COMPLEX_CST:\n     case VECTOR_CST:"}, {"sha": "3609480dc4333598103e2577f757e892439dab8c", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -340,6 +340,7 @@ remap_type_1 (tree type, copy_body_data *id)\n     {\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n       t = TYPE_MIN_VALUE (new);\n@@ -2020,6 +2021,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case IDENTIFIER_NODE:\n     case INTEGER_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case STRING_CST:\n@@ -2085,6 +2087,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case MINUS_EXPR:\n     case MULT_EXPR:\n \n+    case FIXED_CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n \n     case NEGATE_EXPR:"}, {"sha": "a502da02ee63e2e2dbfe85a829c752eff94aca06", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"tree-chrec.h\"\n #include \"tree-pass.h\"\n+#include \"fixed-value.h\"\n #include \"value-prof.h\"\n \n /* Local functions, macros and variables.  */\n@@ -527,6 +528,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case VOID_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n     case ENUMERAL_TYPE:\n@@ -804,6 +806,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tbreak;\n       }\n \n+    case FIXED_CST:\n+      {\n+\tchar string[100];\n+\tfixed_to_decimal (string, TREE_FIXED_CST_PTR (node), sizeof (string));\n+\tpp_string (buffer, string);\n+\tbreak;\n+      }\n+\n     case COMPLEX_CST:\n       pp_string (buffer, \"__complex__ (\");\n       dump_generic_node (buffer, TREE_REALPART (node), spc, flags, false);\n@@ -1378,6 +1388,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       NIY;\n       break;\n \n+    case FIXED_CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case FLOAT_EXPR:\n     case CONVERT_EXPR:"}, {"sha": "64627ef561d97ad3c298eda6e5fab33da7455e0e", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -600,6 +600,7 @@ get_scalar_evolution (tree scalar)\n       break;\n \n     case REAL_CST:\n+    case FIXED_CST:\n     case INTEGER_CST:\n       res = scalar;\n       break;"}, {"sha": "f2e64c702e4cf94469d30ac7e88038356dc0a85f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -220,6 +220,7 @@ is_sra_scalar_type (tree type)\n {\n   enum tree_code code = TREE_CODE (type);\n   return (code == INTEGER_TYPE || code == REAL_TYPE || code == VECTOR_TYPE\n+\t  || code == FIXED_POINT_TYPE\n \t  || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE\n \t  || code == POINTER_TYPE || code == OFFSET_TYPE\n \t  || code == REFERENCE_TYPE);"}, {"sha": "d2ab41ce0543eac3e9cb059d2b750b1a1b2532ab", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -204,6 +204,7 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase COMPLEX_CST:\n \tcase INTEGER_CST:\n \tcase REAL_CST:\n+\tcase FIXED_CST:\n \t  return true;\n \n \tcase TARGET_MEM_REF:"}, {"sha": "059af1212b7ef8e402bf8d24bdbca0badd4f1dd2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -3081,6 +3081,7 @@ poolify_tree (tree node)\n     case INTEGER_CST:\n     case STRING_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case PARM_DECL:\n     case VAR_DECL:\n     case RESULT_DECL:"}, {"sha": "87db02f3273962aa1ebe6b71a765e208febe533c", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -1245,12 +1245,15 @@ break_up_subtract_bb (basic_block bb)\n \n \t  TREE_VISITED (stmt) = 0;\n \t  /* If unsafe math optimizations we can do reassociation for\n-\t     non-integral types.  */\n+\t     non-integral types.  Or, we can do reassociation for\n+\t     non-saturating fixed-point types.  */\n \t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n \t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n-\t\t  || !flag_unsafe_math_optimizations))\n+\t\t  || !flag_unsafe_math_optimizations)\n+\t      && (!NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE (rhs))\n+\t\t  || !NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE(lhs))))\n \t    continue;\n \n \t  /* Check for a subtract used only in an addition.  If this\n@@ -1292,12 +1295,15 @@ reassociate_bb (basic_block bb)\n \t    continue;\n \n \t  /* If unsafe math optimizations we can do reassociation for\n-\t     non-integral types.  */\n+\t     non-integral types.  Or, we can do reassociation for\n+\t     non-saturating fixed-point types.  */\n \t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n \t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n \t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n-\t\t  || !flag_unsafe_math_optimizations))\n+\t\t  || !flag_unsafe_math_optimizations)\n+\t      && (!NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE (rhs))\n+\t\t  || !NON_SAT_FIXED_POINT_TYPE_P (TREE_TYPE(lhs))))\n \t    continue;\n \n \t  if (associative_tree_code (TREE_CODE (rhs)))"}, {"sha": "aa673255ea39e1e13f68544e532e6d653c234278", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -295,7 +295,11 @@ expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n      a BLKmode vector to smaller, hardware-supported vectors), we may want\n      to expand the operations in parallel.  */\n   if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FRACT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UFRACT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_ACCUM\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UACCUM)\n     switch (code)\n       {\n       case PLUS_EXPR:\n@@ -340,15 +344,25 @@ expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n }\n \f\n /* Return a type for the widest vector mode whose components are of mode\n-   INNER_MODE, or NULL_TREE if none is found.  */\n+   INNER_MODE, or NULL_TREE if none is found.\n+   SATP is true for saturating fixed-point types.  */\n+\n static tree\n-type_for_widest_vector_mode (enum machine_mode inner_mode, optab op)\n+type_for_widest_vector_mode (enum machine_mode inner_mode, optab op, int satp)\n {\n   enum machine_mode best_mode = VOIDmode, mode;\n   int best_nunits = 0;\n \n   if (SCALAR_FLOAT_MODE_P (inner_mode))\n     mode = MIN_MODE_VECTOR_FLOAT;\n+  else if (SCALAR_FRACT_MODE_P (inner_mode))\n+    mode = MIN_MODE_VECTOR_FRACT;\n+  else if (SCALAR_UFRACT_MODE_P (inner_mode))\n+    mode = MIN_MODE_VECTOR_UFRACT;\n+  else if (SCALAR_ACCUM_MODE_P (inner_mode))\n+    mode = MIN_MODE_VECTOR_ACCUM;\n+  else if (SCALAR_UACCUM_MODE_P (inner_mode))\n+    mode = MIN_MODE_VECTOR_UACCUM;\n   else\n     mode = MIN_MODE_VECTOR_INT;\n \n@@ -361,7 +375,13 @@ type_for_widest_vector_mode (enum machine_mode inner_mode, optab op)\n   if (best_mode == VOIDmode)\n     return NULL_TREE;\n   else\n-    return lang_hooks.types.type_for_mode (best_mode, 1);\n+    {\n+      /* For fixed-point modes, we need to pass satp as the 2nd parameter.  */\n+      if (ALL_FIXED_POINT_MODE_P (best_mode))\n+\treturn lang_hooks.types.type_for_mode (best_mode, satp);\n+\n+      return lang_hooks.types.type_for_mode (best_mode, 1);\n+    }\n }\n \n /* Process one statement.  If we identify a vector operation, expand it.  */\n@@ -445,7 +465,8 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n   if (TYPE_MODE (type) == BLKmode && op)\n     {\n       tree vector_compute_type\n-        = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op);\n+        = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op,\n+\t\t\t\t       TYPE_SATURATING (TREE_TYPE (type)));\n       if (vector_compute_type != NULL_TREE)\n         compute_type = vector_compute_type;\n     }\n@@ -457,7 +478,11 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n     {\n       compute_mode = TYPE_MODE (compute_type);\n       if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT)\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FRACT\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UFRACT\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_ACCUM\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UACCUM)\n           && op != NULL\n \t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n \treturn;"}, {"sha": "30930c6c690dc999c36af8592c3088eb144d6740", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -4913,7 +4913,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n       if (!vect_is_simple_use (lhs, loop_vinfo, &lhs_def_stmt, &def, &dt))\n \treturn false;\n     }\n-  else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST)\n+  else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST\n+\t   && TREE_CODE (lhs) != FIXED_CST)\n     return false;\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n@@ -4922,7 +4923,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n       if (!vect_is_simple_use (rhs, loop_vinfo, &rhs_def_stmt, &def, &dt))\n \treturn false;\n     }\n-  else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST)\n+  else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST\n+\t   && TREE_CODE (rhs) != FIXED_CST)\n     return false;\n \n   return true;\n@@ -5003,7 +5005,8 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \treturn false;\n     }\n   else if (TREE_CODE (then_clause) != INTEGER_CST \n-\t   && TREE_CODE (then_clause) != REAL_CST)\n+\t   && TREE_CODE (then_clause) != REAL_CST\n+\t   && TREE_CODE (then_clause) != FIXED_CST)\n     return false;\n \n   if (TREE_CODE (else_clause) == SSA_NAME)\n@@ -5014,7 +5017,8 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \treturn false;\n     }\n   else if (TREE_CODE (else_clause) != INTEGER_CST \n-\t   && TREE_CODE (else_clause) != REAL_CST)\n+\t   && TREE_CODE (else_clause) != REAL_CST\n+\t   && TREE_CODE (else_clause) != FIXED_CST)\n     return false;\n \n "}, {"sha": "47a25f8fe5e029c2b86f53b573963ce6f76c700b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -2150,6 +2150,16 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n         }\n       return NULL_TREE;\n     }\n+  else if (SAT_FIXED_POINT_TYPE_P (type))\n+    {\n+      /* Changing the order of operations changes the semantics.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"reduction: unsafe fixed-point math optimization: \");\n+          print_generic_expr (vect_dump, operation, TDF_SLIM);\n+        }\n+      return NULL_TREE;\n+    }\n \n   /* reduction is safe. we're dealing with one of the following:\n      1) integer arithmetic and no trapv"}, {"sha": "9a08a689db42d25123718e249ed4b9082f64a28a", "filename": "gcc/tree.c", "status": "modified", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"params.h\"\n #include \"pointer-set.h\"\n+#include \"fixed-value.h\"\n \n /* Each tree code class has an associated string representation.\n    These must correspond to the tree_code_class entries.  */\n@@ -399,6 +400,7 @@ tree_code_size (enum tree_code code)\n \t{\n \tcase INTEGER_CST:\treturn sizeof (struct tree_int_cst);\n \tcase REAL_CST:\t\treturn sizeof (struct tree_real_cst);\n+\tcase FIXED_CST:\t\treturn sizeof (struct tree_fixed_cst);\n \tcase COMPLEX_CST:\treturn sizeof (struct tree_complex);\n \tcase VECTOR_CST:\treturn sizeof (struct tree_vector);\n \tcase STRING_CST:\tgcc_unreachable ();\n@@ -1095,6 +1097,22 @@ build_constructor_from_list (tree type, tree vals)\n   return t;\n }\n \n+/* Return a new FIXED_CST node whose type is TYPE and value is F.  */\n+\n+tree\n+build_fixed (tree type, FIXED_VALUE_TYPE f)\n+{\n+  tree v;\n+  FIXED_VALUE_TYPE *fp;\n+\n+  v = make_node (FIXED_CST);\n+  fp = ggc_alloc (sizeof (FIXED_VALUE_TYPE));\n+  memcpy (fp, &f, sizeof (FIXED_VALUE_TYPE));\n+\n+  TREE_TYPE (v) = type;\n+  TREE_FIXED_CST_PTR (v) = fp;\n+  return v;\n+}\n \n /* Return a new REAL_CST node whose type is TYPE and value is D.  */\n \n@@ -1215,6 +1233,11 @@ build_one_cst (tree type)\n     case REAL_TYPE:\n       return build_real (type, dconst1);\n \n+    case FIXED_POINT_TYPE:\n+      /* We can only generate 1 for accum types.  */\n+      gcc_assert (ALL_SCALAR_ACCUM_MODE_P (TYPE_MODE (type)));\n+      return build_fixed (type, FCONST1(TYPE_MODE (type)));\n+\n     case VECTOR_TYPE:\n       {\n \ttree scalar, cst;\n@@ -1434,6 +1457,15 @@ integer_nonzerop (const_tree expr)\n \t\t  || integer_nonzerop (TREE_IMAGPART (expr)))));\n }\n \n+/* Return 1 if EXPR is the fixed-point constant zero.  */\n+\n+int\n+fixed_zerop (tree expr)\n+{\n+  return (TREE_CODE (expr) == FIXED_CST\n+\t  && double_int_zero_p (TREE_FIXED_CST (expr).data));\n+}\n+\n /* Return the power of two represented by a tree node known to be a\n    power of two.  */\n \n@@ -2184,6 +2216,7 @@ tree_node_structure (const_tree t)\n       /* tcc_constant cases.  */\n     case INTEGER_CST:\t\treturn TS_INT_CST;\n     case REAL_CST:\t\treturn TS_REAL_CST;\n+    case FIXED_CST:\t\treturn TS_FIXED_CST;\n     case COMPLEX_CST:\t\treturn TS_COMPLEX;\n     case VECTOR_CST:\t\treturn TS_VECTOR;\n     case STRING_CST:\t\treturn TS_STRING;\n@@ -2324,6 +2357,7 @@ type_contains_placeholder_1 (const_tree type)\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n       /* Here we just check the bounds.  */\n       return (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (type))\n \t      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));\n@@ -3677,6 +3711,7 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n \t    (TREE_INT_CST_HIGH (TYPE_MAX_VALUE (ntype)), hashcode);\n \t  break;\n \tcase REAL_TYPE:\n+\tcase FIXED_POINT_TYPE:\n \t  {\n \t    unsigned int precision = TYPE_PRECISION (ntype);\n \t    hashcode = iterative_hash_object (precision, hashcode);\n@@ -4551,6 +4586,9 @@ type_hash_eq (const void *va, const void *vb)\n \t\t  || tree_int_cst_equal (TYPE_MIN_VALUE (a->type),\n \t\t\t\t\t TYPE_MIN_VALUE (b->type))));\n \n+    case FIXED_POINT_TYPE:\n+      return TYPE_SATURATING (a->type) == TYPE_SATURATING (b->type);\n+\n     case OFFSET_TYPE:\n       return TYPE_OFFSET_BASETYPE (a->type) == TYPE_OFFSET_BASETYPE (b->type);\n \n@@ -5011,6 +5049,9 @@ simple_cst_equal (const_tree t1, const_tree t2)\n     case REAL_CST:\n       return REAL_VALUES_IDENTICAL (TREE_REAL_CST (t1), TREE_REAL_CST (t2));\n \n+    case FIXED_CST:\n+      return FIXED_VALUES_IDENTICAL (TREE_FIXED_CST (t1), TREE_FIXED_CST (t2));\n+\n     case STRING_CST:\n       return (TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n \t      && ! memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n@@ -5232,6 +5273,12 @@ iterative_hash_expr (const_tree t, hashval_t val)\n       {\n \tunsigned int val2 = real_hash (TREE_REAL_CST_PTR (t));\n \n+\treturn iterative_hash_hashval_t (val2, val);\n+      }\n+    case FIXED_CST:\n+      {\n+\tunsigned int val2 = fixed_hash (TREE_FIXED_CST_PTR (t));\n+\n \treturn iterative_hash_hashval_t (val2, val);\n       }\n     case STRING_CST:\n@@ -6064,6 +6111,7 @@ get_unwidened (tree op, tree for_type)\n   if (TREE_CODE (op) == COMPONENT_REF\n       /* Since type_for_size always gives an integer type.  */\n       && TREE_CODE (type) != REAL_TYPE\n+      && TREE_CODE (type) != FIXED_POINT_TYPE\n       /* Don't crash if field not laid out yet.  */\n       && DECL_SIZE (TREE_OPERAND (op, 1)) != 0\n       && host_integerp (DECL_SIZE (TREE_OPERAND (op, 1)), 1))\n@@ -6155,6 +6203,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n   if (TREE_CODE (op) == COMPONENT_REF\n       /* Since type_for_size always gives an integer type.  */\n       && TREE_CODE (TREE_TYPE (op)) != REAL_TYPE\n+      && TREE_CODE (TREE_TYPE (op)) != FIXED_POINT_TYPE\n       /* Ensure field is laid out already.  */\n       && DECL_SIZE (TREE_OPERAND (op, 1)) != 0\n       && host_integerp (DECL_SIZE (TREE_OPERAND (op, 1)), 1))\n@@ -6378,6 +6427,7 @@ variably_modified_type_p (tree type, tree fn)\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n       /* Scalar types are variably modified if their end points\n@@ -7048,6 +7098,80 @@ make_or_reuse_type (unsigned size, int unsignedp)\n     return make_signed_type (size);\n }\n \n+/* Create or reuse a fract type by SIZE, UNSIGNEDP, and SATP.  */\n+\n+static tree\n+make_or_reuse_fract_type (unsigned size, int unsignedp, int satp)\n+{\n+  if (satp)\n+    {\n+      if (size == SHORT_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_short_fract_type_node\n+\t\t\t : sat_short_fract_type_node;\n+      if (size == FRACT_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_fract_type_node : sat_fract_type_node;\n+      if (size == LONG_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_long_fract_type_node\n+\t\t\t : sat_long_fract_type_node;\n+      if (size == LONG_LONG_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_long_long_fract_type_node\n+\t\t\t : sat_long_long_fract_type_node;\n+    }\n+  else\n+    {\n+      if (size == SHORT_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_short_fract_type_node\n+\t\t\t : short_fract_type_node;\n+      if (size == FRACT_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_fract_type_node : fract_type_node;\n+      if (size == LONG_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_long_fract_type_node\n+\t\t\t : long_fract_type_node;\n+      if (size == LONG_LONG_FRACT_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_long_long_fract_type_node\n+\t\t\t : long_long_fract_type_node;\n+    }\n+\n+  return make_fract_type (size, unsignedp, satp);\n+}\n+\n+/* Create or reuse an accum type by SIZE, UNSIGNEDP, and SATP.  */\n+\n+static tree\n+make_or_reuse_accum_type (unsigned size, int unsignedp, int satp)\n+{\n+  if (satp)\n+    {\n+      if (size == SHORT_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_short_accum_type_node\n+\t\t\t : sat_short_accum_type_node;\n+      if (size == ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_accum_type_node : sat_accum_type_node;\n+      if (size == LONG_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_long_accum_type_node\n+\t\t\t : sat_long_accum_type_node;\n+      if (size == LONG_LONG_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? sat_unsigned_long_long_accum_type_node\n+\t\t\t : sat_long_long_accum_type_node;\n+    }\n+  else\n+    {\n+      if (size == SHORT_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_short_accum_type_node\n+\t\t\t : short_accum_type_node;\n+      if (size == ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_accum_type_node : accum_type_node;\n+      if (size == LONG_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_long_accum_type_node\n+\t\t\t : long_accum_type_node;\n+      if (size == LONG_LONG_ACCUM_TYPE_SIZE)\n+\treturn unsignedp ? unsigned_long_long_accum_type_node\n+\t\t\t : long_long_accum_type_node;\n+    }\n+\n+  return make_accum_type (size, unsignedp, satp);\n+}\n+\n /* Create nodes for all integer types (and error_mark_node) using the sizes\n    of C datatypes.  The caller should call set_sizetype soon after calling\n    this function to select one of the types as sizetype.  */\n@@ -7195,6 +7319,50 @@ build_common_tree_nodes_2 (int short_double)\n   complex_double_type_node = build_complex_type (double_type_node);\n   complex_long_double_type_node = build_complex_type (long_double_type_node);\n \n+/* Make fixed-point nodes based on sat/non-sat and signed/unsigned.  */\n+#define MAKE_FIXED_TYPE_NODE(KIND,WIDTH,SIZE) \\\n+  sat_ ## WIDTH ## KIND ## _type_node = \\\n+    make_sat_signed_ ## KIND ## _type (SIZE); \\\n+  sat_unsigned_ ## WIDTH ## KIND ## _type_node = \\\n+    make_sat_unsigned_ ## KIND ## _type (SIZE); \\\n+  WIDTH ## KIND ## _type_node = make_signed_ ## KIND ## _type (SIZE); \\\n+  unsigned_ ## WIDTH ## KIND ## _type_node = \\\n+    make_unsigned_ ## KIND ## _type (SIZE);\n+\n+/* Make fixed-point type nodes based on four different widths.  */\n+#define MAKE_FIXED_TYPE_NODE_FAMILY(N1,N2) \\\n+  MAKE_FIXED_TYPE_NODE (N1, short_, SHORT_ ## N2 ## _TYPE_SIZE) \\\n+  MAKE_FIXED_TYPE_NODE (N1, , N2 ## _TYPE_SIZE) \\\n+  MAKE_FIXED_TYPE_NODE (N1, long_, LONG_ ## N2 ## _TYPE_SIZE) \\\n+  MAKE_FIXED_TYPE_NODE (N1, long_long_, LONG_LONG_ ## N2 ## _TYPE_SIZE)\n+\n+/* Make fixed-point mode nodes based on sat/non-sat and signed/unsigned.  */\n+#define MAKE_FIXED_MODE_NODE(KIND,NAME,MODE) \\\n+  NAME ## _type_node = \\\n+    make_or_reuse_signed_ ## KIND ## _type (GET_MODE_BITSIZE (MODE ## mode)); \\\n+  u ## NAME ## _type_node = \\\n+    make_or_reuse_unsigned_ ## KIND ## _type \\\n+      (GET_MODE_BITSIZE (U ## MODE ## mode)); \\\n+  sat_ ## NAME ## _type_node = \\\n+    make_or_reuse_sat_signed_ ## KIND ## _type \\\n+      (GET_MODE_BITSIZE (MODE ## mode)); \\\n+  sat_u ## NAME ## _type_node = \\\n+    make_or_reuse_sat_unsigned_ ## KIND ## _type \\\n+      (GET_MODE_BITSIZE (U ## MODE ## mode));\n+\n+  /* Fixed-point type and mode nodes.  */\n+  MAKE_FIXED_TYPE_NODE_FAMILY (fract, FRACT)\n+  MAKE_FIXED_TYPE_NODE_FAMILY (accum, ACCUM)\n+  MAKE_FIXED_MODE_NODE (fract, qq, QQ)\n+  MAKE_FIXED_MODE_NODE (fract, hq, HQ)\n+  MAKE_FIXED_MODE_NODE (fract, sq, SQ)\n+  MAKE_FIXED_MODE_NODE (fract, dq, DQ)\n+  MAKE_FIXED_MODE_NODE (fract, tq, TQ)\n+  MAKE_FIXED_MODE_NODE (accum, ha, HA)\n+  MAKE_FIXED_MODE_NODE (accum, sa, SA)\n+  MAKE_FIXED_MODE_NODE (accum, da, DA)\n+  MAKE_FIXED_MODE_NODE (accum, ta, TA)\n+\n   {\n     tree t = targetm.build_builtin_va_list ();\n \n@@ -7458,6 +7626,10 @@ build_vector_type_for_mode (tree innertype, enum machine_mode mode)\n     {\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n+    case MODE_VECTOR_FRACT:\n+    case MODE_VECTOR_UFRACT:\n+    case MODE_VECTOR_ACCUM:\n+    case MODE_VECTOR_UACCUM:\n       nunits = GET_MODE_NUNITS (mode);\n       break;\n \n@@ -7518,6 +7690,9 @@ initializer_zerop (const_tree init)\n       return real_zerop (init)\n \t&& ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (init));\n \n+    case FIXED_CST:\n+      return fixed_zerop (init);\n+\n     case COMPLEX_CST:\n       return integer_zerop (init)\n \t|| (real_zerop (init)\n@@ -8211,6 +8386,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n     case IDENTIFIER_NODE:\n     case INTEGER_CST:\n     case REAL_CST:\n+    case FIXED_CST:\n     case VECTOR_CST:\n     case STRING_CST:\n     case BLOCK:\n@@ -8389,6 +8565,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n \t  else if (TREE_CODE (*type_p) == BOOLEAN_TYPE\n \t\t   || TREE_CODE (*type_p) == ENUMERAL_TYPE\n \t\t   || TREE_CODE (*type_p) == INTEGER_TYPE\n+\t\t   || TREE_CODE (*type_p) == FIXED_POINT_TYPE\n \t\t   || TREE_CODE (*type_p) == REAL_TYPE)\n \t    {\n \t      WALK_SUBTREE (TYPE_MIN_VALUE (*type_p));"}, {"sha": "ea8449b1058289e0d7e67fc645b6a31c77ee1dc6", "filename": "gcc/tree.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -172,6 +172,11 @@ DEFTREECODE (REAL_TYPE, \"real_type\", tcc_type, 0)\n    The TREE_TYPE points to the node for the type pointed to.  */\n DEFTREECODE (POINTER_TYPE, \"pointer_type\", tcc_type, 0)\n \n+/* _Fract and _Accum types in Embedded-C.  Different fixed-point types\n+   are distinguished by machine mode and by the TYPE_SIZE and the\n+   TYPE_PRECISION.  */\n+DEFTREECODE (FIXED_POINT_TYPE, \"fixed_point_type\", tcc_type, 0)\n+\n /* A reference is like a pointer except that it is coerced\n    automatically to the value it points to.  Used in C++.  */\n DEFTREECODE (REFERENCE_TYPE, \"reference_type\", tcc_type, 0)\n@@ -272,6 +277,9 @@ DEFTREECODE (INTEGER_CST, \"integer_cst\", tcc_constant, 0)\n /* Contents are in TREE_REAL_CST field.  */\n DEFTREECODE (REAL_CST, \"real_cst\", tcc_constant, 0)\n \n+/* Contents are in TREE_FIXED_CST field.  */\n+DEFTREECODE (FIXED_CST, \"fixed_cst\", tcc_constant, 0)\n+\n /* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n    whose contents are other constant nodes.  */\n DEFTREECODE (COMPLEX_CST, \"complex_cst\", tcc_constant, 0)\n@@ -730,6 +738,11 @@ DEFTREECODE (RANGE_EXPR, \"range_expr\", tcc_binary, 2)\n    represented by CONVERT_EXPR or NOP_EXPR nodes.  */\n DEFTREECODE (CONVERT_EXPR, \"convert_expr\", tcc_unary, 1)\n \n+/* Conversion of a fixed-point value to an integer, a real, or a fixed-point\n+   value.  Or conversion of a fixed-point value from an integer, a real, or\n+   a fixed-point value.  */\n+DEFTREECODE (FIXED_CONVERT_EXPR, \"fixed_convert_expr\", tcc_unary, 1)\n+\n /* Represents a conversion expected to require no code to be generated.  */\n DEFTREECODE (NOP_EXPR, \"nop_expr\", tcc_unary, 1)\n "}, {"sha": "c7301fcfebe4cde337eda827bd47240fedf93584", "filename": "gcc/tree.h", "status": "modified", "additions": 224, "deletions": 2, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -384,6 +384,7 @@ struct tree_base GTY(())\n   unsigned protected_flag : 1;\n   unsigned deprecated_flag : 1;\n   unsigned invariant_flag : 1;\n+  unsigned saturating_flag : 1;\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;\n@@ -394,7 +395,7 @@ struct tree_base GTY(())\n   unsigned lang_flag_6 : 1;\n   unsigned visited : 1;\n \n-  unsigned spare : 24;\n+  unsigned spare : 23;\n \n   /* FIXME tuples: Eventually, we need to move this somewhere external to\n      the trees.  */\n@@ -575,6 +576,11 @@ struct gimple_stmt GTY(())\n \tTREE_INVARIANT in\n \t    all expressions.\n \n+   saturating_flag:\n+\n+       TYPE_SATURATING in\n+           all types\n+\n    nowarning_flag:\n \n        TREE_NO_WARNING in\n@@ -951,7 +957,8 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n   TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)\n \n #define NUMERICAL_TYPE_CHECK(T)\t\t\t\t\t\\\n-  TREE_CHECK4 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, REAL_TYPE)\n+  TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, REAL_TYPE,\t\\\n+\t       FIXED_POINT_TYPE)\n \n /* Nonzero if NODE is a GIMPLE statement.  */\n #define GIMPLE_STMT_P(NODE) \\\n@@ -1039,6 +1046,20 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    || TREE_CODE (TYPE) == BOOLEAN_TYPE \\\n    || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n+/* Nonzero if TYPE represents a non-saturating fixed-point type.  */\n+\n+#define NON_SAT_FIXED_POINT_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == FIXED_POINT_TYPE && !TYPE_SATURATING (TYPE))\n+\n+/* Nonzero if TYPE represents a saturating fixed-point type.  */\n+\n+#define SAT_FIXED_POINT_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == FIXED_POINT_TYPE && TYPE_SATURATING (TYPE))\n+\n+/* Nonzero if TYPE represents a fixed-point type.  */\n+\n+#define FIXED_POINT_TYPE_P(TYPE)\t(TREE_CODE (TYPE) == FIXED_POINT_TYPE)\n+\n /* Nonzero if TYPE represents a scalar floating-point type.  */\n \n #define SCALAR_FLOAT_TYPE_P(TYPE) (TREE_CODE (TYPE) == REAL_TYPE)\n@@ -1336,6 +1357,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    any expression node.  */\n #define TREE_INVARIANT(NODE) ((NODE)->base.invariant_flag)\n \n+/* In fixed-point types, means a saturating type.  */\n+#define TYPE_SATURATING(NODE) ((NODE)->base.saturating_flag)\n+\n /* These flags are available for each language front end to use internally.  */\n #define TREE_LANG_FLAG_0(NODE) ((NODE)->base.lang_flag_0)\n #define TREE_LANG_FLAG_1(NODE) ((NODE)->base.lang_flag_1)\n@@ -1387,6 +1411,18 @@ struct tree_real_cst GTY(())\n   struct real_value * real_cst_ptr;\n };\n \n+/* In a FIXED_CST node.  */\n+struct fixed_value;\n+\n+#define TREE_FIXED_CST_PTR(NODE) (FIXED_CST_CHECK (NODE)->fixed_cst.fixed_cst_ptr)\n+#define TREE_FIXED_CST(NODE) (*TREE_FIXED_CST_PTR (NODE))\n+\n+struct tree_fixed_cst GTY(())\n+{\n+  struct tree_common common;\n+  struct fixed_value * fixed_cst_ptr;\n+};\n+\n /* In a STRING_CST */\n #define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)->string.length)\n #define TREE_STRING_POINTER(NODE) \\\n@@ -2084,6 +2120,8 @@ struct tree_block GTY(())\n    type node requires structural equality. */\n #define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n+#define TYPE_IBIT(NODE) (GET_MODE_IBIT (TYPE_MODE (NODE)))\n+#define TYPE_FBIT(NODE) (GET_MODE_FBIT (TYPE_MODE (NODE)))\n \n /* For a VECTOR_TYPE node, this describes a different type which is emitted\n    in the debugging output.  We use this to describe a vector as a\n@@ -3365,6 +3403,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n   struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n   struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n+  struct tree_fixed_cst GTY ((tag (\"TS_FIXED_CST\"))) fixed_cst;\n   struct tree_vector GTY ((tag (\"TS_VECTOR\"))) vector;\n   struct tree_string GTY ((tag (\"TS_STRING\"))) string;\n   struct tree_complex GTY ((tag (\"TS_COMPLEX\"))) complex;\n@@ -3476,6 +3515,75 @@ enum tree_index\n \n   TI_MAIN_IDENTIFIER,\n \n+  TI_SAT_SFRACT_TYPE,\n+  TI_SAT_FRACT_TYPE,\n+  TI_SAT_LFRACT_TYPE,\n+  TI_SAT_LLFRACT_TYPE,\n+  TI_SAT_USFRACT_TYPE,\n+  TI_SAT_UFRACT_TYPE,\n+  TI_SAT_ULFRACT_TYPE,\n+  TI_SAT_ULLFRACT_TYPE,\n+  TI_SFRACT_TYPE,\n+  TI_FRACT_TYPE,\n+  TI_LFRACT_TYPE,\n+  TI_LLFRACT_TYPE,\n+  TI_USFRACT_TYPE,\n+  TI_UFRACT_TYPE,\n+  TI_ULFRACT_TYPE,\n+  TI_ULLFRACT_TYPE,\n+  TI_SAT_SACCUM_TYPE,\n+  TI_SAT_ACCUM_TYPE,\n+  TI_SAT_LACCUM_TYPE,\n+  TI_SAT_LLACCUM_TYPE,\n+  TI_SAT_USACCUM_TYPE,\n+  TI_SAT_UACCUM_TYPE,\n+  TI_SAT_ULACCUM_TYPE,\n+  TI_SAT_ULLACCUM_TYPE,\n+  TI_SACCUM_TYPE,\n+  TI_ACCUM_TYPE,\n+  TI_LACCUM_TYPE,\n+  TI_LLACCUM_TYPE,\n+  TI_USACCUM_TYPE,\n+  TI_UACCUM_TYPE,\n+  TI_ULACCUM_TYPE,\n+  TI_ULLACCUM_TYPE,\n+  TI_QQ_TYPE,\n+  TI_HQ_TYPE,\n+  TI_SQ_TYPE,\n+  TI_DQ_TYPE,\n+  TI_TQ_TYPE,\n+  TI_UQQ_TYPE,\n+  TI_UHQ_TYPE,\n+  TI_USQ_TYPE,\n+  TI_UDQ_TYPE,\n+  TI_UTQ_TYPE,\n+  TI_SAT_QQ_TYPE,\n+  TI_SAT_HQ_TYPE,\n+  TI_SAT_SQ_TYPE,\n+  TI_SAT_DQ_TYPE,\n+  TI_SAT_TQ_TYPE,\n+  TI_SAT_UQQ_TYPE,\n+  TI_SAT_UHQ_TYPE,\n+  TI_SAT_USQ_TYPE,\n+  TI_SAT_UDQ_TYPE,\n+  TI_SAT_UTQ_TYPE,\n+  TI_HA_TYPE,\n+  TI_SA_TYPE,\n+  TI_DA_TYPE,\n+  TI_TA_TYPE,\n+  TI_UHA_TYPE,\n+  TI_USA_TYPE,\n+  TI_UDA_TYPE,\n+  TI_UTA_TYPE,\n+  TI_SAT_HA_TYPE,\n+  TI_SAT_SA_TYPE,\n+  TI_SAT_DA_TYPE,\n+  TI_SAT_TA_TYPE,\n+  TI_SAT_UHA_TYPE,\n+  TI_SAT_USA_TYPE,\n+  TI_SAT_UDA_TYPE,\n+  TI_SAT_UTA_TYPE,\n+\n   TI_MAX\n };\n \n@@ -3555,6 +3663,84 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define dfloat64_ptr_type_node          global_trees[TI_DFLOAT64_PTR_TYPE]\n #define dfloat128_ptr_type_node         global_trees[TI_DFLOAT128_PTR_TYPE]\n \n+/* The fixed-point types.  */\n+#define sat_short_fract_type_node       global_trees[TI_SAT_SFRACT_TYPE]\n+#define sat_fract_type_node             global_trees[TI_SAT_FRACT_TYPE]\n+#define sat_long_fract_type_node        global_trees[TI_SAT_LFRACT_TYPE]\n+#define sat_long_long_fract_type_node   global_trees[TI_SAT_LLFRACT_TYPE]\n+#define sat_unsigned_short_fract_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_USFRACT_TYPE]\n+#define sat_unsigned_fract_type_node    global_trees[TI_SAT_UFRACT_TYPE]\n+#define sat_unsigned_long_fract_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_ULFRACT_TYPE]\n+#define sat_unsigned_long_long_fract_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_ULLFRACT_TYPE]\n+#define short_fract_type_node           global_trees[TI_SFRACT_TYPE]\n+#define fract_type_node                 global_trees[TI_FRACT_TYPE]\n+#define long_fract_type_node            global_trees[TI_LFRACT_TYPE]\n+#define long_long_fract_type_node       global_trees[TI_LLFRACT_TYPE]\n+#define unsigned_short_fract_type_node  global_trees[TI_USFRACT_TYPE]\n+#define unsigned_fract_type_node        global_trees[TI_UFRACT_TYPE]\n+#define unsigned_long_fract_type_node   global_trees[TI_ULFRACT_TYPE]\n+#define unsigned_long_long_fract_type_node \\\n+\t\t\t\t\tglobal_trees[TI_ULLFRACT_TYPE]\n+#define sat_short_accum_type_node       global_trees[TI_SAT_SACCUM_TYPE]\n+#define sat_accum_type_node             global_trees[TI_SAT_ACCUM_TYPE]\n+#define sat_long_accum_type_node        global_trees[TI_SAT_LACCUM_TYPE]\n+#define sat_long_long_accum_type_node   global_trees[TI_SAT_LLACCUM_TYPE]\n+#define sat_unsigned_short_accum_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_USACCUM_TYPE]\n+#define sat_unsigned_accum_type_node    global_trees[TI_SAT_UACCUM_TYPE]\n+#define sat_unsigned_long_accum_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_ULACCUM_TYPE]\n+#define sat_unsigned_long_long_accum_type_node \\\n+\t\t\t\t\tglobal_trees[TI_SAT_ULLACCUM_TYPE]\n+#define short_accum_type_node           global_trees[TI_SACCUM_TYPE]\n+#define accum_type_node                 global_trees[TI_ACCUM_TYPE]\n+#define long_accum_type_node            global_trees[TI_LACCUM_TYPE]\n+#define long_long_accum_type_node       global_trees[TI_LLACCUM_TYPE]\n+#define unsigned_short_accum_type_node  global_trees[TI_USACCUM_TYPE]\n+#define unsigned_accum_type_node        global_trees[TI_UACCUM_TYPE]\n+#define unsigned_long_accum_type_node   global_trees[TI_ULACCUM_TYPE]\n+#define unsigned_long_long_accum_type_node \\\n+\t\t\t\t\tglobal_trees[TI_ULLACCUM_TYPE]\n+#define qq_type_node                    global_trees[TI_QQ_TYPE]\n+#define hq_type_node                    global_trees[TI_HQ_TYPE]\n+#define sq_type_node                    global_trees[TI_SQ_TYPE]\n+#define dq_type_node                    global_trees[TI_DQ_TYPE]\n+#define tq_type_node                    global_trees[TI_TQ_TYPE]\n+#define uqq_type_node                   global_trees[TI_UQQ_TYPE]\n+#define uhq_type_node                   global_trees[TI_UHQ_TYPE]\n+#define usq_type_node                   global_trees[TI_USQ_TYPE]\n+#define udq_type_node                   global_trees[TI_UDQ_TYPE]\n+#define utq_type_node                   global_trees[TI_UTQ_TYPE]\n+#define sat_qq_type_node                global_trees[TI_SAT_QQ_TYPE]\n+#define sat_hq_type_node                global_trees[TI_SAT_HQ_TYPE]\n+#define sat_sq_type_node                global_trees[TI_SAT_SQ_TYPE]\n+#define sat_dq_type_node                global_trees[TI_SAT_DQ_TYPE]\n+#define sat_tq_type_node                global_trees[TI_SAT_TQ_TYPE]\n+#define sat_uqq_type_node               global_trees[TI_SAT_UQQ_TYPE]\n+#define sat_uhq_type_node               global_trees[TI_SAT_UHQ_TYPE]\n+#define sat_usq_type_node               global_trees[TI_SAT_USQ_TYPE]\n+#define sat_udq_type_node               global_trees[TI_SAT_UDQ_TYPE]\n+#define sat_utq_type_node               global_trees[TI_SAT_UTQ_TYPE]\n+#define ha_type_node                    global_trees[TI_HA_TYPE]\n+#define sa_type_node                    global_trees[TI_SA_TYPE]\n+#define da_type_node                    global_trees[TI_DA_TYPE]\n+#define ta_type_node                    global_trees[TI_TA_TYPE]\n+#define uha_type_node                   global_trees[TI_UHA_TYPE]\n+#define usa_type_node                   global_trees[TI_USA_TYPE]\n+#define uda_type_node                   global_trees[TI_UDA_TYPE]\n+#define uta_type_node                   global_trees[TI_UTA_TYPE]\n+#define sat_ha_type_node                global_trees[TI_SAT_HA_TYPE]\n+#define sat_sa_type_node                global_trees[TI_SAT_SA_TYPE]\n+#define sat_da_type_node                global_trees[TI_SAT_DA_TYPE]\n+#define sat_ta_type_node                global_trees[TI_SAT_TA_TYPE]\n+#define sat_uha_type_node               global_trees[TI_SAT_UHA_TYPE]\n+#define sat_usa_type_node               global_trees[TI_SAT_USA_TYPE]\n+#define sat_uda_type_node               global_trees[TI_SAT_UDA_TYPE]\n+#define sat_uta_type_node               global_trees[TI_SAT_UTA_TYPE]\n+\n /* The node that should be placed at the end of a parameter list to\n    indicate that the function does not take a variable number of\n    arguments.  The TREE_VALUE will be void_type_node and there will be\n@@ -3834,6 +4020,37 @@ extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n extern bool may_negate_without_overflow_p (const_tree);\n extern tree get_inner_array_type (const_tree);\n \n+/* Construct various nodes representing fract or accum data types.  */\n+\n+extern tree make_fract_type (int, int, int);\n+extern tree make_accum_type (int, int, int);\n+\n+#define make_signed_fract_type(P) make_fract_type (P, 0, 0)\n+#define make_unsigned_fract_type(P) make_fract_type (P, 1, 0)\n+#define make_sat_signed_fract_type(P) make_fract_type (P, 0, 1)\n+#define make_sat_unsigned_fract_type(P) make_fract_type (P, 1, 1)\n+#define make_signed_accum_type(P) make_accum_type (P, 0, 0)\n+#define make_unsigned_accum_type(P) make_accum_type (P, 1, 0)\n+#define make_sat_signed_accum_type(P) make_accum_type (P, 0, 1)\n+#define make_sat_unsigned_accum_type(P) make_accum_type (P, 1, 1)\n+\n+#define make_or_reuse_signed_fract_type(P) \\\n+\t\tmake_or_reuse_fract_type (P, 0, 0)\n+#define make_or_reuse_unsigned_fract_type(P) \\\n+\t\tmake_or_reuse_fract_type (P, 1, 0)\n+#define make_or_reuse_sat_signed_fract_type(P) \\\n+\t\tmake_or_reuse_fract_type (P, 0, 1)\n+#define make_or_reuse_sat_unsigned_fract_type(P) \\\n+\t\tmake_or_reuse_fract_type (P, 1, 1)\n+#define make_or_reuse_signed_accum_type(P) \\\n+\t\tmake_or_reuse_accum_type (P, 0, 0)\n+#define make_or_reuse_unsigned_accum_type(P) \\\n+\t\tmake_or_reuse_accum_type (P, 1, 0)\n+#define make_or_reuse_sat_signed_accum_type(P) \\\n+\t\tmake_or_reuse_accum_type (P, 0, 1)\n+#define make_or_reuse_sat_unsigned_accum_type(P) \\\n+\t\tmake_or_reuse_accum_type (P, 1, 1)\n+\n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if\n    tree.h had been included.  */\n@@ -4209,6 +4426,11 @@ extern int integer_nonzerop (const_tree);\n extern bool cst_and_fits_in_hwi (const_tree);\n extern tree num_ending_zeros (const_tree);\n \n+/* fixed_zerop (tree x) is nonzero if X is a fixed-point constant of\n+   value 0.  */\n+\n+extern int fixed_zerop (tree);\n+\n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  Returns the outermost data.  */\n "}, {"sha": "ef4a7240647a609fd7faefa5d61562dcc4b60779", "filename": "gcc/treestruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325217edf0332af8e5e52a32eb9b3cd862646375/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=325217edf0332af8e5e52a32eb9b3cd862646375", "patch": "@@ -31,6 +31,7 @@ DEFTREESTRUCT(TS_BASE, \"base\")\n DEFTREESTRUCT(TS_COMMON, \"common\")\n DEFTREESTRUCT(TS_INT_CST, \"integer cst\")\n DEFTREESTRUCT(TS_REAL_CST, \"real cst\")\n+DEFTREESTRUCT(TS_FIXED_CST, \"fixed cst\")\n DEFTREESTRUCT(TS_VECTOR, \"vector\")\n DEFTREESTRUCT(TS_STRING, \"string\")\n DEFTREESTRUCT(TS_COMPLEX, \"complex\")"}]}