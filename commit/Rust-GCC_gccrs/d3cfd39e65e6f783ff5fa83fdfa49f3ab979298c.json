{"sha": "d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjZmQzOWU2NWU2Zjc4M2ZmNWZhODNmZGZhNDlmM2FiOTc5Mjk4Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-11-11T08:10:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-11-11T08:10:07Z"}, "message": "tree-vect-slp.c (vect_free_slp_tree): Also free SLP_TREE_CHILDREN vector.\n\n\t* tree-vect-slp.c (vect_free_slp_tree): Also free SLP_TREE_CHILDREN\n\tvector.\n\t(vect_create_new_slp_node): Don't allocate node before checking stmt\n\ttype.\n\t(vect_free_oprnd_info): Remove FREE_DEF_STMTS argument, always\n\tfree def_stmts vectors and additionally free oprnd_info.\n\t(vect_build_slp_tree): Adjust callers.  Call it even if\n\tstop_recursion.  If vect_create_new_slp_node or\n\tvect_build_slp_tree fails, properly handle freeing memory.\n\tIf it succeeded, clear def_stmts in oprnd_info.\n\nFrom-SVN: r181281", "tree": {"sha": "a4703f11eaa696daa28c0efbf1aef00963d37ac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4703f11eaa696daa28c0efbf1aef00963d37ac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4774d267d36bad7261eb60d19502d4706b0d8f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4774d267d36bad7261eb60d19502d4706b0d8f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4774d267d36bad7261eb60d19502d4706b0d8f26"}], "stats": {"total": 83, "additions": 50, "deletions": 33}, "files": [{"sha": "94c9370ce3974b6be05dfda0021445660232f558", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "patch": "@@ -1,3 +1,16 @@\n+2011-11-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vect-slp.c (vect_free_slp_tree): Also free SLP_TREE_CHILDREN\n+\tvector.\n+\t(vect_create_new_slp_node): Don't allocate node before checking stmt\n+\ttype.\n+\t(vect_free_oprnd_info): Remove FREE_DEF_STMTS argument, always\n+\tfree def_stmts vectors and additionally free oprnd_info.\n+\t(vect_build_slp_tree): Adjust callers.  Call it even if\n+\tstop_recursion.  If vect_create_new_slp_node or\n+\tvect_build_slp_tree fails, properly handle freeing memory.\n+\tIf it succeeded, clear def_stmts in oprnd_info.\n+\n 2011-08-12  Dimitrios Apostolou  <jimis@gmx.net>\n \n \t* final.c, output.h (fprint_whex, fprint_w, fprint_ul, sprint_ul):"}, {"sha": "4606c1922acb1432d6ea869824a2174b935379c0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d3cfd39e65e6f783ff5fa83fdfa49f3ab979298c", "patch": "@@ -75,8 +75,9 @@ vect_free_slp_tree (slp_tree node)\n     return;\n \n   FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n-    vect_free_slp_tree ((slp_tree)child);\n+    vect_free_slp_tree ((slp_tree) child);\n \n+  VEC_free (slp_void_p, heap, SLP_TREE_CHILDREN (node));\n   VEC_free (gimple, heap, SLP_TREE_SCALAR_STMTS (node));\n \n   if (SLP_TREE_VEC_STMTS (node))\n@@ -102,7 +103,7 @@ vect_free_slp_instance (slp_instance instance)\n static slp_tree\n vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n {\n-  slp_tree node = XNEW (struct _slp_tree);\n+  slp_tree node;\n   gimple stmt = VEC_index (gimple, scalar_stmts, 0);\n   unsigned int nops;\n \n@@ -117,6 +118,7 @@ vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n   else\n     return NULL;\n \n+  node = XNEW (struct _slp_tree);\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_VEC_STMTS (node) = NULL;\n   SLP_TREE_CHILDREN (node) = VEC_alloc (slp_void_p, heap, nops);\n@@ -152,21 +154,19 @@ vect_create_oprnd_info (int nops, int group_size)\n }\n \n \n-/* Free operands info.  Free def-stmts in FREE_DEF_STMTS is true.\n-   (FREE_DEF_STMTS is true when the SLP analysis fails, and false when it\n-   succeds.  In the later case we don't need the operands info that we used to\n-   check isomorphism of the stmts, but we still need the def-stmts - they are\n-   used as scalar stmts in SLP nodes.  */\n+/* Free operands info.  */\n+\n static void\n-vect_free_oprnd_info (VEC (slp_oprnd_info, heap) **oprnds_info,\n-                      bool free_def_stmts)\n+vect_free_oprnd_info (VEC (slp_oprnd_info, heap) **oprnds_info)\n {\n   int i;\n   slp_oprnd_info oprnd_info;\n \n-  if (free_def_stmts)\n-    FOR_EACH_VEC_ELT (slp_oprnd_info, *oprnds_info, i, oprnd_info)\n+  FOR_EACH_VEC_ELT (slp_oprnd_info, *oprnds_info, i, oprnd_info)\n+    {\n       VEC_free (gimple, heap, oprnd_info->def_stmts);\n+      XDELETE (oprnd_info);\n+    }\n \n   VEC_free (slp_oprnd_info, heap, *oprnds_info);\n }\n@@ -502,7 +502,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n \n-\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  vect_free_oprnd_info (&oprnds_info);\n           return false;\n         }\n \n@@ -516,7 +516,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t    }\n \n-\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  vect_free_oprnd_info (&oprnds_info);\n \t  return false;\n \t}\n \n@@ -532,7 +532,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n \n-          vect_free_oprnd_info (&oprnds_info, true);\n+\t  vect_free_oprnd_info (&oprnds_info);\n           return false;\n         }\n \n@@ -546,7 +546,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n             }\n \n-\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  vect_free_oprnd_info (&oprnds_info);\n           return false;\n         }\n \n@@ -576,7 +576,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \t}\n@@ -611,7 +611,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t    {\n \t\t      if (vect_print_dump_info (REPORT_SLP))\n \t\t\tfprintf (vect_dump, \"Build SLP failed: no optab.\");\n-\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t      vect_free_oprnd_info (&oprnds_info);\n \t\t      return false;\n \t\t    }\n \t\t  icode = (int) optab_handler (optab, vec_mode);\n@@ -620,7 +620,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      if (vect_print_dump_info (REPORT_SLP))\n \t\t\tfprintf (vect_dump, \"Build SLP failed: \"\n \t\t\t\t            \"op not supported by target.\");\n-\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t      vect_free_oprnd_info (&oprnds_info);\n \t\t      return false;\n \t\t    }\n \t\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n@@ -657,7 +657,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \n@@ -671,7 +671,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \n@@ -691,7 +691,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t    }\n \n-\t\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t\t  vect_free_oprnd_info (&oprnds_info);\n \t\t  return false;\n \t\t}\n \t    }\n@@ -707,7 +707,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t\tstmt, ncopies_for_cost,\n \t\t\t\t\t\t(i == 0), &oprnds_info))\n \t\t{\n-\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t  vect_free_oprnd_info (&oprnds_info);\n  \t\t  return false;\n \t\t}\n \t    }\n@@ -727,7 +727,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                     }\n \n-\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t  vect_free_oprnd_info (&oprnds_info);\n                   return false;\n                 }\n \n@@ -744,7 +744,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                     }\n \n-\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t  vect_free_oprnd_info (&oprnds_info);\n                   return false;\n                 }\n \n@@ -765,7 +765,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                         }\n  \n-\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t      vect_free_oprnd_info (&oprnds_info);\n                       return false;\n                     }\n                 }\n@@ -785,7 +785,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                         }\n \n-\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n+\t  \t      vect_free_oprnd_info (&oprnds_info);\n                       return false;\n                     }\n \n@@ -821,7 +821,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t}\n \n \t      /* FORNOW: Not strided loads are not supported.  */\n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \n@@ -838,7 +838,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \n@@ -857,7 +857,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                     }\n \n-\t\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t\t  vect_free_oprnd_info (&oprnds_info);\n                   return false;\n \t\t}\n             }\n@@ -867,7 +867,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t    ncopies_for_cost, (i == 0),\n \t\t\t\t\t    &oprnds_info))\n \t    {\n-\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n \t    }\n \t}\n@@ -898,6 +898,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             *loads_permuted = true;\n         }\n \n+      vect_free_oprnd_info (&oprnds_info);\n       return true;\n     }\n \n@@ -916,15 +917,18 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\tmax_nunits, load_permutation, loads,\n \t\t\t\tvectorization_factor, loads_permuted))\n         {\n-          free (child);\n-          vect_free_oprnd_info (&oprnds_info, true);\n+\t  if (child)\n+\t    oprnd_info->def_stmts = NULL;\n+\t  vect_free_slp_tree (child);\n+\t  vect_free_oprnd_info (&oprnds_info);\n    \t  return false;\n \t}\n \n+      oprnd_info->def_stmts = NULL;\n       VEC_quick_push (slp_void_p, SLP_TREE_CHILDREN (*node), child);\n     }\n \n-  vect_free_oprnd_info (&oprnds_info, false);\n+  vect_free_oprnd_info (&oprnds_info);\n   return true;\n }\n "}]}