{"sha": "50ad96428042fa526d001309059a6187dd9e0d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhZDk2NDI4MDQyZmE1MjZkMDAxMzA5MDU5YTYxODdkZDllMGQzYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-08-08T05:48:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-08-08T05:48:39Z"}, "message": "Rework build_component_ref.\n\n\t* call.c (build_vfield_ref): Do not go through build_component_ref.\n\t(build_field_call): Use build_class_member_access_expr.\n\t(build_user_type_conversion_1): Use BASELINK_FUNCTIONS.\n\t(build_object_call): Likewise.\n\t* class.c (convert_to_base): New function.\n\t(type_requires_array_cookie): Use BASELINK_FUNCTIONS.\n\t(instantiate_type): Handle BASELINKs.\n\t* cp-tree.def (BASELINK): New tree code.\n\t* cp-tree.h (BASELINK_P): Reimplement.\n\t(SET_BASELINK_P): Remove.\n\t(BASELINK_BINFO): Reimplement.\n\t(BASELINK_FUNCTIONS): Likewise.\n\t(BASELINK_ACCESS_BINFO): Likewise.\n\t(BASELINK_OPTYPE): Likewise.\n\t(convert_to_base): New function.\n\t(name_p): Likewise.\n\t(build_object_ref): Remove.\n\t(build_component_ref_1): Likewise.\n\t(build_component_ref): Likewise.\n\t(build_x_component_ref): Likewise.\n\t(build_class_member_access_expr): New function.\n\t(finish_class_member_access_expr): Likewise.\n\t(build_ptrmemfunc_access_expr): Likewise.\n\t* decl.c (grokdeclarator): Handle BASELINKs.\n\t* decl2. (build_expr_from_tree): Handle COMPONENT_REFs by using\n\tfinish_class_member_access_expr.\n\t(arg_assoc): Handle BASELINKs.\n\t(do_class_using_decl): Likewise.\n\t* error.c (dump_decl): Likewise.\n\t(dump_expr): Use build_ptrmemfunc_access_expr.\n\t* except.c (dtor_nothrow): Use CLASSTYPE_DESTRUCTORS to find\n\tdestructors.\n\t(build_throw): Use BASELINK_FUNCTIONS.\n\t* init.c (perform_member_init): Use\n\tbuild_class_member_access_expr.\n\t(build_offset_ref): Handle BASELINKs.  Use\n\tbuild_class_member_access_expr.\n\t* method.c (hack_identifier): Likewise.\n\t* parse.y (do_id): Use BASELINK, not TREE_LIST.\n\t(primary): Remove uses of build_object_ref.\n\t* pt.c (lookup_template_function): Handle BASELINKs.\n\t(resolve_overloaded_unification): Likewise.\n\t* search.c (build_baselink): Build a BASELINK, not a TREE_LIST.\n\t(lookup_field): Use BASELINK, not TREE_LIST.\n\t(lookup_fnfiels): Likewise.\n\t(setup_class_bindings): Likewise.\n\t* semantics.c (finish_object_call_expr): Do not use\n\tbuild_method_call when we already know what function is being\n\tcalled.\n\t* spew.c (identifier_type): Use BASELINK, not TREE_LIST.\n\t* tree.c (really_overloaded_fn): Use OVL_CHAIN for OVERLOADs, not\n\tTREE_CHAIN.\n\t(name_p): New function.\n\t* typeck.c (build_object_ref): Remove.\n\t(build_component_ref_1): Likewise.\n\t(build_x_component_ref): Likewise.\n\t(build_class_member_access_expr): New function.\n\t(finish_class_member_access_expr): Likewise.\n\t(build_ptrmemfunc_access_expr): Likewise.\n\t(get_member_function_from_ptrfunc): Use\n\tbuild_ptrmemfunc_access_expr.\n\t(build_binary_op): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_ptrmemfunc): Likewise.\n\t(pfn_from_ptrmemfunc): Likewise.\n\t* typeck2.c (build_m_component_ref): Adjust comment.\n\n\t* g++.dg/abi/offsetof.C: Tweak error messages.\n\t* g++.old-deja/g++.mike/p10769a.C: Likewise.\n\nFrom-SVN: r56117", "tree": {"sha": "058425a91c86198acce41c98f8f13929c3780dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/058425a91c86198acce41c98f8f13929c3780dc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ad96428042fa526d001309059a6187dd9e0d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ad96428042fa526d001309059a6187dd9e0d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ad96428042fa526d001309059a6187dd9e0d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ad96428042fa526d001309059a6187dd9e0d3c/comments", "author": null, "committer": null, "parents": [{"sha": "774b5662b439b3c2c48ffd0e0f19218f3054296f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774b5662b439b3c2c48ffd0e0f19218f3054296f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774b5662b439b3c2c48ffd0e0f19218f3054296f"}], "stats": {"total": 1079, "additions": 642, "deletions": 437}, "files": [{"sha": "b5e51ed353847915b437049ce10cbabbae2aea67", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1,3 +1,73 @@\n+2002-08-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRework build_component_ref.\n+\t* call.c (build_vfield_ref): Do not go through build_component_ref.\n+\t(build_field_call): Use build_class_member_access_expr.\n+\t(build_user_type_conversion_1): Use BASELINK_FUNCTIONS.\n+\t(build_object_call): Likewise.\n+\t* class.c (convert_to_base): New function.\n+\t(type_requires_array_cookie): Use BASELINK_FUNCTIONS.\n+\t(instantiate_type): Handle BASELINKs.\n+\t* cp-tree.def (BASELINK): New tree code.\n+\t* cp-tree.h (BASELINK_P): Reimplement.\n+\t(SET_BASELINK_P): Remove.\n+\t(BASELINK_BINFO): Reimplement.\n+\t(BASELINK_FUNCTIONS): Likewise.\n+\t(BASELINK_ACCESS_BINFO): Likewise.\n+\t(BASELINK_OPTYPE): Likewise.\n+\t(convert_to_base): New function.\n+\t(name_p): Likewise.\n+\t(build_object_ref): Remove.\n+\t(build_component_ref_1): Likewise.\n+\t(build_component_ref): Likewise.\n+\t(build_x_component_ref): Likewise.\n+\t(build_class_member_access_expr): New function.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(build_ptrmemfunc_access_expr): Likewise.\n+\t* decl.c (grokdeclarator): Handle BASELINKs.\n+\t* decl2. (build_expr_from_tree): Handle COMPONENT_REFs by using\n+\tfinish_class_member_access_expr.\n+\t(arg_assoc): Handle BASELINKs.\n+\t(do_class_using_decl): Likewise.\n+\t* error.c (dump_decl): Likewise.\n+\t(dump_expr): Use build_ptrmemfunc_access_expr.\n+\t* except.c (dtor_nothrow): Use CLASSTYPE_DESTRUCTORS to find\n+\tdestructors.\n+\t(build_throw): Use BASELINK_FUNCTIONS.\n+\t* init.c (perform_member_init): Use\n+\tbuild_class_member_access_expr.\n+\t(build_offset_ref): Handle BASELINKs.  Use\n+\tbuild_class_member_access_expr.\n+\t* method.c (hack_identifier): Likewise.\n+\t* parse.y (do_id): Use BASELINK, not TREE_LIST.\n+\t(primary): Remove uses of build_object_ref.\n+\t* pt.c (lookup_template_function): Handle BASELINKs.\n+\t(resolve_overloaded_unification): Likewise.\n+\t* search.c (build_baselink): Build a BASELINK, not a TREE_LIST.\n+\t(lookup_field): Use BASELINK, not TREE_LIST.\n+\t(lookup_fnfiels): Likewise.\n+\t(setup_class_bindings): Likewise.\n+\t* semantics.c (finish_object_call_expr): Do not use\n+\tbuild_method_call when we already know what function is being\n+\tcalled.\n+\t* spew.c (identifier_type): Use BASELINK, not TREE_LIST.\n+\t* tree.c (really_overloaded_fn): Use OVL_CHAIN for OVERLOADs, not\n+\tTREE_CHAIN.\n+\t(name_p): New function.\n+\t* typeck.c (build_object_ref): Remove.\n+\t(build_component_ref_1): Likewise.\n+\t(build_x_component_ref): Likewise.\n+\t(build_class_member_access_expr): New function.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(build_ptrmemfunc_access_expr): Likewise.\n+\t(get_member_function_from_ptrfunc): Use\n+\tbuild_ptrmemfunc_access_expr.\n+\t(build_binary_op): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_ptrmemfunc): Likewise.\n+\t(pfn_from_ptrmemfunc): Likewise.\n+\t* typeck2.c (build_m_component_ref): Adjust comment.\n+\t\n 2002-08-07  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* Make-lang.in (CXX_C_OBJS): Update."}, {"sha": "7f6b32fc053f1cd18e48b74be80267b95c1ad743", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -106,21 +106,18 @@ tree\n build_vfield_ref (datum, type)\n      tree datum, type;\n {\n-  tree rval;\n-\n   if (datum == error_mark_node)\n     return error_mark_node;\n \n   if (TREE_CODE (TREE_TYPE (datum)) == REFERENCE_TYPE)\n     datum = convert_from_reference (datum);\n \n-  if (! TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (type))\n-    rval = build (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n-\t\t  datum, TYPE_VFIELD (type));\n-  else\n-    rval = build_component_ref (datum, DECL_NAME (TYPE_VFIELD (type)), NULL_TREE, 0);\n+  if (TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (type)\n+      && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n+    datum = convert_to_base (datum, type, /*check_access=*/false);\n \n-  return rval;\n+  return build (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n+\t\tdatum, TYPE_VFIELD (type));\n }\n \n /* Build a call to a member of an object.  I.e., one that overloads\n@@ -139,7 +136,9 @@ build_field_call (tree instance_ptr, tree decl, tree parms)\n       /* If it's a field, try overloading operator (),\n \t or calling if the field is a pointer-to-function.  */\n       instance = build_indirect_ref (instance_ptr, NULL);\n-      instance = build_component_ref_1 (instance, decl, 0);\n+      instance = build_class_member_access_expr (instance, decl, \n+\t\t\t\t\t\t /*access_path=*/NULL_TREE,\n+\t\t\t\t\t\t /*preserve_reference=*/false);\n \n       if (instance == error_mark_node)\n \treturn error_mark_node;\n@@ -2500,7 +2499,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       tree t;\n \n-      ctors = TREE_VALUE (ctors);\n+      ctors = BASELINK_FUNCTIONS (ctors);\n \n       t = build_int_2 (0, 0);\n       TREE_TYPE (t) = build_pointer_type (totype);\n@@ -2796,10 +2795,10 @@ build_object_call (obj, args)\n \n   if (fns)\n     {\n-      tree base = BINFO_TYPE (TREE_PURPOSE (fns));\n+      tree base = BINFO_TYPE (BASELINK_BINFO (fns));\n       mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n \n-      for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n+      for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)"}, {"sha": "03f73f20561a3ec2bab006a0ae8418c620989e17", "filename": "gcc/cp/class.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -358,6 +358,24 @@ build_base_path (code, expr, binfo, nonnull)\n   return expr;\n }\n \n+/* Convert OBJECT to the base TYPE.  If CHECK_ACCESS is true, an error\n+   message is emitted if TYPE is inaccessible.  OBJECT is assumed to\n+   be non-NULL.  */\n+\n+tree\n+convert_to_base (tree object, tree type, bool check_access)\n+{\n+  tree binfo;\n+\n+  binfo = lookup_base (TREE_TYPE (object), type, \n+\t\t       check_access ? ba_check : ba_ignore, \n+\t\t       NULL);\n+  if (!binfo || TREE_CODE (binfo) == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_base_path (PLUS_EXPR, object, binfo, /*nonnull=*/1);\n+}\n+\n \f\n /* Virtual function things.  */\n \n@@ -4201,7 +4219,7 @@ type_requires_array_cookie (type)\n   if (!fns || fns == error_mark_node)\n     return false;\n   /* Loop through all of the functions.  */\n-  for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n+  for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n     {\n       tree fn;\n       tree second_parm;\n@@ -6003,6 +6021,9 @@ instantiate_type (lhstype, rhs, flags)\n       return error_mark_node;\n     }\n \n+  if (TREE_CODE (rhs) == BASELINK)\n+    rhs = BASELINK_FUNCTIONS (rhs);\n+\n   /* We don't overwrite rhs if it is an overloaded function.\n      Copying it would destroy the tree link.  */\n   if (TREE_CODE (rhs) != OVERLOAD)"}, {"sha": "90685af50d4007adca53c24bd4d4c573cc4943db", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -89,6 +89,20 @@ DEFTREECODE (THROW_EXPR, \"throw_expr\", 'e', 1)\n    these to avoid actually creating instances of the empty classes.  */\n DEFTREECODE (EMPTY_CLASS_EXPR, \"empty_class_expr\", 'e', 0)\n \n+/* A reference to a member function or member functions from a base\n+   class.  BASELINK_FUNCTIONS gives the FUNCTION_DECL,\n+   TEMPLATE_DECL, OVERLOAD, or TEMPLATE_ID_EXPR corresponding to the\n+   functions.  BASELINK_BINFO gives the base from which the functions\n+   come, i.e., the base to which the `this' pointer must be converted\n+   before the functions are called.  BASELINK_ACCESS_BINFO gives the\n+   base used to name the functions.  \n+\n+   A BASELINK is an expression; the TREE_TYPE of the BASELINK gives\n+   the type of the expression.  This type is either a FUNCTION_TYPE,\n+   METHOD_TYPE, or `unknown_type_node' indicating that the function is\n+   overloaded. */\n+DEFTREECODE (BASELINK, \"baselink\", 'e', 3)\n+\n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n    accessing this data."}, {"sha": "25b6e949d2d5dd1cb0d44061187c61595d85a0ac", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -57,7 +57,6 @@ struct diagnostic_context;\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (in _TYPE).\n       INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n-      BASELINK_P (in TREE_LIST)\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       BINFO_ACCESS (in BINFO)\n    2: IDENTIFIER_OPNAME_P.\n@@ -361,32 +360,28 @@ struct tree_overload GTY(())\n   tree function;\n };\n \n-/* A `baselink' is a TREE_LIST whose TREE_PURPOSE is a BINFO\n-   indicating a particular base class, and whose TREE_VALUE is a\n-   (possibly overloaded) function from that base class.  */\n+/* Returns true iff NODE is a BASELINK.  */\n #define BASELINK_P(NODE) \\\n-  (TREE_CODE (NODE) == TREE_LIST && TREE_LANG_FLAG_1 (NODE))\n-#define SET_BASELINK_P(NODE) \\\n-  (TREE_LANG_FLAG_1 (NODE) = 1)\n-/* The BINFO indicated the base from which the BASELINK_FUNCTIONS came.  */\n+  (TREE_CODE (NODE) == BASELINK)\n+/* The BINFO indicating the base from which the BASELINK_FUNCTIONS came.  */\n #define BASELINK_BINFO(NODE) \\\n-  (TREE_PURPOSE (NODE))\n-/* The functions referred to by the BASELINK; either a FUNCTION_DECL\n-   or an OVERLOAD.  */\n+  (TREE_OPERAND (BASELINK_CHECK (NODE), 0))\n+/* The functions referred to by the BASELINK; either a FUNCTION_DECL,\n+   a TEMPLATE_DECL, an OVERLOAD, or a TEMPLATE_ID_EXPR.  */\n #define BASELINK_FUNCTIONS(NODE) \\\n-  (TREE_VALUE (NODE))\n+  (TREE_OPERAND (BASELINK_CHECK (NODE), 1))\n /* The BINFO in which the search for the functions indicated by this baselink \n    began.  This base is used to determine the accessibility of functions \n    selected by overload resolution.  */\n #define BASELINK_ACCESS_BINFO(NODE) \\\n-  (TREE_TYPE (NODE))\n+  (TREE_OPERAND (BASELINK_CHECK (NODE), 2))\n /* For a type-conversion operator, the BASELINK_OPTYPE indicates the type\n    to which the conversion should occur.  This value is important if\n    the BASELINK_FUNCTIONS include a template conversion operator --\n    the BASELINK_OPTYPE can be used to determine what type the user\n    requested.  */\n #define BASELINK_OPTYPE(NODE) \\\n-  (TREE_CHAIN (NODE))\n+  (TREE_CHAIN (BASELINK_CHECK (NODE)))\n \n #define WRAPPER_ZC(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->z_c)\n \n@@ -3525,6 +3520,7 @@ extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n \n /* in class.c */\n extern tree build_base_path\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n+extern tree convert_to_base                     (tree, tree, bool);\n extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n@@ -4238,6 +4234,7 @@ extern tree cp_build_qualified_type_real        PARAMS ((tree, int, tsubst_flags\n   cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning)\n extern tree build_shared_int_cst                PARAMS ((int));\n extern special_function_kind special_function_p PARAMS ((tree));\n+extern bool name_p                              (tree);\n extern int count_trees                          PARAMS ((tree));\n extern int char_type_p                          PARAMS ((tree));\n extern void verify_stmt_tree                    PARAMS ((tree));\n@@ -4277,10 +4274,8 @@ extern tree cxx_sizeof_or_alignof_type    PARAMS ((tree, enum tree_code, int));\n #define cxx_sizeof_nowarn(T) cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false)\n extern tree inline_conversion\t\t\tPARAMS ((tree));\n extern tree decay_conversion\t\t\tPARAMS ((tree));\n-extern tree build_object_ref\t\t\tPARAMS ((tree, tree, tree));\n-extern tree build_component_ref_1\t\tPARAMS ((tree, tree, int));\n-extern tree build_component_ref\t\t\tPARAMS ((tree, tree, tree, int));\n-extern tree build_x_component_ref\t\tPARAMS ((tree, tree, tree));\n+extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n+extern tree finish_class_member_access_expr     (tree, tree);\n extern tree build_x_indirect_ref\t\tPARAMS ((tree, const char *));\n extern tree build_indirect_ref\t\t\tPARAMS ((tree, const char *));\n extern tree build_array_ref\t\t\tPARAMS ((tree, tree));\n@@ -4321,6 +4316,7 @@ extern tree check_return_expr                   PARAMS ((tree));\n   build_binary_op(code, arg1, arg2, 1)\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n #define cxx_alignof(T) cxx_sizeof_or_alignof_type (T, ALIGNOF_EXPR, true)\n+extern tree build_ptrmemfunc_access_expr       (tree, tree);\n \n /* in typeck2.c */\n extern void cxx_incomplete_type_diagnostic\tPARAMS ((tree, tree, int));"}, {"sha": "fcf7e4536817e28a4007e4fdf0360cf64ff613aa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -10001,6 +10001,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    next = 0;\n \t    break;\n \n+\t  case BASELINK:\n+\t    next = &BASELINK_FUNCTIONS (decl);\n+\t    break;\n+\t    \n \t  default:\n \t    internal_error (\"`%D' as declarator\", decl);\n \t  }\n@@ -11133,6 +11137,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  break;\n \n+\tcase BASELINK:\n+\t  declarator = BASELINK_FUNCTIONS (declarator);\n+\t  break;\n+\n \tcase RECORD_TYPE:\n \tcase UNION_TYPE:\n \tcase ENUMERAL_TYPE:"}, {"sha": "bdd854f4d5a7ffb6baf1fd38efa992e50ed7a554", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -3369,17 +3369,8 @@ build_expr_from_tree (t)\n     case COMPONENT_REF:\n       {\n \ttree object = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\ttree field = TREE_OPERAND (t, 1);\n-\t\n-\t/* We use a COMPONENT_REF to indicate things of the form `x.b'\n-\t   and `x.A::b'.  We must distinguish between those cases\n-\t   here.  */\n-\tif (TREE_CODE (field) == SCOPE_REF)\n-\t  return build_object_ref (object, \n-\t\t\t\t   TREE_OPERAND (field, 0),\n-\t\t\t\t   TREE_OPERAND (field, 1));\n-\telse\n-\t  return build_x_component_ref (object, field, NULL_TREE);\n+\treturn finish_class_member_access_expr (object, \n+\t\t\t\t\t\tTREE_OPERAND (t, 1));\n       }\n \n     case THROW_EXPR:\n@@ -4283,6 +4274,8 @@ arg_assoc (k, n)\n     n = TREE_OPERAND (n, 1);\n   while (TREE_CODE (n) == TREE_LIST)\n     n = TREE_VALUE (n);\n+  if (TREE_CODE (n) == BASELINK)\n+    n = BASELINK_FUNCTIONS (n);\n \n   if (TREE_CODE (n) == FUNCTION_DECL)\n     return arg_assoc_type (k, TREE_TYPE (n));\n@@ -4647,6 +4640,13 @@ do_class_using_decl (decl)\n     }\n   if (TREE_CODE (name) == TYPE_DECL || TREE_CODE (name) == TEMPLATE_DECL)\n     name = DECL_NAME (name);\n+  else if (BASELINK_P (name))\n+    {\n+      name = BASELINK_FUNCTIONS (name);\n+      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\tname = TREE_OPERAND (name, 0);\n+      name = DECL_NAME (get_first_fn (name));\n+    }\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n "}, {"sha": "b6caac7d7892e84c8a61bb2f541b0e16bc096757", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -990,6 +990,10 @@ dump_decl (t, flags)\n       print_tree_identifier (scratch_buffer, DECL_NAME (t));\n       break;\n \n+    case BASELINK:\n+      dump_decl (BASELINK_FUNCTIONS (t), flags);\n+      break;\n+\n     default:\n       sorry_for_unsupported_tree (t);\n       /* Fallthrough to error.  */\n@@ -1826,7 +1830,7 @@ dump_expr (t, flags)\n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n \t{\n-\t  tree idx = build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n+\t  tree idx = build_ptrmemfunc_access_expr (t, pfn_identifier);\n \n \t  if (integer_zerop (idx))\n \t    {"}, {"sha": "4b8b5ee85039b7049ace5e80f3187ea4d10aa83e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -174,17 +174,13 @@ static int\n dtor_nothrow (type)\n      tree type;\n {\n-  tree fn;\n-\n   if (type == NULL_TREE)\n     return 0;\n \n   if (! TYPE_HAS_DESTRUCTOR (type))\n     return 1;\n \n-  fn = lookup_member (type, dtor_identifier, 0, 0);\n-  fn = TREE_VALUE (fn);\n-  return TREE_NOTHROW (fn);\n+  return TREE_NOTHROW (CLASSTYPE_DESTRUCTORS (type));\n }\n \n /* Build up a call to __cxa_end_catch, to destroy the exception object\n@@ -753,7 +749,7 @@ build_throw (exp)\n \t{\n \t  cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n \t\t\t\t     complete_dtor_identifier, 0);\n-\t  cleanup = TREE_VALUE (cleanup);\n+\t  cleanup = BASELINK_FUNCTIONS (cleanup);\n \t  mark_used (cleanup);\n \t  cxx_mark_addressable (cleanup);\n \t  /* Pretend it's a normal function.  */"}, {"sha": "737cd9c15c11c111824f32d04882b3b0ddf8d06e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -232,8 +232,9 @@ perform_member_init (member, init, explicit)\n   tree decl;\n   tree type = TREE_TYPE (member);\n \n-  decl = build_component_ref (current_class_ref, member, NULL_TREE, explicit);\n-\n+  decl = build_class_member_access_expr (current_class_ref, member,\n+\t\t\t\t\t /*access_path=*/NULL_TREE,\n+\t\t\t\t\t /*preserve_reference=*/true);\n   if (decl == error_mark_node)\n     return;\n \n@@ -305,8 +306,9 @@ perform_member_init (member, init, explicit)\n     {\n       tree expr;\n \n-      expr = build_component_ref (current_class_ref, member, NULL_TREE,\n-\t\t\t\t  explicit);\n+      expr = build_class_member_access_expr (current_class_ref, member,\n+\t\t\t\t\t     /*access_path=*/NULL_TREE,\n+\t\t\t\t\t     /*preserve_reference=*/false);\n       expr = build_delete (type, expr, sfk_complete_destructor,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n@@ -1668,10 +1670,15 @@ build_offset_ref (type, name)\n \n   decl = maybe_dummy_object (type, &basebinfo);\n \n-  member = lookup_member (basebinfo, name, 1, 0);\n-\n-  if (member == error_mark_node)\n-    return error_mark_node;\n+  if (BASELINK_P (name))\n+    member = name;\n+  else\n+    {\n+      member = lookup_member (basebinfo, name, 1, 0);\n+      \n+      if (member == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n   /* A lot of this logic is now handled in lookup_member.  */\n   if (member && BASELINK_P (member))\n@@ -1703,7 +1710,7 @@ build_offset_ref (type, name)\n \t  return t;\n \t}\n \n-      if (!really_overloaded_fn (t))\n+      if (TREE_CODE (t) != TEMPLATE_ID_EXPR && !really_overloaded_fn (t))\n \t{\n \t  /* Get rid of a potential OVERLOAD around it */\n \t  t = OVL_CURRENT (t);\n@@ -1848,7 +1855,9 @@ resolve_offset_ref (exp)\n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n \tbase = build_scoped_ref (base, TYPE_OFFSET_BASETYPE (type), &binfo);\n \n-      return build_component_ref (base, member, binfo, 1);\n+      return build_class_member_access_expr (base, member,\n+\t\t\t\t\t     /*access_path=*/NULL_TREE,\n+\t\t\t\t\t     /*preserve_reference=*/false);\n     }\n \n   /* Ensure that we have an object.  */\n@@ -3332,9 +3341,10 @@ push_base_cleanups ()\n \tcontinue;\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n \t{\n-\t  tree this_member = (build_component_ref\n-\t\t\t      (current_class_ref, DECL_NAME (member),\n-\t\t\t       NULL_TREE, 0));\n+\t  tree this_member = (build_class_member_access_expr \n+\t\t\t      (current_class_ref, member, \n+\t\t\t       /*access_path=*/NULL_TREE,\n+\t\t\t       /*preserve_reference=*/false));\n \t  tree this_type = TREE_TYPE (member);\n \t  expr = build_delete (this_type, this_member,\n \t\t\t       sfk_complete_destructor,"}, {"sha": "5fa7433c8609ed0aa952f4e2a87d6ef38337b028", "filename": "gcc/cp/method.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -161,12 +161,26 @@ hack_identifier (value, name)\n \t  return error_mark_node;\n \t}\n       TREE_USED (current_class_ptr) = 1;\n+      if (processing_template_decl)\n+\tvalue = build_min_nt (COMPONENT_REF, current_class_ref, name);\n+      else\n+\t{\n+\t  tree access_type = current_class_type;\n+\t  \n+\t  while (!DERIVED_FROM_P (context_for_name_lookup (value), \n+\t\t\t\t  access_type))\n+\t    {\n+\t      access_type = TYPE_CONTEXT (access_type);\n+\t      while (DECL_P (access_type))\n+\t\taccess_type = DECL_CONTEXT (access_type);\n+\t    }\n \n-      /* Mark so that if we are in a constructor, and then find that\n-\t this field was initialized by a base initializer,\n-\t we can emit an error message.  */\n-      TREE_USED (value) = 1;\n-      value = build_component_ref (current_class_ref, name, NULL_TREE, 1);\n+\t  enforce_access (access_type, value);\n+\t  value \n+\t    = build_class_member_access_expr (current_class_ref, value,\n+\t\t\t\t\t      /*access_path=*/NULL_TREE,\n+\t\t\t\t\t      /*preserve_reference=*/false);\n+\t}\n     }\n   else if ((TREE_CODE (value) == FUNCTION_DECL\n \t    && DECL_FUNCTION_MEMBER_P (value))\n@@ -179,7 +193,7 @@ hack_identifier (value, name)\n \tvalue = OVL_CURRENT (value);\n \n       decl = maybe_dummy_object (DECL_CONTEXT (value), 0);\n-      value = build_component_ref (decl, name, NULL_TREE, 1);\n+      value = finish_class_member_access_expr (decl, name);\n     }\n   else if (really_overloaded_fn (value))\n     ;"}, {"sha": "01181d73b4c313ffd255e54a056ff2cd39ebe92b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1520,11 +1520,11 @@ notype_unqualified_id:\n \n do_id:\n \t\t{\n-\t\t  /* If lastiddecl is a TREE_LIST, it's a baselink, which\n-\t\t     means that we're in an expression like S::f<int>, so\n-\t\t     don't do_identifier; we only do that for unqualified\n+\t\t  /* If lastiddecl is a BASELINK we're in an\n+\t\t     expression like S::f<int>, so don't\n+\t\t     do_identifier; we only do that for unqualified\n \t\t     identifiers.  */\n-\t          if (!lastiddecl || TREE_CODE (lastiddecl) != TREE_LIST)\n+\t          if (!lastiddecl || !BASELINK_P (lastiddecl))\n \t\t    $$ = do_identifier ($<ttype>-1, 1, NULL_TREE);\n \t\t  else\n \t\t    $$ = $<ttype>-1;\n@@ -1718,20 +1718,15 @@ primary:\n \t| overqualified_id LEFT_RIGHT\n \t\t{ $$ = parse_finish_call_expr ($1, NULL_TREE, 0); }\n         | object object_template_id %prec UNARY\n-                {\n-\t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE);\n-\t\t}\n+                { $$ = finish_class_member_access_expr ($$, $2); }\n         | object object_template_id '(' nonnull_exprlist ')'\n                 { $$ = finish_object_call_expr ($2, $1, $4); }\n \t| object object_template_id LEFT_RIGHT\n                 { $$ = finish_object_call_expr ($2, $1, NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n-\t\t{ $$ = build_x_component_ref ($$, $2, NULL_TREE); }\n+\t\t{ $$ = finish_class_member_access_expr ($$, $2); }\n \t| object overqualified_id  %prec UNARY\n-\t\t{ if (processing_template_decl)\n-\t\t    $$ = build_min_nt (COMPONENT_REF, $1, $2);\n-\t\t  else\n-\t\t    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n+                { $$ = finish_class_member_access_expr ($1, $2); }\n \t| object unqualified_id '(' nonnull_exprlist ')'\n                 { $$ = finish_object_call_expr ($2, $1, $4); }\n \t| object unqualified_id LEFT_RIGHT\n@@ -4147,14 +4142,20 @@ parse_finish_call_expr (tree fn, tree args, int koenig)\n \t      else \n \t\ttemplate_id = NULL_TREE;\n \n-\t      if (TREE_CODE (name) == OVERLOAD)\n-\t\tname = DECL_NAME (get_first_fn (name));\n-\t      fn = lookup_member (scope, name, /*protect=*/1, \n-\t\t\t\t  /*prefer_type=*/0);\n-\t      if (BASELINK_P (fn) && template_id)\n-\t\tBASELINK_FUNCTIONS (fn) = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t\t\t\t    BASELINK_FUNCTIONS (fn),\n-\t\t\t\t\t\t    template_args);\n+\t      if (BASELINK_P (name))\n+\t\tfn = name;\n+\t      else \n+\t\t{\n+\t\t  if (TREE_CODE (name) == OVERLOAD)\n+\t\t    name = DECL_NAME (get_first_fn (name));\n+\t\t  fn = lookup_member (scope, name, /*protect=*/1, \n+\t\t\t\t      /*prefer_type=*/0);\n+\t\t  if (BASELINK_P (fn) && template_id)\n+\t\t    BASELINK_FUNCTIONS (fn) \n+\t\t      = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t\t  BASELINK_FUNCTIONS (fn),\n+\t\t\t\t  template_args);\n+\t\t}\n \t      if (BASELINK_P (fn) \n \t\t  && current_class_type \n \t\t  && DERIVED_FROM_P (scope, current_class_type))\n@@ -4216,9 +4217,19 @@ parse_finish_call_expr (tree fn, tree args, int koenig)\n \n \t      if (DERIVED_FROM_P (scope, current_class_type)\n \t\t  && current_class_ref)\n-\t\treturn finish_object_call_expr (fn,\n-\t\t\t\t\t\tcurrent_class_ref,\n-\t\t\t\t\t\targs);\n+\t\t{\n+\t\t  fn = build_baselink (lookup_base (current_class_type,\n+\t\t\t\t\t\t    scope,\n+\t\t\t\t\t\t    ba_any,\n+\t\t\t\t\t\t    NULL),\n+\t\t\t\t       TYPE_BINFO (current_class_type),\n+\t\t\t\t       fn,\n+\t\t\t\t       /*optype=*/NULL_TREE);\n+\t\t  return finish_object_call_expr (fn,\n+\t\t\t\t\t\t  current_class_ref,\n+\t\t\t\t\t\t  args);\n+\t\t}\n+\n \n \t      access_scope = current_class_type;\n \t      while (!DERIVED_FROM_P (scope, access_scope))"}, {"sha": "af698747292755d229c485ebbc6f58f192c23698", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -3833,10 +3833,20 @@ lookup_template_function (fns, arglist)\n \n   my_friendly_assert (TREE_CODE (fns) == TEMPLATE_DECL\n \t\t      || TREE_CODE (fns) == OVERLOAD\n+\t\t      || BASELINK_P (fns)\n \t\t      || TREE_CODE (fns) == IDENTIFIER_NODE\n \t\t      || TREE_CODE (fns) == LOOKUP_EXPR,\n \t\t      20020730);\n \n+  if (BASELINK_P (fns))\n+    {\n+      BASELINK_FUNCTIONS (fns) = build (TEMPLATE_ID_EXPR,\n+\t\t\t\t\tunknown_type_node,\n+\t\t\t\t\tBASELINK_FUNCTIONS (fns),\n+\t\t\t\t\targlist);\n+      return fns;\n+    }\n+\n   type = TREE_TYPE (fns);\n   if (TREE_CODE (fns) == OVERLOAD || !type)\n     type = unknown_type_node;\n@@ -8193,8 +8203,8 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n     arg = TREE_OPERAND (arg, 1);\n \n   /* Strip baselink information.  */\n-  while (TREE_CODE (arg) == TREE_LIST)\n-    arg = TREE_VALUE (arg);\n+  if (BASELINK_P (arg))\n+    arg = BASELINK_FUNCTIONS (arg);\n \n   if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n     {"}, {"sha": "071a551fbe36b929f18a83d12fd2b8c9bb0c2ec6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -300,8 +300,10 @@ lookup_base_r (binfo, base, access, within_current_scope,\n    canonical).  If KIND_PTR is non-NULL, fill with information about\n    what kind of base we discovered.\n \n-   If ba_quiet bit is set in ACCESS, then do not issue an error, and\n-   return NULL_TREE for failure.  */\n+   If the base is inaccessible, or ambiguous, and the ba_quiet bit is\n+   not set in ACCESS, then an error is issued and error_mark_node is\n+   returned.  If the ba_quiet bit is set, then no error is issued and\n+   NULL_TREE is returned.  */\n \n tree\n lookup_base (t, base, access, kind_ptr)\n@@ -1385,9 +1387,10 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n \t\t      || TREE_CODE (functions) == OVERLOAD,\n \t\t      20020730);\n   my_friendly_assert (!optype || TYPE_P (optype), 20020730);\n+  my_friendly_assert (TREE_TYPE (functions), 20020805);\n \n-  baselink = build_tree_list (NULL_TREE, NULL_TREE);\n-  SET_BASELINK_P (baselink);\n+  baselink = build (BASELINK, TREE_TYPE (functions), NULL_TREE,\n+\t\t    NULL_TREE, NULL_TREE);\n   BASELINK_BINFO (baselink) = binfo;\n   BASELINK_ACCESS_BINFO (baselink) = access_binfo;\n   BASELINK_FUNCTIONS (baselink) = functions;\n@@ -1522,7 +1525,7 @@ lookup_field (xbasetype, name, protect, want_type)\n   tree rval = lookup_member (xbasetype, name, protect, want_type);\n   \n   /* Ignore functions.  */\n-  if (rval && TREE_CODE (rval) == TREE_LIST)\n+  if (rval && BASELINK_P (rval))\n     return NULL_TREE;\n \n   return rval;\n@@ -1539,7 +1542,7 @@ lookup_fnfields (xbasetype, name, protect)\n   tree rval = lookup_member (xbasetype, name, protect, /*want_type=*/0);\n \n   /* Ignore non-functions.  */\n-  if (rval && TREE_CODE (rval) != TREE_LIST)\n+  if (rval && !BASELINK_P (rval))\n     return NULL_TREE;\n \n   return rval;\n@@ -2436,7 +2439,7 @@ setup_class_bindings (name, type_binding_p)\n \t{\n \t  if (BASELINK_P (value_binding))\n \t    /* NAME is some overloaded functions.  */\n-\t    value_binding = TREE_VALUE (value_binding);\n+\t    value_binding = BASELINK_FUNCTIONS (value_binding);\n \t  pushdecl_class_level (value_binding);\n \t}\n     }"}, {"sha": "a1b34d75c7852e2bc231105d4b8b0ab510aa8e08", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1400,7 +1400,10 @@ finish_object_call_expr (fn, object, args)\n \t}\n     }\n   \n-  return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n+  if (name_p (fn))\n+    return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n+  else\n+    return build_new_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n }\n \n /* Finish a qualified member function call using OBJECT and ARGS as"}, {"sha": "efeae64a71122a4fbaa940e7d271f7e3939d1048", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -595,8 +595,8 @@ identifier_type (decl)\n   if (looking_for_template && really_overloaded_fn (decl))\n     {\n       /* See through a baselink.  */\n-      if (TREE_CODE (decl) == TREE_LIST)\n-\tdecl = TREE_VALUE (decl);\n+      if (TREE_CODE (decl) == BASELINK)\n+\tdecl = BASELINK_FUNCTIONS (decl);\n \n       for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n \tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t)))"}, {"sha": "ef870765fe8e36a48605162c723946cb3ca584a8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -964,7 +964,7 @@ really_overloaded_fn (x)\n   if (BASELINK_P (x))\n     x = BASELINK_FUNCTIONS (x);\n   return (TREE_CODE (x) == OVERLOAD \n-\t  && (TREE_CHAIN (x) != NULL_TREE\n+\t  && (OVL_CHAIN (x)\n \t      || DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (x))));\n }\n \n@@ -2446,8 +2446,8 @@ cxx_unsave_expr_now (tp)\n }\n \n /* Returns the kind of special function that DECL (a FUNCTION_DECL)\n-   is.  Note that this sfk_none is zero, so this function can be used\n-   as a predicate to test whether or not DECL is a special function.  */\n+   is.  Note that sfk_none is zero, so this function can be used as a\n+   predicate to test whether or not DECL is a special function.  */\n \n special_function_kind\n special_function_p (decl)\n@@ -2476,6 +2476,22 @@ special_function_p (decl)\n   return sfk_none;\n }\n \n+/* Returns true if and only if NODE is a name, i.e., a node created\n+   by the parser when processing an id-expression.  */\n+\n+bool\n+name_p (tree node)\n+{\n+  if (TREE_CODE (node) == TEMPLATE_ID_EXPR)\n+    node = TREE_OPERAND (node, 0);\n+  return (/* An ordinary unqualified name.  */\n+\t  TREE_CODE (node) == IDENTIFIER_NODE\n+\t  /* A destructor name.  */\n+\t  || TREE_CODE (node) == BIT_NOT_EXPR\n+\t  /* A qualified name.  */\n+\t  || TREE_CODE (node) == SCOPE_REF);\n+}\n+\n /* Returns non-zero if TYPE is a character type, including wchar_t.  */\n \n int"}, {"sha": "6ac38224a248ea8455861f14de514575e1419e73", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 352, "deletions": 327, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1758,45 +1758,6 @@ string_conv_p (totype, exp, warn)\n \n   return 1;\n }\n-\f\n-tree\n-build_object_ref (datum, basetype, field)\n-     tree datum, basetype, field;\n-{\n-  tree dtype;\n-  if (datum == error_mark_node)\n-    return error_mark_node;\n-\n-  dtype = TREE_TYPE (datum);\n-  if (TREE_CODE (dtype) == REFERENCE_TYPE)\n-    dtype = TREE_TYPE (dtype);\n-  if (! IS_AGGR_TYPE_CODE (TREE_CODE (dtype)))\n-    {\n-      error (\"request for member `%T::%D' in expression of non-aggregate type `%T'\",\n-\t\tbasetype, field, dtype);\n-      return error_mark_node;\n-    }\n-  else if (is_aggr_type (basetype, 1))\n-    {\n-      tree binfo = NULL_TREE;\n-      datum = build_scoped_ref (datum, basetype, &binfo);\n-      return build_x_component_ref (datum, field, binfo);\n-    }\n-  return error_mark_node;\n-}\n-\n-/* Like `build_component_ref, but uses an already found field, and converts\n-   from a reference.  Must compute access for current_class_ref.\n-   Otherwise, ok.  */\n-\n-tree\n-build_component_ref_1 (datum, field, protect)\n-     tree datum, field;\n-     int protect;\n-{\n-  return convert_from_reference\n-    (build_component_ref (datum, field, NULL_TREE, protect));\n-}\n \n /* Given a COND_EXPR, MIN_EXPR, or MAX_EXPR in T, return it in a form that we\n    can, for example, use as an lvalue.  This code used to be in\n@@ -1868,342 +1829,406 @@ lookup_anon_field (t, type)\n   return NULL_TREE;\n }\n \n-/* Build a COMPONENT_REF for a given DATUM, and it's member COMPONENT.\n-   COMPONENT can be an IDENTIFIER_NODE that is the name of the member\n-   that we are interested in, or it can be a FIELD_DECL.  */\n+/* Build an expression representing OBJECT.MEMBER.  OBJECT is an\n+   expression; MEMBER is a DECL or baselink.  If ACCESS_PATH is\n+   non-NULL, it indicates the path to the base used to name MEMBER.\n+   If PRESERVE_REFERENCE is true, the expression returned will have\n+   REFERENCE_TYPE if the MEMBER does.  Otherwise, the expression\n+   returned will have the type referred to by the reference. \n+\n+   This function does not perform access control; that is either done\n+   earlier by the parser when the name of MEMBER is resolved to MEMBER\n+   itself, or later when overload resolution selects one of the\n+   functions indicated by MEMBER.  */\n \n tree\n-build_component_ref (datum, component, basetype_path, protect)\n-     tree datum, component, basetype_path;\n-     int protect;\n+build_class_member_access_expr (tree object, tree member, \n+\t\t\t\ttree access_path, bool preserve_reference)\n {\n-  register tree basetype;\n-  register enum tree_code code;\n-  register tree field = NULL;\n-  register tree ref;\n-  tree field_type;\n-  int type_quals;\n-  tree old_datum;\n-  tree old_basetype;\n+  tree object_type;\n+  tree member_scope;\n+  tree result = NULL_TREE;\n \n-  if (processing_template_decl)\n-    return build_min_nt (COMPONENT_REF, datum, component);\n-  \n-  if (datum == error_mark_node \n-      || TREE_TYPE (datum) == error_mark_node)\n+  if (object == error_mark_node || member == error_mark_node)\n     return error_mark_node;\n \n-  /* BASETYPE holds the type of the class containing the COMPONENT.  */\n-  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n-    \n-  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference\n-     inside it.  */\n-  switch (TREE_CODE (datum))\n-    {\n-    case COMPOUND_EXPR:\n-      {\n-\ttree value = build_component_ref (TREE_OPERAND (datum, 1), component,\n-\t\t\t\t\t  basetype_path, protect);\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t      TREE_OPERAND (datum, 0), value);\n-      }\n-    case COND_EXPR:\n-      return build_conditional_expr\n-\t(TREE_OPERAND (datum, 0),\n-\t build_component_ref (TREE_OPERAND (datum, 1), component,\n-\t\t\t      basetype_path, protect),\n-\t build_component_ref (TREE_OPERAND (datum, 2), component,\n-\t\t\t      basetype_path, protect));\n-\n-    case TEMPLATE_DECL:\n-      error (\"invalid use of `%D'\", datum);\n-      datum = error_mark_node;\n-      break;\n-\n-    default:\n-      break;\n-    }\n+  my_friendly_assert (DECL_P (member) || BASELINK_P (member),\n+\t\t      20020801);\n \n-  code = TREE_CODE (basetype);\n+  /* [expr.ref]\n \n-  if (code == REFERENCE_TYPE)\n-    {\n-      datum = convert_from_reference (datum);\n-      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n-      code = TREE_CODE (basetype);\n-    }\n-  if (TREE_CODE (datum) == OFFSET_REF)\n+     The type of the first expression shall be \"class object\" (of a\n+     complete type).  */\n+  object_type = TREE_TYPE (object);\n+  if (!complete_type_or_else (object_type, object))\n+    return error_mark_node;\n+  if (!CLASS_TYPE_P (object_type))\n     {\n-      datum = resolve_offset_ref (datum);\n-      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n-      code = TREE_CODE (basetype);\n+      error (\"request for member `%D' in `%E', which is of non-class type `%T'\", \n+\t     member, object, object_type);\n+      return error_mark_node;\n     }\n \n-  /* First, see if there is a field or component with name COMPONENT.  */\n-  if (TREE_CODE (component) == TREE_LIST)\n+  /* The standard does not seem to actually say that MEMBER must be a\n+     member of OBJECT_TYPE.  However, that is clearly what is\n+     intended.  */\n+  if (DECL_P (member))\n     {\n-      /* I could not trigger this code. MvL */\n-      abort ();\n-#ifdef DEAD\n-      my_friendly_assert (!(TREE_CHAIN (component) == NULL_TREE\n-\t\t&& DECL_CHAIN (TREE_VALUE (component)) == NULL_TREE), 309);\n-#endif\n-      return build (COMPONENT_REF, TREE_TYPE (component), datum, component);\n+      member_scope = DECL_CLASS_CONTEXT (member);\n+      mark_used (member);\n+      if (TREE_DEPRECATED (member))\n+\twarn_deprecated_use (member);\n+    }\n+  else\n+    member_scope = BINFO_TYPE (BASELINK_BINFO (member));\n+  /* If MEMBER is from an anonymous aggregate, MEMBER_SCOPE will\n+     presently be the anonymous union.  Go outwards until we find a\n+     type related to OBJECT_TYPE.  */\n+  while (ANON_AGGR_TYPE_P (member_scope)\n+\t && !same_type_ignoring_top_level_qualifiers_p (member_scope,\n+\t\t\t\t\t\t\tobject_type))\n+    member_scope = TYPE_CONTEXT (member_scope);\n+  if (!member_scope || !DERIVED_FROM_P (member_scope, object_type))\n+    {\n+      error (\"`%D' is not a member of `%T'\", member, object_type);\n+      return error_mark_node;\n     }\n \n-  if (! IS_AGGR_TYPE_CODE (code))\n+  /* In [expr.ref], there is an explicit list of the valid choices for\n+     MEMBER.  We check for each of those cases here.  */\n+  if (TREE_CODE (member) == VAR_DECL)\n     {\n-      if (code != ERROR_MARK)\n-\terror (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n-\t\t  component, datum, basetype);\n-      return error_mark_node;\n+      /* A static data member.  */\n+      result = member;\n+      /* If OBJECT has side-effects, they are supposed to occur.  */\n+      if (TREE_SIDE_EFFECTS (object))\n+\tresult = build (COMPOUND_EXPR, TREE_TYPE (result), object, result);\n     }\n+  else if (TREE_CODE (member) == FIELD_DECL)\n+    {\n+      /* A non-static data member.  */\n+      bool null_object_p;\n+      int type_quals;\n+      tree member_type;\n \n-  if (!complete_type_or_else (basetype, datum))\n-    return error_mark_node;\n+      null_object_p = (TREE_CODE (object) == INDIRECT_REF\n+\t\t       && integer_zerop (TREE_OPERAND (object, 0)));\n \n-  if (TREE_CODE (component) == BIT_NOT_EXPR)\n-    {\n-      if (TYPE_IDENTIFIER (basetype) != TREE_OPERAND (component, 0))\n+      /* Convert OBJECT to the type of MEMBER.  */\n+      if (!same_type_p (object_type, member_scope))\n \t{\n-\t  error (\"destructor specifier `%T::~%T' must have matching names\",\n-\t\t    basetype, TREE_OPERAND (component, 0));\n-\t  return error_mark_node;\n+\t  tree binfo;\n+\t  base_kind kind;\n+\n+\t  binfo = lookup_base (access_path ? access_path : object_type,\n+\t\t\t       member_scope, ba_ignore,  &kind);\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  /* It is invalid to use to try to get to a virtual base of a\n+\t     NULL object.  The most common cause is invalid use of\n+\t     offsetof macro.  */\n+\t  if (null_object_p && kind == bk_via_virtual)\n+\t    {\n+\t      error (\"invalid access to non-static data member `%D' of NULL object\",\n+\t\t     member);\n+\t      error (\"(perhaps the `offsetof' macro was used incorrectly)\");\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  /* Convert to the base.  */\n+\t  object = build_base_path (PLUS_EXPR, object, binfo, \n+\t\t\t\t    /*nonnull=*/1);\n+\t  /* If we found the base successfully then we should be able\n+\t     to convert to it successfully.  */\n+\t  my_friendly_assert (object != error_mark_node,\n+\t\t\t      20020801);\n \t}\n-      if (! TYPE_HAS_DESTRUCTOR (basetype))\n+      \n+      /* Issue a warning about access a member of a NULL object.  */\n+      if (null_object_p && CLASSTYPE_NON_POD_P (object_type))\n \t{\n-\t  error (\"type `%T' has no destructor\", basetype);\n+\t  warning (\"invalid access to non-static data member `%D' of NULL object\", \n+\t\t   member);\n+\t  warning  (\"(perhaps the `offsetof' macro was used incorrectly)\");\n \t  return error_mark_node;\n \t}\n-      return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1);\n-    }\n \n-  /* Look up component name in the structure type definition.  */\n-  if (TYPE_VFIELD (basetype)\n-      && DECL_NAME (TYPE_VFIELD (basetype)) == component)\n-    /* Special-case this because if we use normal lookups in an ambiguous\n-       hierarchy, the compiler will abort (because vptr lookups are\n-       not supposed to be ambiguous.  */\n-    field = TYPE_VFIELD (basetype);\n-  else if (TREE_CODE (component) == FIELD_DECL)\n-    field = component;\n-  else if (TREE_CODE (component) == TYPE_DECL)\n+      /* If MEMBER is from an anonymous aggregate, we have converted\n+\t OBJECT so that it refers to the class containing the\n+\t anonymous union.  Generate a reference to the anonymous union\n+\t itself, and recur to find MEMBER.  */\n+      if (ANON_AGGR_TYPE_P (DECL_CONTEXT (member)))\n+\t{\n+\t  tree anonymous_union;\n+\n+\t  anonymous_union = lookup_anon_field (TREE_TYPE (object),\n+\t\t\t\t\t       DECL_CONTEXT (member));\n+\t  object = build_class_member_access_expr (object,\n+\t\t\t\t\t\t   anonymous_union,\n+\t\t\t\t\t\t   /*access_path=*/NULL_TREE,\n+\t\t\t\t\t\t   preserve_reference);\n+\t}\n+\n+      /* Compute the type of the field, as described in [expr.ref].  */\n+      type_quals = TYPE_UNQUALIFIED;\n+      member_type = TREE_TYPE (member);\n+      if (TREE_CODE (member_type) != REFERENCE_TYPE)\n+\t{\n+\t  type_quals = (cp_type_quals (member_type)  \n+\t\t\t| cp_type_quals (object_type));\n+\t  \n+\t  /* A field is const (volatile) if the enclosing object, or the\n+\t     field itself, is const (volatile).  But, a mutable field is\n+\t     not const, even within a const object.  */\n+\t  if (DECL_MUTABLE_P (member))\n+\t    type_quals &= ~TYPE_QUAL_CONST;\n+\t  member_type = cp_build_qualified_type (member_type, type_quals);\n+\t}\n+\n+      result = fold (build (COMPONENT_REF, member_type, object, member));\n+\n+      /* Mark the expression const or volatile, as appropriate.  Even\n+\t though we've dealt with the type above, we still have to mark the\n+\t expression itself.  */\n+      if (type_quals & TYPE_QUAL_CONST)\n+\tTREE_READONLY (result) = 1;\n+      else if (type_quals & TYPE_QUAL_VOLATILE)\n+\tTREE_THIS_VOLATILE (result) = 1;\n+    }\n+  else if (BASELINK_P (member))\n     {\n-      error (\"invalid use of type decl `%#D' as expression\", component);\n-      return error_mark_node;\n+      /* The member is a (possibly overloaded) member function.  */\n+      tree functions;\n+\n+      /* If the MEMBER is exactly one static member function, then we\n+\t know the type of the expression.  Otherwise, we must wait\n+\t until overload resolution has been performed.  */\n+      functions = BASELINK_FUNCTIONS (member);\n+      if (TREE_CODE (functions) == FUNCTION_DECL\n+\t  && DECL_STATIC_FUNCTION_P (functions))\n+\t{\n+\t  /* A static member function.  */\n+\t  result = functions;\n+\t  mark_used (result);\n+\t  /* If OBJECT has side-effects, they are supposed to occur.  */\n+\t  if (TREE_SIDE_EFFECTS (object))\n+\t    result = build (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t\t    object, result);\n+\t}\n+      else\n+\t/* Note that we do not convert OBJECT to the BASELINK_BINFO\n+\t   base.  That will happen when the function is called.  */\n+\tresult = build (COMPONENT_REF, unknown_type_node, object, member);\n     }\n-  else if (TREE_CODE (component) == TEMPLATE_DECL)\n+  else if (TREE_CODE (member) == CONST_DECL)\n     {\n-      error (\"invalid use of template `%#D' as expression\", component);\n-      return error_mark_node;\n+      /* The member is an enumerator.  */\n+      result = member;\n+      /* If OBJECT has side-effects, they are supposed to occur.  */\n+      if (TREE_SIDE_EFFECTS (object))\n+\tresult = build (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t\tobject, result);\n     }\n   else\n     {\n-      tree name = component;\n-      \n-      if (TREE_CODE (component) == TEMPLATE_ID_EXPR)\n-\tname = TREE_OPERAND (component, 0);\n-      else if (TREE_CODE (component) == VAR_DECL)\n-\tname = DECL_NAME (component);\n-      if (TREE_CODE (component) == NAMESPACE_DECL)\n-        /* Source is in error, but produce a sensible diagnostic.  */\n-        name = DECL_NAME (component);\n-      if (basetype_path == NULL_TREE)\n-\tbasetype_path = TYPE_BINFO (basetype);\n-      field = lookup_field (basetype_path, name,\n-\t\t\t    protect && !VFIELD_NAME_P (name), 0);\n-      if (field == error_mark_node)\n-\treturn error_mark_node;\n+      error (\"invalid use of `%D'\", member);\n+      return error_mark_node;\n+    }\n \n-      if (field == NULL_TREE)\n-\t{\n-\t  /* Not found as a data field, look for it as a method.  If found,\n-\t     then if this is the only possible one, return it, else\n-\t     report ambiguity error.  */\n-\t  tree fndecls = lookup_fnfields (basetype_path, name, 1);\n-\t  if (fndecls == error_mark_node)\n-\t    return error_mark_node;\n-\t  if (fndecls)\n-\t    {\n-\t      /* If the function is unique and static, we can resolve it\n-\t\t now.  Otherwise, we have to wait and see what context it is\n-\t\t used in; a component_ref involving a non-static member\n-\t\t function can only be used in a call (expr.ref).  */\n-\t      \n-\t      if (TREE_CHAIN (fndecls) == NULL_TREE\n-\t\t  && TREE_CODE (TREE_VALUE (fndecls)) == FUNCTION_DECL)\n-\t\t{\n-\t\t  if (DECL_STATIC_FUNCTION_P (TREE_VALUE (fndecls)))\n-\t\t    {\n-\t\t      tree fndecl = TREE_VALUE (fndecls);\n-\t\t      enforce_access (basetype_path, fndecl);\n-\t\t      mark_used (fndecl);\n-\t\t      return fndecl;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* A unique non-static member function.  Other parts\n-\t\t\t of the compiler expect something with\n-\t\t\t unknown_type_node to be really overloaded, so\n-\t\t\t let's oblige.  */\n-\t\t      TREE_VALUE (fndecls)\n-\t\t\t= ovl_cons (TREE_VALUE (fndecls), NULL_TREE);\n-\t\t    }\n-\t\t}\n+  if (!preserve_reference)\n+    /* [expr.ref]\n+       \n+       If E2 is declared to have type \"reference to T\", then ... the\n+       type of E1.E2 is T.  */\n+    result = convert_from_reference (result);\n \n-\t      fndecls = TREE_VALUE (fndecls);\n-\t      \n- \t      if (IDENTIFIER_TYPENAME_P (name))\n- \t\t{\n- \t\t  /* We want for a conversion op. We need to remember\n- \t\t     the actual type we wanted, in case we got a set of\n- \t\t     templated conversion operators back.  */\n- \t\t  fndecls = ovl_cons (OVL_CURRENT (fndecls),\n- \t\t\t\t      OVL_NEXT (fndecls));\n- \t\t  TREE_TYPE (fndecls) = TREE_TYPE (name);\n- \t\t}\n-\t      else if (TREE_CODE (component) == TEMPLATE_ID_EXPR)\n-\t\tfndecls = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t\t    fndecls, TREE_OPERAND (component, 1));\n-\t      \n-\t      ref = build (COMPONENT_REF, unknown_type_node,\n-\t\t\t   datum, fndecls);\n-\t      return ref;\n-\t    }\n+  return result;\n+}\n \n-\t  error (\"`%#T' has no member named `%D'\", basetype, name);\n-\t  return error_mark_node;\n-\t}\n-      else if (TREE_TYPE (field) == error_mark_node)\n-\treturn error_mark_node;\n+/* This function is called by the parser to process a class member\n+   access expression of the form OBJECT.NAME.  NAME is a node used by\n+   the parser to represent a name; it is not yet a DECL.  It may,\n+   however, be a BASELINK where the BASELINK_FUNCTIONS is a\n+   TEMPLATE_ID_EXPR.  Templates must be looked up by the parser, and\n+   there is no reason to do the lookup twice, so the parser keeps the\n+   BASELINK.  */\n \n-      if (TREE_CODE (field) != FIELD_DECL)\n-\t{\n-\t  if (TREE_CODE (field) == TYPE_DECL)\n-\t    pedwarn (\"invalid use of type decl `%#D' as expression\", field);\n-\t  else if (DECL_RTL (field) != 0)\n-\t    mark_used (field);\n-\t  else\n-\t    TREE_USED (field) = 1;\n+tree\n+finish_class_member_access_expr (tree object, tree name)\n+{\n+  tree object_type;\n+  tree member;\n+  tree access_path = NULL_TREE;\n+\n+  if (object == error_mark_node || name == error_mark_node)\n+    return error_mark_node;\n \n-\t  /* Do evaluate the object when accessing a static member.  */\n-\t  if (TREE_SIDE_EFFECTS (datum))\n-\t    field = build (COMPOUND_EXPR, TREE_TYPE (field), datum, field);\n+  if (processing_template_decl)\n+    return build_min_nt (COMPONENT_REF, object, name);\n+  \n+  if (TREE_CODE (object) == OFFSET_REF)\n+    object = resolve_offset_ref (object);\n \n-\t  return field;\n-\t}\n+  object_type = TREE_TYPE (object);\n+  if (TREE_CODE (object_type) == REFERENCE_TYPE)\n+    {\n+      object = convert_from_reference (object);\n+      object_type = TREE_TYPE (object);\n     }\n \n-  if (TREE_DEPRECATED (field))\n-    warn_deprecated_use (field);\n+  /* [expr.ref]\n \n-  old_datum = datum;\n-  old_basetype = basetype;\n+     The type of the first expression shall be \"class object\" (of a\n+     complete type).  */\n+  if (!complete_type_or_else (object_type, object))\n+    return error_mark_node;\n+  if (!CLASS_TYPE_P (object_type))\n+    {\n+      error (\"request for member `%D' in `%E', which is of non-class type `%T'\", \n+\t     name, object, object_type);\n+      return error_mark_node;\n+    }\n \n-  /* See if we have to do any conversions so that we pick up the field from the\n-     right context.  */\n-  if (DECL_FIELD_CONTEXT (field) != basetype)\n+  if (BASELINK_P (name))\n     {\n-      tree context = DECL_FIELD_CONTEXT (field);\n-      tree base = context;\n-      while (!same_type_p (base, basetype) && TYPE_NAME (base)\n-\t     && ANON_AGGR_TYPE_P (base))\n-\tbase = TYPE_CONTEXT (base);\n+      /* A member function that has already been looked up.  */\n+      my_friendly_assert ((TREE_CODE (BASELINK_FUNCTIONS (name)) \n+\t\t\t   == TEMPLATE_ID_EXPR), \n+\t\t\t  20020805);\n+      member = name;\n+    }\n+  else\n+    {\n+      bool is_template_id = false;\n+      tree template_args = NULL_TREE;\n \n-      /* Handle base classes here...  */\n-      if (base != basetype && TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype))\n+      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \t{\n-\t  base_kind kind;\n- \t  tree binfo = lookup_base (TREE_TYPE (datum), base, ba_check, &kind);\n+\t  is_template_id = true;\n+\t  template_args = TREE_OPERAND (name, 1);\n+\t  name = TREE_OPERAND (name, 0);\n+\t}\n \n-\t  /* Complain about use of offsetof which will break.  */\n-\t  if (TREE_CODE (datum) == INDIRECT_REF\n-\t      && integer_zerop (TREE_OPERAND (datum, 0))\n-\t      && kind == bk_via_virtual)\n+      if (TREE_CODE (name) == SCOPE_REF)\n+\t{\n+\t  tree scope;\n+\n+\t  /* A qualified name.  The qualifying class or namespace `S' has\n+\t     already been looked up; it is either a TYPE or a\n+\t     NAMESPACE_DECL.  The member name is either an IDENTIFIER_NODE\n+\t     or a BIT_NOT_EXPR.  */\n+\t  scope = TREE_OPERAND (name, 0);\n+\t  name = TREE_OPERAND (name, 1);\n+\t  my_friendly_assert ((CLASS_TYPE_P (scope) \n+\t\t\t       || TREE_CODE (scope) == NAMESPACE_DECL),\n+\t\t\t      20020804);\n+\t  my_friendly_assert ((TREE_CODE (name) == IDENTIFIER_NODE\n+\t\t\t       || TREE_CODE (name) == BIT_NOT_EXPR),\n+\t\t\t      20020804);\n+\n+\t  /* If SCOPE is a namespace, then the qualified name does not\n+\t     name a member of OBJECT_TYPE.  */\n+\t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n-\t      error (\"\\\n-invalid offsetof from non-POD type `%#T'; use pointer to member instead\",\n-\t\t     basetype);\n+\t      error (\"`%D::%D' is not a member of `%T'\", \n+\t\t     scope, member, object_type);\n \t      return error_mark_node;\n \t    }\n- \t  datum = build_base_path (PLUS_EXPR, datum, binfo, 1);\n-\t  if (datum == error_mark_node)\n+\n+\t  /* Find the base of OBJECT_TYPE corresponding to SCOPE.  */\n+\t  access_path = lookup_base (object_type, scope, ba_check, NULL);\n+\t  if (!access_path || access_path == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  /* Look up the member.  */\n+\t  member = lookup_member (access_path, name, /*protect=*/1, \n+\t\t\t\t  /*want_type=*/0);\n+\t  if (member == error_mark_node)\n \t    return error_mark_node;\n \t}\n-      basetype = base;\n- \n-      /* Handle things from anon unions here...  */\n-      if (TYPE_NAME (context) && ANON_AGGR_TYPE_P (context))\n+      else if (TREE_CODE (name) == BIT_NOT_EXPR)\n+\t{\n+\t  /* A destructor.  */\n+\t  if (TYPE_IDENTIFIER (object_type) != TREE_OPERAND (name, 0))\n+\t    {\n+\t      error (\"destructor specifier `%T::~%T' must have matching names\",\n+\t\t     object_type, TREE_OPERAND (name, 0));\n+\t      return error_mark_node;\n+\t    }\n+\t  if (! TYPE_HAS_DESTRUCTOR (object_type))\n+\t    {\n+\t      error (\"type `%T' has no destructor\", object_type);\n+\t      return error_mark_node;\n+\t    }\n+\t  member = CLASSTYPE_DESTRUCTORS (object_type);\n+\t}\n+      else if (TREE_CODE (name) == IDENTIFIER_NODE)\n \t{\n-\t  tree subfield = lookup_anon_field (basetype, context);\n-\t  tree subdatum = build_component_ref (datum, subfield,\n-\t\t\t\t\t       basetype_path, protect);\n-\t  return build_component_ref (subdatum, field, basetype_path, protect);\n+\t  /* An unqualified name.  */\n+\t  member = lookup_member (object_type, name, /*protect=*/1, \n+\t\t\t\t  /*want_type=*/0);\n+\t  if (member == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  /* The YACC parser sometimes gives us things that are not names.\n+\t     These always indicate errors.  The recursive-descent parser\n+\t     does not do this, so this code can go away once that parser\n+\t     replaces the YACC parser.  */\n+\t  error (\"invalid use of `%D'\", name);\n+\t  return error_mark_node;\n+\t}\n+      \n+      if (is_template_id)\n+\t{\n+\t  tree template = member;\n+\t  \n+\t  if (BASELINK_P (template))\n+\t    BASELINK_FUNCTIONS (template) \n+\t      = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t  BASELINK_FUNCTIONS (template),\n+\t\t\t  template_args);\n+\t  else\n+\t    {\n+\t      error (\"`%D' is not a member template function\", name);\n+\t      return error_mark_node;\n+\t    }\n \t}\n     }\n \n-  /* Complain about other invalid uses of offsetof, even though they will\n-     give the right answer.  Note that we complain whether or not they\n-     actually used the offsetof macro, since there's no way to know at this\n-     point.  So we just give a warning, instead of a pedwarn.  */\n-  if (protect\n-      && CLASSTYPE_NON_POD_P (old_basetype)\n-      && TREE_CODE (old_datum) == INDIRECT_REF\n-      && integer_zerop (TREE_OPERAND (old_datum, 0)))\n-    warning (\"\\\n-invalid offsetof from non-POD type `%#T'; use pointer to member instead\",\n-\t     basetype);\n-\n-  /* Compute the type of the field, as described in [expr.ref].  */\n-  type_quals = TYPE_UNQUALIFIED;\n-  field_type = TREE_TYPE (field);\n-  if (TREE_CODE (field_type) == REFERENCE_TYPE)\n-    /* The standard says that the type of the result should be the\n-       type referred to by the reference.  But for now, at least, we\n-       do the conversion from reference type later.  */\n-    ;\n-  else\n-    {\n-      type_quals = (cp_type_quals (field_type)  \n-\t\t    | cp_type_quals (TREE_TYPE (datum)));\n-\n-      /* A field is const (volatile) if the enclosing object, or the\n-\t field itself, is const (volatile).  But, a mutable field is\n-\t not const, even within a const object.  */\n-      if (DECL_MUTABLE_P (field))\n-\ttype_quals &= ~TYPE_QUAL_CONST;\n-      field_type = cp_build_qualified_type (field_type, type_quals);\n-    }\n-\n-  ref = fold (build (COMPONENT_REF, field_type, datum, field));\n-\n-  /* Mark the expression const or volatile, as appropriate.  Even\n-     though we've dealt with the type above, we still have to mark the\n-     expression itself.  */\n-  if (type_quals & TYPE_QUAL_CONST)\n-    TREE_READONLY (ref) = 1;\n-  else if (type_quals & TYPE_QUAL_VOLATILE)\n-    TREE_THIS_VOLATILE (ref) = 1;\n-\n-  return ref;\n+  return build_class_member_access_expr (object, member, access_path,\n+\t\t\t\t\t /*preserve_reference=*/false);\n }\n \n-/* Variant of build_component_ref for use in expressions, which should\n-   never have REFERENCE_TYPE.  */\n+/* Return an expression for the MEMBER_NAME field in the internal\n+   representation of PTRMEM, a pointer-to-member function.  (Each\n+   pointer-to-member function type gets its own RECORD_TYPE so it is\n+   more convenient to access the fields by name than by FIELD_DECL.)\n+   This routine converts the NAME to a FIELD_DECL and then creates the\n+   node for the complete expression.  */\n \n tree\n-build_x_component_ref (datum, component, basetype_path)\n-     tree datum, component, basetype_path;\n+build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n {\n-  tree t = build_component_ref (datum, component, basetype_path, \n-\t\t\t\t/*protect=*/1);\n-\n-  if (! processing_template_decl)\n-    t = convert_from_reference (t);\n-\n-  return t;\n+  tree ptrmem_type;\n+  tree member;\n+  tree member_type;\n+\n+  /* This code is a stripped down version of\n+     build_class_member_access_expr.  It does not work to use that\n+     routine directly because it expects the object to be of class\n+     type.  */\n+  ptrmem_type = TREE_TYPE (ptrmem);\n+  my_friendly_assert (TYPE_PTRMEMFUNC_P (ptrmem_type), 20020804);\n+  member = lookup_member (ptrmem_type, member_name, /*protect=*/0,\n+\t\t\t  /*want_type=*/0);\n+  member_type = cp_build_qualified_type (TREE_TYPE (member),\n+\t\t\t\t\t cp_type_quals (ptrmem_type));\n+  return fold (build (COMPONENT_REF, member_type, ptrmem, member));\n }\n-\f\n+\n /* Given an expression PTR for a pointer, return an expression\n    for the value pointed to.\n    ERRORSTRING is the name of the operator to appear in error messages.\n@@ -2505,7 +2530,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n       /* Start by extracting all the information from the PMF itself.  */\n       e3 = PFN_FROM_PTRMEMFUNC (function);\n-      delta = build_component_ref (function, delta_identifier, NULL_TREE, 0);\n+      delta = build_ptrmemfunc_access_expr (function, delta_identifier);\n       idx = build1 (NOP_EXPR, vtable_index_type, e3);\n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n@@ -3219,7 +3244,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n-\t  op0 = build_component_ref (op0, pfn_identifier, NULL_TREE, 0);\n+\t  op0 = build_ptrmemfunc_access_expr (op0, pfn_identifier);\n \t  op1 = cp_convert (TREE_TYPE (op0), integer_zero_node);\n \t  result_type = TREE_TYPE (op0);\n \t}\n@@ -3253,10 +3278,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     DELTA field is unspecified.  */\n \t  pfn0 = pfn_from_ptrmemfunc (op0);\n \t  pfn1 = pfn_from_ptrmemfunc (op1);\n-\t  delta0 = build_component_ref (op0, delta_identifier,\n-\t\t\t\t\tNULL_TREE, 0);\n-\t  delta1 = build_component_ref (op1, delta_identifier,\n-\t\t\t\t\tNULL_TREE, 0);\n+\t  delta0 = build_ptrmemfunc_access_expr (op0,\n+\t\t\t\t\t\t delta_identifier);\n+\t  delta1 = build_ptrmemfunc_access_expr (op1,\n+\t\t\t\t\t\t delta_identifier);\n \t  e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n \t  e2 = cp_build_binary_op (EQ_EXPR, \n \t\t\t\t   pfn0,\n@@ -4191,7 +4216,7 @@ build_unary_op (code, xarg, noconvert)\n \t}\n \n       if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n-          && OVL_NEXT (TREE_OPERAND (arg, 1)) == NULL_TREE)\n+\t  && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n         {\n \t  /* They're trying to take the address of a unique non-static\n \t     member function.  This is ill-formed (except in MS-land),\n@@ -4204,7 +4229,7 @@ build_unary_op (code, xarg, noconvert)\n \t     a useful error here.  */\n \n \t  tree base = TREE_TYPE (TREE_OPERAND (arg, 0));\n-\t  tree name = DECL_NAME (OVL_CURRENT (TREE_OPERAND (arg, 1)));\n+\t  tree name = DECL_NAME (get_first_fn (TREE_OPERAND (arg, 1)));\n \n \t  if (! flag_ms_extensions)\n \t    {\n@@ -5595,8 +5620,8 @@ build_ptrmemfunc (type, pfn, force)\n \texpand_ptrmemfunc_cst (pfn, &delta, &npfn);\n       else\n \t{\n-\t  npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n-\t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n+\t  npfn = build_ptrmemfunc_access_expr (pfn, pfn_identifier);\n+\t  delta = build_ptrmemfunc_access_expr (pfn, delta_identifier);\n \t}\n \n       /* Just adjust the DELTA field.  */\n@@ -5711,7 +5736,7 @@ pfn_from_ptrmemfunc (t)\n \treturn pfn;\n     }\n \n-  return build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n+  return build_ptrmemfunc_access_expr (t, pfn_identifier);\n }\n \n /* Expression EXPR is about to be implicitly converted to TYPE.  Warn"}, {"sha": "e4d7e3eb0a2a429c632655374144073aade1ceaf", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1196,8 +1196,8 @@ build_m_component_ref (datum, component)\n \t\t\t| cp_type_quals (TREE_TYPE (datum)));\n \n \t  /* There's no such thing as a mutable pointer-to-member, so\n-\t     we don't need to deal with that here like we do in\n-\t     build_component_ref.  */\n+\t     things are not as complex as they are for references to\n+\t     non-static data members.  */\n \t  field_type = cp_build_qualified_type (field_type, type_quals);\n \t}\n     }"}, {"sha": "c458f430f887826cb33b7dd1adb4fcef2a1e0bd8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -1,3 +1,8 @@\n+2002-08-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/offsetof.C: Tweak error messages.\n+\t* g++.old-deja/g++.mike/p10769a.C: Likewise.\n+\t\n 2002-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/bitfld-3.c: New test."}, {"sha": "0085e57dd9815e3e9a33c82f0cb3d757b8f261cd", "filename": "gcc/testsuite/g++.dg/abi/offsetof.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Foffsetof.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Foffsetof.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Foffsetof.C?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -18,5 +18,5 @@ struct C: public B { };\n \n int main ()\n {\n-  return ((unsigned long) &((C*)0)->i) != sizeof(void*); // { dg-warning \"offsetof\" \"\" }\n+  return ((unsigned long) &((C*)0)->i) != sizeof(void*); // { dg-warning \"offsetof|invalid\" \"\" }\n }"}, {"sha": "cb49ab7501a0a78f7f032eddd40d6fb7e5f0c2ad", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p10769a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ad96428042fa526d001309059a6187dd9e0d3c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C?ref=50ad96428042fa526d001309059a6187dd9e0d3c", "patch": "@@ -9,7 +9,7 @@ class A {\n public:\n   void f1a() { ok += 3; }\n   void f1b() { ok += 5; }\n-  void f2a() { ok += 7; }\t// gets bogus error XFAIL *-*-*\n+  void f2a() { ok += 7; }\n   void f2b() { }\n   static void (*table[2][2])();\n   void main();"}]}