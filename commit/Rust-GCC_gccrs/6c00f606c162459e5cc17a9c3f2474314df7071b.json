{"sha": "6c00f606c162459e5cc17a9c3f2474314df7071b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMwMGY2MDZjMTYyNDU5ZTVjYzE3YTljM2YyNDc0MzE0ZGY3MDcxYg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-04-27T20:22:17Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-04-27T20:22:17Z"}, "message": "Implement new immediate use iterators.\n\n2006-04-27  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR tree-optimization/26854\n\t* tree-vrp.c (remove_range_assertions): Use new Immuse iterator.\n\t* doc/tree-ssa.texi: Update immuse iterator documentation.\n\t* tree-ssa-math-opts.c (execute_cse_reciprocals_1): Use new iterator.\n\t* tree-ssa-dom.c (propagate_rhs_into_lhs): Use new iterator.\n\t* tree-flow-inline.h (end_safe_imm_use_traverse, end_safe_imm_use_p,\n\tfirst_safe_imm_use, next_safe_imm_use): Remove.\n\t(end_imm_use_stmt_p): New.  Check for end of immuse stmt traversal.\n\t(end_imm_use_stmt_traverse): New.  Terminate immuse stmt traversal.\n\t(move_use_after_head): New.  Helper function to sort immuses in a stmt.\n\t(link_use_stmts_after): New.  Link all immuses in a stmt consescutively.\n\t(first_imm_use_stmt): New.  Get first stmt in an immuse list.\n\t(next_imm_use_stmt): New.  Get next stmt in an immuse list.\n\t(first_imm_use_on_stmt): New.  Get first immuse on a stmt.\n\t(end_imm_use_on_stmt_p): New.  Check for end of immuses on a stmt.\n\t(next_imm_use_on_stmt): New.  Move to next immuse on a stmt.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr): Use new iterator.\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use new iterator.\n\t(perfect_nestify): Use new iterator.\n\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Use new \n\titerator.\n\t* tree-flow.h (struct immediate_use_iterator_d): Add comments.\n\t(next_imm_name): New field in struct immediate_use_iterator_d.\n\t(FOR_EACH_IMM_USE_SAFE, BREAK_FROM_SAFE_IMM_USE): Remove.\n\t(FOR_EACH_IMM_USE_STMT, BREAK_FROM_IMM_USE_STMT, \n\tFOR_EACH_IMM_USE_ON_STMT): New immediate use iterator macros.\n\t* tree-cfg.c (replace_uses_by): Use new iterator.\n\t* tree-ssa-threadedge.c (lhs_of_dominating_assert): Use new iterator.\n\t* tree-ssa-operands.c (correct_use_link): Remove.\n\t(finalize_ssa_use_ops): No longer call correct_use_link.\n\nFrom-SVN: r113321", "tree": {"sha": "39c9b1002df8b0cd95dd8e90404343ea80786b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39c9b1002df8b0cd95dd8e90404343ea80786b25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c00f606c162459e5cc17a9c3f2474314df7071b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c00f606c162459e5cc17a9c3f2474314df7071b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c00f606c162459e5cc17a9c3f2474314df7071b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c00f606c162459e5cc17a9c3f2474314df7071b/comments", "author": null, "committer": null, "parents": [{"sha": "8fcd79cbcdf931c4875a6863fe47482224b1f03d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcd79cbcdf931c4875a6863fe47482224b1f03d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fcd79cbcdf931c4875a6863fe47482224b1f03d"}], "stats": {"total": 633, "additions": 348, "deletions": 285}, "files": [{"sha": "c2f022ac445fb4cdb619168521208745e9cda70c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -1,3 +1,36 @@\n+2006-04-27  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/26854\n+\t* tree-vrp.c (remove_range_assertions): Use new Immuse iterator.\n+\t* doc/tree-ssa.texi: Update immuse iterator documentation.\n+\t* tree-ssa-math-opts.c (execute_cse_reciprocals_1): Use new iterator.\n+\t* tree-ssa-dom.c (propagate_rhs_into_lhs): Use new iterator.\n+\t* tree-flow-inline.h (end_safe_imm_use_traverse, end_safe_imm_use_p,\n+\tfirst_safe_imm_use, next_safe_imm_use): Remove.\n+\t(end_imm_use_stmt_p): New.  Check for end of immuse stmt traversal.\n+\t(end_imm_use_stmt_traverse): New.  Terminate immuse stmt traversal.\n+\t(move_use_after_head): New.  Helper function to sort immuses in a stmt.\n+\t(link_use_stmts_after): New.  Link all immuses in a stmt consescutively.\n+\t(first_imm_use_stmt): New.  Get first stmt in an immuse list.\n+\t(next_imm_use_stmt): New.  Get next stmt in an immuse list.\n+\t(first_imm_use_on_stmt): New.  Get first immuse on a stmt.\n+\t(end_imm_use_on_stmt_p): New.  Check for end of immuses on a stmt.\n+\t(next_imm_use_on_stmt): New.  Move to next immuse on a stmt.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr): Use new iterator.\n+\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use new iterator.\n+\t(perfect_nestify): Use new iterator.\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Use new \n+\titerator.\n+\t* tree-flow.h (struct immediate_use_iterator_d): Add comments.\n+\t(next_imm_name): New field in struct immediate_use_iterator_d.\n+\t(FOR_EACH_IMM_USE_SAFE, BREAK_FROM_SAFE_IMM_USE): Remove.\n+\t(FOR_EACH_IMM_USE_STMT, BREAK_FROM_IMM_USE_STMT, \n+\tFOR_EACH_IMM_USE_ON_STMT): New immediate use iterator macros.\n+\t* tree-cfg.c (replace_uses_by): Use new iterator.\n+\t* tree-ssa-threadedge.c (lhs_of_dominating_assert): Use new iterator.\n+\t* tree-ssa-operands.c (correct_use_link): Remove.\n+\t(finalize_ssa_use_ops): No longer call correct_use_link.\n+\n 2006-04-27  Stuart Hastings  <stuart@apple.com>\n \n \t* config/rs6000/t-darwin (DARWIN_EXTRA_CRT_BUILD_CFLAGS): New."}, {"sha": "016f812fed477458e5f05f17e9de6f9fe5433004", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -1092,37 +1092,48 @@ FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)\n \n Immediate use information is now always available.  Using the immediate use \n iterators, you may examine every use of any @code{SSA_NAME}. For instance,\n-to change each use of @code{ssa_var} to @code{ssa_var2}:\n+to change each use of @code{ssa_var} to @code{ssa_var2} and call fold_stmt on\n+each stmt after that is done:\n \n @smallexample\n   use_operand_p imm_use_p;\n   imm_use_iterator iterator;\n-  tree ssa_var\n+  tree ssa_var, stmt;\n \n-  FOR_EACH_IMM_USE_SAFE (imm_use_p, iterator, ssa_var)\n-    SET_USE (imm_use_p, ssa_var_2);\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)\n+    @{\n+      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)\n+        SET_USE (imm_use_p, ssa_var_2);\n+      fold_stmt (stmt);\n+    @}\n @end smallexample\n \n There are 2 iterators which can be used. @code{FOR_EACH_IMM_USE_FAST} is used \n when the immediate uses are not changed, ie. you are looking at the uses, but \n not setting them.  \n \n If they do get changed, then care must be taken that things are not changed \n-under the iterators, so use the @code{FOR_EACH_IMM_USE_SAFE} iterator.  It \n-attempts to preserve the sanity of the use list by moving an iterator element\n-through the use list, preventing insertions and deletions in the list from\n-resulting in invalid pointers.  This is a little slower since it adds a\n-placeholder element and moves it through the list.  This element must be \n-also be removed if the loop is terminated early.  A macro \n-(@code{BREAK_FROM SAFE_IMM_USE}) is provided for this:\n+under the iterators, so use the @code{FOR_EACH_IMM_USE_STMT} and \n+@code{FOR_EACH_IMM_USE_ON_STMT} iterators.  They attempt to preserve the \n+sanity of the use list by moving all the uses for a statement into \n+a controlled position, and then iterating over those uses.  Then the \n+optimization can manipulate the stmt when all the uses have been\n+processed.  This is a little slower than the FAST version since it adds a \n+placeholder element and must sort through the list a bit for each statement.  \n+This placeholder element must be also be removed if the loop is \n+terminated early.  The macro @code{BREAK_FROM_IMM_USE_SAFE} is provided \n+to do this :\n \n @smallexample\n-  FOR_EACH_IMM_USE_SAFE (use_p, iter, var)\n+  FOR_EACH_IMM_USE_STMT (stmt, iterator, ssa_var)\n     @{\n-      if (var == last_var)\n+      if (stmt == last_stmt)\n         BREAK_FROM_SAFE_IMM_USE (iter);\n-      else\n-        SET_USE (use_p, var2);\n+\n+      FOR_EACH_IMM_USE_ON_STMT (imm_use_p, iterator)\n+        SET_USE (imm_use_p, ssa_var_2);\n+      fold_stmt (stmt);\n     @}\n @end smallexample\n "}, {"sha": "3a28ee30c9da03d4a1a924bfe635757857974080", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -1923,47 +1923,42 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n   for (i = 0; VEC_iterate (tree, old_ivs, i, oldiv); i++)\n     {\n       imm_use_iterator imm_iter;\n-      use_operand_p imm_use;\n+      use_operand_p use_p;\n       tree oldiv_def;\n       tree oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n+      tree stmt;\n \n       if (TREE_CODE (oldiv_stmt) == PHI_NODE)\n         oldiv_def = PHI_RESULT (oldiv_stmt);\n       else\n \toldiv_def = SINGLE_SSA_TREE_OPERAND (oldiv_stmt, SSA_OP_DEF);\n       gcc_assert (oldiv_def != NULL_TREE);\n \n-      FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, oldiv_def)\n-\t{\n-\t  tree stmt = USE_STMT (imm_use);\n-\t  use_operand_p use_p;\n-\t  ssa_op_iter iter;\n+      FOR_EACH_IMM_USE_STMT (stmt, imm_iter, oldiv_def)\n+        {\n+\t  tree newiv, stmts;\n+\t  lambda_body_vector lbv, newlbv;\n+\n \t  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      if (USE_FROM_PTR (use_p) == oldiv)\n-\t\t{\n-\t\t  tree newiv, stmts;\n-\t\t  lambda_body_vector lbv, newlbv;\n-\t\t  /* Compute the new expression for the induction\n-\t\t     variable.  */\n-\t\t  depth = VEC_length (tree, new_ivs);\n-\t\t  lbv = lambda_body_vector_new (depth);\n-\t\t  LBV_COEFFICIENTS (lbv)[i] = 1;\n-\t\t  \n-\t\t  newlbv = lambda_body_vector_compute_new (transform, lbv);\n-\n-\t\t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n-\t\t\t\t\t\t new_ivs, &stmts);\n-\t\t  bsi = bsi_for_stmt (stmt);\n-\t\t  /* Insert the statements to build that\n-\t\t     expression.  */\n-\t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-\t\t  propagate_value (use_p, newiv);\n-\t\t  update_stmt (stmt);\n-\t\t  \n-\t\t}\n-\t    }\n+\n+\t  /* Compute the new expression for the induction\n+\t     variable.  */\n+\t  depth = VEC_length (tree, new_ivs);\n+\t  lbv = lambda_body_vector_new (depth);\n+\t  LBV_COEFFICIENTS (lbv)[i] = 1;\n+\t  \n+\t  newlbv = lambda_body_vector_compute_new (transform, lbv);\n+\n+\t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n+\t\t\t\t\t new_ivs, &stmts);\n+\t  bsi = bsi_for_stmt (stmt);\n+\t  /* Insert the statements to build that\n+\t     expression.  */\n+\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\n+\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t    propagate_value (use_p, newiv);\n+\t  update_stmt (stmt);\n \t}\n     }\n   VEC_free (tree, heap, new_ivs);\n@@ -2482,6 +2477,7 @@ perfect_nestify (struct loops *loops,\n \t\t{ \n \t\t  use_operand_p use_p;\n \t\t  imm_use_iterator imm_iter;\n+\t\t  tree imm_stmt;\n \t\t  tree stmt = bsi_stmt (bsi);\n \n \t\t  if (stmt == exit_condition\n@@ -2495,10 +2491,9 @@ perfect_nestify (struct loops *loops,\n \t\t  \n \t\t  /* Make copies of this statement to put it back next\n \t\t     to its uses. */\n-\t\t  FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, \n+\t\t  FOR_EACH_IMM_USE_STMT (imm_stmt, imm_iter, \n \t\t\t\t\t TREE_OPERAND (stmt, 0))\n \t\t    {\n-\t\t      tree imm_stmt = USE_STMT (use_p);\n \t\t      if (!exit_phi_for_loop_p (loop->inner, imm_stmt))\n \t\t\t{\n \t\t\t  block_stmt_iterator tobsi;\n@@ -2511,7 +2506,8 @@ perfect_nestify (struct loops *loops,\n \t\t\t  newname = SSA_NAME_VAR (newname);\n \t\t\t  newname = make_ssa_name (newname, newstmt);\n \t\t\t  TREE_OPERAND (newstmt, 0) = newname;\n-\t\t\t  SET_USE (use_p, TREE_OPERAND (newstmt, 0));\n+\t\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t\t    SET_USE (use_p, newname);\n \t\t\t  bsi_insert_before (&tobsi, newstmt, BSI_SAME_STMT);\n \t\t\t  update_stmt (newstmt);\n \t\t\t  update_stmt (imm_stmt);"}, {"sha": "744a9032b5f5f50c76219e5da62f29b9b9375ff9", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -1259,51 +1259,42 @@ replace_uses_by (tree name, tree val)\n   tree stmt;\n   edge e;\n   unsigned i;\n-  VEC(tree,heap) *stmts = VEC_alloc (tree, heap, 20);\n \n-  FOR_EACH_IMM_USE_SAFE (use, imm_iter, name)\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, name)\n     {\n-      stmt = USE_STMT (use);\n-      replace_exp (use, val);\n+      FOR_EACH_IMM_USE_ON_STMT (use, imm_iter)\n+        {\n+\t  replace_exp (use, val);\n \n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\t{\n-\t  e = PHI_ARG_EDGE (stmt, PHI_ARG_INDEX_FROM_USE (use));\n-\t  if (e->flags & EDGE_ABNORMAL)\n+\t  if (TREE_CODE (stmt) == PHI_NODE)\n \t    {\n-\t      /* This can only occur for virtual operands, since\n-\t\t for the real ones SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-\t\t would prevent replacement.  */\n-\t      gcc_assert (!is_gimple_reg (name));\n-\t      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val) = 1;\n+\t      e = PHI_ARG_EDGE (stmt, PHI_ARG_INDEX_FROM_USE (use));\n+\t      if (e->flags & EDGE_ABNORMAL)\n+\t\t{\n+\t\t  /* This can only occur for virtual operands, since\n+\t\t     for the real ones SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+\t\t     would prevent replacement.  */\n+\t\t  gcc_assert (!is_gimple_reg (name));\n+\t\t  SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val) = 1;\n+\t\t}\n \t    }\n \t}\n-      else\n-\tVEC_safe_push (tree, heap, stmts, stmt);\n-    }\n- \n-  /* We do not update the statements in the loop above.  Consider\n-     x = w * w;\n-\n-     If we performed the update in the first loop, the statement\n-     would be rescanned after first occurrence of w is replaced,\n-     the new uses would be placed to the beginning of the list,\n-     and we would never process them.  */\n-  for (i = 0; VEC_iterate (tree, stmts, i, stmt); i++)\n-    {\n-      tree rhs;\n-\n-      fold_stmt_inplace (stmt);\n+      if (TREE_CODE (stmt) != PHI_NODE)\n+\t{\n+\t  tree rhs;\n \n-      rhs = get_rhs (stmt);\n-      if (TREE_CODE (rhs) == ADDR_EXPR)\n-\trecompute_tree_invariant_for_addr_expr (rhs);\n+\t  fold_stmt_inplace (stmt);\n+\t  rhs = get_rhs (stmt);\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (rhs);\n \n-      maybe_clean_or_replace_eh_stmt (stmt, stmt);\n-      mark_new_vars_to_rename (stmt);\n+\t  maybe_clean_or_replace_eh_stmt (stmt, stmt);\n+\t  mark_new_vars_to_rename (stmt);\n+\t}\n     }\n-\n-  VEC_free (tree, heap, stmts);\n+ \n+  gcc_assert (num_imm_uses (name) == 0);\n \n   /* Also update the trees stored in loop structures.  */\n   if (current_loops)"}, {"sha": "58684bdb76d4ec30909578bb965c6c6d5bc8b82e", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 155, "deletions": 77, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -394,83 +394,6 @@ relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old, tree s\n   linknode->stmt = stmt;\n }\n \n-/* Finished the traverse of an immediate use list IMM by removing it from \n-   the list.  */\n-static inline void\n-end_safe_imm_use_traverse (imm_use_iterator *imm)\n-{\n- delink_imm_use (&(imm->iter_node));\n-}\n-\n-/* Return true if IMM is at the end of the list.  */\n-static inline bool\n-end_safe_imm_use_p (imm_use_iterator *imm)\n-{\n-  return (imm->imm_use == imm->end_p);\n-}\n-\n-/* Initialize iterator IMM to process the list for VAR.  */\n-static inline use_operand_p\n-first_safe_imm_use (imm_use_iterator *imm, tree var)\n-{\n-  /* Set up and link the iterator node into the linked list for VAR.  */\n-  imm->iter_node.use = NULL;\n-  imm->iter_node.stmt = NULL_TREE;\n-  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n-  /* Check if there are 0 elements.  */\n-  if (imm->end_p->next == imm->end_p)\n-    {\n-      imm->imm_use = imm->end_p;\n-      return NULL_USE_OPERAND_P;\n-    }\n-\n-  link_imm_use (&(imm->iter_node), var);\n-  imm->imm_use = imm->iter_node.next;\n-  return imm->imm_use;\n-}\n-\n-/* Bump IMM to the next use in the list.  */\n-static inline use_operand_p\n-next_safe_imm_use (imm_use_iterator *imm)\n-{\n-  ssa_use_operand_t *ptr;\n-  use_operand_p old;\n-\n-  old = imm->imm_use;\n-  /* If the next node following the iter_node is still the one referred to by\n-     imm_use, then the list hasn't changed, go to the next node.  */\n-  if (imm->iter_node.next == imm->imm_use)\n-    {\n-      ptr = &(imm->iter_node);\n-      /* Remove iternode from the list.  */\n-      delink_imm_use (ptr);\n-      imm->imm_use = imm->imm_use->next;\n-      if (! end_safe_imm_use_p (imm))\n-\t{\n-\t  /* This isn't the end, link iternode before the next use.  */\n-\t  ptr->prev = imm->imm_use->prev;\n-\t  ptr->next = imm->imm_use;\n-\t  imm->imm_use->prev->next = ptr;\n-\t  imm->imm_use->prev = ptr;\n-\t}\n-      else\n-\treturn old;\n-    }\n-  else\n-    {\n-      /* If the 'next' value after the iterator isn't the same as it was, then\n-\t a node has been deleted, so we simply proceed to the node following \n-\t where the iterator is in the list.  */\n-      imm->imm_use = imm->iter_node.next;\n-      if (end_safe_imm_use_p (imm))\n-        {\n-\t  end_safe_imm_use_traverse (imm);\n-\t  return old;\n-\t}\n-    }\n-\n-  return imm->imm_use;\n-}\n \n /* Return true is IMM has reached the end of the immediate use list.  */\n static inline bool\n@@ -1376,7 +1299,162 @@ op_iter_init_phidef (ssa_op_iter *ptr, tree phi, int flags)\n   return PHI_RESULT_PTR (phi);\n }\n \n+/* Return true is IMM has reached the end of the immediate use stmt list.  */\n+\n+static inline bool\n+end_imm_use_stmt_p (imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == imm->end_p);\n+}\n+\n+/* Finished the traverse of an immediate use stmt list IMM by removing the\n+   placeholder node from the list.  */\n+\n+static inline void\n+end_imm_use_stmt_traverse (imm_use_iterator *imm)\n+{\n+  delink_imm_use (&(imm->iter_node));\n+}\n+\n+/* Immediate use traversal of uses within a stmt require that all the\n+   uses on a stmt be sequentially listed.  This routine is used to build up\n+   this sequential list by adding USE_P to the end of the current list \n+   currently delimited by HEAD and LAST_P.  The new LAST_P value is \n+   returned.  */\n+\n+static inline use_operand_p\n+move_use_after_head (use_operand_p use_p, use_operand_p head, \n+\t\t      use_operand_p last_p)\n+{\n+  gcc_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n+  /* Skip head when we find it.  */\n+  if (use_p != head)\n+    {\n+      /* If use_p is already linked in after last_p, continue.  */\n+      if (last_p->next == use_p)\n+\tlast_p = use_p;\n+      else\n+\t{\n+\t  /* Delink from current location, and link in at last_p.  */\n+\t  delink_imm_use (use_p);\n+\t  link_imm_use_to_list (use_p, last_p);\n+\t  last_p = use_p;\n+\t}\n+    }\n+  return last_p;\n+}\n+\n+\n+/* This routine will relink all uses with the same stmt as HEAD into the list\n+   immediately following HEAD for iterator IMM.  */\n+\n+static inline void\n+link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n+{\n+  use_operand_p use_p;\n+  use_operand_p last_p = head;\n+  tree head_stmt = USE_STMT (head);\n+  tree use = USE_FROM_PTR (head);\n+  ssa_op_iter op_iter;\n+  int flag;\n+\n+  /* Only look at virtual or real uses, depending on the type of HEAD.  */\n+  flag = (is_gimple_reg (use) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n+\n+  if (TREE_CODE (head_stmt) == PHI_NODE)\n+    {\n+      FOR_EACH_PHI_ARG (use_p, head_stmt, op_iter, flag)\n+\tif (USE_FROM_PTR (use_p) == use)\n+\t  last_p = move_use_after_head (use_p, head, last_p);\n+    }\n+  else\n+    {\n+      FOR_EACH_SSA_USE_OPERAND (use_p, head_stmt, op_iter, flag)\n+\tif (USE_FROM_PTR (use_p) == use)\n+\t  last_p = move_use_after_head (use_p, head, last_p);\n+    }\n+  /* LInk iter node in after last_p.  */\n+  if (imm->iter_node.prev != NULL)\n+    delink_imm_use (&imm->iter_node);\n+  link_imm_use_to_list (&(imm->iter_node), last_p);\n+}\n+\n+/* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */\n+static inline tree\n+first_imm_use_stmt (imm_use_iterator *imm, tree var)\n+{\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+  \n+  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n+  imm->imm_use = imm->end_p->next;\n+  imm->next_imm_name = NULL_USE_OPERAND_P;\n+\n+  /* iter_node is used as a marker within the immediate use list to indicate\n+     where the end of the current stmt's uses are.  Iintialize it to NULL\n+     stmt and use, which indicateds a marker node.  */\n+  imm->iter_node.prev = NULL_USE_OPERAND_P;\n+  imm->iter_node.next = NULL_USE_OPERAND_P;\n+  imm->iter_node.stmt = NULL_TREE;\n+  imm->iter_node.use = NULL_USE_OPERAND_P;\n+\n+  if (end_imm_use_stmt_p (imm))\n+    return NULL_TREE;\n+\n+  link_use_stmts_after (imm->imm_use, imm);\n+\n+  return USE_STMT (imm->imm_use);\n+}\n+\n+/* Bump IMM to the next stmt which has a use of var.  */\n+\n+static inline tree\n+next_imm_use_stmt (imm_use_iterator *imm)\n+{\n+  imm->imm_use = imm->iter_node.next;\n+  if (end_imm_use_stmt_p (imm))\n+    {\n+      if (imm->iter_node.prev != NULL)\n+\tdelink_imm_use (&imm->iter_node);\n+      return NULL_TREE;\n+    }\n+\n+  link_use_stmts_after (imm->imm_use, imm);\n+  return USE_STMT (imm->imm_use);\n \n+}\n+\n+/* This routine will return the first use on the stmt IMM currently refers\n+   to.  */\n+\n+static inline use_operand_p\n+first_imm_use_on_stmt (imm_use_iterator *imm)\n+{\n+  imm->next_imm_name = imm->imm_use->next;\n+  return imm->imm_use;\n+}\n+\n+/*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */\n+\n+static inline bool\n+end_imm_use_on_stmt_p (imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == &(imm->iter_node));\n+}\n+\n+/* Bump to the next use on the stmt IMM refers to, return NULL if done.  */\n+\n+static inline use_operand_p\n+next_imm_use_on_stmt (imm_use_iterator *imm)\n+{\n+  imm->imm_use = imm->next_imm_name;\n+  if (end_imm_use_on_stmt_p (imm))\n+    return NULL_USE_OPERAND_P;\n+  else\n+    {\n+      imm->next_imm_name = imm->imm_use->next;\n+      return imm->imm_use;\n+    }\n+}\n \n /* Return true if VAR cannot be modified by the program.  */\n "}, {"sha": "98ed8afe282e8ddcb0a5b3bf30389da83ff0382d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -225,9 +225,15 @@ struct function_ann_d GTY(())\n \n typedef struct immediate_use_iterator_d\n {\n+  /* This is the current use the iterator is processing.  */\n   ssa_use_operand_t *imm_use;\n+  /* This marks the last use in the list (use node from SSA_NAME)  */\n   ssa_use_operand_t *end_p;\n+  /* This node is inserted and used to mark the end of the uses for a stmt.  */\n   ssa_use_operand_t iter_node;\n+  /* This is the next ssa_name to visit.  IMM_USE may get removed before\n+     the next one is traversed to, so it must be cached early.  */\n+  ssa_use_operand_t *next_imm_name;\n } imm_use_iterator;\n \n \n@@ -239,18 +245,43 @@ typedef struct immediate_use_iterator_d\n        !end_readonly_imm_use_p (&(ITER));\t\t\t\\\n        (DEST) = next_readonly_imm_use (&(ITER)))\n   \n+/* Use this iterator to visit each stmt which has a use of SSAVAR.  */\n \n-#define FOR_EACH_IMM_USE_SAFE(DEST, ITER, SSAVAR)\t\t\\\n-  for ((DEST) = first_safe_imm_use (&(ITER), (SSAVAR));\t\t\\\n-       !end_safe_imm_use_p (&(ITER));\t\t\t\t\\\n-       (DEST) = next_safe_imm_use (&(ITER)))\n+#define FOR_EACH_IMM_USE_STMT(STMT, ITER, SSAVAR)\t\t\\\n+  for ((STMT) = first_imm_use_stmt (&(ITER), (SSAVAR));\t\t\\\n+       !end_imm_use_stmt_p (&(ITER));\t\t\t\t\\\n+       (STMT) = next_imm_use_stmt (&(ITER)))\n \n-#define BREAK_FROM_SAFE_IMM_USE(ITER)\t\t\t\t\\\n+/* Use this to terminate the FOR_EACH_IMM_USE_STMT loop early.  Failure to \n+   do so will result in leaving a iterator marker node in the immediate\n+   use list, and nothing good will come from that.   */\n+#define BREAK_FROM_IMM_USE_STMT(ITER)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n-     end_safe_imm_use_traverse (&(ITER));\t\t\t\\\n+     end_imm_use_stmt_traverse (&(ITER));\t\t\t\\\n      break;\t\t\t\t\t\t\t\\\n    }\n \n+\n+/* Use this iterator in combination with FOR_EACH_IMM_USE_STMT to \n+   get access to each occurence of ssavar on the stmt returned by\n+   that iterator..  for instance:\n+\n+     FOR_EACH_IMM_USE_STMT (stmt, iter, var)\n+       {\n+         FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t   {\n+\t     SET_USE (use_p) = blah;\n+\t   }\n+\t update_stmt (stmt);\n+       }\t\t\t\t\t\t\t */\n+\n+#define FOR_EACH_IMM_USE_ON_STMT(DEST, ITER)\t\t\t\\\n+  for ((DEST) = first_imm_use_on_stmt (&(ITER));\t\t\\\n+       !end_imm_use_on_stmt_p (&(ITER));\t\t\t\\\n+       (DEST) = next_imm_use_on_stmt (&(ITER)))\n+\n+\n+\n struct stmt_ann_d GTY(())\n {\n   struct tree_ann_common_d common;"}, {"sha": "431f8564bd3337039c4f34187daba4844238d770", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -2118,6 +2118,7 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n     {\n       use_operand_p use_p;\n       imm_use_iterator iter;\n+      tree use_stmt;\n       bool all = true;\n \n       /* Dump details.  */\n@@ -2134,10 +2135,8 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n       /* Walk over every use of LHS and try to replace the use with RHS. \n \t At this point the only reason why such a propagation would not\n \t be successful would be if the use occurs in an ASM_EXPR.  */\n-    repeat:\n-      FOR_EACH_IMM_USE_SAFE (use_p, iter, lhs)\n+      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t{\n-\t  tree use_stmt = USE_STMT (use_p);\n \t\n \t  /* It's not always safe to propagate into an ASM_EXPR.  */\n \t  if (TREE_CODE (use_stmt) == ASM_EXPR\n@@ -2156,7 +2155,8 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \t    }\n \n \t  /* Propagate the RHS into this use of the LHS.  */\n-\t  propagate_value (use_p, rhs);\n+\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t    propagate_value (use_p, rhs);\n \n \t  /* Special cases to avoid useless calls into the folding\n \t     routines, operand scanning, etc.\n@@ -2303,23 +2303,8 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \t    }\n \t}\n \n-      /* Due to a bug in the immediate use iterator code, we can\n-\t miss visiting uses in some cases when there is more than\n-\t one use in a statement.  Missing a use can cause a multitude\n-         of problems if we expected to eliminate all uses and remove\n-         the defining statement.\n-\n-\t Until Andrew can fix the iterator, this hack will detect\n-\t the cases which cause us problems.  Namely if ALL is set\n-\t and we still have some immediate uses, then we must have\n-\t skipped one or more in the loop above.  So just re-execute\n-\t the loop.\n-\n-\t The maximum number of times we can re-execute the loop is\n-\t bounded by the maximum number of times a given SSA_NAME\n-\t appears in a single statement.  */\n-      if (all && !has_zero_uses (lhs))\n-\tgoto repeat;\n+      /* Ensure there is nothing else to do. */ \n+      gcc_assert (all && has_zero_uses (lhs));\n \n       /* If we were able to propagate away all uses of LHS, then\n \t we can remove STMT.  */"}, {"sha": "d43fb857feb0b69fad97f3c41096dc0e884bf680", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -805,14 +805,13 @@ forward_propagate_addr_expr (tree stmt, bool *some)\n {\n   int stmt_loop_depth = bb_for_stmt (stmt)->loop_depth;\n   tree name = TREE_OPERAND (stmt, 0);\n-  use_operand_p imm_use;\n   imm_use_iterator iter;\n+  tree use_stmt;\n   bool all = true;\n \n-  FOR_EACH_IMM_USE_SAFE (imm_use, iter, name)\n+  FOR_EACH_IMM_USE_STMT (use_stmt, iter, name)\n     {\n       bool result;\n-      tree use_stmt = USE_STMT (imm_use);\n \n       /* If the use is not in a simple assignment statement, then\n \t there is nothing we can do.  */"}, {"sha": "ee5ff8f411ec19e41ceba54d1d7c4935a1553288", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -446,17 +446,20 @@ execute_cse_reciprocals_1 (block_stmt_iterator *def_bsi, tree def)\n   threshold = targetm.min_divisions_for_recip_mul (TYPE_MODE (TREE_TYPE (def)));\n   if (count >= threshold)\n     {\n+      tree use_stmt;\n       for (occ = occ_head; occ; occ = occ->next)\n \t{\n \t  compute_merit (occ);\n \t  insert_reciprocals (def_bsi, occ, def, NULL, threshold);\n \t}\n \n-      FOR_EACH_IMM_USE_SAFE (use_p, use_iter, def)\n+      FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, def)\n \t{\n-\t  tree use_stmt = USE_STMT (use_p);\n \t  if (is_division_by (use_stmt, def))\n-\t    replace_reciprocal (use_p);\n+\t    {\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, use_iter)\n+\t\treplace_reciprocal (use_p);\n+\t    }\n \t}\n     }\n "}, {"sha": "e979b4ce65aa5ca3a6b05fd5ebc5c78f2463a7c2", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 8, "deletions": 78, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -325,49 +325,9 @@ ssa_operand_alloc (unsigned size)\n }\n \n \n-/* Make sure PTR is in the correct immediate use list.  Since uses are simply\n-   pointers into the stmt TREE, there is no way of telling if anyone has\n-   changed what this pointer points to via TREE_OPERANDS (exp, 0) = <...>.\n-   The contents are different, but the pointer is still the same.  This\n-   routine will check to make sure PTR is in the correct list, and if it isn't\n-   put it in the correct list.  We cannot simply check the previous node \n-   because all nodes in the same stmt might have be changed.  */\n-\n-static inline void\n-correct_use_link (use_operand_p ptr, tree stmt)\n-{\n-  use_operand_p prev;\n-  tree root;\n-\n-  /*  fold_stmt may have changed the stmt pointers.  */\n-  if (ptr->stmt != stmt)\n-    ptr->stmt = stmt;\n-\n-  prev = ptr->prev;\n-  if (prev)\n-    {\n-      /* Find the root element, making sure we skip any safe iterators.  */\n-      while (prev->use != NULL || prev->stmt == NULL)\n-\tprev = prev->prev;\n-\n-      /* Get the SSA_NAME of the list the node is in.  */\n-      root = prev->stmt;\n-\n-      /* If it's the right list, simply return.  */\n-      if (root == *(ptr->use))\n-\treturn;\n-    }\n-\n-  /* It is in the wrong list if we reach here.  */\n-  delink_imm_use (ptr);\n-  link_imm_use (ptr, *(ptr->use));\n-}\n-\n \n /* This routine makes sure that PTR is in an immediate use list, and makes\n-   sure the stmt pointer is set to the current stmt.  Virtual uses do not need\n-   the overhead of correct_use_link since they cannot be directly manipulated\n-   like a real use can be.  (They don't exist in the TREE_OPERAND nodes.)  */\n+   sure the stmt pointer is set to the current stmt.  */\n \n static inline void\n set_virtual_use_link (use_operand_p ptr, tree stmt)\n@@ -579,56 +539,20 @@ finalize_ssa_defs (tree stmt)\n }\n \n /* Takes elements from build_uses and turns them into use operands of STMT.\n-   TODO -- Given that use operands list is not necessarily sorted, merging\n-\t   the operands this way does not make much sense.\n-\t-- Make build_uses VEC of tree *.  */\n+   TODO -- Make build_uses VEC of tree *.  */\n \n static inline void\n finalize_ssa_use_ops (tree stmt)\n {\n   unsigned new_i;\n   struct use_optype_d new_list;\n   use_optype_p old_ops, ptr, last;\n-  tree *old_base, *new_base;\n \n   new_list.next = NULL;\n   last = &new_list;\n \n   old_ops = USE_OPS (stmt);\n \n-  new_i = 0;\n-  while (old_ops && new_i < VEC_length (tree, build_uses))\n-    {\n-      new_base = (tree *) VEC_index (tree, build_uses, new_i);\n-      old_base = USE_OP_PTR (old_ops)->use;\n-\n-      if (old_base == new_base)\n-        {\n-\t  /* if variables are the same, reuse this node.  */\n-\t  MOVE_HEAD_AFTER (old_ops, last);\n-\t  correct_use_link (USE_OP_PTR (last), stmt);\n-\t  new_i++;\n-\t}\n-      else if (old_base < new_base)\n-\t{\n-\t  /* if old is less than new, old goes to the free list.  */\n-\t  delink_imm_use (USE_OP_PTR (old_ops));\n-\t  MOVE_HEAD_TO_FREELIST (old_ops, use);\n-\t}\n-      else\n-\t{\n-\t  /* This is a new operand.  */\n-\t  add_use_op (stmt, new_base, &last);\n-\t  new_i++;\n-\t}\n-    }\n-\n-  /* If there is anything remaining in the build_uses list, simply emit it.  */\n-  for ( ; new_i < VEC_length (tree, build_uses); new_i++)\n-    add_use_op (stmt, (tree *) VEC_index (tree, build_uses, new_i), &last);\n-\n-  last->next = NULL;\n-\n   /* If there is anything in the old list, free it.  */\n   if (old_ops)\n     {\n@@ -638,6 +562,12 @@ finalize_ssa_use_ops (tree stmt)\n       free_uses = old_ops;\n     }\n \n+  /* Now create nodes for all the new nodes.  */\n+  for (new_i = 0; new_i < VEC_length (tree, build_uses); new_i++)\n+    add_use_op (stmt, (tree *) VEC_index (tree, build_uses, new_i), &last);\n+\n+  last->next = NULL;\n+\n   /* Now set the stmt's operands.  */\n   USE_OPS (stmt) = new_list.next;\n "}, {"sha": "6ae5d3e5468df2f1b4f3b88a4dbb4b2fe5fe8e18", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -84,18 +84,20 @@ static tree\n lhs_of_dominating_assert (tree op, basic_block bb, tree stmt)\n {\n   imm_use_iterator imm_iter;\n-  use_operand_p imm_use;\n+  tree use_stmt;\n+  use_operand_p use_p;\n \n-  FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, op)\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n     {\n-      tree use_stmt = USE_STMT (imm_use);\n-\n+      use_stmt = USE_STMT (use_p);\n       if (use_stmt != stmt\n           && TREE_CODE (use_stmt) == MODIFY_EXPR\n           && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == ASSERT_EXPR\n           && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 0) == op\n \t  && dominated_by_p (CDI_DOMINATORS, bb, bb_for_stmt (use_stmt)))\n-\top = TREE_OPERAND (use_stmt, 0);\n+\t{\n+\t  return TREE_OPERAND (use_stmt, 0);\n+\t}\n     }\n   return op;\n }"}, {"sha": "b1a9b0a394540f36cf1ee2df937e5c1d4b5737df", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -791,6 +791,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   bool extract_scalar_result;\n   tree reduction_op;\n   tree orig_stmt;\n+  tree use_stmt;\n   tree operation = TREE_OPERAND (stmt, 1);\n   int op_type;\n   \n@@ -1082,8 +1083,9 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   gcc_assert (exit_phi);\n   /* Replace the uses:  */\n   orig_name = PHI_RESULT (exit_phi);\n-  FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, orig_name)\n-    SET_USE (use_p, new_temp);\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n+    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+      SET_USE (use_p, new_temp);\n } \n \n "}, {"sha": "7c6fe6e32ab4948cabdbc98a15f74c8d7e05244e", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c00f606c162459e5cc17a9c3f2474314df7071b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6c00f606c162459e5cc17a9c3f2474314df7071b", "patch": "@@ -3242,6 +3242,7 @@ remove_range_assertions (void)\n     for (si = bsi_start (bb); !bsi_end_p (si);)\n       {\n \ttree stmt = bsi_stmt (si);\n+\ttree use_stmt;\n \n \tif (TREE_CODE (stmt) == MODIFY_EXPR\n \t    && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n@@ -3255,11 +3256,12 @@ remove_range_assertions (void)\n \n \t    /* Propagate the RHS into every use of the LHS.  */\n \t    var = ASSERT_EXPR_VAR (rhs);\n-\t    FOR_EACH_IMM_USE_SAFE (use_p, iter, TREE_OPERAND (stmt, 0))\n-\t      {\n-\t\tSET_USE (use_p, var);\n-\t\tgcc_assert (TREE_CODE (var) == SSA_NAME);\n-\t      }\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, TREE_OPERAND (stmt, 0))\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t{\n+\t\t  SET_USE (use_p, var);\n+\t\t  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\t\t}\n \n \t    /* And finally, remove the copy, it is not needed.  */\n \t    bsi_remove (&si, true);"}]}