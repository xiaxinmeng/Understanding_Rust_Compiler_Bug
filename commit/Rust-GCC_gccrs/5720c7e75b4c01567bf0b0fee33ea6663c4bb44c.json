{"sha": "5720c7e75b4c01567bf0b0fee33ea6663c4bb44c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcyMGM3ZTc1YjRjMDE1NjdiZjBiMGZlZTMzZWE2NjYzYzRiYjQ0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-20T12:33:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-20T12:33:43Z"}, "message": "(check_for_full_enumeration_handling): Call case_tree2list before checking for...\n\n(check_for_full_enumeration_handling): Call case_tree2list\nbefore checking for case expressions not corresponding to enumerators.\n(mark_seen_cases): If SPARSENESS == 2, exploit AVL order.\nElse, convert tree to list.\nSet xlo to -1 if SPARSENESS == 1 search failed.\n(expand_end_case): Avoid calling case_tree2list on list.\n\nFrom-SVN: r11857", "tree": {"sha": "600ff401c40a3fea087486f34e580dbb45997973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/600ff401c40a3fea087486f34e580dbb45997973"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c/comments", "author": null, "committer": null, "parents": [{"sha": "b059139cfa7b992bccdaac439853f8e1b4422f7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b059139cfa7b992bccdaac439853f8e1b4422f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b059139cfa7b992bccdaac439853f8e1b4422f7d"}], "stats": {"total": 95, "additions": 66, "deletions": 29}, "files": [{"sha": "951bb225fc72f5013a9d98380b12a531e0f61b54", "filename": "gcc/stmt.c", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5720c7e75b4c01567bf0b0fee33ea6663c4bb44c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=5720c7e75b4c01567bf0b0fee33ea6663c4bb44c", "patch": "@@ -143,8 +143,9 @@ extern void (*interim_eh_hook)\tPROTO((tree));\n    statements.  We handle \"range\" labels; for a single-value label\n    as in C, the high and low limits are the same.\n \n-   A chain of case nodes is initially maintained via the RIGHT fields\n-   in the nodes.  Nodes with higher case values are later in the list.\n+   An AVL tree of case nodes is initially created, and later transformed\n+   to a list linked via the RIGHT fields in the nodes.  Nodes with\n+   higher case values are later in the list.\n \n    Switch statements can be output in one of two forms.  A branch table\n    is used if there are more than a few labels and the labels are dense\n@@ -4280,6 +4281,8 @@ add_case_node (low, high, label, duplicate)\n \t      else\n \t\t/* r->balance == +1 */\n \t\t{\n+\t\t  /* LR-Rotation */\n+\n \t\t  int b2;\n \t\t  struct case_node *t = r->right;\n \n@@ -4570,36 +4573,62 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n   tree next_node_to_try = NULL_TREE;\n   long next_node_offset = 0;\n \n-  register struct case_node *n;\n+  register struct case_node *n, *root = case_stack->data.case_stmt.case_list;\n   tree val = make_node (INTEGER_CST);\n   TREE_TYPE (val) = type;\n-  for (n = case_stack->data.case_stmt.case_list; n;\n-       n = n->right)\n+  if (! root)\n+    ; /* Do nothing */\n+  else if (sparseness == 2)\n     {\n-      TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (n->low);\n-      TREE_INT_CST_HIGH (val) = TREE_INT_CST_HIGH (n->low);\n-      while ( ! tree_int_cst_lt (n->high, val))\n+      tree t;\n+      HOST_WIDE_INT xlo;\n+\n+      /* This less efficient loop is only needed to handle\n+\t duplicate case values (multiple enum constants\n+\t with the same value).  */\n+      TREE_TYPE (val) = TREE_TYPE (root->low);\n+      for (t = TYPE_VALUES (type), xlo = 0;  t != NULL_TREE;\n+\t   t = TREE_CHAIN (t), xlo++)\n \t{\n-\t  /* Calculate (into xlo) the \"offset\" of the integer (val).\n-\t     The element with lowest value has offset 0, the next smallest\n-\t     element has offset 1, etc.  */\n-\n-\t  HOST_WIDE_INT xlo, xhi;\n-\t  tree t;\n-\t  if (sparseness == 2)\n+\t  TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (TREE_VALUE (t));\n+\t  TREE_INT_CST_HIGH (val) = TREE_INT_CST_HIGH (TREE_VALUE (t));\n+\t  n = root;\n+\t  do\n \t    {\n-\t      /* This less efficient loop is only needed to handle\n-\t\t duplicate case values (multiple enum constants\n-\t\t with the same value).  */\n-\t      for (t = TYPE_VALUES (type), xlo = 0;  t != NULL_TREE;\n-\t\t   t = TREE_CHAIN (t), xlo++)\n+\t      /* Keep going past elements distinctly greater than VAL.  */\n+\t      if (tree_int_cst_lt (val, n->low))\n+\t\tn = n->left;\n+\t\n+\t      /* or distinctly less than VAL.  */\n+\t      else if (tree_int_cst_lt (n->high, val))\n+\t\tn = n->right;\n+\t\n+\t      else\n \t\t{\n-\t\t  if (tree_int_cst_equal (val, TREE_VALUE (t)))\n-\t\t    BITARRAY_SET (cases_seen, xlo);\n+\t\t  /* We have found a matching range.  */\n+\t\t  BITARRAY_SET (cases_seen, xlo);\n+\t\t  break;\n \t\t}\n \t    }\n-\t  else\n+\t  while (n);\n+\t}\n+    }\n+  else\n+    {\n+      if (root->left)\n+\tcase_stack->data.case_stmt.case_list = root = case_tree2list (root, 0);\n+      for (n = root; n; n = n->right)\n+\t{\n+\t  TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (n->low);\n+\t  TREE_INT_CST_HIGH (val) = TREE_INT_CST_HIGH (n->low);\n+\t  while ( ! tree_int_cst_lt (n->high, val))\n \t    {\n+\t      /* Calculate (into xlo) the \"offset\" of the integer (val).\n+\t\t The element with lowest value has offset 0, the next smallest\n+\t\t element has offset 1, etc.  */\n+\n+\t      HOST_WIDE_INT xlo, xhi;\n+\t      tree t;\n \t      if (sparseness && TYPE_VALUES (type) != NULL_TREE)\n \t\t{\n \t\t  /* The TYPE_VALUES will be in increasing order, so\n@@ -4623,7 +4652,10 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t\t      xlo++;\n \t\t      t = TREE_CHAIN (t);\n \t\t      if (t == next_node_to_try)\n-\t\t\tbreak;\n+\t\t\t{\n+\t\t\t  xlo = -1;\n+\t\t\t  break;\n+\t\t\t}\n \t\t    }\n \t\t}\n \t      else\n@@ -4641,10 +4673,10 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t      \n \t      if (xhi == 0 && xlo >= 0 && xlo < count)\n \t\tBITARRAY_SET (cases_seen, xlo);\n+\t      add_double (TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val),\n+\t\t\t  1, 0,\n+\t\t\t  &TREE_INT_CST_LOW (val), &TREE_INT_CST_HIGH (val));\n \t    }\n-\t  add_double (TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val),\n-\t\t      1, 0,\n-\t\t      &TREE_INT_CST_LOW (val), &TREE_INT_CST_HIGH (val));\n \t}\n     }\n }\n@@ -4706,7 +4738,7 @@ check_for_full_enumeration_handling (type)\n       /* The time complexity of this code is normally O(N), where\n \t N being the number of members in the enumerated type.\n \t However, if type is a ENUMERAL_TYPE whose values do not\n-\t increase monotonically, quadratic time may be needed. */\n+\t increase monotonically, O(N*log(N)) time may be needed. */\n \n       mark_seen_cases (type, cases_seen, size, sparseness);\n \n@@ -4725,6 +4757,10 @@ check_for_full_enumeration_handling (type)\n      occur since C and C++ don't enforce type-checking of\n      assignments to enumeration variables. */\n \n+  if (case_stack->data.case_stmt.case_list\n+      && case_stack->data.case_stmt.case_list->left)\n+    case_stack->data.case_stmt.case_list\n+      = case_tree2list (case_stack->data.case_stmt.case_list, 0);\n   if (warn_switch)\n     for (n = case_stack->data.case_stmt.case_list; n; n = n->right)\n       {\n@@ -4908,7 +4944,8 @@ expand_end_case (orig_index)\n \n       before_case = get_last_insn ();\n \n-      if (thiscase->data.case_stmt.case_list)\n+      if (thiscase->data.case_stmt.case_list\n+\t  && thiscase->data.case_stmt.case_list->left)\n \tthiscase->data.case_stmt.case_list\n \t  = case_tree2list(thiscase->data.case_stmt.case_list, 0);\n "}]}