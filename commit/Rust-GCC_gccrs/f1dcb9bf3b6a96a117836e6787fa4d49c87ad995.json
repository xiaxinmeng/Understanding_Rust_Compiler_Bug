{"sha": "f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFkY2I5YmYzYjZhOTZhMTE3ODM2ZTY3ODdmYTRkNDljODdhZDk5NQ==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-01-10T05:46:13Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-01-10T05:46:13Z"}, "message": "re PR fortran/30381 ([4.1 only] ISHFTC() constant folding is broken.)\n\nPR 30381\nPR 30420\n* fortran/simplify.c (convert_mpz_to_unsigned): New function.\n\t(convert_mpz_to_signed): New function, largely based on\n\ttwos_complement().\n\t(twos_complement): Removed.\n\t(gfc_simplify_ibclr): Add conversions to and from an\n\tunsigned representation before bit-twiddling.\n\t(gfc_simplify_ibset): Same.\n\t(gfc_simplify_ishftc): Add checks for overly large\n\tconstant arguments, only check the third argument if\n\tit's present, carry over high bits into\tthe result as\n\tappropriate, and perform the final conversion back to\n\ta signed representation using the correct sign bit.\n\t(gfc_simplify_not): Removed unnecessary masking.\n* testsuite/gfortran.dg/\n\t* chkbits.f90: Added IBCLR tests; test calls for\n\tdifferent integer kinds.\n\t* ishft.f90: Renamed to ishft_1.f90...\n\t* ishft_1.f90: ...Renamed from ishft.f90.\n\t* ishft_2.f90: New test.\n\t* ishft_3.f90: New test.\n\nFrom-SVN: r120634", "tree": {"sha": "23ccb0abe794245c81bad05c2acfc7144098c78a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ccb0abe794245c81bad05c2acfc7144098c78a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/comments", "author": null, "committer": null, "parents": [{"sha": "e1f1d97f19dc76735e2a6ac743ee31e545264969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f1d97f19dc76735e2a6ac743ee31e545264969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f1d97f19dc76735e2a6ac743ee31e545264969"}], "stats": {"total": 203, "additions": 149, "deletions": 54}, "files": [{"sha": "8cf0bc3ebdf1d0ecc776378eed3b685cd460e2b1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -1,3 +1,21 @@\n+2007-01-09  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\tPR 30381\n+\tPR 30420\n+\t* simplify.c (convert_mpz_to_unsigned): New function.\n+\t(convert_mpz_to_signed): New function, largely based on\n+\ttwos_complement().\n+\t(twos_complement): Removed.\n+\t(gfc_simplify_ibclr): Add conversions to and from an\n+\tunsigned representation before bit-twiddling.\n+\t(gfc_simplify_ibset): Same.\n+\t(gfc_simplify_ishftc): Add checks for overly large\n+\tconstant arguments, only check the third argument if\n+\tit's present, carry over high bits into\tthe result as\n+\tappropriate, and perform the final conversion back to\n+\ta signed representation using the correct sign bit.\n+\t(gfc_simplify_not): Removed unnecessary masking.\n+\n 2007-01-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/30408"}, {"sha": "82005f1d58f5e9eb9fd89b664e9a1eea8a60614f", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 90, "deletions": 46, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -154,20 +154,56 @@ get_kind (bt type, gfc_expr * k, const char *name, int default_kind)\n }\n \n \n-/* Checks if X, which is assumed to represent a two's complement\n-   integer of binary width BITSIZE, has the signbit set.  If so, makes \n-   X the corresponding negative number.  */\n+/* Converts an mpz_t signed variable into an unsigned one, assuming\n+   two's complement representations and a binary width of bitsize.\n+   The conversion is a no-op unless x is negative; otherwise, it can\n+   be accomplished by masking out the high bits.  */\n \n static void\n-twos_complement (mpz_t x, int bitsize)\n+convert_mpz_to_unsigned (mpz_t x, int bitsize)\n {\n   mpz_t mask;\n \n+  if (mpz_sgn (x) < 0)\n+    {\n+      /* Confirm that no bits above the signed range are unset.  */\n+      gcc_assert (mpz_scan0 (x, bitsize-1) == ULONG_MAX);\n+\n+      mpz_init_set_ui (mask, 1);\n+      mpz_mul_2exp (mask, mask, bitsize);\n+      mpz_sub_ui (mask, mask, 1);\n+\n+      mpz_and (x, x, mask);\n+\n+      mpz_clear (mask);\n+    }\n+  else\n+    {\n+      /* Confirm that no bits above the signed range are set.  */\n+      gcc_assert (mpz_scan1 (x, bitsize-1) == ULONG_MAX);\n+    }\n+}\n+\n+\n+/* Converts an mpz_t unsigned variable into a signed one, assuming\n+   two's complement representations and a binary width of bitsize.\n+   If the bitsize-1 bit is set, this is taken as a sign bit and\n+   the number is converted to the corresponding negative number.  */\n+\n+\n+static void\n+convert_mpz_to_signed (mpz_t x, int bitsize)\n+{\n+  mpz_t mask;\n+\n+  /* Confirm that no bits above the unsigned range are set.  */\n+  gcc_assert (mpz_scan1 (x, bitsize) == ULONG_MAX);\n+\n   if (mpz_tstbit (x, bitsize - 1) == 1)\n     {\n-      mpz_init_set_ui(mask, 1);\n-      mpz_mul_2exp(mask, mask, bitsize);\n-      mpz_sub_ui(mask, mask, 1);\n+      mpz_init_set_ui (mask, 1);\n+      mpz_mul_2exp (mask, mask, bitsize);\n+      mpz_sub_ui (mask, mask, 1);\n \n       /* We negate the number by hand, zeroing the high bits, that is\n         make it the corresponding positive number, and then have it\n@@ -1253,7 +1289,14 @@ gfc_simplify_ibclr (gfc_expr * x, gfc_expr * y)\n \n   result = gfc_copy_expr (x);\n \n+  convert_mpz_to_unsigned (result->value.integer,\n+\t\t\t   gfc_integer_kinds[k].bit_size);\n+\n   mpz_clrbit (result->value.integer, pos);\n+\n+  convert_mpz_to_signed (result->value.integer,\n+\t\t\t gfc_integer_kinds[k].bit_size);\n+\n   return range_check (result, \"IBCLR\");\n }\n \n@@ -1289,9 +1332,8 @@ gfc_simplify_ibits (gfc_expr * x, gfc_expr * y, gfc_expr * z)\n \n   if (pos + len > bitsize)\n     {\n-      gfc_error\n-\t(\"Sum of second and third arguments of IBITS exceeds bit size \"\n-\t \"at %L\", &y->where);\n+      gfc_error (\"Sum of second and third arguments of IBITS exceeds \"\n+\t\t \"bit size at %L\", &y->where);\n       return &gfc_bad_expr;\n     }\n \n@@ -1353,9 +1395,13 @@ gfc_simplify_ibset (gfc_expr * x, gfc_expr * y)\n \n   result = gfc_copy_expr (x);\n \n+  convert_mpz_to_unsigned (result->value.integer,\n+\t\t\t   gfc_integer_kinds[k].bit_size);\n+\n   mpz_setbit (result->value.integer, pos);\n \n-  twos_complement (result->value.integer, gfc_integer_kinds[k].bit_size);\n+  convert_mpz_to_signed (result->value.integer,\n+\t\t\t gfc_integer_kinds[k].bit_size);\n \n   return range_check (result, \"IBSET\");\n }\n@@ -1786,7 +1832,7 @@ gfc_simplify_ishft (gfc_expr * e, gfc_expr * s)\n \t}\n     }\n \n-  twos_complement (result->value.integer, isize);\n+  convert_mpz_to_signed (result->value.integer, isize);\n \n   gfc_free (bits);\n   return result;\n@@ -1797,7 +1843,7 @@ gfc_expr *\n gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n {\n   gfc_expr *result;\n-  int shift, ashift, isize, delta, k;\n+  int shift, ashift, isize, ssize, delta, k;\n   int i, *bits;\n \n   if (e->expr_type != EXPR_CONSTANT || s->expr_type != EXPR_CONSTANT)\n@@ -1810,45 +1856,60 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n     }\n \n   k = gfc_validate_kind (e->ts.type, e->ts.kind, false);\n+  isize = gfc_integer_kinds[k].bit_size;\n \n   if (sz != NULL)\n     {\n-      if (gfc_extract_int (sz, &isize) != NULL || isize < 0)\n+      if (sz->expr_type != EXPR_CONSTANT)\n+        return NULL;\n+\n+      if (gfc_extract_int (sz, &ssize) != NULL || ssize <= 0)\n \t{\n \t  gfc_error (\"Invalid third argument of ISHFTC at %L\", &sz->where);\n \t  return &gfc_bad_expr;\n \t}\n+\n+      if (ssize > isize)\n+\t{\n+\t  gfc_error (\"Magnitude of third argument of ISHFTC exceeds \"\n+\t\t     \"BIT_SIZE of first argument at %L\", &s->where);\n+\t  return &gfc_bad_expr;\n+\t}\n     }\n   else\n-    isize = gfc_integer_kinds[k].bit_size;\n+    ssize = isize;\n \n   if (shift >= 0)\n     ashift = shift;\n   else\n     ashift = -shift;\n \n-  if (ashift > isize)\n+  if (ashift > ssize)\n     {\n-      gfc_error\n-\t(\"Magnitude of second argument of ISHFTC exceeds third argument \"\n-\t \"at %L\", &s->where);\n+      if (sz != NULL)\n+\tgfc_error (\"Magnitude of second argument of ISHFTC exceeds \"\n+\t\t   \"third argument at %L\", &s->where);\n+      else\n+\tgfc_error (\"Magnitude of second argument of ISHFTC exceeds \"\n+\t\t   \"BIT_SIZE of first argument at %L\", &s->where);\n       return &gfc_bad_expr;\n     }\n \n   result = gfc_constant_result (e->ts.type, e->ts.kind, &e->where);\n \n+  mpz_set (result->value.integer, e->value.integer);\n+\n   if (shift == 0)\n-    {\n-      mpz_set (result->value.integer, e->value.integer);\n-      return result;\n-    }\n+    return result;\n \n-  bits = gfc_getmem (isize * sizeof (int));\n+  convert_mpz_to_unsigned (result->value.integer, isize);\n \n-  for (i = 0; i < isize; i++)\n+  bits = gfc_getmem (ssize * sizeof (int));\n+\n+  for (i = 0; i < ssize; i++)\n     bits[i] = mpz_tstbit (e->value.integer, i);\n \n-  delta = isize - ashift;\n+  delta = ssize - ashift;\n \n   if (shift > 0)\n     {\n@@ -1860,7 +1921,7 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n \t    mpz_setbit (result->value.integer, i + shift);\n \t}\n \n-      for (i = delta; i < isize; i++)\n+      for (i = delta; i < ssize; i++)\n \t{\n \t  if (bits[i] == 0)\n \t    mpz_clrbit (result->value.integer, i - delta);\n@@ -1878,7 +1939,7 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n \t    mpz_setbit (result->value.integer, i + delta);\n \t}\n \n-      for (i = ashift; i < isize; i++)\n+      for (i = ashift; i < ssize; i++)\n \t{\n \t  if (bits[i] == 0)\n \t    mpz_clrbit (result->value.integer, i + shift);\n@@ -1887,7 +1948,7 @@ gfc_simplify_ishftc (gfc_expr * e, gfc_expr * s, gfc_expr * sz)\n \t}\n     }\n \n-  twos_complement (result->value.integer, isize);\n+  convert_mpz_to_signed (result->value.integer, isize);\n \n   gfc_free (bits);\n   return result;\n@@ -2580,8 +2641,6 @@ gfc_expr *\n gfc_simplify_not (gfc_expr * e)\n {\n   gfc_expr *result;\n-  int i;\n-  mpz_t mask;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -2590,21 +2649,6 @@ gfc_simplify_not (gfc_expr * e)\n \n   mpz_com (result->value.integer, e->value.integer);\n \n-  /* Because of how GMP handles numbers, the result must be ANDed with\n-     a mask.  For radices <> 2, this will require change.  */\n-\n-  i = gfc_validate_kind (BT_INTEGER, e->ts.kind, false);\n-\n-  mpz_init (mask);\n-  mpz_add (mask, gfc_integer_kinds[i].huge, gfc_integer_kinds[i].huge);\n-  mpz_add_ui (mask, mask, 1);\n-\n-  mpz_and (result->value.integer, result->value.integer, mask);\n-\n-  twos_complement (result->value.integer, gfc_integer_kinds[i].bit_size);\n-\n-  mpz_clear (mask);\n-\n   return range_check (result, \"NOT\");\n }\n "}, {"sha": "71488e554a2b05455c5491f2cca54d453104242a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -1,3 +1,12 @@\n+2007-01-09  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* gfortran.dg/chkbits.f90: Added IBCLR tests; test calls\n+\tfor different integer kinds.\n+\t* gfortran.dg/ishft.f90: Renamed to ishft_1.f90...\n+\t* gfortran.dg/ishft_1.f90: ...Renamed from ishft.f90.\n+\t* gfortran.dg/ishft_2.f90: New test.\n+\t* gfortran.dg/ishft_3.f90: New test.\n+\n 2007-01-09  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* gfortran.dg/altreturn_2.f90: Removed executable bit."}, {"sha": "4652439fddd3533582872c685f7421c68f645b1a", "filename": "gcc/testsuite/gfortran.dg/chkbits.f90", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fchkbits.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fchkbits.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchkbits.f90?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -11,16 +11,23 @@ program chkbits\n   integer(kind=4) i4\n   integer(kind=8) i8\n \n-  i1 = ibset(2147483647,bit_size(i4)-1)\n-  i2 = ibset(2147483647,bit_size(i4)-1)\n-  i4 = ibset(2147483647,bit_size(i4)-1)\n-  i8 = ibset(2147483647,bit_size(i4)-1)\n+  i1 = ibset(huge(0_1), bit_size(i1)-1)\n+  i2 = ibset(huge(0_2), bit_size(i2)-1)\n+  i4 = ibset(huge(0_4), bit_size(i4)-1)\n+  i8 = ibset(huge(0_8), bit_size(i8)-1)\n   if (i1 /= -1 .or. i2 /= -1 .or. i4 /= -1 .or. i8 /= -1) call abort\n \n-  i1 = not(0)\n-  i2 = not(0)\n-  i4 = not(0)\n-  i8 = not(0)\n+  i1 = ibclr(-1_1, bit_size(i1)-1)\n+  i2 = ibclr(-1_2, bit_size(i2)-1)\n+  i4 = ibclr(-1_4, bit_size(i4)-1)\n+  i8 = ibclr(-1_8, bit_size(i8)-1)\n+  if (i1 /= huge(0_1) .or. i2 /= huge(0_2)) call abort\n+  if (i4 /= huge(0_4) .or. i8 /= huge(0_8)) call abort\n+\n+  i1 = not(0_1)\n+  i2 = not(0_2)\n+  i4 = not(0_4)\n+  i8 = not(0_8)\n   if (i1 /= -1 .or. i2 /= -1 .or. i4 /= -1 .or. i8 /= -1) call abort\n \n end program chkbits"}, {"sha": "88edd30efdde2559656261d7e1cdce330d8c2304", "filename": "gcc/testsuite/gfortran.dg/ishft_1.f90", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_1.f90?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "previous_filename": "gcc/testsuite/gfortran.dg/ishft.f90"}, {"sha": "96acf0e3b9b7186b3df971d555de1c0e2de452a4", "filename": "gcc/testsuite/gfortran.dg/ishft_2.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_2.f90?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do run }\n+program ishft_2\n+  if ( ishftc(3, 2, 3) /= 5 ) call abort()\n+  if ( ishftc(256+3, 2, 3) /= 256+5 ) call abort()\n+  if ( ishftc(1_4, 31)+1 /= -huge(1_4) ) call abort()\n+end program"}, {"sha": "fa3938ef9f0cba266e0878e2d5315459ef255938", "filename": "gcc/testsuite/gfortran.dg/ishft_3.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dcb9bf3b6a96a117836e6787fa4d49c87ad995/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fishft_3.f90?ref=f1dcb9bf3b6a96a117836e6787fa4d49c87ad995", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+program ishft_3\n+  integer i, j\n+  write(*,*) ishftc( 3, 2, 3 )\n+  write(*,*) ishftc( 3, 2, i )\n+  write(*,*) ishftc( 3, i, j )\n+  write(*,*) ishftc( 3, 128 )     ! { dg-error \"exceeds BIT_SIZE of first\" }\n+  write(*,*) ishftc( 3, 0, 128 )  ! { dg-error \"exceeds BIT_SIZE of first\" }\n+  write(*,*) ishftc( 3, 0, 0 )    ! { dg-error \"Invalid third argument\" }\n+  write(*,*) ishftc( 3, 3, 2 )    ! { dg-error \"exceeds third argument\" }\n+end program"}]}