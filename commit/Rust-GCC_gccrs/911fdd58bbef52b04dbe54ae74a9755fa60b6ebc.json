{"sha": "911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTExZmRkNThiYmVmNTJiMDRkYmU1NGFlNzRhOTc1NWZhNjBiNmViYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-15T00:44:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-15T00:44:58Z"}, "message": "mrs/manson:\n\nUpdate documentation.\n\nFrom-SVN: r12715", "tree": {"sha": "4eeea742ca7c6eb94a785009e6bcfe2a991c2f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eeea742ca7c6eb94a785009e6bcfe2a991c2f10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc/comments", "author": null, "committer": null, "parents": [{"sha": "ef19912d09dff11b4a52d4e1ea52acb86c5c85c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef19912d09dff11b4a52d4e1ea52acb86c5c85c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef19912d09dff11b4a52d4e1ea52acb86c5c85c8"}], "stats": {"total": 151, "additions": 144, "deletions": 7}, "files": [{"sha": "7c31e950fee256049d41e19d4bd805d231ba6b85", "filename": "gcc/except.h", "status": "modified", "additions": 144, "deletions": 7, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "patch": "@@ -26,6 +26,8 @@ Boston, MA 02111-1307, USA.  */\n \n #ifdef TREE_CODE\n \n+/* A stack of labels. CHAIN points to the next entry in the stack.  */\n+\n struct label_node {\n   union {\n     rtx rlabel;\n@@ -34,8 +36,19 @@ struct label_node {\n   struct label_node *chain;\n };\n \n-/* A entry for the exception handling stack EHSTACK or the exception\n-   handling queue EHQUEUE.  */\n+/* An eh_entry is used to describe one exception handling region.\n+\n+   START_LABEL is the label corresponding to the start of the region.\n+\n+   END_LABEL is the label corresponding to the end of the region.\n+\n+   EXCEPTION_HANDLER_LABEL is the label corresponding to the handler\n+   for this region.\n+\n+   FINALIZATION is the tree codes for the handler, or is NULL_TREE if\n+   one hasn't been generated yet, or is integer_zero_node to mark the\n+   end of a group of try blocks.  */\n+\n struct eh_entry {\n   rtx start_label;\n   rtx end_label;\n@@ -44,55 +57,179 @@ struct eh_entry {\n   tree finalization;\n };\n \n+/* A list of EH_ENTRYs. ENTRY is the entry; CHAIN points to the next\n+   entry in the list, or is NULL if this is the last entry.  */\n+\n struct eh_node {\n   struct eh_entry *entry;\n   struct eh_node *chain;\n };\n \n+/* A stack of EH_ENTRYs. TOP is the topmost entry on the stack. TOP is\n+   NULL if the stack is empty.  */\n+\n struct eh_stack {\n   struct eh_node *top;\n };\n \n+/* A queue of EH_ENTRYs. HEAD is the front of the queue; TAIL is the\n+   end (the latest entry). HEAD and TAIL are NULL if the queue is\n+   empty.  */\n+\n struct eh_queue {\n   struct eh_node *head;\n   struct eh_node *tail;\n };\n \n \n+extern void expand_eh_region_start\t\tPROTO((void));\n+\n+extern void expand_eh_region_end\t\tPROTO((tree));\n+\n+/* Push RLABEL or TLABEL onto LABELSTACK. Only one of RLABEL or TLABEL\n+   should be set; the other must be NULL.  */\n+\n extern void push_label_entry\t\t\tPROTO((struct label_node **labelstack, rtx rlabel, tree tlabel));\n+\n+/* Pop the topmost entry from LABELSTACK and return its value as an\n+   rtx node. If LABELSTACK is empty, return NULL.  */\n+\n extern rtx pop_label_entry\t\t\tPROTO((struct label_node **labelstack));\n+\n+/* Return the topmost entry of LABELSTACK as a tree node, or return\n+   NULL_TREE if LABELSTACK is empty.  */\n+\n extern tree top_label_entry\t\t\tPROTO((struct label_node **labelstack));\n \n+/* The stack used to keep track of the exception region corresponding to\n+   the current instruction.  */\n+\n extern struct eh_stack ehstack;\n+\n+/* A queue used to track closed exception regions whose handlers have\n+   not been emitted yet.  */\n+\n extern struct eh_queue ehqueue;\n+\n+/* A set of insns for the catch clauses in the current function. They\n+   will be emitted at the end of the current function.  */\n+\n extern rtx catch_clauses;\n-extern tree protect_list;\n \n #endif\n \n struct function;\n \n+/* Toplevel initialization for EH.  */\n+\n extern void init_eh\t\t\t\tPROTO((void));\n+\n+/* Initialization for the per-function EH data.  */\n+\n extern void init_eh_for_function\t\tPROTO((void));\n+\n+/* Saves the current per-function EH data into P.  */\n+\n extern void save_eh_status\t\t\tPROTO((struct function *p));\n+\n+/* Restores the per-function EH data from P.  */\n+\n extern void restore_eh_status\t\t\tPROTO((struct function *p));\n-extern void add_eh_table_entry\t\t\tPROTO((int));\n+\n+/* Adds an EH table entry for EH entry number N. Called from\n+   final_scan_insn for NOTE_INSN_EH_REGION_BEG.  */\n+\n+extern void add_eh_table_entry\t\t\tPROTO((int n));\n+\n+/* Returns a non-zero value if we need to output an exception table.  */\n+\n extern int exception_table_p\t\t\tPROTO((void));\n+\n+/* Outputs the exception table if we have one.  */\n+\n extern void output_exception_table\t\tPROTO((void));\n-extern rtx eh_outer_context\t\t\tPROTO((rtx));\n+\n+/* Given a return address in ADDR, determine the address we should use\n+   to find the corresponding EH region.  */\n+\n+extern rtx eh_outer_context\t\t\tPROTO((rtx addr));\n+\n+/* Called at the start of a block of try statements for which there is\n+   a supplied catch handler.  */\n+\n+extern void expand_start_try_stmts \t\tPROTO((void));\n+\n+/* Called at the start of a block of catch statements. It terminates the\n+   previous set of try statements.  */\n+\n+extern void expand_start_all_catch\t\tPROTO((void));\n+\n+/* Called at the end of a block of catch statements.  */\n+\n+extern void expand_end_all_catch\t\tPROTO((void));\n+\n+#ifdef TREE_CODE\n+/* Create a new exception region and add the handler for the region\n+   onto a list. These regions will be ended (and their handlers\n+   emitted) when end_protect_partials is invoked.  */\n+\n+extern void add_partial_entry\t\t\tPROTO((tree handler));\n+#endif\n+\n+/* End all of the pending exception regions that have handlers added with\n+   push_protect_entry ().  */\n+\n+extern void end_protect_partials\t\tPROTO((void));\n+\n+/* An internal throw with a direct CONTEXT we want to throw\n+   from. CONTEXT must be a label.  */\n+\n+extern void expand_internal_throw\t\tPROTO((rtx context));\n+\n+/* Called from expand_exception_blocks and expand_end_catch_block to\n+   expand and pending handlers.  */\n+\n+extern void expand_leftover_cleanups\t\tPROTO((void));\n+\n+/* If necessary, emit insns for the start of per-function unwinder for\n+   the current function.  */\n+\n extern void emit_unwinder\t\t\tPROTO((void));\n+\n+/* If necessary, emit insns for the end of the per-function unwinder\n+   for the current function.  */\n+\n extern void end_eh_unwinder\t\t\tPROTO((void));\n-extern void find_handler_labels\t\t\tPROTO((void));\n-extern void check_handler_labels\t\tPROTO((void));\n \n+/* Builds a list of handler labels and puts them in the global\n+   variable exception_handler_labels.  */\n+\n+extern void find_exception_handler_labels\tPROTO((void));\n+\n+/* Performs sanity checking on the check_exception_handler_labels\n+   list.  */\n+\n+extern void check_exception_handler_labels\tPROTO((void));\n+\n+/* A stack used to keep track of the label used to resume normal program\n+   flow out of the current exception handler region.  */\n \n extern struct label_node *caught_return_label_stack;\n+\n+/* A random area used for purposes elsewhere.  */\n+\n extern struct label_node *false_label_stack;\n \n+/* A list of labels used for exception handlers. It is created by\n+   find_exception_handler_labels for the optimization passes.  */\n+\n extern rtx exception_handler_labels;\n \n /* The rtx for the saved PC value.  */\n \n extern rtx eh_saved_pc_rtx;\n \n+/* Performs optimizations for exception handling, such as removing\n+   unnecessary exception regions. Invoked from jump_optimize ().  */\n+\n extern void exception_optimize\t\t\tPROTO((void));"}]}