{"sha": "2f8fda1221fc3a98c01e68ca54fc150e198c2575", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY4ZmRhMTIyMWZjM2E5OGMwMWU2OGNhNTRmYzE1MGUxOThjMjU3NQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2015-05-19T17:35:08Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-05-19T17:35:08Z"}, "message": "S/390 Add zvector testcases.\n\ngcc/testsuite/\n\t* gcc.target/s390/zvector/vec-dbl-math-compile-1.c: New test.\n\t* gcc.target/s390/zvector/vec-genbytemask-1.c: New test.\n\t* gcc.target/s390/zvector/vec-genmask-1.c: New test.\n\t* gcc.target/s390/zvector/vec-lcbb-1.c: New test.\n\t* gcc.target/s390/zvector/vec-overloading-1.c: New test.\n\t* gcc.target/s390/zvector/vec-overloading-2.c: New test.\n\t* gcc.target/s390/zvector/vec-overloading-3.c: New test.\n\t* gcc.target/s390/zvector/vec-overloading-4.c: New test.\n\t* gcc.target/s390/zvector/vec-test-mask-1.c: New test.\n\t* gcc.target/s390/zvector/vec-elem-1.c: New test.\n\nFrom-SVN: r223399", "tree": {"sha": "b70188d7486fbbb450114a6c2406219178d538a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b70188d7486fbbb450114a6c2406219178d538a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f8fda1221fc3a98c01e68ca54fc150e198c2575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8fda1221fc3a98c01e68ca54fc150e198c2575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8fda1221fc3a98c01e68ca54fc150e198c2575", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8fda1221fc3a98c01e68ca54fc150e198c2575/comments", "author": null, "committer": null, "parents": [{"sha": "3af82a61fa223fad00f5396b8f0ebb93cde646d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af82a61fa223fad00f5396b8f0ebb93cde646d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3af82a61fa223fad00f5396b8f0ebb93cde646d1"}], "stats": {"total": 404, "additions": 404, "deletions": 0}, "files": [{"sha": "2726dbf47e30749d7d0e659b1f6cf3d99931fb7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -1,3 +1,47 @@\n+2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config.gcc: Add vecintrin.h to extra_headers.  Add s390-c.o to\n+\tc_target_objs and cxx_target_objs.  Add t-s390 to tmake_file.\n+\t* config/s390/s390-builtin-types.def: New file.\n+\t* config/s390/s390-builtins.def: New file.\n+\t* config/s390/s390-builtins.h: New file.\n+\t* config/s390/s390-c.c: New file.\n+\t* config/s390/s390-modes.def: Add modes CCVEQANY, CCVH,\n+\tCCVHANY, CCVHU, CCVHUANY, CCVFHANY, CCVFHEANY.\n+\t* config/s390/s390-protos.h (s390_expand_vec_compare_cc)\n+\t(s390_cpu_cpp_builtins, s390_register_target_pragmas): Add\n+\tprototypes.\n+\t* config/s390/s390.c (s390-builtins.h, s390-builtins.def):\n+\tInclude.\n+\t(flags_builtin, flags_overloaded_builtin_var, s390_builtin_types)\n+\t(s390_builtin_fn_types, s390_builtin_decls, code_for_builtin): New\n+\tvariable definitions.\n+\t(s390_const_operand_ok): New function.\n+\t(s390_expand_builtin): Rewrite.\n+\t(s390_init_builtins): New function.\n+\t(s390_handle_vectorbool_attribute): New function.\n+\t(s390_attribute_table): Add s390_vector_bool attribute.\n+\t(s390_match_ccmode_set): Handle new cc modes CCVH, CCVHU.\n+\t(s390_branch_condition_mask): Generate masks for new modes.\n+\t(s390_expand_vec_compare_cc): New function.\n+\t(s390_mangle_type): Add mangling for vector bool types.\n+\t(enum s390_builtin): Remove.\n+\t(s390_atomic_assign_expand_fenv): Rename constants for sfpc and\n+\tefpc builtins.\n+\t* config/s390/s390.h (TARGET_CPU_CPP_BUILTINS): Call\n+\ts390_cpu_cpp_builtins.\n+\t(REGISTER_TARGET_PRAGMAS): New macro.\n+\t* config/s390/s390.md: Define more UNSPEC_VEC_* constants.\n+\t(insn_cmp mode attribute): Add new CC modes.\n+\t(s390_sfpc, s390_efpc): Rename patterns to sfpc and efpc.\n+\t(lcbb): New pattern definition.\n+\t* config/s390/s390intrin.h: Include vecintrin.h.\n+\t* config/s390/t-s390: New file.\n+\t* config/s390/vecintrin.h: New file.\n+\t* config/s390/vector.md: Include vx-builtins.md.\n+\t* config/s390/vx-builtins.md: New file.S/390 zvector builtin\n+\tsupport.\n+\n 2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390-modes.def: Add new modes CCVEQ, CCVFH, and"}, {"sha": "902d3927a8f96a7d9f336f9ebc46d487df8a2897", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -1,3 +1,16 @@\n+2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/zvector/vec-dbl-math-compile-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-genbytemask-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-genmask-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-lcbb-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-overloading-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-overloading-2.c: New test.\n+\t* gcc.target/s390/zvector/vec-overloading-3.c: New test.\n+\t* gcc.target/s390/zvector/vec-overloading-4.c: New test.\n+\t* gcc.target/s390/zvector/vec-test-mask-1.c: New test.\n+\t* gcc.target/s390/zvector/vec-elem-1.c: New test.\n+\n 2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/vector/vec-scalar-cmp-1.c: New test."}, {"sha": "31b277bf948a297a04e7e92b93e21eb34b3b369c", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-dbl-math-compile-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-dbl-math-compile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-dbl-math-compile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-dbl-math-compile-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector --save-temps\" } */\n+\n+/* { dg-final { scan-assembler-times \"vfcedb\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfchdb\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vfchedb\\t\" 2 } } */\n+\n+/* { dg-final { scan-assembler-times \"vfcedbs\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vfchdbs\\t\" 2 } } */\n+\n+/* { dg-final { cleanup-saved-temps } } */\n+\n+#include <vecintrin.h>\n+\n+vector bool long long\n+cmpeq (vector double a, vector double b)\n+{\n+  return vec_cmpeq (a, b); /* vfcedb */\n+}\n+\n+vector bool long long\n+cmpgt (vector double a, vector double b)\n+{\n+  return vec_cmpgt (a, b); /* vfchdb */\n+}\n+\n+vector bool long long\n+cmpge (vector double a, vector double b)\n+{\n+  return vec_cmpge (a, b); /* vfchedb */\n+}\n+\n+vector bool long long\n+cmplt (vector double a, vector double b)\n+{\n+  return vec_cmplt (a, b); /* vfchdb */\n+}\n+\n+vector bool long long\n+cmple (vector double a, vector double b)\n+{\n+  return vec_cmple (a, b); /* vfchedb */\n+}\n+\n+int\n+all_eq (vector double a, vector double b)\n+{\n+  return vec_all_eq (a, b);\n+}\n+\n+int\n+any_eq (vector double a, vector double b)\n+{\n+  return vec_any_eq (a, b);\n+}\n+\n+int\n+all_lt (vector double a, vector double b)\n+{\n+  return vec_all_lt (a, b);\n+}\n+\n+int\n+any_lt (vector double a, vector double b)\n+{\n+  return vec_any_lt (a, b);\n+}"}, {"sha": "c8578bf80dda69c5a8d95cad86a6bb80c27e9281", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-elem-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-elem-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-elem-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-elem-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector\" } */\n+\n+/* { dg-final { scan-assembler \"nilf\\t%r2,15\" } } */\n+/* { dg-final { scan-assembler \"vlgvb\" } } */\n+\n+signed char\n+foo(unsigned char uc)\n+{\n+  return __builtin_s390_vec_extract((__vector signed char){ 0 }, uc);\n+}"}, {"sha": "09471f8bc5661a502c29f33b19b88f23d495e165", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-genbytemask-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genbytemask-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genbytemask-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genbytemask-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector\" } */\n+\n+#include <vecintrin.h>\n+\n+\n+vector unsigned char a, b, c, d;\n+\n+int\n+foo ()\n+{\n+  a = vec_genmask (0);\n+  b = vec_genmask (65535);\n+  c = vec_genmask (43605);\n+  d = vec_genmask (37830);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vzero\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vone\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgbm\\t%v.*,43605\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgbm\\t%v.*,37830\" 1 } } */"}, {"sha": "745c1ed6eb454679e028a7f11597be171bf20b33", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-genmask-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genmask-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genmask-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-genmask-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector\" } */\n+\n+#include <vecintrin.h>\n+\n+\n+vector unsigned int a, b, c, d, e, f;\n+\n+int\n+foo ()\n+{\n+  a = vec_genmasks_32 (0, 31);\n+  b = vec_genmasks_32 (0, 0);\n+  c = vec_genmasks_32 (31, 31);\n+  d = vec_genmasks_32 (5, 5);\n+  e = vec_genmasks_32 (31, 0);\n+  f = vec_genmasks_32 (6, 5);\n+}\n+/* { dg-final { scan-assembler-times \"vone\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgmf\\t%v.*,0,0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgmf\\t%v.*,31,31\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgmf\\t%v.*,5,5\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vgmf\\t%v.*,31,0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vone\" 1 } } */"}, {"sha": "3588b61a079a2389412a886376d2cf0b315f9a67", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-lcbb-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-lcbb-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-lcbb-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-lcbb-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\tlcbb\\t\" 4 } } */\n+\n+#include <vecintrin.h>\n+\n+/* CC will be extracted into a GPR and returned.  */\n+int\n+foo1 (void *ptr)\n+{\n+  return __lcbb (ptr, 64);\n+}\n+\n+int\n+foo2 (void *ptr)\n+{\n+  return __lcbb (ptr, 128) > 16;\n+}\n+\n+int\n+foo3 (void *ptr)\n+{\n+  return __lcbb (ptr, 256) == 16;\n+}\n+\n+int\n+foo4 (void *ptr)\n+{\n+  return __lcbb (ptr, 512) < 16;\n+}"}, {"sha": "ca3a943735e48589c60e2dff1a26681c835af695", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-overloading-1.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,77 @@\n+/* Test whether overloading works as expected.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-march=z13 -mzarch -mzvector -fdump-tree-original\" } */\n+\n+__vector int var_v4si;\n+__vector unsigned var_uv4si;\n+__vector bool var_bv4si;\n+__vector long long var_v2di;\n+__vector unsigned long long var_uv2di;\n+__vector bool long long var_bv2di;\n+__vector double var_v2df;\n+\n+int *intptr;\n+unsigned *uintptr;\n+double *dblptr;\n+unsigned long long ull;\n+const int *cintptr;\n+long long* llptr;\n+unsigned long long* ullptr;\n+\n+typedef __vector int v4si;\n+typedef __vector unsigned int uv4si;\n+\n+v4si var2_v4si;\n+uv4si var2_uv4si;\n+\n+void\n+foo ()\n+{\n+  __builtin_s390_vec_scatter_element (var_v4si,  var_uv4si, intptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var2_v4si, var2_uv4si, intptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_bv4si, var_uv4si, uintptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_uv4si, var_uv4si, uintptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_v2di,  var_uv2di, llptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_bv2di, var_uv2di, ullptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_uv2di, var_uv2di, ullptr, (unsigned long long)0);\n+  __builtin_s390_vec_scatter_element (var_v2df,  var_uv2di, dblptr, (unsigned long long)0);\n+\n+  /* While the last argument is a int there is a way to convert it to\n+     unsigned long long, so this variant is supposed to match.  */\n+ __builtin_s390_vec_scatter_element (var_v4si,  var_uv4si, intptr, 0);\n+\n+  __builtin_s390_vec_insert_and_zero (intptr);\n+  __builtin_s390_vec_insert_and_zero (cintptr);\n+\n+  __builtin_s390_vec_promote ((signed char)1, 1);\n+  __builtin_s390_vec_promote ((unsigned char)1, 1);\n+  __builtin_s390_vec_promote ((short int)1, 1);\n+  __builtin_s390_vec_promote ((unsigned short int)1, 1);\n+  __builtin_s390_vec_promote ((int)1, 1);\n+  __builtin_s390_vec_promote ((unsigned)1, 1);\n+  __builtin_s390_vec_promote ((long long)1, 1);\n+  __builtin_s390_vec_promote ((unsigned long long)1, 1);\n+  __builtin_s390_vec_promote ((double)1, 1);\n+\n+  /* This is supposed to match vec_promote_s32 */\n+  __builtin_s390_vec_promote (1, (signed char) -1);\n+\n+  /* Constants in C usually are considered int.  */\n+  __builtin_s390_vec_promote (1, 1);\n+\n+  /* And (unsigned) long if they are too big for int.  */\n+  __builtin_s390_vec_promote (1ULL << 32, 1);\n+  __builtin_s390_vec_promote (1LL << 32, 1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vscef \" 5 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vsceg \" 4 \"original\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vllezf \" 2 \"original\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vlvgb_noin \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vlvgh_noin \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vlvgf_noin \" 4 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vlvgg_noin \" 4 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_s390_vlvgg_dbl_noin \" 1 \"original\" } } */"}, {"sha": "fd66e02b59d1338483f3facd9325e3490d10f9fa", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-overloading-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-2.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,54 @@\n+/* Test whether overloading works as expected.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-march=z13 -mzarch -mzvector\" } */\n+\n+__vector int v4si;\n+__vector unsigned uv4si;\n+__vector bool bv4si;\n+__vector long long v2di;\n+__vector unsigned long long uv2di;\n+__vector bool long long bv2di;\n+__vector double v2df;\n+int *intptr;\n+unsigned *uintptr;\n+double *dblptr;\n+long long ll;\n+unsigned long long ull;\n+const int *cintptr;\n+long long* llptr;\n+unsigned long long* ullptr;\n+\n+void\n+foo ()\n+{\n+  __builtin_s390_vec_scatter_element (v4si,  uv4si, (int*)0, 0); /* ok */\n+  __builtin_s390_vec_insert_and_zero (intptr); /* ok */\n+\n+  /* The unsigned pointer must not match the signed pointer.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, uintptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* Make sure signed int pointers don't match unsigned int pointers.  */\n+  __builtin_s390_vec_scatter_element (bv4si, uv4si, intptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* Const pointers do not match unqualified operands.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, cintptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* Volatile pointers do not match unqualified operands.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, cintptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* The third operands needs to be double *.  */\n+  __builtin_s390_vec_scatter_element (v2df, uv4si, intptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* This is an ambigious overload.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, 0, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* Pointer to vector must not match.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, &v4si, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  /* Don't accept const int* for int*.  */\n+  __builtin_s390_vec_scatter_element (v4si,  uv4si, cintptr, 0); /* { dg-error \"invalid parameter combination for intrinsic\" } */\n+\n+  __builtin_s390_vec_load_pair (ll, ull); /* { dg-error \"ambiguous overload for intrinsic\" } */\n+  __builtin_s390_vec_load_pair (ull, ll); /* { dg-error \"ambiguous overload for intrinsic\" } */\n+}"}, {"sha": "761e5b6d36733cb9fe5d80ca7f4144e1045759d8", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-overloading-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-3.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,19 @@\n+/* Check for error messages supposed to be issued during overloading.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-march=z13 -mzarch -mzvector\" } */\n+\n+__vector int v4si;\n+__vector unsigned uv4si;\n+\n+int *intptr;\n+unsigned long long ull;\n+const unsigned int *ucintptr;\n+\n+void\n+foo ()\n+{\n+  /* A backend check makes sure the forth operand is a literal.  */\n+  __builtin_s390_vec_gather_element (uv4si, uv4si, ucintptr, 256); /* { dg-error \"constant argument 4 for builtin.*is out of range for target type\" } */\n+  __builtin_s390_vec_gather_element (uv4si, uv4si, ucintptr, 5); /* { dg-error \"constant argument 4 for builtin.*is out of range\" } */\n+}"}, {"sha": "66912f97985d3c51757866b308eb6e6a812caff5", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-overloading-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-overloading-4.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,18 @@\n+/* Check for error messages supposed to be issued during builtin expansion.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-march=z13 -mzarch -mzvector\" } */\n+\n+__vector int v4si;\n+__vector unsigned uv4si;\n+\n+int *intptr;\n+unsigned long long ull;\n+const unsigned int *ucintptr;\n+\n+void\n+foo ()\n+{\n+  /* A backend check makes sure the forth operand is a literal.  */\n+  __builtin_s390_vec_scatter_element (v4si, uv4si, intptr, ull); /* { dg-error \"constant value required for builtin\" } */\n+}"}, {"sha": "418d5b20f51b7c6cdc9fc783b13fe858bb0f785c", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec-test-mask-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-test-mask-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8fda1221fc3a98c01e68ca54fc150e198c2575/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-test-mask-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec-test-mask-1.c?ref=2f8fda1221fc3a98c01e68ca54fc150e198c2575", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13 -mzvector\" } */\n+\n+/* { dg-final { scan-assembler-times \"vtm\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ipm\" 1 } } */\n+\n+#include <vecintrin.h>\n+\n+/* CC will be extracted into a GPR and returned.  */\n+int\n+foo (vector unsigned int a, vector unsigned b)\n+{\n+  return vec_test_mask (a, b);\n+}\n+\n+extern void baz (void);\n+\n+/* In that case the ipm/srl is supposed to optimized out by\n+   combine/s390_canonicalize_comparison.  */\n+int\n+bar (vector unsigned int a, vector unsigned b)\n+{\n+  if (vec_test_mask (a, b) == 2)\n+    baz ();\n+}"}]}