{"sha": "4d6922ee327a1a5c4a6bbf974186a34355464df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2OTIyZWUzMjdhMWE1YzRhNmJiZjk3NDE4NmEzNDM1NTQ2NGRmOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-05T15:17:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-05T15:17:36Z"}, "message": "bt-load.c: Fix comment typos.\n\n\t* bt-load.c: Fix comment typos.\n\t* c-incpath.c: Likewise.\n\t* cfg.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfgloop.h: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* dwarfout.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* et-forest.c: Likewise.\n\t* et-forest.h: Likewise.\n\t* expr.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattr.c: Likewise.\n\t* jump.c: Likewise.\n\t* langhooks.h: Likewise.\n\t* local-alloc.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* loop-unswitch.c: Likewise.\n\t* ra-build.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* rtl.def: Likewise.\n\t* rtlanal.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* ssa.c: Likewise.\n\t* tracer.c: Likewise.\n\t* tree.c: Likewise.\n\nFrom-SVN: r68975", "tree": {"sha": "a2dfd9ba34b919d888653777fd366320e2e0fccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2dfd9ba34b919d888653777fd366320e2e0fccd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6922ee327a1a5c4a6bbf974186a34355464df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6922ee327a1a5c4a6bbf974186a34355464df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6922ee327a1a5c4a6bbf974186a34355464df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6922ee327a1a5c4a6bbf974186a34355464df9/comments", "author": null, "committer": null, "parents": [{"sha": "f1c4bc4fccc9966ace2dc89e430e935448ec3f65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c4bc4fccc9966ace2dc89e430e935448ec3f65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c4bc4fccc9966ace2dc89e430e935448ec3f65"}], "stats": {"total": 106, "additions": 70, "deletions": 36}, "files": [{"sha": "a1e122751972406ece66ca7a961e475ac091302d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -1,3 +1,37 @@\n+2003-07-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* bt-load.c: Fix comment typos.\n+\t* c-incpath.c: Likewise.\n+\t* cfg.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* dwarfout.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* et-forest.c: Likewise.\n+\t* et-forest.h: Likewise.\n+\t* expr.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattr.c: Likewise.\n+\t* jump.c: Likewise.\n+\t* langhooks.h: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* loop-unswitch.c: Likewise.\n+\t* ra-build.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* rtl.def: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* tracer.c: Likewise.\n+\t* tree.c: Likewise.\n+\n 2003-07-05  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cppcharset.c: Use the correct return type for the fallback iconv"}, {"sha": "4bcf76c3f224a2c0ac6f0b927b81b85e8b4a9a92", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -1157,7 +1157,7 @@ can_move_up (basic_block bb, rtx insn, int n_insns)\n    MIN_COST is the lower bound on the cost of the DEF after migration.\n    If we migrate DEF so that its cost falls below MIN_COST,\n    then we do not attempt to migrate further.  The idea is that\n-   we migrate defintions in a priority order based on their cost,\n+   we migrate definitions in a priority order based on their cost,\n    when the cost of this definition falls below MIN_COST, then\n    there is another definition with cost == MIN_COST which now\n    has a higher priority than this definition."}, {"sha": "efcd19b5ea5b9a8402a6a9968b22908e67050087", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -208,7 +208,7 @@ remove_duplicates (cpp_reader *pfile, struct cpp_path *head,\n \n \t  if (!tmp)\n \t    {\n-\t      /* Dupicate of something earlier in the same chain?  */\n+\t      /* Duplicate of something earlier in the same chain?  */\n \t      reason = REASON_DUP;\n \t      for (tmp = head; tmp != cur; tmp = tmp->next)\n \t\tif (INO_T_EQ (cur->ino, tmp->ino) && cur->dev == tmp->dev)"}, {"sha": "ba4dd812a64b1b3d40b912c4999f8b2cc9303596", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -20,7 +20,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* This file contains low level functions to manipulate the CFG and\n-   analyze it.  All other modules should not transform the datastructure\n+   analyze it.  All other modules should not transform the data structure\n    directly and use abstraction instead.  The file is supposed to be\n    ordered bottom-up and should not contain any code dependent on a\n    particular intermediate language (RTL or trees)."}, {"sha": "7dbed9b970549fe9f721da5a6516555c82c1ba87", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -769,7 +769,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n \n    It may be good idea to return basic block before C in the case\n    C has been moved after B and originally appeared earlier in the\n-   insn seqeunce, but we have no infromation available about the\n+   insn sequence, but we have no information available about the\n    relative ordering of these two.  Hopefully it is not too common.  */\n \n static basic_block"}, {"sha": "e879e5220315abd1855797c4e5d6a2eb251fd1e1", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -266,7 +266,7 @@ extern int flow_loop_scan (struct loops *, struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n \n-/* Loop datastructure manipulation/querying.  */\n+/* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n extern void flow_loop_tree_node_remove (struct loop *);\n extern bool flow_loop_outside_edge_p (const struct loop *, edge);"}, {"sha": "8892720069d36330737b47646e0d96255d29a9ce", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -169,7 +169,7 @@ fix_bb_placement (struct loops *loops, basic_block bb)\n    his placement no longer has to be correct, and iteratively fix placement of\n    its predecessors that may change if placement of FROM changed.  Also fix\n    placement of subloops of FROM->loop_father, that might also be altered due\n-   to this change; the condition for them is simmilar, except that instead of\n+   to this change; the condition for them is similar, except that instead of\n    successors we consider edges coming out of the loops.  */\n static void\n fix_bb_placements (struct loops *loops, basic_block from)"}, {"sha": "09e2e1c93951500b0e0056c4f1a996bff4a46913", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -1340,7 +1340,7 @@ rtl_split_edge (edge edge_in)\n \n   make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n \n-  /* For non-fallthry edges, we must adjust the predecessor's\n+  /* For non-fallthru edges, we must adjust the predecessor's\n      jump instruction to target our new block.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {"}, {"sha": "cd0cebaf1bd5bf7da790a109f2aba8a12e53d1f2", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -34,7 +34,7 @@ typedef struct\n   int err_no;  /* for %m */\n } text_info;\n \n-/* Contants used to discriminate diagnostics.  */\n+/* Constants used to discriminate diagnostics.  */\n typedef enum\n {\n #define DEFINE_DIAGNOSTIC_KIND(K, M) K,  "}, {"sha": "caed460664354847be0088808d2569c7ef6b3017", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -2182,7 +2182,7 @@ output_loc_descriptor (rtx rtl)\n \n /* Given a tree node describing an array bound (either lower or upper)\n    output a representation for that bound.  DIM_NUM is used for\n-   multi-dimensional arrays and U_OR_L disgnates upper or lower\n+   multi-dimensional arrays and U_OR_L designates upper or lower\n    bound.  */\n \n static void"}, {"sha": "d191b286bb34fb800f236256610480ddab7f4029", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -912,7 +912,7 @@ set_decl_rtl (tree t, rtx x)\n \n   if (!x)\n     return;\n-  /* For register, we maitain the reverse information too.  */\n+  /* For register, we maintain the reverse information too.  */\n   if (GET_CODE (x) == REG)\n     REG_ATTRS (x) = get_reg_attrs (t, 0);\n   else if (GET_CODE (x) == SUBREG)\n@@ -2241,7 +2241,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n   new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n \n   /* At this point we don't know _why_ the address is invalid.  It\n-     could have secondary memory refereces, multiplies or anything.\n+     could have secondary memory references, multiplies or anything.\n \n      However, if we did go and rearrange things, we can wind up not\n      being able to recognize the magic around pic_offset_table_rtx."}, {"sha": "ffdce1d76bd75c3dc019f8cbfa6e945a05d00489", "filename": "gcc/et-forest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -1,4 +1,4 @@\n-/* ET-trees datastructure implementation.\n+/* ET-trees data structure implementation.\n    Contributed by Pavel Nejedly\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n "}, {"sha": "66aec4897c0d55a7693c0f2a15fb09793f95287b", "filename": "gcc/et-forest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -20,7 +20,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    for tree operations (insertion and removal of nodes and edges) and\n    poly-logarithmic time for nearest common ancestor.\n \n-   ET tree strores its structue as a sequence of symbols obtained\n+   ET tree stores its structue as a sequence of symbols obtained\n    by dfs(root)\n \n    dfs (node)"}, {"sha": "eedf68c1018d19a3d9f2689223bd7d796c7755ff", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -4398,7 +4398,7 @@ store_expr (tree exp, rtx target, int want_value)\n     {\n       /* C++ can generate ?: expressions with a throw expression in one\n \t branch and an rvalue in the other. Here, we resolve attempts to\n-\t store the throw expression's nonexistant result.  */\n+\t store the throw expression's nonexistent result.  */\n       if (want_value)\n \tabort ();\n       expand_expr (exp, const0_rtx, VOIDmode, 0);"}, {"sha": "5525ffe95afc744641299c9aa40e6e03f74a715d", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -5327,7 +5327,7 @@ insert_insn_end_bb (expr, bb, pre)\n     pat_end = NEXT_INSN (pat_end);\n \n   /* If the last insn is a jump, insert EXPR in front [taking care to\n-     handle cc0, etc. properly].  Similary we need to care trapping\n+     handle cc0, etc. properly].  Similarly we need to care trapping\n      instructions in presence of non-call exceptions.  */\n \n   if (GET_CODE (insn) == JUMP_INSN"}, {"sha": "cccacba3915ee764c83d5af290f8204c6a488f1c", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -165,7 +165,7 @@ write_units (int num_units, struct range *multiplicity, struct range *simultanei\n   printf (\"#define BLOCKAGE_BITS %d\\n\", i + 1);\n \n   /* INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n-     MAX_READY_COST.  This is the longest time an isnsn may be queued.  */\n+     MAX_READY_COST.  This is the longest time an insn may be queued.  */\n   i = MAX (blockage->max, ready_cost->max);\n   for (q_size = 1; q_size <= i; q_size <<= 1)\n     ;"}, {"sha": "adf3fdbd7e8b4348599d1de25ce046c062ea2340", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -681,7 +681,7 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n     case NE:\n     case EQ:\n       /* It is always safe to reverse EQ and NE, even for the floating\n-\t point.  Similary the unsigned comparisons are never used for\n+\t point.  Similarly the unsigned comparisons are never used for\n \t floating point so we can reverse them in the default way.  */\n       return reverse_condition (code);\n     case ORDERED:"}, {"sha": "d0abc298d949e7f9fce37ae2efef9c171d37c1f7", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -211,7 +211,7 @@ struct lang_hooks\n \n   /* Handle the switch CODE, which has real type enum opt_code from\n      options.h.  If the switch takes an argument, it is passed in ARG\n-     which points to permanent storage.  The handler is resonsible for\n+     which points to permanent storage.  The handler is responsible for\n      checking whether ARG is NULL, which indicates that no argument\n      was in fact supplied.  For -f and -W switches, VALUE is 1 or 0\n      for the positive and negative forms respectively."}, {"sha": "3881e408587a3c4e6375542b95b0def88849251c", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -922,7 +922,7 @@ update_equiv_regs ()\n \t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n \t\t  && GET_CODE (src) == MEM))\n \t    {\n-\t      /* This might be seting a SUBREG of a pseudo, a pseudo that is\n+\t      /* This might be setting a SUBREG of a pseudo, a pseudo that is\n \t\t also set somewhere else to a constant.  */\n \t      note_stores (set, no_equiv, NULL);\n \t      continue;\n@@ -1035,7 +1035,7 @@ update_equiv_regs ()\n      registers only used that once.  If so, see if we can replace the\n      reference with the equivalent from.  If we can, delete the\n      initializing reference and this register will go away.  If we\n-     can't replace the reference, and the initialzing reference is\n+     can't replace the reference, and the initializing reference is\n      within the same loop (or in an inner loop), then move the register\n      initialization just before the use, so that they are in the same\n      basic block.  */"}, {"sha": "a0f253b9f0f14fae8dd1f518c9d95071ae28a28a", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    optimizations on innermost loops (with single exception) because\n    the impact on performance is greatest here, and we want to avoid\n    unnecessary code size growth.  The gain is caused by greater sequentiality\n-   of code, better code to optimize for futher passes and in some cases\n+   of code, better code to optimize for further passes and in some cases\n    by fewer testings of exit conditions.  The main problem is code growth,\n    that impacts performance negatively due to effect of caches.\n "}, {"sha": "05ac83eaa913014bdcf4c2664ef2e0a05657f876", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -410,7 +410,7 @@ unswitch_loop (loops, loop, unswitch_on)\n   remove_path (loops, unswitch_on_alt->succ);\n \n   /* One of created loops do not have to be subloop of the outer loop now,\n-     so fix its placement in loop datastructure.  */\n+     so fix its placement in loop data structure.  */\n   fix_loop_placement (loop);\n   fix_loop_placement (nloop);\n "}, {"sha": "e6f846aea59354955374b5000c47750406a50443", "filename": "gcc/ra-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -667,7 +667,7 @@ defuse_overlap_p_1 (def, use)\n \t     if they refer to the same word.  */\n \t  if (SUBREG_BYTE (def) == SUBREG_BYTE (use->x))\n \t    return 1;\n-\t/* Now the more difficult part: the same regno is refered, but the\n+\t/* Now the more difficult part: the same regno is referred, but the\n \t   sizes of the references or the words differ.  E.g.\n            (subreg:SI (reg:CDI a) 0) and (subreg:DI (reg:CDI a) 2) do not\n \t   overlap, whereas the latter overlaps with (subreg:SI (reg:CDI a) 3)."}, {"sha": "32ef9cc7125d8aa185f47796afcecbdabf6e2bb3", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -1828,7 +1828,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n      we may want to adjust the cost of that register class to -1.\n \n      Avoid the adjustment if the source does not die to avoid stressing of\n-     register allocator by preferrencing two coliding registers into single\n+     register allocator by preferrencing two colliding registers into single\n      class.\n \n      Also avoid the adjustment if a copy between registers of the class"}, {"sha": "bdd7ae88f4306f71de4ba0b9aa32369d4aedc625", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -2070,7 +2070,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n }\n \n \n-/* return nonzero if X is stable and mentions no regsiters but for\n+/* return nonzero if X is stable and mentions no registers but for\n    mentioning SRC or mentioning / changing DST .  If in doubt, presume\n    it is unstable.\n    The rationale is that we want to check if we can move an insn easily"}, {"sha": "54b6940e780d5f8b818e8a77668fcff37e9f10ae", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -528,7 +528,7 @@ DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n        first regular expression *and* the reservation described by the\n        second regular expression *and* etc.\n \n-       4. \"*\" is used for convinience and simply means sequence in\n+       4. \"*\" is used for convenience and simply means sequence in\n        which the regular expression are repeated NUMBER times with\n        cycle advancing (see \",\").\n "}, {"sha": "de228e39431e67d38fdfdac67689cd4e372e61e2", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -3693,7 +3693,7 @@ can_hoist_insn_p (insn, val, live)\n \t      break;\n \t    case USE:\n \t      /* We need to fix callers to really ensure availability\n-\t         of all values inisn uses, but for now it is safe to prohibit\n+\t         of all values insn uses, but for now it is safe to prohibit\n \t\t hoisting of any insn having such a hidden uses.  */\n \t      return false;\n \t      break;"}, {"sha": "7f4486636f3f2696aa257682ba130db4d5eac942", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -290,7 +290,7 @@ fix_basic_block_boundaries (bb, last, head, tail)\n \t         it by splitting the edge and repositioning the block.\n \t         This is somewhat hackish, but at least avoid cut&paste \n \n-\t         Safter sollution can be to bring the code into sequence,\n+\t         A safer solution can be to bring the code into sequence,\n \t         do the split and re-emit it back in case this will ever\n \t         trigger problem.  */\n \t      f = bb->prev_bb->succ;\n@@ -410,7 +410,7 @@ earliest_block_with_similiar_load (last_block, load_insn)\n   return earliest_block;\n }\n \n-/* The following function adds dependecies between jumps and risky\n+/* The following function adds dependencies between jumps and risky\n    insns in given ebb.  */\n \n static void"}, {"sha": "8310243a24ce36e6b090c65c0cc628d7067fb3a4", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -142,7 +142,7 @@ static int *rgn_bb_table;\n /* Topological order of blocks in the region (if b2 is reachable from\n    b1, block_to_bb[b2] > block_to_bb[b1]).  Note: A basic block is\n    always referred to by either block or b, while its topological\n-   order name (in the region) is refered to by bb.  */\n+   order name (in the region) is referred to by bb.  */\n static int *block_to_bb;\n \n /* The number of the region containing a block.  */"}, {"sha": "0b584aeed59580f8ad33d62d17da3ef077a8ff33", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -2897,7 +2897,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t    return NULL_RTX;\n \t}\n \n-      /* Recurse for futher possible simplifications.  */\n+      /* Recurse for further possible simplifications.  */\n       new = simplify_subreg (outermode, SUBREG_REG (op),\n \t\t\t     GET_MODE (SUBREG_REG (op)),\n \t\t\t     final_offset);"}, {"sha": "af5f23194e19373937608bcf9339a1922e760465", "filename": "gcc/ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -142,7 +142,7 @@ static void ssa_rename_from_free\n typedef int (*srf_trav) PARAMS ((int regno, rtx r, sbitmap canonical_elements, partition reg_partition));\n static void ssa_rename_from_traverse\n   PARAMS ((htab_trav callback_function, sbitmap canonical_elements, partition reg_partition));\n-/*static Avoid warnign message.  */ void ssa_rename_from_print\n+/*static Avoid warning message.  */ void ssa_rename_from_print\n   PARAMS ((void));\n static int ssa_rename_from_print_1\n   PARAMS ((void **slot, void *data));\n@@ -360,7 +360,7 @@ ssa_rename_from_print ()\n }\n \n /* Print the contents of the hash table entry SLOT, passing the unused\n-   sttribute DATA.  Used as a callback function with htab_traverse ().  */\n+   attribute DATA.  Used as a callback function with htab_traverse ().  */\n \n static int\n ssa_rename_from_print_1 (slot, data)\n@@ -1568,7 +1568,7 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n }\n \n /* Consider phi insns in basic block BB pairwise.  If the set target\n-   of both isns are equivalent pseudos, make the corresponding phi\n+   of both insns are equivalent pseudos, make the corresponding phi\n    alternatives in each phi corresponding equivalent.\n \n    Return nonzero if any new register classes were unioned.  */"}, {"sha": "a0164ddfcfc92e8fc588e9c29c0ce238f00c6b40", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -316,7 +316,7 @@ tail_duplicate ()\n   fibheap_delete (heap);\n }\n \n-/* Connect the superblocks into linear seuqence.  At the moment we attempt to keep\n+/* Connect the superblocks into linear sequence.  At the moment we attempt to keep\n    the original order as much as possible, but the algorithm may be made smarter\n    later if needed.  BB reordering pass should void most of the benefits of such\n    change though.  */"}, {"sha": "6473871d84cb66f76d01cd0b6a33cc842aa8d4da", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6922ee327a1a5c4a6bbf974186a34355464df9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4d6922ee327a1a5c4a6bbf974186a34355464df9", "patch": "@@ -5080,7 +5080,7 @@ build_common_tree_nodes_2 (short_double)\n     tree t;\n     BUILD_VA_LIST_TYPE (t);\n \n-    /* Many back-ends define record types without seting TYPE_NAME.\n+    /* Many back-ends define record types without setting TYPE_NAME.\n        If we copied the record type here, we'd keep the original\n        record type without a name.  This breaks name mangling.  So,\n        don't copy record types and let c_common_nodes_and_builtins()"}]}