{"sha": "f8ece0008540563127461c1c431ab2df0b7597a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlY2UwMDA4NTQwNTYzMTI3NDYxYzFjNDMxYWIyZGYwYjc1OTdhMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-05-12T11:43:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-05-12T11:43:05Z"}, "message": "sparc.h: Remove dead code.\n\n\t* config/sparc/sparc.h: Remove dead code.\n\t* config/sparc/sparc.c (sparc_compute_frame_size): Use\n\tFIRST_PARM_OFFSET for the size of the register window area.\n\t(emit_save_regs): Rename into emit_save_or_restore_regs.\n\tAdd 'action' parameter.  Use 4095 as upper bound for the offset.\n\tPass 'action' to save_or_restore_regs.\n\t(emit_restore_regs): Delete.\n\t(sparc_expand_prologue): Call emit_save_or_restore_regs.\n\t(sparc_expand_epilogue): Likewise.\n\t* config/sparc/sparc.md (mode macro P): Move.\n\t(movdi_insn_sp32_v9, movdi_insn_sp32): Swap.\n\t(mov<V32:mode> expander): Move to the top of the V32 section.\n\t(movdf_insn_sp32_v9_no_fpu, movdf_insn_sp32_v9): Swap.\n\t(movtf_insn_sp64_hq, movtf_insn_sp64): Swap.\n\t(sibcall_epilogue): Move.\n\nFrom-SVN: r99609", "tree": {"sha": "e0a8309419bcb4da709beb254bb4cfebd815dc99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0a8309419bcb4da709beb254bb4cfebd815dc99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8ece0008540563127461c1c431ab2df0b7597a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ece0008540563127461c1c431ab2df0b7597a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ece0008540563127461c1c431ab2df0b7597a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ece0008540563127461c1c431ab2df0b7597a0/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa2c88a05bc12d885de1ece297c8f0c2b2cdde43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2c88a05bc12d885de1ece297c8f0c2b2cdde43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa2c88a05bc12d885de1ece297c8f0c2b2cdde43"}], "stats": {"total": 420, "additions": 214, "deletions": 206}, "files": [{"sha": "11b87280666e49a101ccd161a19ed3893c1a60c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8ece0008540563127461c1c431ab2df0b7597a0", "patch": "@@ -1,3 +1,21 @@\n+2005-05-12  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.h: Remove dead code.\n+\t* config/sparc/sparc.c (sparc_compute_frame_size): Use\n+\tFIRST_PARM_OFFSET for the size of the register window area.\n+\t(emit_save_regs): Rename into emit_save_or_restore_regs.\n+\tAdd 'action' parameter.  Use 4095 as upper bound for the offset.\n+\tPass 'action' to save_or_restore_regs.\n+\t(emit_restore_regs): Delete.\n+\t(sparc_expand_prologue): Call emit_save_or_restore_regs.\n+\t(sparc_expand_epilogue): Likewise.\n+\t* config/sparc/sparc.md (mode macro P): Move.\n+\t(movdi_insn_sp32_v9, movdi_insn_sp32): Swap.\n+\t(mov<V32:mode> expander): Move to the top of the V32 section.\n+\t(movdf_insn_sp32_v9_no_fpu, movdf_insn_sp32_v9): Swap.\n+\t(movtf_insn_sp64_hq, movtf_insn_sp64): Swap.\n+\t(sibcall_epilogue): Move.\n+\n 2005-05-12  Richard Earnshaw  <richard.earnshaw@arm.com>\n \n \tPR target/21501"}, {"sha": "2ab08fde5d6f109655f319d420c2e10310a5bf2f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f8ece0008540563127461c1c431ab2df0b7597a0", "patch": "@@ -318,8 +318,7 @@ static int set_extends (rtx);\n static void emit_pic_helper (void);\n static void load_pic_register (bool);\n static int save_or_restore_regs (int, int, rtx, int, int);\n-static void emit_save_regs (void);\n-static void emit_restore_regs (void);\n+static void emit_save_or_restore_regs (int);\n static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n #ifdef OBJECT_FORMAT_ELF\n@@ -3508,10 +3507,9 @@ sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n \n   /* Make sure nothing can clobber our register windows.\n      If a SAVE must be done, or there is a stack-local variable,\n-     the register window area must be allocated.\n-     ??? For v8 we apparently need an additional 8 bytes of reserved space.  */\n+     the register window area must be allocated.  */\n   if (! leaf_function_p || size > 0)\n-    actual_fsize += (16 * UNITS_PER_WORD) + (TARGET_ARCH64 ? 0 : 8);\n+    actual_fsize += FIRST_PARM_OFFSET (current_function_decl);\n \n   return SPARC_STACK_ALIGN (actual_fsize);\n }\n@@ -3623,14 +3621,14 @@ save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n /* Emit code to save call-saved registers.  */\n \n static void\n-emit_save_regs (void)\n+emit_save_or_restore_regs (int action)\n {\n   HOST_WIDE_INT offset;\n   rtx base;\n \n   offset = frame_base_offset - apparent_fsize;\n \n-  if (offset < -4096 || offset + num_gfregs * 4 > 4096)\n+  if (offset < -4096 || offset + num_gfregs * 4 > 4095)\n     {\n       /* ??? This might be optimized a little as %g1 might already have a\n \t value close enough that a single add insn will do.  */\n@@ -3648,34 +3646,8 @@ emit_save_regs (void)\n   else\n     base = frame_base_reg;\n \n-  offset = save_or_restore_regs (0, 8, base, offset, SORR_SAVE);\n-  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, SORR_SAVE);\n-}\n-\n-/* Emit code to restore call-saved registers.  */\n-\n-static void\n-emit_restore_regs (void)\n-{\n-  HOST_WIDE_INT offset;\n-  rtx base;\n-\n-  offset = frame_base_offset - apparent_fsize;\n-\n-  if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n-    {\n-      base = gen_rtx_REG (Pmode, 1);\n-      emit_move_insn (base, GEN_INT (offset));\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      base,\n-\t\t\t      gen_rtx_PLUS (Pmode, frame_base_reg, base)));\n-      offset = 0;\n-    }\n-  else\n-    base = frame_base_reg;\n-\n-  offset = save_or_restore_regs (0, 8, base, offset, SORR_RESTORE);\n-  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, SORR_RESTORE);\n+  offset = save_or_restore_regs (0, 8, base, offset, action);\n+  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, action);\n }\n \n /* Generate a save_register_window insn.  */\n@@ -3814,22 +3786,16 @@ sparc_expand_prologue (void)\n         RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, i)) = 1;\n     }\n \n-  /* Call-saved registers are saved just above the outgoing argument area.  */\n   if (num_gfregs)\n-    emit_save_regs ();\n+    emit_save_or_restore_regs (SORR_SAVE);\n \n   /* Load the PIC register if needed.  */\n   if (flag_pic && current_function_uses_pic_offset_table)\n     load_pic_register (false);\n }\n  \n /* This function generates the assembly code for function entry, which boils\n-   down to emitting the necessary .register directives.\n-\n-   ??? Historical cruft: \"On SPARC, move-double insns between fpu and cpu need\n-   an 8-byte block of memory.  If any fpu reg is used in the function, we\n-   allocate such a block here, at the bottom of the frame, just in case it's\n-   needed.\"  Could this explain the -8 in emit_restore_regs?  */\n+   down to emitting the necessary .register directives.  */\n \n static void\n sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n@@ -3847,7 +3813,7 @@ void\n sparc_expand_epilogue (void)\n {\n   if (num_gfregs)\n-    emit_restore_regs ();\n+    emit_save_or_restore_regs (SORR_RESTORE);\n \n   if (actual_fsize == 0)\n     /* do nothing.  */ ;"}, {"sha": "0e0aea211ff477139a6e3129c27150327dcdddfe", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f8ece0008540563127461c1c431ab2df0b7597a0", "patch": "@@ -906,9 +906,6 @@ extern int sparc_mode_class[];\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n-/* SPARC pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 14\n \n@@ -1375,16 +1372,12 @@ extern char leaf_reg_remap[];\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n    of the first local allocated.  */\n-/* This allows space for one TFmode floating point value.  */\n+/* This allows space for one TFmode floating point value, which is used\n+   by SECONDARY_MEMORY_NEEDED_RTX.  */\n #define STARTING_FRAME_OFFSET \\\n   (TARGET_ARCH64 ? -16 \\\n    : (-SPARC_STACK_ALIGN (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)))\n \n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On SPARC, don't define this because there are no push insns.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n /* Offset of first parameter from the argument pointer register value.\n    !v9: This is 64 for the ins and locals, plus 4 for the struct-return reg\n    even if this function isn't going to use it."}, {"sha": "6b7045d5069a289c92aea11791eaa605db092b3f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 184, "deletions": 153, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ece0008540563127461c1c431ab2df0b7597a0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f8ece0008540563127461c1c431ab2df0b7597a0", "patch": "@@ -68,14 +68,13 @@\n    (UNSPECV_SAVEW\t\t6)\n   ])\n \n-(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n-\n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n ;; a second register class, EXTRA_FP_REGS, exists for the v9 chip.  The name\n ;; is a bit of a misnomer as it covers all 64 fp regs.  The corresponding\n ;; constraint letter is 'e'.  To avoid any confusion, 'e' is used instead of\n ;; 'f' for all DF/TFmode values, including those that are specific to the v8.\n \n+\n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n (define_attr \"cpu\"\n@@ -300,6 +299,7 @@\n (define_delay (eq_attr \"type\" \"return\")\n   [(eq_attr \"eligible_for_return_delay\" \"true\") (nil) (nil)])\n \n+\n ;; Include SPARC DFA schedulers\n \n (include \"cypress.md\")\n@@ -309,6 +309,7 @@\n (include \"ultra1_2.md\")\n (include \"ultra3.md\")\n \n+\n ;; Operand and operator predicates.\n \n (include \"predicates.md\")\n@@ -329,8 +330,6 @@\n ;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n ;; insns that actually require more than one machine instruction.\n \n-;; Put cmpsi first among compare insns so it matches two CONST_INT operands.\n-\n (define_expand \"cmpsi\"\n   [(set (reg:CC 100)\n \t(compare:CC (match_operand:SI 0 \"compare_operand\" \"\")\n@@ -1694,7 +1693,10 @@\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"reg\")])\n-\f\n+\n+\n+(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+\n ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic\n ;; value subject to a PC-relative relocation.  Operand 2 is a helper function\n ;; that adds the PC value at the call point to operand 0.\n@@ -1716,8 +1718,9 @@\n \t(if_then_else (eq_attr \"delayed_branch\" \"true\")\n \t\t      (const_int 3)\n \t\t      (const_int 4)))])\n-\f\n-;; Move instructions\n+\n+\n+;; Integer move instructions\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -2121,17 +2124,15 @@\n ;;      (reg:DI 2 %g2))\n ;;\n \n-(define_insn \"*movdi_insn_sp32_v9\"\n+(define_insn \"*movdi_insn_sp32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\t\"=T,o,T,U,o,r,r,r,?T,?f,?f,?o,?e,?e,?W\")\n+\t\t\t\t\"=o,T,U,o,r,r,r,?T,?f,?f,?o,?f\")\n         (match_operand:DI 1 \"input_operand\"\n-\t\t\t\t\t\" J,J,U,T,r,o,i,r, f, T, o, f, e, W, e\"))]\n-  \"! TARGET_ARCH64\n-   && TARGET_V9\n+\t\t\t\t\" J,U,T,r,o,i,r, f, T, o, f, f\"))]\n+  \"! TARGET_V9\n    && (register_operand (operands[0], DImode)\n-       || register_or_zero_operand (operands[1], DImode))\"\n+       || register_operand (operands[1], DImode))\"\n   \"@\n-   stx\\t%%g0, %0\n    #\n    std\\t%1, %0\n    ldd\\t%1, %0\n@@ -2143,22 +2144,21 @@\n    ldd\\t%1, %0\n    #\n    #\n-   fmovd\\\\t%1, %0\n-   ldd\\\\t%1, %0\n-   std\\\\t%1, %0\"\n-  [(set_attr \"type\" \"store,store,store,load,*,*,*,*,fpstore,fpload,*,*,fpmove,fpload,fpstore\")\n-   (set_attr \"length\" \"*,2,*,*,2,2,2,2,*,*,2,2,*,*,*\")\n-   (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*\")])\n+   #\"\n+  [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n+   (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n \n-(define_insn \"*movdi_insn_sp32\"\n+(define_insn \"*movdi_insn_sp32_v9\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=o,T,U,o,r,r,r,?T,?f,?f,?o,?f\")\n+\t\t\t\t\t\"=T,o,T,U,o,r,r,r,?T,?f,?f,?o,?e,?e,?W\")\n         (match_operand:DI 1 \"input_operand\"\n-\t\t\t\t\" J,U,T,r,o,i,r, f, T, o, f, f\"))]\n-  \"! TARGET_V9\n+\t\t\t\t\t\" J,J,U,T,r,o,i,r, f, T, o, f, e, W, e\"))]\n+  \"! TARGET_ARCH64\n+   && TARGET_V9\n    && (register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode))\"\n+       || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n+   stx\\t%%g0, %0\n    #\n    std\\t%1, %0\n    ldd\\t%1, %0\n@@ -2170,13 +2170,12 @@\n    ldd\\t%1, %0\n    #\n    #\n-   #\"\n-  [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n-   (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n-\n-;; We don't define V1SI because SI should work just fine.\n-(define_mode_macro V64 [DF V2SI V4HI V8QI])\n-(define_mode_macro V32 [SF V2HI V4QI])\n+   fmovd\\\\t%1, %0\n+   ldd\\\\t%1, %0\n+   std\\\\t%1, %0\"\n+  [(set_attr \"type\" \"store,store,store,load,*,*,*,*,fpstore,fpload,*,*,fpmove,fpload,fpstore\")\n+   (set_attr \"length\" \"*,2,*,*,2,2,2,2,*,*,2,2,*,*,*\")\n+   (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*\")])\n \n (define_insn \"*movdi_insn_sp64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,m,?e,?e,?W,b\")\n@@ -2552,6 +2551,72 @@\n \n ;; Floating point and vector move instructions\n \n+;; We don't define V1SI because SI should work just fine.\n+(define_mode_macro V32 [SF V2HI V4QI])\n+\n+;; Yes, you guessed it right, the former movsf expander.\n+(define_expand \"mov<V32:mode>\"\n+  [(set (match_operand:V32 0 \"general_operand\" \"\")\n+\t(match_operand:V32 1 \"general_operand\" \"\"))]\n+  \"<V32:MODE>mode == SFmode || TARGET_VIS\"\n+{\n+  /* Force constants into memory.  */\n+  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n+    {\n+      /* emit_group_store will send such bogosity to us when it is\n+         not storing directly into memory.  So fix this up to avoid\n+         crashes in output_constant_pool.  */\n+      if (operands [1] == const0_rtx)\n+        operands[1] = CONST0_RTX (<V32:MODE>mode);\n+\n+      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n+\t  && const_zero_operand (operands[1], <V32:MODE>mode))\n+\tgoto movsf_is_ok;\n+\n+      /* We are able to build any SF constant in integer registers\n+\t with at most 2 instructions.  */\n+      if (REGNO (operands[0]) < 32\n+\t  && <V32:MODE>mode == SFmode)\n+\tgoto movsf_is_ok;\n+\n+      operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n+                                                   operands[1]));\n+    }\n+\n+  /* Handle sets of MEM first.  */\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (register_or_zero_operand (operands[1], <V32:MODE>mode))\n+\tgoto movsf_is_ok;\n+\n+      if (! reload_in_progress)\n+\t{\n+\t  operands[0] = validize_mem (operands[0]);\n+\t  operands[1] = force_reg (<V32:MODE>mode, operands[1]);\n+\t}\n+    }\n+\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (CONSTANT_P (operands[1])\n+\t  && pic_address_needs_scratch (operands[1]))\n+\toperands[1] = legitimize_pic_address (operands[1], <V32:MODE>mode, 0);\n+\n+      if (symbolic_operand (operands[1], <V32:MODE>mode))\n+\t{\n+\t  operands[1] = legitimize_pic_address (operands[1],\n+\t\t\t\t\t\t<V32:MODE>mode,\n+\t\t\t\t\t\t(reload_in_progress ?\n+\t\t\t\t\t\t operands[0] :\n+\t\t\t\t\t\t NULL_RTX));\n+\t}\n+    }\n+\n+ movsf_is_ok:\n+  ;\n+})\n+\n (define_insn \"*movsf_insn\"\n   [(set (match_operand:V32 0 \"nonimmediate_operand\" \"=d,f,*r,*r,*r,*r,f,m,m\")\n \t(match_operand:V32 1 \"input_operand\"        \"GY,f,*rRY,Q,S,m,m,f,*rGY\"))]\n@@ -2676,68 +2741,7 @@\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-;; Yes, you guessed it right, the former movsf expander.\n-(define_expand \"mov<V32:mode>\"\n-  [(set (match_operand:V32 0 \"general_operand\" \"\")\n-\t(match_operand:V32 1 \"general_operand\" \"\"))]\n-  \"<V32:MODE>mode == SFmode || TARGET_VIS\"\n-{\n-  /* Force constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n-    {\n-      /* emit_group_store will send such bogosity to us when it is\n-         not storing directly into memory.  So fix this up to avoid\n-         crashes in output_constant_pool.  */\n-      if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (<V32:MODE>mode);\n-\n-      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && const_zero_operand (operands[1], <V32:MODE>mode))\n-\tgoto movsf_is_ok;\n-\n-      /* We are able to build any SF constant in integer registers\n-\t with at most 2 instructions.  */\n-      if (REGNO (operands[0]) < 32\n-\t  && <V32:MODE>mode == SFmode)\n-\tgoto movsf_is_ok;\n-\n-      operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-                                                   operands[1]));\n-    }\n-\n-  /* Handle sets of MEM first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], <V32:MODE>mode))\n-\tgoto movsf_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (<V32:MODE>mode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], <V32:MODE>mode, 0);\n-\n-      if (symbolic_operand (operands[1], <V32:MODE>mode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\t<V32:MODE>mode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t}\n-    }\n-\n- movsf_is_ok:\n-  ;\n-})\n+(define_mode_macro V64 [DF V2SI V4HI V8QI])\n \n ;; Yes, you again guessed it right, the former movdf expander.\n (define_expand \"mov<V64:mode>\"\n@@ -2840,23 +2844,6 @@\n   [(set_attr \"type\" \"load,store,*,*,*\")\n    (set_attr \"length\" \"*,*,2,2,2\")])\n \n-(define_insn \"*movdf_insn_sp32_v9_no_fpu\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,T,r,o\")\n-\t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,rG\"))]\n-  \"! TARGET_FPU\n-   && TARGET_V9\n-   && ! TARGET_ARCH64\n-   && (register_operand (operands[0], DFmode)\n-       || register_or_zero_operand (operands[1], DFmode))\"\n-  \"@\n-  ldd\\t%1, %0\n-  std\\t%1, %0\n-  stx\\t%r1, %0\n-  #\n-  #\"\n-  [(set_attr \"type\" \"load,store,store,*,*\")\n-   (set_attr \"length\" \"*,*,*,2,2\")])\n-\n ;; We have available v9 double floats but not 64-bit integer registers.\n (define_insn \"*movdf_insn_sp32_v9\"\n   [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,T,W,U,T,f,*r,o\")\n@@ -2881,6 +2868,23 @@\n    (set_attr \"length\" \"*,*,*,*,*,*,*,2,2,2\")\n    (set_attr \"fptype\" \"double,double,*,*,*,*,*,*,*,*\")])\n \n+(define_insn \"*movdf_insn_sp32_v9_no_fpu\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,T,r,o\")\n+\t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,rG\"))]\n+  \"! TARGET_FPU\n+   && TARGET_V9\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_or_zero_operand (operands[1], DFmode))\"\n+  \"@\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  stx\\t%r1, %0\n+  #\n+  #\"\n+  [(set_attr \"type\" \"load,store,store,*,*\")\n+   (set_attr \"length\" \"*,*,*,2,2\")])\n+\n ;; We have available both v9 double floats and 64-bit integer registers.\n (define_insn \"*movdf_insn_sp64\"\n   [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,W,*r,*r,m,*r\")\n@@ -3217,6 +3221,17 @@\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n+(define_insn \"*movtf_insn_sp64\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,o,r\")\n+        (match_operand:TF 1 \"input_operand\"    \"G,oe,Ger,roG\"))]\n+  \"TARGET_FPU\n+   && TARGET_ARCH64\n+   && ! TARGET_HARD_QUAD\n+   && (register_operand (operands[0], TFmode)\n+       || register_or_zero_operand (operands[1], TFmode))\"\n+  \"#\"\n+  [(set_attr \"length\" \"2\")])\n+\n (define_insn \"*movtf_insn_sp64_hq\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,e,m,o,r\")\n         (match_operand:TF 1 \"input_operand\"    \"G,e,m,e,rG,roG\"))]\n@@ -3235,17 +3250,6 @@\n   [(set_attr \"type\" \"*,fpmove,fpload,fpstore,*,*\")\n    (set_attr \"length\" \"2,*,*,*,2,2\")])\n \n-(define_insn \"*movtf_insn_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,o,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"G,oe,Ger,roG\"))]\n-  \"TARGET_FPU\n-   && TARGET_ARCH64\n-   && ! TARGET_HARD_QUAD\n-   && (register_operand (operands[0], TFmode)\n-       || register_or_zero_operand (operands[1], TFmode))\"\n-  \"#\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*movtf_insn_sp64_no_fpu\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n         (match_operand:TF 1 \"input_operand\"    \"orG,rG\"))]\n@@ -3373,8 +3377,9 @@\n \t\t\tgen_df_reg (set_src, 1)));\n   DONE;\n })\n-\f\n-;; SPARC V9 conditional move instructions.\n+\n+\n+;; SPARC-V9 conditional move instructions.\n \n ;; We can handle larger constants here for some flavors, but for now we keep\n ;; it simple and only allow those constants supported by all flavors.\n@@ -3865,7 +3870,7 @@\n   [(set_attr \"length\" \"2\")])\n \n \f\n-;;- zero extension instructions\n+;; Zero-extension instructions\n \n ;; These patterns originally accepted general_operands, however, slightly\n ;; better code is generated by only accepting register_operands, and then\n@@ -3981,7 +3986,6 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n-\n ;; ??? Write truncdisi pattern using sra?\n \n (define_expand \"zero_extendsidi2\"\n@@ -4145,7 +4149,8 @@\n   \"andcc\\t%1, 0xff, %0\"\n   [(set_attr \"type\" \"compare\")])\n \f\n-;;- sign extension instructions\n+\n+;; Sign-extension instructions\n \n ;; These patterns originally accepted general_operands, however, slightly\n ;; better code is generated by only accepting register_operands, and then\n@@ -4330,7 +4335,8 @@\n   ldsw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,sload\")\n    (set_attr \"us3load_type\" \"*,3cycle\")])\n-\f\n+\n+\n ;; Special pattern for optimizing bit-field compares.  This is needed\n ;; because combine uses this as a canonical form.\n \n@@ -4367,7 +4373,8 @@\n   return \"andcc\\t%0, %1, %%g0\";\n }\n   [(set_attr \"type\" \"compare\")])\n-\f\n+\n+\n ;; Conversions between float, double and long double.\n \n (define_insn \"extendsfdf2\"\n@@ -4447,7 +4454,8 @@\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtod\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")])\n-\f\n+\n+\n ;; Conversion between fixed point and floating point.\n \n (define_insn \"floatsisf2\"\n@@ -4621,7 +4629,8 @@\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n   \"emit_tfmode_cvt (UNSIGNED_FIX, operands); DONE;\")\n \n-;; Integer Addition/Subtraction.\n+\n+;; Integer addition/subtraction instructions.\n \n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4967,8 +4976,9 @@\n   \"TARGET_ARCH64\"\n   \"subcc\\t%1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n-\f\n-;; Integer Multiply/Divide.\n+\n+\n+;; Integer multiply/divide instructions.\n \n ;; The 32 bit multiply/divide instructions are deprecated on v9, but at\n ;; least in UltraSPARC I, II and IIi it is a win tick-wise.\n@@ -5632,8 +5642,10 @@\n   \"TARGET_SPARCLET\"\n   \"umacd\\t%1, %2, %L0\"\n   [(set_attr \"type\" \"imul\")])\n-\f\n-;; Boolean instructions\n+\n+\n+;; Boolean instructions.\n+\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n@@ -6331,7 +6343,8 @@\n   \"TARGET_ARCH64\"\n   \"orcc\\t%1, 0, %0\"\n    [(set_attr \"type\" \"compare\")])\n-\f\n+\n+\n ;; Floating point arithmetic instructions.\n \n (define_expand \"addtf3\"\n@@ -6691,8 +6704,9 @@\n   \"TARGET_FPU\"\n   \"fsqrts\\t%1, %0\"\n   [(set_attr \"type\" \"fpsqrts\")])\n-\f\n-;;- arithmetic shift instructions\n+\n+\n+;; Arithmetic shift instructions.\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -6990,8 +7004,10 @@\n   return \"srlx\\t%1, %2, %0\";\n }\n   [(set_attr \"type\" \"shift\")])\n-\f\n-;; Unconditional and other jump instructions\n+\n+\n+;; Unconditional and other jump instructions.\n+\n (define_insn \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n@@ -7034,7 +7050,9 @@\n   \"jmp\\t%a0%#\"\n   [(set_attr \"type\" \"uncond_branch\")])\n \n-;;- jump to subroutine\n+\n+;; Jump to subroutine instructions.\n+\n (define_expand \"call\"\n   ;; Note that this expression is not used for generating RTL.\n   ;; All the RTL is generated explicitly below.\n@@ -7293,7 +7311,8 @@\n   DONE;\n })\n \n-;;- tail calls\n+;;  Tail call instructions.\n+\n (define_expand \"sibcall\"\n   [(parallel [(call (match_operand 0 \"call_operand\" \"\") (const_int 0))\n \t      (return)])]\n@@ -7341,13 +7360,8 @@\n   \"* return output_sibcall(insn, operands[1]);\"\n   [(set_attr \"type\" \"sibcall\")])\n \n-(define_expand \"sibcall_epilogue\"\n-  [(return)]\n-  \"\"\n-{\n-  sparc_expand_epilogue ();\n-  DONE;\n-})\n+\n+;; Special instructions.\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -7381,6 +7395,14 @@\n   sparc_expand_epilogue ();\n })\n \n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  sparc_expand_epilogue ();\n+  DONE;\n+})\n+\n (define_expand \"return\"\n   [(return)]\n   \"sparc_can_use_return_insn_p ()\"\n@@ -7650,8 +7672,8 @@\n   { return TARGET_V9 ? \"flush\\t%f0\" : \"iflush\\t%f0\"; }\n   [(set_attr \"type\" \"iflush\")])\n \n-\f\n-;; find first set.\n+\n+;; Find first set instructions.\n \n ;; The scan instruction searches from the most significant bit while ffs\n ;; searches from the least significant bit.  The bit index and treatment of\n@@ -7847,6 +7869,9 @@\n \t\t   (compare:CCX (match_dup 1) (const_int 0)))])]\n   \"\")\n \n+\n+;; Prefetch instructions.\n+\n ;; ??? UltraSPARC-III note: A memory operation loading into the floating point register\n ;; ??? file, if it hits the prefetch cache, has a chance to dual-issue with other memory\n ;; ??? operations.  With DFA we might be able to model this, but it requires a lot of\n@@ -7913,7 +7938,10 @@\n   return prefetch_instr [read_or_write][locality == 0 ? 0 : 1];\n }\n   [(set_attr \"type\" \"load\")])\n-\f\n+\n+\n+;; Trap instructions.\n+\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 5))]\n   \"\"\n@@ -7949,7 +7977,9 @@\n   \"t%C0\\t%%xcc, %1\"\n   [(set_attr \"type\" \"trap\")])\n \n-;; TLS support\n+\n+;; TLS support instructions.\n+\n (define_insn \"tgd_hi22\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (high:SI (unspec:SI [(match_operand 1 \"tgd_symbolic_operand\" \"\")]\n@@ -8512,6 +8542,7 @@\n   \"stx\\t%0, [%1 + %2], %%tldo_add(%3)\"\n   [(set_attr \"type\" \"store\")])\n \n+\n ;; Vector instructions.\n \n (define_insn \"addv2si3\""}]}