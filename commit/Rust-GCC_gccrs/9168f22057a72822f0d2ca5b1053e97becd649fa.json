{"sha": "9168f22057a72822f0d2ca5b1053e97becd649fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2OGYyMjA1N2E3MjgyMmYwZDJjYTViMTA1M2U5N2JlY2Q2NDlmYQ==", "commit": {"author": {"name": "Johannes Pfau", "email": "johannespfau@gmail.com", "date": "2019-04-25T11:11:39Z"}, "committer": {"name": "Johannes Pfau", "email": "jpfau@gcc.gnu.org", "date": "2019-04-25T11:11:39Z"}, "message": "D: Implement GCC emutls in druntime\n\n* libdruntime/Makefile.am: Add emutls and gthread files.\n* libdruntime/Makefile.in: Regenerate.\n* libdruntime/gcc/emutls.d: New file. Implement GC-compatible emutls.\n* libdruntime/gcc/gthread.d: New file.\n* libdruntime/gcc/sections/elf_shared.d: Integrate emutls support.\n* testsuite/libphobos.allocations/tls_gc_integration.d: New test for\nTLS.\n\nFrom-SVN: r270568", "tree": {"sha": "687c80f5f3eb4cfe35d64eaf588ccd3d1a8e047c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/687c80f5f3eb4cfe35d64eaf588ccd3d1a8e047c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9168f22057a72822f0d2ca5b1053e97becd649fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9168f22057a72822f0d2ca5b1053e97becd649fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9168f22057a72822f0d2ca5b1053e97becd649fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9168f22057a72822f0d2ca5b1053e97becd649fa/comments", "author": {"login": "jpf91", "id": 583238, "node_id": "MDQ6VXNlcjU4MzIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/583238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jpf91", "html_url": "https://github.com/jpf91", "followers_url": "https://api.github.com/users/jpf91/followers", "following_url": "https://api.github.com/users/jpf91/following{/other_user}", "gists_url": "https://api.github.com/users/jpf91/gists{/gist_id}", "starred_url": "https://api.github.com/users/jpf91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jpf91/subscriptions", "organizations_url": "https://api.github.com/users/jpf91/orgs", "repos_url": "https://api.github.com/users/jpf91/repos", "events_url": "https://api.github.com/users/jpf91/events{/privacy}", "received_events_url": "https://api.github.com/users/jpf91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7da021f080b23bbfe6206855a40a73e145f10b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da021f080b23bbfe6206855a40a73e145f10b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da021f080b23bbfe6206855a40a73e145f10b75"}], "stats": {"total": 607, "additions": 570, "deletions": 37}, "files": [{"sha": "131d7f9168f23eb075d5feebeddabc4014be88ad", "filename": "libphobos/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FChangeLog?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -1,3 +1,12 @@\n+2019-04-25  Johannes Pfau  <johannespfau@gmail.com>\n+\n+        * libdruntime/Makefile.am: Add emutls and gthread files.\n+        * libdruntime/Makefile.in: Regenerate.\n+        * libdruntime/gcc/emutls.d: New file. Implement GC-compatible emutls.\n+        * libdruntime/gcc/gthread.d: New file.\n+        * libdruntime/gcc/sections/elf_shared.d: Integrate emutls support.\n+        * testsuite/libphobos.allocations/tls_gc_integration.d: New test for TLS.\n+\n 2019-04-25  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* testsuite/Makefile.am: Set PWD_COMMAND."}, {"sha": "bf9bff095ca587c098dbb74ce067e502450ad2c4", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -161,7 +161,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/config.d core/sync/exception.d core/sync/mutex.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread.d core/time.d \\\n \tcore/vararg.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/emutls.d gcc/gthread.d gcc/sections/android.d \\\n+\tgcc/sections/elf_shared.d gcc/sections/osx.d \\\n \tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\"}, {"sha": "19ee94fc370d9f5f2cc6011c9a04c8b429ce59cd", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -203,10 +203,10 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/sync/exception.lo core/sync/mutex.lo core/sync/rwmutex.lo \\\n \tcore/sync/semaphore.lo core/thread.lo core/time.lo \\\n \tcore/vararg.lo gcc/attribute.lo gcc/backtrace.lo \\\n-\tgcc/builtins.lo gcc/deh.lo gcc/sections/android.lo \\\n-\tgcc/sections/elf_shared.lo gcc/sections/osx.lo \\\n-\tgcc/sections/package.lo gcc/sections/win32.lo \\\n-\tgcc/sections/win64.lo gcc/unwind/arm.lo \\\n+\tgcc/builtins.lo gcc/deh.lo gcc/emutls.lo gcc/gthread.lo \\\n+\tgcc/sections/android.lo gcc/sections/elf_shared.lo \\\n+\tgcc/sections/osx.lo gcc/sections/package.lo \\\n+\tgcc/sections/win32.lo gcc/sections/win64.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n@@ -757,7 +757,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/config.d core/sync/exception.d core/sync/mutex.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread.d core/time.d \\\n \tcore/vararg.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/emutls.d gcc/gthread.d gcc/sections/android.d \\\n+\tgcc/sections/elf_shared.d gcc/sections/osx.d \\\n \tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n@@ -1104,6 +1105,8 @@ gcc/attribute.lo: gcc/$(am__dirstamp)\n gcc/backtrace.lo: gcc/$(am__dirstamp)\n gcc/builtins.lo: gcc/$(am__dirstamp)\n gcc/deh.lo: gcc/$(am__dirstamp)\n+gcc/emutls.lo: gcc/$(am__dirstamp)\n+gcc/gthread.lo: gcc/$(am__dirstamp)\n gcc/sections/$(am__dirstamp):\n \t@$(MKDIR_P) gcc/sections\n \t@: > gcc/sections/$(am__dirstamp)"}, {"sha": "461f20d9e28c9ad53977dcf1adee2202ed538f21", "filename": "libphobos/libdruntime/gcc/emutls.d", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Femutls.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Femutls.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Femutls.d?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -0,0 +1,316 @@\n+// GNU D Compiler emulated TLS routines.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This code is based on the libgcc emutls.c emulated TLS support.\n+\n+module gcc.emutls;\n+\n+import core.atomic, core.stdc.stdlib, core.stdc.string, core.sync.mutex;\n+import rt.util.container.array, rt.util.container.hashtab;\n+import core.internal.traits : classInstanceAlignment;\n+import gcc.builtins, gcc.gthread;\n+\n+version (GNU_EMUTLS): private:\n+\n+alias word = __builtin_machine_uint;\n+alias pointer = __builtin_pointer_uint;\n+alias TlsArray = Array!(void**);\n+\n+/*\n+ * TLS control data emitted by GCC for every TLS variable.\n+ */\n+struct __emutls_object\n+{\n+    word size;\n+    word align_;\n+    union\n+    {\n+        pointer offset;\n+        void* ptr;\n+    }\n+\n+    ubyte* templ;\n+}\n+\n+// Per-thread key to obtain the per-thread TLS variable array\n+__gshared __gthread_key_t emutlsKey;\n+// Largest, currently assigned TLS variable offset\n+__gshared pointer emutlsMaxOffset = 0;\n+// Contains the size of the TLS variables (for GC)\n+__gshared Array!word emutlsSizes;\n+// Contains the TLS variable array for single-threaded apps\n+__gshared TlsArray singleArray;\n+// List of all currently alive TlsArrays (for GC)\n+__gshared HashTab!(TlsArray*, TlsArray*) emutlsArrays;\n+\n+// emutlsMutex Mutex + @nogc handling\n+enum mutexAlign = classInstanceAlignment!Mutex;\n+enum mutexClassInstanceSize = __traits(classInstanceSize, Mutex);\n+__gshared align(mutexAlign) void[mutexClassInstanceSize] _emutlsMutex;\n+\n+@property Mutex emutlsMutex() nothrow @nogc\n+{\n+    return cast(Mutex) _emutlsMutex.ptr;\n+}\n+\n+/*\n+ * Global (de)initialization functions\n+ */\n+extern (C) void _d_emutls_init() nothrow @nogc\n+{\n+    memcpy(_emutlsMutex.ptr, typeid(Mutex).initializer.ptr, _emutlsMutex.length);\n+    (cast(Mutex) _emutlsMutex.ptr).__ctor();\n+\n+    if (__gthread_key_create(&emutlsKey, &emutlsDestroyThread) != 0)\n+        abort();\n+}\n+\n+__gshared __gthread_once_t initOnce = GTHREAD_ONCE_INIT;\n+\n+/*\n+ * emutls main entrypoint, called by GCC for each TLS variable access.\n+ */\n+extern (C) void* __emutls_get_address(shared __emutls_object* obj) nothrow @nogc\n+{\n+    pointer offset;\n+    if (__gthread_active_p())\n+    {\n+        // Obtain the offset index into the TLS array (same for all-threads)\n+        // for requested var. If it is unset, obtain a new offset index.\n+        offset = atomicLoad!(MemoryOrder.acq, pointer)(obj.offset);\n+        if (__builtin_expect(offset == 0, 0))\n+        {\n+            __gthread_once(&initOnce, &_d_emutls_init);\n+            emutlsMutex.lock_nothrow();\n+\n+            offset = obj.offset;\n+            if (offset == 0)\n+            {\n+                offset = ++emutlsMaxOffset;\n+\n+                emutlsSizes.ensureLength(offset);\n+                // Note: it's important that we copy any data from obj and\n+                // do not keep an reference to obj itself: If a library is\n+                // unloaded, its tls variables are not removed from the arrays\n+                // and the GC will still scan these. If we then try to reference\n+                // a pointer to the data segment of an unloaded library, this\n+                // will crash.\n+                emutlsSizes[offset - 1] = obj.size;\n+\n+                atomicStore!(MemoryOrder.rel, pointer)(obj.offset, offset);\n+            }\n+            emutlsMutex.unlock_nothrow();\n+        }\n+    }\n+    // For single-threaded systems, don't synchronize\n+    else\n+    {\n+        if (__builtin_expect(obj.offset == 0, 0))\n+        {\n+            offset = ++emutlsMaxOffset;\n+\n+            emutlsSizes.ensureLength(offset);\n+            emutlsSizes[offset - 1] = obj.size;\n+\n+            obj.offset = offset;\n+        }\n+    }\n+\n+    TlsArray* arr;\n+    if (__gthread_active_p())\n+        arr = cast(TlsArray*) __gthread_getspecific(emutlsKey);\n+    else\n+        arr = &singleArray;\n+\n+    // This will always be false for singleArray\n+    if (__builtin_expect(arr == null, 0))\n+    {\n+        arr = mallocTlsArray(offset);\n+        __gthread_setspecific(emutlsKey, arr);\n+        emutlsMutex.lock_nothrow();\n+        emutlsArrays[arr] = arr;\n+        emutlsMutex.unlock_nothrow();\n+    }\n+    // Check if we have to grow the per-thread array\n+    else if (__builtin_expect(offset > arr.length, 0))\n+    {\n+        (*arr).ensureLength(offset);\n+    }\n+\n+    // Offset 0 is used as a not-initialized marker above. In the\n+    // TLS array, we start at 0.\n+    auto index = offset - 1;\n+\n+    // Get the per-thread pointer from the TLS array\n+    void** ret = (*arr)[index];\n+    if (__builtin_expect(ret == null, 0))\n+    {\n+        // Initial access, have to allocate the storage\n+        ret = emutlsAlloc(obj);\n+        (*arr)[index] = ret;\n+    }\n+\n+    return ret;\n+}\n+\n+// 1:1 copy from libgcc emutls.c\n+extern (C) void __emutls_register_common(__emutls_object* obj, word size, word align_, ubyte* templ) nothrow @nogc\n+{\n+    if (obj.size < size)\n+    {\n+        obj.size = size;\n+        obj.templ = null;\n+    }\n+    if (obj.align_ < align_)\n+        obj.align_ = align_;\n+    if (templ && size == obj.size)\n+        obj.templ = templ;\n+}\n+\n+// 1:1 copy from libgcc emutls.c\n+void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc\n+{\n+    void* ptr;\n+    void* ret;\n+    enum pointerSize = (void*).sizeof;\n+\n+    /* We could use here posix_memalign if available and adjust\n+     emutls_destroy accordingly.  */\n+    if ((cast() obj).align_ <= pointerSize)\n+    {\n+        ptr = malloc((cast() obj).size + pointerSize);\n+        if (ptr == null)\n+            abort();\n+        (cast(void**) ptr)[0] = ptr;\n+        ret = ptr + pointerSize;\n+    }\n+    else\n+    {\n+        ptr = malloc(obj.size + pointerSize + obj.align_ - 1);\n+        if (ptr == null)\n+            abort();\n+        ret = cast(void*)((cast(pointer)(ptr + pointerSize + obj.align_ - 1)) & ~cast(\n+                pointer)(obj.align_ - 1));\n+        (cast(void**) ret)[-1] = ptr;\n+    }\n+\n+    if (obj.templ)\n+        memcpy(ret, cast(ubyte*) obj.templ, cast() obj.size);\n+    else\n+        memset(ret, 0, cast() obj.size);\n+\n+    return cast(void**) ret;\n+}\n+\n+/*\n+ * When a thread has finished, remove the TLS array from the GC\n+ * scan list emutlsArrays, free all allocated TLS variables and\n+ * finally free the array.\n+ */\n+extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc\n+{\n+    auto arr = cast(TlsArray*) ptr;\n+    emutlsMutex.lock_nothrow();\n+    emutlsArrays.remove(arr);\n+    emutlsMutex.unlock_nothrow();\n+\n+    foreach (entry; *arr)\n+    {\n+        if (entry)\n+            free(entry[-1]);\n+    }\n+\n+    free(arr);\n+}\n+\n+/*\n+ * Allocate a new TLS array, set length according to offset.\n+ */\n+TlsArray* mallocTlsArray(pointer offset = 0) nothrow @nogc\n+{\n+    static assert(TlsArray.alignof == (void*).alignof);\n+    void[] data = malloc(TlsArray.sizeof)[0 .. TlsArray.sizeof];\n+    if (data.ptr == null)\n+        abort();\n+\n+    static immutable TlsArray init = TlsArray.init;\n+    memcpy(data.ptr, &init, data.length);\n+    (cast(TlsArray*) data).length = 32;\n+    return cast(TlsArray*) data.ptr;\n+}\n+\n+/*\n+ * Make sure array is large enough to hold an entry for offset.\n+ * Note: the array index will be offset - 1!\n+ */\n+void ensureLength(Value)(ref Array!(Value) arr, size_t offset) nothrow @nogc\n+{\n+    // index is offset-1\n+    if (offset > arr.length)\n+    {\n+        auto newSize = arr.length * 2;\n+        if (offset > newSize)\n+            newSize = offset + 32;\n+        arr.length = newSize;\n+    }\n+}\n+\n+// Public interface\n+public:\n+void _d_emutls_scan(scope void delegate(void* pbeg, void* pend) nothrow cb) nothrow\n+{\n+    void scanArray(scope TlsArray* arr) nothrow\n+    {\n+        foreach (index, entry; *arr)\n+        {\n+            auto ptr = cast(void*) entry;\n+            if (ptr)\n+                cb(ptr, ptr + emutlsSizes[index]);\n+        }\n+    }\n+\n+    __gthread_once(&initOnce, &_d_emutls_init);\n+    emutlsMutex.lock_nothrow();\n+    // this code is effectively nothrow\n+    try\n+    {\n+        foreach (arr, value; emutlsArrays)\n+        {\n+            scanArray(arr);\n+        }\n+    }\n+    catch (Exception)\n+    {\n+    }\n+    emutlsMutex.unlock_nothrow();\n+    scanArray(&singleArray);\n+}\n+\n+// Call this after druntime has been unloaded\n+void _d_emutls_destroy() nothrow @nogc\n+{\n+    if (__gthread_key_delete(emutlsKey) != 0)\n+        abort();\n+\n+    (cast(Mutex) _emutlsMutex.ptr).__dtor();\n+    destroy(emutlsArrays);\n+}"}, {"sha": "580fdcb9b0d80a54cb8708cd15cdbf0aa190244a", "filename": "libphobos/libdruntime/gcc/gthread.d", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Fgthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Fgthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fgthread.d?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -0,0 +1,127 @@\n+// GNU D Compiler thread support for emulated TLS routines.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.gthread;\n+import gcc.config;\n+\n+extern (C) nothrow @nogc:\n+\n+alias GthreadDestroyFn = extern (C) void function(void*);\n+alias GthreadOnceFn = extern (C) void function();\n+\n+static if (GNU_Thread_Model == ThreadModel.Posix)\n+{\n+    import core.sys.posix.pthread;\n+\n+    alias __gthread_key_create = pthread_key_create;\n+    alias __gthread_key_delete = pthread_key_delete;\n+    alias __gthread_getspecific = pthread_getspecific;\n+    alias __gthread_setspecific = pthread_setspecific;\n+    alias __gthread_once = pthread_once;\n+    alias __gthread_key_t = pthread_key_t;\n+    alias __gthread_once_t = pthread_once_t;\n+    enum GTHREAD_ONCE_INIT = PTHREAD_ONCE_INIT;\n+\n+    // TODO: FreeBSD and Solaris exposes a dummy POSIX threads\n+    // interface that will need to be handled here.\n+    extern (D) int __gthread_active_p()\n+    {\n+        return 1;\n+    }\n+}\n+else static if (GNU_Thread_Model == ThreadModel.Single)\n+{\n+    alias __gthread_key_t = int;\n+    alias __gthread_once_t = int;\n+    enum GTHREAD_ONCE_INIT = 0;\n+\n+    extern (D) int __gthread_key_create(__gthread_key_t*, GthreadDestroyFn)\n+    {\n+        return 0;\n+    }\n+\n+    extern (D) int __gthread_key_delete(__gthread_key_t)\n+    {\n+        return 0;\n+    }\n+\n+    extern (D) void* __gthread_getspecific(__gthread_key_t)\n+    {\n+        return null;\n+    }\n+\n+    extern (D) int __gthread_setspecific(__gthread_key_t, void*)\n+    {\n+        return 0;\n+    }\n+\n+    extern (D) int __gthread_once(__gthread_once_t*, GthreadOnceFn)\n+    {\n+        return 0;\n+    }\n+\n+    extern (D) int __gthread_active_p()\n+    {\n+        return 0;\n+    }\n+}\n+else static if (GNU_Thread_Model == ThreadModel.Win32)\n+{\n+    struct __gthread_once_t\n+    {\n+        INT done;\n+        LONG started;\n+    }\n+\n+    int __gthr_win32_key_create(__gthread_key_t* keyp, GthreadDestroyFn dtor);\n+    int __gthr_win32_key_delete(__gthread_key_t key);\n+    void* __gthr_win32_getspecific(__gthread_key_t key);\n+    int __gthr_win32_setspecific(__gthread_key_t key, const void* ptr);\n+    int __gthr_win32_once(__gthread_once_t* once, GthreadOnceFn);\n+\n+    alias __gthread_key_create = __gthr_win32_key_create;\n+    alias __gthread_key_delete = __gthr_win32_key_delete;\n+    alias __gthread_getspecific = __gthr_win32_getspecific;\n+    alias __gthread_setspecific = __gthr_win32_setspecific;\n+    alias __gthread_once = __gthr_win32_once;\n+    enum GTHREAD_ONCE_INIT = __gthread_once_t(0, -1);\n+    alias __gthread_key_t = c_ulong;\n+\n+    version (MinGW)\n+    {\n+        // Mingw runtime >= v0.3 provides a magic variable that is set to nonzero\n+        // if -mthreads option was specified, or 0 otherwise.\n+        extern __gshared int _CRT_MT;\n+    }\n+\n+    extern (D) int __gthread_active_p()\n+    {\n+        version (MinGW)\n+            return _CRT_MT;\n+        else\n+            return 1;\n+    }\n+}\n+else\n+{\n+    static assert(false, \"Not implemented\");\n+}"}, {"sha": "3a2c85cba6454b37acde109643a860406bb0955c", "filename": "libphobos/libdruntime/gcc/sections/elf_shared.d", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -222,8 +222,16 @@ version (Shared)\n \n     void scanTLSRanges(Array!(ThreadDSO)* tdsos, scope ScanDG dg) nothrow\n     {\n-        foreach (ref tdso; *tdsos)\n-            dg(tdso._tlsRange.ptr, tdso._tlsRange.ptr + tdso._tlsRange.length);\n+        version (GNU_EMUTLS)\n+        {\n+            import gcc.emutls;\n+            _d_emutls_scan(dg);\n+        }\n+        else\n+        {\n+            foreach (ref tdso; *tdsos)\n+                dg(tdso._tlsRange.ptr, tdso._tlsRange.ptr + tdso._tlsRange.length);\n+        }\n     }\n \n     // interface for core.thread to inherit loaded libraries\n@@ -310,8 +318,16 @@ else\n \n     void scanTLSRanges(Array!(void[])* rngs, scope ScanDG dg) nothrow\n     {\n-        foreach (rng; *rngs)\n-            dg(rng.ptr, rng.ptr + rng.length);\n+        version (GNU_EMUTLS)\n+        {\n+            import gcc.emutls;\n+            _d_emutls_scan(dg);\n+        }\n+        else\n+        {\n+            foreach (rng; *rngs)\n+                dg(rng.ptr, rng.ptr + rng.length);\n+        }\n     }\n }\n \n@@ -519,6 +535,11 @@ extern(C) void _d_dso_registry(CompilerDSOData* data)\n                 _handleToDSO.reset();\n             }\n             finiLocks();\n+            version (GNU_EMUTLS)\n+            {\n+                import gcc.emutls;\n+                _d_emutls_destroy();\n+            }\n         }\n     }\n }\n@@ -805,40 +826,46 @@ void scanSegments(in ref dl_phdr_info info, DSO* pdso) nothrow @nogc\n             break;\n \n         case PT_TLS: // TLS segment\n-            safeAssert(!pdso._tlsSize, \"Multiple TLS segments in image header.\");\n-            static if (OS_Have_Dlpi_Tls_Modid)\n+            version (GNU_EMUTLS)\n             {\n-                pdso._tlsMod = info.dlpi_tls_modid;\n-                pdso._tlsSize = phdr.p_memsz;\n             }\n-            else version (Solaris)\n+            else\n             {\n-                struct Rt_map\n+                safeAssert(!pdso._tlsSize, \"Multiple TLS segments in image header.\");\n+                static if (OS_Have_Dlpi_Tls_Modid)\n                 {\n-                    Link_map rt_public;\n-                    const char* rt_pathname;\n-                    c_ulong rt_padstart;\n-                    c_ulong rt_padimlen;\n-                    c_ulong rt_msize;\n-                    uint rt_flags;\n-                    uint rt_flags1;\n-                    c_ulong rt_tlsmodid;\n+                    pdso._tlsMod = info.dlpi_tls_modid;\n+                    pdso._tlsSize = phdr.p_memsz;\n                 }\n+                else version (Solaris)\n+                {\n+                    struct Rt_map\n+                    {\n+                        Link_map rt_public;\n+                        const char* rt_pathname;\n+                        c_ulong rt_padstart;\n+                        c_ulong rt_padimlen;\n+                        c_ulong rt_msize;\n+                        uint rt_flags;\n+                        uint rt_flags1;\n+                        c_ulong rt_tlsmodid;\n+                    }\n \n-                Rt_map* map;\n-                version (Shared)\n-                    dlinfo(handleForName(info.dlpi_name), RTLD_DI_LINKMAP, &map);\n+                    Rt_map* map;\n+                    version (Shared)\n+                        dlinfo(handleForName(info.dlpi_name), RTLD_DI_LINKMAP, &map);\n+                    else\n+                        dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &map);\n+                    // Until Solaris 11.4, tlsmodid for the executable is 0.\n+                    // Let it start at 1 as the rest of the code expects.\n+                    pdso._tlsMod = map.rt_tlsmodid + 1;\n+                    pdso._tlsSize = phdr.p_memsz;\n+                }\n                 else\n-                    dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &map);\n-                // Until Solaris 11.4, tlsmodid for the executable is 0.\n-                // Let it start at 1 as the rest of the code expects.\n-                pdso._tlsMod = map.rt_tlsmodid + 1;\n-                pdso._tlsSize = phdr.p_memsz;\n-            }\n-            else\n-            {\n-                pdso._tlsMod = 0;\n-                pdso._tlsSize = 0;\n+                {\n+                    pdso._tlsMod = 0;\n+                    pdso._tlsSize = 0;\n+                }\n             }\n             break;\n "}, {"sha": "44eb40c366d9d60afc4e01ac6ba15ea3918274c5", "filename": "libphobos/testsuite/libphobos.allocations/tls_gc_integration.d", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9168f22057a72822f0d2ca5b1053e97becd649fa/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d?ref=9168f22057a72822f0d2ca5b1053e97becd649fa", "patch": "@@ -0,0 +1,50 @@\n+import core.memory, core.thread, core.bitop;\n+\n+/*\n+ * This test repeatedly performs operations on GC-allocated objects which\n+ * are only reachable from TLS storage. Tests are performed in multiple threads\n+ * and GC collections are triggered repeatedly, so if the GC does not properly\n+ * scan TLS memory, this provokes a crash.\n+ */\n+class TestTLS\n+{\n+    uint a;\n+    void addNumber()\n+    {\n+        auto val = volatileLoad(&a);\n+        val++;\n+        volatileStore(&a, val);\n+    }\n+}\n+\n+TestTLS tlsPtr;\n+\n+static this()\n+{\n+    tlsPtr = new TestTLS();\n+}\n+\n+void main()\n+{\n+    void runThread()\n+    {\n+        for (size_t i = 0; i < 100; i++)\n+        {\n+            Thread.sleep(10.msecs);\n+            tlsPtr.addNumber();\n+            GC.collect();\n+        }\n+    }\n+\n+    Thread[] threads;\n+    for (size_t i = 0; i < 20; i++)\n+    {\n+        auto t = new Thread(&runThread);\n+        threads ~= t;\n+        t.start();\n+    }\n+    runThread();\n+\n+    foreach (thread; threads)\n+        thread.join();\n+}"}]}