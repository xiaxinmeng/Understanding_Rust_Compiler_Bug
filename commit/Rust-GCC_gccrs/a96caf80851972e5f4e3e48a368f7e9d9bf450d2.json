{"sha": "a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2Y2FmODA4NTE5NzJlNWY0ZTNlNDhhMzY4ZjdlOWQ5YmY0NTBkMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-11-26T21:41:42Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-11-26T21:41:42Z"}, "message": "re PR rtl-optimization/38582 (excessive time in rename registers)\n\n\tPR rtl-opt/38582\n\t* regrename.c (struct du_head): New members id, conflicts,\n\thard_conflicts and cannot_rename.\n\t(enum scan_actions): Remove terminate_all_read and\n\tterminate_overlapping_read; add mark_all_read.\n\t(scan_actions_name): Likewise.\n\t(du_head_p): New typedef.  Define a vector type for it.\n\t(id_to_chain): New static variable.\n\t(note_sets, clear_dead_regs): Delete functions.\n\t(free_chain_data): New function.\n\t(merge_overlapping_regs): Simply walk the conflicts bitmap.\n\tRemove argument B, all callers changed.\n\t(regrename_optimize): Allocate id_to_chain.  Ignore chains that have\n\tthe cannot_rename bit set.  Update regno and nregs of a renamed chain.\n\tCall free_chain_data when done.\n\t(do_replace): Remove death notes when the renamed reg is set in the\n\tlast insn; add them if not.\n\t(mark_conflict, note_sets_clobbers): New static function.\n\t(fail_current_block, current_id, open_chains_set, live_hard_regs): New\n\tstatic variables.\n\t(scan_rtx_reg): Keep track of conflicts between chains, and between\n\tchains and hard regs.  Don't terminate chains when we find a read we\n\tcan't handle, mark it unrenameable instead.  For terminate_write,\n\tterminate chains that are written with an exact match or a superset\n\tof registers.  Set fail_current_block if multi-word lifetimes are too\n\tcomplex to handle.\n\t(scan_rtx_address): Use mark_all_read instead of terminate_all_read.\n\t(build_def_use): Initialize current_id, live_chains and live_hard_regs;\n\tfree memory for them when done.\n\tRearrange the steps so that earlyclobbers are noted before reads\n\tare processed.  Add new steps to keep track of hard register lifetimes\n\toutside insn operands.\n\nFrom-SVN: r154688", "tree": {"sha": "949d7357876cb59c5ee333ce2b11bbf51a4c5ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/949d7357876cb59c5ee333ce2b11bbf51a4c5ec6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96caf80851972e5f4e3e48a368f7e9d9bf450d2/comments", "author": null, "committer": null, "parents": [{"sha": "6bda9bdf522dc14c5deff16d364b19d1095d8a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bda9bdf522dc14c5deff16d364b19d1095d8a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bda9bdf522dc14c5deff16d364b19d1095d8a33"}], "stats": {"total": 555, "additions": 362, "deletions": 193}, "files": [{"sha": "850e31f8235eceb962f38b877020376154b88188", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96caf80851972e5f4e3e48a368f7e9d9bf450d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96caf80851972e5f4e3e48a368f7e9d9bf450d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "patch": "@@ -9,6 +9,38 @@\n \tbroken out of build_def_use.\n \t(build_def_use): Call them as necessary.\n \n+\t* regrename.c (struct du_head): New members id, conflicts,\n+\thard_conflicts and cannot_rename.\n+\t(enum scan_actions): Remove terminate_all_read and\n+\tterminate_overlapping_read; add mark_all_read.\n+\t(scan_actions_name): Likewise.\n+\t(du_head_p): New typedef.  Define a vector type for it.\n+\t(id_to_chain): New static variable.\n+\t(note_sets, clear_dead_regs): Delete functions.\n+\t(free_chain_data): New function.\n+\t(merge_overlapping_regs): Simply walk the conflicts bitmap.\n+\tRemove argument B, all callers changed.\n+\t(regrename_optimize): Allocate id_to_chain.  Ignore chains that have\n+\tthe cannot_rename bit set.  Update regno and nregs of a renamed chain.\n+\tCall free_chain_data when done.\n+\t(do_replace): Remove death notes when the renamed reg is set in the\n+\tlast insn; add them if not.\n+\t(mark_conflict, note_sets_clobbers): New static function.\n+\t(fail_current_block, current_id, open_chains_set, live_hard_regs): New\n+\tstatic variables.\n+\t(scan_rtx_reg): Keep track of conflicts between chains, and between\n+\tchains and hard regs.  Don't terminate chains when we find a read we\n+\tcan't handle, mark it unrenameable instead.  For terminate_write,\n+\tterminate chains that are written with an exact match or a superset\n+\tof registers.  Set fail_current_block if multi-word lifetimes are too\n+\tcomplex to handle.\n+\t(scan_rtx_address): Use mark_all_read instead of terminate_all_read.\n+\t(build_def_use): Initialize current_id, live_chains and live_hard_regs;\n+\tfree memory for them when done.\n+\tRearrange the steps so that earlyclobbers are noted before reads\n+\tare processed.  Add new steps to keep track of hard register lifetimes\n+\toutside insn operands.\n+\n 2009-11-26  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-dce.c (nr_walks): New variable."}, {"sha": "a29ffe349ee066df6a42c40e813c12e8886128f4", "filename": "gcc/regrename.c", "status": "modified", "additions": 330, "deletions": 193, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96caf80851972e5f4e3e48a368f7e9d9bf450d2/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96caf80851972e5f4e3e48a368f7e9d9bf450d2/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=a96caf80851972e5f4e3e48a368f7e9d9bf450d2", "patch": "@@ -50,10 +50,22 @@ struct du_head\n   struct du_chain *first, *last;\n   /* Describes the register being tracked.  */\n   unsigned regno, nregs;\n+\n+  /* A unique id to be used as an index into the conflicts bitmaps.  */\n+  unsigned id;\n+  /* A bitmap to record conflicts with other chains.  */\n+  bitmap_head conflicts;\n+  /* Conflicts with untracked hard registers.  */\n+  HARD_REG_SET hard_conflicts;\n+\n+  /* Nonzero if the chain is finished; zero if it is still open.  */\n+  unsigned int terminated:1;\n   /* Nonzero if the chain crosses a call.  */\n   unsigned int need_caller_save_reg:1;\n-  /* Nonzero if the chain is finished.  */\n-  unsigned int terminated:1;\n+  /* Nonzero if the register is used in a way that prevents renaming,\n+     such as the SET_DEST of a CALL_INSN or an asm operand that used\n+     to be a hard register.  */\n+  unsigned int cannot_rename:1;\n };\n \n /* This struct describes a single occurrence of a register.  */\n@@ -72,10 +84,9 @@ struct du_chain\n \n enum scan_actions\n {\n-  terminate_all_read,\n-  terminate_overlapping_read,\n   terminate_write,\n   terminate_dead,\n+  mark_all_read,\n   mark_read,\n   mark_write,\n   /* mark_access is for marking the destination regs in\n@@ -86,10 +97,9 @@ enum scan_actions\n \n static const char * const scan_actions_name[] =\n {\n-  \"terminate_all_read\",\n-  \"terminate_overlapping_read\",\n   \"terminate_write\",\n   \"terminate_dead\",\n+  \"mark_all_read\",\n   \"mark_read\",\n   \"mark_write\",\n   \"mark_access\"\n@@ -106,95 +116,38 @@ static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n \t\t      enum op_type);\n static struct du_head *build_def_use (basic_block);\n static void dump_def_use_chain (struct du_head *);\n-static void note_sets (rtx, const_rtx, void *);\n-static void clear_dead_regs (HARD_REG_SET *, enum reg_note, rtx);\n-static void merge_overlapping_regs (basic_block, HARD_REG_SET *,\n-\t\t\t\t    struct du_head *);\n \n-/* Called through note_stores.  Find sets of registers, and\n-   record them in *DATA (which is actually a HARD_REG_SET *).  */\n+typedef struct du_head *du_head_p;\n+DEF_VEC_P (du_head_p);\n+DEF_VEC_ALLOC_P (du_head_p, heap);\n+static VEC(du_head_p, heap) *id_to_chain;\n \n static void\n-note_sets (rtx x, const_rtx set ATTRIBUTE_UNUSED, void *data)\n+free_chain_data (void)\n {\n-  HARD_REG_SET *pset = (HARD_REG_SET *) data;\n+  int i;\n+  du_head_p ptr;\n+  for (i = 0; VEC_iterate(du_head_p, id_to_chain, i, ptr); i++)\n+    bitmap_clear (&ptr->conflicts);\n \n-  if (GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-  if (!REG_P (x))\n-    return;\n-  /* There must not be pseudos at this point.  */\n-  gcc_assert (HARD_REGISTER_P (x));\n-  add_to_hard_reg_set (pset, GET_MODE (x), REGNO (x));\n+  VEC_free (du_head_p, heap, id_to_chain);\n }\n \n-/* Clear all registers from *PSET for which a note of kind KIND can be found\n-   in the list NOTES.  */\n+/* For a def-use chain HEAD, find which registers overlap its lifetime and\n+   set the corresponding bits in *PSET.  */\n \n static void\n-clear_dead_regs (HARD_REG_SET *pset, enum reg_note kind, rtx notes)\n+merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n {\n-  rtx note;\n-  for (note = notes; note; note = XEXP (note, 1))\n-    if (REG_NOTE_KIND (note) == kind && REG_P (XEXP (note, 0)))\n-      {\n-\trtx reg = XEXP (note, 0);\n-\t/* There must not be pseudos at this point.  */\n-\tgcc_assert (HARD_REGISTER_P (reg));\n-\tremove_from_hard_reg_set (pset, GET_MODE (reg), REGNO (reg));\n-      }\n-}\n-\n-/* For a def-use chain HEAD in basic block B, find which registers overlap\n-   its lifetime and set the corresponding bits in *PSET.  */\n-\n-static void\n-merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n-\t\t\tstruct du_head *head)\n-{\n-  struct du_chain *t;\n-  rtx insn;\n-  HARD_REG_SET live;\n-  df_ref *def_rec;\n-\n-  REG_SET_TO_HARD_REG_SET (live, df_get_live_in (b));\n-  for (def_rec = df_get_artificial_defs (b->index); *def_rec; def_rec++)\n+  bitmap_iterator bi;\n+  unsigned i;\n+  IOR_HARD_REG_SET (*pset, head->hard_conflicts);\n+  EXECUTE_IF_SET_IN_BITMAP (&head->conflicts, 0, i, bi)\n     {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\tSET_HARD_REG_BIT (live, DF_REF_REGNO (def));\n-    }\n-\n-  t = head->first;\n-  insn = BB_HEAD (b);\n-  while (t)\n-    {\n-      /* Search forward until the next reference to the register to be\n-\t renamed.  */\n-      while (insn != t->insn)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      clear_dead_regs (&live, REG_DEAD, REG_NOTES (insn));\n-\t      note_stores (PATTERN (insn), note_sets, (void *) &live);\n-\t      /* Only record currently live regs if we are inside the\n-\t\t reg's live range.  */\n-\t      if (t != head->first)\n-\t\tIOR_HARD_REG_SET (*pset, live);\n-\t      clear_dead_regs (&live, REG_UNUSED, REG_NOTES (insn));\n-\t    }\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-\n-      IOR_HARD_REG_SET (*pset, live);\n-\n-      /* For the last reference, also merge in all registers set in the\n-\t same insn.\n-\t @@@ We only have take earlyclobbered sets into account.  */\n-      if (! t->next_use)\n-\tnote_stores (PATTERN (insn), note_sets, (void *) pset);\n-\n-      t = t->next_use;\n+      du_head_p other = VEC_index (du_head_p, id_to_chain, i);\n+      unsigned j = other->nregs;\n+      while (j-- > 0)\n+\tSET_HARD_REG_BIT (*pset, other->regno + j);\n     }\n }\n \n@@ -224,6 +177,8 @@ regrename_optimize (void)\n       HARD_REG_SET unavailable;\n       HARD_REG_SET regs_seen;\n \n+      id_to_chain = VEC_alloc (du_head_p, heap, 0);\n+\n       CLEAR_HARD_REG_SET (unavailable);\n \n       if (dump_file)\n@@ -247,7 +202,7 @@ regrename_optimize (void)\n       CLEAR_HARD_REG_SET (regs_seen);\n       while (all_chains)\n \t{\n-\t  int new_reg, best_new_reg;\n+\t  int new_reg, best_new_reg, best_nregs;\n \t  int n_uses;\n \t  struct du_head *this_head = all_chains;\n \t  struct du_chain *tmp;\n@@ -257,7 +212,11 @@ regrename_optimize (void)\n \n \t  all_chains = this_head->next_chain;\n \n+\t  if (this_head->cannot_rename)\n+\t    continue;\n+\n \t  best_new_reg = reg;\n+\t  best_nregs = this_head->nregs;\n \n #if 0 /* This just disables optimization opportunities.  */\n \t  /* Only rename once we've seen the reg more than once.  */\n@@ -297,7 +256,7 @@ regrename_optimize (void)\n \t  if (this_head->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n-\t  merge_overlapping_regs (bb, &this_unavailable, this_head);\n+\t  merge_overlapping_regs (&this_unavailable, this_head);\n \n \t  /* Now potential_regs is a reasonable approximation, let's\n \t     have a closer look at each register still in there.  */\n@@ -341,7 +300,10 @@ regrename_optimize (void)\n \t      if (! tmp)\n \t\t{\n \t\t  if (tick[best_new_reg] > tick[new_reg])\n-\t\t    best_new_reg = new_reg;\n+\t\t    {\n+\t\t      best_new_reg = new_reg;\n+\t\t      best_nregs = nregs;\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -365,10 +327,13 @@ regrename_optimize (void)\n \t    fprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n \n \t  do_replace (this_head, best_new_reg);\n+\t  this_head->regno = best_new_reg;\n+\t  this_head->nregs = best_nregs;\n \t  tick[best_new_reg] = ++this_tick;\n \t  df_set_regs_ever_live (best_new_reg, true);\n \t}\n \n+      free_chain_data ();\n       obstack_free (&rename_obstack, first_obj);\n     }\n \n@@ -385,6 +350,7 @@ do_replace (struct du_head *head, int reg)\n {\n   struct du_chain *chain;\n   unsigned int base_regno = head->regno;\n+  bool found_note = false;\n \n   gcc_assert (! DEBUG_INSN_P (head->first->insn));\n \n@@ -408,26 +374,92 @@ do_replace (struct du_head *head, int reg)\n \n \t  for (note = REG_NOTES (chain->insn); note; note = XEXP (note, 1))\n \t    {\n-\t      if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t  || REG_NOTE_KIND (note) == REG_UNUSED)\n+\t      enum reg_note kind = REG_NOTE_KIND (note);\n+\t      if (kind == REG_DEAD || kind == REG_UNUSED)\n \t\t{\n \t\t  rtx reg = XEXP (note, 0);\n \t\t  gcc_assert (HARD_REGISTER_P (reg));\n \n \t\t  if (REGNO (reg) == base_regno)\n-\t\t    XEXP (note, 0) = *chain->loc;\n+\t\t    {\n+\t\t      found_note = true;\n+\t\t      if (kind == REG_DEAD\n+\t\t\t  && reg_set_p (*chain->loc, chain->insn))\n+\t\t\tremove_note (chain->insn, note);\n+\t\t      else\n+\t\t\tXEXP (note, 0) = *chain->loc;\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n \n       df_insn_rescan (chain->insn);\n     }\n+  if (!found_note)\n+    {\n+      /* If the chain's first insn is the same as the last, we should have\n+\t found a REG_UNUSED note.  */\n+      gcc_assert (head->first->insn != head->last->insn);\n+      if (!reg_set_p (*head->last->loc, head->last->insn))\n+\tadd_reg_note (head->last->insn, REG_DEAD, *head->last->loc);\n+    }\n }\n \n \n+/* Walk all chains starting with CHAINS and record that they conflict with\n+   another chain whose id is ID.  */\n+\n+static void\n+mark_conflict (struct du_head *chains, unsigned id)\n+{\n+  while (chains)\n+    {\n+      bitmap_set_bit (&chains->conflicts, id);\n+      chains = chains->next_chain;\n+    }\n+}\n+\n+/* True if we found a register with a size mismatch, which means that we\n+   can't track its lifetime accurately.  If so, we abort the current block\n+   without renaming.  */\n+static bool fail_current_block;\n+\n+/* The id to be given to the next opened chain.  */\n+static unsigned current_id;\n+\n+/* List of currently open chains, and closed chains that can be renamed.  */\n static struct du_head *open_chains;\n static struct du_head *closed_chains;\n \n+/* Conflict bitmaps, tracking the live chains and the live hard registers.\n+   The bits set in open_chains_set always match the list found in\n+   open_chains.  */\n+static bitmap_head open_chains_set;\n+static HARD_REG_SET live_hard_regs;\n+\n+/* Called through note_stores.  DATA points to a rtx_code, either SET or\n+   CLOBBER, which tells us which kind of rtx to look at.  If we have a\n+   match, record the set register in live_hard_regs and in the hard_conflicts\n+   bitmap of open chains.  */\n+\n+static void\n+note_sets_clobbers (rtx x, const_rtx set, void *data)\n+{\n+  enum rtx_code code = *(enum rtx_code *)data;\n+  struct du_head *chain;\n+\n+  if (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+  if (!REG_P (x) || GET_CODE (set) != code)\n+    return;\n+  /* There must not be pseudos at this point.  */\n+  gcc_assert (HARD_REGISTER_P (x));\n+  add_to_hard_reg_set (&live_hard_regs, GET_MODE (x), REGNO (x));\n+  for (chain = open_chains; chain; chain = chain->next_chain)\n+    add_to_hard_reg_set (&chain->hard_conflicts, GET_MODE (x), REGNO (x));\n+}\n+\n static void\n scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      enum op_type type)\n@@ -444,18 +476,45 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t{\n \t  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n \t  struct du_chain *this_du = XOBNEW (&rename_obstack, struct du_chain);\n+\t  int nregs;\n+\n \t  head->next_chain = open_chains;\n \t  open_chains = head;\n \t  head->first = head->last = this_du;\n \t  head->regno = this_regno;\n \t  head->nregs = this_nregs;\n \t  head->need_caller_save_reg = 0;\n+\t  head->cannot_rename = 0;\n \t  head->terminated = 0;\n \n+\t  VEC_safe_push (du_head_p, heap, id_to_chain, head);\n+\t  head->id = current_id++;\n+\n+\t  bitmap_initialize (&head->conflicts, &bitmap_default_obstack);\n+\t  bitmap_copy (&head->conflicts, &open_chains_set);\n+\t  mark_conflict (open_chains, head->id);\n+\n+\t  /* Since we're tracking this as a chain now, remove it from the\n+\t     list of conflicting live hard registers.  */\n+\t  nregs = head->nregs;\n+\t  while (nregs-- > 0)\n+\t    CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n+\n+\t  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n+\t  bitmap_set_bit (&open_chains_set, head->id);\n+\n+\t  open_chains = head;\n+\n \t  this_du->next_use = 0;\n \t  this_du->loc = loc;\n \t  this_du->insn = insn;\n \t  this_du->cl = cl;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Creating chain %s (%d) at insn %d (%s)\\n\",\n+\t\t     reg_names[head->regno], head->id, INSN_UID (insn),\n+\t\t     scan_actions_name[(int) action]);\n \t}\n       return;\n     }\n@@ -466,82 +525,94 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n   for (p = &open_chains; *p;)\n     {\n       struct du_head *head = *p;\n+      struct du_head *next = head->next_chain;\n+      int exact_match = (head->regno == this_regno\n+\t\t\t && head->nregs == this_nregs);\n+      int superset = (this_regno <= head->regno\n+\t\t      && this_regno + this_nregs >= head->regno + head->nregs);\n+\n+      if (head->terminated\n+\t  || head->regno + head->nregs <= this_regno\n+\t  || this_regno + this_nregs <= head->regno)\n+\t{\n+\t  p = &head->next_chain;\n+\t  continue;\n+\t}\n \n-      /* Check if the chain has been terminated if it has then skip to\n-\t the next chain.\n-\n-\t This can happen when we've already appended the location to\n-\t the chain in Step 3, but are trying to hide in-out operands\n-\t from terminate_write in Step 5.  */\n-\n-      if (head->terminated)\n-\tp = &head->next_chain;\n-      else\n+      if (action == mark_read || action == mark_access)\n \t{\n-\t  int exact_match = (head->regno == this_regno\n-\t\t\t     && head->nregs == this_nregs);\n+\t  /* ??? Class NO_REGS can happen if the md file makes use of\n+\t     EXTRA_CONSTRAINTS to match registers.  Which is arguably\n+\t     wrong, but there we are.  */\n \n-\t  if (head->regno + head->nregs <= this_regno\n-\t      || this_regno + this_nregs <= head->regno)\n+\t  if (cl == NO_REGS || (!exact_match && !DEBUG_INSN_P (insn)))\n \t    {\n-\t      p = &head->next_chain;\n-\t      continue;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Cannot rename chain %s (%d) at insn %d (%s)\\n\",\n+\t\t\t reg_names[head->regno], head->id, INSN_UID (insn),\n+\t\t\t scan_actions_name[(int) action]);\n+\t      head->cannot_rename = 1;\n \t    }\n-\n-\t  if (action == mark_read || action == mark_access)\n+\t  else\n \t    {\n-\t      gcc_assert (exact_match || DEBUG_INSN_P (insn));\n+\t      struct du_chain *this_du;\n+\t      this_du = XOBNEW (&rename_obstack, struct du_chain);\n+\t      this_du->next_use = 0;\n+\t      this_du->loc = loc;\n+\t      this_du->insn = insn;\n+\t      this_du->cl = cl;\n+\t      head->last->next_use = this_du;\n+\t      head->last = this_du;\n \n-\t      /* ??? Class NO_REGS can happen if the md file makes use of\n-\t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n-\t\t wrong, but there we are.  Since we know not what this may\n-\t\t be replaced with, terminate the chain.  */\n-\t      if (cl != NO_REGS)\n-\t\t{\n-\t\t  struct du_chain *this_du;\n-\t\t  this_du = XOBNEW (&rename_obstack, struct du_chain);\n-\t\t  this_du->next_use = 0;\n-\t\t  this_du->loc = loc;\n-\t\t  this_du->insn = insn;\n-\t\t  this_du->cl = cl;\n-\t\t  head->last->next_use = this_du;\n-\t\t  head->last = this_du;\n-\t\t  return;\n-\t\t}\n \t    }\n+\t  /* Avoid adding the same location in a DEBUG_INSN multiple times,\n+\t     which could happen with non-exact overlap.  */\n+\t  if (DEBUG_INSN_P (insn))\n+\t    return;\n+\t  /* Otherwise, find any other chains that do not match exactly;\n+\t     ensure they all get marked unrenamable.  */\n+\t  p = &head->next_chain;\n+\t  continue;\n+\t}\n \n-\t  if (action != terminate_overlapping_read || ! exact_match)\n-\t    {\n-\t      struct du_head *next = head->next_chain;\n-\n-\t      /* Whether the terminated chain can be used for renaming\n-\t         depends on the action and this being an exact match.\n-\t         In either case, we remove this element from open_chains.  */\n+      /* Whether the terminated chain can be used for renaming\n+\t depends on the action and this being an exact match.\n+\t In either case, we remove this element from open_chains.  */\n \n-\t      head->terminated = 1;\n-\t      if ((action == terminate_dead || action == terminate_write)\n-\t\t  && exact_match)\n-\t\t{\n-\t\t  head->next_chain = closed_chains;\n-\t\t  closed_chains = head;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Closing chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[head->regno], INSN_UID (insn),\n-\t\t\t     scan_actions_name[(int) action]);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Discarding chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[head->regno], INSN_UID (insn),\n-\t\t\t     scan_actions_name[(int) action]);\n-\t\t}\n-\t      *p = next;\n-\t    }\n-\t  else\n-\t    p = &head->next_chain;\n+      if ((action == terminate_dead || action == terminate_write)\n+\t  && superset)\n+\t{\n+\t  head->terminated = 1;\n+\t  head->next_chain = closed_chains;\n+\t  closed_chains = head;\n+\t  bitmap_clear_bit (&open_chains_set, head->id);\n+\t  *p = next;\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Closing chain %s (%d) at insn %d (%s)\\n\",\n+\t\t     reg_names[head->regno], head->id, INSN_UID (insn),\n+\t\t     scan_actions_name[(int) action]);\n+\t}\n+      else if (action == terminate_dead || action == terminate_write)\n+\t{\n+\t  /* In this case, tracking liveness gets too hard.  Fail the\n+\t     entire basic block.  */\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Failing basic block due to unhandled overlap\\n\");\n+\t  fail_current_block = true;\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  head->cannot_rename = 1;\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Cannot rename chain %s (%d) at insn %d (%s)\\n\",\n+\t\t     reg_names[head->regno], head->id, INSN_UID (insn),\n+\t\t     scan_actions_name[(int) action]);\n+\t  p = &head->next_chain;\n \t}\n     }\n }\n@@ -667,7 +738,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n #ifndef AUTO_INC_DEC\n       /* If the target doesn't claim to handle autoinc, this must be\n \t something special, like a stack push.  Kill this chain.  */\n-      action = terminate_all_read;\n+      action = mark_all_read;\n #endif\n       break;\n \n@@ -785,13 +856,15 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n /* Hide operands of the current insn (of which there are N_OPS) by\n    substituting cc0 for them.\n    Previous values are stored in the OLD_OPERANDS and OLD_DUPS.\n-   If INOUT_ONLY is set, we only do this for OP_INOUT type operands.  */\n+   If INOUT_AND_EC_ONLY is set, we only do this for OP_INOUT type operands\n+   and earlyclobbers.  */\n \n static void\n hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n-\t       bool inout_only)\n+\t       bool inout_and_ec_only)\n {\n   int i;\n+  int alt = which_alternative;\n   for (i = 0; i < n_ops; i++)\n     {\n       old_operands[i] = recog_data.operand[i];\n@@ -800,14 +873,16 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n \t reachable by proper operands.  */\n       if (recog_data.constraints[i][0] == '\\0')\n \tcontinue;\n-      if (!inout_only || recog_data.operand_type[i] == OP_INOUT)\n+      if (!inout_and_ec_only || recog_data.operand_type[i] == OP_INOUT\n+\t  || recog_op_alt[i][alt].earlyclobber)\n \t*recog_data.operand_loc[i] = cc0_rtx;\n     }\n   for (i = 0; i < recog_data.n_dups; i++)\n     {\n       int opn = recog_data.dup_num[i];\n       old_dups[i] = *recog_data.dup_loc[i];\n-      if (!inout_only || recog_data.operand_type[opn] == OP_INOUT)\n+      if (!inout_and_ec_only || recog_data.operand_type[opn] == OP_INOUT\n+\t  || recog_op_alt[opn][alt].earlyclobber)\n \t*recog_data.dup_loc[i] = cc0_rtx;\n     }\n }\n@@ -828,10 +903,11 @@ restore_operands (rtx insn, int n_ops, rtx *old_operands, rtx *old_dups)\n }\n \n /* For each output operand of INSN, call scan_rtx to create a new\n-   open chain.  */\n+   open chain.  Do this only for normal or earlyclobber outputs,\n+   depending on EARLYCLOBBER.  */\n \n static void\n-record_out_operands (rtx insn)\n+record_out_operands (rtx insn, bool earlyclobber)\n {\n   int n_ops = recog_data.n_operands;\n   int alt = which_alternative;\n@@ -849,7 +925,8 @@ record_out_operands (rtx insn)\n \n       struct du_head *prev_open;\n \n-      if (recog_data.operand_type[opn] != OP_OUT)\n+      if (recog_data.operand_type[opn] != OP_OUT\n+\t  || recog_op_alt[opn][alt].earlyclobber != earlyclobber)\n \tcontinue;\n \n       prev_open = open_chains;\n@@ -866,7 +943,7 @@ record_out_operands (rtx insn)\n \t      && REGNO (op) == ORIGINAL_REGNO (op)))\n \t{\n \t  if (prev_open != open_chains)\n-\t    open_chains->first->cl = NO_REGS;\n+\t    open_chains->cannot_rename = 1;\n \t}\n     }\n }\n@@ -877,9 +954,22 @@ static struct du_head *\n build_def_use (basic_block bb)\n {\n   rtx insn;\n+  df_ref *def_rec;\n \n   open_chains = closed_chains = NULL;\n \n+  fail_current_block = false;\n+\n+  current_id = 0;\n+  bitmap_initialize (&open_chains_set, &bitmap_default_obstack);\n+  REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_in (bb));\n+  for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\tSET_HARD_REG_BIT (live_hard_regs, DF_REF_REGNO (def));\n+    }\n+\n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (NONDEBUG_INSN_P (insn))\n@@ -891,22 +981,31 @@ build_def_use (basic_block bb)\n \t  int i, icode;\n \t  int alt;\n \t  int predicated;\n+\t  enum rtx_code set_code = SET;\n+\t  enum rtx_code clobber_code = CLOBBER;\n \n \t  /* Process the insn, determining its effect on the def-use\n-\t     chains.  We perform the following steps with the register\n-\t     references in the insn:\n-\t     (1) Any read that overlaps an open chain, but doesn't exactly\n-\t         match, causes that chain to be closed.  We can't deal\n-\t         with overlaps yet.\n+\t     chains and live hard registers.  We perform the following\n+\t     steps with the register references in the insn, simulating\n+\t     its effect:\n+\t     (1) Deal with earlyclobber operands and CLOBBERs of non-operands\n+\t         by creating chains and marking hard regs live.\n \t     (2) Any read outside an operand causes any chain it overlaps\n-\t         with to be closed, since we can't replace it.\n+\t         with to be marked unrenamable.\n \t     (3) Any read inside an operand is added if there's already\n \t         an open chain for it.\n \t     (4) For any REG_DEAD note we find, close open chains that\n \t         overlap it.\n-\t     (5) For any write we find, close open chains that overlap it.\n-\t     (6) For any write we find in an operand, make a new chain.\n-\t     (7) For any REG_UNUSED, close any chains we just opened.  */\n+\t     (5) For any non-earlyclobber write we find, close open chains\n+\t         that overlap it.\n+\t     (6) For any non-earlyclobber write we find in an operand, make\n+\t         a new chain or mark the hard register as live.\n+\t     (7) For any REG_UNUSED, close any chains we just opened.\n+\n+\t     We cannot deal with situations where we track a reg in one mode\n+\t     and see a reference in another mode; these will cause the chain\n+\t     to be marked unrenamable or even cause us to abort the entire\n+\t     basic block.  */\n \n \t  icode = recog_memoized (insn);\n \t  extract_insn (insn);\n@@ -928,28 +1027,41 @@ build_def_use (basic_block bb)\n \t\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n \t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n \t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n-\t\trecog_data.operand_type[i] = OP_INOUT;\n+\t\t{\n+\t\t  recog_data.operand_type[i] = OP_INOUT;\n+\t\t  if (matches >= 0\n+\t\t      && (GET_MODE_SIZE (recog_data.operand_mode[i])\n+\t\t\t  != GET_MODE_SIZE (recog_data.operand_mode[matches])))\n+\t\t    fail_current_block = true;\n+\t\t}\n \t    }\n \n-\t  /* Step 1: Close chains for which we have overlapping reads.  */\n-\t  for (i = 0; i < n_ops; i++)\n-\t    scan_rtx (insn, recog_data.operand_loc[i],\n-\t\t      NO_REGS, terminate_overlapping_read,\n-\t\t      recog_data.operand_type[i]);\n+\t  if (fail_current_block)\n+\t    break;\n+\n+\t  /* Step 1a: Mark hard registers that are clobbered in this insn,\n+\t     outside an operand, as live.  */\n+\t  hide_operands (n_ops, old_operands, old_dups, false);\n+\t  note_stores (PATTERN (insn), note_sets_clobbers, &clobber_code);\n+\t  restore_operands (insn, n_ops, old_operands, old_dups);\n+\n+\t  /* Step 1b: Begin new chains for earlyclobbered writes inside\n+\t     operands.  */\n+\t  record_out_operands (insn, true);\n \n-\t  /* Step 2: Close chains for which we have reads outside operands.\n+\t  /* Step 2: Mark chains for which we have reads outside operands\n+\t     as unrenamable.\n \t     We do this by munging all operands into CC0, and closing\n \t     everything remaining.  */\n \n \t  hide_operands (n_ops, old_operands, old_dups, false);\n-\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_all_read,\n-\t\t    OP_IN);\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, mark_all_read, OP_IN);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 2B: Can't rename function call argument registers.  */\n \t  if (CALL_P (insn) && CALL_INSN_FUNCTION_USAGE (insn))\n \t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t      NO_REGS, terminate_all_read, OP_IN);\n+\t\t      NO_REGS, mark_all_read, OP_IN);\n \n \t  /* Step 2C: Can't rename asm operands that were originally\n \t     hard registers.  */\n@@ -963,7 +1075,7 @@ build_def_use (basic_block bb)\n \t\t    && REGNO (op) == ORIGINAL_REGNO (op)\n \t\t    && (recog_data.operand_type[i] == OP_IN\n \t\t\t|| recog_data.operand_type[i] == OP_INOUT))\n-\t\t  scan_rtx (insn, loc, NO_REGS, terminate_all_read, OP_IN);\n+\t\t  scan_rtx (insn, loc, NO_REGS, mark_all_read, OP_IN);\n \t      }\n \n \t  /* Step 3: Append to chains for reads inside operands.  */\n@@ -999,8 +1111,13 @@ build_def_use (basic_block bb)\n \t  /* Step 4: Close chains for registers that die here.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_DEAD)\n-\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n-\t\t\tOP_IN);\n+\t      {\n+\t\tremove_from_hard_reg_set (&live_hard_regs,\n+\t\t\t\t\t  GET_MODE (XEXP (note, 0)),\n+\t\t\t\t\t  REGNO (XEXP (note, 0)));\n+\t\tscan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n+\t\t\t  OP_IN);\n+\t      }\n \n \t  /* Step 4B: If this is a call, any chain live at this point\n \t     requires a caller-saved reg.  */\n@@ -1013,16 +1130,26 @@ build_def_use (basic_block bb)\n \n \t  /* Step 5: Close open chains that overlap writes.  Similar to\n \t     step 2, we hide in-out operands, since we do not want to\n-\t     close these chains.  */\n+\t     close these chains.  We also hide earlyclobber operands,\n+\t     since we've opened chains for them in step 1, and earlier\n+\t     chains they would overlap with must have been closed at\n+\t     the previous insn at the latest, as such operands cannot\n+\t     possibly overlap with any input operands.  */\n \n \t  hide_operands (n_ops, old_operands, old_dups, true);\n \t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n-\t  /* Step 6: Begin new chains for writes inside operands.  */\n-\t  record_out_operands (insn);\n+\t  /* Step 6a: Mark hard registers that are set in this insn,\n+\t     outside an operand, as live.  */\n+\t  hide_operands (n_ops, old_operands, old_dups, false);\n+\t  note_stores (PATTERN (insn), note_sets_clobbers, &set_code);\n+\t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n-\t  /* Step 6B: Record destination regs in REG_FRAME_RELATED_EXPR\n+\t  /* Step 6b: Begin new chains for writes inside operands.  */\n+\t  record_out_operands (insn, false);\n+\n+\t  /* Step 6c: Record destination regs in REG_FRAME_RELATED_EXPR\n \t     notes for update.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_FRAME_RELATED_EXPR)\n@@ -1033,8 +1160,13 @@ build_def_use (basic_block bb)\n \t     really used here.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_UNUSED)\n-\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n-\t\t\tOP_IN);\n+\t      {\n+\t\tremove_from_hard_reg_set (&live_hard_regs,\n+\t\t\t\t\t  GET_MODE (XEXP (note, 0)),\n+\t\t\t\t\t  REGNO (XEXP (note, 0)));\n+\t\tscan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n+\t\t\t  OP_IN);\n+\t      }\n \t}\n       else if (DEBUG_INSN_P (insn)\n \t       && !VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))\n@@ -1046,6 +1178,11 @@ build_def_use (basic_block bb)\n \tbreak;\n     }\n \n+  bitmap_clear (&open_chains_set);\n+\n+  if (fail_current_block)\n+    return NULL;\n+\n   /* Since we close every chain when we find a REG_DEAD note, anything that\n      is still open lives past the basic block, so it can't be renamed.  */\n   return closed_chains;"}]}