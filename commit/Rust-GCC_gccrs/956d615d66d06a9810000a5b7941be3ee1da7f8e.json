{"sha": "956d615d66d06a9810000a5b7941be3ee1da7f8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2ZDYxNWQ2NmQwNmE5ODEwMDAwYTViNzk0MWJlM2VlMWRhN2Y4ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-23T11:44:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-23T11:44:51Z"}, "message": "ipa-fnsummary.c: Fix comment typos.\n\n\t* ipa-fnsummary.c: Fix comment typos.\n\t* ipa-ref.h: Likewise.\n\t* ipa-predicate.h: Likewise.\n\t* ipa-split.c: Likewise.\n\t* ipa-inline-analysis.c: Likewise.\n\t* ipa-predicate.c: Likewise.\n\t* ipa-devirt.c: Likewise.\n\t* ipa-icf.h: Likewise.\n\t* profile-count.c: Likewise.\n\t* ipa-icf.c: Likewise.\n\t(sem_function::equals_wpa): Fix typos in dump messages.\n\t* ipa-icf-gimple.h: Fix comment typos.\n\t* ipa-inline-transform.c: Likewise.\n\t* ipa-polymorphic-call.c: Likewise.\n\t* ipa-fnsummary.h: Likewise.\n\t* ipa-inline.c: Likewise.\n\t(dump_inline_stats): Fix typo in debug dump message.\n\t* profile-count.h: Fix comment typos.\n\nFrom-SVN: r278643", "tree": {"sha": "c83ab08bf31cd219c19b4ce43217b5a462726223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c83ab08bf31cd219c19b4ce43217b5a462726223"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/956d615d66d06a9810000a5b7941be3ee1da7f8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956d615d66d06a9810000a5b7941be3ee1da7f8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956d615d66d06a9810000a5b7941be3ee1da7f8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956d615d66d06a9810000a5b7941be3ee1da7f8e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d0d7a63019a7d67943d1867348673e3ca3dc824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0d7a63019a7d67943d1867348673e3ca3dc824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d0d7a63019a7d67943d1867348673e3ca3dc824"}], "stats": {"total": 297, "additions": 158, "deletions": 139}, "files": [{"sha": "b7d223ca8d0409fc897959e2dd715fd9458420fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -1,5 +1,24 @@\n 2019-11-23  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* ipa-fnsummary.c: Fix comment typos.\n+\t* ipa-ref.h: Likewise.\n+\t* ipa-predicate.h: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* ipa-inline-analysis.c: Likewise.\n+\t* ipa-predicate.c: Likewise.\n+\t* ipa-devirt.c: Likewise.\n+\t* ipa-icf.h: Likewise.\n+\t* profile-count.c: Likewise.\n+\t* ipa-icf.c: Likewise.\n+\t(sem_function::equals_wpa): Fix typos in dump messages.\n+\t* ipa-icf-gimple.h: Fix comment typos.\n+\t* ipa-inline-transform.c: Likewise.\n+\t* ipa-polymorphic-call.c: Likewise.\n+\t* ipa-fnsummary.h: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t(dump_inline_stats): Fix typo in debug dump message.\n+\t* profile-count.h: Fix comment typos.\n+\n \tPR target/92615\n \t* config/i386/i386.c (ix86_md_asm_adjust): If dest_mode is\n \tGET_MODE (dest), is not QImode, using ZERO_EXTEND and dest is not"}, {"sha": "c158d3c968df123053e524080a61b580048b7aae", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -216,7 +216,7 @@ struct GTY(()) odr_type_d\n   bool all_derivations_known;\n   /* Did we report ODR violation here?  */\n   bool odr_violated;\n-  /* Set when virtual table without RTTI previaled table with.  */\n+  /* Set when virtual table without RTTI prevailed table with.  */\n   bool rtti_broken;\n   /* Set when the canonical type is determined using the type name.  */\n   bool tbaa_enabled;\n@@ -655,7 +655,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n       end2 = !vtable->iterate_reference (n2, ref2);\n \n       /* !DECL_VIRTUAL_P means RTTI entry;\n-\t We warn when RTTI is lost because non-RTTI previals; we silently\n+\t We warn when RTTI is lost because non-RTTI prevails; we silently\n \t accept the other case.  */\n       while (!end2\n \t     && (end1\n@@ -767,7 +767,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \n       class_type->odr_violated = true;\n \n-      /* Complain about size mismatch.  Either we have too many virutal\n+      /* Complain about size mismatch.  Either we have too many virtual\n  \t functions or too many virtual table pointers.  */\n       if (end1 || end2)\n \t{\n@@ -861,7 +861,7 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n   if (!warn || !TYPE_NAME(TYPE_MAIN_VARIANT (t1)))\n     return;\n \n-  /* ODR warnings are output druing LTO streaming; we must apply location\n+  /* ODR warnings are output during LTO streaming; we must apply location\n      cache for potential warnings to be output correctly.  */\n   if (lto_location_cache::current_cache)\n     lto_location_cache::current_cache->apply_location_cache ();\n@@ -920,7 +920,7 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n     *warned = true;\n }\n \n-/* Return ture if T1 and T2 are incompatible and we want to recusively\n+/* Return true if T1 and T2 are incompatible and we want to recursively\n    dive into them from warn_type_mismatch to give sensible answer.  */\n \n static bool\n@@ -941,7 +941,7 @@ type_mismatch_p (tree t1, tree t2)\n    This is hard to do in general.  We basically handle the common cases.\n \n    If LOC1 and LOC2 are meaningful locations, use it in the case the types\n-   themselves do no thave one.*/\n+   themselves do not have one.  */\n \n void\n warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n@@ -1006,7 +1006,7 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n \tn1 = DECL_NAME (n1);\n       if (n2 && TREE_CODE (n2) == TYPE_DECL)\n \tn2 = DECL_NAME (n2);\n-      /* Most of the time, the type names will match, do not be unnecesarily\n+      /* Most of the time, the type names will match, do not be unnecessarily\n          verbose.  */\n       if (n1 != n2)\n         inform (loc_t1,\n@@ -1132,7 +1132,7 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n   if (types_odr_comparable (t1, t2)\n       /* We make assign integers mangled names to be able to handle\n \t signed/unsigned chars.  Accepting them here would however lead to\n-\t confussing message like\n+\t confusing message like\n \t \"type \u2018const int\u2019 itself violates the C++ One Definition Rule\"  */\n       && TREE_CODE (t1) != INTEGER_TYPE\n       && types_same_for_odr (t1, t2))\n@@ -1149,7 +1149,7 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n     inform (loc_t2, \"the incompatible type is defined here\");\n }\n \n-/* Return true if T should be ignored in TYPE_FIELDS for ODR comparsion.  */\n+/* Return true if T should be ignored in TYPE_FIELDS for ODR comparison.  */\n \n static bool\n skip_in_fields_list_p (tree t)\n@@ -2047,7 +2047,7 @@ odr_type_violation_reported_p (tree type)\n   return get_odr_type (type, false)->odr_violated;\n }\n \n-/* Add TYPE od ODR type hash.  */\n+/* Add TYPE of ODR type hash.  */\n \n void\n register_odr_type (tree type)\n@@ -2056,7 +2056,7 @@ register_odr_type (tree type)\n     odr_hash = new odr_hash_type (23);\n   if (type == TYPE_MAIN_VARIANT (type))\n     {\n-      /* To get ODR warings right, first register all sub-types.  */\n+      /* To get ODR warnings right, first register all sub-types.  */\n       if (RECORD_OR_UNION_TYPE_P (type)\n \t  && COMPLETE_TYPE_P (type))\n \t{\n@@ -2157,7 +2157,7 @@ dump_type_inheritance_graph (FILE *f)\n \tcontinue;\n \n       /* To aid ODR warnings we also mangle integer constants but do\n-\t not consinder duplicates there.  */\n+\t not consider duplicates there.  */\n       if (TREE_CODE (odr_types[i]->type) == INTEGER_TYPE)\n \tcontinue;\n \n@@ -2987,7 +2987,7 @@ class final_warning_record *final_warning_records;\n    If INCLUDE_BASES is true, walk also base types of OUTER_TYPES containing\n    OTR_TYPE and include their virtual method.  This is useful for types\n    possibly in construction or destruction where the virtual table may\n-   temporarily change to one of base types.  INCLUDE_DERIVER_TYPES make\n+   temporarily change to one of base types.  INCLUDE_DERIVED_TYPES make\n    us to walk the inheritance graph for all derivations.\n \n    If COMPLETEP is non-NULL, store true if the list is complete. \n@@ -3672,7 +3672,7 @@ ipa_devirt (void)\n \t       itself.\n \n \t       This may need to be revisited once we add further ways to use\n-\t       the may edges, but it is a resonable thing to do right now.  */\n+\t       the may edges, but it is a reasonable thing to do right now.  */\n \n \t    if ((e->indirect_info->param_index == -1\n \t\t|| (!opt_for_fn (n->decl, flag_devirtualize_speculatively)"}, {"sha": "e53d9e9013c43fdd903ca33886e1255935d43ca4", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -145,7 +145,7 @@ ipa_dump_hints (FILE *f, ipa_hints hints)\n \n /* Record SIZE and TIME to SUMMARY.\n    The accounted code will be executed when EXEC_PRED is true.\n-   When NONCONST_PRED is false the code will evaulate to constant and\n+   When NONCONST_PRED is false the code will evaluate to constant and\n    will get optimized out in specialized clones of the function.\n    If CALL is true account to call_size_time_table rather than\n    size_time_table.   */\n@@ -171,12 +171,12 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n   if (nonconst_pred == false)\n     return;\n \n-  /* We need to create initial empty unconitional clause, but otherwie\n+  /* We need to create initial empty unconditional clause, but otherwise\n      we don't need to account empty times and sizes.  */\n   if (!size && time == 0 && table)\n     return;\n \n-  /* Only for calls we are unaccounting what we previously recoreded.  */\n+  /* Only for calls we are unaccounting what we previously recorded.  */\n   gcc_checking_assert (time >= 0 || call);\n \n   for (i = 0; vec_safe_iterate (table, i, &e); i++)\n@@ -234,7 +234,7 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n     }\n }\n \n-/* We proved E to be unreachable, redirect it to __bultin_unreachable.  */\n+/* We proved E to be unreachable, redirect it to __builtin_unreachable.  */\n \n static struct cgraph_edge *\n redirect_to_unreachable (struct cgraph_edge *e)\n@@ -309,17 +309,17 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n }\n \n \n-/* Compute what conditions may or may not hold given invormation about\n+/* Compute what conditions may or may not hold given information about\n    parameters.  RET_CLAUSE returns truths that may hold in a specialized copy,\n-   whie RET_NONSPEC_CLAUSE returns truths that may hold in an nonspecialized\n+   while RET_NONSPEC_CLAUSE returns truths that may hold in an nonspecialized\n    copy when called in a given context.  It is a bitmask of conditions. Bit\n    0 means that condition is known to be false, while bit 1 means that condition\n    may or may not be true.  These differs - for example NOT_INLINED condition\n    is always false in the second and also builtin_constant_p tests cannot use\n    the fact that parameter is indeed a constant.\n \n    KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n-   KNOWN_AGGS is a vector of aggreggate known offset/value set for each\n+   KNOWN_AGGS is a vector of aggregate known offset/value set for each\n    parameter.  Return clause of possible truths.  When INLINE_P is true, assume\n    that we are inlining.\n \n@@ -506,12 +506,12 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n /* Work out what conditions might be true at invocation of E.\n    Compute costs for inlined edge if INLINE_P is true.\n \n-   Return in CLAUSE_PTR the evaluated condistions and in NONSPEC_CLAUSE_PTR\n+   Return in CLAUSE_PTR the evaluated conditions and in NONSPEC_CLAUSE_PTR\n    (if non-NULL) conditions evaluated for nonspecialized clone called\n    in a given context.\n \n    KNOWN_VALS_PTR and KNOWN_AGGS_PTR must be non-NULL and will be filled by\n-   known canstant and aggregate values of parameters.\n+   known constant and aggregate values of parameters.\n \n    KNOWN_CONTEXT_PTR, if non-NULL, will be filled by polymorphic call contexts\n    of parameter used by a polymorphic call.  */\n@@ -784,7 +784,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       info->account_size_time (0, 0, true_pred, true_pred);\n \n       /* Remap size_time vectors.\n-         Simplify the predicate by prunning out alternatives that are known\n+         Simplify the predicate by pruning out alternatives that are known\n          to be false.\n          TODO: as on optimization, we can also eliminate conditions known\n          to be true.  */\n@@ -822,7 +822,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n \n-      /* Remap indirect edge predicates with the same simplificaiton as above. \n+      /* Remap indirect edge predicates with the same simplification as above.\n          Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n@@ -847,7 +847,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       /* If inliner or someone after inliner will ever start producing\n          non-trivial clones, we will get trouble with lack of information\n          about updating self sizes, because size vectors already contains\n-         sizes of the calees.  */\n+         sizes of the callees.  */\n       gcc_assert (!inlined_to_p || !optimized_out_size);\n     }\n   else\n@@ -1202,7 +1202,7 @@ eliminated_by_inlining_prob (ipa_func_body_info *fbi, gimple *stmt)\n \n       /* Casts of parameters, loads from parameters passed by reference\n          and stores to return value or parameters are often free after\n-         inlining dua to SRA and further combining.\n+         inlining due to SRA and further combining.\n          Assume that half of statements goes away.  */\n       if (CONVERT_EXPR_CODE_P (rhs_code)\n \t  || rhs_code == VIEW_CONVERT_EXPR\n@@ -1256,20 +1256,20 @@ eliminated_by_inlining_prob (ipa_func_body_info *fbi, gimple *stmt)\n \t    lhs_free = true;\n \n \t  /* Writes to parameters, parameters passed by value and return value\n-\t     (either dirrectly or passed via invisible reference) are free.  \n+\t     (either directly or passed via invisible reference) are free.  \n \n \t     TODO: We ought to handle testcase like\n \t     struct a {int a,b;};\n \t     struct a\n-\t     retrurnsturct (void)\n+\t     returnstruct (void)\n \t     {\n \t     struct a a ={1,2};\n \t     return a;\n \t     }\n \n \t     This translate into:\n \n-\t     retrurnsturct ()\n+\t     returnstruct ()\n \t     {\n \t     int a$b;\n \t     int a$a;\n@@ -1467,7 +1467,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t  enum tree_code this_code = (e->flags & EDGE_TRUE_VALUE\n \t\t\t\t      ? code : inverted_code);\n \t  /* invert_tree_comparison will return ERROR_MARK on FP\n-\t     comparsions that are not EQ/NE instead of returning proper\n+\t     comparisons that are not EQ/NE instead of returning proper\n \t     unordered one.  Be sure it is not confused with NON_CONSTANT.\n \n \t     And if the edge's target is the final block of diamond CFG graph\n@@ -1498,7 +1498,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n      Here we can predicate nonconstant_code.  We can't\n      really handle constant_code since we have no predicate\n      for this and also the constant code is not known to be\n-     optimized away when inliner doen't see operand is constant.\n+     optimized away when inliner doesn't see operand is constant.\n      Other optimizers might think otherwise.  */\n   if (gimple_cond_code (last) != NE_EXPR\n       || !integer_zerop (gimple_cond_rhs (last)))\n@@ -1921,7 +1921,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n   int base_index;\n   struct agg_position_info aggpos;\n \n-  /* What statments might be optimized away\n+  /* What statements might be optimized away\n      when their arguments are constant.  */\n   if (gimple_code (stmt) != GIMPLE_ASSIGN\n       && gimple_code (stmt) != GIMPLE_COND\n@@ -2004,7 +2004,7 @@ struct record_modified_bb_info\n   gimple *stmt;\n };\n \n-/* Value is initialized in INIT_BB and used in USE_BB.  We want to copute\n+/* Value is initialized in INIT_BB and used in USE_BB.  We want to compute\n    probability how often it changes between USE_BB.\n    INIT_BB->count/USE_BB->count is an estimate, but if INIT_BB\n    is in different loop nest, we can do better.\n@@ -2333,7 +2333,7 @@ find_foldable_builtin_expect (basic_block bb)\n    presence of EH and will be optimized out by optimize_clobbers later in the\n    game. \n \n-   NEED_EH is used to recurse in case the clobber has non-EH predecestors\n+   NEED_EH is used to recurse in case the clobber has non-EH predecessors\n    that can be clobber only, too.. When it is false, the RESX is not necessary\n    on the end of basic block.  */\n \n@@ -2367,7 +2367,7 @@ clobber_only_eh_bb_p (basic_block bb, bool need_eh = true)\n       return false;\n     }\n \n-  /* See if all predecestors are either throws or clobber only BBs.  */\n+  /* See if all predecessors are either throws or clobber only BBs.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     if (!(e->flags & EDGE_EH)\n \t&& !clobber_only_eh_bb_p (e->src, false))\n@@ -2543,7 +2543,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  predicate will_be_nonconstant;\n \n           /* This relation stmt should be folded after we remove\n-             buildin_expect call. Adjust the cost here.  */\n+             __builtin_expect call. Adjust the cost here.  */\n \t  if (stmt == fix_builtin_expect_stmt)\n             {\n               this_size--;\n@@ -2609,7 +2609,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t}\n \t    }\n \n-\t  /* TODO: When conditional jump or swithc is known to be constant, but\n+\t  /* TODO: When conditional jump or switch is known to be constant, but\n \t     we did not translate it into the predicates, we really can account\n \t     just maximum of the possible paths.  */\n \t  if (fbi.info)\n@@ -3066,7 +3066,7 @@ estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n \t  || es->predicate->evaluate (possible_truths))\n \t{\n \t  /* Predicates of calls shall not use NOT_CHANGED codes,\n-\t     sowe do not need to compute probabilities.  */\n+\t     so we do not need to compute probabilities.  */\n \t  estimate_edge_size_and_time (e, size,\n \t\t\t\t       es->predicate ? NULL : min_size,\n \t\t\t\t       time,\n@@ -3239,7 +3239,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n }\n \n /* Default constructor for ipa call context.\n-   Memory alloction of known_vals, known_contexts\n+   Memory allocation of known_vals, known_contexts\n    and known_aggs vectors is owned by the caller, but can\n    be release by ipa_call_context::release.  \n    \n@@ -3334,7 +3334,7 @@ ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n \n /* Release memory used by known_vals/contexts/aggs vectors.\n    If ALL is true release also inline_param_summary.\n-   This happens when context was previously duplciated to be stored\n+   This happens when context was previously duplicated to be stored\n    into cache.  */\n \n void\n@@ -3471,7 +3471,7 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n }\n \n /* Estimate size and time needed to execute call in the given context.\n-   Additionally detemine hints determined by the context.  Finally compute\n+   Additionally determine hints determined by the context.  Finally compute\n    minimal size needed for the call that is independent on the call context and\n    can be used for fast estimates.  Return the values in RET_SIZE,\n    RET_MIN_SIZE, RET_TIME and RET_HINTS.  */\n@@ -3575,7 +3575,7 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n   gcc_checking_assert ((nonspecialized_time - time * 99 / 100) >= -1);\n \n   /* Roundoff issues may make specialized time bigger than nonspecialized\n-     time.  We do not really want that to happen because some heurstics\n+     time.  We do not really want that to happen because some heuristics\n      may get confused by seeing negative speedups.  */\n   if (time > nonspecialized_time)\n     time = nonspecialized_time;\n@@ -3684,7 +3684,7 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n \n /* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n    When function A is inlined in B and A calls C with parameter that\n-   changes with probability PROB1 and C is known to be passthroug\n+   changes with probability PROB1 and C is known to be passthrough\n    of argument if B that change with probability PROB2, the probability\n    of change is now PROB1*PROB2.  */\n "}, {"sha": "21ecd54293f6ee03f212bd1e8df61d039584cfff", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -26,13 +26,13 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* Hints are reasons why IPA heuristics should prefer specializing given\n-   function.  They are represtented as bitmap of the following values.  */\n+   function.  They are represented as bitmap of the following values.  */\n enum ipa_hints_vals {\n   /* When specialization turns indirect call into a direct call,\n      it is good idea to do so.  */\n   INLINE_HINT_indirect_call = 1,\n   /* Inlining may make loop iterations or loop stride known.  It is good idea\n-     to do so because it enables loop optimizatoins.  */\n+     to do so because it enables loop optimizations.  */\n   INLINE_HINT_loop_iterations = 2,\n   INLINE_HINT_loop_stride = 4,\n   /* Inlining within same strongly connected component of callgraph is often\n@@ -162,7 +162,7 @@ class GTY(()) ipa_fn_summary\n   /* Conditional size/time information.  The summaries are being\n      merged during inlining.  */\n   conditions conds;\n-  /* Normal code is acocunted in size_time_table, while calls are\n+  /* Normal code is accounted in size_time_table, while calls are\n      accounted in call_size_time_table.  This is because calls\n      are often adjusted by IPA optimizations and thus this summary\n      is generated from call summary information when needed.  */\n@@ -292,7 +292,7 @@ class ipa_call_summary_t: public fast_call_summary <ipa_call_summary *, va_heap>\n \n /* This object describe a context of call.  That is a summary of known\n    information about its parameters.  Main purpose of this context is\n-   to give more realistic esitmations of function runtime, size and\n+   to give more realistic estimations of function runtime, size and\n    inline hints.  */\n class ipa_call_context\n {\n@@ -323,7 +323,7 @@ class ipa_call_context\n   /* Called function.  */\n   cgraph_node *m_node;\n   /* Clause describing what predicate conditionals can be satisfied\n-     in this context if function is inlined/specialised.  */\n+     in this context if function is inlined/specialized.  */\n   clause_t m_possible_truths;\n   /* Clause describing what predicate conditionals can be satisfied\n      in this context if function is kept offline.  */"}, {"sha": "67ad60241cdd3a661d94667b40ecdb099259454d", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -19,13 +19,13 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Gimple identical code folding (class func_checker) is an infastructure\n+/* Gimple identical code folding (class func_checker) is an infrastructure\n    capable of comparing two given functions. The class compares every\n    gimple statement and uses many dictionaries to map source and target\n    SSA_NAMEs, declarations and other components.\n \n-   To use the infrastructure, create an instanse of func_checker and call\n-   a comparsion function based on type of gimple statement.  */\n+   To use the infrastructure, create an instance of func_checker and call\n+   a comparison function based on type of gimple statement.  */\n \n /* Prints string STRING to a FILE with a given number of SPACE_COUNT.  */\n #define FPUTS_SPACES(file, space_count, string) \\\n@@ -220,7 +220,7 @@ class func_checker : operand_compare\n   bool compare_loops (basic_block bb1, basic_block bb2);\n \n   /* Return true if types are compatible for polymorphic call analysis.\n-     COMPARE_PTR indicates if polymorphic type comparsion should be\n+     COMPARE_PTR indicates if polymorphic type comparison should be\n      done for pointers, too.  */\n   static bool compatible_polymorphic_types_p (tree t1, tree t2,\n \t\t\t\t\t      bool compare_ptr);"}, {"sha": "20e92e12babebe5cb5405b8549b4a575a04b2f43", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -300,7 +300,7 @@ sem_function::get_hash (void)\n \n /* Compare properties of symbols N1 and N2 that does not affect semantics of\n    symbol itself but affects semantics of its references from USED_BY (which\n-   may be NULL if it is unknown).  If comparsion is false, symbols\n+   may be NULL if it is unknown).  If comparison is false, symbols\n    can still be merged but any symbols referring them can't.\n \n    If ADDRESS is true, do extra checking needed for IPA_REF_ADDR.\n@@ -550,7 +550,7 @@ sem_function::equals_wpa (sem_item *item,\n \n   if (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl)\n        != DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (item->decl))\n-    return return_false_with_msg (\"intrument function entry exit \"\n+    return return_false_with_msg (\"instrument function entry exit \"\n \t\t\t\t  \"attributes are different\");\n \n   if (DECL_NO_LIMIT_STACK (decl) != DECL_NO_LIMIT_STACK (item->decl))\n@@ -576,7 +576,7 @@ sem_function::equals_wpa (sem_item *item,\n       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n     {\n       if (TREE_CODE (TREE_TYPE (item->decl)) != METHOD_TYPE)\n-        return return_false_with_msg (\"DECL_CXX_CONSTURCTOR type mismatch\");\n+        return return_false_with_msg (\"DECL_CXX_CONSTRUCTOR type mismatch\");\n       else if (!func_checker::compatible_polymorphic_types_p\n \t\t (TYPE_METHOD_BASETYPE (TREE_TYPE (decl)),\n \t\t  TYPE_METHOD_BASETYPE (TREE_TYPE (item->decl)), false))\n@@ -726,7 +726,7 @@ sem_function::equals_wpa (sem_item *item,\n }\n \n /* Update hash by address sensitive references. We iterate over all\n-   sensitive references (address_matters_p) and we hash ultime alias\n+   sensitive references (address_matters_p) and we hash ultimate alias\n    target of these nodes, which can improve a semantic item hash.\n \n    Also hash in referenced symbols properties.  This can be done at any time\n@@ -1114,7 +1114,7 @@ sem_function::merge (sem_item *alias_item)\n         }\n       /* Do not turn function in one comdat group into wrapper to another\n \t comdat group. Other compiler producing the body of the\n-\t another comdat group may make opossite decision and with unfortunate\n+\t another comdat group may make opposite decision and with unfortunate\n \t linker choices this may close a loop.  */\n       else if (DECL_COMDAT_GROUP (original->decl)\n \t       && DECL_COMDAT_GROUP (alias->decl)\n@@ -1160,7 +1160,7 @@ sem_function::merge (sem_item *alias_item)\n       else\n         create_wrapper = true;\n \n-      /* We can redirect local calls in the case both alias and orignal\n+      /* We can redirect local calls in the case both alias and original\n \t are not interposable.  */\n       redirect_callers\n \t= alias->get_availability () > AVAIL_INTERPOSABLE\n@@ -1989,7 +1989,7 @@ sem_variable::merge (sem_item *alias_item)\n       return false;\n     }\n \n-  /* We cannot merge if address comparsion metters.  */\n+  /* We cannot merge if address comparison matters.  */\n   if (alias_address_matters && flag_merge_constants < 2)\n     {\n       if (dump_enabled_p ())\n@@ -3420,7 +3420,7 @@ sem_item_optimizer::fixup_points_to_sets (void)\n \t  fixup_pt_set (&SSA_NAME_PTR_INFO (name)->pt);\n       fixup_pt_set (&fn->gimple_df->escaped);\n \n-       /* The above get's us to 99% I guess, at least catching the\n+       /* The above gets us to 99% I guess, at least catching the\n \t  address compares.  Below also gets us aliasing correct\n \t  but as said we're giving leeway to the situation with\n \t  readonly vars anyway, so ... */\n@@ -3505,7 +3505,7 @@ ipa_icf_read_summary (void)\n   optimizer->register_hooks ();\n }\n \n-/* Semantic equality exection function.  */\n+/* Semantic equality execution function.  */\n \n static unsigned int\n ipa_icf_driver (void)"}, {"sha": "261911799e203860d2528cf923de2ca57b1ee6c9", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -24,7 +24,7 @@ class sem_item;\n \n /* Congruence class encompasses a collection of either functions or\n    read-only variables. These items are considered to be equivalent\n-   if not proved the oposite.  */\n+   if not proved the opposite.  */\n class congruence_class\n {\n public:\n@@ -200,7 +200,7 @@ class sem_item\n   virtual bool equals_wpa (sem_item *item,\n \t\t\t   hash_map <symtab_node *, sem_item *> &ignored_nodes) = 0;\n \n-  /* Returns true if the item equals to ITEM given as arguemnt.  */\n+  /* Returns true if the item equals to ITEM given as argument.  */\n   virtual bool equals (sem_item *item,\n \t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes) = 0;\n \n@@ -350,7 +350,7 @@ class sem_function: public sem_item\n \t\t\t      ipa_icf_gimple::func_checker *checker);\n \n   /* Perform additional checks needed to match types of used function\n-     paramters.  */\n+     parameters.  */\n   bool compatible_parm_types_p (tree, tree);\n \n   /* Exception handling region tree.  */\n@@ -606,7 +606,7 @@ class sem_item_optimizer\n   static bool release_split_map (congruence_class * const &cls, bitmap const &b,\n \t\t\t\t traverse_split_pair *pair);\n \n-  /* Process split operation for a cognruence class CLS,\n+  /* Process split operation for a congruence class CLS,\n      where bitmap B splits congruence class members. DATA is used\n      as argument of split pair.  */\n   static bool traverse_congruence_split (congruence_class * const &cls,"}, {"sha": "ae8e5db3d9c8cb983288824eb43bf39d997062e5", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -148,7 +148,7 @@ free_growth_caches (void)\n   node_context_cache_clear = 0;\n }\n \n-/* Return hints derrived from EDGE.   */\n+/* Return hints derived from EDGE.   */\n \n int\n simple_edge_hints (struct cgraph_edge *edge)"}, {"sha": "e7ec7f911e1be8871f3b4e8fab8495e19673cf68", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -105,7 +105,7 @@ can_remove_node_now_p_1 (struct cgraph_node *node, struct cgraph_edge *e)\n \t  && (!DECL_VIRTUAL_P (node->decl)\n \t      || !opt_for_fn (node->decl, flag_devirtualize))\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n-\t     callgraph and they might reffer the function in question.  */\n+\t     callgraph and they might refer the function in question.  */\n \t  && !cgraph_new_nodes.exists ());\n }\n \n@@ -176,7 +176,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n     {\n       /* We may eliminate the need for out-of-line copy to be output.\n \t In that case just go ahead and re-use it.  This is not just an\n-\t memory optimization.  Making offline copy of fuction disappear\n+\t memory optimization.  Making offline copy of function disappear\n \t from the program will improve future decisions on inlining.  */\n       if (!e->callee->callers->next_caller\n \t  /* Recursive inlining never wants the master clone to\n@@ -192,7 +192,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     need small function inlining to register edge removal hook to\n \t     maintain the priority queue.\n \n-\t     For now we keep the ohter functions in the group in program until\n+\t     For now we keep the other functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->inlined_to);\n \t  e->callee->remove_from_same_comdat_group ();"}, {"sha": "4dd4de157f16603b66ee4e8db77acee233d2012b", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -517,7 +517,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t\t  && DECL_FUNCTION_PERSONALITY (callee->decl))\n \t      || (check_maybe_up (flag_exceptions)\n \t\t  && DECL_FUNCTION_PERSONALITY (callee->decl))\n-\t      /* When devirtualization is diabled for callee, it is not safe\n+\t      /* When devirtualization is disabled for callee, it is not safe\n \t\t to inline it as we possibly mangled the type info.\n \t\t Allow early inlining of always inlines.  */\n \t      || (!early && check_maybe_down (flag_devirtualize)))\n@@ -547,7 +547,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t       || DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \t;\n       /* If mismatch is caused by merging two LTO units with different\n-\t optimizationflags we want to be bit nicer.  However never inline\n+\t optimization flags we want to be bit nicer.  However never inline\n \t if one of functions is not optimized at all.  */\n       else if (!opt_for_fn (callee->decl, optimize)\n       \t       || !opt_for_fn (caller->decl, optimize))\n@@ -783,8 +783,8 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   return time;\n }\n \n-/* Determine time saved by inlininig EDGE of frequency FREQ\n-   where callee's runtime w/o inlineing is UNINLINED_TYPE\n+/* Determine time saved by inlining EDGE of frequency FREQ\n+   where callee's runtime w/o inlining is UNINLINED_TYPE\n    and with inlined is INLINED_TYPE.  */\n \n inline sreal\n@@ -1222,7 +1222,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t     if (need_more_work)\n \t       noninline_callee ();\n \t   }\n-\t Withhout penalizing this case, we usually inline noninline_callee\n+\t Without penalizing this case, we usually inline noninline_callee\n \t into the inline_caller because overall_growth is small preventing\n \t further inlining of inline_caller.\n \n@@ -1297,7 +1297,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t}\n     }\n   /* When function local profile is not available or it does not give\n-     useful information (ie frequency is zero), base the cost on\n+     useful information (i.e. frequency is zero), base the cost on\n      loop nest and overall size growth, so we optimize for overall number\n      of functions fully inlined in program.  */\n   else\n@@ -1349,7 +1349,7 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n       gcc_checking_assert (n->get_data () == edge);\n \n       /* fibonacci_heap::replace_key does busy updating of the\n-\t heap that is unnecesarily expensive.\n+\t heap that is unnecessarily expensive.\n \t We do lazy increases: after extracting minimum if the key\n \t turns out to be out of date, it is re-inserted into heap\n \t with correct value.  */\n@@ -1383,7 +1383,7 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n \n \n /* NODE was inlined.\n-   All caller edges needs to be resetted because\n+   All caller edges needs to be reset because\n    size estimates change. Similarly callees needs reset\n    because better context may be known.  */\n \n@@ -1520,7 +1520,7 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n \t      update_edge_key (heap, e);\n \t  }\n \t/* We do not reset callee growth cache here.  Since we added a new call,\n-\t   growth chould have just increased and consequentely badness metric\n+\t   growth should have just increased and consequently badness metric\n            don't need updating.  */\n \telse if (e->inline_failed\n \t\t && (callee = e->callee->ultimate_alias_target (&avail,\n@@ -2082,7 +2082,7 @@ inline_small_functions (void)\n \t  edge_growth_cache->get (edge)->hints = old_hints_est + 1;\n \n \t  /* When updating the edge costs, we only decrease badness in the keys.\n-\t     Increases of badness are handled lazilly; when we see key with out\n+\t     Increases of badness are handled lazily; when we see key with out\n \t     of date value on it, we re-insert it now.  */\n \t  current_badness = edge_badness (edge, false);\n \t  gcc_assert (cached_badness == current_badness);\n@@ -2225,7 +2225,7 @@ inline_small_functions (void)\n \t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n \t  /* If caller's size and time increased we do not need to update\n-\t     all edges becuase badness is not going to decrease.  */\n+\t     all edges because badness is not going to decrease.  */\n \t  if (old_size <= ipa_size_summaries->get (where)->size\n \t      && old_time <= ipa_fn_summaries->get (where)->time\n \t      /* Wrapper penalty may be non-monotonous in this respect.\n@@ -2569,7 +2569,7 @@ dump_inline_stats (void)\n \t       \"%\" PRId64 \" + previously indirect \"\n \t       \"%\" PRId64 \" + virtual \"\n \t       \"%\" PRId64 \" + virtual and previously indirect \"\n-\t       \"%\" PRId64 \" + stil indirect \"\n+\t       \"%\" PRId64 \" + still indirect \"\n \t       \"%\" PRId64 \" + still indirect polymorphic \"\n \t       \"%\" PRId64 \"\\n\", inlined_cnt,\n \t       inlined_speculative, inlined_speculative_ply,\n@@ -2725,7 +2725,7 @@ ipa_inline (void)\n      into callee often leads to better optimization of callee due to\n      increased context for optimization.\n      For example if main() function calls a function that outputs help\n-     and then function that does the main optmization, we should inline\n+     and then function that does the main optimization, we should inline\n      the second with priority even if both calls are cold by themselves.\n \n      We probably want to implement new predicate replacing our use of\n@@ -2850,7 +2850,7 @@ early_inline_small_functions (struct cgraph_node *node)\n     {\n       struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n \n-      /* We can enounter not-yet-analyzed function during\n+      /* We can encounter not-yet-analyzed function during\n \t early inlining on callgraphs with strongly\n \t connected components.  */\n       ipa_fn_summary *s = ipa_fn_summaries->get (callee);"}, {"sha": "a50d2c5c8c300bbc10f3adec8db86d4a7f235bfa", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -69,7 +69,7 @@ contains_polymorphic_type_p (const_tree type)\n }\n \n /* Return true if it seems valid to use placement new to build EXPECTED_TYPE\n-   at possition CUR_OFFSET within TYPE.  \n+   at position CUR_OFFSET within TYPE.  \n \n    POD can be changed to an instance of a polymorphic type by\n    placement new.  Here we play safe and assume that any\n@@ -99,7 +99,7 @@ possible_placement_new (tree type, tree expected_type,\n    to represent it.\n \n    If OTR_TYPE is NULL, just find outermost polymorphic type with\n-   virtual table present at possition OFFSET.\n+   virtual table present at position OFFSET.\n \n    For example when THIS represents type\n    class A\n@@ -113,7 +113,7 @@ possible_placement_new (tree type, tree expected_type,\n \n    If we cannot find corresponding class, give up by setting\n    THIS->OUTER_TYPE to OTR_TYPE and THIS->OFFSET to NULL. \n-   Return true when lookup was sucesful.\n+   Return true when lookup was successful.\n \n    When CONSIDER_PLACEMENT_NEW is false, reject contexts that may be made\n    valid only via allocation of new polymorphic type inside by means\n@@ -147,7 +147,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n     Because the instance type may contain field whose type is of OUTER_TYPE,\n     we cannot derive any effective information about it.\n \n-    TODO: In the case we know all derrived types, we can definitely do better\n+    TODO: In the case we know all derived types, we can definitely do better\n     here.  */\n   else if (TYPE_SIZE (outer_type)\n \t   && tree_fits_shwi_p (TYPE_SIZE (outer_type))\n@@ -240,7 +240,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t      if (cur_offset != 0)\n \t\tgoto no_useful_type_info;\n \t      /* If we determined type precisely or we have no clue on\n- \t\t speuclation, we are done.  */\n+ \t\t speculation, we are done.  */\n \t      if (!maybe_derived_type || !speculative_outer_type\n \t\t  || !speculation_consistent_p (speculative_outer_type,\n \t\t\t\t\t        speculative_offset,\n@@ -317,7 +317,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t\t{\n \t\t  outer_type = type;\n \t\t  offset = cur_offset;\n-\t\t  /* As soon as we se an field containing the type,\n+\t\t  /* As soon as we see an field containing the type,\n \t\t     we know we are not looking for derivations.  */\n \t\t  maybe_derived_type = false;\n \t\t}\n@@ -395,7 +395,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t      else\n \t\treturn true;\n \t    }\n-\t  /* We found no way to embedd EXPECTED_TYPE in TYPE.\n+\t  /* We found no way to embed EXPECTED_TYPE in TYPE.\n \t     We still permit two special cases - placement new and\n \t     the case of variadic types containing themselves.  */\n \t  if (!speculative\n@@ -552,7 +552,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n     return true;\n \n   /* Pure functions cannot do any changes on the dynamic type;\n-     that require writting to memory.  */\n+     that require writing to memory.  */\n   if ((!base || !auto_var_in_fn_p (base, function))\n       && flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n     return false;\n@@ -721,7 +721,7 @@ ipa_polymorphic_call_context::stream_in (class lto_input_block *ib,\n     }\n }\n \n-/* Proudce polymorphic call context for call method of instance\n+/* Produce polymorphic call context for call method of instance\n    that is located within BASE (that is assumed to be a decl) at offset OFF. */\n \n void\n@@ -915,7 +915,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t  if (TREE_CODE (base) == MEM_REF || DECL_P (base))\n \t    {\n \t      /* We found dereference of a pointer.  Type of the pointer\n-\t\t and MEM_REF is meaningless, but we can look futher.  */\n+\t\t and MEM_REF is meaningless, but we can look further.  */\n \t      offset_int mem_offset;\n \t      if (TREE_CODE (base) == MEM_REF\n \t\t  && mem_ref_offset (base).is_constant (&mem_offset))\n@@ -1004,14 +1004,14 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t     0-thunk.fixed_offset.  It starts with code that adds\n \t     think.fixed_offset to the pointer to compensate for this.\n \n-\t     Because we walked all the way to the begining of thunk, we now\n+\t     Because we walked all the way to the beginning of thunk, we now\n \t     see pointer &bar-thunk.fixed_offset and need to compensate\n \t     for it.  */\n \t  if (node->thunk.fixed_offset)\n \t    offset -= node->thunk.fixed_offset * BITS_PER_UNIT;\n \n \t  /* Dynamic casting has possibly upcasted the type\n-\t     in the hiearchy.  In this case outer type is less\n+\t     in the hierarchy.  In this case outer type is less\n \t     informative than inner type and we should forget\n \t     about it.  */\n \t  if ((otr_type\n@@ -1113,7 +1113,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t\t\t      offset,\n \t\t\t      true, NULL /* Do not change type here */);\n   /* TODO: There are multiple ways to derive a type.  For instance\n-     if BASE_POINTER is passed to an constructor call prior our refernece.\n+     if BASE_POINTER is passed to an constructor call prior our reference.\n      We do not make this type of flow sensitive analysis yet.  */\n   if (instance)\n     *instance = base_pointer;\n@@ -1323,7 +1323,7 @@ extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"    Construction vtable used\\n\");\n-      /* FIXME: We should suport construction contexts.  */\n+      /* FIXME: We should support construction contexts.  */\n       return NULL;\n     }\n  \n@@ -1557,7 +1557,7 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \n    AA_WALK_BUDGET_P, if not NULL, is how statements we should allow\n    walk_aliased_vdefs to examine.  The value should be decremented by the\n-   number of stetements we examined or set to zero if exhausted.  */\n+   number of statements we examined or set to zero if exhausted.  */\n \n bool\n ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n@@ -1583,7 +1583,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n     otr_type = TYPE_MAIN_VARIANT (otr_type);\n \n   /* Walk into inner type. This may clear maybe_derived_type and save us\n-     from useless work.  It also makes later comparsions with static type\n+     from useless work.  It also makes later comparisons with static type\n      easier.  */\n   if (outer_type && otr_type)\n     {\n@@ -1599,7 +1599,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n   if (TREE_CODE (instance) == MEM_REF)\n     return false;\n \n-  /* We need to obtain refernce to virtual table pointer.  It is better\n+  /* We need to obtain reference to virtual table pointer.  It is better\n      to look it up in the code rather than build our own.  This require bit\n      of pattern matching, but we end up verifying that what we found is\n      correct. \n@@ -1778,7 +1778,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \n      Therefore if the static outer type was found (outer_type)\n      we can safely ignore tci.speculative that is set on calls and give up\n-     only if there was dyanmic type store that may affect given variable\n+     only if there was dynamic type store that may affect given variable\n      (seen_unanalyzed_store)  */\n \n   if (walked < 0)\n@@ -1915,7 +1915,7 @@ ipa_polymorphic_call_context::combine_speculation_with\n     return false;\n \n   /* restrict_to_inner_class may eliminate wrong speculation making our job\n-     easeier.  */\n+     easier.  */\n   if (otr_type)\n     restrict_to_inner_class (otr_type);\n \n@@ -1963,7 +1963,7 @@ ipa_polymorphic_call_context::combine_speculation_with\n     }\n   /* Choose type that contains the other.  This one either contains the outer\n      as a field (thus giving exactly one target) or is deeper in the type\n-     hiearchy.  */\n+     hierarchy.  */\n   else if (speculative_outer_type\n \t   && speculative_maybe_derived_type\n \t   && (new_offset > speculative_offset\n@@ -2015,7 +2015,7 @@ ipa_polymorphic_call_context::meet_speculation_with\n     }\n \n   /* restrict_to_inner_class may eliminate wrong speculation making our job\n-     easeier.  */\n+     easier.  */\n   if (otr_type)\n     restrict_to_inner_class (otr_type);\n \n@@ -2095,8 +2095,8 @@ ipa_polymorphic_call_context::meet_speculation_with\n     }\n }\n \n-/* Assume that both THIS and a given context is valid and strenghten THIS\n-   if possible.  Return true if any strenghtening was made.\n+/* Assume that both THIS and a given context is valid and strengthen THIS\n+   if possible.  Return true if any strengthening was made.\n    If actual type the context is being used in is known, OTR_TYPE should be\n    set accordingly. This improves quality of combined result.  */\n \n@@ -2261,7 +2261,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t      goto invalidate;\n \t    }\n \t}\n-      /* Pick variant deeper in the hiearchy.  */\n+      /* Pick variant deeper in the hierarchy.  */\n       else\n \t{\n \t  outer_type = ctx.outer_type;\n@@ -2299,7 +2299,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t    }\n \t}\n     }\n-  /* TODO handle merging using hiearchy. */\n+  /* TODO handle merging using hierarchy. */\n   else if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Giving up on merge\\n\");\n \n@@ -2587,7 +2587,7 @@ ipa_polymorphic_call_context::meet_with (ipa_polymorphic_call_context ctx,\n       if (!dynamic && ctx.dynamic)\n \tdynamic = true;\n     }\n-  /* TODO handle merging using hiearchy. */\n+  /* TODO handle merging using hierarchy. */\n   else\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "9cd21ae5060886de49d559a71ad97e49584a2f7f", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -444,8 +444,8 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n }\n \n \n-/* Dump THIS to F. CONDS a vector of conditions used when evauating\n-   predicats. When NL is true new line is output at the end of dump.  */\n+/* Dump THIS to F.  CONDS a vector of conditions used when evaluating\n+   predicates.  When NL is true new line is output at the end of dump.  */\n \n void\n predicate::dump (FILE *f, conditions conds, bool nl) const\n@@ -495,7 +495,7 @@ predicate::remap_after_duplication (clause_t possible_truths)\n \n    INFO is ipa_fn_summary of function we are adding predicate into, CALLEE_INFO\n    is summary of function predicate P is from. OPERAND_MAP is array giving\n-   callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clausule of all\n+   callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clause of all\n    callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n    predicate under which callee is executed.  OFFSET_MAP is an array of of\n    offsets that need to be added to conditions, negative offset means that"}, {"sha": "265b1d163b2d5f755ced23b81499e3a3f05da486", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -62,7 +62,7 @@ struct GTY(()) condition\n      passed by reference and by value.  */\n   unsigned by_ref : 1;\n   /* A set of sequential operations on the parameter, which can be seen as\n-     a mathmatical function on the parameter.  */\n+     a mathematical function on the parameter.  */\n   expr_eval_ops param_ops;\n };\n \n@@ -89,7 +89,7 @@ struct inline_param_summary\n \n typedef vec<condition, va_gc> *conditions;\n \n-/* Predicates are used to repesent function parameters (such as runtime)\n+/* Predicates are used to represent function parameters (such as runtime)\n    which depend on a context function is called in.\n \n    Predicates are logical formulas in conjunctive-disjunctive form consisting\n@@ -117,7 +117,7 @@ class predicate\n       first_dynamic_condition = 2\n     };\n \n-  /* Maximal number of conditions predicate can reffer to.  This is limited\n+  /* Maximal number of conditions predicate can refer to.  This is limited\n      by using clause_t to be 32bit.  */\n   static const int num_conditions = 32;\n "}, {"sha": "00af24c77db536b2adcf89afd8ff57c9bebcb628", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -46,7 +46,7 @@ struct GTY(()) ipa_ref\n      function.  */\n   bool cannot_lead_to_return ();\n \n-  /* Return true if refernece may be used in address compare.  */\n+  /* Return true if reference may be used in address compare.  */\n   bool address_matters_p ();\n \n   /* Return reference list this reference is in.  */"}, {"sha": "2310c1abd0e1f6546db76665cd25f2d0e2d7c830", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -168,7 +168,7 @@ test_nonssa_use (gimple *, tree t, tree, void *data)\n       || (VAR_P (t)\n \t  && auto_var_in_fn_p (t, current_function_decl))\n       || TREE_CODE (t) == RESULT_DECL\n-\t /* Normal labels are part of CFG and will be handled gratefuly.\n+\t /* Normal labels are part of CFG and will be handled gratefully.\n \t    Forced labels however can be used directly by statements and\n \t    need to stay in one partition along with their uses.  */\n       || (TREE_CODE (t) == LABEL_DECL\n@@ -455,7 +455,7 @@ consider_split (class split_point *current, bitmap non_ssa_vars,\n \t   (param_partial_inlining_entry_probability, 100))))\n     {\n       /* When profile is guessed, we cannot expect it to give us\n-\t realistic estimate on likelyness of function taking the\n+\t realistic estimate on likeliness of function taking the\n \t complex path.  As a special case, when tail of the function is\n \t a loop, enable splitting since inlining code skipping the loop\n \t is likely noticeable win.  */"}, {"sha": "49467481d47a9194efb14c8df67c2df50de2cf60", "filename": "gcc/profile-count.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -105,7 +105,7 @@ profile_count::debug () const\n   fprintf (stderr, \"\\n\");\n }\n \n-/* Return true if THIS differs from OTHER; tolerate small diferences.  */\n+/* Return true if THIS differs from OTHER; tolerate small differences.  */\n \n bool\n profile_count::differs_from_p (profile_count other) const\n@@ -186,7 +186,7 @@ profile_probability::debug () const\n   fprintf (stderr, \"\\n\");\n }\n \n-/* Return true if THIS differs from OTHER; tolerate small diferences.  */\n+/* Return true if THIS differs from OTHER; tolerate small differences.  */\n \n bool\n profile_probability::differs_from_p (profile_probability other) const\n@@ -388,7 +388,7 @@ profile_count::from_gcov_type (gcov_type v, profile_quality quality)\n   }\n \n /* COUNT1 times event happens with *THIS probability, COUNT2 times OTHER\n-   happens with COUNT2 probablity. Return probablity that either *THIS or\n+   happens with COUNT2 probability.  Return probability that either *THIS or\n    OTHER happens.  */\n \n profile_probability\n@@ -398,7 +398,7 @@ profile_probability::combine_with_count (profile_count count1,\n {\n   /* If probabilities are same, we are done.\n      If counts are nonzero we can distribute accordingly. In remaining\n-     cases just avreage the values and hope for the best.  */\n+     cases just average the values and hope for the best.  */\n   if (*this == other || count1 == count2\n       || (count2 == profile_count::zero ()\n \t  && !(count1 == profile_count::zero ())))"}, {"sha": "3d6e388f7fe3975bfb3eb23e33c242991fdb3ce6", "filename": "gcc/profile-count.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956d615d66d06a9810000a5b7941be3ee1da7f8e/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=956d615d66d06a9810000a5b7941be3ee1da7f8e", "patch": "@@ -37,7 +37,7 @@ enum profile_quality {\n   GUESSED_LOCAL,\n \n   /* Profile was read by feedback and was 0, we used local heuristics to guess\n-     better.  This is the case of functions not run in profile fedback.\n+     better.  This is the case of functions not run in profile feedback.\n      Never used by probabilities.  */\n   GUESSED_GLOBAL0,\n \n@@ -48,7 +48,7 @@ enum profile_quality {\n      not reflect the reality but it can be compared interprocedurally\n      (for example, we inlined function w/o profile feedback into function\n       with feedback and propagated from that).\n-     Never used by probablities.  */\n+     Never used by probabilities.  */\n   GUESSED,\n \n   /* Profile was determined by autofdo.  */\n@@ -111,7 +111,7 @@ safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n \n    In addition to actual value the quality of profile is tracked and propagated\n    through all operations.  Special value UNINITIALIZED_PROFILE is used for probabilities\n-   that has not been determined yet (for example bacause of\n+   that has not been determined yet (for example because of\n    -fno-guess-branch-probability)\n \n    Typically probabilities are derived from profile feedback (via\n@@ -122,7 +122,7 @@ safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n      - never           (0 probability)\n      - guessed_never\n      - very_unlikely   (1/2000 probability)\n-     - unlikely        (1/5 probablity)\n+     - unlikely        (1/5 probability)\n      - even            (1/2 probability)\n      - likely          (4/5 probability)\n      - very_likely     (1999/2000 probability)\n@@ -479,7 +479,7 @@ class GTY((user)) profile_probability\n       /* The following is equivalent to:\n          *this = cprob.invert () * *this / ret.invert ();\n \t Avoid scaling when overall outcome is supposed to be always.\n-\t Without knowing that one is inverse of toher, the result would be\n+\t Without knowing that one is inverse of other, the result would be\n \t conservative.  */\n       if (!(*this == always ()))\n         *this = (*this - ret) / ret.invert ();\n@@ -532,7 +532,7 @@ class GTY((user)) profile_probability\n \n   /* Return true when the probability of edge is reliable.\n \n-     The profile guessing code is good at predicting branch outcome (ie.\n+     The profile guessing code is good at predicting branch outcome (i.e.\n      taken/not taken), that is predicted right slightly over 75% of time.\n      It is however notoriously poor on predicting the probability itself.\n      In general the profile appear a lot flatter (with probabilities closer\n@@ -567,7 +567,7 @@ class GTY((user)) profile_probability\n       return m_val <= max_probability;\n     }\n \n-  /* Comparsions are three-state and conservative.  False is returned if\n+  /* Comparisons are three-state and conservative.  False is returned if\n      the inequality cannot be decided.  */\n   bool operator< (const profile_probability &other) const\n     {\n@@ -608,7 +608,7 @@ class GTY((user)) profile_probability\n   bool differs_lot_from_p (profile_probability other) const;\n \n   /* COUNT1 times event happens with *THIS probability, COUNT2 times OTHER\n-     happens with COUNT2 probablity. Return probablity that either *THIS or\n+     happens with COUNT2 probability. Return probability that either *THIS or\n      OTHER happens.  */\n   profile_probability combine_with_count (profile_count count1,\n \t\t\t\t\t  profile_probability other,\n@@ -631,7 +631,7 @@ class GTY((user)) profile_probability\n         estimation.\n      2) ipa counters which are result of profile feedback or special case\n         of static profile estimation (such as in function main).\n-     3) counters which counts as 0 inter-procedurally (beause given function\n+     3) counters which counts as 0 inter-procedurally (because given function\n         was never run in train feedback) but they hold local static profile\n         estimate.\n \n@@ -641,7 +641,7 @@ class GTY((user)) profile_probability\n    well defined.\n \n    To take local counter and use it inter-procedurally use ipa member function\n-   which strips information irelevant at the inter-procedural level.\n+   which strips information irrelevant at the inter-procedural level.\n \n    Counters are 61bit integers representing number of executions during the\n    train run or normalized frequency within the function.\n@@ -660,7 +660,7 @@ class GTY((user)) profile_probability\n    and they do end up in uninitialized scale if any of the parameters is\n    uninitialized.\n \n-   All comparsions that are three state and handling of probabilities.  Thus\n+   All comparisons that are three state and handling of probabilities.  Thus\n    a < b is not equal to !(a >= b).\n \n    The following pre-defined counts are available:\n@@ -770,7 +770,7 @@ struct GTY(()) profile_count\n       return m_quality >= ADJUSTED;\n     }\n \n-  /* Return true if vlaue can be operated inter-procedurally.  */\n+  /* Return true if value can be operated inter-procedurally.  */\n   bool ipa_p () const\n     {\n       return !initialized_p () || m_quality >= GUESSED_GLOBAL0;\n@@ -890,7 +890,7 @@ struct GTY(()) profile_count\n       return m_val != uninitialized_count || m_quality == GUESSED_LOCAL;\n     }\n \n-  /* Comparsions are three-state and conservative.  False is returned if\n+  /* Comparisons are three-state and conservative.  False is returned if\n      the inequality cannot be decided.  */\n   bool operator< (const profile_count &other) const\n     {\n@@ -976,7 +976,7 @@ struct GTY(()) profile_count\n       return initialized_p () && m_val != 0;\n     }\n \n-  /* Make counter forcingly nonzero.  */\n+  /* Make counter forcibly nonzero.  */\n   profile_count force_nonzero () const\n     {\n       if (!initialized_p ())\n@@ -1119,8 +1119,8 @@ struct GTY(()) profile_count\n       return ret;\n     }\n \n-  /* Return variant of profile counte which is always safe to compare\n-     acorss functions.  */\n+  /* Return variant of profile count which is always safe to compare\n+     across functions.  */\n   profile_count ipa () const\n     {\n       if (m_quality > GUESSED_GLOBAL0_ADJUSTED)"}]}