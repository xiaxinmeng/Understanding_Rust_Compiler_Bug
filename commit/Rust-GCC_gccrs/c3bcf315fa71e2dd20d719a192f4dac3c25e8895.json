{"sha": "c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNiY2YzMTVmYTcxZTJkZDIwZDcxOWExOTJmNGRhYzNjMjVlODg5NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-02T08:46:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-02T08:46:26Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r16274,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r16275", "tree": {"sha": "e8b0579ef78e912fd52ada9b501d9ef921391281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8b0579ef78e912fd52ada9b501d9ef921391281"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/comments", "author": null, "committer": null, "parents": [{"sha": "336b436af56bf1082c50897581fef100f92ad23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336b436af56bf1082c50897581fef100f92ad23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/336b436af56bf1082c50897581fef100f92ad23d"}], "stats": {"total": 7711, "additions": 3919, "deletions": 3792}, "files": [{"sha": "7b5fdee5ff884ebbc44a1eff9eba3a405f6d3c5b", "filename": "gcc/ORDERS", "status": "modified", "additions": 854, "deletions": 700, "changes": 1554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2FORDERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2FORDERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FORDERS?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}, {"sha": "da8a4ee7d6b539bc47ce04b59e58829115ebdc3e", "filename": "gcc/SERVICE", "status": "modified", "additions": 11, "deletions": 58, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2FSERVICE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2FSERVICE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FSERVICE?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -198,33 +198,6 @@ Rates: ~60 US$ / hour (Flux 2000.-)\n \n Updated:  1997-05-07\n \u001f\n-Paul Black                                      <paulb@triode.apana.org.au>\n-Sydney, Australia\n-\n-     I am available for general consulting on GNU software.  My specific\n-areas of interest are:\n-\t- general C, C++, ADA and APL programming\n-\t- Gnu/unix utilities\n-\t- Troff\n-\t- Real Time Software\n-\t- Linux\n-\t- IP Comms, SMTP, NNTP, HTTP and WWW\n-\t- Simulation\n-\n-I am happy to provide free consulting/services if the work is of the order of\n-a couple of hours. If more time is required, I am happy to negotiate depending\n-on the nature of the work, my indicative rate is $40 per hour.\n-\n-Entered: 1996-07-10\n-\u001f\n-Keith Bostic\n-\n-\tI'm interested in supporting/extending the ex/vi editors,\n-\twhich I wrote.  On-site or by email, rates are based on the\n-\tproject.  <bostic@cs.berkeley.edu>\n-\n-Entered:  1996-07-15\n-\u001f\n Philip Brown\n <phil@mitre.org>\n (703) 893-8967 (prefer email)\n@@ -415,8 +388,6 @@ Cygnus Solutions\n Sunnyvale, CA 94089 USA\n +1 408 542 9600 voice\n +1 408 542 9699 fax\n-Web Site: http://www.cygnus.com\n-\n \n Cygnus Solutions provides supported and maintained versions of gcc, g++, gdb\n with GUI, GNU linker and GNU macro assembler.  In addition, Cygnus provides\n@@ -440,7 +411,7 @@ Cygnus Solutions contacts:\n    \tph: +1 408 542 9637\n    \tfx: +1 408 542 9699\n    \temail:  <westcott@cygnus.com>\n-Updated: 1997-05-23\n+Updated: 1997-09-02 by rms\n \u001f\n Marcus G. Daniels              <marcusd@gnu.ai.mit.edu>\n 31060 S. Kaufman Rd.           <marcus@tdb.com>\n@@ -671,24 +642,6 @@ Consulting rates: $70 to $175 per hour.\n  \n Updated:  1997-05-07\n \u001f\n-Ehud Karni      <kehud@simonwiesel.net.il>\n-\n-I am an UNIX system programmer. My skills include writing in C and scripts.\n-\n-In the GNU domain, I consider myself an expert on Emacs.  I have written several\n-packages in emacs-lisp (.el) including: better Hebrew support, another marking\n-system, emulation for CDC full screen editor (FSE), COBOL mode, mathematical\n-expression computing, and enhancements to vc.el (customization) and to ange-ftp\n-(added Novell and NT operating systems).\n-     I have installed and tested Emacs and my el's on several machines: DG,\n-HP, Alpha (OSF) and PC (DOS).\n-     I installed and worked with several other GNU packages - RCS, Gmake, GCC\n-and more, but I'm not an expert in these packages.\n-\n-I work in Israel and my normal rate is $40 per hour.\n-\n-Entered:  1996-07-15\n-\u001f\n Joseph R. Kiniry\t\t<kiniry@cs.caltech.edu>\n Caltech Mailstop 256-80\t\thttp://www.cs.caltech.edu/~kiniry/\n Pasadena, CA 91125              <jrk@metagenesis.com>\n@@ -717,26 +670,26 @@ Updated: 1997-05-07\n \u001f\n Bradley M. Kuhn\n <bkuhn@acm.org>\n-http://www.smart.net/~bkuhn\n+http://www.ebb.org/bkuhn\n \n I am available for primarily Unix system administration consulting, including\n but not limited to installation, configuration and integration of GNU tools\n and other copy-lefted software such as GNU/Linux.\n \n-I am particularly skilled at end-user hand-holding and assisting in the\n-integration of GNU and other copy-lefted software into new environments that\n-have not used such tools in the past.\n+I am particularly skilled at integration of GNU and other copy-lefted software\n+into new environments that have not used such tools in the past, and porting\n+the GNU software to new Unix-based platforms.\n \n Please visit my homepage for more information on my background and skills.\n \n I am available for both 1099 (preferred) and W2 on-site contracting in the\n-Baltimore, MD metropolitan area, as well as remote consulting via dialup or\n+Cincinnati, OH metropolitan area, as well as remote consulting via dialup or\n Internet connection anywhere in the US.\n-\n+ \n My rate is in the $40/hour range, depending on the circumstances.  Rates for\n non-profit organizations are substantially lower, and possibly free.\n \n-Updated: 1996-12-31\n+Updated: 1997-08-03\n \u001f\n Fen Labalme                       <fen@comedia.com>\n CoMedia Consulting           http//www.comedia.com/comedia/\n@@ -1376,12 +1329,12 @@ Services:\n   Internet access\n \n Rates:\n-  DM 110 (~$70) per hour\n-  Support contracts start at DM 170/month + DM 30/supported system.\n+  DM 150 (~$85) per hour\n+  Support contracts start at DM 220/month + DM 30/supported system.\n   Willing to travel for sufficiently large jobs.\n   Rates don't include taxes.\n \n-Updated: 1996-07-05\n+Updated: 1997-08-04\n \u001f\n Paul C.A. van Gool\n       <P.vanGool@LR.TUDelft.NL>"}, {"sha": "5c1cc1bf1dcf6f79c5eb9d40a2d7f7b0fa60bab2", "filename": "gcc/c-parse.c", "status": "modified", "additions": 1132, "deletions": 1145, "changes": 2277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}, {"sha": "58b75251ba652f60dc3a719f7c88124f6bf5eae2", "filename": "gcc/c-parse.y", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -54,11 +54,12 @@ State 434 contains 2 shift/reduce conflicts.  (Four ways to parse this.)  */\n \n \n %{\n+#include \"config.h\"\n+\n #include <stdio.h>\n #include <errno.h>\n #include <setjmp.h>\n \n-#include \"config.h\"\n #include \"tree.h\"\n #include \"input.h\"\n #include \"c-lex.h\"\n@@ -207,9 +208,11 @@ void yyerror ();\n \f\n \f\n %{\n-/* Number of statements (loosely speaking) seen so far.  */\n+/* Number of statements (loosely speaking) and compound statements \n+   seen so far.  */\n static int stmt_count;\n-\n+static int compstmt_count;\n+  \n /* Input file and line number of the end of the body of last simple_if;\n    used by the stmt-rule immediately after simple_if returns.  */\n static char *if_stmt_file;\n@@ -442,7 +445,7 @@ unary_expr:\n \t| sizeof unary_expr  %prec UNARY\n \t\t{ skip_evaluation--;\n \t\t  if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))\n+\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n \t\t    error (\"`sizeof' applied to a bit-field\");\n \t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n \t| sizeof '(' typename ')'  %prec HYPERUNARY\n@@ -1544,25 +1547,27 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt: '{' '}'\n+compstmt_start: '{' { compstmt_count++; }\n+\n+compstmt: compstmt_start '}'\n \t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| '{' pushlevel maybe_label_decls decls xstmts '}'\n+\t| compstmt_start pushlevel maybe_label_decls decls xstmts '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), 1, 0);\n \t\t  $$ = poplevel (1, 1, 0);\n \t\t  if (yychar == CONSTANT || yychar == STRING)\n \t\t    pop_momentary_nofree ();\n \t\t  else\n \t\t    pop_momentary (); }\n-\t| '{' pushlevel maybe_label_decls error '}'\n+\t| compstmt_start pushlevel maybe_label_decls error '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n \t\t  if (yychar == CONSTANT || yychar == STRING)\n \t\t    pop_momentary_nofree ();\n \t\t  else\n \t\t    pop_momentary (); }\n-\t| '{' pushlevel maybe_label_decls stmts '}'\n+\t| compstmt_start pushlevel maybe_label_decls stmts '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n@@ -1575,16 +1580,17 @@ compstmt: '{' '}'\n /* Value is number of statements counted as of the closeparen.  */\n simple_if:\n \t  if_prefix lineno_labeled_stmt\n-/* Make sure expand_end_cond is run once\n-   for each call to expand_start_cond.\n+/* Make sure c_expand_end_cond is run once\n+   for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n \t| if_prefix error\n \t;\n \n if_prefix:\n \t  IF '(' expr ')'\n \t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  expand_start_cond (truthvalue_conversion ($3), 0);\n+\t\t  c_expand_start_cond (truthvalue_conversion ($3), 0, \n+\t\t\t\t       compstmt_count);\n \t\t  $<itype>$ = stmt_count;\n \t\t  if_stmt_file = $<filename>-1;\n \t\t  if_stmt_line = $<lineno>0;\n@@ -1597,6 +1603,7 @@ if_prefix:\n do_stmt_start:\n \t  DO\n \t\t{ stmt_count++;\n+\t\t  compstmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  /* See comment in `while' alternative, above.  */\n \t\t  emit_nop ();\n@@ -1659,27 +1666,27 @@ stmt:\n \t\t  iterator_expand ($1);\n \t\t  clear_momentary (); }\n \t| simple_if ELSE\n-\t\t{ expand_start_else ();\n+\t\t{ c_expand_start_else ();\n \t\t  $<itype>1 = stmt_count;\n \t\t  position_after_white_space (); }\n \t  lineno_labeled_stmt\n-\t\t{ expand_end_cond ();\n+\t\t{ c_expand_end_cond ();\n \t\t  if (extra_warnings && stmt_count == $<itype>1)\n \t\t    warning (\"empty body in an else-statement\"); }\n \t| simple_if %prec IF\n-\t\t{ expand_end_cond ();\n+\t\t{ c_expand_end_cond ();\n \t\t  /* This warning is here instead of in simple_if, because we\n \t\t     do not want a warning if an empty if is followed by an\n \t\t     else statement.  Increment stmt_count so we don't\n \t\t     give a second error if this is a nested `if'.  */\n \t\t  if (extra_warnings && stmt_count++ == $<itype>1)\n \t\t    warning_with_file_and_line (if_stmt_file, if_stmt_line,\n \t\t\t\t\t\t\"empty body in an if-statement\"); }\n-/* Make sure expand_end_cond is run once\n-   for each call to expand_start_cond.\n+/* Make sure c_expand_end_cond is run once\n+   for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n \t| simple_if ELSE error\n-\t\t{ expand_end_cond (); }\n+\t\t{ c_expand_end_cond (); }\n \t| WHILE\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);"}, {"sha": "3156a2c1e828e9cdde54bd5fabc27d47bc2d610e", "filename": "gcc/cexp.c", "status": "modified", "additions": 111, "deletions": 108, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,5 +1,6 @@\n \n-/*  A Bison parser, made from cexp.y with Bison version GNU Bison version 1.24\n+/*  A Bison parser, made from cexp.y\n+ by  Bison version A2.5 (Andrew Consortium)\n   */\n \n #define YYBISON 1  /* Identify Bison output.  */\n@@ -25,15 +26,11 @@\n /* #define YYDEBUG 1 */\n \n /* The following symbols should be autoconfigured:\n-\tHAVE_STDLIB_H\n \tSTDC_HEADERS\n    In the mean time, we'll get by with approximations based\n    on existing GCC configuration symbols.  */\n \n #ifdef POSIX\n-# ifndef HAVE_STDLIB_H\n-# define HAVE_STDLIB_H 1\n-# endif\n # ifndef STDC_HEADERS\n # define STDC_HEADERS 1\n # endif\n@@ -47,6 +44,10 @@\n # include <stdlib.h>\n #endif\n \n+#if HAVE_LIMITS_H\n+# include <limits.h>\n+#endif\n+\n #ifdef MULTIBYTE_CHARS\n #include <locale.h>\n #endif\n@@ -82,18 +83,38 @@ struct arglist {\n #endif\n \n /* Find the largest host integer type and set its size and type.\n-   Don't blindly use `long'; on some crazy hosts it is shorter than `int'.  */\n+   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n \n-#ifndef HOST_BITS_PER_WIDE_INT\n+#ifndef HOST_WIDE_INT\n+# if HAVE_INTTYPES_H\n+#  include <inttypes.h>\n+#  define HOST_WIDE_INT intmax_t\n+#  define unsigned_HOST_WIDE_INT uintmax_t\n+# else\n+#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT \\\n+       && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n+#   define HOST_WIDE_INT int\n+#  else\n+#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG \\\n+       || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n+#   define HOST_WIDE_INT long\n+#  else\n+#   define HOST_WIDE_INT long long\n+#  endif\n+#  endif\n+# endif\n+#endif\n \n-#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n-#define HOST_WIDE_INT long\n-#else\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n-#define HOST_WIDE_INT int\n+#ifndef unsigned_HOST_WIDE_INT\n+#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT\n #endif\n \n+#ifndef CHAR_BIT\n+#define CHAR_BIT 8\n+#endif\n+\n+#ifndef HOST_BITS_PER_WIDE_INT\n+#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))\n #endif\n \n #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)\n@@ -194,17 +215,13 @@ extern int warn_undef;\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n-#if MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT\n-#define MAX_CHAR_TYPE_MASK (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE))\n-#else\n-#define MAX_CHAR_TYPE_MASK (~ (HOST_WIDE_INT) 0)\n-#endif\n+#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    : ~ (HOST_WIDE_INT) 0)\n \n-#if MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT\n-#define MAX_WCHAR_TYPE_MASK (~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE))\n-#else\n-#define MAX_WCHAR_TYPE_MASK (~ (HOST_WIDE_INT) 0)\n-#endif\n+#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     : ~ (HOST_WIDE_INT) 0)\n \n /* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n@@ -227,37 +244,20 @@ void pedwarn PRINTF_PROTO_1((char *, ...));\n void warning PRINTF_PROTO_1((char *, ...));\n \n static int parse_number PROTO((int));\n-static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n-static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n+static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n+static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n static void integer_overflow PROTO((void));\n \n /* `signedp' values */\n #define SIGNED (~0)\n #define UNSIGNED 0\n \n-#line 244 \"cexp.y\"\n+#line 260 \"cexp.y\"\n typedef union {\n   struct constant {HOST_WIDE_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n   struct arglist *keywords;\n } YYSTYPE;\n-\n-#ifndef YYLTYPE\n-typedef\n-  struct yyltype\n-    {\n-      int timestamp;\n-      int first_line;\n-      int first_column;\n-      int last_line;\n-      int last_column;\n-      char *text;\n-   }\n-  yyltype;\n-\n-#define YYLTYPE yyltype\n-#endif\n-\n #include <stdio.h>\n \n #ifndef __cplusplus\n@@ -333,17 +333,20 @@ static const short yyrhs[] = {    35,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   274,   279,   280,   287,   292,   295,   297,   300,   304,   306,\n-   311,   316,   329,   346,   359,   365,   371,   377,   383,   386,\n-   389,   396,   403,   410,   417,   420,   423,   426,   429,   432,\n-   435,   438,   440,   443,   446,   448,   450,   458,   460,   473\n+   290,   295,   296,   303,   308,   311,   313,   316,   320,   322,\n+   327,   332,   345,   362,   375,   381,   387,   393,   399,   402,\n+   405,   412,   419,   426,   433,   436,   439,   442,   445,   448,\n+   451,   454,   456,   459,   462,   464,   466,   474,   476,   489\n };\n+#endif\n+\n+\n+#if YYDEBUG != 0\n \n static const char * const yytname[] = {   \"$\",\"error\",\"$undefined.\",\"INT\",\"CHAR\",\n \"NAME\",\"ERROR\",\"'?'\",\"':'\",\"','\",\"OR\",\"AND\",\"'|'\",\"'^'\",\"'&'\",\"EQUAL\",\"NOTEQUAL\",\n \"'<'\",\"'>'\",\"LEQ\",\"GEQ\",\"LSH\",\"RSH\",\"'+'\",\"'-'\",\"'*'\",\"'/'\",\"'%'\",\"UNARY\",\"'!'\",\n-\"'~'\",\"'#'\",\"'('\",\"')'\",\"start\",\"exp1\",\"exp\",\"@1\",\"@2\",\"@3\",\"@4\",\"@5\",\"keywords\",\n-\"\"\n+\"'~'\",\"'#'\",\"'('\",\"')'\",\"start\",\"exp1\",\"exp\",\"@1\",\"@2\",\"@3\",\"@4\",\"@5\",\"keywords\", NULL\n };\n #endif\n \n@@ -439,7 +442,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/share/bison.simple\"\n+#line 3 \"/usr/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -632,7 +635,7 @@ __yy_memcpy (char *from, char *to, int count)\n #endif\n #endif\n \f\n-#line 192 \"/usr/local/share/bison.simple\"\n+#line 192 \"/usr/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -931,59 +934,59 @@ yyparse(YYPARSE_PARAM)\n   switch (yyn) {\n \n case 1:\n-#line 275 \"cexp.y\"\n+#line 291 \"cexp.y\"\n { expression_value = yyvsp[0].integer.value; ;\n     break;}\n case 3:\n-#line 281 \"cexp.y\"\n+#line 297 \"cexp.y\"\n { if (pedantic)\n \t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n \t\t\t  yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 4:\n-#line 288 \"cexp.y\"\n+#line 304 \"cexp.y\"\n { yyval.integer.value = - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp;\n \t\t\t  if ((yyval.integer.value & yyvsp[0].integer.value & yyval.integer.signedp) < 0)\n \t\t\t    integer_overflow (); ;\n     break;}\n case 5:\n-#line 293 \"cexp.y\"\n+#line 309 \"cexp.y\"\n { yyval.integer.value = ! yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 6:\n-#line 296 \"cexp.y\"\n+#line 312 \"cexp.y\"\n { yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 7:\n-#line 298 \"cexp.y\"\n+#line 314 \"cexp.y\"\n { yyval.integer.value = ~ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp; ;\n     break;}\n case 8:\n-#line 301 \"cexp.y\"\n+#line 317 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[0].name.address, yyvsp[0].name.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 9:\n-#line 305 \"cexp.y\"\n+#line 321 \"cexp.y\"\n { keyword_parsing = 1; ;\n     break;}\n case 10:\n-#line 307 \"cexp.y\"\n+#line 323 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[-4].name.address, yyvsp[-4].name.length,\n \t\t\t\t\t\t      1, yyvsp[-1].keywords);\n \t\t\t  keyword_parsing = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 11:\n-#line 312 \"cexp.y\"\n+#line 328 \"cexp.y\"\n { yyval.integer = yyvsp[-1].integer; ;\n     break;}\n case 12:\n-#line 317 \"cexp.y\"\n+#line 333 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    {\n@@ -994,11 +997,11 @@ case 12:\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t* yyvsp[0].integer.value); ;\n     break;}\n case 13:\n-#line 330 \"cexp.y\"\n+#line 346 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -1013,11 +1016,11 @@ case 13:\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t/ yyvsp[0].integer.value); ;\n     break;}\n case 14:\n-#line 347 \"cexp.y\"\n+#line 363 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -1028,158 +1031,158 @@ case 14:\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value % yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t% yyvsp[0].integer.value); ;\n     break;}\n case 15:\n-#line 360 \"cexp.y\"\n+#line 376 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyvsp[-2].integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyval.integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 16:\n-#line 366 \"cexp.y\"\n+#line 382 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyval.integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyvsp[-2].integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 17:\n-#line 372 \"cexp.y\"\n+#line 388 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 18:\n-#line 378 \"cexp.y\"\n+#line 394 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 19:\n-#line 384 \"cexp.y\"\n+#line 400 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 20:\n-#line 387 \"cexp.y\"\n+#line 403 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 21:\n-#line 390 \"cexp.y\"\n+#line 406 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t<= yyvsp[0].integer.value); ;\n     break;}\n case 22:\n-#line 397 \"cexp.y\"\n+#line 413 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t>= yyvsp[0].integer.value); ;\n     break;}\n case 23:\n-#line 404 \"cexp.y\"\n+#line 420 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t< yyvsp[0].integer.value); ;\n     break;}\n case 24:\n-#line 411 \"cexp.y\"\n+#line 427 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n \t\t\t\t\t> yyvsp[0].integer.value); ;\n     break;}\n case 25:\n-#line 418 \"cexp.y\"\n+#line 434 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 26:\n-#line 421 \"cexp.y\"\n+#line 437 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 27:\n-#line 424 \"cexp.y\"\n+#line 440 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 28:\n-#line 427 \"cexp.y\"\n+#line 443 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 29:\n-#line 429 \"cexp.y\"\n+#line 445 \"cexp.y\"\n { skip_evaluation -= !yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value && yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 30:\n-#line 433 \"cexp.y\"\n+#line 449 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-1].integer.value; ;\n     break;}\n case 31:\n-#line 435 \"cexp.y\"\n+#line 451 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value || yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 32:\n-#line 439 \"cexp.y\"\n+#line 455 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 33:\n-#line 441 \"cexp.y\"\n+#line 457 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-4].integer.value - !yyvsp[-4].integer.value; ;\n     break;}\n case 34:\n-#line 443 \"cexp.y\"\n+#line 459 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-6].integer.value;\n \t\t\t  yyval.integer.value = yyvsp[-6].integer.value ? yyvsp[-3].integer.value : yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-3].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 35:\n-#line 447 \"cexp.y\"\n+#line 463 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 36:\n-#line 449 \"cexp.y\"\n+#line 465 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 37:\n-#line 451 \"cexp.y\"\n+#line 467 \"cexp.y\"\n { if (warn_undef && !skip_evaluation)\n \t\t\t    warning (\"`%.*s' is not defined\",\n \t\t\t\t     yyvsp[0].name.length, yyvsp[0].name.address);\n \t\t\t  yyval.integer.value = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 38:\n-#line 459 \"cexp.y\"\n+#line 475 \"cexp.y\"\n { yyval.keywords = 0; ;\n     break;}\n case 39:\n-#line 461 \"cexp.y\"\n+#line 477 \"cexp.y\"\n { struct arglist *temp;\n \t\t\t  yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->next = yyvsp[-2].keywords;\n@@ -1194,15 +1197,15 @@ case 39:\n \t\t\t  temp->next->length = 1; ;\n     break;}\n case 40:\n-#line 474 \"cexp.y\"\n+#line 490 \"cexp.y\"\n { yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->name = yyvsp[-1].name.address;\n \t\t\t  yyval.keywords->length = yyvsp[-1].name.length;\n \t\t\t  yyval.keywords->next = yyvsp[0].keywords; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 487 \"/usr/local/share/bison.simple\"\n+#line 487 \"/usr/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -1398,7 +1401,7 @@ case 40:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 479 \"cexp.y\"\n+#line 495 \"cexp.y\"\n \n \f\n /* During parsing of a C expression, the pointer to the next character\n@@ -1418,7 +1421,7 @@ parse_number (olen)\n {\n   register char *p = lexptr;\n   register int c;\n-  register unsigned HOST_WIDE_INT n = 0, nd, max_over_base;\n+  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;\n   register int base = 10;\n   register int len = olen;\n   register int overflow = 0;\n@@ -1436,7 +1439,7 @@ parse_number (olen)\n     }\n   }\n \n-  max_over_base = (unsigned HOST_WIDE_INT) -1 / base;\n+  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;\n \n   for (; len > 0; len--) {\n     c = *p++;\n@@ -1674,11 +1677,11 @@ yylex ()\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & (~ (unsigned HOST_WIDE_INT) 0\n+\t      = result & (~ (unsigned_HOST_WIDE_INT) 0\n \t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~(~ (unsigned HOST_WIDE_INT) 0\n+\t      = result | ~(~ (unsigned_HOST_WIDE_INT) 0\n \t\t\t   >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t}\n       else\n@@ -1885,7 +1888,7 @@ parse_escape (string_ptr, result_mask)\n       }\n     case 'x':\n       {\n-\tregister unsigned HOST_WIDE_INT i = 0, overflow = 0;\n+\tregister unsigned_HOST_WIDE_INT i = 0, overflow = 0;\n \tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n@@ -1938,28 +1941,28 @@ integer_overflow ()\n static HOST_WIDE_INT\n left_shift (a, b)\n      struct constant *a;\n-     unsigned HOST_WIDE_INT b;\n+     unsigned_HOST_WIDE_INT b;\n {\n    /* It's unclear from the C standard whether shifts can overflow.\n       The following code ignores overflow; perhaps a C standard\n       interpretation ruling is needed.  */\n   if (b >= HOST_BITS_PER_WIDE_INT)\n     return 0;\n   else\n-    return (unsigned HOST_WIDE_INT) a->value << b;\n+    return (unsigned_HOST_WIDE_INT) a->value << b;\n }\n \n static HOST_WIDE_INT\n right_shift (a, b)\n      struct constant *a;\n-     unsigned HOST_WIDE_INT b;\n+     unsigned_HOST_WIDE_INT b;\n {\n   if (b >= HOST_BITS_PER_WIDE_INT)\n     return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;\n   else if (a->signedp)\n     return a->value >> b;\n   else\n-    return (unsigned HOST_WIDE_INT) a->value >> b;\n+    return (unsigned_HOST_WIDE_INT) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */"}, {"sha": "a0de5bf1a77154f256b276a873c11c6ad3c5f458", "filename": "gcc/config/arm/xm-netbsd.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fconfig%2Farm%2Fxm-netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fconfig%2Farm%2Fxm-netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxm-netbsd.h?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -7,4 +7,12 @@\n #undef HAVE_VPRINTF\n #endif\n \n+#ifndef SYS_SIGLIST_DECLARED\n+#define SYS_SIGLIST_DECLARED\n+#endif\n+\n+#ifndef HAVE_STRERROR\n+#define HAVE_STRERROR\n+#endif\n+\n #include <xm-netbsd.h>"}, {"sha": "9c80c878ad4d9965c51b73a3af7110c95c746686", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 1755, "deletions": 1747, "changes": 3502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}, {"sha": "4dc0bcf95caae085cde3e2d4becbd69f72016ff5", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -31,11 +31,12 @@ Boston, MA 02111-1307, USA.  */\n %expect 66\n \n %{\n+#include \"config.h\"\n+\n #include <stdio.h>\n #include <errno.h>\n #include <setjmp.h>\n \n-#include \"config.h\"\n #include \"tree.h\"\n #include \"input.h\"\n #include \"c-lex.h\"\n@@ -196,9 +197,11 @@ void yyerror ();\n %type <ttype> CLASSNAME OBJC_STRING OBJECTNAME\n \f\n %{\n-/* Number of statements (loosely speaking) seen so far.  */\n+/* Number of statements (loosely speaking) and compound statements \n+   seen so far.  */\n static int stmt_count;\n-\n+static int compstmt_count;\n+  \n /* Input file and line number of the end of the body of last simple_if;\n    used by the stmt-rule immediately after simple_if returns.  */\n static char *if_stmt_file;\n@@ -445,7 +448,7 @@ unary_expr:\n \t| sizeof unary_expr  %prec UNARY\n \t\t{ skip_evaluation--;\n \t\t  if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))\n+\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n \t\t    error (\"`sizeof' applied to a bit-field\");\n \t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n \t| sizeof '(' typename ')'  %prec HYPERUNARY\n@@ -1658,25 +1661,27 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt: '{' '}'\n+compstmt_start: '{' { compstmt_count++; }\n+\n+compstmt: compstmt_start '}'\n \t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| '{' pushlevel maybe_label_decls decls xstmts '}'\n+\t| compstmt_start pushlevel maybe_label_decls decls xstmts '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), 1, 0);\n \t\t  $$ = poplevel (1, 1, 0);\n \t\t  if (yychar == CONSTANT || yychar == STRING)\n \t\t    pop_momentary_nofree ();\n \t\t  else\n \t\t    pop_momentary (); }\n-\t| '{' pushlevel maybe_label_decls error '}'\n+\t| compstmt_start pushlevel maybe_label_decls error '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n \t\t  if (yychar == CONSTANT || yychar == STRING)\n \t\t    pop_momentary_nofree ();\n \t\t  else\n \t\t    pop_momentary (); }\n-\t| '{' pushlevel maybe_label_decls stmts '}'\n+\t| compstmt_start pushlevel maybe_label_decls stmts '}'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n@@ -1689,16 +1694,17 @@ compstmt: '{' '}'\n /* Value is number of statements counted as of the closeparen.  */\n simple_if:\n \t  if_prefix lineno_labeled_stmt\n-/* Make sure expand_end_cond is run once\n-   for each call to expand_start_cond.\n+/* Make sure c_expand_end_cond is run once\n+   for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n \t| if_prefix error\n \t;\n \n if_prefix:\n \t  IF '(' expr ')'\n \t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  expand_start_cond (truthvalue_conversion ($3), 0);\n+\t\t  c_expand_start_cond (truthvalue_conversion ($3), 0, \n+\t\t\t\t       compstmt_count);\n \t\t  $<itype>$ = stmt_count;\n \t\t  if_stmt_file = $<filename>-1;\n \t\t  if_stmt_line = $<lineno>0;\n@@ -1711,6 +1717,7 @@ if_prefix:\n do_stmt_start:\n \t  DO\n \t\t{ stmt_count++;\n+\t\t  compstmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  /* See comment in `while' alternative, above.  */\n \t\t  emit_nop ();\n@@ -1773,27 +1780,27 @@ stmt:\n \t\t  iterator_expand ($1);\n \t\t  clear_momentary (); }\n \t| simple_if ELSE\n-\t\t{ expand_start_else ();\n+\t\t{ c_expand_start_else ();\n \t\t  $<itype>1 = stmt_count;\n \t\t  position_after_white_space (); }\n \t  lineno_labeled_stmt\n-\t\t{ expand_end_cond ();\n+\t\t{ c_expand_end_cond ();\n \t\t  if (extra_warnings && stmt_count == $<itype>1)\n \t\t    warning (\"empty body in an else-statement\"); }\n \t| simple_if %prec IF\n-\t\t{ expand_end_cond ();\n+\t\t{ c_expand_end_cond ();\n \t\t  /* This warning is here instead of in simple_if, because we\n \t\t     do not want a warning if an empty if is followed by an\n \t\t     else statement.  Increment stmt_count so we don't\n \t\t     give a second error if this is a nested `if'.  */\n \t\t  if (extra_warnings && stmt_count++ == $<itype>1)\n \t\t    warning_with_file_and_line (if_stmt_file, if_stmt_line,\n \t\t\t\t\t\t\"empty body in an if-statement\"); }\n-/* Make sure expand_end_cond is run once\n-   for each call to expand_start_cond.\n+/* Make sure c_expand_end_cond is run once\n+   for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n \t| simple_if ELSE error\n-\t\t{ expand_end_cond (); }\n+\t\t{ c_expand_end_cond (); }\n \t| WHILE\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);"}]}