{"sha": "3aeb3655cf89356c86726d49316dcb957859971f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlYjM2NTVjZjg5MzU2Yzg2NzI2ZDQ5MzE2ZGNiOTU3ODU5OTcxZg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-06-02T19:46:13Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-06-02T19:46:13Z"}, "message": "c-typeck.c (common_type): Don't lose type qualifiers when creating new variants.\n\n2004-06-02  Eric Christopher  <echristo@redhat.com>\n\n        * c-typeck.c (common_type): Don't lose type qualifiers\n        when creating new variants.\n\n2004-06-02  Eric Christopher  <echristo@redhat.com>\n\n        * gcc.c-torture/compile/20040602-1.c: New.\n\nFrom-SVN: r82577", "tree": {"sha": "d36ee4bf09e2586b23075250a34462a295e2664c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d36ee4bf09e2586b23075250a34462a295e2664c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aeb3655cf89356c86726d49316dcb957859971f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aeb3655cf89356c86726d49316dcb957859971f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aeb3655cf89356c86726d49316dcb957859971f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aeb3655cf89356c86726d49316dcb957859971f/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03a4c969079e508d695f0b8b82bd573b54e01a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a4c969079e508d695f0b8b82bd573b54e01a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a4c969079e508d695f0b8b82bd573b54e01a3c"}], "stats": {"total": 102, "additions": 68, "deletions": 34}, "files": [{"sha": "b70ac67846fcb70b2564c2d0b97acc9bb31515a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aeb3655cf89356c86726d49316dcb957859971f", "patch": "@@ -1,3 +1,8 @@\n+2004-06-02  Eric Christopher  <echristo@redhat.com>\n+\n+\t* c-typeck.c (common_type): Don't lose type qualifiers\n+\twhen creating new variants.\n+\n 2004-06-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-optimization/14042"}, {"sha": "cf01aa5f60f2e307fcf72b10ae01db8c4a21555c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3aeb3655cf89356c86726d49316dcb957859971f", "patch": "@@ -279,45 +279,64 @@ common_type (tree t1, tree t2)\n \n       /* Same precision.  Prefer long longs to longs to ints when the\n \t same precision, following the C99 rules on integer type rank\n-\t (which are equivalent to the C90 rules for C90 types).  */\n+\t (which are equivalent to the C90 rules for C90 types).\n+\t Make sure that we don't lose the type qualifications when\n+\t creating the new variant.  */\n \n       if (TYPE_MAIN_VARIANT (t1) == long_long_unsigned_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_long_unsigned_type_node)\n-\treturn build_type_attribute_variant (long_long_unsigned_type_node,\n-\t\t\t\t\t     attributes);\n+\t{\n+\t  t1 = build_qualified_type (long_long_unsigned_type_node,\n+\t\t\t\t     TYPE_QUALS (t1));\n+\t  return build_type_attribute_variant (t1, attributes);\n+\t}\n \n       if (TYPE_MAIN_VARIANT (t1) == long_long_integer_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_long_integer_type_node)\n \t{\n+\t  tree ntype;\n+\n \t  if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t     t1 = long_long_unsigned_type_node;\n+\t     ntype = long_long_unsigned_type_node;\n \t  else\n-\t     t1 = long_long_integer_type_node;\n-\t  return build_type_attribute_variant (t1, attributes);\n+\t     ntype = long_long_integer_type_node;\n+\n+\t  ntype = build_qualified_type (ntype, TYPE_QUALS (t1));\n+\t  return build_type_attribute_variant (ntype, attributes);\n \t}\n \n       if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n-\treturn build_type_attribute_variant (long_unsigned_type_node,\n-\t\t\t\t\t     attributes);\n+\t{\n+\t  t1 = build_qualified_type (long_unsigned_type_node,\n+\t\t\t\t     TYPE_QUALS (t1));\n+\t  return build_type_attribute_variant (t1, attributes);\n+\t}\n \n       if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n \t{\n+\t  tree ntype;\n+\n \t  /* But preserve unsignedness from the other type,\n \t     since long cannot hold all the values of an unsigned int.  */\n \t  if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t     t1 = long_unsigned_type_node;\n+\t     ntype = long_unsigned_type_node;\n \t  else\n-\t     t1 = long_integer_type_node;\n-\t  return build_type_attribute_variant (t1, attributes);\n+\t     ntype = long_integer_type_node;\n+\n+\t  ntype = build_qualified_type (ntype, TYPE_QUALS (t1));\n+\t  return build_type_attribute_variant (ntype, attributes);\n \t}\n \n       /* Likewise, prefer long double to double even if same size.  */\n       if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n-\treturn build_type_attribute_variant (long_double_type_node,\n-\t\t\t\t\t     attributes);\n+\t{\n+\t  t1 = build_qualified_type (long_double_type_node,\n+\t\t\t\t     TYPE_QUALS (t1));\n+\t  return build_type_attribute_variant (t1, attributes);\n+\t}\n \n       /* Otherwise prefer the unsigned one.  */\n \n@@ -425,7 +444,7 @@ common_type (tree t1, tree t2)\n \t\ttree memb;\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p1));\n \t\t     memb; memb = TREE_CHAIN (memb))\n-\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p2), \n+\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p2),\n \t\t\t\t COMPARE_STRICT))\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p2);\n@@ -440,7 +459,7 @@ common_type (tree t1, tree t2)\n \t\ttree memb;\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p2));\n \t\t     memb; memb = TREE_CHAIN (memb))\n-\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p1), \n+\t\t  if (comptypes (TREE_TYPE (memb), TREE_VALUE (p1),\n \t\t\t\t COMPARE_STRICT))\n \t\t    {\n \t\t      TREE_VALUE (n) = TREE_VALUE (p1);\n@@ -506,7 +525,8 @@ comptypes (tree type1, tree type2, int flags)\n \n   /* Different classes of types can't be compatible.  */\n \n-  if (TREE_CODE (t1) != TREE_CODE (t2)) return 0;\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return 0;\n \n   /* Qualifiers must match.  */\n \n@@ -686,7 +706,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n {\n   tree s1, s2;\n   bool needs_warning = false;\n-  \n+\n   /* We have to verify that the tags of the types are the same.  This\n      is harder than it looks because this may be a typedef, so we have\n      to go look at the original type.  It may even be a typedef of a\n@@ -706,49 +726,49 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n   /* C90 didn't have the requirement that the two tags be the same.  */\n   if (flag_isoc99 && TYPE_NAME (t1) != TYPE_NAME (t2))\n     return 0;\n-  \n+\n   /* C90 didn't say what happened if one or both of the types were\n      incomplete; we choose to follow C99 rules here, which is that they\n      are compatible.  */\n   if (TYPE_SIZE (t1) == NULL\n       || TYPE_SIZE (t2) == NULL)\n     return 1;\n-  \n+\n   {\n     const struct tagged_tu_seen * tts_i;\n     for (tts_i = tagged_tu_seen_base; tts_i != NULL; tts_i = tts_i->next)\n       if (tts_i->t1 == t1 && tts_i->t2 == t2)\n \treturn 1;\n   }\n-  \n+\n   switch (TREE_CODE (t1))\n     {\n     case ENUMERAL_TYPE:\n       {\n-      \n+\n         /* Speed up the case where the type values are in the same order.  */\n         tree tv1 = TYPE_VALUES (t1);\n         tree tv2 = TYPE_VALUES (t2);\n-        \n+\n         if (tv1 == tv2)\n           return 1;\n-        \n+\n         for (;tv1 && tv2; tv1 = TREE_CHAIN (tv1), tv2 = TREE_CHAIN (tv2))\n           {\n             if (TREE_PURPOSE (tv1) != TREE_PURPOSE (tv2))\n               break;\n             if (simple_cst_equal (TREE_VALUE (tv1), TREE_VALUE (tv2)) != 1)\n               return 0;\n           }\n-        \n+\n         if (tv1 == NULL_TREE && tv2 == NULL_TREE)\n           return 1;\n         if (tv1 == NULL_TREE || tv2 == NULL_TREE)\n           return 0;\n-        \n+\n \tif (list_length (TYPE_VALUES (t1)) != list_length (TYPE_VALUES (t2)))\n \t  return 0;\n-\t\n+\n \tfor (s1 = TYPE_VALUES (t1); s1; s1 = TREE_CHAIN (s1))\n \t  {\n \t    s2 = purpose_member (TREE_PURPOSE (s1), TYPE_VALUES (t2));\n@@ -773,7 +793,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n \t    tts.t1 = t1;\n \t    tts.t2 = t2;\n \t    tagged_tu_seen_base = &tts;\n-\t\n+\n \t    if (DECL_NAME (s1) != NULL)\n \t      for (s2 = TYPE_VALUES (t2); s2; s2 = TREE_CHAIN (s2))\n \t\tif (DECL_NAME (s1) == DECL_NAME (s2))\n@@ -784,7 +804,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n \t\t      break;\n \t\t    if (result == 2)\n \t\t      needs_warning = true;\n-\t\t    \n+\n \t\t    if (TREE_CODE (s1) == FIELD_DECL\n \t\t\t&& simple_cst_equal (DECL_FIELD_BIT_OFFSET (s1),\n \t\t\t\t\t     DECL_FIELD_BIT_OFFSET (s2)) != 1)\n@@ -803,13 +823,13 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n     case RECORD_TYPE:\n       {\n \tstruct tagged_tu_seen tts;\n-\t\n+\n \ttts.next = tagged_tu_seen_base;\n \ttts.t1 = t1;\n \ttts.t2 = t2;\n \ttagged_tu_seen_base = &tts;\n-\t  \n-\tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2); \n+\n+\tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2);\n \t     s1 && s2;\n \t     s1 = TREE_CHAIN (s1), s2 = TREE_CHAIN (s2))\n \t  {\n@@ -822,7 +842,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n \t      break;\n \t    if (result == 2)\n \t      needs_warning = true;\n-\t    \n+\n \t    if (TREE_CODE (s1) == FIELD_DECL\n \t\t&& simple_cst_equal (DECL_FIELD_BIT_OFFSET (s1),\n \t\t\t\t     DECL_FIELD_BIT_OFFSET (s2)) != 1)\n@@ -4319,7 +4339,7 @@ finish_init (void)\n \n   /* Pop back to the data of the outer initializer (if any).  */\n   free (spelling_base);\n-  \n+\n   constructor_decl = p->decl;\n   constructor_asmspec = p->asmspec;\n   require_constant_value = p->require_constant_value;"}, {"sha": "da095bfcb52266229c1aa92fed2915eb2f502780", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3aeb3655cf89356c86726d49316dcb957859971f", "patch": "@@ -1,11 +1,15 @@\n+2004-06-02  Eric Christopher  <echristo@redhat.com>\n+\n+\t* gcc.c-torture/compile/20040602-1.c: New.\n+\n 2004-06-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* g++.dg/tree-ssa/ssa-sra-1.C: Fix comment.\n \t* g++.dg/tree-ssa/ssa-sra-2.C: Likewise.\n \n \tPR tree-optimization/14736\n \t* g++.dg/tree-ssa/ssa-cast-1.C: New Test.\n-\t\n+\n \tPR tree-optimization/14042\n \t* g++.dg/tree-ssa/ssa-sra-1.C: New Test.\n "}, {"sha": "8f751e36208d78a1614d5014dbfdc7262f48ab3e", "filename": "gcc/testsuite/gcc.c-torture/compile/20040602-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040602-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb3655cf89356c86726d49316dcb957859971f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040602-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040602-1.c?ref=3aeb3655cf89356c86726d49316dcb957859971f", "patch": "@@ -0,0 +1,5 @@\n+/* Test type qualifiers.  These should as equal types.  */\n+extern volatile unsigned long foo;\n+typedef unsigned long ulong;\n+extern volatile ulong foo;\n+volatile ulong foo;"}]}