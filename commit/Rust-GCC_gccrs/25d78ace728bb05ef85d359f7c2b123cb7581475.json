{"sha": "25d78ace728bb05ef85d359f7c2b123cb7581475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVkNzhhY2U3MjhiYjA1ZWY4NWQzNTlmN2MyYjEyM2NiNzU4MTQ3NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-05-10T16:17:07Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-05-10T16:17:07Z"}, "message": "c-parse.in: Remove many shift/reduce conflicts.\n\n\t* c-parse.in: Remove many shift/reduce conflicts.  Update\n\t%expect values.\n\t(declspecs_nosc_nots_nosa_noea, declspecs_nosc_nots_nosa_ea,\n\tdeclspecs_nosc_nots_sa_noea, declspecs_nosc_nots_sa_ea,\n\tdeclspecs_nosc_ts_nosa_noea, declspecs_nosc_ts_nosa_ea,\n\tdeclspecs_nosc_ts_sa_noea, declspecs_nosc_ts_sa_ea,\n\tdeclspecs_sc_nots_nosa_noea, declspecs_sc_nots_nosa_ea,\n\tdeclspecs_sc_nots_sa_noea, declspecs_sc_nots_sa_ea,\n\tdeclspecs_sc_ts_nosa_noea, declspecs_sc_ts_nosa_ea,\n\tdeclspecs_sc_ts_sa_noea, declspecs_sc_ts_sa_ea, declspecs_ts,\n\tdeclspecs_nots, declspecs_ts_nosa, declspecs_nots_nosa,\n\tdeclspecs_nosc_ts, declspecs_nosc_nots, declspecs_nosc, declspecs,\n\tmaybe_type_quals_setattrs, typespec_nonattr, typespec_attr,\n\ttypespec_reserved_nonattr, typespec_reserved_attr,\n\ttypespec_nonreserved_nonattr, maybe_setattrs, structsp_attr,\n\tstructsp_nonattr, components_notype, component_notype_declarator,\n\tabsdcl1_ea, absdcl1_noea, direct_absdcl1, absdcl_maybe_attribute,\n\tfirstparm, setspecs_fp): New\n\t(typed_declspecs, reserved_declspecs, typed_typespecs,\n\treserved_typespecquals, declmods, typespec, typespecqual_reserved,\n\ttyped_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n\tdeclmods_no_prefix_attr, nonempty_type_quals, structsp,\n\ttype_quals): Remove.  Users updated.\n\t(initdecls, notype_initdecls, after_type_declarator,\n\tparm_declarator, notype_declarator, absdcl1, components, ivars):\n\tDon't allow attributes at the start of a declarator; include them\n\tin the production containing the declarator instead.  Always\n\trequire type specifiers before trying to redeclare a typedef name.\n\t(typename): Allow for attributes but warn that they are ignored.\n\t(parmlist, firstparm, setspecs_fp): Include attributes in\n\tparmlist; suck them off the parser stack in firstparm using\n\tsetspecs_fp.\n\ntestsuite:\n\t* gcc.c-torture/compile/20010313-1.c: New test.\n\nFrom-SVN: r41940", "tree": {"sha": "24b1e84afc1583d8b663e559841c1ca54b693e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24b1e84afc1583d8b663e559841c1ca54b693e2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25d78ace728bb05ef85d359f7c2b123cb7581475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25d78ace728bb05ef85d359f7c2b123cb7581475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25d78ace728bb05ef85d359f7c2b123cb7581475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25d78ace728bb05ef85d359f7c2b123cb7581475/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f926a2566dd729e82c3798ed9e3e0a91d67b06de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f926a2566dd729e82c3798ed9e3e0a91d67b06de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f926a2566dd729e82c3798ed9e3e0a91d67b06de"}], "stats": {"total": 946, "additions": 739, "deletions": 207}, "files": [{"sha": "db35f560fd02f5ec8e83572c530ea82a0161d086", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25d78ace728bb05ef85d359f7c2b123cb7581475", "patch": "@@ -1,3 +1,38 @@\n+2001-05-10  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-parse.in: Remove many shift/reduce conflicts.  Update\n+\t%expect values.\n+\t(declspecs_nosc_nots_nosa_noea, declspecs_nosc_nots_nosa_ea,\n+\tdeclspecs_nosc_nots_sa_noea, declspecs_nosc_nots_sa_ea,\n+\tdeclspecs_nosc_ts_nosa_noea, declspecs_nosc_ts_nosa_ea,\n+\tdeclspecs_nosc_ts_sa_noea, declspecs_nosc_ts_sa_ea,\n+\tdeclspecs_sc_nots_nosa_noea, declspecs_sc_nots_nosa_ea,\n+\tdeclspecs_sc_nots_sa_noea, declspecs_sc_nots_sa_ea,\n+\tdeclspecs_sc_ts_nosa_noea, declspecs_sc_ts_nosa_ea,\n+\tdeclspecs_sc_ts_sa_noea, declspecs_sc_ts_sa_ea, declspecs_ts,\n+\tdeclspecs_nots, declspecs_ts_nosa, declspecs_nots_nosa,\n+\tdeclspecs_nosc_ts, declspecs_nosc_nots, declspecs_nosc, declspecs,\n+\tmaybe_type_quals_setattrs, typespec_nonattr, typespec_attr,\n+\ttypespec_reserved_nonattr, typespec_reserved_attr,\n+\ttypespec_nonreserved_nonattr, maybe_setattrs, structsp_attr,\n+\tstructsp_nonattr, components_notype, component_notype_declarator,\n+\tabsdcl1_ea, absdcl1_noea, direct_absdcl1, absdcl_maybe_attribute,\n+\tfirstparm, setspecs_fp): New\n+\t(typed_declspecs, reserved_declspecs, typed_typespecs,\n+\treserved_typespecquals, declmods, typespec, typespecqual_reserved,\n+\ttyped_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n+\tdeclmods_no_prefix_attr, nonempty_type_quals, structsp,\n+\ttype_quals): Remove.  Users updated.\n+\t(initdecls, notype_initdecls, after_type_declarator,\n+\tparm_declarator, notype_declarator, absdcl1, components, ivars):\n+\tDon't allow attributes at the start of a declarator; include them\n+\tin the production containing the declarator instead.  Always\n+\trequire type specifiers before trying to redeclare a typedef name.\n+\t(typename): Allow for attributes but warn that they are ignored.\n+\t(parmlist, firstparm, setspecs_fp): Include attributes in\n+\tparmlist; suck them off the parser stack in firstparm using\n+\tsetspecs_fp.\n+\n Thu May 10 09:17:42 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* ifcvt.c (merge_if_block): Use any_uncondjump_p, not simplejump_p"}, {"sha": "e91f9ebdf9fc7e50388d2ce5195620482f2f93f7", "filename": "gcc/c-parse.in", "status": "modified", "additions": 695, "deletions": 207, "changes": 902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=25d78ace728bb05ef85d359f7c2b123cb7581475", "patch": "@@ -29,10 +29,10 @@ Boston, MA 02111-1307, USA.  */\n    written by AT&T, but I have never seen it.  */\n \n ifobjc\n-%expect 74\n+%expect 31\n end ifobjc\n ifc\n-%expect 53\n+%expect 10\n end ifc\n \n %{\n@@ -167,16 +167,27 @@ end ifc\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n-%type <ttype> typed_declspecs reserved_declspecs\n-%type <ttype> typed_typespecs reserved_typespecquals\n-%type <ttype> declmods typespec typespecqual_reserved\n-%type <ttype> typed_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n-%type <ttype> declmods_no_prefix_attr\n-%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n+%type <ttype> declspecs_nosc_nots_nosa_noea declspecs_nosc_nots_nosa_ea\n+%type <ttype> declspecs_nosc_nots_sa_noea declspecs_nosc_nots_sa_ea\n+%type <ttype> declspecs_nosc_ts_nosa_noea declspecs_nosc_ts_nosa_ea\n+%type <ttype> declspecs_nosc_ts_sa_noea declspecs_nosc_ts_sa_ea\n+%type <ttype> declspecs_sc_nots_nosa_noea declspecs_sc_nots_nosa_ea\n+%type <ttype> declspecs_sc_nots_sa_noea declspecs_sc_nots_sa_ea\n+%type <ttype> declspecs_sc_ts_nosa_noea declspecs_sc_ts_nosa_ea\n+%type <ttype> declspecs_sc_ts_sa_noea declspecs_sc_ts_sa_ea\n+%type <ttype> declspecs_ts declspecs_nots\n+%type <ttype> declspecs_ts_nosa declspecs_nots_nosa\n+%type <ttype> declspecs_nosc_ts declspecs_nosc_nots declspecs_nosc declspecs\n+%type <ttype> maybe_type_quals_setattrs typespec_nonattr typespec_attr\n+%type <ttype> typespec_reserved_nonattr typespec_reserved_attr\n+%type <ttype> typespec_nonreserved_nonattr\n+\n+%type <ttype> SCSPEC TYPESPEC TYPE_QUAL maybe_type_qual\n %type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n %type <ttype> init maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n+%type <ttype> maybe_setattrs\n %type <ttype> any_word extension\n \n %type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n@@ -187,18 +198,21 @@ end ifc\n %type <ttype> notype_declarator after_type_declarator\n %type <ttype> parm_declarator\n \n-%type <ttype> structsp component_decl_list component_decl_list2\n-%type <ttype> component_decl components component_declarator\n+%type <ttype> structsp_attr structsp_nonattr\n+%type <ttype> component_decl_list component_decl_list2\n+%type <ttype> component_decl components components_notype component_declarator\n+%type <ttype> component_notype_declarator\n %type <ttype> enumlist enumerator\n %type <ttype> struct_head union_head enum_head\n-%type <ttype> typename absdcl absdcl1 type_quals\n-%type <ttype> xexpr parms parm identifiers\n+%type <ttype> typename absdcl absdcl1 absdcl1_ea absdcl1_noea\n+%type <ttype> direct_absdcl1 absdcl_maybe_attribute\n+%type <ttype> xexpr parms parm firstparm identifiers\n \n %type <ttype> parmlist parmlist_1 parmlist_2\n %type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n %type <ttype> identifiers_or_typenames\n \n-%type <itype> setspecs\n+%type <itype> setspecs setspecs_fp\n \n %type <filename> save_filename\n %type <lineno> save_lineno\n@@ -345,17 +359,15 @@ datadef:\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods setspecs notype_initdecls ';'\n+        | declspecs_nots setspecs notype_initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs initdecls ';'\n+\t| declspecs_ts setspecs initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods ';'\n-\t  { pedwarn (\"empty declaration\"); }\n-\t| typed_declspecs ';'\n+\t| declspecs ';'\n \t  { shadow_tag ($1); }\n \t| error ';'\n \t| error '}'\n@@ -365,7 +377,7 @@ datadef:\n \t;\n \f\n fndef:\n-\t  typed_declspecs setspecs declarator\n+\t  declspecs_ts setspecs declarator\n \t\t{ if (! start_function (current_declspecs, $3,\n \t\t\t\t\tprefix_attributes, NULL_TREE))\n \t\t    YYERROR1;\n@@ -379,11 +391,11 @@ fndef:\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs declarator error\n+\t| declspecs_ts setspecs declarator error\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator\n+\t| declspecs_nots setspecs notype_declarator\n \t\t{ if (! start_function (current_declspecs, $3,\n \t\t\t\t\tprefix_attributes, NULL_TREE))\n \t\t    YYERROR1;\n@@ -397,7 +409,7 @@ fndef:\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator error\n+\t| declspecs_nots setspecs notype_declarator error\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n@@ -816,18 +828,18 @@ datadecls:\n    attribute suffix, or function defn with attribute prefix on first old\n    style parm.  */\n datadecl:\n-\ttyped_declspecs_no_prefix_attr setspecs initdecls ';'\n+\tdeclspecs_ts_nosa setspecs initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods_no_prefix_attr setspecs notype_initdecls ';'\n+\t| declspecs_nots_nosa setspecs notype_initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\t\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs_no_prefix_attr ';'\n+\t| declspecs_ts_nosa ';'\n \t\t{ shadow_tag_warned ($1, 1);\n \t\t  pedwarn (\"empty declaration\"); }\n-\t| declmods_no_prefix_attr ';'\n+\t| declspecs_nots_nosa ';'\n \t\t{ pedwarn (\"empty declaration\"); }\n \t;\n \n@@ -853,138 +865,562 @@ setspecs: /* empty */\n \t\t\t\t     &current_declspecs, &prefix_attributes); }\n \t;\n \n-/* ??? Yuck.  See after_type_declarator.  */\n+/* ??? Yuck.  See maybe_setattrs.  */\n setattrs: /* empty */\n \t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n \t;\n \n+maybe_setattrs:\n+\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n+\t   prefix_attributes because $1 only applies to this\n+\t   declarator.  We assume setspecs has already been done.\n+\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n+\t   attributes could be recognized here or in `attributes').\n+\t   Properly attributes ought to be able to apply to any level of\n+\t   nested declarator, but the necessary compiler support isn't\n+\t   present, so the attributes apply to a declaration (which may be\n+\t   nested).  */\n+\t  maybe_attribute setattrs\n+\t;\n+\n decl:\n-\ttyped_declspecs setspecs initdecls ';'\n+\tdeclspecs_ts setspecs initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_initdecls ';'\n+\t| declspecs_nots setspecs notype_initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs nested_function\n+\t| declspecs_ts setspecs nested_function\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_nested_function\n+\t| declspecs_nots setspecs notype_nested_function\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs ';'\n+\t| declspecs ';'\n \t\t{ shadow_tag ($1); }\n-\t| declmods ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n \t| extension decl\n \t\t{ RESTORE_WARN_FLAGS ($1); }\n \t;\n \n+/* A list of declaration specifiers.  These are:\n+\n+   - Storage class specifiers (SCSPEC), which for GCC currently include\n+   function specifiers (\"inline\").\n+\n+   - Type specifiers (typespec_*).\n+\n+   - Type qualifiers (TYPE_QUAL).\n+\n+   - Attribute specifier lists (attributes).\n+\n+   These are stored as a TREE_LIST; the head of the list is the last\n+   item in the specifier list.  Each entry in the list has either a\n+   TREE_PURPOSE that is an attribute specifier list, or a TREE_VALUE that\n+   is a single other specifier or qualifier; and a TREE_CHAIN that is the\n+   rest of the list.  TREE_STATIC is set on the list if something other\n+   than a storage class specifier or attribute has been seen; this is used\n+   to warn for the obsolescent usage of storage class specifiers other than\n+   at the start of the list.  (Doing this properly would require function\n+   specifiers to be handled separately from storage class specifiers.)\n+\n+   The various cases below are classified according to:\n+\n+   (a) Whether a storage class specifier is included or not; some\n+   places in the grammar disallow storage class specifiers (_sc or _nosc).\n+\n+   (b) Whether a type specifier has been seen; after a type specifier,\n+   a typedef name is an identifier to redeclare (_ts or _nots).\n+\n+   (c) Whether the list starts with an attribute; in certain places,\n+   the grammar requires specifiers that don't start with an attribute\n+   (_sa or _nosa).\n+\n+   (d) Whether the list ends with an attribute (or a specifier such that\n+   any following attribute would have been parsed as part of that specifier);\n+   this avoids shift-reduce conflicts in the parsing of attributes\n+   (_ea or _noea).\n+\n+   TODO:\n+\n+   (i) Distinguish between function specifiers and storage class specifiers,\n+   at least for the purpose of warnings about obsolescent usage.\n+\n+   (ii) Halve the number of productions here by eliminating the _sc/_nosc\n+   distinction and instead checking where required that storage class\n+   specifiers aren't present.  */\n+\n /* Declspecs which contain at least one type specifier or typedef name.\n    (Just `const' or `volatile' is not enough.)\n    A typedef'd name following these is taken as a name to be declared.\n    Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n-typed_declspecs:\n-\t  typespec reserved_declspecs\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods typespec reserved_declspecs\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+declspecs_nosc_nots_nosa_noea:\n+\t  TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n \t;\n \n-reserved_declspecs:  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs SCSPEC\n-\t\t{ if (extra_warnings)\n+declspecs_nosc_nots_nosa_ea:\n+\t  declspecs_nosc_nots_nosa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t;\n+\n+declspecs_nosc_nots_sa_noea:\n+\t  declspecs_nosc_nots_sa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n+\n+declspecs_nosc_nots_sa_ea:\n+\t  attributes\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 0; }\n+\t| declspecs_nosc_nots_sa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t;\n+\n+declspecs_nosc_ts_nosa_noea:\n+\t  typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_noea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_ea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_noea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_ea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n+\n+declspecs_nosc_ts_nosa_ea:\n+\t  typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_ts_nosa_noea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_ea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_noea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_ea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n+\n+declspecs_nosc_ts_sa_noea:\n+\t  declspecs_nosc_ts_sa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_sa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_sa_noea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_sa_ea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_noea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_ea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n+\n+declspecs_nosc_ts_sa_ea:\n+\t  declspecs_nosc_ts_sa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_ts_sa_noea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_sa_ea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_noea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_ea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n+\n+declspecs_sc_nots_nosa_noea:\n+\t  SCSPEC\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 0; }\n+\t| declspecs_sc_nots_nosa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_nosa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_nosa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_nots_nosa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_nots_nosa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_nots_nosa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n-typed_declspecs_no_prefix_attr:\n-\t  typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods_no_prefix_attr typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+declspecs_sc_nots_nosa_ea:\n+\t  declspecs_sc_nots_nosa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n-reserved_declspecs_no_prefix_attr:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs_no_prefix_attr typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs_no_prefix_attr SCSPEC\n-\t\t{ if (extra_warnings)\n+declspecs_sc_nots_sa_noea:\n+\t  declspecs_sc_nots_sa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_sa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_nots_sa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_nots_sa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_nots_sa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_nots_sa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n-/* List of just storage classes, type modifiers, and prefix attributes.\n-   A declaration can start with just this, but then it cannot be used\n-   to redeclare a typedef-name.\n-   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n-\n-declmods:\n-\t  declmods_no_prefix_attr\n-\t\t{ $$ = $1; }\n-\t| attributes\n-\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n-\t| declmods declmods_no_prefix_attr\n-\t\t{ $$ = chainon ($2, $1); }\n-\t| declmods attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n+declspecs_sc_nots_sa_ea:\n+\t  declspecs_sc_nots_sa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n-declmods_no_prefix_attr:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+declspecs_sc_ts_nosa_noea:\n+\t  declspecs_sc_ts_nosa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n \t\t  TREE_STATIC ($$) = 1; }\n-\t| SCSPEC\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| declmods_no_prefix_attr TYPE_QUAL\n+\t| declspecs_sc_ts_nosa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_nosa_noea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_nosa_ea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_nosa_noea typespec_nonattr\n \t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n \t\t  TREE_STATIC ($$) = 1; }\n-\t| declmods_no_prefix_attr SCSPEC\n+\t| declspecs_sc_nots_nosa_ea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_nosa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_ts_nosa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_nosa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_nosa_ea SCSPEC\n \t\t{ if (extra_warnings && TREE_STATIC ($1))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n \t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n+declspecs_sc_ts_nosa_ea:\n+\t  declspecs_sc_ts_nosa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_nosa_noea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_nosa_ea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_nosa_noea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_nosa_ea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t;\n \n-/* Used instead of declspecs where storage classes are not allowed\n-   (that is, for typenames and structure components).\n-   Don't accept a typedef-name if anything but a modifier precedes it.  */\n+declspecs_sc_ts_sa_noea:\n+\t  declspecs_sc_ts_sa_noea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_sa_ea TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_sa_noea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_sa_ea typespec_reserved_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_sa_noea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_sa_ea typespec_nonattr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_nosc_ts_sa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_nosc_ts_sa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_sa_noea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_sa_ea SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t;\n \n-typed_typespecs:\n-\t  typespec reserved_typespecquals\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| nonempty_type_quals typespec reserved_typespecquals\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+declspecs_sc_ts_sa_ea:\n+\t  declspecs_sc_ts_sa_noea attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t| declspecs_sc_ts_sa_noea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_ts_sa_ea typespec_reserved_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_sa_noea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declspecs_sc_nots_sa_ea typespec_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n \t;\n \n-reserved_typespecquals:  /* empty */\n+/* Particular useful classes of declspecs.  */\n+declspecs_ts:\n+\t  declspecs_nosc_ts_nosa_noea\n+\t| declspecs_nosc_ts_nosa_ea\n+\t| declspecs_nosc_ts_sa_noea\n+\t| declspecs_nosc_ts_sa_ea\n+\t| declspecs_sc_ts_nosa_noea\n+\t| declspecs_sc_ts_nosa_ea\n+\t| declspecs_sc_ts_sa_noea\n+\t| declspecs_sc_ts_sa_ea\n+\t;\n+\n+declspecs_nots:\n+\t  declspecs_nosc_nots_nosa_noea\n+\t| declspecs_nosc_nots_nosa_ea\n+\t| declspecs_nosc_nots_sa_noea\n+\t| declspecs_nosc_nots_sa_ea\n+\t| declspecs_sc_nots_nosa_noea\n+\t| declspecs_sc_nots_nosa_ea\n+\t| declspecs_sc_nots_sa_noea\n+\t| declspecs_sc_nots_sa_ea\n+\t;\n+\n+declspecs_ts_nosa:\n+\t  declspecs_nosc_ts_nosa_noea\n+\t| declspecs_nosc_ts_nosa_ea\n+\t| declspecs_sc_ts_nosa_noea\n+\t| declspecs_sc_ts_nosa_ea\n+\t;\n+\n+declspecs_nots_nosa:\n+\t  declspecs_nosc_nots_nosa_noea\n+\t| declspecs_nosc_nots_nosa_ea\n+\t| declspecs_sc_nots_nosa_noea\n+\t| declspecs_sc_nots_nosa_ea\n+\t;\n+\n+declspecs_nosc_ts:\n+\t  declspecs_nosc_ts_nosa_noea\n+\t| declspecs_nosc_ts_nosa_ea\n+\t| declspecs_nosc_ts_sa_noea\n+\t| declspecs_nosc_ts_sa_ea\n+\t;\n+\n+declspecs_nosc_nots:\n+\t  declspecs_nosc_nots_nosa_noea\n+\t| declspecs_nosc_nots_nosa_ea\n+\t| declspecs_nosc_nots_sa_noea\n+\t| declspecs_nosc_nots_sa_ea\n+\t;\n+\n+declspecs_nosc:\n+\t  declspecs_nosc_ts_nosa_noea\n+\t| declspecs_nosc_ts_nosa_ea\n+\t| declspecs_nosc_ts_sa_noea\n+\t| declspecs_nosc_ts_sa_ea\n+\t| declspecs_nosc_nots_nosa_noea\n+\t| declspecs_nosc_nots_nosa_ea\n+\t| declspecs_nosc_nots_sa_noea\n+\t| declspecs_nosc_nots_sa_ea\n+\t;\n+\n+declspecs:\n+\t  declspecs_nosc_nots_nosa_noea\n+\t| declspecs_nosc_nots_nosa_ea\n+\t| declspecs_nosc_nots_sa_noea\n+\t| declspecs_nosc_nots_sa_ea\n+\t| declspecs_nosc_ts_nosa_noea\n+\t| declspecs_nosc_ts_nosa_ea\n+\t| declspecs_nosc_ts_sa_noea\n+\t| declspecs_nosc_ts_sa_ea\n+\t| declspecs_sc_nots_nosa_noea\n+\t| declspecs_sc_nots_nosa_ea\n+\t| declspecs_sc_nots_sa_noea\n+\t| declspecs_sc_nots_sa_ea\n+\t| declspecs_sc_ts_nosa_noea\n+\t| declspecs_sc_ts_nosa_ea\n+\t| declspecs_sc_ts_sa_noea\n+\t| declspecs_sc_ts_sa_ea\n+\t;\n+\n+/* A (possibly empty) sequence of type qualifiers and attributes, to be\n+   followed by the effect of setattrs if any attributes were present.  */\n+maybe_type_quals_setattrs:\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| reserved_typespecquals typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t| declspecs_nosc_nots\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  /* ??? Yuck.  See maybe_setattrs.  */\n+\t\t  if (attrs != NULL_TREE)\n+\t\t    prefix_attributes = chainon (prefix_attributes, attrs);\n+\t\t  $$ = specs; }\n \t;\n \n-/* A typespec (but not a type qualifier).\n+/* A type specifier (but not a type qualifier).\n    Once we have seen one of these in a declaration,\n-   if a typedef name appears then it is being redeclared.  */\n+   if a typedef name appears then it is being redeclared.\n \n-typespec: TYPESPEC\n-\t| structsp\n-\t| TYPENAME\n+   The _reserved versions start with a reserved word and may appear anywhere\n+   in the declaration specifiers; the _nonreserved versions may only\n+   appear before any other type specifiers, and after that are (if names)\n+   being redeclared.\n+\n+   FIXME: should the _nonreserved version be restricted to names being\n+   redeclared only?  The other entries there relate only the GNU extensions\n+   and Objective C, and are historically parsed thus, and don't make sense\n+   after other type specifiers, but it might be cleaner to count them as\n+   _reserved.\n+\n+   _attr means: specifiers that either end with attributes,\n+   or are such that any following attributes would\n+   be parsed as part of the specifier.\n+\n+   _nonattr: specifiers.  */\n+\n+typespec_nonattr:\n+\t  typespec_reserved_nonattr\n+\t| typespec_nonreserved_nonattr\n+\t;\n+\n+typespec_attr:\n+\t  typespec_reserved_attr\n+\t;\n+\n+typespec_reserved_nonattr:\n+\t  TYPESPEC\n+\t| structsp_nonattr\n+\t;\n+\n+typespec_reserved_attr:\n+\t  structsp_attr\n+\t;\n+\n+typespec_nonreserved_nonattr:\n+\t  TYPENAME\n \t\t{ /* For a typedef name, record the meaning, not the name.\n \t\t     In case of `foo foo, bar;'.  */\n \t\t  $$ = lookup_name ($1); }\n@@ -1005,21 +1441,16 @@ end ifobjc\n \t\t{ $$ = groktypename ($3); }\n \t;\n \n-/* A typespec that is a reserved word, or a type qualifier.  */\n-\n-typespecqual_reserved: TYPESPEC\n-\t| TYPE_QUAL\n-\t| structsp\n-\t;\n+/* typespec_nonreserved_attr does not exist.  */\n \n initdecls:\n \tinitdcl\n-\t| initdecls ',' initdcl\n+\t| initdecls ',' maybe_setattrs initdcl\n \t;\n \n notype_initdecls:\n \tnotype_initdcl\n-\t| notype_initdecls ',' initdcl\n+\t| notype_initdecls ',' maybe_setattrs notype_initdcl\n \t;\n \n maybeasm:\n@@ -1257,8 +1688,8 @@ declarator:\n /* A declarator that is allowed only after an explicit typespec.  */\n \n after_type_declarator:\n-\t  '(' after_type_declarator ')'\n-\t\t{ $$ = $2; }\n+\t  '(' maybe_setattrs after_type_declarator ')'\n+\t\t{ $$ = $3; }\n \t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n /*\t| after_type_declarator '(' error ')'  %prec '.'\n@@ -1268,15 +1699,8 @@ after_type_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n \t| after_type_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals after_type_declarator  %prec UNARY\n+\t| '*' maybe_type_quals_setattrs after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs after_type_declarator\n-\t\t{ $$ = $3; }\n \t| TYPENAME\n ifobjc\n \t| OBJECTNAME\n@@ -1305,15 +1729,8 @@ end ifc\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n \t| parm_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals parm_declarator  %prec UNARY\n+\t| '*' maybe_type_quals_setattrs parm_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs parm_declarator\n-\t\t{ $$ = $3; }\n \t| TYPENAME\n \t;\n \n@@ -1326,9 +1743,9 @@ notype_declarator:\n /*\t| notype_declarator '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n-\t| '(' notype_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| '*' type_quals notype_declarator  %prec UNARY\n+\t| '(' maybe_setattrs notype_declarator ')'\n+\t\t{ $$ = $3; }\n+\t| '*' maybe_type_quals_setattrs notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n ifc\n \t| notype_declarator '[' '*' ']'  %prec '.'\n@@ -1341,13 +1758,6 @@ end ifc\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n \t| notype_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs notype_declarator\n-\t\t{ $$ = $3; }\n \t| IDENTIFIER\n \t;\n \n@@ -1372,7 +1782,13 @@ enum_head:\n \t\t{ $$ = $2; }\n \t;\n \n-structsp:\n+/* structsp_attr: struct/union/enum specifiers that either\n+   end with attributes, or are such that any following attributes would\n+   be parsed as part of the struct/union/enum specifier.\n+\n+   structsp_nonattr: other struct/union/enum specifiers.  */\n+\n+structsp_attr:\n \t  struct_head identifier '{'\n \t\t{ $$ = start_struct (RECORD_TYPE, $2);\n \t\t  /* Start scope of tag before parsing components.  */\n@@ -1383,8 +1799,6 @@ structsp:\n \t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n \t\t\t\t      $3, chainon ($1, $5));\n \t\t}\n-\t| struct_head identifier\n-\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n \t| union_head identifier '{'\n \t\t{ $$ = start_struct (UNION_TYPE, $2); }\n \t  component_decl_list '}' maybe_attribute\n@@ -1393,8 +1807,6 @@ structsp:\n \t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n \t\t\t\t      $3, chainon ($1, $5));\n \t\t}\n-\t| union_head identifier\n-\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n \t| enum_head identifier '{'\n \t\t{ $$ = start_enum ($2); }\n \t  enumlist maybecomma_warn '}' maybe_attribute\n@@ -1405,6 +1817,13 @@ structsp:\n \t  enumlist maybecomma_warn '}' maybe_attribute\n \t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4),\n \t\t\t\t    chainon ($1, $7)); }\n+\t;\n+\n+structsp_nonattr:\n+\t  struct_head identifier\n+\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n+\t| union_head identifier\n+\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n \t| enum_head identifier\n \t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2);\n \t\t  /* In ISO C, enumerated types can be referred to\n@@ -1458,22 +1877,13 @@ ifobjc\n end ifobjc\n \t;\n \n-/* There is a shift-reduce conflict here, because `components' may\n-   start with a `typename'.  It happens that shifting (the default resolution)\n-   does the right thing, because it treats the `typename' as part of\n-   a `typed_typespecs'.\n-\n-   It is possible that this same technique would allow the distinction\n-   between `notype_initdecls' and `initdecls' to be eliminated.\n-   But I am being cautious and not trying it.  */\n-\n component_decl:\n-\t  typed_typespecs setspecs components\n+\t  declspecs_nosc_ts setspecs components\n \t\t{ $$ = $3;\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_typespecs setspecs save_filename save_lineno maybe_attribute\n+\t| declspecs_nosc_ts setspecs save_filename save_lineno\n \t\t{\n \t\t  /* Support for unnamed structs or unions as members of \n \t\t     structs or unions (which is [a] useful and [b] supports \n@@ -1486,12 +1896,12 @@ component_decl:\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n \t\t}\n-    | nonempty_type_quals setspecs components\n+\t| declspecs_nosc_nots setspecs components_notype\n \t\t{ $$ = $3;\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| nonempty_type_quals\n+\t| declspecs_nosc_nots\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids member declarations with no members\");\n \t\t  shadow_tag($1);\n@@ -1505,8 +1915,14 @@ component_decl:\n \n components:\n \t  component_declarator\n-\t| components ',' component_declarator\n-\t\t{ $$ = chainon ($1, $3); }\n+\t| components ',' maybe_setattrs component_declarator\n+\t\t{ $$ = chainon ($1, $4); }\n+\t;\n+\n+components_notype:\n+\t  component_notype_declarator\n+\t| components_notype ',' maybe_setattrs component_notype_declarator\n+\t\t{ $$ = chainon ($1, $4); }\n \t;\n \n component_declarator:\n@@ -1522,6 +1938,19 @@ component_declarator:\n \t\t  decl_attributes ($$, $5, prefix_attributes); }\n \t;\n \n+component_notype_declarator:\n+\t  save_filename save_lineno notype_declarator maybe_attribute\n+\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n+\t\t  decl_attributes ($$, $4, prefix_attributes); }\n+\t| save_filename save_lineno\n+\t  notype_declarator ':' expr_no_commas maybe_attribute\n+\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n+\t\t  decl_attributes ($$, $6, prefix_attributes); }\n+\t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n+\t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n+\t\t  decl_attributes ($$, $5, prefix_attributes); }\n+\t;\n+\n /* We chain the enumerators in reverse order.\n    They are put in forward order where enumlist is used.\n    (The order used to be significant, but no longer is so.\n@@ -1547,12 +1976,16 @@ enumerator:\n \t;\n \n typename:\n-\t  typed_typespecs\n-\t\t{ pending_xref_error (); }\n+\t  declspecs_nosc\n+\t\t{ tree specs, attrs;\n+\t\t  pending_xref_error ();\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  /* We don't yet support attributes here.  */\n+\t\t  if (attrs != NULL_TREE)\n+\t\t    warning (\"attributes on type name ignored\");\n+\t\t  $<ttype>$ = specs; }\n \t  absdcl\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t| nonempty_type_quals absdcl\n-\t\t{ $$ = build_tree_list ($1, $2); }\n+\t\t{ $$ = build_tree_list ($<ttype>2, $3); }\n \t;\n \n absdcl:   /* an absolute declarator */\n@@ -1561,45 +1994,57 @@ absdcl:   /* an absolute declarator */\n \t| absdcl1\n \t;\n \n-nonempty_type_quals:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| nonempty_type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+absdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */\n+\t/* empty */\n+\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n+\t\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t\tbuild_tree_list (prefix_attributes,\n+\t\t\t\t\t\t\t NULL_TREE)); }\n+\t| absdcl1\n+\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n+\t\t\t\t\t\t\t $1),\n+\t\t\t\t\tbuild_tree_list (prefix_attributes,\n+\t\t\t\t\t\t\t NULL_TREE)); }\n+\t| absdcl1_noea attributes\n+\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n+\t\t\t\t\t\t\t $1),\n+\t\t\t\t\tbuild_tree_list (prefix_attributes,\n+\t\t\t\t\t\t\t $2)); }\n \t;\n \n-type_quals:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+absdcl1:  /* a nonempty absolute declarator */\n+\t  absdcl1_ea\n+\t| absdcl1_noea\n \t;\n \n-absdcl1:  /* a nonempty absolute declarator */\n-\t  '(' absdcl1 ')'\n-\t\t{ $$ = $2; }\n-\t  /* `(typedef)1' is `int'.  */\n-\t| '*' type_quals absdcl1  %prec UNARY\n+absdcl1_noea:\n+\t  direct_absdcl1\n+\t| '*' maybe_type_quals_setattrs absdcl1_noea\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' type_quals  %prec UNARY\n+\t;\n+\n+absdcl1_ea:\n+\t  '*' maybe_type_quals_setattrs\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| absdcl1 '(' parmlist  %prec '.'\n+\t| '*' maybe_type_quals_setattrs absdcl1_ea\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t;\n+\n+direct_absdcl1:\n+\t  '(' maybe_setattrs absdcl1 ')'\n+\t\t{ $$ = $3; }\n+\t| direct_absdcl1 '(' parmlist\n \t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-\t| absdcl1 '[' expr ']'  %prec '.'\n+\t| direct_absdcl1 '[' expr ']'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| absdcl1 '[' ']'  %prec '.'\n+\t| direct_absdcl1 '[' ']'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '(' parmlist  %prec '.'\n+\t| '(' parmlist\n \t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n-\t| '[' expr ']'  %prec '.'\n+\t| '[' expr ']'\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n-\t| '[' ']'  %prec '.'\n+\t| '[' ']'\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n-\t/* ??? It appears we have to support attributes here, however\n-\t   using prefix_attributes is wrong.  */\n-\t| attributes setattrs absdcl1\n-\t\t{ $$ = $3; }\n-\t;\n \n /* A nonempty series of declarations and statements (possibly followed by\n    some labels) that can form the body of a compound statement.\n@@ -2080,13 +2525,17 @@ asm_clobbers:\n \t;\n \f\n /* This is what appears inside the parens in a function declarator.\n-   Its value is a list of ..._TYPE nodes.  */\n+   Its value is a list of ..._TYPE nodes.  Attributes must appear here\n+   to avoid a conflict with their appearance after an open parenthesis\n+   in an abstract declarator, as in\n+   \"void bar (int (__attribute__((__mode__(SI))) int foo));\".  */\n parmlist:\n+\t  maybe_attribute\n \t\t{ pushlevel (0);\n \t\t  clear_parm_order ();\n \t\t  declare_parm_level (0); }\n \t  parmlist_1\n-\t\t{ $$ = $2;\n+\t\t{ $$ = $3;\n \t\t  parmlist_tags_warning ();\n \t\t  poplevel (0, 0, 0); }\n \t;\n@@ -2101,8 +2550,11 @@ parmlist_1:\n \t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n \t\t    TREE_ASM_WRITTEN (parm) = 1;\n \t\t  clear_parm_order (); }\n+\t  maybe_attribute\n+\t\t{ /* Dummy action so attributes are in known place\n+\t\t     on parser stack.  */ }\n \t  parmlist_1\n-\t\t{ $$ = $4; }\n+\t\t{ $$ = $6; }\n \t| error ')'\n \t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }\n \t;\n@@ -2128,7 +2580,7 @@ parmlist_2:  /* empty */\n \t;\n \n parms:\n-\tparm\n+\tfirstparm\n \t\t{ push_parm_decl ($1); }\n \t| parms ',' parm\n \t\t{ push_parm_decl ($3); }\n@@ -2137,47 +2589,86 @@ parms:\n /* A single parameter declaration or parameter type name,\n    as found in a parmlist.  */\n parm:\n-\t  typed_declspecs setspecs parm_declarator maybe_attribute\n+\t  declspecs_ts setspecs parm_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $4));\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs notype_declarator maybe_attribute\n+\t| declspecs_ts setspecs notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $4)); \n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs absdcl maybe_attribute\n+\t| declspecs_ts setspecs absdcl_maybe_attribute\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t| declspecs_nots setspecs notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $4));\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator maybe_attribute\n+\n+\t| declspecs_nots setspecs absdcl_maybe_attribute\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t;\n+\n+/* The first parm, which must suck attributes from off the top of the parser\n+   stack.  */\n+firstparm:\n+\t  declspecs_ts_nosa setspecs_fp parm_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $4));\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\n-\t| declmods setspecs absdcl maybe_attribute\n+\t| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute\n+\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n+\t\t\t\t\t\t\t $3),\n+\t\t\t\t\tbuild_tree_list (prefix_attributes,\n+\t\t\t\t\t\t\t $4)); \n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t| declspecs_nots_nosa setspecs_fp notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $4));\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\n+\t| declspecs_nots_nosa setspecs_fp absdcl_maybe_attribute\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t;\n+\n+setspecs_fp:\n+\t  setspecs\n+\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>-2); }\n \t;\n \n /* This is used in a function definition\n@@ -2459,12 +2950,12 @@ ivar_decls:\n    But I am being cautious and not trying it.  */\n \n ivar_decl:\n-\ttyped_typespecs setspecs ivars\n+\tdeclspecs_nosc_ts setspecs ivars\n \t        { $$ = $3;\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| nonempty_type_quals setspecs ivars\n+\t| declspecs_nosc_nots setspecs ivars\n \t\t{ $$ = $3;\n \t\t  current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n@@ -2477,7 +2968,7 @@ ivars:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| ivar_declarator\n-\t| ivars ',' ivar_declarator\n+\t| ivars ',' maybe_setattrs ivar_declarator\n \t;\n \n ivar_declarator:\n@@ -2652,13 +3143,13 @@ mydecls:\n \t;\n \n mydecl:\n-\ttyped_declspecs setspecs myparms ';'\n+\tdeclspecs_ts setspecs myparms ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs ';'\n+\t| declspecs_ts ';'\n \t\t{ shadow_tag ($1); }\n-\t| declmods ';'\n+\t| declspecs_nots ';'\n \t\t{ pedwarn (\"empty declaration\"); }\n \t;\n \n@@ -2683,11 +3174,8 @@ myparm:\n \t\t\t\t\t\t\t $1),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n \t\t\t\t\t\t\t $2)); }\n-\t| absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $1),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $2)); }\n+\t| absdcl_maybe_attribute\n+\t\t{ $$ = $1; }\n \t;\n \n optparmlist:"}, {"sha": "2bcd774917d5beda2f8db5c1a435bdc8cad8d2cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25d78ace728bb05ef85d359f7c2b123cb7581475", "patch": "@@ -1,3 +1,7 @@\n+2001-05-10  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.c-torture/compile/20010313-1.c: New test.\n+\n 2001-05-09  Zack Weinberg  <zackw@stanford.edu>\n \n \t* gcc.dg/cpp/direct2.c: New test."}, {"sha": "a5a6ee652175584456f33b11d37400e331bd8689", "filename": "gcc/testsuite/gcc.c-torture/compile/20010313-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010313-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25d78ace728bb05ef85d359f7c2b123cb7581475/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010313-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010313-1.c?ref=25d78ace728bb05ef85d359f7c2b123cb7581475", "patch": "@@ -0,0 +1,5 @@\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */\n+/* After the open parenthesis before the __attribute__, we used to shift\n+   the __attribute__ (expecting a parenthesised abstract declarator)\n+   instead of reducing to the start of a parameter list.  */\n+void bar (int (__attribute__((__mode__(__SI__))) int foo));"}]}