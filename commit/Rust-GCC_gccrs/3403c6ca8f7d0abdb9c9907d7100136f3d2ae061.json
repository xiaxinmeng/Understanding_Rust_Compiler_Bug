{"sha": "3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwM2M2Y2E4ZjdkMGFiZGI5Yzk5MDdkNzEwMDEzNmYzZDJhZTA2MQ==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@cygnus.com", "date": "1998-07-06T23:39:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-06T23:39:32Z"}, "message": "i386.c (ix86_epilogue): For pentium processors...\n\n        * i386.c (ix86_epilogue): For pentium processors, try to deallocate\n        4 or 8 byte stacks with pop instructions instead of an add instruction.\n\nFrom-SVN: r20979", "tree": {"sha": "eba0dcca0c1c2cc66414929c47f7e56794db0f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba0dcca0c1c2cc66414929c47f7e56794db0f55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061/comments", "author": null, "committer": null, "parents": [{"sha": "eb04ab5a1ad20cfd72b6e461d1be026ac418818e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb04ab5a1ad20cfd72b6e461d1be026ac418818e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb04ab5a1ad20cfd72b6e461d1be026ac418818e"}], "stats": {"total": 60, "additions": 54, "deletions": 6}, "files": [{"sha": "83eaeac326a21dbc7326b39d9a6839f8bb0b9300", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "patch": "@@ -1,3 +1,8 @@\n+Tue Jul  7 00:36:41 1998  Ulrich Drepper <drepper@cygnus.com>\n+\n+\t* i386.c (ix86_epilogue): For pentium processors, try to deallocate\n+\t4 or 8 byte stacks with pop instructions instead of an add instruction.\n+\n Tue Jul  7 00:30:08 1998  Klaus Kaempf <kkaempf@rmi.de>\n \n \t* alpha.c: Include tree.h before expr.h."}, {"sha": "42c4dbbe2bc77a16c29be7ee7b6a8feab9550aab", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "patch": "@@ -2353,14 +2353,57 @@ ix86_epilogue (do_rtl)\n \n   else if (tsize)\n     {\n-      /* If there is no frame pointer, we must still release the frame. */\n-      xops[0] = GEN_INT (tsize);\n+      /* Intel's docs say that for 4 or 8 bytes of stack frame one should\n+\t use `pop' and not `add'.  */\n+      int use_pop = tsize == 4;\n \n-      if (do_rtl)\n-\temit_insn (gen_rtx (SET, VOIDmode, xops[2],\n-\t\t\t    gen_rtx (PLUS, SImode, xops[2], xops[0])));\n+      /* Use two pops only for the Pentium processors.  */\n+      if (tsize == 8 && !TARGET_386 && !TARGET_486)\n+\t{\n+\t  rtx retval = current_function_return_rtx;\n+\n+\t  xops[1] = gen_rtx_REG (SImode, 1);\t/* %edx */\n+\n+\t  /* This case is a bit more complex.  Since we cannot pop into\n+\t     %ecx twice we need a second register.  But this is only\n+\t     available if the return value is not of DImode in which\n+\t     case the %edx register is not available.  */\n+\t  use_pop = (retval == NULL\n+\t\t     || ! reg_overlap_mentioned_p (xops[1], retval));\n+\t}\n+\n+      if (use_pop)\n+\t{\n+\t  xops[0] = gen_rtx_REG (SImode, 2);\t/* %ecx */\n+\n+\t  if (do_rtl)\n+\t    {\n+\t      /* We have to prevent the two pops here from being scheduled.\n+\t\t GCC otherwise would try in some situation to put other\n+\t\t instructions in between them which has a bad effect.  */\n+\t      emit_insn (gen_blockage ());\n+\t      emit_insn (gen_pop (xops[0]));\n+\t      if (tsize == 8)\n+\t\temit_insn (gen_pop (xops[1]));\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"pop%L0 %0\", xops);\n+\t      if (tsize == 8)\n+\t\toutput_asm_insn (\"pop%L1 %1\", xops);\n+\t    }\n+\t}\n       else\n-\toutput_asm_insn (AS2 (add%L2,%0,%2), xops);\n+\t{\n+\t  /* If there is no frame pointer, we must still release the frame. */\n+\t  xops[0] = GEN_INT (tsize);\n+\n+\t  if (do_rtl)\n+\t    emit_insn (gen_rtx (SET, VOIDmode, xops[2],\n+\t\t\t\tgen_rtx (PLUS, SImode, xops[2], xops[0])));\n+\t  else\n+\t    output_asm_insn (AS2 (add%L2,%0,%2), xops);\n+\t}\n     }\n \n #ifdef FUNCTION_BLOCK_PROFILER_EXIT"}]}