{"sha": "1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM5NmZhNWI5MWNmYTBiMzcwOGVjOWRmMzNjMGJiODQzODYwODFkNg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-05T11:45:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-06-10T13:09:37Z"}, "message": "Merge evrp uses of substitute_and_fold_engine into the engine itself.\n\nThis patch merges the evrp uses of the substitute and fold engine into\nthe engine itself, at least the parts that can be re-used by other\nengine uses.  It also adds a context parameter to get_value() for\nfurther use.\n\ngcc/\n\t* gimple-loop-versioning.cc (loop_versioning::name_prop::get_value):\n\tAdd stmt parameter.\n\t* gimple-ssa-evrp.c (class evrp_folder): New.\n\t(class evrp_dom_walker): Remove.\n\t(execute_early_vrp): Use evrp_folder instead of evrp_dom_walker.\n\t* tree-ssa-ccp.c (ccp_folder::get_value): Add stmt parameter.\n\t* tree-ssa-copy.c (copy_folder::get_value): Same.\n\t* tree-ssa-propagate.c (substitute_and_fold_engine::replace_uses_in):\n\tPass stmt to get_value.\n\t(substitute_and_fold_engine::replace_phi_args_in): Same.\n\t(substitute_and_fold_dom_walker::after_dom_children): Call\n\tpost_fold_bb.\n\t(substitute_and_fold_dom_walker::foreach_new_stmt_in_bb): New.\n\t(substitute_and_fold_dom_walker::propagate_into_phi_args): New.\n\t(substitute_and_fold_dom_walker::before_dom_children): Adjust to\n\tcall virtual functions for folding, pre_folding, and post folding.\n\tCall get_value with PHI.  Tweak dump.\n\t* tree-ssa-propagate.h (class substitute_and_fold_engine):\n\tNew argument to get_value.\n\tNew virtual function pre_fold_bb.\n\tNew virtual function post_fold_bb.\n\tNew virtual function pre_fold_stmt.\n\tNew virtual function post_new_stmt.\n\tNew function propagate_into_phi_args.\n\t* tree-vrp.c (vrp_folder::get_value): Add stmt argument.\n\t* vr-values.c (vr_values::extract_range_from_stmt): Adjust dump\n\toutput.\n\t(vr_values::fold_cond): New.\n\t(vr_values::simplify_cond_using_ranges_1): Call fold_cond.\n\t* vr-values.h (class vr_values): Add\n\tsimplify_cond_using_ranges_when_edge_is_known.\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/ssa-dse-30.c: Adjust test for folding of\n\tmemmove happening later.", "tree": {"sha": "d5eb6c1149ef54835dcc6b0d2d7be8fa28de1d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5eb6c1149ef54835dcc6b0d2d7be8fa28de1d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b6731e674c76cb48a417f2eef74ced92a17f469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6731e674c76cb48a417f2eef74ced92a17f469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b6731e674c76cb48a417f2eef74ced92a17f469"}], "stats": {"total": 523, "additions": 220, "deletions": 303}, "files": [{"sha": "002b2a68b96a2b9aa6fbcb54d682c1385a92d5fb", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -277,7 +277,7 @@ class loop_versioning\n   {\n   public:\n     name_prop (loop_info &li) : m_li (li) {}\n-    tree get_value (tree) FINAL OVERRIDE;\n+    tree get_value (tree, gimple *) FINAL OVERRIDE;\n \n   private:\n     /* Information about the versioning we've performed on the loop.  */\n@@ -534,7 +534,8 @@ loop_versioning::lv_dom_walker::after_dom_children (basic_block bb)\n    Return the new value if so, otherwise return null.  */\n \n tree\n-loop_versioning::name_prop::get_value (tree val)\n+loop_versioning::name_prop::get_value (tree val,\n+\t\t\t\t       gimple *stmt ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (val) == SSA_NAME\n       && bitmap_bit_p (&m_li.unity_names, SSA_NAME_VERSION (val)))"}, {"sha": "af780fd0519d37eb1371098bcef983fee40da1d9", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 63, "deletions": 271, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -43,293 +43,86 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa-evrp-analyze.h\"\n \n class evrp_folder : public substitute_and_fold_engine\n-{\n- public:\n-  tree get_value (tree) FINAL OVERRIDE;\n-  evrp_folder (class vr_values *vr_values_) : vr_values (vr_values_) { }\n-  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n-    { return vr_values->simplify_stmt_using_ranges (gsi); }\n-  class vr_values *vr_values;\n-\n- private:\n-  DISABLE_COPY_AND_ASSIGN (evrp_folder);\n-};\n-\n-tree\n-evrp_folder::get_value (tree op)\n-{\n-  return vr_values->op_with_constant_singleton_value_range (op);\n-}\n-\n-/* evrp_dom_walker visits the basic blocks in the dominance order and set\n-   the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n-   discover more VRs.  */\n-\n-class evrp_dom_walker : public dom_walker\n {\n public:\n-  evrp_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS),\n-      evrp_range_analyzer (true),\n-      evrp_folder (evrp_range_analyzer.get_vr_values ())\n-    {\n-      need_eh_cleanup = BITMAP_ALLOC (NULL);\n-    }\n-  ~evrp_dom_walker ()\n-    {\n-      BITMAP_FREE (need_eh_cleanup);\n-    }\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-  void cleanup (void);\n-\n- private:\n-  DISABLE_COPY_AND_ASSIGN (evrp_dom_walker);\n-  bitmap need_eh_cleanup;\n-  auto_vec<gimple *> stmts_to_fixup;\n-  auto_vec<gimple *> stmts_to_remove;\n-\n-  class evrp_range_analyzer evrp_range_analyzer;\n-  class evrp_folder evrp_folder;\n+  evrp_folder () : m_range_analyzer (/*update_global_ranges=*/true),\n+    m_vr_values (m_range_analyzer.get_vr_values ())\n+  {\n+  }\n+\n+  ~evrp_folder ()\n+  {\n+    m_vr_values->cleanup_edges_and_switches ();\n+\n+    if (dump_file)\n+      {\n+\tfprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n+\tm_range_analyzer.dump_all_value_ranges (dump_file);\n+\tfprintf (dump_file, \"\\n\");\n+      }\n+  }\n+\n+  tree get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED) OVERRIDE\n+  {\n+    return m_vr_values->op_with_constant_singleton_value_range (op);\n+  }\n+\n+  void pre_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+      fprintf (dump_file, \"evrp visiting BB%d\\n\", bb->index);\n+    m_range_analyzer.enter (bb);\n+  }\n+\n+  void pre_fold_stmt (gimple *stmt) OVERRIDE\n+  {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+      {\n+\tfprintf (dump_file, \"evrp visiting stmt \");\n+\tprint_gimple_stmt (dump_file, stmt, 0);\n+      }\n+    m_range_analyzer.record_ranges_from_stmt (stmt, false);\n+  }\n+\n+  bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n+  {\n+    return m_vr_values->simplify_stmt_using_ranges (gsi);\n+  }\n+\n+  void post_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    m_range_analyzer.leave (bb);\n+  }\n+\n+  void post_new_stmt (gimple *stmt) OVERRIDE\n+  {\n+    m_vr_values->set_defs_to_varying (stmt);\n+  }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (evrp_folder);\n+  class evrp_range_analyzer m_range_analyzer;\n+  class vr_values *m_vr_values;\n };\n \n-edge\n-evrp_dom_walker::before_dom_children (basic_block bb)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n-\n-  evrp_range_analyzer.enter (bb);\n-\n-  for (gphi_iterator gpi = gsi_start_phis (bb);\n-       !gsi_end_p (gpi); gsi_next (&gpi))\n-    {\n-      gphi *phi = gpi.phi ();\n-      tree lhs = PHI_RESULT (phi);\n-      if (virtual_operand_p (lhs))\n-\tcontinue;\n-\n-      const value_range_equiv *vr = evrp_range_analyzer.get_value_range (lhs);\n-      /* Mark PHIs whose lhs we fully propagate for removal.  */\n-      tree val;\n-      if (vr->singleton_p (&val) && may_propagate_copy (lhs, val))\n-\t{\n-\t  stmts_to_remove.safe_push (phi);\n-\t  continue;\n-\t}\n-    }\n-\n-  edge taken_edge = NULL;\n-\n-  /* Visit all other stmts and discover any new VRs possible.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n-       !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      tree output = NULL_TREE;\n-      gimple *old_stmt = stmt;\n-      bool was_noreturn = (is_gimple_call (stmt)\n-\t\t\t   && gimple_call_noreturn_p (stmt));\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Visiting stmt \");\n-\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t}\n-\n-      evrp_range_analyzer.record_ranges_from_stmt (stmt, false);\n-\n-      if (gcond *cond = dyn_cast <gcond *> (stmt))\n-\t{\n-\t  evrp_range_analyzer.vrp_visit_cond_stmt (cond, &taken_edge);\n-\t  if (taken_edge)\n-\t    {\n-\t      if (taken_edge->flags & EDGE_TRUE_VALUE)\n-\t\tgimple_cond_make_true (cond);\n-\t      else if (taken_edge->flags & EDGE_FALSE_VALUE)\n-\t\tgimple_cond_make_false (cond);\n-\t      else\n-\t\tgcc_unreachable ();\n-\t      update_stmt (stmt);\n-\t    }\n-\t}\n-      else if (stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  output = get_output_for_vrp (stmt);\n-\t  if (output)\n-\t    {\n-\t      const value_range_equiv *vr\n-\t\t= evrp_range_analyzer.get_value_range (output);\n-\n-\t      /* Mark stmts whose output we fully propagate for removal.  */\n-\t      tree val;\n-\t      if (vr->singleton_p (&val)\n-\t\t  && may_propagate_copy (output, val)\n-\t\t  && !stmt_could_throw_p (cfun, stmt)\n-\t\t  && !gimple_has_side_effects (stmt))\n-\t\t{\n-\t\t  stmts_to_remove.safe_push (stmt);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Try folding stmts with the VR discovered.  */\n-      bool did_replace = evrp_folder.replace_uses_in (stmt);\n-      gimple_stmt_iterator prev_gsi = gsi;\n-      gsi_prev (&prev_gsi);\n-      if (fold_stmt (&gsi, follow_single_use_edges)\n-\t  || did_replace)\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  update_stmt (stmt);\n-\t  did_replace = true;\n-\t}\n-      if (evrp_folder.simplify_stmt_using_ranges (&gsi))\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  update_stmt (stmt);\n-\t  did_replace = true;\n-\t}\n-\n-      if (did_replace)\n-\t{\n-\t  /* If we wound up generating new stmts during folding\n-\t     drop all their defs to VARYING.  We can't easily\n-\t     process them because we've already instantiated\n-\t     ranges on uses on STMT that only hold after it.  */\n-\t  if (gsi_end_p (prev_gsi))\n-\t    prev_gsi = gsi_start_bb (bb);\n-\t  else\n-\t    gsi_next (&prev_gsi);\n-\t  while (gsi_stmt (prev_gsi) != gsi_stmt (gsi))\n-\t    {\n-\t      evrp_range_analyzer.get_vr_values ()\n-\t\t->set_defs_to_varying (gsi_stmt (prev_gsi));\n-\t      gsi_next (&prev_gsi);\n-\t    }\n-\n-\t  /* If we cleaned up EH information from the statement,\n-\t     remove EH edges.  */\n-\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n-\t    bitmap_set_bit (need_eh_cleanup, bb->index);\n-\n-\t  /* If we turned a not noreturn call into a noreturn one\n-\t     schedule it for fixup.  */\n-\t  if (!was_noreturn\n-\t      && is_gimple_call (stmt)\n-\t      && gimple_call_noreturn_p (stmt))\n-\t    stmts_to_fixup.safe_push (stmt);\n-\n-\t  if (gimple_assign_single_p (stmt))\n-\t    {\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t\trecompute_tree_invariant_for_addr_expr (rhs);\n-\t    }\n-\t}\n-    }\n-\n-  /* Visit BB successor PHI nodes and replace PHI args.  */\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      for (gphi_iterator gpi = gsi_start_phis (e->dest);\n-\t   !gsi_end_p (gpi); gsi_next (&gpi))\n-\t{\n-\t  gphi *phi = gpi.phi ();\n-\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  tree arg = USE_FROM_PTR (use_p);\n-\t  if (TREE_CODE (arg) != SSA_NAME\n-\t      || virtual_operand_p (arg))\n-\t    continue;\n-\t  const value_range_equiv\n-\t    *vr = evrp_range_analyzer.get_value_range (arg);\n-\t  tree val;\n-\t  if (vr->singleton_p (&val) && may_propagate_copy (arg, val))\n-\t    propagate_value (use_p, val);\n-\t}\n-    }\n- \n-  return taken_edge;\n-}\n-\n-void\n-evrp_dom_walker::after_dom_children (basic_block bb)\n-{\n-  evrp_range_analyzer.leave (bb);\n-}\n-\n-/* Perform any cleanups after the main phase of EVRP has completed.  */\n-\n-void\n-evrp_dom_walker::cleanup (void)\n-{\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-      evrp_range_analyzer.dump_all_value_ranges (dump_file);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* Remove stmts in reverse order to make debug stmt creation possible.  */\n-  while (! stmts_to_remove.is_empty ())\n-    {\n-      gimple *stmt = stmts_to_remove.pop ();\n-      if (dump_file && dump_flags & TDF_DETAILS)\n-\t{\n-\t  fprintf (dump_file, \"Removing dead stmt \");\n-\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tremove_phi_node (&gsi, true);\n-      else\n-\t{\n-\t  unlink_stmt_vdef (stmt);\n-\t  gsi_remove (&gsi, true);\n-\t  release_defs (stmt);\n-\t}\n-    }\n-\n-  if (!bitmap_empty_p (need_eh_cleanup))\n-    gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n-\n-  /* Fixup stmts that became noreturn calls.  This may require splitting\n-     blocks and thus isn't possible during the dominator walk.  Do this\n-     in reverse order so we don't inadvertedly remove a stmt we want to\n-     fixup by visiting a dominating now noreturn call first.  */\n-  while (!stmts_to_fixup.is_empty ())\n-    {\n-      gimple *stmt = stmts_to_fixup.pop ();\n-      fixup_noreturn_call (stmt);\n-    }\n-\n-  evrp_folder.vr_values->cleanup_edges_and_switches ();\n-}\n-\n /* Main entry point for the early vrp pass which is a simplified non-iterative\n    version of vrp where basic blocks are visited in dominance order.  Value\n    ranges discovered in early vrp will also be used by ipa-vrp.  */\n \n static unsigned int\n execute_early_vrp ()\n {\n-  /* Ideally this setup code would move into the ctor for the dominator\n-     walk.  However, this setup can change the number of blocks which\n+  /* Ideally this setup code would move into the ctor for the folder\n+     However, this setup can change the number of blocks which\n      invalidates the internal arrays that are set up by the dominator\n-     walker.  */\n+     walker in substitute_and_fold_engine.  */\n   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   scev_initialize ();\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Walk stmts in dominance order and propagate VRP.  */\n-  evrp_dom_walker walker;\n-  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  walker.cleanup ();\n+  evrp_folder folder;\n+  folder.substitute_and_fold ();\n \n   scev_finalize ();\n   loop_optimizer_finalize ();\n@@ -375,4 +168,3 @@ make_pass_early_vrp (gcc::context *ctxt)\n {\n   return new pass_early_vrp (ctxt);\n }\n-"}, {"sha": "9f56b392cdd9d2abed37b4e0514b41ad7bef94de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-30.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-30.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -8,9 +8,8 @@ void test_bcopy (const void *s)\n {\n   char d[33];\n \n-  /* Bcopy is transformed into memmove and those calls are expanded\n-     inline in EVRP, before DSE runs, so this test doesn't actually\n-     verify that DSE does its job.  */\n+  /* Bcopy is transformed into memmove before DSE runs, so this test\n+     doesn't actually verify that DSE does its job.  */\n   __builtin_bcopy (s, d, sizeof d);\n   __builtin_bcopy (s, d, sizeof d);\n \n@@ -28,4 +27,17 @@ void test_bzero (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"builtin_memset\" 1 \"dse1\" } } */\n-/* { dg-final { scan-tree-dump-not \"builtin_(bcopy|bzero|memcpy|memmove)\" \"dse1\" } } */\n+\n+/* Merging the evrp folder into substitute_and_fold_engine shuffled\n+   the order of gimple_fold a bit, so evrp is no longer folding the\n+   memmove inline.  This folding is instead done by forwprop.  Thus, I\n+   have remmoved the |memmove in the test below as this is not done\n+   until after dse.\n+\n+   What happened was that the propagator engine only called gimple\n+   fold if replace_uses_in() was successful.  On the other hand, EVRP\n+   called gimple fold regardless.\n+\n+   If we really care about previous behavior, we could put a call to\n+   gimple ::fold_stmt into evrp_folder::fold_stmt().  */\n+/* { dg-final { scan-tree-dump-not \"builtin_(bcopy|bzero|memcpy)\" \"dse1\" } } */"}, {"sha": "f7a27952ce4feeabcfe2cce3cc92ac280ed4ae79", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -943,7 +943,7 @@ do_dbg_cnt (void)\n class ccp_folder : public substitute_and_fold_engine\n {\n  public:\n-  tree get_value (tree) FINAL OVERRIDE;\n+  tree get_value (tree, gimple *) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n };\n \n@@ -952,7 +952,7 @@ class ccp_folder : public substitute_and_fold_engine\n    of calling member functions.  */\n \n tree\n-ccp_folder::get_value (tree op)\n+ccp_folder::get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED)\n {\n   return get_constant_value (op);\n }"}, {"sha": "9bcb708379e146e6322088f4b1a9dff4b297507b", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -492,13 +492,13 @@ init_copy_prop (void)\n class copy_folder : public substitute_and_fold_engine\n {\n  public:\n-  tree get_value (tree) FINAL OVERRIDE;\n+  tree get_value (tree, gimple *) FINAL OVERRIDE;\n };\n \n /* Callback for substitute_and_fold to get at the final copy-of values.  */\n \n tree\n-copy_folder::get_value (tree name)\n+copy_folder::get_value (tree name, gimple *stmt ATTRIBUTE_UNUSED)\n {\n   tree val;\n   if (SSA_NAME_VERSION (name) >= n_copy_of)"}, {"sha": "4fda296ef9e4ee6a7447dd4a097efaceba698d8c", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 95, "deletions": 18, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -868,7 +868,7 @@ substitute_and_fold_engine::replace_uses_in (gimple *stmt)\n   FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree tuse = USE_FROM_PTR (use);\n-      tree val = get_value (tuse);\n+      tree val = get_value (tuse, stmt);\n \n       if (val == tuse || val == NULL_TREE)\n \tcontinue;\n@@ -903,19 +903,13 @@ substitute_and_fold_engine::replace_phi_args_in (gphi *phi)\n   size_t i;\n   bool replaced = false;\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Folding PHI node: \");\n-      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n-    }\n-\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       tree arg = gimple_phi_arg_def (phi, i);\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  tree val = get_value (arg);\n+\t  tree val = get_value (arg, phi);\n \n \t  if (val && val != arg && may_propagate_copy (arg, val))\n \t    {\n@@ -983,19 +977,75 @@ class substitute_and_fold_dom_walker : public dom_walker\n     }\n \n     virtual edge before_dom_children (basic_block);\n-    virtual void after_dom_children (basic_block) {}\n+    virtual void after_dom_children (basic_block bb)\n+    {\n+      substitute_and_fold_engine->post_fold_bb (bb);\n+    }\n \n     bool something_changed;\n     vec<gimple *> stmts_to_remove;\n     vec<gimple *> stmts_to_fixup;\n     bitmap need_eh_cleanup;\n \n     class substitute_and_fold_engine *substitute_and_fold_engine;\n+\n+private:\n+    void foreach_new_stmt_in_bb (gimple_stmt_iterator old_gsi,\n+\t\t\t\t gimple_stmt_iterator new_gsi);\n };\n \n+/* Call post_new_stmt for each each new statement that has been added\n+   to the current BB.  OLD_GSI is the statement iterator before the BB\n+   changes ocurred.  NEW_GSI is the iterator which may contain new\n+   statements.  */\n+\n+void\n+substitute_and_fold_dom_walker::foreach_new_stmt_in_bb\n+\t\t\t\t(gimple_stmt_iterator old_gsi,\n+\t\t\t\t gimple_stmt_iterator new_gsi)\n+{\n+  basic_block bb = gsi_bb (new_gsi);\n+  if (gsi_end_p (old_gsi))\n+    old_gsi = gsi_start_bb (bb);\n+  else\n+    gsi_next (&old_gsi);\n+  while (gsi_stmt (old_gsi) != gsi_stmt (new_gsi))\n+    {\n+      gimple *stmt = gsi_stmt (old_gsi);\n+      substitute_and_fold_engine->post_new_stmt (stmt);\n+      gsi_next (&old_gsi);\n+    }\n+}\n+\n+void\n+substitute_and_fold_engine::propagate_into_phi_args (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  /* Visit BB successor PHI nodes and replace PHI args.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      for (gphi_iterator gpi = gsi_start_phis (e->dest);\n+\t   !gsi_end_p (gpi); gsi_next (&gpi))\n+\t{\n+\t  gphi *phi = gpi.phi ();\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  tree arg = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (arg) != SSA_NAME\n+\t      || virtual_operand_p (arg))\n+\t    continue;\n+\t  tree val = get_value (arg, phi);\n+\t  if (val && may_propagate_copy (arg, val))\n+\t    propagate_value (use_p, val);\n+\t}\n+    }\n+}\n+\n edge\n substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n {\n+  substitute_and_fold_engine->pre_fold_bb (bb);\n+\n   /* Propagate known values into PHI nodes.  */\n   for (gphi_iterator i = gsi_start_phis (bb);\n        !gsi_end_p (i);\n@@ -1005,13 +1055,24 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       tree res = gimple_phi_result (phi);\n       if (virtual_operand_p (res))\n \tcontinue;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Folding PHI node: \");\n+\t  print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n+\t}\n       if (res && TREE_CODE (res) == SSA_NAME)\n \t{\n-\t  tree sprime = substitute_and_fold_engine->get_value (res);\n+\t  tree sprime = substitute_and_fold_engine->get_value (res, phi);\n \t  if (sprime\n \t      && sprime != res\n \t      && may_propagate_copy (res, sprime))\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Queued PHI for removal.  Folds to: \");\n+\t\t  print_generic_expr (dump_file, sprime);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n \t      stmts_to_remove.safe_push (phi);\n \t      continue;\n \t    }\n@@ -1028,12 +1089,20 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       bool did_replace;\n       gimple *stmt = gsi_stmt (i);\n \n+      substitute_and_fold_engine->pre_fold_stmt (stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Folding statement: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+\n       /* No point propagating into a stmt we have a value for we\n          can propagate into all uses.  Mark it for removal instead.  */\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t{\n-\t  tree sprime = substitute_and_fold_engine->get_value (lhs);\n+\t  tree sprime = substitute_and_fold_engine->get_value (lhs, stmt);\n \t  if (sprime\n \t      && sprime != lhs\n \t      && may_propagate_copy (lhs, sprime)\n@@ -1043,6 +1112,12 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t      && (!is_gimple_assign (stmt)\n \t\t  || gimple_assign_rhs_code (stmt) != ASSERT_EXPR))\n \t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Queued stmt for removal.  Folds to: \");\n+\t\t  print_generic_expr (dump_file, sprime);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n \t      stmts_to_remove.safe_push (stmt);\n \t      continue;\n \t    }\n@@ -1051,19 +1126,16 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       /* Replace the statement with its folded version and mark it\n \t folded.  */\n       did_replace = false;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Folding statement: \");\n-\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t}\n-\n       gimple *old_stmt = stmt;\n       bool was_noreturn = (is_gimple_call (stmt)\n \t\t\t   && gimple_call_noreturn_p (stmt));\n \n       /* Replace real uses in the statement.  */\n       did_replace |= substitute_and_fold_engine->replace_uses_in (stmt);\n \n+      gimple_stmt_iterator prev_gsi = i;\n+      gsi_prev (&prev_gsi);\n+\n       /* If we made a replacement, fold the statement.  */\n       if (did_replace)\n \t{\n@@ -1084,7 +1156,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t specific information.  Do this before propagating\n \t into the stmt to not disturb pass specific information.  */\n       update_stmt_if_modified (stmt);\n-      if (substitute_and_fold_engine->fold_stmt(&i))\n+      if (substitute_and_fold_engine->fold_stmt (&i))\n \t{\n \t  did_replace = true;\n \t  prop_stats.num_stmts_folded++;\n@@ -1115,6 +1187,8 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       /* Now cleanup.  */\n       if (did_replace)\n \t{\n+\t  foreach_new_stmt_in_bb (prev_gsi, i);\n+\n \t  /* If we cleaned up EH information from the statement,\n \t     remove EH edges.  */\n \t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n@@ -1153,6 +1227,9 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t    fprintf (dump_file, \"Not folded\\n\");\n \t}\n     }\n+\n+  substitute_and_fold_engine->propagate_into_phi_args (bb);\n+\n   return NULL;\n }\n "}, {"sha": "24de43ebc6c6b074a34d095f8dc68cd02cac214f", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -104,12 +104,19 @@ class substitute_and_fold_engine\n     : fold_all_stmts (fold_all_stmts) { }\n   virtual ~substitute_and_fold_engine (void) { }\n   virtual bool fold_stmt (gimple_stmt_iterator *) { return false; }\n-  virtual tree get_value (tree) { return NULL_TREE; }\n+  virtual tree get_value (tree, gimple *) { return NULL_TREE; }\n \n   bool substitute_and_fold (basic_block = NULL);\n   bool replace_uses_in (gimple *);\n   bool replace_phi_args_in (gphi *);\n \n+  virtual void pre_fold_bb (basic_block) { }\n+  virtual void post_fold_bb (basic_block) { }\n+  virtual void pre_fold_stmt (gimple *) { }\n+  virtual void post_new_stmt (gimple *) { }\n+\n+  void propagate_into_phi_args (basic_block);\n+\n   /* Users like VRP can set this when they want to perform\n      folding for every propagation.  */\n   bool fold_all_stmts;"}, {"sha": "c39a6f5e3748f8cbcf3af511734bbcf5359cfe53", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -3940,7 +3940,7 @@ class vrp_folder : public substitute_and_fold_engine\n {\n public:\n   vrp_folder () : substitute_and_fold_engine (/* Fold all stmts.  */ true) {  }\n-  tree get_value (tree) FINAL OVERRIDE;\n+  tree get_value (tree, gimple *stmt) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n \n   class vr_values *vr_values;\n@@ -4037,7 +4037,7 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n    Implemented as a pure wrapper right now, but this will change.  */\n \n tree\n-vrp_folder::get_value (tree op)\n+vrp_folder::get_value (tree op, gimple *stmt ATTRIBUTE_UNUSED)\n {\n   return op_with_constant_singleton_value_range (op);\n }"}, {"sha": "e95df78870aba4b528039e96679ca1976b3558d2", "filename": "gcc/vr-values.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -2799,7 +2799,7 @@ vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n+      fprintf (dump_file, \"\\nextract_range_from_stmt visiting:\\n\");\n       print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n     }\n \n@@ -3550,6 +3550,30 @@ range_fits_type_p (const value_range_equiv *vr,\n   return true;\n }\n \n+/* If COND can be folded entirely as TRUE or FALSE, rewrite the\n+   conditional as such, and return TRUE.  */\n+\n+bool\n+vr_values::fold_cond (gcond *cond)\n+{\n+  /* ?? vrp_folder::fold_predicate_in() is a superset of this.  At\n+     some point we should merge all variants of this code.  */\n+  edge taken_edge;\n+  vrp_visit_cond_stmt (cond, &taken_edge);\n+  if (taken_edge)\n+    {\n+      if (taken_edge->flags & EDGE_TRUE_VALUE)\n+       gimple_cond_make_true (cond);\n+      else if (taken_edge->flags & EDGE_FALSE_VALUE)\n+       gimple_cond_make_false (cond);\n+      else\n+       gcc_unreachable ();\n+      update_stmt (cond);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Simplify a conditional using a relational operator to an equality\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n@@ -3561,6 +3585,9 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n   tree op1 = gimple_cond_rhs (stmt);\n   enum tree_code cond_code = gimple_cond_code (stmt);\n \n+  if (fold_cond (stmt))\n+    return true;\n+\n   if (cond_code != NE_EXPR\n       && cond_code != EQ_EXPR\n       && TREE_CODE (op0) == SSA_NAME"}, {"sha": "ac25139762af8828218a5821b1fa502c604f6b46", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1396fa5b91cfa0b3708ec9df33c0bb84386081d6/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "patch": "@@ -112,6 +112,7 @@ class vr_values\n   bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_cond_using_ranges_1 (gcond *);\n+  bool fold_cond (gcond *);\n   bool simplify_switch_using_ranges (gswitch *);\n   bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n \t\t\t\t\t       gimple *);"}]}