{"sha": "9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "node_id": "C_kwDOANBUbNoAKDlmYjA2ZDY2Y2VmNzA1ODRlN2FhMmZhM2E2YWQyMmVmN2RlZjZiODQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-17T17:02:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-17T17:02:43Z"}, "message": "Merge #938\n\n938: First pass at declarative macro expansion  r=philberty a=philberty\n\nThis does not support repetition matchers but it supports simple\r\ndeclarative macros and transcribes them. The approach taken here is that\r\nwe reuse our existing parser to call the apropriate functions as specified\r\nas part of the MacroFragmentType enum if the parser does not have errors\r\nparsing that item then it must be a match.\r\n    \r\nThen once we match a rule we have a map of the token begin/end offsets\r\nfor each fragment match, this is then used to adjust and create a new token\r\nstream for the macro rule definition so that when we feed it to the parser\r\nthe tokens are already substituted. The resulting expression or item is\r\nthen attached to the respective macro invocation and this is then name\r\nresolved and used for hir lowering.\r\n    \r\nFixes #17 #22\r\nAddresses #573\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "d8ed1ea0d957afd906556ae89e8622f79c4690f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ed1ea0d957afd906556ae89e8622f79c4690f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiDn+zCRBK7hj4Ov3rIwAARmoIAGExvo73pXUcSlzy44a2oqOp\nX3gxcsahTmfZTJPCGJB6Rv/TXouAOSmR0x7Z4p4U6H90T971Ky0LLrdbtpIdwjPL\nx/2XE8ow84rRuC+G1wRb+dAqUaiTugv2UuMvu5ZZASv3h4AeVESEAw8xB3+fpXTn\nc8S9xbdiEHwu3Ep4QnQREjuxOhZBBM0rTmmVINVnKdE9mx4UrzpCm8BqR9/V4z5R\n1I3Acuadv51GEE6sPFUIGO7nN0pQdxgMZTvuDQXERCP74Nb2ht4m6vUBr0YOX9em\n6L2+6o+LLGQA/9FblEIUhpV30QwHsgQPkpDy6swAUiGuof1HtocYURaCf0xs1Vc=\n=2r05\n-----END PGP SIGNATURE-----\n", "payload": "tree d8ed1ea0d957afd906556ae89e8622f79c4690f1\nparent 752bf6c80a922e09edf5bcb53e15e08e83057a7f\nparent 37415eec77438bba2fc61df3e9a396c1e2cbaca8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645117363 +0000\ncommitter GitHub <noreply@github.com> 1645117363 +0000\n\nMerge #938\n\n938: First pass at declarative macro expansion  r=philberty a=philberty\n\nThis does not support repetition matchers but it supports simple\r\ndeclarative macros and transcribes them. The approach taken here is that\r\nwe reuse our existing parser to call the apropriate functions as specified\r\nas part of the MacroFragmentType enum if the parser does not have errors\r\nparsing that item then it must be a match.\r\n    \r\nThen once we match a rule we have a map of the token begin/end offsets\r\nfor each fragment match, this is then used to adjust and create a new token\r\nstream for the macro rule definition so that when we feed it to the parser\r\nthe tokens are already substituted. The resulting expression or item is\r\nthen attached to the respective macro invocation and this is then name\r\nresolved and used for hir lowering.\r\n    \r\nFixes #17 #22\r\nAddresses #573\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752bf6c80a922e09edf5bcb53e15e08e83057a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752bf6c80a922e09edf5bcb53e15e08e83057a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/752bf6c80a922e09edf5bcb53e15e08e83057a7f"}, {"sha": "37415eec77438bba2fc61df3e9a396c1e2cbaca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37415eec77438bba2fc61df3e9a396c1e2cbaca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37415eec77438bba2fc61df3e9a396c1e2cbaca8"}], "stats": {"total": 1652, "additions": 1383, "deletions": 269}, "files": [{"sha": "3a1e2956689fa0437999b84770584d8eac11dd44", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -4387,13 +4387,6 @@ std::vector<std::unique_ptr<Token> >\n DelimTokenTree::to_token_stream () const\n {\n   std::vector<std::unique_ptr<Token> > tokens;\n-\n-  // simulate presence of delimiters\n-  const_TokenPtr left_paren\n-    = Rust::Token::make (LEFT_PAREN, Linemap::unknown_location ());\n-  tokens.push_back (\n-    std::unique_ptr<Token> (new Token (std::move (left_paren))));\n-\n   for (const auto &tree : token_trees)\n     {\n       std::vector<std::unique_ptr<Token> > stream = tree->to_token_stream ();\n@@ -4402,13 +4395,7 @@ DelimTokenTree::to_token_stream () const\n \t\t     std::make_move_iterator (stream.end ()));\n     }\n \n-  const_TokenPtr right_paren\n-    = Rust::Token::make (RIGHT_PAREN, Linemap::unknown_location ());\n-  tokens.push_back (\n-    std::unique_ptr<Token> (new Token (std::move (right_paren))));\n-\n   tokens.shrink_to_fit ();\n-\n   return tokens;\n }\n "}, {"sha": "e72937e5d7098267aba51576e6332b656d102cb5", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 191, "deletions": 33, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -22,17 +22,13 @@\n \n #include \"rust-system.h\"\n #include \"rust-hir-map.h\"\n-\n-// gccrs imports\n-// required for AST::Token\n #include \"rust-token.h\"\n #include \"rust-location.h\"\n \n namespace Rust {\n // TODO: remove typedefs and make actual types for these\n typedef std::string Identifier;\n typedef int TupleIndex;\n-\n struct Session;\n \n namespace AST {\n@@ -48,34 +44,6 @@ enum DelimType\n   CURLY\n };\n \n-// Base AST node object - TODO is this really required or useful? Where to draw\n-// line?\n-/*class Node {\n-  public:\n-    // Gets node's Location.\n-    Location get_locus() const {\n-\treturn loc;\n-    }\n-\n-    // Sets node's Location.\n-    void set_locus(Location loc_) {\n-\tloc = loc_;\n-    }\n-\n-    // Get node output as a string. Pure virtual.\n-    virtual std::string as_string() const = 0;\n-\n-    virtual ~Node() {}\n-\n-    // TODO: constructor including Location? Make all derived classes have\n-Location?\n-\n-  private:\n-    // The node's location.\n-    Location loc;\n-};*/\n-// decided to not have node as a \"node\" would never need to be stored\n-\n // forward decl for use in token tree method\n class Token;\n \n@@ -108,6 +76,14 @@ class TokenTree\n class MacroMatch\n {\n public:\n+  enum MacroMatchType\n+  {\n+    Fragment,\n+    Repetition,\n+    Matcher,\n+    Tok\n+  };\n+\n   virtual ~MacroMatch () {}\n \n   virtual std::string as_string () const = 0;\n@@ -121,6 +97,8 @@ class MacroMatch\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual MacroMatchType get_macro_match_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual MacroMatch *clone_macro_match_impl () const = 0;\n@@ -234,6 +212,11 @@ class Token : public TokenTree, public MacroMatch\n   // Get a new token pointer copy.\n   const_TokenPtr get_tok_ptr () const { return tok_ref; }\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Tok;\n+  }\n+\n protected:\n   // No virtual for now as not polymorphic but can be in future\n   /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n@@ -788,6 +771,13 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   {\n     return AttrInput::AttrInputType::TOKEN_TREE;\n   }\n+\n+  std::vector<std::unique_ptr<TokenTree> > &get_token_trees ()\n+  {\n+    return token_trees;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n };\n \n /* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n@@ -1485,6 +1475,160 @@ struct MacroInvocData\n   }\n };\n \n+class SingleASTNode\n+{\n+public:\n+  enum NodeType\n+  {\n+    EXPRESSION,\n+    ITEM,\n+    STMT,\n+  };\n+\n+  SingleASTNode (std::unique_ptr<Expr> expr)\n+    : type (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Item> item)\n+    : type (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<Stmt> stmt)\n+    : type (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n+  {}\n+\n+  SingleASTNode (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+      }\n+  }\n+\n+  SingleASTNode operator= (SingleASTNode const &other)\n+  {\n+    type = other.type;\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr = other.expr->clone_expr ();\n+\tbreak;\n+\n+      case ITEM:\n+\titem = other.item->clone_item ();\n+\tbreak;\n+\n+      case STMT:\n+\tstmt = other.stmt->clone_stmt ();\n+\tbreak;\n+      }\n+    return *this;\n+  }\n+\n+  SingleASTNode (SingleASTNode &&other) = default;\n+  SingleASTNode &operator= (SingleASTNode &&other) = default;\n+\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (type == EXPRESSION);\n+    return expr;\n+  }\n+\n+  std::unique_ptr<Item> &get_item ()\n+  {\n+    rust_assert (type == ITEM);\n+    return item;\n+  }\n+\n+  std::unique_ptr<Stmt> &get_stmt ()\n+  {\n+    rust_assert (type == STMT);\n+    return stmt;\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    switch (type)\n+      {\n+      case EXPRESSION:\n+\texpr->accept_vis (vis);\n+\tbreak;\n+\n+      case ITEM:\n+\titem->accept_vis (vis);\n+\tbreak;\n+\n+      case STMT:\n+\tstmt->accept_vis (vis);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  NodeType type;\n+\n+  // FIXME make this a union\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Stmt> stmt;\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+class ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+\n+  ASTFragment (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+  }\n+\n+  ASTFragment &operator= (ASTFragment const &other)\n+  {\n+    nodes.clear ();\n+    nodes.reserve (other.nodes.size ());\n+    for (auto &n : other.nodes)\n+      {\n+\tnodes.push_back (n);\n+      }\n+    return *this;\n+  }\n+\n+  static ASTFragment create_empty () { return ASTFragment ({}); }\n+\n+  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n+};\n+\n /* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n  * invocation) */\n class MacroInvocationSemi : public MacroItem,\n@@ -1496,14 +1640,20 @@ class MacroInvocationSemi : public MacroItem,\n   std::vector<Attribute> outer_attrs;\n   MacroInvocData invoc_data;\n   Location locus;\n+  NodeId node_id;\n+\n+  // this is the expanded macro\n+  ASTFragment fragment;\n \n public:\n   std::string as_string () const override;\n \n   MacroInvocationSemi (MacroInvocData invoc_data,\n \t\t       std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus)\n+      invoc_data (std::move (invoc_data)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n+      fragment (ASTFragment::create_empty ())\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n@@ -1527,6 +1677,14 @@ class MacroInvocationSemi : public MacroItem,\n \n   Location get_locus () const override final { return locus; }\n \n+  MacroInvocData &get_invoc_data () { return invoc_data; }\n+\n+  ASTFragment &get_fragment () { return fragment; }\n+\n+  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n+\n+  NodeId get_macro_node_id () const { return node_id; }\n+\n protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {"}, {"sha": "b5370d853fca6dbea6cc4ef310fe54117509f4ee", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -24,6 +24,7 @@\n \n namespace Rust {\n namespace AST {\n+\n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n class MacroInvocationSemi;\n@@ -109,6 +110,14 @@ class MacroMatchFragment : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Fragment;\n+  }\n+\n+  Identifier get_ident () const { return ident; }\n+  MacroFragSpec get_frag_spec () const { return frag_spec; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -192,6 +201,11 @@ class MacroMatchRepetition : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Repetition;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -259,6 +273,14 @@ class MacroMatcher : public MacroMatch\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Matcher;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -288,6 +310,8 @@ struct MacroTranscriber\n   std::string as_string () const { return token_tree.as_string (); }\n \n   Location get_locus () const { return locus; }\n+\n+  DelimTokenTree &get_token_tree () { return token_tree; }\n };\n \n // A macro rule? Matcher and transcriber pair?\n@@ -319,6 +343,9 @@ struct MacroRule\n   Location get_locus () const { return locus; }\n \n   std::string as_string () const;\n+\n+  MacroMatcher &get_matcher () { return matcher; }\n+  MacroTranscriber &get_transcriber () { return transcriber; }\n };\n \n // A macro rules definition item AST node\n@@ -365,6 +392,11 @@ class MacroRulesDefinition : public MacroItem\n \n   Location get_locus () const override final { return locus; }\n \n+  Identifier get_rule_name () const { return rule_name; }\n+\n+  std::vector<MacroRule> &get_rules () { return rules; }\n+  const std::vector<MacroRule> &get_rules () const { return rules; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -384,13 +416,17 @@ class MacroInvocation : public TypeNoBounds,\n   MacroInvocData invoc_data;\n   Location locus;\n \n+  // this is the expanded macro\n+  ASTFragment fragment;\n+\n public:\n   std::string as_string () const override;\n \n   MacroInvocation (MacroInvocData invoc_data,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus)\n+      invoc_data (std::move (invoc_data)), locus (locus),\n+      fragment (ASTFragment::create_empty ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -417,6 +453,12 @@ class MacroInvocation : public TypeNoBounds,\n     return ExprWithoutBlock::get_node_id ();\n   }\n \n+  MacroInvocData &get_invoc_data () { return invoc_data; }\n+\n+  ASTFragment &get_fragment () { return fragment; }\n+\n+  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -651,62 +693,6 @@ class MetaListNameValueStr : public MetaItem\n   }\n };\n \n-/* Should be a tagged union to save space but implemented as struct due to\n- * technical difficulties. TODO: fix\n- * Basically, a single AST node used inside an AST fragment. */\n-struct SingleASTNode\n-{\n-  std::unique_ptr<Expr> expr;\n-  std::unique_ptr<Stmt> stmt;\n-  std::unique_ptr<Item> item;\n-  std::unique_ptr<Type> type;\n-  std::unique_ptr<Pattern> pattern;\n-  std::unique_ptr<TraitItem> trait_item;\n-  std::unique_ptr<InherentImplItem> inherent_impl_item;\n-  std::unique_ptr<TraitImplItem> trait_impl_item;\n-  std::unique_ptr<ExternalItem> external_item;\n-\n-  SingleASTNode (std::unique_ptr<Expr> expr) : expr (std::move (expr)) {}\n-  SingleASTNode (std::unique_ptr<Stmt> stmt) : stmt (std::move (stmt)) {}\n-  SingleASTNode (std::unique_ptr<Item> item) : item (std::move (item)) {}\n-  SingleASTNode (std::unique_ptr<Type> type) : type (std::move (type)) {}\n-  SingleASTNode (std::unique_ptr<Pattern> pattern)\n-    : pattern (std::move (pattern))\n-  {}\n-  SingleASTNode (std::unique_ptr<TraitItem> trait_item)\n-    : trait_item (std::move (trait_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item)\n-    : inherent_impl_item (std::move (inherent_impl_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n-    : trait_impl_item (std::move (trait_impl_item))\n-  {}\n-  SingleASTNode (std::unique_ptr<ExternalItem> external_item)\n-    : external_item (std::move (external_item))\n-  {}\n-};\n-\n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n- * a result of macro expansion. Really annoying to work with due to the fact\n- * that macros can really expand to anything. As such, horrible representation\n- * at the moment. */\n-struct ASTFragment\n-{\n-private:\n-  /* basic idea: essentially, a vector of tagged unions of different AST node\n-   * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create\n-   * issues with the diamond problem or significant performance penalties. So\n-   * a tagged union had to be used instead. A vector is used to represent the\n-   * ability for a macro to expand to two statements, for instance. */\n-\n-  std::vector<SingleASTNode> nodes;\n-\n-public:\n-  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n-};\n-\n // Object that parses macros from a token stream.\n /* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n  * attributes, I believe */"}, {"sha": "dcfec7ceeb793feb17fd4112a8a2b5bee63f5c49", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 588, "deletions": 44, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -20,6 +20,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-ast-visitor.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-parse.h\"\n \n namespace Rust {\n // Visitor used to expand attributes.\n@@ -323,6 +324,13 @@ class AttrVisitor : public AST::ASTVisitor\n     // I don't think any macro token trees can be stripped in any way\n \n     // TODO: maybe have cfg! macro stripping behaviour here?\n+\n+    expander.expand_invoc_semi (macro_invoc);\n+\n+    // we need to visit the expanded fragments since it may need cfg expansion\n+    // and it may be recursive\n+    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n+      node.accept_vis (*this);\n   }\n \n   void visit (AST::PathInExpression &path) override\n@@ -1033,13 +1041,17 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t     \"cannot strip expression in this position - outer \"\n \t\t     \"attributes not allowed\");\n   }\n+\n   void visit (AST::BlockExpr &expr) override\n   {\n+    expander.push_context (MacroExpander::BLOCK);\n+\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n     if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n+\texpander.pop_context ();\n \treturn;\n       }\n \n@@ -1049,6 +1061,7 @@ class AttrVisitor : public AST::ASTVisitor\n     if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n+\texpander.pop_context ();\n \treturn;\n       }\n \n@@ -1065,7 +1078,9 @@ class AttrVisitor : public AST::ASTVisitor\n \tif (tail_expr->is_marked_for_strip ())\n \t  expr.strip_tail_expr ();\n       }\n+    expander.pop_context ();\n   }\n+\n   void visit (AST::ClosureExprInnerTyped &expr) override\n   {\n     // initial strip test based on outer attrs\n@@ -2509,9 +2524,20 @@ class AttrVisitor : public AST::ASTVisitor\n       }\n \n     // I don't think any macro rules can be stripped in any way\n+\n+    auto path = Resolver::CanonicalPath::new_seg (rules_def.get_node_id (),\n+\t\t\t\t\t\t  rules_def.get_rule_name ());\n+    expander.resolver->get_macro_scope ().insert (path,\n+\t\t\t\t\t\t  rules_def.get_node_id (),\n+\t\t\t\t\t\t  rules_def.get_locus ());\n+    expander.mappings->insert_macro_def (&rules_def);\n   }\n+\n   void visit (AST::MacroInvocation &macro_invoc) override\n   {\n+    // FIXME\n+    // we probably need another recurision check here\n+\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n     if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n@@ -2521,9 +2547,14 @@ class AttrVisitor : public AST::ASTVisitor\n       }\n \n     // I don't think any macro token trees can be stripped in any way\n+    expander.expand_invoc (macro_invoc);\n \n-    // TODO: maybe have stripping behaviour for the cfg! macro here?\n+    // we need to visit the expanded fragments since it may need cfg expansion\n+    // and it may be recursive\n+    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n+      node.accept_vis (*this);\n   }\n+\n   void visit (AST::MetaItemPath &) override {}\n   void visit (AST::MetaItemSeq &) override {}\n   void visit (AST::MetaWord &) override {}\n@@ -3011,7 +3042,7 @@ MacroExpander::parse_macro_to_meta_item (AST::MacroInvocData &invoc)\n     }\n   else\n     {\n-      std::vector<std::unique_ptr<AST::MetaItemInner> > meta_items (\n+      std::vector<std::unique_ptr<AST::MetaItemInner>> meta_items (\n \tstd::move (converted_input->get_items ()));\n       invoc.set_meta_item_output (std::move (meta_items));\n     }\n@@ -3038,10 +3069,11 @@ MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n     return AST::Literal (\"false\", AST::Literal::BOOL, CORETYPE_BOOL);\n }\n \n-#if 0\n AST::ASTFragment\n-MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n-\t\t\t\t  AST::MacroRulesDefinition &rules_def)\n+MacroExpander::expand_decl_macro (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc,\n+\t\t\t\t  AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t  bool semicolon)\n {\n   // ensure that both invocation and rules are in a valid state\n   rust_assert (!invoc.is_marked_for_strip ());\n@@ -3081,49 +3113,123 @@ MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n    * TokenTree). This will prevent re-conversion of Tokens between each type\n    * all the time, while still allowing the heterogenous storage of token trees.\n    */\n+\n+  AST::DelimTokenTree &invoc_token_tree = invoc.get_delim_tok_tree ();\n+\n+  // find matching arm\n+  AST::MacroRule *matched_rule = nullptr;\n+  std::map<std::string, MatchedFragment> matched_fragments;\n+  for (auto &rule : rules_def.get_rules ())\n+    {\n+      sub_stack.push ();\n+      bool did_match_rule = try_match_rule (rule, invoc_token_tree);\n+      matched_fragments = sub_stack.pop ();\n+\n+      if (did_match_rule)\n+\t{\n+\t  matched_rule = &rule;\n+\t  break;\n+\t}\n+    }\n+\n+  if (matched_rule == nullptr)\n+    {\n+      RichLocation r (invoc_locus);\n+      r.add_range (rules_def.get_locus ());\n+      rust_error_at (r, \"Failed to match any rule within macro\");\n+      return AST::ASTFragment::create_empty ();\n+    }\n+\n+  return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n+\t\t\t  semicolon, peek_context ());\n+}\n+\n+void\n+MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // ??\n+  // switch on type of macro:\n+  //  - '!' syntax macro (inner switch)\n+  //      - procedural macro - \"A token-based function-like macro\"\n+  //      - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+  // AST-based function-like macro\"\n+  //      - else is unreachable\n+  //  - attribute syntax macro (inner switch)\n+  //  - procedural macro attribute syntax - \"A token-based attribute\n+  // macro\"\n+  //      - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+  //      - non-macro attribute: mark known\n+  //      - else is unreachable\n+  //  - derive macro (inner switch)\n+  //      - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+  //      - else is unreachable\n+  //  - derive container macro - unreachable\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  bool found = resolver->get_macro_scope ().lookup (\n+    Resolver::CanonicalPath::new_seg (invoc.get_pattern_node_id (),\n+\t\t\t\t      invoc_data.get_path ().as_string ()),\n+    &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro\");\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment\n+    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, false);\n+\n+  // lets attach this fragment to the invocation\n+  invoc.set_fragment (std::move (fragment));\n }\n-#endif\n \n void\n-MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n+MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n {\n-  /* if current expansion depth > recursion limit, create an error (maybe fatal\n-   * error) and return */\n-\n-  /* switch on type of macro:\n-      - '!' syntax macro (inner switch)\n-\t  - procedural macro - \"A token-based function-like macro\"\n-\t  - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n-     AST-based function-like macro\"\n-\t  - else is unreachable\n-      - attribute syntax macro (inner switch)\n-\t  - procedural macro attribute syntax - \"A token-based attribute macro\"\n-\t  - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n-\t  - non-macro attribute: mark known\n-\t  - else is unreachable\n-      - derive macro (inner switch)\n-\t  - derive or legacy derive - \"token-based\" vs \"AST-based\"\n-\t  - else is unreachable\n-      - derive container macro - unreachable*/\n-\n-#if 0\n-  // macro_rules macro test code\n-  auto rule_def = find_rules_def(invoc->get_path());\n-  if (rule_def != nullptr) {\n-    ASTFrag expanded = expand_decl_macro(invoc, rule_def);\n-    /* could make this a data structure containing vectors of exprs, patterns and types (for regular),\n-     * and then stmts and items (for semi). Except what about having an expr, then a type? Hmm. Might\n-     * have to do the \"unified base type\" thing OR just have a simulated union, and then have AST frag\n-     * be a vector of these simulated unions. */\n-\n-    // how would errors be signalled? null fragment? something else?\n-    // what about error vs just not having stuff in rules definition yet?\n-\n-    /* replace macro invocation with ast frag. actually, don't have any context here. maybe attach ast\n-     * frag to macro invocation, and then have a method above get it? Or just return the ast frag from\n-     * this method. */\n-  }\n-#endif\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  bool found = resolver->get_macro_scope ().lookup (\n+    Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n+\t\t\t\t      invoc_data.get_path ().as_string ()),\n+    &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro\");\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment\n+    = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n+\n+  // lets attach this fragment to the invocation\n+  invoc.set_fragment (std::move (fragment));\n }\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n@@ -3225,6 +3331,9 @@ MacroExpander::expand_cfg_attrs (AST::AttrVec &attrs)\n void\n MacroExpander::expand_crate ()\n {\n+  NodeId scope_node_id = crate.get_node_id ();\n+  resolver->get_macro_scope ().push (scope_node_id);\n+\n   /* fill macro/decorator map from init list? not sure where init list comes\n    * from? */\n \n@@ -3242,6 +3351,8 @@ MacroExpander::expand_crate ()\n     }\n   // expand module attributes?\n \n+  push_context (ITEM);\n+\n   // expand attributes recursively and strip items if required\n   AttrVisitor attr_visitor (*this);\n   auto &items = crate.items;\n@@ -3258,6 +3369,8 @@ MacroExpander::expand_crate ()\n \t++it;\n     }\n \n+  pop_context ();\n+\n   // TODO: should recursive attribute and macro expansion be done in the same\n   // transversal? Or in separate ones like currently?\n \n@@ -3267,4 +3380,435 @@ MacroExpander::expand_crate ()\n \n   // extract exported macros?\n }\n+\n+bool\n+MacroExpander::depth_exceeds_recursion_limit () const\n+{\n+  return expansion_depth >= cfg.recursion_limit;\n+}\n+\n+bool\n+MacroExpander::try_match_rule (AST::MacroRule &match_rule,\n+\t\t\t       AST::DelimTokenTree &invoc_token_tree)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  AST::MacroMatcher &matcher = match_rule.get_matcher ();\n+\n+  expansion_depth++;\n+  if (!match_matcher (parser, matcher))\n+    {\n+      expansion_depth--;\n+      return false;\n+    }\n+  expansion_depth--;\n+\n+  bool used_all_input_tokens = parser.skip_token (END_OF_FILE);\n+  return used_all_input_tokens;\n+}\n+\n+bool\n+MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t\t       AST::MacroMatchFragment &fragment)\n+{\n+  switch (fragment.get_frag_spec ())\n+    {\n+    case AST::MacroFragSpec::EXPR:\n+      parser.parse_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::BLOCK:\n+      parser.parse_block_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::IDENT:\n+      parser.parse_identifier_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::LITERAL:\n+      parser.parse_literal_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::ITEM:\n+      parser.parse_item (false);\n+      break;\n+\n+    case AST::MacroFragSpec::TY:\n+      parser.parse_type ();\n+      break;\n+\n+    case AST::MacroFragSpec::PAT:\n+      parser.parse_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::PATH:\n+      parser.parse_path_in_expression ();\n+      break;\n+\n+    case AST::MacroFragSpec::VIS:\n+      parser.parse_visibility ();\n+      break;\n+\n+    case AST::MacroFragSpec::STMT:\n+      parser.parse_stmt ();\n+      break;\n+\n+    case AST::MacroFragSpec::LIFETIME:\n+      parser.parse_lifetime_params ();\n+      break;\n+\n+      // is meta attributes?\n+    case AST::MacroFragSpec::META:\n+      // parser.parse_inner_attribute ?\n+      // parser.parse_outer_attribute ?\n+      // parser.parse_attribute_body ?\n+      // parser.parse_doc_comment ?\n+      gcc_unreachable ();\n+      break;\n+\n+      // what is TT?\n+    case AST::MacroFragSpec::TT:\n+      // parser.parse_token_tree() ?\n+      gcc_unreachable ();\n+      break;\n+\n+      // i guess we just ignore invalid and just error out\n+    case AST::MacroFragSpec::INVALID:\n+      return false;\n+    }\n+\n+  // it matches if the parser did not produce errors trying to parse that type\n+  // of item\n+  return !parser.has_errors ();\n+}\n+\n+bool\n+MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t\t      AST::MacroMatcher &matcher)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (matcher.get_match_locus (), \"reached recursion limit\");\n+      return false;\n+    }\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  switch (matcher.get_delim_type ())\n+    {\n+      case AST::DelimType::PARENS: {\n+\tif (!parser.skip_token (LEFT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::SQUARE: {\n+\tif (!parser.skip_token (LEFT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tif (!parser.skip_token (LEFT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    }\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+\n+  for (auto &match : matcher.get_matches ())\n+    {\n+      size_t offs_begin = source.get_offs ();\n+      switch (match->get_macro_match_type ())\n+\t{\n+\t  case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t    AST::MacroMatchFragment *fragment\n+\t      = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t    if (!match_fragment (parser, *fragment))\n+\t      return false;\n+\n+\t    // matched fragment get the offset in the token stream\n+\t    size_t offs_end = source.get_offs ();\n+\t    sub_stack.peek ().insert (\n+\t      {fragment->get_ident (),\n+\t       {fragment->get_ident (), offs_begin, offs_end}});\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Tok: {\n+\t    AST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t    if (!match_token (parser, *tok))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t    AST::MacroMatchRepetition *rep\n+\t      = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t    if (!match_repetition (parser, *rep))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t    AST::MacroMatcher *m\n+\t      = static_cast<AST::MacroMatcher *> (match.get ());\n+\t    expansion_depth++;\n+\t    if (!match_matcher (parser, *m))\n+\t      {\n+\t\texpansion_depth--;\n+\t\treturn false;\n+\t      }\n+\t    expansion_depth--;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  switch (matcher.get_delim_type ())\n+    {\n+      case AST::DelimType::PARENS: {\n+\tif (!parser.skip_token (RIGHT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::SQUARE: {\n+\tif (!parser.skip_token (RIGHT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tif (!parser.skip_token (RIGHT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+MacroExpander::match_token (Parser<MacroInvocLexer> &parser, AST::Token &token)\n+{\n+  // FIXME this needs to actually match the content and the type\n+  return parser.skip_token (token.get_id ());\n+}\n+\n+bool\n+MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t\t AST::MacroMatchRepetition &rep)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+AST::ASTFragment\n+MacroExpander::transcribe_rule (\n+  AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n+  std::map<std::string, MatchedFragment> &matched_fragments, bool semicolon,\n+  ContextType ctx)\n+{\n+  // we can manipulate the token tree to substitute the dollar identifiers so\n+  // that when we call parse its already substituted for us\n+  AST::MacroTranscriber &transcriber = match_rule.get_transcriber ();\n+  AST::DelimTokenTree &transcribe_tree = transcriber.get_token_tree ();\n+\n+  auto invoc_stream = invoc_token_tree.to_token_stream ();\n+  auto macro_rule_tokens = transcribe_tree.to_token_stream ();\n+\n+  std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n+    = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n+\n+  // // handy for debugging\n+  // for (auto &tok : substituted_tokens)\n+  //   {\n+  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n+  //   }\n+\n+  // parse it to an ASTFragment\n+  MacroInvocLexer lex (std::move (substituted_tokens));\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  switch (transcribe_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  // see https://github.com/Rust-GCC/gccrs/issues/22\n+  // TL;DR:\n+  //   - Treat all macro invocations with parentheses, (), or square brackets,\n+  //   [], as expressions.\n+  //   - If the macro invocation has curly brackets, {}, it may be parsed as a\n+  //   statement depending on the context.\n+  //   - If the macro invocation has a semicolon at the end, it must be parsed\n+  //   as a statement (either via ExpressionStatement or\n+  //   MacroInvocationWithSemi)\n+\n+  // parse the item\n+  std::vector<AST::SingleASTNode> nodes;\n+  switch (invoc_token_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      case AST::DelimType::SQUARE: {\n+\tswitch (ctx)\n+\t  {\n+\t    case ContextType::ITEM: {\n+\t      auto item = parser.parse_item (true);\n+\t      if (item != nullptr && !parser.has_errors ())\n+\t\t{\n+\t\t  rust_debug (\"HELLO WORLD: [%s]\", item->as_string ().c_str ());\n+\t\t  nodes.push_back (std::move (item));\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t    case ContextType::BLOCK: {\n+\t      auto expr = parser.parse_expr ();\n+\t      if (expr != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (expr));\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+      case AST::DelimType::CURLY: {\n+\tswitch (ctx)\n+\t  {\n+\t    case ContextType::ITEM: {\n+\t      auto item = parser.parse_item (true);\n+\t      if (item != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (item));\n+\t    }\n+\t    break;\n+\n+\t    case ContextType::BLOCK: {\n+\t      auto stmt = parser.parse_stmt ();\n+\t      if (stmt != nullptr && !parser.has_errors ())\n+\t\tnodes.push_back (std::move (stmt));\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+    }\n+\n+  // emit any errors\n+  if (parser.has_errors ())\n+    {\n+      for (auto &err : parser.get_errors ())\n+\t{\n+\t  rust_error_at (err.locus, \"%s\", err.message.c_str ());\n+\t}\n+      return AST::ASTFragment::create_empty ();\n+    }\n+\n+  // are all the tokens used?\n+  bool did_delimit = false;\n+  switch (transcribe_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      did_delimit = parser.skip_token (RIGHT_PAREN);\n+      break;\n+    case AST::DelimType::SQUARE:\n+      did_delimit = parser.skip_token (RIGHT_SQUARE);\n+      break;\n+    case AST::DelimType::CURLY:\n+      did_delimit = parser.skip_token (RIGHT_CURLY);\n+      break;\n+    }\n+\n+  bool reached_end_of_stream = did_delimit && parser.skip_token (END_OF_FILE);\n+  if (!reached_end_of_stream)\n+    {\n+      const_TokenPtr current_token = parser.peek_current_token ();\n+      rust_error_at (current_token->get_locus (),\n+\t\t     \"tokens here and after are unparsed\");\n+    }\n+\n+  return AST::ASTFragment (std::move (nodes));\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+MacroExpander::substitute_tokens (\n+  std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::vector<std::unique_ptr<AST::Token>> &macro,\n+  std::map<std::string, MatchedFragment> &fragments)\n+{\n+  std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n+\n+  for (size_t i = 0; i < macro.size (); i++)\n+    {\n+      auto &tok = macro.at (i);\n+      if (tok->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  std::vector<std::unique_ptr<AST::Token>> parsed_toks;\n+\n+\t  std::string ident;\n+\t  for (size_t offs = i; i < macro.size (); offs++)\n+\t    {\n+\t      auto &tok = macro.at (offs);\n+\t      if (tok->get_id () == DOLLAR_SIGN && offs == i)\n+\t\t{\n+\t\t  parsed_toks.push_back (tok->clone_token ());\n+\t\t}\n+\t      else if (tok->get_id () == IDENTIFIER)\n+\t\t{\n+\t\t  rust_assert (tok->as_string ().size () == 1);\n+\t\t  ident.push_back (tok->as_string ().at (0));\n+\t\t  parsed_toks.push_back (tok->clone_token ());\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  // lookup the ident\n+\t  auto it = fragments.find (ident);\n+\t  if (it == fragments.end ())\n+\t    {\n+\t      // just leave the tokens in\n+\t      for (auto &tok : parsed_toks)\n+\t\t{\n+\t\t  replaced_tokens.push_back (tok->clone_token ());\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // replace\n+\t      MatchedFragment &frag = it->second;\n+\t      for (size_t offs = frag.token_offset_begin;\n+\t\t   offs < frag.token_offset_end; offs++)\n+\t\t{\n+\t\t  auto &tok = input.at (offs);\n+\t\t  replaced_tokens.push_back (tok->clone_token ());\n+\t\t}\n+\t    }\n+\t  i += parsed_toks.size () - 1;\n+\t}\n+      else\n+\t{\n+\t  replaced_tokens.push_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return replaced_tokens;\n+}\n+\n } // namespace Rust"}, {"sha": "d8a2d5003e654ed6bfbba53284289591dc010859", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 144, "deletions": 4, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -19,8 +19,13 @@\n #ifndef RUST_MACRO_EXPAND_H\n #define RUST_MACRO_EXPAND_H\n \n+#include \"rust-buffered-queue.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-token.h\"\n #include \"rust-ast.h\"\n #include \"rust-macro.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n \n // Provides objects and method prototypes for macro expansion\n \n@@ -43,14 +48,101 @@ struct ExpansionCfg\n   std::string crate_name = \"\";\n };\n \n+class MacroInvocLexer\n+{\n+public:\n+  MacroInvocLexer (std::vector<std::unique_ptr<AST::Token>> stream)\n+    : offs (0), token_stream (std::move (stream))\n+  {}\n+\n+  // Returns token n tokens ahead of current position.\n+  const_TokenPtr peek_token (int n)\n+  {\n+    if ((offs + n) >= token_stream.size ())\n+      return Token::make (END_OF_FILE, Location ());\n+\n+    return token_stream.at (offs + n)->get_tok_ptr ();\n+  }\n+  // Peeks the current token.\n+  const_TokenPtr peek_token () { return peek_token (0); }\n+\n+  // Advances current token to n + 1 tokens ahead of current position.\n+  void skip_token (int n) { offs += (n + 1); }\n+\n+  // Skips the current token.\n+  void skip_token () { skip_token (0); }\n+\n+  // Splits the current token into two. Intended for use with nested generics\n+  // closes (i.e. T<U<X>> where >> is wrongly lexed as one token). Note that\n+  // this will only work with \"simple\" tokens like punctuation.\n+  void split_current_token (TokenId /*new_left*/, TokenId /*new_right*/)\n+  {\n+    // FIXME\n+    gcc_unreachable ();\n+  }\n+\n+  std::string get_filename () const\n+  {\n+    gcc_unreachable ();\n+    return \"FIXME\";\n+  }\n+\n+  size_t get_offs () const { return offs; }\n+\n+private:\n+  size_t offs;\n+  std::vector<std::unique_ptr<AST::Token>> token_stream;\n+};\n+\n+struct MatchedFragment\n+{\n+  std::string fragment_ident;\n+  size_t token_offset_begin;\n+  size_t token_offset_end;\n+\n+  std::string as_string () const\n+  {\n+    return fragment_ident + \"=\" + std::to_string (token_offset_begin) + \":\"\n+\t   + std::to_string (token_offset_end);\n+  }\n+};\n+\n+class SubstitutionScope\n+{\n+public:\n+  SubstitutionScope () : stack () {}\n+\n+  void push () { stack.push_back ({}); }\n+\n+  std::map<std::string, MatchedFragment> pop ()\n+  {\n+    auto top = stack.back ();\n+    stack.pop_back ();\n+    return top;\n+  }\n+\n+  std::map<std::string, MatchedFragment> &peek () { return stack.back (); }\n+\n+private:\n+  std::vector<std::map<std::string, MatchedFragment>> stack;\n+};\n+\n // Object used to store shared data (between functions) for macro expansion.\n struct MacroExpander\n {\n+  enum ContextType\n+  {\n+    ITEM,\n+    BLOCK,\n+  };\n+\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n   MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n-    : cfg (cfg), crate (crate), session (session)\n+    : cfg (cfg), crate (crate), session (session),\n+      sub_stack (SubstitutionScope ()), resolver (Resolver::Resolver::get ()),\n+      mappings (Analysis::Mappings::get ())\n   {}\n \n   ~MacroExpander () = default;\n@@ -61,11 +153,14 @@ struct MacroExpander\n   /* Expands a macro invocation (not macro invocation semi) - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n-  void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n+  void expand_invoc (AST::MacroInvocation &invoc);\n+  void expand_invoc_semi (AST::MacroInvocationSemi &invoc);\n \n   // Expands a single declarative macro.\n-  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc,\n-\t\t\t\t      AST::MacroRulesDefinition &rules_def);\n+  AST::ASTFragment expand_decl_macro (Location locus,\n+\t\t\t\t      AST::MacroInvocData &invoc,\n+\t\t\t\t      AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t      bool semicolon);\n \n   void expand_cfg_attrs (AST::AttrVec &attrs);\n   bool fails_cfg (const AST::AttrVec &attr) const;\n@@ -76,10 +171,55 @@ struct MacroExpander\n   // Get the literal representation of a cfg! macro.\n   AST::Literal expand_cfg_macro (AST::MacroInvocData &invoc);\n \n+  bool depth_exceeds_recursion_limit () const;\n+\n+  bool try_match_rule (AST::MacroRule &match_rule,\n+\t\t       AST::DelimTokenTree &invoc_token_tree);\n+\n+  AST::ASTFragment\n+  transcribe_rule (AST::MacroRule &match_rule,\n+\t\t   AST::DelimTokenTree &invoc_token_tree,\n+\t\t   std::map<std::string, MatchedFragment> &matched_fragments,\n+\t\t   bool semicolon, ContextType ctx);\n+\n+  bool match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t       AST::MacroMatchFragment &fragment);\n+\n+  bool match_token (Parser<MacroInvocLexer> &parser, AST::Token &token);\n+\n+  bool match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t AST::MacroMatchRepetition &rep);\n+\n+  bool match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t      AST::MacroMatcher &matcher);\n+\n+  static std::vector<std::unique_ptr<AST::Token>>\n+  substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t     std::vector<std::unique_ptr<AST::Token>> &macro,\n+\t\t     std::map<std::string, MatchedFragment> &fragments);\n+\n+  void push_context (ContextType t) { context.push_back (t); }\n+\n+  ContextType pop_context ()\n+  {\n+    ContextType t = context.back ();\n+    context.pop_back ();\n+    return t;\n+  }\n+\n+  ContextType peek_context () { return context.back (); }\n+\n private:\n   AST::Crate &crate;\n   Session &session;\n+  SubstitutionScope sub_stack;\n+  std::vector<ContextType> context;\n+\n+public:\n+  Resolver::Resolver *resolver;\n+  Analysis::Mappings *mappings;\n };\n+\n } // namespace Rust\n \n #endif"}, {"sha": "a8048bb82f262c30d41f795b99348e04116a5236", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -100,6 +100,16 @@ class ASTLoweringExpr : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocation &expr) override\n+  {\n+    AST::ASTFragment &fragment = expr.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     HIR::Expr *tuple_expr"}, {"sha": "3d10b70bc17b27754f337030ccd549c90a446e2c", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -52,6 +52,16 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &alias) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n@@ -308,6 +318,16 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemFunc &func) override\n   {\n     AST::TraitFunctionDecl &ref = func.get_trait_function_decl ();"}, {"sha": "30bd896a7976de4ee8c0837c2847e0960a0fcbd6", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -47,6 +47,16 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::Module &module) override\n   {\n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "b25246a43aa828e776be417f8d5090db44e37935", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -45,6 +45,16 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n+\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     HIR::ExprWithBlock *expr"}, {"sha": "0ae07fe2cd1013aab7ad2f1d02937139a8bdfa9e", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -1,3 +1,21 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_LEX_H\n #define RUST_LEX_H\n \n@@ -198,6 +216,7 @@ class Lexer\n   // Token stream queue.\n   buffered_queue<std::shared_ptr<Token>, TokenSource> token_queue;\n };\n+\n } // namespace Rust\n \n #endif"}, {"sha": "784e6d1efd21ee5f111abbc059428e52cf2af769", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -905,6 +905,9 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n \n   // parse actual token tree vector - 0 or more\n   std::vector<std::unique_ptr<AST::TokenTree>> token_trees_in_tree;\n+  auto delim_open\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees_in_tree.push_back (std::move (delim_open));\n \n   // repeat loop until finding the matching delimiter\n   t = lexer.peek_token ();\n@@ -929,6 +932,9 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n       // lexer.skip_token();\n       t = lexer.peek_token ();\n     }\n+  auto delim_close\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees_in_tree.push_back (std::move (delim_close));\n \n   AST::DelimTokenTree token_tree (delim_type, std::move (token_trees_in_tree),\n \t\t\t\t  initial_loc);\n@@ -1565,6 +1571,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n   // parse actual token trees\n   std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+  auto delim_open\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees.push_back (std::move (delim_open));\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1587,6 +1596,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n       t = lexer.peek_token ();\n     }\n+  auto delim_close\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n+  token_trees.push_back (std::move (delim_close));\n \n   AST::DelimTokenTree delim_tok_tree (delim_type, std::move (token_trees),\n \t\t\t\t      tok_tree_locus);\n@@ -1605,6 +1617,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t  if (!skip_token (SEMICOLON))\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n+\n \t      return std::unique_ptr<AST::MacroInvocationSemi> (\n \t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t      std::move (outer_attrs),\n@@ -11755,6 +11768,9 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \n \t// parse actual token trees\n \tstd::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+\tauto delim_open\n+\t  = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+\ttoken_trees.push_back (std::move (delim_open));\n \n \tt3 = lexer.peek_token ();\n \t// parse token trees until the initial delimiter token is found again\n@@ -11779,6 +11795,10 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t    t3 = lexer.peek_token ();\n \t  }\n \n+\tauto delim_close\n+\t  = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+\ttoken_trees.push_back (std::move (delim_close));\n+\n \t// parse end delimiters\n \tt3 = lexer.peek_token ();\n \tif (token_id_matches_delims (t3->get_id (), type))\n@@ -12070,6 +12090,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \n   // parse actual token trees\n   std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n+  auto delim_open\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+  token_trees.push_back (std::move (delim_open));\n \n   t3 = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -12092,6 +12115,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \n       t3 = lexer.peek_token ();\n     }\n+  auto delim_close\n+    = std::unique_ptr<AST::Token> (new AST::Token (std::move (t3)));\n+  token_trees.push_back (std::move (delim_close));\n \n   // parse end delimiters\n   t3 = lexer.peek_token ();"}, {"sha": "f995e4b5db200ccbe9ac116e6796875dae93c90d", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -18,32 +18,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rust-linemap.h\"\n #include \"rust-diagnostics.h\"\n \n-#if 0\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"input.h\"\n-#include \"diagnostic.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-expr.h\"\n-#include \"convert.h\"\n-#include \"print-tree.h\"\n-#include \"stor-layout.h\"\n-#include \"fold-const.h\"\n-/* order: config, system, coretypes, target, tree, tree-iterator, input, diagnostic, stringpool,\n- * cgraph, gimplify, gimple-expr, convert, print-tree, stor-layout, fold-const  */\n-// probably don't need all these\n-#endif\n-// maybe put these back in if compiling no longer works\n-\n-/* TODO: move non-essential stuff back here from rust-parse-impl.h after\n- * confirming that it works */\n-\n namespace Rust {\n \n std::string"}, {"sha": "5ee7b4e6c853a8db86bd9926cf2ce18c0ec3a7f4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -86,14 +86,36 @@ struct ParseRestrictions\n // TODO: if updated to C++20, ManagedTokenSource would be useful as a concept\n template <typename ManagedTokenSource> class Parser\n {\n+public:\n+  bool skip_token (TokenId t);\n+\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+\n+  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+\n+  std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+\n+  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n+  std::unique_ptr<AST::Pattern> parse_pattern ();\n+  std::unique_ptr<AST::Stmt> parse_stmt ();\n+  std::unique_ptr<AST::Type> parse_type ();\n+  AST::PathInExpression parse_path_in_expression ();\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+  AST::Visibility parse_visibility ();\n+  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+\n private:\n   void skip_after_semicolon ();\n   void skip_after_end ();\n   void skip_after_end_block ();\n   void skip_after_next_block ();\n   void skip_after_end_attribute ();\n \n-  bool skip_token (TokenId t);\n   const_TokenPtr expect_token (TokenId t);\n   void unexpected_token (const_TokenPtr t);\n   bool skip_generics_right_angle ();\n@@ -118,7 +140,6 @@ template <typename ManagedTokenSource> class Parser\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function ();\n-  AST::PathInExpression parse_path_in_expression ();\n   AST::PathExprSegment parse_path_expr_segment ();\n   AST::QualifiedPathInExpression\n   // When given a pratt_parsed_loc, use it as the location of the\n@@ -147,10 +168,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n \n   // Top-level item-related\n-  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n   std::unique_ptr<AST::VisItem> parse_vis_item (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroItem> parse_macro_item (AST::AttrVec outer_attrs);\n-  AST::Visibility parse_visibility ();\n \n   // VisItem subclass-related\n   std::unique_ptr<AST::Module> parse_module (AST::Visibility vis,\n@@ -169,7 +188,7 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params (EndTokenPred is_end_token);\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::LifetimeParam> >\n   parse_lifetime_params (EndTokenPred is_end_token);\n@@ -260,9 +279,6 @@ template <typename ManagedTokenSource> class Parser\n \n   // Expression-related (Pratt parsed)\n   std::unique_ptr<AST::Expr>\n-  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t      ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::Expr>\n   parse_expr (int right_binding_power,\n \t      AST::AttrVec outer_attrs = AST::AttrVec (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n@@ -478,9 +494,6 @@ template <typename ManagedTokenSource> class Parser\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped).\n-  std::unique_ptr<AST::BlockExpr>\n-  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::IfExpr>\n   parse_if_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t Location pratt_parsed_loc = Linemap::unknown_location ());\n@@ -518,8 +531,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::ClosureExpr> parse_closure_expr (AST::AttrVec outer_attrs\n \t\t\t\t\t\t\t= AST::AttrVec ());\n   AST::ClosureParam parse_closure_param ();\n-  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t\t= AST::AttrVec ());\n+\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped).\n@@ -548,7 +560,6 @@ template <typename ManagedTokenSource> class Parser\n   bool will_be_expr_with_block ();\n \n   // Type-related\n-  std::unique_ptr<AST::Type> parse_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n   std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n   std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n@@ -561,7 +572,6 @@ template <typename ManagedTokenSource> class Parser\n   AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n \n   // Statement-related\n-  std::unique_ptr<AST::Stmt> parse_stmt ();\n   std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithBlock>\n@@ -574,13 +584,11 @@ template <typename ManagedTokenSource> class Parser\n   ExprOrStmt parse_path_based_stmt_or_expr (AST::AttrVec outer_attrs);\n \n   // Pattern-related\n-  std::unique_ptr<AST::Pattern> parse_pattern ();\n   std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n   std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n   std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n   std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n   std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n-  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n   std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n@@ -617,6 +625,10 @@ template <typename ManagedTokenSource> class Parser\n   // Get a reference to the list of errors encountered\n   std::vector<Error> &get_errors () { return error_table; }\n \n+  const ManagedTokenSource &get_token_source () const { return lexer; }\n+\n+  const_TokenPtr peek_current_token () { return lexer.peek_token (0); }\n+\n private:\n   // The token source (usually lexer) associated with the parser.\n   ManagedTokenSource lexer;"}, {"sha": "bb1cbb04794692154dbb93a49bf952be6b61c448", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -70,6 +70,13 @@ class ResolveExpr : public ResolverBase\n     expr->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocation &expr) override\n+  {\n+    AST::ASTFragment &fragment = expr.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());"}, {"sha": "ce7234ca1a1ac220986207b31bf3b5a8785b3a46", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -49,6 +49,13 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &type) override\n   {\n     auto decl\n@@ -137,6 +144,13 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemFunc &function) override\n   {\n     auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n@@ -240,6 +254,13 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::ExternalFunctionItem &function) override\n   {\n     auto decl = CanonicalPath::new_seg (function.get_node_id (),"}, {"sha": "48f93e534875a828b73f408b548abc821a72293a", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -45,6 +45,13 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TraitItemType &type) override\n   {\n     auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n@@ -227,6 +234,13 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::TypeAlias &alias) override\n   {\n     auto talias = CanonicalPath::new_seg (alias.get_node_id (),"}, {"sha": "7521739b884614ef4605cc78275243ddc4196e50", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -44,6 +44,14 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,"}, {"sha": "39d6818427a332e9b00cde0ecdf0ee0ef6909414", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -43,6 +43,13 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n+  void visit (AST::MacroInvocationSemi &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n+\n   void visit (AST::Module &module) override\n   {\n     auto mod"}, {"sha": "5ac076a1fb934fc8477236c94b4c501de8cfdf5b", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -54,6 +54,7 @@ Resolver::Resolver ()\n     name_scope (Scope (mappings->get_current_crate ())),\n     type_scope (Scope (mappings->get_current_crate ())),\n     label_scope (Scope (mappings->get_current_crate ())),\n+    macro_scope (Scope (mappings->get_current_crate ())),\n     global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n {\n   generate_builtins ();\n@@ -93,6 +94,13 @@ Resolver::push_new_label_rib (Rib *r)\n   label_ribs[r->get_node_id ()] = r;\n }\n \n+void\n+Resolver::push_new_macro_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  macro_ribs[r->get_node_id ()] = r;\n+}\n+\n bool\n Resolver::find_name_rib (NodeId id, Rib **rib)\n {\n@@ -115,6 +123,17 @@ Resolver::find_type_rib (NodeId id, Rib **rib)\n   return true;\n }\n \n+bool\n+Resolver::find_macro_rib (NodeId id, Rib **rib)\n+{\n+  auto it = macro_ribs.find (id);\n+  if (it == macro_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n void\n Resolver::insert_builtin_types (Rib *r)\n {\n@@ -281,6 +300,27 @@ Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n   return true;\n }\n \n+void\n+Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  rust_assert (it == resolved_macros.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  if (it == resolved_macros.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n // NameResolution\n \n NameResolution *"}, {"sha": "208448036d904fb791a95311aaf6d0693f02d6d3", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -274,10 +274,12 @@ class Resolver\n   void push_new_name_rib (Rib *r);\n   void push_new_type_rib (Rib *r);\n   void push_new_label_rib (Rib *r);\n+  void push_new_macro_rib (Rib *r);\n \n   bool find_name_rib (NodeId id, Rib **rib);\n   bool find_type_rib (NodeId id, Rib **rib);\n   bool find_label_rib (NodeId id, Rib **rib);\n+  bool find_macro_rib (NodeId id, Rib **rib);\n \n   void insert_new_definition (NodeId id, Definition def);\n   bool lookup_definition (NodeId id, Definition *def);\n@@ -291,10 +293,14 @@ class Resolver\n   void insert_resolved_label (NodeId refId, NodeId defId);\n   bool lookup_resolved_label (NodeId refId, NodeId *defId);\n \n+  void insert_resolved_macro (NodeId refId, NodeId defId);\n+  bool lookup_resolved_macro (NodeId refId, NodeId *defId);\n+\n   // proxy for scoping\n   Scope &get_name_scope () { return name_scope; }\n   Scope &get_type_scope () { return type_scope; }\n   Scope &get_label_scope () { return label_scope; }\n+  Scope &get_macro_scope () { return macro_scope; }\n \n   NodeId get_global_type_node_id () { return global_type_node_id; }\n \n@@ -371,6 +377,7 @@ class Resolver\n   Scope name_scope;\n   Scope type_scope;\n   Scope label_scope;\n+  Scope macro_scope;\n \n   NodeId global_type_node_id;\n   NodeId unit_ty_node_id;\n@@ -379,6 +386,7 @@ class Resolver\n   std::map<NodeId, Rib *> name_ribs;\n   std::map<NodeId, Rib *> type_ribs;\n   std::map<NodeId, Rib *> label_ribs;\n+  std::map<NodeId, Rib *> macro_ribs;\n \n   // map any Node to its Definition\n   // ie any name or type usage\n@@ -395,6 +403,7 @@ class Resolver\n   std::map<NodeId, NodeId> resolved_names;\n   std::map<NodeId, NodeId> resolved_types;\n   std::map<NodeId, NodeId> resolved_labels;\n+  std::map<NodeId, NodeId> resolved_macros;\n \n   // map of resolved names mutability flag\n   std::map<NodeId, bool> decl_mutability;"}, {"sha": "53daa42dadf99e2347e9f32bab4281e4d4d7e2c2", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -57,6 +57,12 @@ class TypeResolverDump : public TypeCheckBase\n       += indent () + \"union \" + type_string (union_decl.get_mappings ()) + \"\\n\";\n   }\n \n+  void visit (HIR::TupleStruct &struct_decl) override\n+  {\n+    dump += indent () + \"struct\" + type_string (struct_decl.get_mappings ())\n+\t    + \"\\n\";\n+  }\n+\n   void visit (HIR::ImplBlock &impl_block) override\n   {\n     dump += indent () + \"impl \""}, {"sha": "1348e29e5f558702ab1280b53ac961da20fe7465", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -738,5 +738,25 @@ Mappings::iterate_trait_items (\n     }\n }\n \n+void\n+Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n+{\n+  auto it = macroMappings.find (macro->get_node_id ());\n+  rust_assert (it == macroMappings.end ());\n+\n+  macroMappings[macro->get_node_id ()] = macro;\n+}\n+\n+bool\n+Mappings::lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def)\n+{\n+  auto it = macroMappings.find (id);\n+  if (it == macroMappings.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "799351b41fdc7b987629b96f2d707c83d9f304e2", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -559,6 +559,10 @@ class Mappings\n     return true;\n   }\n \n+  void insert_macro_def (AST::MacroRulesDefinition *macro);\n+\n+  bool lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def);\n+\n private:\n   Mappings ();\n \n@@ -612,6 +616,9 @@ class Mappings\n   // all hirid nodes\n   std::map<CrateNum, std::set<HirId>> hirNodesWithinCrate;\n \n+  // macros\n+  std::map<NodeId, AST::MacroRulesDefinition *> macroMappings;\n+\n   // crate names\n   std::map<CrateNum, std::string> crate_names;\n };"}, {"sha": "652d2d8fe5bf722a80e84ab54c525151cf5ee580", "filename": "gcc/testsuite/rust/execute/torture/macros1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros1.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! add {\n+    ($a:expr,$b:expr) => {\n+        $a + $b\n+    };\n+}\n+\n+fn test() -> i32 {\n+    add!(1 + 2, 3)\n+}\n+\n+fn main() -> i32 {\n+    test() - 6\n+}"}, {"sha": "0116bd131f243a5284442e56ddd8657fa249027b", "filename": "gcc/testsuite/rust/execute/torture/macros2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,40 @@\n+// { dg-output \"arg\\narg\\narg\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        let r_s = \"arg\\n\\0\";\n+        let s_p = r_s as *const str;\n+        let c_p = s_p as *const i8;\n+\n+        printf(c_p);\n+    }\n+}\n+\n+macro_rules! kw0 {\n+    (keyword) => {\n+        f()\n+    };\n+}\n+\n+macro_rules! kw1 {\n+    (fn) => {\n+        f()\n+    };\n+}\n+\n+macro_rules! kw2 {\n+    (kw0 kw1 kw3) => {\n+        f()\n+    };\n+}\n+\n+fn main() -> i32 {\n+    kw0!(keyword);\n+    kw1!(fn);\n+    kw2!(kw0 kw1 kw3);\n+\n+    0\n+}"}, {"sha": "c1f5a5397da6d0bcd7a60af31e9f7c3abf6477fa", "filename": "gcc/testsuite/rust/execute/torture/macros3.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,61 @@\n+// { dg-output \"invok\\ninvok\\ninvok\\ninvok\\ninvok\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        let r_s = \"invok\\n\\0\";\n+        let s_p = r_s as *const str;\n+        let c_p = s_p as *const i8;\n+\n+        printf(c_p);\n+    }\n+}\n+\n+macro_rules! invocation0 {\n+    (valid) => {\n+        f()\n+    };\n+    () => {};\n+}\n+\n+macro_rules! invocation1 {\n+    (valid) => {};\n+    () => {\n+        f()\n+    };\n+}\n+\n+macro_rules! invocation2 {\n+    (valid) => {\n+        f()\n+    };\n+    (invalid) => {};\n+}\n+\n+macro_rules! invocation3 {\n+    (this is a valid invocation) => {\n+        f()\n+    };\n+    (not this one) => {};\n+}\n+\n+macro_rules! invocation4 {\n+    (fn f() {}) => {\n+        f()\n+    };\n+    (not a keyword) => {};\n+}\n+\n+fn main() -> i32 {\n+    invocation0!(valid);\n+    invocation1!();\n+    invocation2!(valid);\n+    invocation3!(this is a valid invocation);\n+    invocation4!(\n+        fn f() {}\n+    );\n+\n+    0\n+}"}, {"sha": "3303bfa58aa6d711746b0c1aaf669966aebc93b5", "filename": "gcc/testsuite/rust/execute/torture/macros4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros4.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,15 @@\n+macro_rules! add {\n+    ($a:expr,$b:expr) => {\n+        $a + $b\n+    };\n+    ($a:expr) => {\n+        $a\n+    };\n+}\n+\n+fn main() -> i32 {\n+    let mut x = add!(1);\n+    x += add!(2, 3);\n+\n+    x - 6\n+}"}, {"sha": "822665494a4519a883a957f935528d9b926a8103", "filename": "gcc/testsuite/rust/execute/torture/macros5.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros5.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! add {\n+    ($a:expr,$b:expr) => {{\n+        $a + $b\n+    }};\n+}\n+\n+fn test() -> i32 {\n+    add!(1, 2)\n+}\n+\n+fn main() -> i32 {\n+    test() - 3\n+}"}, {"sha": "652a765d5a881b7bc0ce80bcc420cfee71220e72", "filename": "gcc/testsuite/rust/execute/torture/macros6.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros6.rs?ref=9fb06d66cef70584e7aa2fa3a6ad22ef7def6b84", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! Test {\n+    ($a:ident, $b:ty) => {\n+        struct $a($b);\n+    };\n+}\n+\n+Test!(Foo, i32);\n+\n+fn main() -> i32 {\n+    let a = Foo(123);\n+    a.0 - 123\n+}"}, {"sha": "49bd6a8c02655b1507f9d5689ea114133427c24e", "filename": "gcc/testsuite/rust/execute/xfail/macro2.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752bf6c80a922e09edf5bcb53e15e08e83057a7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752bf6c80a922e09edf5bcb53e15e08e83057a7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro2.rs?ref=752bf6c80a922e09edf5bcb53e15e08e83057a7f", "patch": "@@ -1,30 +0,0 @@\n-// { dg-output \"arg\\narg\\n\" }\n-extern \"C\" {\n-    fn printf(s: *const i8, ...);\n-}\n-\n-fn f() {\n-    let r_s = \"arg\\n\\0\";\n-    let s_p = r_s as *const str;\n-    let c_p = s_p as *const i8;\n-\n-    printf(c_p);\n-}\n-\n-macro_rules! kw0 {\n-    (keyword) => { f() };\n-}\n-\n-macro_rules! kw1 {\n-    (fn) => { f() };\n-}\n-\n-macro_rules! kw2 {\n-    (kw0 kw1 kw3) => { f() };\n-}\n-\n-fn main() {\n-    kw0!(keyword);\n-    kw1!(fn);\n-    kw2!(kw0 kw1 kw3);\n-}"}, {"sha": "0d99d7165ac40bc32c8e4b69c8540df2ad3bf102", "filename": "gcc/testsuite/rust/execute/xfail/macro3.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752bf6c80a922e09edf5bcb53e15e08e83057a7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752bf6c80a922e09edf5bcb53e15e08e83057a7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Fxfail%2Fmacro3.rs?ref=752bf6c80a922e09edf5bcb53e15e08e83057a7f", "patch": "@@ -1,45 +0,0 @@\n-// { dg-output \"invok\\ninvok\\ninvok\\ninvok\\ninvok\\n\" }\n-extern \"C\" {\n-    fn printf(s: *const i8, ...);\n-}\n-\n-fn f() {\n-    let r_s = \"invok\\n\\0\";\n-    let s_p = r_s as *const str;\n-    let c_p = s_p as *const i8;\n-\n-    printf(c_p);\n-}\n-\n-macro_rules! invocation0 {\n-    (valid) => { f() };\n-    () => { };\n-}\n-\n-macro_rules! invocation1 {\n-    (valid) => { };\n-    () => { f() };\n-}\n-\n-macro_rules! invocation2 {\n-    (valid) => { f() };\n-    (invalid) => { };\n-}\n-\n-macro_rules! invocation3 {\n-    (this is a valid invocation) => { f() };\n-    (not this one) => { };\n-}\n-\n-macro_rules! invocation4 {\n-    (fn f() {}) => { f() };\n-    (not a keyword) => { };\n-}\n-\n-fn main() {\n-    invocation0!(valid);\n-    invocation1!();\n-    invocation2!(valid);\n-    invocation3!(this is a valid invocation);\n-    invocation4!(fn f() {});\n-}"}]}