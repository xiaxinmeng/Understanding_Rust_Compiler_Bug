{"sha": "37678631a8a4464bc16c8d02dfaa4086f6038cb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc2Nzg2MzFhOGE0NDY0YmMxNmM4ZDAyZGZhYTQwODZmNjAzOGNiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-08-19T05:55:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-08-19T05:55:20Z"}, "message": "re PR lto/45375 ([meta-bug] Issues with building Mozilla (i.e. Firefox) with LTO)\n\n\n\tPR lto/45375\n\t* ipa-inline.c (want_inline_small_function_p): Bypass\n\tinline limits for hinted functions.\n\t(edge_badness): Dump hints; decrease badness for hinted funcitons.\n\t* ipa-inline.h (enum inline_hints_vals): New enum.\n\t(inline_hints): New type.\n\t(edge_growth_cache_entry): Add hints.\n\t(dump_inline_summary): Update.\n\t(dump_inline_hints): Declare.\n\t(do_estimate_edge_hints): Declare.\n\t(estimate_edge_hints): New inline function.\n\t(reset_edge_growth_cache): Update.\n\t* predict.c (cgraph_maybe_hot_edge_p): Do not ice on indirect edges.\n\t* ipa-inline-analysis.c (dump_inline_hints): New function.\n\t(estimate_edge_devirt_benefit): Return true when function should be\n\thinted.\n\t(estimate_calls_size_and_time): New hints argument; set it when\n\tdevritualization happens.\n\t(estimate_node_size_and_time): New hints argument.\n\t(do_estimate_edge_time): Cache hints.\n\t(do_estimate_edge_growth): Update.\t\n\t(do_estimate_edge_hints): New function\n\nFrom-SVN: r190509", "tree": {"sha": "032d8e752b8a993f1aa19d59d320266d25238378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/032d8e752b8a993f1aa19d59d320266d25238378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37678631a8a4464bc16c8d02dfaa4086f6038cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37678631a8a4464bc16c8d02dfaa4086f6038cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37678631a8a4464bc16c8d02dfaa4086f6038cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37678631a8a4464bc16c8d02dfaa4086f6038cb1/comments", "author": null, "committer": null, "parents": [{"sha": "ecfdae6f116a6c154d57a4fced789d6f1b396c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecfdae6f116a6c154d57a4fced789d6f1b396c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecfdae6f116a6c154d57a4fced789d6f1b396c07"}], "stats": {"total": 215, "additions": 165, "deletions": 50}, "files": [{"sha": "6dabed6c468422083db23ba19e098085ce4f6dba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -1,3 +1,28 @@\n+2012-08-18  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/45375\n+\t* ipa-inline.c (want_inline_small_function_p): Bypass\n+\tinline limits for hinted functions.\n+\t(edge_badness): Dump hints; decrease badness for hinted funcitons.\n+\t* ipa-inline.h (enum inline_hints_vals): New enum.\n+\t(inline_hints): New type.\n+\t(edge_growth_cache_entry): Add hints.\n+\t(dump_inline_summary): Update.\n+\t(dump_inline_hints): Declare.\n+\t(do_estimate_edge_hints): Declare.\n+\t(estimate_edge_hints): New inline function.\n+\t(reset_edge_growth_cache): Update.\n+\t* predict.c (cgraph_maybe_hot_edge_p): Do not ice on indirect edges.\n+\t* ipa-inline-analysis.c (dump_inline_hints): New function.\n+\t(estimate_edge_devirt_benefit): Return true when function should be\n+\thinted.\n+\t(estimate_calls_size_and_time): New hints argument; set it when\n+\tdevritualization happens.\n+\t(estimate_node_size_and_time): New hints argument.\n+\t(do_estimate_edge_time): Cache hints.\n+\t(do_estimate_edge_growth): Update.\t\n+\t(do_estimate_edge_hints): New function\n+\n 2012-08-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/53823"}, {"sha": "c30e81a88f150762925193248feeda102bea1e2c", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -615,6 +615,22 @@ dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n }\n \n \n+/* Dump inline hints.  */\n+void\n+dump_inline_hints (FILE *f, inline_hints hints)\n+{\n+  if (!hints)\n+    return;\n+  fprintf (f, \"inline hints:\");\n+  if (hints & INLINE_HINT_indirect_call)\n+    {\n+      hints &= ~INLINE_HINT_indirect_call;\n+      fprintf (f, \" indirect_call\");\n+    }\n+  gcc_assert (!hints);\n+}\n+\n+\n /* Record SIZE and TIME under condition PRED into the inline summary.  */\n \n static void\n@@ -2302,7 +2318,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n /* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS and\n    KNOWN_BINFOS.  */\n \n-static void\n+static bool\n estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t\t\t      int *size, int *time, int prob,\n \t\t\t      VEC (tree, heap) *known_vals,\n@@ -2311,14 +2327,16 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n {\n   tree target;\n   int time_diff, size_diff;\n+  struct cgraph_node *callee;\n+  struct inline_summary *isummary;\n \n   if (!known_vals && !known_binfos)\n-    return;\n+    return false;\n \n   target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos,\n \t\t\t\t\t known_aggs);\n   if (!target)\n-    return;\n+    return false;\n \n   /* Account for difference in cost between indirect and direct calls.  */\n   size_diff = ((eni_size_weights.indirect_call_cost - eni_size_weights.call_cost)\n@@ -2328,40 +2346,11 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t       * INLINE_TIME_SCALE * prob / REG_BR_PROB_BASE);\n   *time -= time_diff;\n \n-  /* TODO: This code is trying to benefit indirect calls that will be inlined later.\n-     The logic however do not belong into local size/time estimates and can not be\n-     done here, or the accounting of changes will get wrong and we result with \n-     negative function body sizes.  We need to introduce infrastructure for independent\n-     benefits to the inliner.  */\n-#if 0\n-  struct cgraph_node *callee;\n-  struct inline_summary *isummary;\n-  int edge_size, edge_time, time_diff, size_diff;\n-\n   callee = cgraph_get_node (target);\n   if (!callee || !callee->analyzed)\n-    return;\n+    return false;\n   isummary = inline_summary (callee);\n-  if (!isummary->inlinable)\n-    return;\n-\n-  estimate_edge_size_and_time (ie, &edge_size, &edge_time, prob);\n-\n-  /* Count benefit only from functions that definitely will be inlined\n-     if additional context from NODE's caller were available. \n-\n-     We just account overall size change by inlining.  TODO:\n-     we really need to add sort of benefit metrics for these kind of\n-     cases. */\n-  if (edge_size - size_diff >= isummary->size * INLINE_SIZE_SCALE)\n-    {\n-      /* Subtract size and time that we added for edge IE.  */\n-      *size -= edge_size - size_diff;\n-\n-      /* Account inlined call.  */\n-      *size += isummary->size * INLINE_SIZE_SCALE;\n-    }\n-#endif\n+  return isummary->inlinable;\n }\n \n \n@@ -2371,6 +2360,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n+\t\t\t      inline_hints *hints,\n \t\t\t      clause_t possible_truths,\n \t\t\t      VEC (tree, heap) *known_vals,\n \t\t\t      VEC (tree, heap) *known_binfos,\n@@ -2389,7 +2379,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n \t    }\n \t  else\n-\t    estimate_calls_size_and_time (e->callee, size, time,\n+\t    estimate_calls_size_and_time (e->callee, size, time, hints,\n \t\t\t\t\t  possible_truths,\n \t\t\t\t\t  known_vals, known_binfos, known_aggs);\n \t}\n@@ -2400,8 +2390,11 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n       if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n \t{\n \t  estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n-\t  estimate_edge_devirt_benefit (e, size, time, REG_BR_PROB_BASE,\n-\t\t\t\t\tknown_vals, known_binfos, known_aggs);\n+\t  if (estimate_edge_devirt_benefit (e, size, time, REG_BR_PROB_BASE,\n+\t\t\t\t\t    known_vals, known_binfos, known_aggs)\n+\t      && hints\n+\t      && cgraph_maybe_hot_edge_p (e))\n+\t    *hints |= INLINE_HINT_indirect_call;\n \t}\n     }\n }\n@@ -2418,12 +2411,14 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     VEC (tree, heap) *known_binfos,\n \t\t\t     VEC (ipa_agg_jump_function_p, heap) *known_aggs,\n \t\t       \t     int *ret_size, int *ret_time,\n+\t\t\t     inline_hints *ret_hints,\n \t\t\t     VEC (inline_param_summary_t, heap)\n \t\t\t       *inline_param_summary)\n {\n   struct inline_summary *info = inline_summary (node);\n   size_time_entry *e;\n   int size = 0, time = 0;\n+  inline_hints hints = 0;\n   int i;\n \n   if (dump_file\n@@ -2467,7 +2462,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n-  estimate_calls_size_and_time (node, &size, &time, possible_truths,\n+  estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n \t\t\t\tknown_vals, known_binfos, known_aggs);\n   time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n@@ -2480,6 +2475,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     *ret_time = time;\n   if (ret_size)\n     *ret_size = size;\n+  if (ret_hints)\n+    *ret_hints = hints;\n   return;\n }\n \n@@ -2499,7 +2496,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \n   clause = evaluate_conditions_for_known_args (node, false, known_vals, NULL);\n   estimate_node_size_and_time (node, clause, known_vals, known_binfos, NULL,\n-\t\t\t       ret_size, ret_time,\n+\t\t\t       ret_size, ret_time, NULL,\n \t\t\t       NULL);\n }\n \n@@ -2871,7 +2868,7 @@ inline_update_overall_summary (struct cgraph_node *node)\n   info->time = 0;\n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n     info->size += e->size, info->time += e->time;\n-  estimate_calls_size_and_time (node, &info->size, &info->time,\n+  estimate_calls_size_and_time (node, &info->size, &info->time, NULL,\n \t\t\t\t~(clause_t)(1 << predicate_false_condition),\n \t\t\t\tNULL, NULL, NULL);\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n@@ -2890,6 +2887,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n {\n   int time;\n   int size;\n+  inline_hints hints;\n   gcov_type ret;\n   struct cgraph_node *callee;\n   clause_t clause;\n@@ -2905,7 +2903,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t\t\t\t&clause, &known_vals, &known_binfos,\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, &size, &time, es->param);\n+\t\t\t       known_aggs, &size, &time, &hints, es->param);\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n   VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n@@ -2929,6 +2927,8 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n       gcc_checking_assert (es->call_stmt_size);\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).size\n \t= ret_size + (ret_size >= 0);\n+      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).hints\n+\t= hints + 1;\n     }\n   return ret;\n }\n@@ -2967,7 +2967,7 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n \t\t\t\t&clause, &known_vals, &known_binfos,\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, &size, NULL, NULL);\n+\t\t\t       known_aggs, &size, NULL, NULL, NULL);\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n   VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n@@ -2976,6 +2976,47 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n }\n \n \n+/* Estimate the growth of the caller when inlining EDGE.\n+   Only to be called via estimate_edge_size.  */\n+\n+inline_hints\n+do_estimate_edge_hints (struct cgraph_edge *edge)\n+{\n+  inline_hints hints;\n+  struct cgraph_node *callee;\n+  clause_t clause;\n+  VEC (tree, heap) *known_vals;\n+  VEC (tree, heap) *known_binfos;\n+  VEC (ipa_agg_jump_function_p, heap) *known_aggs;\n+\n+  /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n+\n+  if (edge_growth_cache)\n+    {\n+      do_estimate_edge_time (edge);\n+      hints = VEC_index (edge_growth_cache_entry,\n+\t\t\tedge_growth_cache,\n+\t\t\tedge->uid).hints;\n+      gcc_checking_assert (hints);\n+      return hints - 1;\n+    }\n+\n+  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+\n+  /* Early inliner runs without caching, go ahead and do the dirty work.  */\n+  gcc_checking_assert (edge->inline_failed);\n+  evaluate_properties_for_edge (edge, true,\n+\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&known_aggs);\n+  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n+\t\t\t       known_aggs, NULL, NULL, &hints, NULL);\n+  VEC_free (tree, heap, known_vals);\n+  VEC_free (tree, heap, known_binfos);\n+  VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n+  return hints;\n+}\n+\n+\n /* Estimate self time of the function NODE after inlining EDGE.  */\n \n int"}, {"sha": "55d9a521c32d943500f71b61d7d1b716a8822d90", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -472,11 +472,15 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   else\n     {\n       int growth = estimate_edge_growth (e);\n+      inline_hints hints = estimate_edge_hints (e);\n \n       if (growth <= 0)\n \t;\n+      /* Apply MAX_INLINE_INSNS_SINGLE limit.  Do not do so when\n+\t hints suggests that inlining given function is very profitable.  */\n       else if (DECL_DECLARED_INLINE_P (callee->symbol.decl)\n-\t       && growth >= MAX_INLINE_INSNS_SINGLE)\n+\t       && growth >= MAX_INLINE_INSNS_SINGLE\n+\t       && !(hints & INLINE_HINT_indirect_call))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n@@ -523,8 +527,14 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n           e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t  want_inline = false;\n \t}\n+      /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline\n+\t Upgrade it to MAX_INLINE_INSNS_SINGLE when hints suggests that\n+\t inlining given function is very profitable.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n-\t       && growth >= MAX_INLINE_INSNS_AUTO)\n+\t       && growth >= ((hints & INLINE_HINT_indirect_call)\n+\t\t\t     ? MAX (MAX_INLINE_INSNS_AUTO,\n+\t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n+\t\t\t     : MAX_INLINE_INSNS_AUTO))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n \t  want_inline = false;\n@@ -743,21 +753,25 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee,\n \t\t\t\t\t\t\t      NULL);\n   struct inline_summary *callee_info = inline_summary (callee);\n+  inline_hints hints;\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n   time_growth = estimate_edge_time (edge);\n+  hints = estimate_edge_hints (edge);\n \n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       xstrdup (cgraph_node_name (edge->caller)),\n \t       xstrdup (cgraph_node_name (callee)));\n-      fprintf (dump_file, \"      size growth %i, time growth %i\\n\",\n+      fprintf (dump_file, \"      size growth %i, time growth %i \",\n \t       growth,\n \t       time_growth);\n+      dump_inline_hints (dump_file, hints);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   /* Always prefer inlining saving code size.  */\n@@ -849,6 +863,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  if (dump)\n \t    fprintf (dump_file, \"Badness overflow\\n\");\n \t}\n+      if (hints & INLINE_HINT_indirect_call)\n+\tbadness /= 8;\n       if (dump)\n \t{\n \t  fprintf (dump_file,"}, {"sha": "fca99e629b0046e85cfb732ad8e3bc90a9561c19", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -42,6 +42,13 @@ typedef struct GTY(()) condition\n     unsigned by_ref : 1;\n   } condition;\n \n+/* Inline hints are reasons why inline heuristics should preffer inlining given function.\n+   They are represtented as bitmap of the following values.  */\n+enum inline_hints_vals {\n+  INLINE_HINT_indirect_call = 1\n+};\n+typedef int inline_hints;\n+\n DEF_VEC_O (condition);\n DEF_VEC_ALLOC_O (condition, gc);\n \n@@ -158,6 +165,7 @@ extern VEC(inline_edge_summary_t,heap) *inline_edge_summary_vec;\n typedef struct edge_growth_cache_entry\n {\n   int time, size;\n+  inline_hints hints;\n } edge_growth_cache_entry;\n DEF_VEC_O(edge_growth_cache_entry);\n DEF_VEC_ALLOC_O(edge_growth_cache_entry,heap);\n@@ -168,7 +176,8 @@ extern VEC(edge_growth_cache_entry,heap) *edge_growth_cache;\n /* In ipa-inline-analysis.c  */\n void debug_inline_summary (struct cgraph_node *);\n void dump_inline_summaries (FILE *f);\n-void dump_inline_summary (FILE * f, struct cgraph_node *node);\n+void dump_inline_summary (FILE *f, struct cgraph_node *node);\n+void dump_inline_hints (FILE *f, inline_hints);\n void inline_generate_summary (void);\n void inline_read_summary (void);\n void inline_write_summary (void);\n@@ -185,6 +194,7 @@ void inline_merge_summary (struct cgraph_edge *edge);\n void inline_update_overall_summary (struct cgraph_node *node);\n int do_estimate_edge_growth (struct cgraph_edge *edge);\n int do_estimate_edge_time (struct cgraph_edge *edge);\n+inline_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n void initialize_growth_caches (void);\n void free_growth_caches (void);\n void compute_inline_parameters (struct cgraph_node *, bool);\n@@ -257,6 +267,22 @@ estimate_edge_time (struct cgraph_edge *edge)\n }\n \n \n+/* Return estimated callee runtime increase after inlning\n+   EDGE.  */\n+\n+static inline inline_hints\n+estimate_edge_hints (struct cgraph_edge *edge)\n+{\n+  inline_hints ret;\n+  if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) <= edge->uid\n+      || !(ret = VEC_index (edge_growth_cache_entry,\n+\t\t\t    edge_growth_cache,\n+\t\t\t    edge->uid).hints))\n+    return do_estimate_edge_time (edge);\n+  return ret - 1;\n+}\n+\n+\n /* Reset cached value for NODE.  */\n \n static inline void\n@@ -273,7 +299,7 @@ reset_edge_growth_cache (struct cgraph_edge *edge)\n {\n   if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) > edge->uid)\n     {\n-      struct edge_growth_cache_entry zero = {0, 0};\n+      struct edge_growth_cache_entry zero = {0, 0, 0};\n       VEC_replace (edge_growth_cache_entry, edge_growth_cache, edge->uid, zero);\n     }\n }"}, {"sha": "e1a064d6cde2323dfdd31884527d43d050f45be2", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -165,10 +165,12 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n \t  <= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n     return false;\n   if (edge->caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      || edge->callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+      || (edge->callee\n+\t  && edge->callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n     return false;\n   if (edge->caller->frequency > NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      && edge->callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE)\n+      && (edge->callee\n+\t  && edge->callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE))\n     return false;\n   if (optimize_size)\n     return false;"}, {"sha": "378e778f56a85684549d3595707699fd6cf95266", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -1,3 +1,7 @@\n+2012-08-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/iinline-1.c: Update testcase to test inline hints.\n+\n 2012-08-18  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/39290"}, {"sha": "860b3e5720436f0a2ca0d209530dcb4e5c112e4f", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37678631a8a4464bc16c8d02dfaa4086f6038cb1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c?ref=37678631a8a4464bc16c8d02dfaa4086f6038cb1", "patch": "@@ -1,7 +1,7 @@\n /* Verify that simple indirect calls are inlined even without early\n    inlining..  */\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining -fno-ipa-cp\"  } */\n \n extern void non_existent(int);\n \n@@ -22,5 +22,6 @@ int test (void)\n   return 0;\n }\n \n+/* { dg-final { scan-ipa-dump \"indirect_call\"  \"inline\"  } } */\n /* { dg-final { scan-ipa-dump \"hooray\\[^\\\\n\\]*inline copy in test\"  \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}