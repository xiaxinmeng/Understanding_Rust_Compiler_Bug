{"sha": "7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjYmNhOWQwMjIwNmI4ZmNiYTI3MTBkYWE5ZTBhMzY2YWY2NWE4Yg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@cs.tamu.edu", "date": "2009-10-01T05:13:56Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2009-10-01T05:13:56Z"}, "message": "tree.h (tree_decl_common::lang_flag_8): New.\n\ngcc/\n\t* tree.h (tree_decl_common::lang_flag_8): New.\n\t* c-common.c (c_common_reswords): Include \"constexpr\" as C++0x\n\tkeyword. \n\t* c-common.h (RID_CONSTEXPR): New.\n\ngcc/cp/\n\t* decl.c (check_for_uninitialized_const_var): Check constexpr\n\tvariables too.\n\t(build_ptrmemfunc_type): Make the result a literal type.\n\t(build_ptrmem_type): Likewise.\n\t(grokdeclarator): Handle `constexpr'.\n\t(check_tag_decl): Reject `constexpr'.\n\t(check_function_type): Check constexpr functions.\n\t* cp-tree.h (ds_constexpr): New cp_decl_spec enumerator.\n\t(CLASSTYPE_LITERAL_P): New.\n\t(lang_type_class::is_literal): New.\n\t(lang_type_class::dummy): Adjust width.\n\t(literal_type_p): Declare.\n\t* parser.c (cp_parser_check_decl_spec): Print it.\n\t(cp_parser_decl_specifier_seq): Accept \"constexpr\".\n\t* semantics.c (validate_constexpr_fundecl): Define.\n\t(literal_type_p): Define.\n\nFrom-SVN: r152358", "tree": {"sha": "dcaed29421b884419d98bd0b4cb2308838e9ea60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcaed29421b884419d98bd0b4cb2308838e9ea60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/comments", "author": null, "committer": null, "parents": [{"sha": "ec30ab2c798327e9d538b985a410ba79487ae801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec30ab2c798327e9d538b985a410ba79487ae801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec30ab2c798327e9d538b985a410ba79487ae801"}], "stats": {"total": 258, "additions": 232, "deletions": 26}, "files": [{"sha": "e80433ae8b8668d83754facf29d9785f842a514b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -1,3 +1,10 @@\n+2009-09-30  Gabriel Dos Reis  <gdr@cs.tamu.edu>\n+\n+\t* tree.h (tree_decl_common::lang_flag_8): New.\n+\t* c-common.c (c_common_reswords): Include \"constexpr\" as C++0x\n+\tkeyword. \n+\t* c-common.h (RID_CONSTEXPR): New.\n+\n 2009-09-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_gimplify_va_arg_1):"}, {"sha": "4de92d0de95674bd9f4a7e03338cac3783918632", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -631,6 +631,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"char32_t\",\t\tRID_CHAR32,\tD_CXXONLY | D_CXX0X | D_CXXWARN },\n   { \"class\",\t\tRID_CLASS,\tD_CXX_OBJC | D_CXXWARN },\n   { \"const\",\t\tRID_CONST,\t0 },\n+  { \"constexpr\",\tRID_CONSTEXPR,\tD_CXXONLY | D_CXX0X | D_CXXWARN },\n   { \"const_cast\",\tRID_CONSTCAST,\tD_CXXONLY | D_CXXWARN },\n   { \"continue\",\t\tRID_CONTINUE,\t0 },\n   { \"decltype\",         RID_DECLTYPE,   D_CXXONLY | D_CXX0X | D_CXXWARN },"}, {"sha": "c1655ae69ff09e50545191f95dcc4c7503745e11", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -114,7 +114,7 @@ enum rid\n   RID_IS_UNION,\n \n   /* C++0x */\n-  RID_STATIC_ASSERT, RID_DECLTYPE,\n+  RID_STATIC_ASSERT, RID_CONSTEXPR, RID_DECLTYPE,\n \n   /* Objective-C */\n   RID_AT_ENCODE,   RID_AT_END,"}, {"sha": "a25f62b9a915068757ba084ddcd6a121d083ccd5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -1,3 +1,22 @@\n+2009-09-30  Gabriel Dos Reis  <gdr@cs.tamu.edu>\n+\n+\t* decl.c (check_for_uninitialized_const_var): Check constexpr\n+\tvariables too.\n+\t(build_ptrmemfunc_type): Make the result a literal type.\n+\t(build_ptrmem_type): Likewise.\n+\t(grokdeclarator): Handle `constexpr'.\n+\t(check_tag_decl): Reject `constexpr'.\n+\t(check_function_type): Check constexpr functions.\n+\t* cp-tree.h (ds_constexpr): New cp_decl_spec enumerator.\n+\t(CLASSTYPE_LITERAL_P): New.\n+\t(lang_type_class::is_literal): New.\n+\t(lang_type_class::dummy): Adjust width.\n+\t(literal_type_p): Declare.\n+\t* parser.c (cp_parser_check_decl_spec): Print it.\n+\t(cp_parser_decl_specifier_seq): Accept \"constexpr\".\n+\t* semantics.c (validate_constexpr_fundecl): Define.\n+\t(literal_type_p): Define.\n+\n 2009-09-30  Jason Merrill  <jason@redhat.com>\n \n \t* semantics.c (lambda_expr_this_capture): Fix default capture"}, {"sha": "ab4a6a71abdf6bc8a7121a8932113582130d2095", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -112,11 +112,13 @@ framework extensions, you must include this file before toplev.h, not after.\n    6: IDENTIFIER_REPO_CHOSEN (in IDENTIFIER_NODE)\n       DECL_CONSTRUCTION_VTABLE_P (in VAR_DECL)\n       TYPE_MARKED_P (in _TYPE)\n+   7: DECL_DEAD_FOR_LOCAL (in VAR_DECL)\n+   8: DECL_DECLARED_CONSTEXPR_P (in VAR_DECL, FUNCTION_DECL)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n    1: TYPE_HAS_USER_CONSTRUCTOR.\n-   2: Unused\n+   2: unused\n    3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n    5: CLASS_TYPE_P (in RECORD_TYPE and UNION_TYPE)\n@@ -1211,6 +1213,7 @@ struct GTY(()) lang_type_class {\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n   unsigned lazy_move_ctor : 1;\n+  unsigned is_literal : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1219,7 +1222,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 8;\n+  unsigned dummy : 7;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -2189,6 +2192,10 @@ struct GTY(()) lang_decl {\n #define DECL_REPO_AVAILABLE_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->u.base.repo_available_p)\n \n+/* True if DECL is declared 'constexpr'.  */\n+#define DECL_DECLARED_CONSTEXPR_P(DECL) \\\n+  DECL_LANG_FLAG_8 (VAR_OR_FUNCTION_DECL_CHECK (DECL))\n+\n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n #define DECL_PRETTY_FUNCTION_P(NODE) \\\n@@ -2846,6 +2853,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P(TYPE) \\\n    (UNSCOPED_ENUM_P (TYPE) || CP_INTEGRAL_TYPE_P (TYPE))\n \n+/* True if the class type TYPE is a literal type.  */\n+#define CLASSTYPE_LITERAL_P(TYPE)              \\\n+   (LANG_TYPE_CLASS_CHECK (TYPE)->is_literal)\n+\n /* [basic.fundamental]\n \n    Integral and floating types are collectively called arithmetic\n@@ -4190,6 +4201,7 @@ typedef enum cp_decl_spec {\n   ds_explicit,\n   ds_friend,\n   ds_typedef,\n+  ds_constexpr,\n   ds_complex,\n   ds_thread,\n   ds_last\n@@ -4937,6 +4949,9 @@ extern tree begin_handler\t\t\t(void);\n extern void finish_handler_parms\t\t(tree, tree);\n extern void finish_handler\t\t\t(tree);\n extern void finish_cleanup\t\t\t(tree, tree);\n+extern bool literal_type_p (tree);\n+extern tree validate_constexpr_fundecl (tree);\n+extern tree ensure_literal_type_for_constexpr_object (tree);\n \n enum {\n   BCS_NO_SCOPE = 1,"}, {"sha": "cb2827dfba49c6111de944980c93ec40cd2942d3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -3231,7 +3231,7 @@ record_builtin_java_type (const char* name, int size)\n     }\n   else\n     { /* \"__java_float\" or \"\"__java_double\".  */\n-      type = make_node (REAL_TYPE);\n+      type = cxx_make_type (REAL_TYPE);\n       TYPE_PRECISION (type) = - size;\n       layout_type (type);\n     }\n@@ -3397,7 +3397,7 @@ cxx_init_decl_processing (void)\n \n   /* C++ extensions */\n \n-  unknown_type_node = make_node (UNKNOWN_TYPE);\n+  unknown_type_node = cxx_make_type (UNKNOWN_TYPE);\n   record_unknown_type (unknown_type_node, \"unknown type\");\n \n   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */\n@@ -3408,13 +3408,13 @@ cxx_init_decl_processing (void)\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n-  init_list_type_node = make_node (UNKNOWN_TYPE);\n+  init_list_type_node = cxx_make_type (UNKNOWN_TYPE);\n   record_unknown_type (init_list_type_node, \"init list\");\n \n   {\n     /* Make sure we get a unique function type, so we can give\n        its pointer type a name.  (This wins for gdb.) */\n-    tree vfunc_type = make_node (FUNCTION_TYPE);\n+    tree vfunc_type = cxx_make_type (FUNCTION_TYPE);\n     TREE_TYPE (vfunc_type) = integer_type_node;\n     TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n     layout_type (vfunc_type);\n@@ -3436,7 +3436,7 @@ cxx_init_decl_processing (void)\n   abi_node = current_namespace;\n   pop_namespace ();\n \n-  global_type_node = make_node (LANG_TYPE);\n+  global_type_node = cxx_make_type (LANG_TYPE);\n   record_unknown_type (global_type_node, \"global type\");\n \n   /* Now, C++.  */\n@@ -3939,6 +3939,8 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n \t       \"and functions\");\n       else if (saw_typedef)\n \twarning (0, \"%<typedef%> was ignored in this declaration\");\n+      else if (declspecs->specs[(int) ds_constexpr])\n+        error (\"%<constexpr> cannot be used for type declarations\");\n     }\n \n   return declared_type;\n@@ -4181,6 +4183,9 @@ start_decl (const cp_declarator *declarator,\n \t\terror (\"duplicate initialization of %qD\", decl);\n \t      if (duplicate_decls (decl, field, /*newdecl_is_friend=*/false))\n \t\tdecl = field;\n+              if (declspecs->specs[(int) ds_constexpr]\n+                  && !DECL_DECLARED_CONSTEXPR_P (field))\n+                error (\"%qD declared %<constexpr%> outside its class\", field);\n \t    }\n \t}\n       else\n@@ -4219,6 +4224,9 @@ start_decl (const cp_declarator *declarator,\n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n \tpermerror (input_location, \"declaration of %q#D outside of class is not definition\",\n \t\t   decl);\n+\n+      if (!ensure_literal_type_for_constexpr_object (decl))\n+        return error_mark_node;\n     }\n \n   was_public = TREE_PUBLIC (decl);\n@@ -4660,10 +4668,14 @@ check_for_uninitialized_const_var (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n \n+  if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n+      && DECL_INITIAL (decl) == NULL)\n+    error (\"missing initializer for constexpr %qD\", decl);\n+\n   /* ``Unless explicitly declared extern, a const object does not have\n      external linkage and must be initialized. ($8.4; $12.1)'' ARM\n      7.1.6 */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  else if (TREE_CODE (decl) == VAR_DECL\n       && TREE_CODE (type) != REFERENCE_TYPE\n       && CP_TYPE_CONST_P (type)\n       && !TYPE_NEEDS_CONSTRUCTING (type)\n@@ -7590,6 +7602,7 @@ grokdeclarator (const cp_declarator *declarator,\n   bool type_was_error_mark_node = false;\n   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;\n   bool template_type_arg = false;\n+  bool constexpr_p = declspecs->specs[(int) ds_constexpr];\n   const char *errmsg;\n \n   signed_p = declspecs->specs[(int)ds_signed];\n@@ -8034,6 +8047,17 @@ grokdeclarator (const cp_declarator *declarator,\n   type_quals = TYPE_UNQUALIFIED;\n   if (declspecs->specs[(int)ds_const])\n     type_quals |= TYPE_QUAL_CONST;\n+  /* A `constexpr' specifier used in an object declaration declares\n+     the object as `const'.  */\n+  if (constexpr_p)\n+    {\n+      if (innermost_code == cdk_function)\n+        ;\n+      else if (declspecs->specs[(int)ds_const] != 0)\n+        error (\"both %<const%> and %<constexpr%> cannot be used here\");\n+      else\n+        type_quals |= TYPE_QUAL_CONST;\n+    }\n   if (declspecs->specs[(int)ds_volatile])\n     type_quals |= TYPE_QUAL_VOLATILE;\n   if (declspecs->specs[(int)ds_restrict])\n@@ -8105,6 +8129,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t  error (\"parameter declared %<auto%>\");\n \t  type = error_mark_node;\n \t}\n+\n+      /* Function parameters cannot be constexpr.  If we saw one, moan\n+         and pretend it wasn't there.  */\n+      if (constexpr_p)\n+        {\n+          error (\"a parameter cannot be declared %<constexpr%>\");\n+          constexpr_p = 0;\n+        }\n     }\n \n   /* Give error if `virtual' is used outside of class declaration.  */\n@@ -8412,6 +8444,21 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n+            /* It is not allowed to use `constexpr' in a function\n+               declaration that is not a definition.\n+               That is too strict, though.  */\n+            if (constexpr_p && !funcdef_flag)\n+              {\n+                error (\"the %<constexpr%> specifier cannot be used in \"\n+                       \"a function declaration that is not a definition\");\n+                constexpr_p = false;\n+              }\n+\n+            /* A constexpr non-static member function is implicitly const.  */\n+            if (constexpr_p && decl_context == FIELD && staticp == 0\n+                && sfk != sfk_constructor && sfk != sfk_destructor)\n+              memfn_quals |= TYPE_QUAL_CONST;\n+\n \t    arg_types = grokparms (declarator->u.function.parameters,\n \t\t\t\t   &parms);\n \n@@ -8656,6 +8703,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t      return error_mark_node;\n \t    }\n \n+          /* It is not permitted to define a member function outside ist\n+             membership class as `constexpr'.  */\n+          if (constexpr_p)\n+            error (\"a constexpr function cannot be defined \"\n+                   \"outside of its class.\");\n+\n \t  if (TREE_CODE (sname) == IDENTIFIER_NODE\n \t      && NEW_DELETE_OPNAME_P (sname))\n \t    /* Overloaded operator new and operator delete\n@@ -9123,6 +9176,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t   uqname, ctype);\n \t\t    return error_mark_node;\n \t\t  }\n+                if (constexpr_p)\n+                  error (\"a destructor cannot be %<constexpr%>\");\n \t      }\n \t    else if (sfk == sfk_constructor && friendp)\n \t      {\n@@ -9143,7 +9198,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       parms,\n \t\t\t       unqualified_id,\n \t\t\t       virtualp, flags, memfn_quals, raises,\n-\t\t\t       friendp ? -1 : 0, friendp, publicp, inlinep,\n+\t\t\t       friendp ? -1 : 0, friendp, publicp,\n+                               inlinep || constexpr_p,\n \t\t\t       sfk,\n \t\t\t       funcdef_flag, template_count, in_namespace,\n \t\t\t       attrlist, declarator->id_loc);\n@@ -9235,6 +9291,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tdecl = do_friend (ctype, unqualified_id, decl,\n \t\t\t\t  *attrlist, flags,\n \t\t\t\t  funcdef_flag);\n+                DECL_DECLARED_CONSTEXPR_P (decl) = constexpr_p;\n \t\treturn decl;\n \t      }\n \t    else\n@@ -9296,6 +9353,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    else\n \t      {\n+                if (constexpr_p)\n+                  error (\"non-static data member %qE declared %<constexpr%>\",\n+                         unqualified_id);\n \t\tdecl = build_decl (input_location,\n \t\t\t\t   FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n@@ -9390,7 +9450,7 @@ grokdeclarator (const cp_declarator *declarator,\n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n \t\t\t   virtualp, flags, memfn_quals, raises,\n \t\t\t   1, friendp,\n-\t\t\t   publicp, inlinep, sfk, funcdef_flag,\n+\t\t\t   publicp, inlinep || constexpr_p, sfk, funcdef_flag,\n \t\t\t   template_count, in_namespace, attrlist,\n \t\t\t   declarator->id_loc);\n \tif (decl == NULL_TREE)\n@@ -9487,6 +9547,10 @@ grokdeclarator (const cp_declarator *declarator,\n     else if (storage_class == sc_static)\n       DECL_THIS_STATIC (decl) = 1;\n \n+    /* Don't forget constexprness.  */\n+    if (VAR_OR_FUNCTION_DECL_P (decl))\n+      DECL_DECLARED_CONSTEXPR_P (decl) = constexpr_p;\n+\n     /* Record constancy and volatility on the DECL itself .  There's\n        no need to do this when processing a template; we'll do this\n        for the instantiated declaration based on the type of DECL.  */\n@@ -10983,7 +11047,7 @@ start_enum (tree name, tree underlying_type, bool scoped_enum_p)\n       if (enumtype == error_mark_node)\n \tname = make_anon_name ();\n \n-      enumtype = make_node (ENUMERAL_TYPE);\n+      enumtype = cxx_make_type (ENUMERAL_TYPE);\n       enumtype = pushtag (name, enumtype, /*tag_scope=*/ts_current);\n     }\n \n@@ -11426,6 +11490,10 @@ check_function_type (tree decl, tree current_function_parms)\n   /* In a function definition, arg types must be complete.  */\n   require_complete_types_for_parms (current_function_parms);\n \n+  /* constexpr functions must have literal argument types and\n+     literal return type.  */\n+  validate_constexpr_fundecl (decl);\n+\n   if (dependent_type_p (return_type))\n     return;\n   if (!COMPLETE_OR_VOID_TYPE_P (return_type)"}, {"sha": "950d136f3980aae3b380a307518a54e264390bd8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -2195,6 +2195,7 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n \t    \"explicit\",\n \t    \"friend\",\n \t    \"typedef\",\n+            \"constexpr\",\n \t    \"__complex\",\n \t    \"__thread\"\n \t  };\n@@ -9030,7 +9031,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       switch (token->keyword)\n \t{\n \t  /* decl-specifier:\n-\t       friend  */\n+\t       friend\n+               constexpr */\n \tcase RID_FRIEND:\n \t  if (!at_class_scope_p ())\n \t    {\n@@ -9045,6 +9047,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t    }\n \t  break;\n \n+        case RID_CONSTEXPR:\n+          ++decl_specs->specs[(int) ds_constexpr];\n+          cp_lexer_consume_token (parser->lexer);\n+          break;\n+\n \t  /* function-specifier:\n \t       inline\n \t       virtual"}, {"sha": "d078642226bfaf268ab0a0870667bf1b1d63355d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -3013,7 +3013,7 @@ make_pack_expansion (tree arg)\n       pointer_set_destroy (ppd.visited);\n \n       /* Create the pack expansion type for the base type.  */\n-      purpose = make_node (TYPE_PACK_EXPANSION);\n+      purpose = cxx_make_type (TYPE_PACK_EXPANSION);\n       SET_PACK_EXPANSION_PATTERN (purpose, TREE_PURPOSE (arg));\n       PACK_EXPANSION_PARAMETER_PACKS (purpose) = parameter_packs;\n \n@@ -3028,7 +3028,9 @@ make_pack_expansion (tree arg)\n     for_types = true;\n \n   /* Build the PACK_EXPANSION_* node.  */\n-  result = make_node (for_types ? TYPE_PACK_EXPANSION : EXPR_PACK_EXPANSION);\n+  result = for_types\n+     ? cxx_make_type (TYPE_PACK_EXPANSION)\n+     : make_node (EXPR_PACK_EXPANSION);\n   SET_PACK_EXPANSION_PATTERN (result, arg);\n   if (TREE_CODE (result) == EXPR_PACK_EXPANSION)\n     {\n@@ -3538,7 +3540,7 @@ current_template_args (void)\n                           tree vec = make_tree_vec (1);\n                           TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n                           \n-                          t = make_node (TYPE_ARGUMENT_PACK);\n+                          t = cxx_make_type (TYPE_ARGUMENT_PACK);\n                           SET_ARGUMENT_PACK_ARGS (t, vec);\n                         }\n                     }\n@@ -5575,7 +5577,7 @@ coerce_template_parameter_pack (tree parms,\n \n   if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL\n       || TREE_CODE (TREE_VALUE (parm)) == TEMPLATE_DECL)\n-    argument_pack = make_node (TYPE_ARGUMENT_PACK);\n+    argument_pack = cxx_make_type (TYPE_ARGUMENT_PACK);\n   else\n     {\n       argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n@@ -6261,7 +6263,7 @@ lookup_template_class (tree d1,\n                  the values for the enumeration constants may involve\n                  template parameters.  And, no one should be interested\n                  in the enumeration constants for such a type.  */\n-              t = make_node (ENUMERAL_TYPE);\n+              t = cxx_make_type (ENUMERAL_TYPE);\n               SET_SCOPED_ENUM_P (t, SCOPED_ENUM_P (template_type));\n             }\n \t}\n@@ -7816,7 +7818,7 @@ make_fnparm_pack (tree spec_parm)\n   tree parmvec;\n   tree parmtypevec;\n   tree argpack = make_node (NONTYPE_ARGUMENT_PACK);\n-  tree argtypepack = make_node (TYPE_ARGUMENT_PACK);\n+  tree argtypepack = cxx_make_type (TYPE_ARGUMENT_PACK);\n   int i, len = list_length (spec_parm);\n \n   /* Fill in PARMVEC and PARMTYPEVEC with all of the parameters.  */\n@@ -8147,7 +8149,9 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       else if (ARGUMENT_PACK_P (orig_arg))\n         {\n           /* Substitute into each of the arguments.  */\n-          new_arg = make_node (TREE_CODE (orig_arg));\n+          new_arg = TYPE_P (orig_arg)\n+            ? cxx_make_type (TREE_CODE (orig_arg))\n+            : make_node (TREE_CODE (orig_arg));\n           \n           SET_ARGUMENT_PACK_ARGS (\n             new_arg,\n@@ -10186,7 +10190,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TYPE_ARGUMENT_PACK:\n     case NONTYPE_ARGUMENT_PACK:\n       {\n-        tree r = make_node (TREE_CODE (t));\n+        tree r = TYPE_P (t)\n+          ? cxx_make_type (TREE_CODE (t))\n+          : make_node (TREE_CODE (t));\n         tree packed_out = \n           tsubst_template_args (ARGUMENT_PACK_ARGS (t), \n                                 args,\n@@ -13167,7 +13173,7 @@ type_unification_real (tree tparms,\n                   TREE_CONSTANT (arg) = 1;\n                 }\n               else\n-                arg = make_node (TYPE_ARGUMENT_PACK);\n+                arg = cxx_make_type (TYPE_ARGUMENT_PACK);\n \n               SET_ARGUMENT_PACK_ARGS (arg, make_tree_vec (0));\n \n@@ -13744,7 +13750,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n               TREE_CONSTANT (result) = 1;\n             }\n           else\n-            result = make_node (TYPE_ARGUMENT_PACK);\n+            result = cxx_make_type (TYPE_ARGUMENT_PACK);\n \n           SET_ARGUMENT_PACK_ARGS (result, new_args);\n "}, {"sha": "8199af0e693804321d5ca2c12051b9f435a29a0e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -5203,6 +5203,87 @@ float_const_decimal64_p (void)\n   return 0;\n }\n \n+/* Return true if T is a literal type.   */\n+\n+bool\n+literal_type_p (tree t)\n+{\n+  if (SCALAR_TYPE_P (t))\n+    return true;\n+  if (CLASS_TYPE_P (t))\n+    return CLASSTYPE_LITERAL_P (t);\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return literal_type_p (strip_array_types (t));\n+  return false;\n+}\n+\n+\n+/* If DECL is a variable declared `constexpr', require its type\n+   be literal.  Return the DECL if OK, otherwise NULL.  */\n+\n+tree\n+ensure_literal_type_for_constexpr_object (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n+      && !processing_template_decl && !literal_type_p (type))\n+    {\n+      error (\"the type %qT of constexpr variable %qD is not literal\",\n+             type, decl);\n+      return NULL;\n+    }\n+  return decl;\n+}\n+\n+/* Return non-null if FUN certainly designates a valid constexpr function\n+   declaration.  Otherwise return NULL.  Issue appropriate diagnostics\n+   if necessary.  Note that we only check the declaration, not the body\n+   of the function.  */\n+\n+tree\n+validate_constexpr_fundecl (tree fun)\n+{\n+  tree rettype = NULL;\n+  tree parm = NULL;\n+\n+  /* Don't bother if FUN is not marked constexpr.  */\n+  if (!DECL_DECLARED_CONSTEXPR_P (fun))\n+    return NULL;\n+\n+  /* For a function template, we have absolutely no guarantee that all\n+     instantiations will be constexpr.  */\n+  if (TREE_CODE (fun) == TEMPLATE_DECL)\n+    return NULL;\n+  \n+  parm = FUNCTION_FIRST_USER_PARM (fun);\n+  for (; parm != NULL; parm = TREE_CHAIN (parm))\n+    {\n+      tree type = TREE_TYPE (parm);\n+      if (dependent_type_p (type))\n+        return NULL;\n+      if (!literal_type_p (type))\n+        {\n+           error (\"parameter %q#D is not of literal type\", parm);\n+          return NULL;\n+        }\n+    }\n+\n+  if (DECL_CONSTRUCTOR_P (fun))\n+    return fun;\n+\n+  rettype = TREE_TYPE (TREE_TYPE (fun));\n+  if (dependent_type_p (rettype))\n+    return NULL;\n+  if (!literal_type_p (rettype))\n+    {\n+      error (\"return type %qT of function %qD is not a literal type\",\n+             TREE_TYPE (TREE_TYPE (fun)), fun);\n+      return NULL;\n+    }\n+  return fun;\n+}\n+\n+\n /* Constructor for a lambda expression.  */\n \n tree"}, {"sha": "19a1270b76df7a6e26580bc78ecf05eb5f11d874", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -639,7 +639,7 @@ build_cplus_array_type_1 (tree elt_type, tree index_type)\n       else\n \t{\n \t  /* Build a new array type.  */\n-\t  t = make_node (ARRAY_TYPE);\n+\t  t = cxx_make_type (ARRAY_TYPE);\n \t  TREE_TYPE (t) = elt_type;\n \t  TYPE_DOMAIN (t) = index_type;\n \n@@ -942,7 +942,6 @@ cp_build_qualified_type_real (tree type,\n       && (TYPE_LANG_SPECIFIC (TYPE_CANONICAL (result)) \n           == TYPE_LANG_SPECIFIC (TYPE_CANONICAL (type))))\n     TYPE_LANG_SPECIFIC (TYPE_CANONICAL (result)) = NULL;\n-      \n \n   return result;\n }"}, {"sha": "ce841d548eb5833e397047f924041cc7e516d093", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecbca9d02206b8fcba2710daa9e0a366af65a8b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7ecbca9d02206b8fcba2710daa9e0a366af65a8b", "patch": "@@ -2597,6 +2597,7 @@ struct GTY(()) tree_decl_minimal {\n #define DECL_LANG_FLAG_5(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_5)\n #define DECL_LANG_FLAG_6(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_6)\n #define DECL_LANG_FLAG_7(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_7)\n+#define DECL_LANG_FLAG_8(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_8)\n \n /* Nonzero for a decl which is at file scope.  */\n #define DECL_FILE_SCOPE_P(EXP) \t\t\t\t\t\\\n@@ -2639,6 +2640,7 @@ struct GTY(()) tree_decl_common {\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n   unsigned lang_flag_7 : 1;\n+  unsigned lang_flag_8 : 1;\n \n   /* In LABEL_DECL, this is DECL_ERROR_ISSUED.\n      In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n@@ -2657,8 +2659,9 @@ struct GTY(()) tree_decl_common {\n   unsigned decl_by_reference_flag : 1;\n   /* In VAR_DECL, PARM_DECL and RESULT_DECL, this is DECL_RESTRICTED_P.  */\n   unsigned decl_restricted_flag : 1;\n+\n   /* Padding so that 'off_align' can be on a 32-bit boundary.  */\n-  unsigned decl_common_unused : 3;\n+  unsigned decl_common_unused : 2;\n \n   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */\n   unsigned int off_align : 8;"}]}