{"sha": "f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "node_id": "C_kwDOANBUbNoAKGY4ZTEyZTc4NjI4MjM4YTllM2NmNjhjZTkzNzZhYTJlMjhlMDUwNmY", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-02-17T07:58:30Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:40Z"}, "message": "[Ada] Adapt body of formal sets and maps for SPARK\n\nRemove violations of SPARK rules, to prepare for the proof of hashed\nsets and maps:\n\n- Make the type of hash tables not tagged, so that it will be possible\n  to mark the type of nodes as having relaxed initialization.\n\n- Remove comparison of addresses as check or optimization: as a check,\n  it is not necessary in SPARK as the caller cannot pass in aliased\n  parameters in such cases; as an optimization, it is not possible in\n  SPARK code.\n\n- Avoid aliasing when inserting a node in the hash table. The code for\n  insertion in sets and maps was explicitly aliasing a global for the\n  container and a parameter for its hash table component, both being\n  written. Rewrite the code to pass only the hash table as parameter.\n\n- Insert constants for subtype constraints, which cannot depend on\n  variables in SPARK code.\n\n- Use procedures instead of functions when side-effects are expected.\n\n- Rename variables whose value is only written through calls and not\n  read, using Unused prefix, so that flow analysis does not warn about\n  it.\n\ngcc/ada/\n\n\t* libgnat/a-cfhama.adb (Generic_Allocate): Retype to avoid\n\taliasing.\n\t(Assign, Move): Remove address comparison.\n\t(Include): Insert constants for subtype constraints.\n\t(Insert): Rewrite to avoid aliasing and function with side-effects.\n\t* libgnat/a-cfhase.adb (Generic_Allocate): Retype to avoid\n\taliasing.\n\t(Assign, Move): Remove address comparison.\n\t(Difference, Intersection, Is_Subset, Overlap,\n\tSymmetric_Difference, Union): Remove address comparison.  Insert\n\tconstants for subtype constraints.\n\t(Insert): Rewrite to avoid aliasing and function with\n\tside-effects.\n\t* libgnat/a-chtgfk.adb (Checked_Equivalent_Keys, Checked_Index,\n\tDelete_Key_Sans_Free, Find, Generic_Replace_Element, Index):\n\tType for hash tables not tagged anymore.\n\t(Generic_Conditional_Insert): New_Node generic formal is a\n\tprocedure taking the hash table as first parameter now, to avoid\n\taliasing in the caller.\n\t* libgnat/a-chtgfk.ads: Same.\n\t* libgnat/a-chtgfo.adb (Checked_Index, Clear,\n\tDelete_Node_At_Index, Delete_Node_Sans_Free, First, Free,\n\tGeneric_Allocate, Generic_Iteration, Generic_Read,\n\tGeneric_Write, Index, Next): Type for hash tables not tagged\n\tanymore.\n\t(Generic_Equal): Removed tagged. Remove address comparison.\n\t* libgnat/a-chtgfo.ads: Same.\n\t* libgnat/a-cohata.ads (Hash_Table_Type): Remove tagged.", "tree": {"sha": "62bf2d298b15513e2816f98b52901dde1f64d5cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62bf2d298b15513e2816f98b52901dde1f64d5cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e2f53d50c6fd17eb87d256d57696acc650a50e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2f53d50c6fd17eb87d256d57696acc650a50e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2f53d50c6fd17eb87d256d57696acc650a50e1"}], "stats": {"total": 341, "additions": 145, "deletions": 196}, "files": [{"sha": "c2a7c5958541db3b2f6ad06dd0d6ae089b01e045", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -56,7 +56,7 @@ is\n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n-     (HT   : in out Map;\n+     (HT   : in out HT_Types.Hash_Table_Type;\n       Node : out Count_Type);\n \n    function Hash_Node (Node : Node_Type) return Hash_Type;\n@@ -154,10 +154,6 @@ is\n    --  Start of processing for Assign\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       if Target.Capacity < Length (Source) then\n          raise Constraint_Error with  -- correct exception ???\n            \"Source length exceeds Target capacity\";\n@@ -556,13 +552,16 @@ is\n    -- Generic_Allocate --\n    ----------------------\n \n-   procedure Generic_Allocate (HT : in out Map; Node : out Count_Type) is\n+   procedure Generic_Allocate\n+     (HT   : in out HT_Types.Hash_Table_Type;\n+      Node : out Count_Type)\n+   is\n       procedure Allocate is\n         new HT_Ops.Generic_Allocate (Set_Element);\n \n    begin\n-      Allocate (HT.Content, Node);\n-      HT.Content.Nodes (Node).Has_Element := True;\n+      Allocate (HT, Node);\n+      HT.Nodes (Node).Has_Element := True;\n    end Generic_Allocate;\n \n    -----------------\n@@ -606,7 +605,8 @@ is\n \n       if not Inserted then\n          declare\n-            N : Node_Type renames Container.Content.Nodes (Position.Node);\n+            P : constant Count_Type := Position.Node;\n+            N : Node_Type renames Container.Content.Nodes (P);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -628,7 +628,9 @@ is\n       procedure Assign_Key (Node : in out Node_Type);\n       pragma Inline (Assign_Key);\n \n-      function New_Node return Count_Type;\n+      procedure New_Node\n+        (HT   : in out HT_Types.Hash_Table_Type;\n+         Node : out Count_Type);\n       pragma Inline (New_Node);\n \n       procedure Local_Insert is\n@@ -651,11 +653,12 @@ is\n       -- New_Node --\n       --------------\n \n-      function New_Node return Count_Type is\n-         Result : Count_Type;\n+      procedure New_Node\n+        (HT   : in out HT_Types.Hash_Table_Type;\n+         Node : out Count_Type)\n+      is\n       begin\n-         Allocate (Container, Result);\n-         return Result;\n+         Allocate (HT, Node);\n       end New_Node;\n \n    --  Start of processing for Insert\n@@ -669,11 +672,11 @@ is\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    is\n-      Position : Cursor;\n-      Inserted : Boolean;\n+      Unused_Position : Cursor;\n+      Inserted        : Boolean;\n \n    begin\n-      Insert (Container, Key, New_Item, Position, Inserted);\n+      Insert (Container, Key, New_Item, Unused_Position, Inserted);\n \n       if not Inserted then\n          raise Constraint_Error with \"attempt to insert key already in map\";\n@@ -727,10 +730,6 @@ is\n       Y  : Count_Type;\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       if Target.Capacity < Length (Source) then\n          raise Constraint_Error with  -- ???\n            \"Source length exceeds Target capacity\";"}, {"sha": "834f43a6c4e16e14cfed4bbc8cbe4a94d6f27d78", "filename": "gcc/ada/libgnat/a-cfhase.adb", "status": "modified", "additions": 75, "deletions": 121, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -58,7 +58,7 @@ is\n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n-     (HT   : in out Set;\n+     (HT   : in out Hash_Table_Type;\n       Node : out Count_Type);\n \n    function Hash_Node (Node : Node_Type) return Hash_Type;\n@@ -167,22 +167,18 @@ is\n       --------------------\n \n       procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.Content.Nodes (Source_Node);\n-         X : Count_Type;\n-         B : Boolean;\n+         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n+         Unused_X : Count_Type;\n+         B        : Boolean;\n \n       begin\n-         Insert (Target, N.Element, X, B);\n+         Insert (Target, N.Element, Unused_X, B);\n          pragma Assert (B);\n       end Insert_Element;\n \n    --  Start of processing for Assign\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       if Target.Capacity < Length (Source) then\n          raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n       end if;\n@@ -335,11 +331,6 @@ is\n       SN : Nodes_Type renames Source.Content.Nodes;\n \n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Src_Length := Source.Content.Length;\n \n       if Src_Length = 0 then\n@@ -393,13 +384,13 @@ is\n       -------------\n \n       procedure Process (L_Node : Count_Type) is\n-         B : Boolean;\n-         E : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         X : Count_Type;\n+         B        : Boolean;\n+         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n+         Unused_X : Count_Type;\n \n       begin\n          if Find (Right, E).Node = 0 then\n-            Insert (Target, E, X, B);\n+            Insert (Target, E, Unused_X, B);\n             pragma Assert (B);\n          end if;\n       end Process;\n@@ -411,14 +402,7 @@ is\n    end Difference;\n \n    function Difference (Left : Set; Right : Set) return Set is\n-      C : Count_Type;\n-      H : Hash_Type;\n-\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n       if Length (Left) = 0 then\n          return Empty_Set;\n       end if;\n@@ -427,12 +411,14 @@ is\n          return Copy (Left);\n       end if;\n \n-      C := Length (Left);\n-      H := Default_Modulus (C);\n-\n-      return S : Set (C, H) do\n-         Difference (Left, Right, Target => S);\n-      end return;\n+      declare\n+         C : constant Count_Type := Length (Left);\n+         H : constant Hash_Type := Default_Modulus (C);\n+      begin\n+         return S : Set (C, H) do\n+            Difference (Left, Right, Target => S);\n+         end return;\n+      end;\n    end Difference;\n \n    -------------\n@@ -461,7 +447,7 @@ is\n    function Equivalent_Sets (Left, Right : Set) return Boolean is\n \n       function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type'Class;\n+        (R_HT   : Hash_Table_Type;\n          L_Node : Node_Type) return Boolean;\n       pragma Inline (Find_Equivalent_Key);\n \n@@ -473,7 +459,7 @@ is\n       -------------------------\n \n       function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type'Class;\n+        (R_HT   : Hash_Table_Type;\n          L_Node : Node_Type) return Boolean\n       is\n          R_Index : constant Hash_Type :=\n@@ -793,11 +779,14 @@ is\n    -- Generic_Allocate --\n    ----------------------\n \n-   procedure Generic_Allocate (HT : in out Set; Node : out Count_Type) is\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type;\n+      Node : out Count_Type)\n+   is\n       procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n    begin\n-      Allocate (HT.Content, Node);\n-      HT.Content.Nodes (Node).Has_Element := True;\n+      Allocate (HT, Node);\n+      HT.Nodes (Node).Has_Element := True;\n    end Generic_Allocate;\n \n    package body Generic_Keys with SPARK_Mode => Off is\n@@ -1031,11 +1020,11 @@ is\n    end Insert;\n \n    procedure Insert (Container : in out Set; New_Item : Element_Type) is\n-      Inserted : Boolean;\n-      Position : Cursor;\n+      Inserted        : Boolean;\n+      Unused_Position : Cursor;\n \n    begin\n-      Insert (Container, New_Item, Position, Inserted);\n+      Insert (Container, New_Item, Unused_Position, Inserted);\n \n       if not Inserted then\n          raise Constraint_Error with\n@@ -1052,7 +1041,9 @@ is\n       procedure Allocate_Set_Element (Node : in out Node_Type);\n       pragma Inline (Allocate_Set_Element);\n \n-      function New_Node return Count_Type;\n+      procedure New_Node\n+        (HT   : in out Hash_Table_Type;\n+         Node : out Count_Type);\n       pragma Inline (New_Node);\n \n       procedure Local_Insert is\n@@ -1074,11 +1065,12 @@ is\n       -- New_Node --\n       --------------\n \n-      function New_Node return Count_Type is\n-         Result : Count_Type;\n+      procedure New_Node\n+        (HT   : in out Hash_Table_Type;\n+         Node : out Count_Type)\n+      is\n       begin\n-         Allocate (Container, Result);\n-         return Result;\n+         Allocate (HT, Node);\n       end New_Node;\n \n    --  Start of processing for Insert\n@@ -1096,10 +1088,6 @@ is\n       TN       : Nodes_Type renames Target.Content.Nodes;\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       if Source.Content.Length = 0 then\n          Clear (Target);\n          return;\n@@ -1133,13 +1121,13 @@ is\n       -------------\n \n       procedure Process (L_Node : Count_Type) is\n-         E : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         X : Count_Type;\n-         B : Boolean;\n+         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n+         Unused_X : Count_Type;\n+         B        : Boolean;\n \n       begin\n          if Find (Right, E).Node /= 0 then\n-            Insert (Target, E, X, B);\n+            Insert (Target, E, Unused_X, B);\n             pragma Assert (B);\n          end if;\n       end Process;\n@@ -1151,17 +1139,11 @@ is\n    end Intersection;\n \n    function Intersection (Left : Set; Right : Set) return Set is\n-      C : Count_Type;\n-      H : Hash_Type;\n+      C : constant Count_Type :=\n+        Count_Type'Min (Length (Left), Length (Right));  -- ???\n+      H : constant Hash_Type := Default_Modulus (C);\n \n    begin\n-      if Left'Address = Right'Address then\n-         return Copy (Left);\n-      end if;\n-\n-      C := Count_Type'Min (Length (Left), Length (Right));  -- ???\n-      H := Default_Modulus (C);\n-\n       return S : Set (C, H) do\n          if Length (Left) /= 0 and Length (Right) /= 0 then\n             Intersection (Left, Right, Target => S);\n@@ -1196,18 +1178,15 @@ is\n       Subset_Nodes : Nodes_Type renames Subset.Content.Nodes;\n \n    begin\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n       if Length (Subset) > Length (Of_Set) then\n          return False;\n       end if;\n \n       Subset_Node := First (Subset).Node;\n       while Subset_Node /= 0 loop\n          declare\n-            N : Node_Type renames Subset_Nodes (Subset_Node);\n+            S : constant Count_Type := Subset_Node;\n+            N : Node_Type renames Subset_Nodes (S);\n             E : Element_Type renames N.Element;\n \n          begin\n@@ -1242,10 +1221,6 @@ is\n       X, Y : Count_Type;\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       if Target.Capacity < Length (Source) then\n          raise Constraint_Error with  -- ???\n            \"Source length exceeds Target capacity\";\n@@ -1312,14 +1287,11 @@ is\n          return False;\n       end if;\n \n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       Left_Node := First (Left).Node;\n       while Left_Node /= 0 loop\n          declare\n-            N : Node_Type renames Left_Nodes (Left_Node);\n+            L : constant Count_Type := Left_Node;\n+            N : Node_Type renames Left_Nodes (L);\n             E : Element_Type renames N.Element;\n          begin\n             if Find (Right, E).Node /= 0 then\n@@ -1416,27 +1388,22 @@ is\n       -------------\n \n       procedure Process (Source_Node : Count_Type) is\n-         B : Boolean;\n-         N : Node_Type renames Source.Content.Nodes (Source_Node);\n-         X : Count_Type;\n+         B        : Boolean;\n+         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n+         Unused_X : Count_Type;\n \n       begin\n          if Is_In (Target, N) then\n             Delete (Target, N.Element);\n          else\n-            Insert (Target, N.Element, X, B);\n+            Insert (Target, N.Element, Unused_X, B);\n             pragma Assert (B);\n          end if;\n       end Process;\n \n    --  Start of processing for Symmetric_Difference\n \n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       if Length (Target) = 0 then\n          Assign (Target, Source);\n          return;\n@@ -1446,14 +1413,7 @@ is\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left : Set; Right : Set) return Set is\n-      C : Count_Type;\n-      H : Hash_Type;\n-\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n       if Length (Right) = 0 then\n          return Copy (Left);\n       end if;\n@@ -1462,26 +1422,28 @@ is\n          return Copy (Right);\n       end if;\n \n-      C := Length (Left) + Length (Right);\n-      H := Default_Modulus (C);\n-\n-      return S : Set (C, H) do\n-         Difference (Left, Right, S);\n-         Difference (Right, Left, S);\n-      end return;\n+      declare\n+         C : constant Count_Type := Length (Left) + Length (Right);\n+         H : constant Hash_Type := Default_Modulus (C);\n+      begin\n+         return S : Set (C, H) do\n+            Difference (Left, Right, S);\n+            Difference (Right, Left, S);\n+         end return;\n+      end;\n    end Symmetric_Difference;\n \n    ------------\n    -- To_Set --\n    ------------\n \n    function To_Set (New_Item : Element_Type) return Set is\n-      X : Count_Type;\n-      B : Boolean;\n+      Unused_X : Count_Type;\n+      B        : Boolean;\n \n    begin\n       return S : Set (Capacity => 1, Modulus => 1) do\n-         Insert (S, New_Item, X, B);\n+         Insert (S, New_Item, Unused_X, B);\n          pragma Assert (B);\n       end return;\n    end To_Set;\n@@ -1504,32 +1466,21 @@ is\n          N : Node_Type renames Source.Content.Nodes (Src_Node);\n          E : Element_Type renames N.Element;\n \n-         X : Count_Type;\n-         B : Boolean;\n+         Unused_X : Count_Type;\n+         Unused_B : Boolean;\n \n       begin\n-         Insert (Target, E, X, B);\n+         Insert (Target, E, Unused_X, Unused_B);\n       end Process;\n \n    --  Start of processing for Union\n \n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Iterate (Source.Content);\n    end Union;\n \n    function Union (Left : Set; Right : Set) return Set is\n-      C : Count_Type;\n-      H : Hash_Type;\n-\n    begin\n-      if Left'Address = Right'Address then\n-         return Copy (Left);\n-      end if;\n-\n       if Length (Right) = 0 then\n          return Copy (Left);\n       end if;\n@@ -1538,12 +1489,15 @@ is\n          return Copy (Right);\n       end if;\n \n-      C := Length (Left) + Length (Right);\n-      H := Default_Modulus (C);\n-      return S : Set (C, H) do\n-         Assign (Target => S, Source => Left);\n-         Union (Target => S, Source => Right);\n-      end return;\n+      declare\n+         C : constant Count_Type := Length (Left) + Length (Right);\n+         H : constant Hash_Type := Default_Modulus (C);\n+      begin\n+         return S : Set (C, H) do\n+            Assign (Target => S, Source => Left);\n+            Union (Target => S, Source => Right);\n+         end return;\n+      end;\n    end Union;\n \n    ---------"}, {"sha": "338eb352d9bc0551951d78413ea75002f3760417", "filename": "gcc/ada/libgnat/a-chtgfk.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -36,7 +36,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    -----------------------------\n \n    function Checked_Equivalent_Keys\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Key  : Key_Type;\n       Node : Count_Type) return Boolean\n    is\n@@ -49,7 +49,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    -------------------\n \n    function Checked_Index\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type\n    is\n    begin\n@@ -61,7 +61,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    --------------------------\n \n    procedure Delete_Key_Sans_Free\n-     (HT  : in out Hash_Table_Type'Class;\n+     (HT  : in out Hash_Table_Type;\n       Key : Key_Type;\n       X   : out Count_Type)\n    is\n@@ -108,7 +108,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    ----------\n \n    function Find\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Count_Type\n    is\n       Indx : Hash_Type;\n@@ -119,13 +119,11 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n          return 0;\n       end if;\n \n-      Indx := Checked_Index (HT'Unrestricted_Access.all, Key);\n+      Indx := Checked_Index (HT, Key);\n \n       Node := HT.Buckets (Indx);\n       while Node /= 0 loop\n-         if Checked_Equivalent_Keys\n-           (HT'Unrestricted_Access.all, Key, Node)\n-         then\n+         if Checked_Equivalent_Keys (HT, Key, Node) then\n             return Node;\n          end if;\n          Node := Next (HT.Nodes (Node));\n@@ -139,7 +137,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    --------------------------------\n \n    procedure Generic_Conditional_Insert\n-     (HT       : in out Hash_Table_Type'Class;\n+     (HT       : in out Hash_Table_Type;\n       Key      : Key_Type;\n       Node     : out Count_Type;\n       Inserted : out Boolean)\n@@ -155,7 +153,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n             raise Capacity_Error with \"no more capacity for insertion\";\n          end if;\n \n-         Node := New_Node;\n+         New_Node (HT, Node);\n          Set_Next (HT.Nodes (Node), Next => 0);\n \n          Inserted := True;\n@@ -181,7 +179,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n          raise Capacity_Error with \"no more capacity for insertion\";\n       end if;\n \n-      Node := New_Node;\n+      New_Node (HT, Node);\n       Set_Next (HT.Nodes (Node), Next => HT.Buckets (Indx));\n \n       Inserted := True;\n@@ -195,7 +193,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    -----------------------------\n \n    procedure Generic_Replace_Element\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Node : Count_Type;\n       Key  : Key_Type)\n    is\n@@ -307,7 +305,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    -----------\n \n    function Index\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type is\n    begin\n       return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;"}, {"sha": "8a04487190943733c2e29a8a2de5e9dbe9d69ab2", "filename": "gcc/ada/libgnat/a-chtgfk.ads", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -54,42 +54,44 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    pragma Pure;\n \n    function Index\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type;\n    pragma Inline (Index);\n    --  Returns the bucket number (array index value) for the given key\n \n    function Checked_Index\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type;\n    pragma Inline (Checked_Index);\n    --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n    --  order to detect element tampering by the generic actual Hash function.\n \n    function Checked_Equivalent_Keys\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Key  : Key_Type;\n       Node : Count_Type) return Boolean;\n    --  Calls Equivalent_Keys, but locks and unlocks the container, per\n    --  AI05-0022, in order to detect element tampering by that generic actual.\n \n    procedure Delete_Key_Sans_Free\n-     (HT  : in out Hash_Table_Type'Class;\n+     (HT  : in out Hash_Table_Type;\n       Key : Key_Type;\n       X   : out Count_Type);\n    --  Removes the node (if any) with the given key from the hash table,\n    --  without deallocating it. Program_Error is raised if the hash\n    --  table is busy.\n \n    function Find\n-     (HT  : Hash_Table_Type'Class;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Count_Type;\n    --  Returns the node (if any) corresponding to the given key\n \n    generic\n-      with function New_Node return Count_Type;\n+      with procedure New_Node\n+        (HT   : in out Hash_Table_Type;\n+         Node : out Count_Type);\n    procedure Generic_Conditional_Insert\n-     (HT       : in out Hash_Table_Type'Class;\n+     (HT       : in out Hash_Table_Type;\n       Key      : Key_Type;\n       Node     : out Count_Type;\n       Inserted : out Boolean);\n@@ -103,7 +105,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n       with function Hash (Node : Node_Type) return Hash_Type;\n       with procedure Assign (Node : in out Node_Type; Key : Key_Type);\n    procedure Generic_Replace_Element\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Node : Count_Type;\n       Key  : Key_Type);\n    --  Assigns Key to Node, possibly changing its equivalence class. If Node"}, {"sha": "e35163df67f42ed3b4f70705ee7ec5adc23db885", "filename": "gcc/ada/libgnat/a-chtgfo.adb", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -38,7 +38,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    -------------------\n \n    function Checked_Index\n-     (Hash_Table : Hash_Table_Type'Class;\n+     (Hash_Table : Hash_Table_Type;\n       Node       : Count_Type) return Hash_Type\n    is\n    begin\n@@ -49,7 +49,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    -- Clear --\n    -----------\n \n-   procedure Clear (HT : in out Hash_Table_Type'Class) is\n+   procedure Clear (HT : in out Hash_Table_Type) is\n    begin\n       HT.Length := 0;\n       --  HT.Busy := 0;\n@@ -63,7 +63,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    --------------------------\n \n    procedure Delete_Node_At_Index\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Indx : Hash_Type;\n       X    : Count_Type)\n    is\n@@ -106,7 +106,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    ---------------------------\n \n    procedure Delete_Node_Sans_Free\n-     (HT : in out Hash_Table_Type'Class;\n+     (HT : in out Hash_Table_Type;\n       X  : Count_Type)\n    is\n       pragma Assert (X /= 0);\n@@ -162,7 +162,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    -- First --\n    -----------\n \n-   function First (HT : Hash_Table_Type'Class) return Count_Type is\n+   function First (HT : Hash_Table_Type) return Count_Type is\n       Indx : Hash_Type;\n \n    begin\n@@ -185,7 +185,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    ----------\n \n    procedure Free\n-     (HT : in out Hash_Table_Type'Class;\n+     (HT : in out Hash_Table_Type;\n       X  : Count_Type)\n    is\n       N : Nodes_Type renames HT.Nodes;\n@@ -300,7 +300,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    ----------------------\n \n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Node : out Count_Type)\n    is\n       N : Nodes_Type renames HT.Nodes;\n@@ -338,18 +338,14 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    -------------------\n \n    function Generic_Equal\n-     (L, R : Hash_Table_Type'Class) return Boolean\n+     (L, R : Hash_Table_Type) return Boolean\n    is\n       L_Index : Hash_Type;\n       L_Node  : Count_Type;\n \n       N : Count_Type;\n \n    begin\n-      if L'Address = R'Address then\n-         return True;\n-      end if;\n-\n       if L.Length /= R.Length then\n          return False;\n       end if;\n@@ -403,7 +399,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    -- Generic_Iteration --\n    -----------------------\n \n-   procedure Generic_Iteration (HT : Hash_Table_Type'Class) is\n+   procedure Generic_Iteration (HT : Hash_Table_Type) is\n       Node : Count_Type;\n \n    begin\n@@ -426,7 +422,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n \n    procedure Generic_Read\n      (Stream : not null access Root_Stream_Type'Class;\n-      HT     : out Hash_Table_Type'Class)\n+      HT     : out Hash_Table_Type)\n    is\n       N : Count_Type'Base;\n \n@@ -467,7 +463,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n \n    procedure Generic_Write\n      (Stream : not null access Root_Stream_Type'Class;\n-      HT     : Hash_Table_Type'Class)\n+      HT     : Hash_Table_Type)\n    is\n       procedure Write (Node : Count_Type);\n       pragma Inline (Write);\n@@ -500,7 +496,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    end Index;\n \n    function Index\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Node : Node_Type) return Hash_Type is\n    begin\n       return Index (HT.Buckets, Node);\n@@ -511,7 +507,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    ----------\n \n    function Next\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Node : Count_Type) return Count_Type\n    is\n       Result : Count_Type;\n@@ -527,7 +523,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n       --  This was the last node in the bucket, so move to the next\n       --  bucket, and start searching for next node from there.\n \n-      First := Checked_Index (HT'Unrestricted_Access.all, Node) + 1;\n+      First := Checked_Index (HT, Node) + 1;\n       for Indx in First .. HT.Buckets'Last loop\n          Result := HT.Buckets (Indx);\n "}, {"sha": "b20ef6961a5684e05e5747c08af17da7317b186c", "filename": "gcc/ada/libgnat/a-chtgfo.ads", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -56,36 +56,36 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    --  Uses the hash value of Node to compute its Buckets array index\n \n    function Index\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Node : Node_Type) return Hash_Type;\n    pragma Inline (Index);\n    --  Uses the hash value of Node to compute its Hash_Table buckets array\n    --  index.\n \n    function Checked_Index\n-     (Hash_Table : Hash_Table_Type'Class;\n+     (Hash_Table : Hash_Table_Type;\n       Node       : Count_Type) return Hash_Type;\n    --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n    --  order to detect element tampering by the generic actual Hash function.\n \n    generic\n       with function Find\n-        (HT  : Hash_Table_Type'Class;\n+        (HT  : Hash_Table_Type;\n          Key : Node_Type) return Boolean;\n-   function Generic_Equal (L, R : Hash_Table_Type'Class) return Boolean;\n+   function Generic_Equal (L, R : Hash_Table_Type) return Boolean;\n    --  Used to implement hashed container equality. For each node in hash table\n    --  L, it calls Find to search for an equivalent item in hash table R. If\n    --  Find returns False for any node then Generic_Equal terminates\n    --  immediately and returns False. Otherwise if Find returns True for every\n    --  node then Generic_Equal returns True.\n \n-   procedure Clear (HT : in out Hash_Table_Type'Class);\n+   procedure Clear (HT : in out Hash_Table_Type);\n    --  Deallocates each node in hash table HT. (Note that it only deallocates\n    --  the nodes, not the buckets array.) Program_Error is raised if the hash\n    --  table is busy.\n \n    procedure Delete_Node_At_Index\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Indx : Hash_Type;\n       X    : Count_Type);\n    --  Delete a node whose bucket position is known. extracted from following\n@@ -95,31 +95,31 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    --  not correspond to the hash code that determines its bucket.\n \n    procedure Delete_Node_Sans_Free\n-     (HT : in out Hash_Table_Type'Class;\n+     (HT : in out Hash_Table_Type;\n       X  : Count_Type);\n    --  Removes node X from the hash table without deallocating the node\n \n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type'Class;\n+     (HT   : in out Hash_Table_Type;\n       Node : out Count_Type);\n    --  Claim a node from the free store. Generic_Allocate first\n    --  calls Set_Element on the potential node, and then returns\n    --  the node's index as the value of the Node parameter.\n \n    procedure Free\n-     (HT : in out Hash_Table_Type'Class;\n+     (HT : in out Hash_Table_Type;\n       X  : Count_Type);\n    --  Return a node back to the free store, from where it had\n    --  been previously claimed via Generic_Allocate.\n \n-   function First (HT : Hash_Table_Type'Class) return Count_Type;\n+   function First (HT : Hash_Table_Type) return Count_Type;\n    --  Returns the head of the list in the first (lowest-index) non-empty\n    --  bucket.\n \n    function Next\n-     (HT   : Hash_Table_Type'Class;\n+     (HT   : Hash_Table_Type;\n       Node : Count_Type) return Count_Type;\n    --  Returns the node that immediately follows Node. This corresponds to\n    --  either the next node in the same bucket, or (if Node is the last node in\n@@ -128,7 +128,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n \n    generic\n       with procedure Process (Node : Count_Type);\n-   procedure Generic_Iteration (HT : Hash_Table_Type'Class);\n+   procedure Generic_Iteration (HT : Hash_Table_Type);\n    --  Calls Process for each node in hash table HT\n \n    generic\n@@ -138,7 +138,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n          Node   : Node_Type);\n    procedure Generic_Write\n      (Stream : not null access Root_Stream_Type'Class;\n-      HT     : Hash_Table_Type'Class);\n+      HT     : Hash_Table_Type);\n    --  Used to implement the streaming attribute for hashed containers. It\n    --  calls Write for each node to write its value into Stream.\n \n@@ -148,7 +148,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n          return Count_Type;\n    procedure Generic_Read\n      (Stream : not null access Root_Stream_Type'Class;\n-      HT     : out Hash_Table_Type'Class);\n+      HT     : out Hash_Table_Type);\n    --  Used to implement the streaming attribute for hashed containers. It\n    --  first clears hash table HT, then populates the hash table by calling\n    --  New_Node for each item in Stream."}, {"sha": "b9f775f737565a1e2f0c3d460db6091948f91188", "filename": "gcc/ada/libgnat/a-cohata.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e12e78628238a9e3cf68ce9376aa2e28e0506f/gcc%2Fada%2Flibgnat%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohata.ads?ref=f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "patch": "@@ -89,7 +89,7 @@ package Ada.Containers.Hash_Tables is\n       type Hash_Table_Type\n         (Capacity : Count_Type;\n          Modulus  : Hash_Type) is\n-      tagged record\n+      record\n          Length  : Count_Type                  := 0;\n          Free    : Count_Type'Base             := -1;\n          Nodes   : Nodes_Type (1 .. Capacity);"}]}