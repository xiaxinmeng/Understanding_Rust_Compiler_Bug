{"sha": "c10d53dd60b1aa82fa460b70f16b791b54f7d116", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEwZDUzZGQ2MGIxYWE4MmZhNDYwYjcwZjE2Yjc5MWI1NGY3ZDExNg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T20:02:26Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T20:02:26Z"}, "message": "gcc.c (_WIN32): Don't include process.h or declare spawnv{,p}.\n\n\t* gcc.c (_WIN32): Don't include process.h or declare spawnv{,p}.\n\t(pexecute,pwait): Add prototypes.\n\t(PEXECUTE_{FIRST,LAST,SEARCH}): Define.\n\t(execv,execvp): Delete decls.\n\t(perror_exec): Delete.\n\t(pfatal_pexecute): New function.\n\t(pexecute support): Delete.\n\t(execute): -pipe not supported if _WIN32 or OS2.\n\tUpdate call to pexecute.  Fatal error if pexecute fails.  Call pwait.\n\nFrom-SVN: r12269", "tree": {"sha": "7e51cda4b91bd7fad24e85d558c86caac092ecb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e51cda4b91bd7fad24e85d558c86caac092ecb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c10d53dd60b1aa82fa460b70f16b791b54f7d116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10d53dd60b1aa82fa460b70f16b791b54f7d116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10d53dd60b1aa82fa460b70f16b791b54f7d116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10d53dd60b1aa82fa460b70f16b791b54f7d116/comments", "author": null, "committer": null, "parents": [{"sha": "c6e087c59c02378da1957dc4dc353aed177e8169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6e087c59c02378da1957dc4dc353aed177e8169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6e087c59c02378da1957dc4dc353aed177e8169"}], "stats": {"total": 269, "additions": 48, "deletions": 221}, "files": [{"sha": "eba5f075b16274ca924f243faa297ada82ff0bed", "filename": "gcc/gcc.c", "status": "modified", "additions": 48, "deletions": 221, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10d53dd60b1aa82fa460b70f16b791b54f7d116/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10d53dd60b1aa82fa460b70f16b791b54f7d116/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c10d53dd60b1aa82fa460b70f16b791b54f7d116", "patch": "@@ -39,10 +39,6 @@ compilation is specified by a string called a \"spec\".  */\n \n #ifndef _WIN32\n #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */\n-#else\n-#include <process.h>\n-int __spawnv ();\n-int __spawnvp ();\n #endif\n \n #include \"config.h\"\n@@ -62,6 +58,15 @@ int __spawnvp ();\n #define X_OK 1\n #endif\n \n+/* ??? Need to find a GCC header to put these in.  */\n+extern int pexecute PROTO ((const char *, char * const *, const char *,\n+\t\t\t    const char *, char **, char **, int));\n+extern int pwait PROTO ((int, int *, int));\n+/* Flag arguments to pexecute.  */\n+#define PEXECUTE_FIRST  1\n+#define PEXECUTE_LAST   2\n+#define PEXECUTE_SEARCH 4\n+\n #ifndef WIFSIGNALED\n #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)\n #endif\n@@ -140,8 +145,6 @@ extern char *sys_errlist[];\n extern char *strerror();\n #endif\n \n-extern int execv (), execvp ();\n-\n /* If a stage of compilation returns an exit status >= 1,\n    compilation of that file ceases.  */\n \n@@ -250,7 +253,7 @@ static void set_multilib_dir\tPROTO((void));\n static void print_multilib_info\tPROTO((void));\n static void pfatal_with_name\tPROTO((char *));\n static void perror_with_name\tPROTO((char *));\n-static void perror_exec\t\tPROTO((char *));\n+static void pfatal_pexecute\tPROTO((char *, char *));\n #ifdef HAVE_VPRINTF\n static void fatal\t\tPVPROTO((char *, ...));\n static void error\t\tPVPROTO((char *, ...));\n@@ -1862,201 +1865,6 @@ free_path_prefix (pprefix)\n     }\n   pprefix->plist = (struct prefix_list *) 0;\n }\n-\f\n-/* stdin file number.  */\n-#define STDIN_FILE_NO 0\n-\n-/* stdout file number.  */\n-#define STDOUT_FILE_NO 1\n-\n-/* value of `pipe': port index for reading.  */\n-#define READ_PORT 0\n-\n-/* value of `pipe': port index for writing.  */\n-#define WRITE_PORT 1\n-\n-/* Pipe waiting from last process, to be used as input for the next one.\n-   Value is STDIN_FILE_NO if no pipe is waiting\n-   (i.e. the next command is the first of a group).  */\n-\n-static int last_pipe_input;\n-\n-/* Fork one piped subcommand.  FUNC is the system call to use\n-   (either execv or execvp).  ARGV is the arg vector to use.\n-   NOT_LAST is nonzero if this is not the last subcommand\n-   (i.e. its output should be piped to the next one.)  */\n-\n-#ifdef __MSDOS__\n-\n-#include <process.h>\n-static int\n-pexecute (search_flag, program, argv, not_last)\n-     int search_flag;\n-     char *program;\n-     char *argv[];\n-     int not_last;\n-{\n-#ifdef __GO32__\n-  int i = (search_flag ? spawnv : spawnvp) (1, program, argv);\n-#else\n-  char *scmd, *rf;\n-  FILE *argfile;\n-  int i, el = search_flag ? 0 : 4;\n-\n-  scmd = (char *) xmalloc (strlen (program) + strlen (temp_filename) + 6 + el);\n-  rf = scmd + strlen(program) + 2 + el;\n-  sprintf (scmd, \"%s%s @%s.gp\", program,\n-\t   (search_flag ? \"\" : \".exe\"), temp_filename);\n-  argfile = fopen (rf, \"w\");\n-  if (argfile == 0)\n-    pfatal_with_name (rf);\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      char *cp;\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || isspace (*cp))\n-\t    fputc ('\\\\', argfile);\n-\t  fputc (*cp, argfile);\n-\t}\n-      fputc ('\\n', argfile);\n-    }\n-  fclose (argfile);\n-\n-  i = system (scmd);\n-\n-  remove (rf);\n-#endif\n-  \n-  if (i == -1)\n-    {\n-      perror_exec (program);\n-      return MIN_FATAL_STATUS << 8;\n-    }\n-  return i << 8;\n-}\n-\n-#endif\n-\n-#if !defined(__MSDOS__) && !defined(OS2) && !defined(_WIN32)\n-\n-static int\n-pexecute (search_flag, program, argv, not_last)\n-     int search_flag;\n-     char *program;\n-     char *argv[];\n-     int not_last;\n-{\n-  int (*func)() = (search_flag ? execv : execvp);\n-  int pid;\n-  int pdes[2];\n-  int input_desc = last_pipe_input;\n-  int output_desc = STDOUT_FILE_NO;\n-  int retries, sleep_interval;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-\n-  if (not_last)\n-    {\n-      if (pipe (pdes) < 0)\n-\tpfatal_with_name (\"pipe\");\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n-    }\n-  else\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  /* Fork a subprocess; wait and retry if it fails.  */\n-  sleep_interval = 1;\n-  for (retries = 0; retries < 4; retries++)\n-    {\n-      pid = vfork ();\n-      if (pid >= 0)\n-\tbreak;\n-      sleep (sleep_interval);\n-      sleep_interval *= 2;\n-    }\n-\n-  switch (pid)\n-    {\n-    case -1:\n-#ifdef vfork\n-      pfatal_with_name (\"fork\");\n-#else\n-      pfatal_with_name (\"vfork\");\n-#endif\n-      /* NOTREACHED */\n-      return 0;\n-\n-    case 0: /* child */\n-      /* Move the input and output pipes into place, if nec.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\t{\n-\t  close (STDIN_FILE_NO);\n-\t  dup (input_desc);\n-\t  close (input_desc);\n-\t}\n-      if (output_desc != STDOUT_FILE_NO)\n-\t{\n-\t  close (STDOUT_FILE_NO);\n-\t  dup (output_desc);\n-\t  close (output_desc);\n-\t}\n-\n-      /* Close the parent's descs that aren't wanted here.  */\n-      if (last_pipe_input != STDIN_FILE_NO)\n-\tclose (last_pipe_input);\n-\n-      /* Exec the program.  */\n-      (*func) (program, argv);\n-      perror_exec (program);\n-      exit (-1);\n-      /* NOTREACHED */\n-      return 0;\n-\n-    default:\n-      /* In the parent, after forking.\n-\t Close the descriptors that we made for this child.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\tclose (input_desc);\n-      if (output_desc != STDOUT_FILE_NO)\n-\tclose (output_desc);\n-\n-      /* Return child's process number.  */\n-      return pid;\n-    }\n-}\n-\n-#endif /* not __MSDOS__ and not OS2 and not _WIN32 */\n-\n-#if defined(OS2)\n-\n-static int\n-pexecute (search_flag, program, argv, not_last)\n-     int search_flag;\n-     char *program;\n-     char *argv[];\n-     int not_last;\n-{\n-  return (search_flag ? spawnv : spawnvp) (1, program, argv);\n-}\n-#endif /* OS2 */\n-\n-#if defined(_WIN32)\n-\n-static int\n-pexecute (search_flag, program, argv, not_last)\n-     int search_flag;\n-     char *program;\n-     char *argv[];\n-     int not_last;\n-{\n-  return (search_flag ? __spawnv : __spawnvp) (1, program, argv);\n-}\n-#endif /* _WIN32 */\n-\n \f\n /* Execute the command specified by the arguments on the current line of spec.\n    When using pipes, this includes several piped-together commands\n@@ -2101,8 +1909,8 @@ execute ()\n   for (n_commands = 1, i = 0; i < argbuf_index; i++)\n     if (strcmp (argbuf[i], \"|\") == 0)\n       {\t\t\t\t/* each command.  */\n-#ifdef __MSDOS__\n-        fatal (\"-pipe not supported under MS-DOS\");\n+#if defined (__MSDOS__) || defined (_WIN32) || defined (OS2)\n+        fatal (\"-pipe not supported\");\n #endif\n \targbuf[i] = 0;\t/* termination of command args.  */\n \tcommands[n_commands].prog = argbuf[i + 1];\n@@ -2146,14 +1954,21 @@ execute ()\n \n   /* Run each piped subprocess.  */\n \n-  last_pipe_input = STDIN_FILE_NO;\n   for (i = 0; i < n_commands; i++)\n     {\n+      char *errmsg_fmt, *errmsg_arg;\n       char *string = commands[i].argv[0];\n \n-      commands[i].pid = pexecute (string != commands[i].prog,\n-\t\t\t\t  string, commands[i].argv,\n-\t\t\t\t  i + 1 < n_commands);\n+      commands[i].pid = pexecute (string, commands[i].argv,\n+\t\t\t\t  programname, temp_filename,\n+\t\t\t\t  &errmsg_fmt, &errmsg_arg,\n+\t\t\t\t  ((i == 0 ? PEXECUTE_FIRST : 0)\n+\t\t\t\t   | (i + 1 == n_commands ? PEXECUTE_LAST : 0)\n+\t\t\t\t   | (string == commands[i].prog\n+\t\t\t\t      ? PEXECUTE_SEARCH : 0)));\n+\n+      if (commands[i].pid == -1)\n+\tpfatal_pexecute (errmsg_fmt, errmsg_arg);\n \n       if (string != commands[i].prog)\n \tfree (string);\n@@ -2176,15 +1991,7 @@ execute ()\n \tint status;\n \tint pid;\n \n-#ifdef __MSDOS__\n-        status = pid = commands[i].pid;\n-#else\n-#ifdef _WIN32\n-\tpid = cwait (&status, commands[i].pid, WAIT_CHILD);\n-#else\n-\tpid = wait (&status);\n-#endif\n-#endif\n+\tpid = pwait (commands[i].pid, &status, 0);\n \tif (pid < 0)\n \t  abort ();\n \n@@ -4746,11 +4553,31 @@ perror_with_name (name)\n }\n \n static void\n-perror_exec (name)\n-     char *name;\n+pfatal_pexecute (errmsg_fmt, errmsg_arg)\n+     char *errmsg_fmt;\n+     char *errmsg_arg;\n {\n-  error (\"installation problem, cannot exec `%s': %s\",\n-\t name, my_strerror (errno));\n+  char buf[30];\n+  char *s;\n+\n+  /* ??? Why doesn't my_strerror handle this?  */\n+  if (errno < sys_nerr)\n+    s = my_strerror (errno);\n+  else\n+    {\n+      sprintf (buf, \"unknown error %d\", errno);\n+      s = buf;\n+    }\n+\n+  if (errmsg_arg)\n+    {\n+      /* Space for trailing '\\0' is in %s.  */\n+      char *msg = xmalloc (strlen (errmsg_fmt) + strlen (errmsg_arg));\n+      sprintf (msg, errmsg_fmt, errmsg_arg);\n+      errmsg_fmt = msg;\n+    }\n+\n+  fatal (\"%s: %s\", errmsg_fmt, s);\n }\n \n /* More 'friendly' abort that prints the line and file."}]}