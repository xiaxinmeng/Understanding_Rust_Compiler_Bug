{"sha": "b335a54914864ff4da3ddd7493487b75844dd1bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMzNWE1NDkxNDg2NGZmNGRhM2RkZDc0OTM0ODdiNzU4NDRkZDFiYg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-05-05T06:02:37Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-05T06:02:37Z"}, "message": "2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/DecimalFormat.java\n\t(MAXIMUM_INTEGER_DIGITS): New constant to keep the numeric value 309.\n\t(applyPatternWithSymbols): Use MAXIMUM_INTEGER_DIGITS.\n\t(parse): Fixed handling of exponentiation notation and grouping.\n\nFrom-SVN: r81502", "tree": {"sha": "7328a518bd8b4c4f90b396122ed733e7a8628b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7328a518bd8b4c4f90b396122ed733e7a8628b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b335a54914864ff4da3ddd7493487b75844dd1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b335a54914864ff4da3ddd7493487b75844dd1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b335a54914864ff4da3ddd7493487b75844dd1bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b335a54914864ff4da3ddd7493487b75844dd1bb/comments", "author": null, "committer": null, "parents": [{"sha": "07b232667eed3d5c6d24c1ce59e9e8abea31330a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b232667eed3d5c6d24c1ce59e9e8abea31330a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b232667eed3d5c6d24c1ce59e9e8abea31330a"}], "stats": {"total": 149, "additions": 132, "deletions": 17}, "files": [{"sha": "497a705670c4227e07309a73c255f3a836c50c3d", "filename": "libjava/java/text/DecimalFormat.java", "status": "modified", "additions": 132, "deletions": 17, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b335a54914864ff4da3ddd7493487b75844dd1bb/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b335a54914864ff4da3ddd7493487b75844dd1bb/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=b335a54914864ff4da3ddd7493487b75844dd1bb", "patch": "@@ -330,7 +330,7 @@ private final void applyPatternWithSymbols (String pattern,\n     useExponentialNotation = false;\n     groupingUsed = false;\n     maximumFractionDigits = 0;\n-    maximumIntegerDigits = 309;\n+    maximumIntegerDigits = MAXIMUM_INTEGER_DIGITS;\n     minimumFractionDigits = 0;\n     minimumIntegerDigits = 1;\n \n@@ -562,7 +562,7 @@ protected void formatInternal (double number, FormatBuffer dest,\n \t    dest.append (symbols.getDecimalSeparator(), NumberFormat.Field.DECIMAL_SEPARATOR);\n \t  }\n \n-\n+\tint fraction_begin = dest.length();\n \tdest.setDefaultAttribute(NumberFormat.Field.FRACTION);\n \tfor (count = 0;\n \t     count < localMaximumFractionDigits\n@@ -594,6 +594,12 @@ protected void formatInternal (double number, FormatBuffer dest,\n \t      dest.cutTail(1);\n \t  }\n \n+\tif (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n+\t  {\n+\t    fieldPos.setBeginIndex(fraction_begin);\n+\t    fieldPos.setEndIndex(dest.length());\n+\t  }\n+\n \t// Finally, print the exponent.\n \tif (useExponentialNotation)\n \t  {\n@@ -793,14 +799,19 @@ public boolean isDecimalSeparatorAlwaysShown ()\n \n   public Number parse (String str, ParsePosition pos)\n   {\n-    // Our strategy is simple: copy the text into a buffer,\n-    // translating or omitting locale-specific information.  Then\n-    // let Double or Long convert the number for us.\n+    /*\n+     * Our strategy is simple: copy the text into separate buffers: one for the int part,\n+     * one for the fraction part and for the exponential part.\n+     * We translate or omit locale-specific information.  \n+     * If exponential is sufficiently big we merge the fraction and int part and\n+     * remove the '.' and then we use Long to convert the number. In the other\n+     * case, we use Double to convert the full number.\n+     */\n \n     boolean is_neg = false;\n     int index = pos.getIndex();\n-    StringBuffer buf = new StringBuffer ();\n-\n+    StringBuffer int_buf = new StringBuffer ();\n+        \n     // We have to check both prefixes, because one might be empty.  We\n     // want to pick the longest prefix that matches.\n     boolean got_pos = str.startsWith(positivePrefix, index);\n@@ -840,11 +851,17 @@ else if (got_pos)\n     // FIXME: do we have to respect minimum digits?\n     // What about leading zeros?  What about multiplier?\n \n+    StringBuffer buf = int_buf;\n+    StringBuffer frac_buf = null;\n+    StringBuffer exp_buf = null;\n     int start_index = index;\n     int max = str.length();\n-    int last = index + maximumIntegerDigits;\n+    int exp_index = -1;\n+    int last = index + MAXIMUM_INTEGER_DIGITS;\n+\n     if (last > 0 && max > last)\n       max = last;\n+\n     char zero = symbols.getZeroDigit();\n     int last_group = -1;\n     boolean int_part = true;\n@@ -863,12 +880,11 @@ else if (got_pos)\n \t\tpos.setErrorIndex(index);\n \t\treturn null;\n \t      }\n-\t    last_group = index;\n+\t    last_group = index+1;\n \t  }\n \telse if (c >= zero && c <= zero + 9)\n \t  {\n \t    buf.append((char) (c - zero + '0'));\n-\t    exp_part = false;\n \t  }\n \telse if (parseIntegerOnly)\n \t  break;\n@@ -881,14 +897,16 @@ else if (c == symbols.getDecimalSeparator())\n \t\tpos.setErrorIndex(index);\n \t\treturn null;\n \t      }\n-\t    buf.append('.');\n+\t    buf = frac_buf = new StringBuffer();\n+\t    frac_buf.append('.');\n \t    int_part = false;\n \t  }\n \telse if (c == symbols.getExponential())\n \t  {\n-\t    buf.append('E');\n+\t    buf = exp_buf = new StringBuffer();\n \t    int_part = false;\n \t    exp_part = true;\n+\t    exp_index = index+1;\n \t  }\n \telse if (exp_part\n \t\t && (c == '+' || c == '-' || c == symbols.getMinusSign()))\n@@ -932,16 +950,111 @@ else if (got_pos != got_pos_suf && got_neg != got_neg_suf)\n       }\n \n     String suffix = is_neg ? ns : positiveSuffix;\n+    long multiplier = 1;\n+    boolean use_long;\n+\n     if (is_neg)\n-      buf.insert(0, '-');\n+      int_buf.insert(0, '-');\n+\n+    // Now handle the exponential part if there is one.\n+    if (exp_buf != null)\n+      {\n+\tint exponent_value;\n+\n+\ttry\n+\t  {\n+\t    exponent_value = Integer.parseInt(exp_buf.toString());\n+\t  }\n+\tcatch (NumberFormatException x1)\n+\t  {\n+\t    pos.setErrorIndex(exp_index);\n+\t    return null;\n+\t  }\n+\n+\tif (frac_buf == null)\n+\t  {\n+\t    // We only have to add some zeros to the int part.\n+\t    // Build a multiplier.\n+\t    for (int i = 0; i < exponent_value; i++)\n+\t      int_buf.append('0');\n+\t    \n+\t    use_long = true;\n+\t  }\n+\telse\n+\t  {\n+\t    boolean long_sufficient;\n+\n+\t    if (exponent_value < frac_buf.length()-1)\n+\t      {\n+\t\tint lastNonNull = -1;\n+\t\t/* We have to check the fraction buffer: it may only be full of '0'\n+\t\t * or be sufficiently filled with it to convert the number into Long.\n+\t\t */\n+\t\tfor (int i = 1; i < frac_buf.length(); i++)\n+\t\t  if (frac_buf.charAt(i) != '0')\n+\t\t    lastNonNull = i;\n+\n+\t\tlong_sufficient = (lastNonNull < 0 || lastNonNull <= exponent_value);\n+\t      }\n+\t    else\n+\t      long_sufficient = true;\n+\t    \n+\t    if (long_sufficient)\n+\t      {\n+\t\tfor (int i = 1; i < frac_buf.length() && i < exponent_value; i++)\n+\t\t  int_buf.append(frac_buf.charAt(i));\n+\t\tfor (int i = frac_buf.length()-1; i < exponent_value; i++)\n+\t\t  int_buf.append('0');\n+\t\tuse_long = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/*\n+\t\t * A long type is not sufficient, we build the full buffer to\n+\t\t * be parsed by Double.\n+\t\t */\n+\t\tint_buf.append(frac_buf);\n+\t\tint_buf.append('E');\n+\t\tint_buf.append(exp_buf);\n+\t\tuse_long = false;\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\tif (frac_buf != null)\n+\t  {\n+\t    /* Check whether the fraction buffer contains only '0' */\n+\t    int i;\n+\t    for (i = 1; i < frac_buf.length(); i++)\n+\t      if (frac_buf.charAt(i) != '0')\n+\t\tbreak;\n+\t   \n+\t    if (i != frac_buf.length())\n+\t      {\n+\t\tuse_long = false;\n+\t\tint_buf.append(frac_buf);\n+\t      }\n+\t    else\n+\t      use_long = true;\n+\t  }\n+\telse\n+\t  use_long = true;\n+      }\n \n-    String t = buf.toString();\n+    String t = int_buf.toString();\n     Number result = null;\n-    try\n+    if (use_long)\n       {\n-\tresult = new Long (t);\n+\ttry\n+\t  {\n+\t    result = new Long (t);\n+\t  }\n+\tcatch (NumberFormatException x1)\n+\t  {\n+\t  }\n       }\n-    catch (NumberFormatException x1)\n+    else\n       {\n \ttry\n \t  {\n@@ -1110,6 +1223,8 @@ public String toPattern ()\n     return computePattern (nonLocalizedSymbols);\n   }\n \n+  private static final int MAXIMUM_INTEGER_DIGITS = 309; \n+\n   // These names are fixed by the serialization spec.\n   private boolean decimalSeparatorAlwaysShown;\n   private byte groupingSize;"}]}