{"sha": "2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1YWIxZTQzOGU1Y2YzODM4OTIyZGVkZTdmMWI4ZWE0OTc0YjMyYw==", "commit": {"author": {"name": "Michael Brune", "email": "lucdanton@free.fr", "date": "2013-11-01T20:08:39Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-11-01T20:08:39Z"}, "message": "enable_special_members.h: New.\n\n2013-10-31  Michael Brune  <lucdanton@free.fr>\n\n\t* include/bits/enable_special_members.h: New.\n\t* include/experimental/optional: New.\n\t* include/Makefile.am: Handle include/experimental.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/libstdc++-dg/conformance.exp: Run tests from\n\ttestsuite/experimental sub-directory.\n\t* testsuite/experimental/optional/assignment/1.cc: New.\n\t* testsuite/experimental/optional/assignment/2.cc: New.\n\t* testsuite/experimental/optional/assignment/3.cc: New.\n\t* testsuite/experimental/optional/assignment/4.cc: New.\n\t* testsuite/experimental/optional/assignment/5.cc: New.\n\t* testsuite/experimental/optional/assignment/6.cc: New.\n\t* testsuite/experimental/optional/cons/copy.cc: New.\n\t* testsuite/experimental/optional/cons/default.cc: New.\n\t* testsuite/experimental/optional/cons/move.cc: New.\n\t* testsuite/experimental/optional/cons/value.cc: New.\n\t* testsuite/experimental/optional/constexpr/cons/default.cc: New.\n\t* testsuite/experimental/optional/constexpr/cons/value.cc: New.\n\t* testsuite/experimental/optional/constexpr/in_place.cc: New.\n\t* testsuite/experimental/optional/constexpr/make_optional.cc: New.\n\t* testsuite/experimental/optional/constexpr/nullopt.cc: New.\n\t* testsuite/experimental/optional/constexpr/observers/1.cc: New.\n\t* testsuite/experimental/optional/constexpr/observers/2.cc: New.\n\t* testsuite/experimental/optional/constexpr/observers/3.cc: New.\n\t* testsuite/experimental/optional/constexpr/observers/4.cc: New.\n\t* testsuite/experimental/optional/constexpr/observers/5.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/1.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/2.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/3.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/4.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/5.cc: New.\n\t* testsuite/experimental/optional/constexpr/relops/6.cc: New.\n\t* testsuite/experimental/optional/in_place.cc: New.\n\t* testsuite/experimental/optional/make_optional.cc: New.\n\t* testsuite/experimental/optional/nullopt.cc: New.\n\t* testsuite/experimental/optional/observers/1.cc: New.\n\t* testsuite/experimental/optional/observers/2.cc: New.\n\t* testsuite/experimental/optional/observers/3.cc: New.\n\t* testsuite/experimental/optional/observers/4.cc: New.\n\t* testsuite/experimental/optional/observers/5.cc: New.\n\t* testsuite/experimental/optional/relops/1.cc: New.\n\t* testsuite/experimental/optional/relops/2.cc: New.\n\t* testsuite/experimental/optional/relops/3.cc: New.\n\t* testsuite/experimental/optional/relops/4.cc: New.\n\t* testsuite/experimental/optional/relops/5.cc: New.\n\t* testsuite/experimental/optional/relops/6.cc: New.\n\t* testsuite/experimental/optional/requirements.cc: New.\n\t* testsuite/experimental/optional/swap/1.cc: New.\n\nFrom-SVN: r204299", "tree": {"sha": "bde4bff4bf62bef490a103fa4bdfecfb41ec1aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bde4bff4bf62bef490a103fa4bdfecfb41ec1aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/comments", "author": {"login": "other-mickk", "id": 5111293, "node_id": "MDQ6VXNlcjUxMTEyOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5111293?v=4", "gravatar_id": "", "url": "https://api.github.com/users/other-mickk", "html_url": "https://github.com/other-mickk", "followers_url": "https://api.github.com/users/other-mickk/followers", "following_url": "https://api.github.com/users/other-mickk/following{/other_user}", "gists_url": "https://api.github.com/users/other-mickk/gists{/gist_id}", "starred_url": "https://api.github.com/users/other-mickk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/other-mickk/subscriptions", "organizations_url": "https://api.github.com/users/other-mickk/orgs", "repos_url": "https://api.github.com/users/other-mickk/repos", "events_url": "https://api.github.com/users/other-mickk/events{/privacy}", "received_events_url": "https://api.github.com/users/other-mickk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7920263202cd3d7b421750abc49cf5b66f31d25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7920263202cd3d7b421750abc49cf5b66f31d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7920263202cd3d7b421750abc49cf5b66f31d25"}], "stats": {"total": 4791, "additions": 4785, "deletions": 6}, "files": [{"sha": "f5129329636b76685dfa3d204cff99889e736b82", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -1,3 +1,54 @@\n+2013-10-31  Michael Brune  <lucdanton@free.fr>\n+\n+\t* include/bits/enable_special_members.h: New.\n+\t* include/experimental/optional: New.\n+\t* include/Makefile.am: Handle include/experimental.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/libstdc++-dg/conformance.exp: Run tests from\n+\ttestsuite/experimental sub-directory.\n+\t* testsuite/experimental/optional/assignment/1.cc: New.\n+\t* testsuite/experimental/optional/assignment/2.cc: New.\n+\t* testsuite/experimental/optional/assignment/3.cc: New.\n+\t* testsuite/experimental/optional/assignment/4.cc: New.\n+\t* testsuite/experimental/optional/assignment/5.cc: New.\n+\t* testsuite/experimental/optional/assignment/6.cc: New.\n+\t* testsuite/experimental/optional/cons/copy.cc: New.\n+\t* testsuite/experimental/optional/cons/default.cc: New.\n+\t* testsuite/experimental/optional/cons/move.cc: New.\n+\t* testsuite/experimental/optional/cons/value.cc: New.\n+\t* testsuite/experimental/optional/constexpr/cons/default.cc: New.\n+\t* testsuite/experimental/optional/constexpr/cons/value.cc: New.\n+\t* testsuite/experimental/optional/constexpr/in_place.cc: New.\n+\t* testsuite/experimental/optional/constexpr/make_optional.cc: New.\n+\t* testsuite/experimental/optional/constexpr/nullopt.cc: New.\n+\t* testsuite/experimental/optional/constexpr/observers/1.cc: New.\n+\t* testsuite/experimental/optional/constexpr/observers/2.cc: New.\n+\t* testsuite/experimental/optional/constexpr/observers/3.cc: New.\n+\t* testsuite/experimental/optional/constexpr/observers/4.cc: New.\n+\t* testsuite/experimental/optional/constexpr/observers/5.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/1.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/2.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/3.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/4.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/5.cc: New.\n+\t* testsuite/experimental/optional/constexpr/relops/6.cc: New.\n+\t* testsuite/experimental/optional/in_place.cc: New.\n+\t* testsuite/experimental/optional/make_optional.cc: New.\n+\t* testsuite/experimental/optional/nullopt.cc: New.\n+\t* testsuite/experimental/optional/observers/1.cc: New.\n+\t* testsuite/experimental/optional/observers/2.cc: New.\n+\t* testsuite/experimental/optional/observers/3.cc: New.\n+\t* testsuite/experimental/optional/observers/4.cc: New.\n+\t* testsuite/experimental/optional/observers/5.cc: New.\n+\t* testsuite/experimental/optional/relops/1.cc: New.\n+\t* testsuite/experimental/optional/relops/2.cc: New.\n+\t* testsuite/experimental/optional/relops/3.cc: New.\n+\t* testsuite/experimental/optional/relops/4.cc: New.\n+\t* testsuite/experimental/optional/relops/5.cc: New.\n+\t* testsuite/experimental/optional/relops/6.cc: New.\n+\t* testsuite/experimental/optional/requirements.cc: New.\n+\t* testsuite/experimental/optional/swap/1.cc: New.\n+\n 2013-11-01  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/stl_function.h (logical_not<void>): Add noexcept."}, {"sha": "505679af5ae092e0e5f0c81f20e2023704ac3057", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -94,6 +94,7 @@ bits_headers = \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/enable_special_members.h \\\n \t${bits_srcdir}/forward_list.h \\\n \t${bits_srcdir}/forward_list.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n@@ -633,6 +634,12 @@ decimal_headers = \\\n \t${decimal_srcdir}/decimal \\\n \t${decimal_srcdir}/decimal.h\n \n+# Post-C++11 TS's\n+experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n+experimental_builddir = ./experimental\n+experimental_headers = \\\n+\t${experimental_srcdir}/optional\n+\n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n c_base_builddir = .\n@@ -910,8 +917,8 @@ endif\n allstamped = \\\n \tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n-\tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n-\tstamp-host\n+\tstamp-experimental stamp-debug stamp-parallel stamp-profile \\\n+\tstamp-profile-impl stamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -1034,6 +1041,11 @@ stamp-decimal: ${decimal_headers}\n \t@-cd ${decimal_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-decimal\n \n+stamp-experimental: ${experimental_headers}\n+\t@-mkdir -p ${experimental_builddir}\n+\t@-cd ${experimental_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-experimental\n+\n stamp-debug: ${debug_headers}\n \t@-mkdir -p ${debug_builddir}\n \t@-cd ${debug_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1277,6 +1289,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${decimal_builddir}\n \tfor file in ${decimal_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${decimal_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${experimental_builddir}\n+\tfor file in ${experimental_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${experimental_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done\n@@ -1322,9 +1337,10 @@ clean-local:\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n .PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr2_headers)\n-\t   $(decimal_headers) $(ext_headers)\n+\t   $(decimal_headers) $(ext_headers) $(experimental_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n $(decimal_headers): ; @:\n $(ext_headers): ; @:\n+$(experimental_headers): ; @:"}, {"sha": "1f5daba83f77915cb0461cf59dfbfd09ee7fd011", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -361,6 +361,7 @@ bits_headers = \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/enable_special_members.h \\\n \t${bits_srcdir}/forward_list.h \\\n \t${bits_srcdir}/forward_list.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n@@ -899,6 +900,13 @@ decimal_headers = \\\n \t${decimal_srcdir}/decimal.h\n \n \n+# Post-C++11 TS's\n+experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n+experimental_builddir = ./experimental\n+experimental_headers = \\\n+\t${experimental_srcdir}/optional\n+\n+\n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n c_base_builddir = .\n@@ -1166,8 +1174,8 @@ PCHFLAGS = -x c++-header -nostdinc++ $(CXXFLAGS) $(VTV_PCH_CXXFLAGS)\n allstamped = \\\n \tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n-\tstamp-debug stamp-parallel stamp-profile stamp-profile-impl \\\n-\tstamp-host\n+\tstamp-experimental stamp-debug stamp-parallel stamp-profile \\\n+\tstamp-profile-impl stamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1452,6 +1460,11 @@ stamp-decimal: ${decimal_headers}\n \t@-cd ${decimal_builddir} && $(LN_S) $? . 2>/dev/null\n \t@$(STAMP) stamp-decimal\n \n+stamp-experimental: ${experimental_headers}\n+\t@-mkdir -p ${experimental_builddir}\n+\t@-cd ${experimental_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-experimental\n+\n stamp-debug: ${debug_headers}\n \t@-mkdir -p ${debug_builddir}\n \t@-cd ${debug_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1680,6 +1693,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${decimal_builddir}\n \tfor file in ${decimal_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${decimal_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${experimental_builddir}\n+\tfor file in ${experimental_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${experimental_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done\n@@ -1722,12 +1738,13 @@ clean-local:\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n .PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr2_headers)\n-\t   $(decimal_headers) $(ext_headers)\n+\t   $(decimal_headers) $(ext_headers) $(experimental_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n $(decimal_headers): ; @:\n $(ext_headers): ; @:\n+$(experimental_headers): ; @:\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "eb90037e66fbea77e65fd4d38a747c2e5f1e970c", "filename": "libstdc++-v3/include/bits/enable_special_members.h", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fenable_special_members.h?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,278 @@\n+// <bits/enable_special_members.h> -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/enable_special_members.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly.\n+ */\n+\n+#ifndef _ENABLE_SPECIAL_MEMBERS_H\n+#define _ENABLE_SPECIAL_MEMBERS_H 1\n+\n+#pragma GCC system_header\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+/**\n+  * @brief A mixin helper to conditionally enable or disable the default\n+  * constructor.\n+  * @sa _Enable_special_members\n+  */\n+template<bool _Switch, typename _Tag = void>\n+  struct _Enable_default_constructor { };\n+\n+\n+/**\n+  * @brief A mixin helper to conditionally enable or disable the default\n+  * destructor.\n+  * @sa _Enable_special_members\n+  */\n+template<bool _Switch, typename _Tag = void>\n+  struct _Enable_destructor { };\n+\n+/**\n+  * @brief A mixin helper to conditionally enable or disable the copy/move\n+  * special members.\n+  * @sa _Enable_special_members\n+  */\n+template<bool _Copy, bool _CopyAssignment,\n+         bool _Move, bool _MoveAssignment,\n+         typename _Tag = void>\n+  struct _Enable_copy_move { };\n+\n+/**\n+  * @brief A mixin helper to conditionally enable or disable the special\n+  * members.\n+  *\n+  * The @c _Tag type parameter is to make mixin bases unique and thus avoid\n+  * ambiguities.\n+  */\n+template<bool _Default, bool _Destructor,\n+         bool _Copy, bool _CopyAssignment,\n+         bool _Move, bool _MoveAssignment,\n+         typename _Tag = void>\n+  struct _Enable_special_members\n+  : private _Enable_default_constructor<_Default, _Tag>,\n+    private _Enable_destructor<_Destructor, _Tag>,\n+    private _Enable_copy_move<_Copy, _CopyAssignment,\n+                              _Move, _MoveAssignment,\n+                              _Tag>\n+  { };\n+\n+// Boilerplate follows.\n+\n+template<typename _Tag>\n+  struct _Enable_default_constructor<false, _Tag>\n+  { constexpr _Enable_default_constructor() noexcept = delete; };\n+\n+template<typename _Tag>\n+  struct _Enable_destructor<false, _Tag>\n+  { ~_Enable_destructor() noexcept = delete; };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, true, true, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, false, true, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, false, true, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, true, false, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, true, false, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, false, false, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, false, false, true, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = default;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, true, true, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, true, true, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, false, true, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, false, true, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, true, false, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, true, false, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = default;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<true, false, false, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+template<typename _Tag>\n+  struct _Enable_copy_move<false, false, false, false, _Tag>\n+  {\n+    constexpr _Enable_copy_move() noexcept                          = default;\n+    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;\n+    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move const&) noexcept                    = delete;\n+    _Enable_copy_move&\n+    operator=(_Enable_copy_move&&) noexcept                         = delete;\n+  };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // _ENABLE_SPECIAL_MEMBERS_H"}, {"sha": "5915892aec256c32c5181fa75c70ad8799ef83a8", "filename": "libstdc++-v3/include/experimental/optional", "status": "added", "additions": 828, "deletions": 0, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,828 @@\n+// <optional> -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/optional\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_OPTIONAL\n+#define _GLIBCXX_EXPERIMENTAL_OPTIONAL 1\n+\n+/**\n+ * @defgroup experimental Experimental\n+ *\n+ * Components specified by various Technical Specifications.\n+ */\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <utility>\n+#include <type_traits>\n+#include <stdexcept>\n+#include <new>\n+#include <initializer_list>\n+#include <bits/functexcept.h>\n+#include <bits/functional_hash.h>\n+#include <bits/enable_special_members.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @defgroup optional Optional values\n+   * @ingroup experimental\n+   *\n+   * Class template for optional values and surrounding facilities, as\n+   * described in n3793 \"A proposal to add a utility class to represent\n+   * optional objects (Revision 5)\".\n+   *\n+   * @{\n+   */\n+\n+  // All subsequent [X.Y.n] references are against n3793.\n+\n+  // [X.Y.4]\n+  template<typename _Tp>\n+    class optional;\n+\n+  // [X.Y.5]\n+  /// Tag type for in-place construction.\n+  struct in_place_t { };\n+\n+  /// Tag for in-place construction.\n+  constexpr in_place_t in_place { };\n+\n+  // [X.Y.6]\n+  /// Tag type to disengage optional objects.\n+  struct nullopt_t\n+  {\n+    // Do not user-declare default constructor at all for\n+    // optional_value = {} syntax to work.\n+    // nullopt_t() = delete;\n+\n+    // Used for constructing nullopt.\n+    enum class _Construct { _Token };\n+\n+    // Must be constexpr for nullopt_t to be literal.\n+    explicit constexpr nullopt_t(_Construct) { }\n+  };\n+\n+  // [X.Y.6]\n+  /// Tag to disengage optional objects.\n+  constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };\n+\n+  // [X.Y.7]\n+  /**\n+   *  @brief Exception class thrown when a disengaged optional object is\n+   *  dereferenced.\n+   *  @ingroup exceptions\n+   */\n+  class bad_optional_access : public logic_error\n+  {\n+  public:\n+    // XXX Should not be inline\n+    explicit bad_optional_access(const string& __arg) : logic_error(__arg) { }\n+\n+    explicit bad_optional_access(const char* __arg) : logic_error(__arg) { }\n+\n+    virtual ~bad_optional_access() noexcept = default;\n+  };\n+\n+  void\n+  __throw_bad_optional_access(const char*)\n+  __attribute__((__noreturn__));\n+\n+  // XXX Does not belong here.\n+  inline void\n+  __throw_bad_optional_access(const char* __s)\n+  { _GLIBCXX_THROW_OR_ABORT(bad_optional_access(__s)); }\n+\n+  template<typename _Tp, typename _Sfinae = void>\n+    struct _Has_addressof_impl : std::false_type { };\n+\n+  template<typename _Tp>\n+    struct _Has_addressof_impl<_Tp,\n+      decltype( std::declval<const _Tp&>().operator&(), void() )>\n+    : std::true_type { };\n+\n+  /**\n+    * @brief Trait that detects the presence of an overloaded unary operator&.\n+    *\n+    * Practically speaking this detects the presence of such an operator when\n+    * called on a const-qualified lvalue (i.e.\n+    * declval<_Tp * const&>().operator&()).\n+    */\n+  template<typename _Tp>\n+    struct _Has_addressof : _Has_addressof_impl<_Tp>::type { };\n+\n+  /**\n+    * @brief An overload that attempts to take the address of an lvalue as a\n+    * constant expression. Falls back to __addressof in the presence of an\n+    * overloaded addressof operator (unary operator&), in which case the call\n+    * will not be a constant expression.\n+    */\n+  template<typename _Tp, typename enable_if<!_Has_addressof<_Tp>::value,\n+                                            int>::type...>\n+    constexpr _Tp* __constexpr_addressof(_Tp& __t)\n+    { return &__t; }\n+\n+  /**\n+    * @brief Fallback overload that defers to __addressof.\n+    */\n+  template<typename _Tp, typename enable_if<_Has_addressof<_Tp>::value,\n+                                            int>::type...>\n+    _Tp* __constexpr_addressof(_Tp& __t)\n+    { return std::__addressof(__t); }\n+\n+  /**\n+    * @brief Class template that holds the necessary state for @ref optional\n+    * and that has the responsibility for construction and the special members.\n+    *\n+    * Such a separate base class template is necessary in order to\n+    * conditionally enable the special members (e.g. copy/move constructors).\n+    * Note that this means that @ref _Optional_base implements the\n+    * functionality for copy and move assignment, but not for converting\n+    * assignment.\n+    *\n+    * @see optional, _Enable_special_members\n+    */\n+  template<typename _Tp, bool _ShouldProvideDestructor =\n+\t   !is_trivially_destructible<_Tp>::value>\n+    class _Optional_base\n+    {\n+    private:\n+      // Remove const to avoid prohibition of reusing object storage for\n+      // const-qualified types in [3.8/9]. This is strictly internal\n+      // and even optional itself is oblivious to it.\n+      using _Stored_type = typename remove_const<_Tp>::type;\n+\n+    public:\n+      // [X.Y.4.1] Constructors.\n+\n+      // Constructors for disengaged optionals.\n+      constexpr _Optional_base() noexcept\n+      : _M_empty{} { }\n+\n+      constexpr _Optional_base(nullopt_t) noexcept\n+      : _Optional_base{} { }\n+\n+      // Constructors for engaged optionals.\n+      constexpr _Optional_base(const _Tp& __t)\n+      : _M_payload(__t), _M_engaged(true) { }\n+\n+      constexpr _Optional_base(_Tp&& __t)\n+      : _M_payload(std::move(__t)), _M_engaged(true) { }\n+\n+      template<typename... _Args>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+\n+      template<typename _Up, typename... _Args,\n+               typename enable_if<is_constructible<_Tp,\n+                                                   initializer_list<_Up>&,\n+                                                   _Args&&...>::value,\n+                                  int>::type...>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(__il, std::forward<_Args>(__args)...),\n+          _M_engaged(true) { }\n+\n+      // Copy and move constructors.\n+      _Optional_base(const _Optional_base& __other)\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(__other._M_get());\n+      }\n+\n+      _Optional_base(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>())\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(std::move(__other._M_get()));\n+      }\n+\n+      // [X.Y.4.3] (partly) Assignment.\n+      _Optional_base&\n+      operator=(const _Optional_base& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+        {\n+          if (__other._M_engaged)\n+            this->_M_construct(__other._M_get());\n+          else\n+            this->_M_reset();\n+        }\n+\n+        return *this;\n+      }\n+\n+      _Optional_base&\n+      operator=(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>()\n+               && is_nothrow_move_assignable<_Tp>())\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = std::move(__other._M_get());\n+        else\n+        {\n+          if (__other._M_engaged)\n+            this->_M_construct(std::move(__other._M_get()));\n+          else\n+            this->_M_reset();\n+        }\n+\n+        return *this;\n+      }\n+\n+      // [X.Y.4.2] Destructor.\n+      ~_Optional_base()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_payload.~_Stored_type();\n+      }\n+\n+      // The following functionality is also needed by optional, hence the\n+      // protected accessibility.\n+    protected:\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      _Tp&\n+      _M_get() noexcept\n+      { return _M_payload; }\n+\n+      constexpr const _Tp&\n+      _M_get() const noexcept\n+      { return _M_payload; }\n+\n+      // The _M_construct operation has !_M_engaged as a precondition\n+      // while _M_destruct has _M_engaged as a precondition.\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new (std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      void\n+      _M_destruct()\n+      {\n+        this->_M_engaged = false;\n+        this->_M_payload.~_Stored_type();\n+      }\n+\n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_destruct();\n+      }\n+\n+    private:\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+    };\n+\n+  /// Partial specialization that is exactly identical to the primary template\n+  /// save for not providing a destructor, to fulfill triviality requirements.\n+  template<typename _Tp>\n+    class _Optional_base<_Tp, false>\n+    {\n+    private:\n+      using _Stored_type = typename remove_const<_Tp>::type;\n+\n+    public:\n+      constexpr _Optional_base() noexcept\n+      : _M_empty{} { }\n+\n+      constexpr _Optional_base(nullopt_t) noexcept\n+      : _Optional_base{} { }\n+\n+      constexpr _Optional_base(const _Tp& __t)\n+      : _M_payload(__t), _M_engaged(true) { }\n+\n+      constexpr _Optional_base(_Tp&& __t)\n+      : _M_payload(std::move(__t)), _M_engaged(true) { }\n+\n+      template<typename... _Args>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+\n+      template<typename _Up, typename... _Args,\n+               typename enable_if<is_constructible<_Tp,\n+                                                   initializer_list<_Up>&,\n+                                                   _Args&&...>::value,\n+                                  int>::type...>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(__il, std::forward<_Args>(__args)...),\n+          _M_engaged(true) { }\n+\n+      _Optional_base(const _Optional_base& __other)\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(__other._M_get());\n+      }\n+\n+      _Optional_base(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>())\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(std::move(__other._M_get()));\n+      }\n+\n+      _Optional_base&\n+      operator=(const _Optional_base& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+        {\n+          if (__other._M_engaged)\n+            this->_M_construct(__other._M_get());\n+          else\n+            this->_M_reset();\n+        }\n+\n+        return *this;\n+      }\n+\n+      _Optional_base&\n+      operator=(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>()\n+               && is_nothrow_move_assignable<_Tp>())\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = std::move(__other._M_get());\n+        else\n+        {\n+          if (__other._M_engaged)\n+            this->_M_construct(std::move(__other._M_get()));\n+          else\n+            this->_M_reset();\n+        }\n+\n+        return *this;\n+      }\n+\n+      // Sole difference\n+      // ~_Optional_base() noexcept = default;\n+\n+    protected:\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_engaged; }\n+\n+      _Tp&\n+      _M_get() noexcept\n+      { return _M_payload; }\n+\n+      constexpr const _Tp&\n+      _M_get() const noexcept\n+      { return _M_payload; }\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new (std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      void\n+      _M_destruct()\n+      {\n+        this->_M_engaged = false;\n+        this->_M_payload.~_Stored_type();\n+      }\n+\n+      void\n+      _M_reset()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_destruct();\n+      }\n+\n+    private:\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+    };\n+\n+  /**\n+    * @brief Class template for optional values.\n+    */\n+  template<typename _Tp>\n+    class optional\n+    : private _Optional_base<_Tp>,\n+      private _Enable_copy_move<\n+        // Copy constructor.\n+        is_copy_constructible<_Tp>::value,\n+        // Copy assignment.\n+        is_copy_constructible<_Tp>::value\n+        && is_copy_assignable<_Tp>::value,\n+        // Move constructor.\n+        is_move_constructible<_Tp>::value,\n+        // Move assignment.\n+        is_move_constructible<_Tp>::value\n+        && is_move_assignable<_Tp>::value,\n+        // Unique tag type.\n+        optional<_Tp>>\n+    {\n+      static_assert(!is_same<typename remove_cv<_Tp>::type,\n+                             nullopt_t>()\n+                    && !is_same<typename remove_cv<_Tp>::type,\n+                             in_place_t>()\n+                    && !is_reference<_Tp>(),\n+                    \"Invalid instantiation of optional<T>.\");\n+\n+    private:\n+      using _Base = _Optional_base<_Tp>;\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      // _Optional_base has the responsibility for construction.\n+      using _Base::_Base;\n+\n+      // [X.Y.4.3] (partly) Assignment.\n+      optional&\n+      operator=(nullopt_t) noexcept\n+      {\n+        this->_M_reset();\n+        return *this;\n+      }\n+\n+      template<typename _Up>\n+        typename enable_if<\n+                 is_same<_Tp, typename decay<_Up>::type>::value,\n+                 optional&\n+               >::type\n+        operator=(_Up&& __u)\n+        {\n+          static_assert(is_constructible<_Tp, _Up>()\n+                        && is_assignable<_Tp&, _Up>(),\n+                        \"Cannot assign to value type from argument.\");\n+\n+          if (this->_M_is_engaged())\n+            this->_M_get() = std::forward<_Up>(__u);\n+          else\n+            this->_M_construct(std::forward<_Up>(__u));\n+\n+          return *this;\n+        }\n+\n+      template<typename... _Args>\n+\tvoid\n+\templace(_Args&&... __args)\n+\t{\n+\t  static_assert(is_constructible<_Tp, _Args&&...>(),\n+\t\t\t\"Cannot emplace value type from arguments.\");\n+\n+\t  this->_M_reset();\n+\t  this->_M_construct(std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Up, typename... _Args>\n+        typename enable_if<\n+                 is_constructible<_Tp,\n+                                  initializer_list<_Up>&,\n+                                  _Args&&...>::value\n+               >::type\n+\templace(initializer_list<_Up> __il, _Args&&... __args)\n+\t{\n+\t  this->_M_reset();\n+\t  this->_M_construct(__il, std::forward<_Args>(__args)...);\n+\t}\n+\n+      // [X.Y.4.2] Destructor is implicit, implemented in _Optional_base.\n+\n+      // [X.Y.4.4] Swap.\n+      void\n+      swap(optional& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>()\n+               && noexcept(swap(declval<_Tp&>(), declval<_Tp&>())))\n+      {\n+        using std::swap;\n+\n+        if (this->_M_is_engaged() && __other._M_is_engaged())\n+          swap(this->_M_get(), __other._M_get());\n+        else if (this->_M_is_engaged())\n+        {\n+          __other._M_construct(std::move(this->_M_get()));\n+          this->_M_destruct();\n+        }\n+        else if (__other._M_is_engaged())\n+        {\n+          this->_M_construct(std::move(__other._M_get()));\n+          __other._M_destruct();\n+        }\n+      }\n+\n+      // [X.Y.4.5] Observers.\n+      constexpr const _Tp*\n+      operator->() const\n+      { return __constexpr_addressof(this->_M_get()); }\n+\n+      _Tp*\n+      operator->()\n+      { return std::__addressof(this->_M_get()); }\n+\n+      constexpr const _Tp&\n+      operator*() const\n+      { return this->_M_get(); }\n+\n+      _Tp&\n+      operator*()\n+      { return this->_M_get(); }\n+\n+      constexpr explicit operator bool() const noexcept\n+      { return this->_M_is_engaged(); }\n+\n+      constexpr const _Tp&\n+      value() const\n+      {\n+        return this->_M_is_engaged() ?\n+          this->_M_get() :\n+          (__throw_bad_optional_access(\"Attempt to access value of a disengaged\"\n+                                       \" optional object.\"),\n+           this->_M_get());\n+      }\n+\n+      _Tp&\n+      value()\n+      {\n+        if (this->_M_is_engaged())\n+          return this->_M_get();\n+\n+        __throw_bad_optional_access(\"Attempt to access value of a disengaged\"\n+                                    \" optional object.\");\n+      }\n+\n+      template<typename _Up>\n+\tconstexpr _Tp\n+\tvalue_or(_Up&& __u) const&\n+\t{\n+\t  static_assert(is_copy_constructible<_Tp>()\n+\t\t\t&& is_convertible<_Up&&, _Tp>(),\n+\t\t\t\"Cannot return value.\");\n+\n+\t  return this->_M_is_engaged() ?\n+\t    this->_M_get() :\n+\t    static_cast<_Tp>(std::forward<_Up>(__u));\n+\t}\n+\n+      template<typename _Up>\n+\t_Tp\n+\tvalue_or(_Up&& __u) &&\n+\t{\n+\t  static_assert( is_move_constructible<_Tp>()\n+\t\t\t&& is_convertible<_Up&&, _Tp>(),\n+\t\t\t\"Cannot return value.\" );\n+\n+\t  return this->_M_is_engaged() ?\n+\t    std::move(this->_M_get()) :\n+\t    static_cast<_Tp>(std::forward<_Up>(__u));\n+\t}\n+    };\n+\n+  // [X.Y.8] Comparisons between optional values.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    {\n+      return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)\n+        && (!__lhs || *__lhs == *__rhs);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__lhs == __rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    {\n+      return static_cast<bool>(__rhs)\n+        && (!__lhs || *__lhs < *__rhs);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs < __lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__rhs < __lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__lhs < __rhs); }\n+\n+  // [X.Y.9] Comparisons with nullopt.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return !__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return !__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return static_cast<bool>(__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return static_cast<bool>(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept\n+    { return false; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return static_cast<bool>(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return static_cast<bool>(__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept\n+    { return false; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return !__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept\n+    { return true; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept\n+    { return true; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return !__rhs; }\n+\n+  // [X.Y.10] Comparisons with value type.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && *__lhs == __rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && __lhs == *__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, _Tp const& __rhs)\n+    { return !__lhs || *__lhs != __rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || __lhs != *__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return !__lhs || *__lhs < __rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && __lhs < *__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && __rhs < *__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || *__rhs < __lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return !__lhs || !(__rhs < *__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && !(*__rhs < __lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && !(*__lhs < __rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || !(__lhs < *__rhs); }\n+\n+  // [X.Y.11]\n+  template<typename _Tp>\n+    void\n+    swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)\n+    noexcept(noexcept(__lhs.swap(__rhs)))\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr optional<typename decay<_Tp>::type>\n+    make_optional(_Tp&& __t)\n+    { return optional<typename decay<_Tp>::type> { std::forward<_Tp>(__t) }; }\n+\n+  // @} group optional\n+_GLIBCXX_END_NAMESPACE_VERSION\n+}\n+\n+  // [X.Y.12]\n+  template<typename _Tp>\n+    struct hash<experimental::optional<_Tp>>\n+    {\n+      using result_type = size_t;\n+      using argument_type = experimental::optional<_Tp>;\n+\n+      size_t\n+      operator()(const experimental::optional<_Tp>& __t) const\n+      noexcept(noexcept(hash<_Tp> {}(*__t)))\n+      {\n+        // We pick an arbitrary hash for disengaged optionals which hopefully\n+        // usual values of _Tp won't typically hash to.\n+        constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);\n+        return __t ? hash<_Tp> {}(*__t) : __magic_disengaged_hash;\n+      }\n+    };\n+}\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_OPTIONAL"}, {"sha": "b09e0acde7456443acf178c7a0ba7888e82f6cc0", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/1.cc", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,195 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return O { std::experimental::in_place, s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check copy/move assignment for disengaged optional\n+\n+  // From disengaged optional\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p;\n+    o = p;\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p;\n+    o = std::move(p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  // From engaged optional\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_copy_assignment);\n+    o = p;\n+    VERIFY( o && o->state == S::throwing_copy_assignment );\n+    VERIFY( p && p->state == S::throwing_copy_assignment );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_move_assignment);\n+    o = std::move(p);\n+    VERIFY( o && o->state == S::throwing_move_assignment );\n+    VERIFY( p && p->state == S::moved_from );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_copy);\n+\n+    try\n+    {\n+      o = p;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !o );\n+    VERIFY( p && p->state == S::throwing_copy );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_move);\n+\n+    try\n+    {\n+      o = std::move(p);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !o );\n+    VERIFY( p && p->state == S::moved_from );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "7985fffe8f750bacd2ca43c08877f7cd0a8f3754", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/2.cc", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F2.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,193 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return O { std::experimental::in_place, s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check copy/move assignment for engaged optional\n+\n+  // From disengaged optional\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p;\n+    o = p;\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p;\n+    o = std::move(p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  // From engaged optional\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_copy);\n+    o = p;\n+    VERIFY( o && o->state == S::throwing_copy);\n+    VERIFY( p && p->state == S::throwing_copy);\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_move);\n+    o = std::move(p);\n+    VERIFY( o && o->state == S::throwing_move);\n+    VERIFY( p && p->state == S::moved_from);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_copy_assignment);\n+\n+    try\n+    {\n+      o = p;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw);\n+    VERIFY( p && p->state == S::throwing_copy_assignment);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_move_assignment);\n+\n+    try\n+    {\n+      o = std::move(p);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw);\n+    VERIFY( p && p->state == S::moved_from);\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "d631886269cc11c42059c0bb46ff68359e1812b4", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/3.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F3.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,158 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return value_type { s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check value assignment for disengaged optional\n+\n+  {\n+    O o;\n+    value_type v = make(S::throwing_copy_assignment);\n+    o = v;\n+    VERIFY( o && o->state == S::throwing_copy_assignment );\n+  }\n+\n+  {\n+    O o;\n+    value_type v = make(S::throwing_move_assignment);\n+    o = std::move(v);\n+    VERIFY( o && o->state == S::throwing_move_assignment );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    value_type v = make(S::throwing_copy);\n+\n+    try\n+    {\n+      o = v;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    value_type v = make(S::throwing_move);\n+\n+    try\n+    {\n+      o = std::move(v);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "e5f1f1691cc02c1f2668625720eb4cc01e38eaa4", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/4.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F4.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,158 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return value_type { s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check value assignment for engaged optional\n+\n+  {\n+    O o = make();\n+    value_type v = make(S::throwing_copy);\n+    o = v;\n+    VERIFY( o && o->state == S::throwing_copy);\n+  }\n+\n+  {\n+    O o = make();\n+    value_type v = make(S::throwing_move);\n+    o = std::move(v);\n+    VERIFY( o && o->state == S::throwing_move);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make();\n+    value_type v = make(S::throwing_copy_assignment);\n+\n+    try\n+    {\n+      o = v;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make();\n+    value_type v = make(S::throwing_move_assignment);\n+\n+    try\n+    {\n+      o = std::move(v);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "d6e268f44643066c73cf7dba564dc4dcbd4d67b9", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/5.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F5.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter { };\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+\n+  // Check std::experimental::nullopt_t and 'default' (= {}) assignment\n+\n+  {\n+    O o;\n+    o = std::experimental::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place };\n+    o = std::experimental::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o;\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place };\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "55be89d0dcf31fbb1e48b7d427f59376e666ffaf", "filename": "libstdc++-v3/testsuite/experimental/optional/assignment/6.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fassignment%2F6.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,83 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  value_type() = default;\n+  value_type(int) : state(1) { }\n+  value_type(std::initializer_list<char>, const char*) : state(2) { }\n+  int state = 0;\n+};\n+\n+int main()\n+{\n+  using O = std::experimental::optional<value_type>;\n+\n+  // Check emplace\n+\n+  {\n+    O o;\n+    o.emplace();\n+    VERIFY( o && o->state == 0 );\n+  }\n+  {\n+    O o { std::experimental::in_place, 0 };\n+    o.emplace();\n+    VERIFY( o && o->state == 0 );\n+  }\n+\n+  {\n+    O o;\n+    o.emplace(0);\n+    VERIFY( o && o->state == 1 );\n+  }\n+  {\n+    O o { std::experimental::in_place };\n+    o.emplace(0);\n+    VERIFY( o && o->state == 1 );\n+  }\n+\n+  {\n+    O o;\n+    o.emplace({ 'a' }, \"\");\n+    VERIFY( o && o->state == 2 );\n+  }\n+  {\n+    O o { std::experimental::in_place };\n+    o.emplace({ 'a' }, \"\");\n+    VERIFY( o && o->state == 2 );\n+  }\n+\n+  static_assert( !std::is_constructible<O, std::initializer_list<int>, int>(), \"\" );\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "bbd932818c676a9ec558d8983967fe4057a36171", "filename": "libstdc++-v3/testsuite/experimental/optional/cons/copy.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fcopy.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,125 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_copy\n+{\n+  throwing_copy() = default;\n+  throwing_copy(throwing_copy const&) { throw exception {}; }\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::experimental::optional<long> o;\n+    auto copy = o;\n+    VERIFY( !copy );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<long> o { std::experimental::in_place, 0x1234ABCDF1E2D3C4 };\n+    auto copy = o;\n+    VERIFY( copy );\n+    VERIFY( *copy == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( o && o == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o;\n+    auto copy = o;\n+    VERIFY( !copy );\n+    VERIFY( tracker::count == 0 );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o { std::experimental::in_place, 333 };\n+    auto copy = o;\n+    VERIFY( copy );\n+    VERIFY( copy->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( o && o->value == 333 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    std::experimental::optional<throwing_copy> o;\n+\n+    try\n+    {\n+      auto copy = o;\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    std::experimental::optional<throwing_copy> o { std::experimental::in_place };\n+\n+    try\n+    {\n+      auto copy = o;\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "452f2d020bcb70f7feffbcefbc06f86a8478cf97", "filename": "libstdc++-v3/testsuite/experimental/optional/cons/default.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fdefault.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker() { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const&) { ++count; }\n+  tracker(tracker&&) { ++count; }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::experimental::optional<tracker> o;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o {};\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o = {};\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "75d7677b7aa99c6a9e32f5adcff0b963cb0c63cd", "filename": "libstdc++-v3/testsuite/experimental/optional/cons/move.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fmove.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,125 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_move\n+{\n+  throwing_move() = default;\n+  throwing_move(throwing_move const&) { throw exception {}; }\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::experimental::optional<long> o;\n+    auto moved_to = std::move(o);\n+    VERIFY( !moved_to );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<long> o { std::experimental::in_place, 0x1234ABCDF1E2D3C4 };\n+    auto moved_to = std::move(o);\n+    VERIFY( moved_to );\n+    VERIFY( *moved_to == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( o && *o == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o;\n+    auto moved_to = std::move(o);\n+    VERIFY( !moved_to );\n+    VERIFY( tracker::count == 0 );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<tracker> o { std::experimental::in_place, 333 };\n+    auto moved_to = std::move(o);\n+    VERIFY( moved_to );\n+    VERIFY( moved_to->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( o && o->value == -1 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    std::experimental::optional<throwing_move> o;\n+\n+    try\n+    {\n+      auto moved_to = std::move(o);\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    std::experimental::optional<throwing_move> o { std::experimental::in_place };\n+\n+    try\n+    {\n+      auto moved_to = std::move(o);\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "339c120707c2a7842d9be0f82821fea91a4d4739", "filename": "libstdc++-v3/testsuite/experimental/optional/cons/value.cc", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fcons%2Fvalue.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,239 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <vector>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_construction\n+{\n+  explicit throwing_construction(bool propagate) : propagate(propagate) { }\n+\n+  throwing_construction(throwing_construction const& other)\n+  : propagate(other.propagate)\n+  {\n+    if(propagate)\n+      throw exception {};\n+  }\n+\n+  bool propagate;\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o { i };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o = i;\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o = { i };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o { std::move(i) };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o = std::move(i);\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCDF1E2D3C4;\n+    std::experimental::optional<long> o = { std::move(i) };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCDF1E2D3C4 );\n+    VERIFY( i == 0x1234ABCDF1E2D3C4 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o { v };\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o = v;\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o { v };\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o { std::move(v) };\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o = std::move(v);\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::experimental::optional<std::vector<int>> o { std::move(v) };\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    tracker t { 333 };\n+    std::experimental::optional<tracker> o = t;\n+    VERIFY( o->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( t.value == 333 );\n+  }\n+\n+  {\n+    tracker t { 333 };\n+    std::experimental::optional<tracker> o = std::move(t);\n+    VERIFY( o->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( t.value == -1 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { false };\n+\n+    try\n+    {\n+      std::experimental::optional<throwing_construction> o { t };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { true };\n+\n+    try\n+    {\n+      std::experimental::optional<throwing_construction> o { t };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { false };\n+\n+    try\n+    {\n+      std::experimental::optional<throwing_construction> o { std::move(t) };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { true };\n+\n+    try\n+    {\n+      std::experimental::optional<throwing_construction> o { std::move(t) };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+}"}, {"sha": "d437cd8f439f90bec1675ba6328beb7b373aba0f", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/cons/default.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    constexpr std::experimental::optional<int> o;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<int> o {};\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<int> o = {};\n+    static_assert( !o, \"\" );\n+  }\n+}"}, {"sha": "98e0a224a3766fab6d36f075c4f2caa6905a9e30", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/cons/value.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o { i };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o = i;\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o = { i };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o { std::move(i) };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o = std::move(i);\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+\n+  {\n+    constexpr auto i = 0x1234ABCDF1E2D3C4;\n+    constexpr std::experimental::optional<long> o = { std::move(i) };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCDF1E2D3C4, \"\" );\n+  }\n+}"}, {"sha": "f2bb8fdc11a6295805566ad149ae27edf0ca1ed6", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/in_place.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fin_place.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fin_place.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fin_place.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.5] In-place construction\n+  static_assert( std::is_same<decltype(std::experimental::in_place), const std::experimental::in_place_t>(), \"\" );\n+  static_assert( std::is_empty<std::experimental::in_place_t>(), \"\" );\n+\n+  {\n+    constexpr std::experimental::optional<int> o { std::experimental::in_place };\n+    static_assert( o, \"\" );\n+    static_assert( *o == int {}, \"\" );\n+\n+    static_assert( !std::is_convertible<std::experimental::in_place_t, std::experimental::optional<int>>(), \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<int> o { std::experimental::in_place, 42 };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 42, \"\" );\n+  }\n+}"}, {"sha": "4b59ba9eb51ae15f6909ad3794f1873cdef54354", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/make_optional.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fmake_optional.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fmake_optional.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fmake_optional.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// XFAIL pending resolution of PR libstdc++/58777\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-excess-errors \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  constexpr int i = 42;\n+  constexpr auto o = std::experimental::make_optional(i);\n+  static_assert( std::is_same<decltype(o), const std::experimental::optional<int>>(), \"\" );\n+  static_assert( o && *o == 42, \"\" );\n+  static_assert( &*o != &i, \"\" );\n+}"}, {"sha": "08566e1cb04f3a3980e3c1053625309c3f6005d6", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/nullopt.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fnullopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fnullopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fnullopt.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.6] Disengaged state indicator\n+  static_assert( std::is_same<decltype(std::experimental::nullopt), const std::experimental::nullopt_t>(), \"\" );\n+  static_assert( std::is_empty<std::experimental::nullopt_t>(), \"\" );\n+  static_assert( std::is_literal_type<std::experimental::nullopt_t>(), \"\" );\n+  static_assert( !std::is_default_constructible<std::experimental::nullopt_t>(), \"\" );\n+\n+  {\n+    constexpr std::experimental::optional<int> o = std::experimental::nullopt;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<int> o = { std::experimental::nullopt };\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<int> o { std::experimental::nullopt };\n+    static_assert( !o, \"\" );\n+  }\n+}"}, {"sha": "5943a352412bcd36ce1526191f0701b210f21f7d", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/observers/1.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::experimental::optional<value_type> o { value_type { 51 } };\n+  static_assert( (*o).i == 51, \"\" );\n+}"}, {"sha": "3df68d3575dadcae976661605eb427e30c056910", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/observers/2.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F2.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// XFAIL pending resolution of PR libstdc++/58777\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-excess-errors \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::experimental::optional<value_type> o { value_type { 51 } };\n+  static_assert( o->i == 51, \"\" );\n+  static_assert( o->i == (*o).i, \"\" );\n+  static_assert( &o->i == &(*o).i, \"\" );\n+}"}, {"sha": "6528d99c823350c75e073468d648ca0bffbbfb9b", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/observers/3.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F3.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// XFAIL pending resolution of PR libstdc++/58777\n+// { dg-do compile { xfail *-*-* } }\n+// { dg-excess-errors \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::experimental::optional<value_type> o { value_type { 51 } };\n+  static_assert( o.value().i == 51, \"\" );\n+  static_assert( o.value().i == (*o).i, \"\" );\n+  static_assert( &o.value().i == &(*o).i, \"\" );\n+}"}, {"sha": "9098c0c5a54ec70e60d25597490a920f4fe3bfbd", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/observers/4.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F4.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::experimental::optional<value_type> o { value_type { 51 } };\n+  constexpr value_type fallback { 3 };\n+  static_assert( o.value_or(fallback).i == 51, \"\" );\n+  static_assert( o.value_or(fallback).i == (*o).i, \"\" );\n+}"}, {"sha": "e86d040894317c52074920260a864fb5d1c88bc1", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/observers/5.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Fobservers%2F5.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    constexpr std::experimental::optional<value_type> o = std::experimental::nullopt;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<value_type> o { value_type { 51 } };\n+    static_assert( o, \"\" );\n+  }\n+}"}, {"sha": "591eb1346e0725e4a22998288fe5b6a2fc2848a4", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/1.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,99 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  {\n+    constexpr O o, p;\n+    static_assert( o == p, \"\" );\n+    static_assert( !(o != p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p;\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o == p, \"\" );\n+    static_assert( !(o != p), \"\" );\n+  }\n+}"}, {"sha": "9bc140dc9e5d810711932b4f6b1de1166feec9b6", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/2.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F2.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,111 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  {\n+    constexpr O o, p;\n+    static_assert( !(o < p), \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p;\n+    static_assert( !(o < p), \"\" );\n+    static_assert( o > p, \"\" );\n+    static_assert( !(o <= p), \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o < p, \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( !(o >= p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o < p, \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( !(o >= p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o < p), \"\" );\n+    static_assert( o > p, \"\" );\n+    static_assert( !(o <= p), \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o < p), \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+}"}, {"sha": "6ffd2b6cf792c1b6126ddaf9c788ac9238958618", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/3.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F3.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  constexpr value_type reference { 42, \"forty-two\" };\n+\n+  {\n+    constexpr O o;\n+    static_assert( !(o == reference), \"\" );\n+    static_assert( !(reference == o), \"\" );\n+    static_assert( o != reference, \"\" );\n+    static_assert( reference != o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o == reference), \"\" );\n+    static_assert( !(reference == o), \"\" );\n+    static_assert( o != reference, \"\" );\n+    static_assert( reference != o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } };\n+    static_assert( o == reference, \"\" );\n+    static_assert( reference == o, \"\" );\n+    static_assert( !(o != reference), \"\" );\n+    static_assert( !(reference != o), \"\" );\n+  }\n+}"}, {"sha": "8df602cb402704df590621953e4f0290f8c37751", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/4.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F4.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  constexpr value_type reference { 42, \"forty-two\" };\n+\n+  {\n+    constexpr O o;\n+    static_assert( o < reference, \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( reference > o, \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( !(reference <= o), \"\" );\n+    static_assert( !(o >= reference), \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } };\n+    static_assert( o < reference, \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( reference > o, \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( !(reference <= o), \"\" );\n+    static_assert( !(o >= reference), \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o < reference), \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( !(reference > o), \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( reference <= o, \"\" );\n+    static_assert( o >= reference, \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+}"}, {"sha": "241a71b8d104dded98f44ff31db9f06d6a3d1f90", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/5.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F5.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+  using std::experimental::nullopt;\n+\n+  {\n+    constexpr O o;\n+    static_assert( o == nullopt, \"\" );\n+    static_assert( nullopt == o, \"\" );\n+    static_assert( !(o != nullopt), \"\" );\n+    static_assert( !(nullopt != o), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { std::experimental::in_place };\n+    static_assert( !(o == nullopt), \"\" );\n+    static_assert( !(nullopt == o), \"\" );\n+    static_assert( o != nullopt, \"\" );\n+    static_assert( nullopt != o, \"\" );\n+  }\n+}"}, {"sha": "a4282d89e51f4bdd0c7a83bc6a5fba48e536d489", "filename": "libstdc++-v3/testsuite/experimental/optional/constexpr/relops/6.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fconstexpr%2Frelops%2F6.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,88 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+  using std::experimental::nullopt;\n+\n+  {\n+    constexpr O o;\n+    static_assert( !(o < nullopt), \"\" );\n+    static_assert( !(nullopt < o), \"\" );\n+    static_assert( !(o > nullopt), \"\" );\n+    static_assert( !(nullopt > o), \"\" );\n+    static_assert( o <= nullopt, \"\" );\n+    static_assert( nullopt <= o, \"\" );\n+    static_assert( o >= nullopt, \"\" );\n+    static_assert( nullopt >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { std::experimental::in_place };\n+    static_assert( !(o < nullopt), \"\" );\n+    static_assert( nullopt < o, \"\" );\n+    static_assert( o > nullopt, \"\" );\n+    static_assert( !(nullopt > o), \"\" );\n+    static_assert( !(o <= nullopt), \"\" );\n+    static_assert( nullopt <= o, \"\" );\n+    static_assert( o >= nullopt, \"\" );\n+    static_assert( !(nullopt >= o), \"\" );\n+  }\n+}"}, {"sha": "ceaa97d91b367c51f9b896bb7242c72b83e6c631", "filename": "libstdc++-v3/testsuite/experimental/optional/in_place.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fin_place.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fin_place.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fin_place.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <vector>\n+\n+int main()\n+{\n+  // [20.5.5] In-place construction\n+  static_assert( std::is_same<decltype(std::experimental::in_place), const std::experimental::in_place_t>(), \"\" );\n+  static_assert( std::is_empty<std::experimental::in_place_t>(), \"\" );\n+\n+  {\n+    std::experimental::optional<int> o { std::experimental::in_place };\n+    VERIFY( o );\n+    VERIFY( *o == int() );\n+\n+    static_assert( !std::is_convertible<std::experimental::in_place_t, std::experimental::optional<int>>(), \"\" );\n+  }\n+\n+  {\n+    std::experimental::optional<int> o { std::experimental::in_place, 42 };\n+    VERIFY( o );\n+    VERIFY( *o == 42 );\n+  }\n+\n+  {\n+    std::experimental::optional<std::vector<int>> o { std::experimental::in_place, 18, 4 };\n+    VERIFY( o );\n+    VERIFY( o->size() == 18 );\n+    VERIFY( (*o)[17] == 4 );\n+  }\n+\n+  {\n+    std::experimental::optional<std::vector<int>> o { std::experimental::in_place, { 18, 4 } };\n+    VERIFY( o );\n+    VERIFY( o->size() == 2 );\n+    VERIFY( (*o)[0] == 18 );\n+  }\n+\n+  {\n+    std::experimental::optional<std::vector<int>> o { std::experimental::in_place, { 18, 4 }, std::allocator<int> {} };\n+    VERIFY( o );\n+    VERIFY( o->size() == 2 );\n+    VERIFY( (*o)[0] == 18 );\n+  }\n+}"}, {"sha": "90ebe6c4bfc99ba9846c886952cc647b7d3a964e", "filename": "libstdc++-v3/testsuite/experimental/optional/make_optional.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fmake_optional.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fmake_optional.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fmake_optional.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  const int i = 42;\n+  auto o = std::experimental::make_optional(i);\n+  static_assert( std::is_same<decltype(o), std::experimental::optional<int>>(), \"\" );\n+  VERIFY( o && *o == 42 );\n+  VERIFY( &*o != &i );\n+}"}, {"sha": "f1b1bb6dcabc3fd216fed455eb5983f16e985616", "filename": "libstdc++-v3/testsuite/experimental/optional/nullopt.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fnullopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fnullopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fnullopt.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.6] Disengaged state indicator\n+  static_assert( std::is_same<decltype(std::experimental::nullopt), const std::experimental::nullopt_t>(), \"\" );\n+  static_assert( std::is_empty<std::experimental::nullopt_t>(), \"\" );\n+  static_assert( std::is_literal_type<std::experimental::nullopt_t>(), \"\" );\n+  static_assert( !std::is_default_constructible<std::experimental::nullopt_t>(), \"\" );\n+\n+  {\n+    std::experimental::optional<int> o = std::experimental::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<int> o = { std::experimental::nullopt };\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<int> o { std::experimental::nullopt };\n+    VERIFY( !o );\n+  }\n+}"}, {"sha": "5ffa3a5ebc0630d30433e0dd3c79a0db7dc13b65", "filename": "libstdc++-v3/testsuite/experimental/optional/observers/1.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  std::experimental::optional<value_type> o { value_type { 51 } };\n+  VERIFY( (*o).i == 51 );\n+}"}, {"sha": "444a14157ac43f9098b2ee0b91bc7799be94b47f", "filename": "libstdc++-v3/testsuite/experimental/optional/observers/2.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F2.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  std::experimental::optional<value_type> o { value_type { 51 } };\n+  VERIFY( o->i == 51 );\n+  VERIFY( o->i == (*o).i );\n+  VERIFY( &o->i == &(*o).i );\n+}"}, {"sha": "b82142d06632a484e5f264a9dff7857bd7bea149", "filename": "libstdc++-v3/testsuite/experimental/optional/observers/3.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F3.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    std::experimental::optional<value_type> o { value_type { 51 } };\n+    VERIFY( o.value().i == 51 );\n+    VERIFY( o.value().i == (*o).i );\n+    VERIFY( &o.value().i == &(*o).i );\n+  }\n+\n+  {\n+    enum outcome_type { nothrow, caught, bad_catch };\n+\n+    outcome_type outcome {};\n+    std::experimental::optional<value_type> o = std::experimental::nullopt;\n+    bool called = false;\n+    auto const eat = [&called](int) { called = true; };\n+\n+    try\n+    {\n+      eat(o.value().i);\n+    }\n+    catch(std::experimental::bad_optional_access const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !called );\n+  }\n+}"}, {"sha": "3b43c77d4c39b41b3110e4ca316ac6c4a467e61a", "filename": "libstdc++-v3/testsuite/experimental/optional/observers/4.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F4.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  std::experimental::optional<value_type> o { value_type { 51 } };\n+  value_type fallback { 3 };\n+  VERIFY( o.value_or(fallback).i == 51 );\n+  VERIFY( o.value_or(fallback).i == (*o).i );\n+}"}, {"sha": "c6957ec3295d0a8af34b11209adfe433be723896", "filename": "libstdc++-v3/testsuite/experimental/optional/observers/5.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fobservers%2F5.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    std::experimental::optional<value_type> o = std::experimental::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::experimental::optional<value_type> o { value_type { 51 } };\n+    VERIFY( o );\n+  }\n+}"}, {"sha": "6f0c60f71ce03df418ec88e0e285358514e983f0", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/1.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  {\n+    O o, p;\n+    VERIFY( o == p );\n+    VERIFY( !(o != p) );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p;\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o == p );\n+    VERIFY( !(o != p) );\n+  }\n+}"}, {"sha": "b1ae705bd3d8448607c8a0db22179b5fc4fdd5b7", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/2.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F2.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  {\n+    O o, p;\n+    VERIFY( !(o < p) );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p;\n+    VERIFY( !(o < p) );\n+    VERIFY( o > p );\n+    VERIFY( !(o <= p) );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o < p );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( !(o >= p) );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o < p );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( !(o >= p) );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o < p) );\n+    VERIFY( o > p );\n+    VERIFY( !(o <= p) );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o < p) );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( o >= p );\n+  }\n+}"}, {"sha": "6b361dfa23e863398ae35585c66980b43104dbf2", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/3.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F3.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  value_type const reference { 42, \"forty-two\" };\n+\n+  {\n+    O o;\n+    VERIFY( !(o == reference) );\n+    VERIFY( !(reference == o) );\n+    VERIFY( o != reference );\n+    VERIFY( reference != o );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o == reference) );\n+    VERIFY( !(reference == o) );\n+    VERIFY( o != reference );\n+    VERIFY( reference != o );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } };\n+    VERIFY( o == reference );\n+    VERIFY( reference == o );\n+    VERIFY( !(o != reference) );\n+    VERIFY( !(reference != o) );\n+  }\n+}"}, {"sha": "9f316f1eb417664f330f1ea53d6795f3a12b9019", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/4.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F4.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,91 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+\n+  value_type const reference { 42, \"forty-two\" };\n+\n+  {\n+    O o;\n+    VERIFY( o < reference );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( reference > o );\n+    VERIFY( o <= reference );\n+    VERIFY( !(reference <= o) );\n+    VERIFY( !(o >= reference) );\n+    VERIFY( reference >= o );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } };\n+    VERIFY( o < reference );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( reference > o );\n+    VERIFY( o <= reference );\n+    VERIFY( !(reference <= o) );\n+    VERIFY( !(o >= reference) );\n+    VERIFY( reference >= o );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o < reference) );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( !(reference > o) );\n+    VERIFY( o <= reference );\n+    VERIFY( reference <= o );\n+    VERIFY( o >= reference );\n+    VERIFY( reference >= o );\n+  }\n+}"}, {"sha": "c7b27bbabbbec29b5a5a13c59b0cd96ebd3c8b97", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/5.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F5.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+  using std::experimental::nullopt;\n+\n+  {\n+    O o;\n+    VERIFY( o == nullopt );\n+    VERIFY( nullopt == o );\n+    VERIFY( !(o != nullopt) );\n+    VERIFY( !(nullopt != o) );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place };\n+    VERIFY( !(o == nullopt) );\n+    VERIFY( !(nullopt == o) );\n+    VERIFY( o != nullopt );\n+    VERIFY( nullopt != o );\n+  }\n+}"}, {"sha": "d8a4f6fd0574371fbfdf677c508bbb50ecd2dcd7", "filename": "libstdc++-v3/testsuite/experimental/optional/relops/6.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frelops%2F6.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::experimental::optional<value_type>;\n+  using std::experimental::nullopt;\n+\n+  {\n+    O o;\n+    VERIFY( !(o < nullopt) );\n+    VERIFY( !(nullopt < o) );\n+    VERIFY( !(o > nullopt) );\n+    VERIFY( !(nullopt > o) );\n+    VERIFY( o <= nullopt );\n+    VERIFY( nullopt <= o );\n+    VERIFY( o >= nullopt );\n+    VERIFY( nullopt >= o );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place };\n+    VERIFY( !(o < nullopt) );\n+    VERIFY( nullopt < o );\n+    VERIFY( o > nullopt );\n+    VERIFY( !(nullopt > o) );\n+    VERIFY( !(o <= nullopt) );\n+    VERIFY( nullopt <= o );\n+    VERIFY( o >= nullopt );\n+    VERIFY( !(nullopt >= o) );\n+  }\n+}"}, {"sha": "c97cde581ee9f54cb5fb905132038c6b1255dd1c", "filename": "libstdc++-v3/testsuite/experimental/optional/requirements.cc", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Frequirements.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,256 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+\n+struct trivially_destructible\n+{\n+  trivially_destructible() = delete;\n+  trivially_destructible(trivially_destructible const&) = delete;\n+  trivially_destructible& operator=(trivially_destructible const&) = delete;\n+  trivially_destructible(trivially_destructible&&) = delete;\n+  trivially_destructible& operator=(trivially_destructible&&) = delete;\n+  ~trivially_destructible() noexcept = default;\n+};\n+\n+static_assert( std::is_trivially_destructible<trivially_destructible>(), \"\" );\n+\n+struct no_default_constructor\n+{\n+  no_default_constructor() = delete;\n+};\n+\n+struct no_copy_constructor\n+{\n+  no_copy_constructor() = default;\n+  no_copy_constructor(no_copy_constructor const&) = delete;\n+  no_copy_constructor& operator=(no_copy_constructor const&) = default;\n+  no_copy_constructor(no_copy_constructor&&) = default;\n+  no_copy_constructor& operator=(no_copy_constructor&&) = default;\n+};\n+\n+struct no_copy_assignment\n+{\n+  no_copy_assignment() = default;\n+  no_copy_assignment(no_copy_assignment const&) = default;\n+  no_copy_assignment(no_copy_assignment&&) = default;\n+  no_copy_assignment& operator=(no_copy_assignment&&) = default;\n+};\n+\n+struct no_move_constructor\n+{\n+  no_move_constructor() = default;\n+  no_move_constructor(no_move_constructor const&) = default;\n+  no_move_constructor& operator=(no_move_constructor const&) = default;\n+  no_move_constructor(no_move_constructor&&) = delete;\n+  no_move_constructor& operator=(no_move_constructor&&) = default;\n+};\n+\n+struct no_move_assignment\n+{\n+  no_move_assignment() = default;\n+  no_move_assignment(no_move_assignment const&) = default;\n+  no_move_assignment& operator=(no_move_assignment const&) = default;\n+  no_move_assignment(no_move_assignment&&) = default;\n+  no_move_assignment& operator=(no_move_assignment&&) = delete;\n+};\n+\n+struct no_copy : no_copy_constructor, no_copy_assignment { };\n+struct no_move : no_move_constructor, no_move_assignment { };\n+\n+// Laxest possible model of a value type for optional\n+struct only_destructible\n+{\n+  only_destructible(only_destructible&&) = delete;\n+};\n+\n+int main()\n+{\n+  {\n+    static_assert( std::is_trivially_destructible<std::experimental::optional<trivially_destructible>>(), \"\" );\n+  }\n+\n+  {\n+    using T = no_default_constructor;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy_constructor;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy_assignment;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move_constructor;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    /*\n+     * T should be move constructible due to [12.8/11], which is a new rule in C++1y\n+     * not yet implemented by GCC. Because there is already a special exception in C++11\n+     * for the generation of the special members that GCC implements (at least some of the\n+     * time), this does not affect the std::experimental::optional implementation however. So the assertion\n+     * for T should be changed (or removed altogether) when the time comes, but the rest\n+     * should however remain correct and unchanged.\n+     */\n+    static_assert( !std::is_move_constructible<T>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move_assignment;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    /*\n+     * Paragraph 23 of same leads to a similar situation but with respect to move\n+     * assignment.\n+     */\n+    static_assert( !std::is_move_assignable<T>(), \"\" );\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = only_destructible;\n+    using O = std::experimental::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( !std::is_move_constructible<O>(), \"\" );\n+    static_assert( !std::is_move_assignable<O>(), \"\" );\n+  }\n+\n+  {\n+    /*\n+     * Should not complain about 'invalid' specializations as long as\n+     * they're not instantiated.\n+     */\n+    using A = std::experimental::optional<int&>;\n+    using B = std::experimental::optional<int&&>;\n+    using C1 = std::experimental::optional<std::experimental::in_place_t>;\n+    using C2 = std::experimental::optional<std::experimental::in_place_t const>;\n+    using C3 = std::experimental::optional<std::experimental::in_place_t volatile>;\n+    using C4 = std::experimental::optional<std::experimental::in_place_t const volatile>;\n+    using D1 = std::experimental::optional<std::experimental::nullopt_t>;\n+    using D2 = std::experimental::optional<std::experimental::nullopt_t const>;\n+    using D3 = std::experimental::optional<std::experimental::nullopt_t volatile>;\n+    using D4 = std::experimental::optional<std::experimental::nullopt_t const volatile>;\n+\n+    using X = std::tuple<A, B, C1, C2, C3, C4, D1, D2, D3, D4>;\n+  }\n+\n+  {\n+    std::experimental::optional<const int> o { 42 };\n+    static_assert( std::is_same<decltype(o)::value_type, const int>(), \"\" );\n+    VERIFY( o );\n+    VERIFY( *o == 42 );\n+  }\n+\n+  {\n+    constexpr std::experimental::optional<const int> o { 33 };\n+    static_assert( std::is_same<decltype(o)::value_type, const int>(), \"\" );\n+    static_assert( o, \"\" );\n+    static_assert( *o == 33, \"\" );\n+  }\n+}"}, {"sha": "95235b3e711305fd149a645b7c33ef6e9919b070", "filename": "libstdc++-v3/testsuite/experimental/optional/swap/1.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Foptional%2Fswap%2F1.cc?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -0,0 +1,95 @@\n+// { dg-options \"-std=gnu++1y\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+namespace ns\n+{\n+\n+struct value_type : private mixin_counter\n+{\n+  explicit value_type(int state) : state(state) { }\n+  int state;\n+};\n+\n+int swaps = 0;\n+\n+void\n+swap(value_type& lhs, value_type& rhs)\n+{\n+  ++swaps;\n+  using std::swap;\n+  swap(lhs.state, rhs.state);\n+}\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using O = std::experimental::optional<ns::value_type>;\n+\n+  VERIFY( ns::swaps == 0 );\n+\n+  {\n+    O o, p;\n+    swap(o, p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place, 45 }, p;\n+    swap(o, p);\n+    VERIFY( !o );\n+    VERIFY( p && p->state == 45 );\n+  }\n+\n+  {\n+    O o, p { std::experimental::in_place, 45 };\n+    swap(o, p);\n+    VERIFY( o && o->state == 45 );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o { std::experimental::in_place, 167 }, p { std::experimental::in_place, 999 };\n+    VERIFY( ns::swaps == 0 );\n+\n+    swap(o, p);\n+\n+    VERIFY( o && o->state == 999 );\n+    VERIFY( p && p->state == 167 );\n+    VERIFY( ns::swaps == 1 );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "b6976fcb4b272def8db8e93f3371d6dff6c31a8b", "filename": "libstdc++-v3/testsuite/libstdc++-dg/conformance.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5ab1e438e5cf3838922dede7f1b8ea4974b32c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-dg%2Fconformance.exp?ref=2b5ab1e438e5cf3838922dede7f1b8ea4974b32c", "patch": "@@ -60,6 +60,7 @@ if {[info exists tests_file] && [file exists $tests_file]} {\n     lappend subdirs \"$srcdir/tr1\"\n     lappend subdirs \"$srcdir/tr2\"\n     lappend subdirs \"$srcdir/decimal\"\n+    lappend subdirs \"$srcdir/experimental\"\n     verbose \"subdirs are $subdirs\"\n \n     # Find all the tests."}]}