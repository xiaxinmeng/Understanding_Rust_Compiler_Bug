{"sha": "5c88165592ad1864b5c6cb832d6616407e031b85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM4ODE2NTU5MmFkMTg2NGI1YzZjYjgzMmQ2NjE2NDA3ZTAzMWI4NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-12T19:42:42Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-01-12T19:42:42Z"}, "message": "re PR rtl-optimization/12508 (weak optimization for some constants < 2^16)\n\n2004-01-12  Kazu Hirata  <kazu@cs.umass.edu>\n\n        PR optimization/12508.\n        * combine.c (try_combine): Remove a dead set in a parallel\n        even if its destination is a subreg.\n\n        Revert:\n        2003-06-03  Kazu Hirata  <kazu@cs.umass.edu>\n        * combine.c (simplify_set): Don't move a subreg in SET_SRC to\n        SET_DEST if WORD_REGISTER_OPERATIONS is not defined.\n\nFrom-SVN: r75747", "tree": {"sha": "140d59418d5ede550da2b6aae172861824d0999b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140d59418d5ede550da2b6aae172861824d0999b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c88165592ad1864b5c6cb832d6616407e031b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c88165592ad1864b5c6cb832d6616407e031b85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c88165592ad1864b5c6cb832d6616407e031b85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c88165592ad1864b5c6cb832d6616407e031b85/comments", "author": null, "committer": null, "parents": [{"sha": "74c0b320be063136b9fd12d6cd9e80ae1d26bdd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c0b320be063136b9fd12d6cd9e80ae1d26bdd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c0b320be063136b9fd12d6cd9e80ae1d26bdd4"}], "stats": {"total": 88, "additions": 54, "deletions": 34}, "files": [{"sha": "29eb50376e77f88fb656cf73a7d021ef4fb955a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c88165592ad1864b5c6cb832d6616407e031b85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c88165592ad1864b5c6cb832d6616407e031b85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c88165592ad1864b5c6cb832d6616407e031b85", "patch": "@@ -1,3 +1,14 @@\n+2004-01-12  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR optimization/12508.\n+\t* combine.c (try_combine): Remove a dead set in a parallel\n+\teven if its destination is a subreg.\n+\n+\tRevert:\n+\t2003-06-03  Kazu Hirata  <kazu@cs.umass.edu>\n+\t* combine.c (simplify_set): Don't move a subreg in SET_SRC to\n+\tSET_DEST if WORD_REGISTER_OPERATIONS is not defined.\n+\n 2004-01-12  Geoffrey Keating  <geoffk@apple.com>\n \n \t* real.c: Update copyright date."}, {"sha": "e54ef60f21b9ef053fb01c798440df4df164578b", "filename": "gcc/combine.c", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c88165592ad1864b5c6cb832d6616407e031b85/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c88165592ad1864b5c6cb832d6616407e031b85/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5c88165592ad1864b5c6cb832d6616407e031b85", "patch": "@@ -2024,34 +2024,41 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && XVECLEN (newpat, 0) == 2\n       && GET_CODE (XVECEXP (newpat, 0, 0)) == SET\n       && GET_CODE (XVECEXP (newpat, 0, 1)) == SET\n-      && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == REG\n-      && find_reg_note (i3, REG_UNUSED, SET_DEST (XVECEXP (newpat, 0, 1)))\n-      && ! side_effects_p (SET_SRC (XVECEXP (newpat, 0, 1)))\n       && asm_noperands (newpat) < 0)\n     {\n-      newpat = XVECEXP (newpat, 0, 0);\n-      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n-    }\n-\n-  else if (insn_code_number < 0 && GET_CODE (newpat) == PARALLEL\n-\t   && XVECLEN (newpat, 0) == 2\n-\t   && GET_CODE (XVECEXP (newpat, 0, 0)) == SET\n-\t   && GET_CODE (XVECEXP (newpat, 0, 1)) == SET\n-\t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 0))) == REG\n-\t   && find_reg_note (i3, REG_UNUSED, SET_DEST (XVECEXP (newpat, 0, 0)))\n-\t   && ! side_effects_p (SET_SRC (XVECEXP (newpat, 0, 0)))\n-\t   && asm_noperands (newpat) < 0)\n-    {\n-      newpat = XVECEXP (newpat, 0, 1);\n-      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n- \n-      if (insn_code_number >= 0)\n-\t{\n-\t  /* If we will be able to accept this, we have made a change to the\n-\t     destination of I3.  This requires us to do a few adjustments.  */\n-\t  PATTERN (i3) = newpat;\n-\t  adjust_for_new_dest (i3);\n-\t}\n+      rtx set0 = XVECEXP (newpat, 0, 0);\n+      rtx set1 = XVECEXP (newpat, 0, 1);\n+  \n+      if (((GET_CODE (SET_DEST (set1)) == REG\n+            && find_reg_note (i3, REG_UNUSED, SET_DEST (set1)))\n+          || (GET_CODE (SET_DEST (set1)) == SUBREG\n+              && find_reg_note (i3, REG_UNUSED, SUBREG_REG (SET_DEST (set1)))))\n+          && ! side_effects_p (SET_SRC (set1)))\n+        {\n+          newpat = set0;\n+          insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+        }\n+  \n+      else if (((GET_CODE (SET_DEST (set0)) == REG\n+                && find_reg_note (i3, REG_UNUSED, SET_DEST (set0)))\n+                || (GET_CODE (SET_DEST (set0)) == SUBREG\n+                    && find_reg_note (i3, REG_UNUSED,\n+                                      SUBREG_REG (SET_DEST (set0)))))\n+              && ! side_effects_p (SET_SRC (set0)))\n+        {\n+          newpat = set1;\n+          insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+    \n+          if (insn_code_number >= 0)\n+            {\n+              /* If we will be able to accept this, we have made a\n+                 change to the destination of I3.  This requires us to\n+                 do a few adjustments.  */\n+            \n+              PATTERN (i3) = newpat;\n+              adjust_for_new_dest (i3);\n+            }\n+        }\n     }\n \n   /* If we were combining three insns and the result is a simple SET\n@@ -5114,25 +5121,28 @@ simplify_set (rtx x)\n       SUBST (SET_SRC (x), src);\n     }\n \n-#ifdef WORD_REGISTER_OPERATIONS\n   /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some operation,\n      and X being a REG or (subreg (reg)), we may be able to convert this to\n      (set (subreg:m2 x) (op)).\n \n-     On a machine where WORD_REGISTER_OPERATIONS is defined, this\n-     transformation is safe as long as M1 and M2 have the same number\n-     of words.\n+     We can always do this if M1 is narrower than M2 because that means that\n+     we only care about the low bits of the result.\n \n-     However, on a machine without WORD_REGISTER_OPERATIONS defined,\n-     we cannot apply this transformation because it would create a\n-     paradoxical subreg in SET_DEST.  */\n+     However, on machines without WORD_REGISTER_OPERATIONS defined, we cannot\n+     perform a narrower operation than requested since the high-order bits will\n+     be undefined.  On machine where it is defined, this transformation is safe\n+     as long as M1 and M2 have the same number of words.  */\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n       && GET_RTX_CLASS (GET_CODE (SUBREG_REG (src))) != 'o'\n       && (((GET_MODE_SIZE (GET_MODE (src)) + (UNITS_PER_WORD - 1))\n \t   / UNITS_PER_WORD)\n \t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n \t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n+#ifndef WORD_REGISTER_OPERATIONS\n+      && (GET_MODE_SIZE (GET_MODE (src))\n+        < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n+#endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n@@ -5150,7 +5160,6 @@ simplify_set (rtx x)\n \n       src = SET_SRC (x), dest = SET_DEST (x);\n     }\n-#endif\n \n #ifdef HAVE_cc0\n   /* If we have (set (cc0) (subreg ...)), we try to remove the subreg"}]}