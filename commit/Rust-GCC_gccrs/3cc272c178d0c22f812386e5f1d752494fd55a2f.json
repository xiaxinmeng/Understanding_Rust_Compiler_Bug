{"sha": "3cc272c178d0c22f812386e5f1d752494fd55a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjMjcyYzE3OGQwYzIyZjgxMjM4NmU1ZjFkNzUyNDk0ZmQ1NWEyZg==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-06-03T09:29:06Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-06-03T09:29:06Z"}, "message": "re PR tree-optimization/61328 (valgrind finds problem in find_bswap_or_nop_1)\n\n2014-06-03  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\tPR tree-optimization/61328\n\t* tree-ssa-math-opts.c (init_symbolic_number): Extract symbolic number\n        initialization from find_bswap_or_nop_1.\n        (find_bswap_or_nop_1): Test return value of find_bswap_or_nop_1 stored\n        in source_expr2 before using the size value the function sets. Also\n        make use of init_symbolic_number () in both the old place and\n        find_bswap_or_nop_load () to avoid reading uninitialized memory when\n        doing recursion in the GIMPLE_BINARY_RHS case.\n\nFrom-SVN: r211166", "tree": {"sha": "e5494ee56bf0f0a13aab7c8a170acf255baae7aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5494ee56bf0f0a13aab7c8a170acf255baae7aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cc272c178d0c22f812386e5f1d752494fd55a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc272c178d0c22f812386e5f1d752494fd55a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc272c178d0c22f812386e5f1d752494fd55a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc272c178d0c22f812386e5f1d752494fd55a2f/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "597c6315ca23f0451be82a7cfb4ebc9fa34105e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/597c6315ca23f0451be82a7cfb4ebc9fa34105e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/597c6315ca23f0451be82a7cfb4ebc9fa34105e7"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "411e71048ccc03b5e27cc4bcd4dc1b9fd58ca8be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc272c178d0c22f812386e5f1d752494fd55a2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc272c178d0c22f812386e5f1d752494fd55a2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cc272c178d0c22f812386e5f1d752494fd55a2f", "patch": "@@ -1,3 +1,14 @@\n+2014-06-03  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/61328\n+\t* tree-ssa-math-opts.c (init_symbolic_number): Extract symbolic number\n+\tinitialization from find_bswap_or_nop_1.\n+\t(find_bswap_or_nop_1): Test return value of find_bswap_or_nop_1 stored\n+\tin source_expr2 before using the size value the function sets. Also\n+\tmake use of init_symbolic_number () in both the old place and\n+\tfind_bswap_or_nop_load () to avoid reading uninitialized memory when\n+\tdoing recursion in the GIMPLE_BINARY_RHS case.\n+\n 2014-06-03  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/61383"}, {"sha": "658b341667acbbbfb5f5faeb6a2181dc3f762cea", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc272c178d0c22f812386e5f1d752494fd55a2f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc272c178d0c22f812386e5f1d752494fd55a2f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=3cc272c178d0c22f812386e5f1d752494fd55a2f", "patch": "@@ -1702,6 +1702,30 @@ verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n   return true;\n }\n \n+/* Initialize the symbolic number N for the bswap pass from the base element\n+   SRC manipulated by the bitwise OR expression.  */\n+\n+static bool\n+init_symbolic_number (struct symbolic_number *n, tree src)\n+{\n+  n->base_addr = n->offset = n->alias_set = n->vuse = NULL_TREE;\n+\n+  /* Set up the symbolic number N by setting each byte to a value between 1 and\n+     the byte size of rhs1.  The highest order byte is set to n->size and the\n+     lowest order byte to 1.  */\n+  n->size = TYPE_PRECISION (TREE_TYPE (src));\n+  if (n->size % BITS_PER_UNIT != 0)\n+    return false;\n+  n->size /= BITS_PER_UNIT;\n+  n->range = n->size;\n+  n->n = CMPNOP;\n+\n+  if (n->size < (int)sizeof (int64_t))\n+    n->n &= ((uint64_t)1 << (n->size * BITS_PER_UNIT)) - 1;\n+\n+  return true;\n+}\n+\n /* Check if STMT might be a byte swap or a nop from a memory source and returns\n    the answer. If so, REF is that memory source and the base of the memory area\n    accessed and the offset of the access from that base are recorded in N.  */\n@@ -1714,26 +1738,27 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n   HOST_WIDE_INT bitsize, bitpos;\n   enum machine_mode mode;\n   int unsignedp, volatilep;\n+  tree offset, base_addr;\n \n   if (!gimple_assign_load_p (stmt) || gimple_has_volatile_ops (stmt))\n     return false;\n \n-  n->base_addr = get_inner_reference (ref, &bitsize, &bitpos, &n->offset,\n-\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n+  base_addr = get_inner_reference (ref, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t   &unsignedp, &volatilep, false);\n \n-  if (TREE_CODE (n->base_addr) == MEM_REF)\n+  if (TREE_CODE (base_addr) == MEM_REF)\n     {\n       offset_int bit_offset = 0;\n-      tree off = TREE_OPERAND (n->base_addr, 1);\n+      tree off = TREE_OPERAND (base_addr, 1);\n \n       if (!integer_zerop (off))\n \t{\n-\t  offset_int boff, coff = mem_ref_offset (n->base_addr);\n+\t  offset_int boff, coff = mem_ref_offset (base_addr);\n \t  boff = wi::lshift (coff, LOG2_BITS_PER_UNIT);\n \t  bit_offset += boff;\n \t}\n \n-      n->base_addr = TREE_OPERAND (n->base_addr, 0);\n+      base_addr = TREE_OPERAND (base_addr, 0);\n \n       /* Avoid returning a negative bitpos as this may wreak havoc later.  */\n       if (wi::neg_p (bit_offset))\n@@ -1744,11 +1769,11 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n \t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n \t  bit_offset -= tem;\n \t  tem = wi::arshift (tem, LOG2_BITS_PER_UNIT);\n-\t  if (n->offset)\n-\t    n->offset = size_binop (PLUS_EXPR, n->offset,\n+\t  if (offset)\n+\t    offset = size_binop (PLUS_EXPR, offset,\n \t\t\t\t    wide_int_to_tree (sizetype, tem));\n \t  else\n-\t    n->offset = wide_int_to_tree (sizetype, tem);\n+\t    offset = wide_int_to_tree (sizetype, tem);\n \t}\n \n       bitpos += bit_offset.to_shwi ();\n@@ -1759,6 +1784,9 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n   if (bitsize % BITS_PER_UNIT)\n     return false;\n \n+  init_symbolic_number (n, ref);\n+  n->base_addr = base_addr;\n+  n->offset = offset;\n   n->bytepos = bitpos / BITS_PER_UNIT;\n   n->alias_set = reference_alias_ptr_type (ref);\n   n->vuse = gimple_vuse (stmt);\n@@ -1817,28 +1845,12 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n       /* If find_bswap_or_nop_1 returned NULL, STMT is a leaf node and\n \t we have to initialize the symbolic number.  */\n-      if (!source_expr1 || gimple_assign_load_p (rhs1_stmt))\n+      if (!source_expr1)\n \t{\n-\t  /* Set up the symbolic number N by setting each byte to a\n-\t     value between 1 and the byte size of rhs1.  The highest\n-\t     order byte is set to n->size and the lowest order\n-\t     byte to 1.  */\n-\t  n->size = TYPE_PRECISION (TREE_TYPE (rhs1));\n-\t  if (n->size % BITS_PER_UNIT != 0)\n+\t  if (gimple_assign_load_p (stmt)\n+\t      || !init_symbolic_number (n, rhs1))\n \t    return NULL_TREE;\n-\t  n->size /= BITS_PER_UNIT;\n-\t  n->range = n->size;\n-\t  n->n = CMPNOP;\n-\n-\t  if (n->size < (int)sizeof (int64_t))\n-\t    n->n &= ((uint64_t)1 <<\n-\t\t     (n->size * BITS_PER_UNIT)) - 1;\n-\n-\t  if (!source_expr1)\n-\t    {\n-\t      n->base_addr = n->offset = n->alias_set = n->vuse = NULL_TREE;\n-\t      source_expr1 = rhs1;\n-\t    }\n+\t  source_expr1 = rhs1;\n \t}\n \n       switch (code)\n@@ -1916,7 +1928,10 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n \t  source_expr2 = find_bswap_or_nop_1 (rhs2_stmt, &n2, limit - 1);\n \n-\t  if (n1.size != n2.size || !source_expr2)\n+\t  if (!source_expr2)\n+\t    return NULL_TREE;\n+\n+\t  if (n1.size != n2.size)\n \t    return NULL_TREE;\n \n \t  if (!n1.vuse != !n2.vuse ||"}]}