{"sha": "882c3f17b61fffed412c19753c3b71b3c270b72f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgyYzNmMTdiNjFmZmZlZDQxMmMxOTc1M2MzYjcxYjNjMjcwYjcyZg==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2018-09-24T15:01:57Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@gcc.gnu.org", "date": "2018-09-24T15:01:57Z"}, "message": "Change EQ_ATTR_ALT to support up to 64 alternatives\n\nOn S/390 there is a need to support more than 32 instruction\nalternatives per define_insn.  Currently this is not explicitly\nprohibited or unsupported: MAX_RECOG_ALTERNATIVES is equal 35, and,\nfuthermore, the related code uses uint64_t for bitmaps in most places.\n\nHowever, genattrtab contains the logic to convert (eq_attr \"attribute\"\n\"value\") RTXs to (eq_attr_alt bitmap) RTXs, where bitmap contains\nalternatives, whose \"attribute\" has the corresponding \"value\".\nUnfortunately, bitmap is only 32 bits.\n\nWhen adding the 33rd alternative, this led to (eq_attr \"type\" \"larl\")\nbecoming (eq_attr_alt -1050625 1), where -1050625 == 0xffeff7ff.  The\ncleared bits 12, 21 and 32 correspond to two existing and one newly\nadded insn of type \"larl\".  compute_alternative_mask sign extended this\nto 0xffffffffffeff7ff, which contained non-existent alternatives, and\nthis made simplify_test_exp fail with \"invalid alternative specified\".\n\nI'm not sure why it didn't fail the same way before, since the top bit,\nwhich led to sign extension, should have been set even with 32\nalternatives.  Maybe simplify_test_exp was not called for \"type\"\nattribute for some reason?\n\nThis patch widens EQ_ATTR_ALT bitmap to 64 bits, making it possible to\ngracefully handle up to 64 alternatives.  It eliminates the problem with\nthe 33rd alternative on S/390.\n\ngcc/ChangeLog:\n\n2018-09-24  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* genattrtab.c (mk_attr_alt): Use alternative_mask.\n\t(attr_rtx_1): Adjust caching to match the new EQ_ATTR_ALT field\n        types.\n\t(check_attr_test): Use alternative_mask.\n\t(get_attr_value): Likewise.\n\t(compute_alternative_mask): Use alternative_mask and XWINT.\n\t(make_alternative_compare): Use alternative_mask.\n\t(attr_alt_subset_p): Use XWINT.\n\t(attr_alt_subset_of_compl_p): Likewise.\n\t(attr_alt_intersection): Use alternative_mask and XWINT.\n\t(attr_alt_union): Likewise.\n\t(attr_alt_complement): Use HOST_WIDE_INT and XWINT.\n        (mk_attr_alt): Use alternative_mask and HOST_WIDE_INT.\n\t(simplify_test_exp): Use alternative_mask and XWINT.\n\t(write_test_expr): Use alternative_mask and XWINT, adjust bit\n        number calculation to support 64 bits.  Generate code that\n        checks 64-bit masks.\n\t(main): Use alternative_mask.\n\t* rtl.def (EQ_ATTR_ALT): Change field types from ii to ww.\n\nFrom-SVN: r264537", "tree": {"sha": "f8015d3556c0e8b04bfd0986b572c065db185264", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8015d3556c0e8b04bfd0986b572c065db185264"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/882c3f17b61fffed412c19753c3b71b3c270b72f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/882c3f17b61fffed412c19753c3b71b3c270b72f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/882c3f17b61fffed412c19753c3b71b3c270b72f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/882c3f17b61fffed412c19753c3b71b3c270b72f/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a51c0cc2af361d9338965d41d40ce8f8ede5266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a51c0cc2af361d9338965d41d40ce8f8ede5266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a51c0cc2af361d9338965d41d40ce8f8ede5266"}], "stats": {"total": 158, "additions": 96, "deletions": 62}, "files": [{"sha": "7a85aecbd9e16084679c6ac788f42189304d223d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=882c3f17b61fffed412c19753c3b71b3c270b72f", "patch": "@@ -1,3 +1,25 @@\n+2018-09-24  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\t* genattrtab.c (mk_attr_alt): Use alternative_mask.\n+\t(attr_rtx_1): Adjust caching to match the new EQ_ATTR_ALT field\n+        types.\n+\t(check_attr_test): Use alternative_mask.\n+\t(get_attr_value): Likewise.\n+\t(compute_alternative_mask): Use alternative_mask and XWINT.\n+\t(make_alternative_compare): Use alternative_mask.\n+\t(attr_alt_subset_p): Use XWINT.\n+\t(attr_alt_subset_of_compl_p): Likewise.\n+\t(attr_alt_intersection): Use alternative_mask and XWINT.\n+\t(attr_alt_union): Likewise.\n+\t(attr_alt_complement): Use HOST_WIDE_INT and XWINT.\n+        (mk_attr_alt): Use alternative_mask and HOST_WIDE_INT.\n+\t(simplify_test_exp): Use alternative_mask and XWINT.\n+\t(write_test_expr): Use alternative_mask and XWINT, adjust bit\n+        number calculation to support 64 bits.  Generate code that\n+        checks 64-bit masks.\n+\t(main): Use alternative_mask.\n+\t* rtl.def (EQ_ATTR_ALT): Change field types from ii to ww.\n+\n 2018-09-24  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/80080"}, {"sha": "d5cdbf5be23a93b56f816522121463bf40b179b8", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=882c3f17b61fffed412c19753c3b71b3c270b72f", "patch": "@@ -228,7 +228,9 @@ static int *insn_n_alternatives;\n /* Stores, for each insn code, a bitmap that has bits on for each possible\n    alternative.  */\n \n-static uint64_t *insn_alternatives;\n+/* Keep this in sync with recog.h.  */\n+typedef uint64_t alternative_mask;\n+static alternative_mask *insn_alternatives;\n \n /* Used to simplify expressions.  */\n \n@@ -256,7 +258,7 @@ static char *attr_printf           (unsigned int, const char *, ...)\n   ATTRIBUTE_PRINTF_2;\n static rtx make_numeric_value      (int);\n static struct attr_desc *find_attr (const char **, int);\n-static rtx mk_attr_alt             (uint64_t);\n+static rtx mk_attr_alt             (alternative_mask);\n static char *next_comma_elt\t   (const char **);\n static rtx insert_right_side\t   (enum rtx_code, rtx, rtx, int, int);\n static rtx copy_boolean\t\t   (rtx);\n@@ -494,26 +496,26 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \t}\n     }\n   else if (GET_RTX_LENGTH (code) == 2\n-\t   && GET_RTX_FORMAT (code)[0] == 'i'\n-\t   && GET_RTX_FORMAT (code)[1] == 'i')\n+\t   && GET_RTX_FORMAT (code)[0] == 'w'\n+\t   && GET_RTX_FORMAT (code)[1] == 'w')\n     {\n-      int  arg0 = va_arg (p, int);\n-      int  arg1 = va_arg (p, int);\n+      HOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n+      HOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n \n       hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code\n-\t    && XINT (h->u.rtl, 0) == arg0\n-\t    && XINT (h->u.rtl, 1) == arg1)\n+\t    && XWINT (h->u.rtl, 0) == arg0\n+\t    && XWINT (h->u.rtl, 1) == arg1)\n \t  return h->u.rtl;\n \n       if (h == 0)\n \t{\n \t  rtl_obstack = hash_obstack;\n \t  rt_val = rtx_alloc (code);\n-\t  XINT (rt_val, 0) = arg0;\n-\t  XINT (rt_val, 1) = arg1;\n+\t  XWINT (rt_val, 0) = arg0;\n+\t  XWINT (rt_val, 1) = arg1;\n \t}\n     }\n   else if (code == CONST_INT)\n@@ -703,7 +705,8 @@ check_attr_test (file_location loc, rtx exp, attr_desc *attr)\n \t  if (attr2 == NULL)\n \t    {\n \t      if (! strcmp (XSTR (exp, 0), \"alternative\"))\n-\t\treturn mk_attr_alt (((uint64_t) 1) << atoi (XSTR (exp, 1)));\n+\t\treturn mk_attr_alt (((alternative_mask) 1)\n+\t\t\t\t    << atoi (XSTR (exp, 1)));\n \t      else\n \t\tfatal_at (loc, \"unknown attribute `%s' in definition of\"\n \t\t\t  \" attribute `%s'\", XSTR (exp, 0), attr->name);\n@@ -750,7 +753,7 @@ check_attr_test (file_location loc, rtx exp, attr_desc *attr)\n \n \t      name_ptr = XSTR (exp, 1);\n \t      while ((p = next_comma_elt (&name_ptr)) != NULL)\n-\t\tset |= ((uint64_t) 1) << atoi (p);\n+\t\tset |= ((alternative_mask) 1) << atoi (p);\n \n \t      return mk_attr_alt (set);\n \t    }\n@@ -1224,7 +1227,7 @@ get_attr_value (file_location loc, rtx value, struct attr_desc *attr,\n \t\tint insn_code)\n {\n   struct attr_value *av;\n-  uint64_t num_alt = 0;\n+  alternative_mask num_alt = 0;\n \n   value = make_canonical (loc, attr, value);\n   if (compares_alternatives_p (value))\n@@ -1868,7 +1871,7 @@ insert_right_side (enum rtx_code code, rtx exp, rtx term, int insn_code, int ins\n    This routine is passed an expression and either AND or IOR.  It returns a\n    bitmask indicating which alternatives are mentioned within EXP.  */\n \n-static uint64_t\n+static alternative_mask\n compute_alternative_mask (rtx exp, enum rtx_code code)\n {\n   const char *string;\n@@ -1887,27 +1890,27 @@ compute_alternative_mask (rtx exp, enum rtx_code code)\n \n   else if (GET_CODE (exp) == EQ_ATTR_ALT)\n     {\n-      if (code == AND && XINT (exp, 1))\n-\treturn XINT (exp, 0);\n+      if (code == AND && XWINT (exp, 1))\n+\treturn XWINT (exp, 0);\n \n-      if (code == IOR && !XINT (exp, 1))\n-\treturn XINT (exp, 0);\n+      if (code == IOR && !XWINT (exp, 1))\n+\treturn XWINT (exp, 0);\n \n       return 0;\n     }\n   else\n     return 0;\n \n   if (string[1] == 0)\n-    return ((uint64_t) 1) << (string[0] - '0');\n-  return ((uint64_t) 1) << atoi (string);\n+    return ((alternative_mask) 1) << (string[0] - '0');\n+  return ((alternative_mask) 1) << atoi (string);\n }\n \n /* Given I, a single-bit mask, return RTX to compare the `alternative'\n    attribute with the value represented by that bit.  */\n \n static rtx\n-make_alternative_compare (uint64_t mask)\n+make_alternative_compare (alternative_mask mask)\n {\n   return mk_attr_alt (mask);\n }\n@@ -2286,19 +2289,19 @@ simplify_test_exp_in_temp (rtx exp, int insn_code, int insn_index)\n static bool\n attr_alt_subset_p (rtx s1, rtx s2)\n {\n-  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+  switch ((XWINT (s1, 1) << 1) | XWINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      return !(XINT (s1, 0) &~ XINT (s2, 0));\n+      return !(XWINT (s1, 0) &~ XWINT (s2, 0));\n \n     case (0 << 1) | 1:\n-      return !(XINT (s1, 0) & XINT (s2, 0));\n+      return !(XWINT (s1, 0) & XWINT (s2, 0));\n \n     case (1 << 1) | 0:\n       return false;\n \n     case (1 << 1) | 1:\n-      return !(XINT (s2, 0) &~ XINT (s1, 0));\n+      return !(XWINT (s2, 0) &~ XWINT (s1, 0));\n \n     default:\n       gcc_unreachable ();\n@@ -2310,16 +2313,16 @@ attr_alt_subset_p (rtx s1, rtx s2)\n static bool\n attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n {\n-  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+  switch ((XWINT (s1, 1) << 1) | XWINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      return !(XINT (s1, 0) & XINT (s2, 0));\n+      return !(XWINT (s1, 0) & XWINT (s2, 0));\n \n     case (0 << 1) | 1:\n-      return !(XINT (s1, 0) & ~XINT (s2, 0));\n+      return !(XWINT (s1, 0) & ~XWINT (s2, 0));\n \n     case (1 << 1) | 0:\n-      return !(XINT (s2, 0) &~ XINT (s1, 0));\n+      return !(XWINT (s2, 0) &~ XWINT (s1, 0));\n \n     case (1 << 1) | 1:\n       return false;\n@@ -2334,72 +2337,73 @@ attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n static rtx\n attr_alt_intersection (rtx s1, rtx s2)\n {\n-  int result;\n+  alternative_mask result;\n \n-  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+  switch ((XWINT (s1, 1) << 1) | XWINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      result = XINT (s1, 0) & XINT (s2, 0);\n+      result = XWINT (s1, 0) & XWINT (s2, 0);\n       break;\n     case (0 << 1) | 1:\n-      result = XINT (s1, 0) & ~XINT (s2, 0);\n+      result = XWINT (s1, 0) & ~XWINT (s2, 0);\n       break;\n     case (1 << 1) | 0:\n-      result = XINT (s2, 0) & ~XINT (s1, 0);\n+      result = XWINT (s2, 0) & ~XWINT (s1, 0);\n       break;\n     case (1 << 1) | 1:\n-      result = XINT (s1, 0) | XINT (s2, 0);\n+      result = XWINT (s1, 0) | XWINT (s2, 0);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  return attr_rtx (EQ_ATTR_ALT, result, XINT (s1, 1) & XINT (s2, 1));\n+  return attr_rtx (EQ_ATTR_ALT, result, XWINT (s1, 1) & XWINT (s2, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing union of S1 and S2.  */\n \n static rtx\n attr_alt_union (rtx s1, rtx s2)\n {\n-  int result;\n+  alternative_mask result;\n \n-  switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n+  switch ((XWINT (s1, 1) << 1) | XWINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      result = XINT (s1, 0) | XINT (s2, 0);\n+      result = XWINT (s1, 0) | XWINT (s2, 0);\n       break;\n     case (0 << 1) | 1:\n-      result = XINT (s2, 0) & ~XINT (s1, 0);\n+      result = XWINT (s2, 0) & ~XWINT (s1, 0);\n       break;\n     case (1 << 1) | 0:\n-      result = XINT (s1, 0) & ~XINT (s2, 0);\n+      result = XWINT (s1, 0) & ~XWINT (s2, 0);\n       break;\n     case (1 << 1) | 1:\n-      result = XINT (s1, 0) & XINT (s2, 0);\n+      result = XWINT (s1, 0) & XWINT (s2, 0);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  return attr_rtx (EQ_ATTR_ALT, result, XINT (s1, 1) | XINT (s2, 1));\n+  return attr_rtx (EQ_ATTR_ALT, result, XWINT (s1, 1) | XWINT (s2, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing complement of S.  */\n \n static rtx\n attr_alt_complement (rtx s)\n {\n-  return attr_rtx (EQ_ATTR_ALT, XINT (s, 0), 1 - XINT (s, 1));\n+  return attr_rtx (EQ_ATTR_ALT, XWINT (s, 0),\n+                   ((HOST_WIDE_INT) 1) - XWINT (s, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing set containing elements set\n    in E.  */\n \n static rtx\n-mk_attr_alt (uint64_t e)\n+mk_attr_alt (alternative_mask e)\n {\n-  return attr_rtx (EQ_ATTR_ALT, (int)e, 0);\n+  return attr_rtx (EQ_ATTR_ALT, (HOST_WIDE_INT) e, (HOST_WIDE_INT) 0);\n }\n \n /* Given an expression, see if it can be simplified for a particular insn\n@@ -2419,7 +2423,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n   struct attr_value *av;\n   struct insn_ent *ie;\n   struct attr_value_list *iv;\n-  uint64_t i;\n+  alternative_mask i;\n   rtx newexp = exp;\n   bool left_alt, right_alt;\n \n@@ -2484,14 +2488,14 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t\t    && XSTR (XEXP (left, 0), 0) == alternative_name);\n       else\n \tleft_alt = (GET_CODE (left) == EQ_ATTR_ALT\n-\t\t    && XINT (left, 1));\n+\t\t    && XWINT (left, 1));\n \n       if (GET_CODE (right) == NOT)\n \tright_alt = (GET_CODE (XEXP (right, 0)) == EQ_ATTR\n \t\t     && XSTR (XEXP (right, 0), 0) == alternative_name);\n       else\n \tright_alt = (GET_CODE (right) == EQ_ATTR_ALT\n-\t\t     && XINT (right, 1));\n+\t\t     && XWINT (right, 1));\n \n       if (insn_code >= 0\n \t  && (GET_CODE (left) == AND\n@@ -2602,12 +2606,12 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n       else if (insn_code >= 0\n \t       && (GET_CODE (left) == IOR\n \t\t   || (GET_CODE (left) == EQ_ATTR_ALT\n-\t\t       && !XINT (left, 1))\n+\t\t       && !XWINT (left, 1))\n \t\t   || (GET_CODE (left) == EQ_ATTR\n \t\t       && XSTR (left, 0) == alternative_name)\n \t\t   || GET_CODE (right) == IOR\n \t\t   || (GET_CODE (right) == EQ_ATTR_ALT\n-\t\t       && !XINT (right, 1))\n+\t\t       && !XWINT (right, 1))\n \t\t   || (GET_CODE (right) == EQ_ATTR\n \t\t       && XSTR (right, 0) == alternative_name)))\n \t{\n@@ -2688,14 +2692,15 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n       break;\n \n     case EQ_ATTR_ALT:\n-      if (!XINT (exp, 0))\n-\treturn XINT (exp, 1) ? true_rtx : false_rtx;\n+      if (!XWINT (exp, 0))\n+\treturn XWINT (exp, 1) ? true_rtx : false_rtx;\n       break;\n \n     case EQ_ATTR:\n       if (XSTR (exp, 0) == alternative_name)\n \t{\n-\t  newexp = mk_attr_alt (((uint64_t) 1) << atoi (XSTR (exp, 1)));\n+\t  newexp = mk_attr_alt (((alternative_mask) 1)\n+\t\t\t\t<< atoi (XSTR (exp, 1)));\n \t  break;\n \t}\n \n@@ -3568,7 +3573,8 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n \n     case EQ_ATTR_ALT:\n \t{\n-\t  int set = XINT (exp, 0), bit = 0;\n+\t  alternative_mask set = XWINT (exp, 0);\n+\t  int bit = 0;\n \n \t  if (flags & FLG_BITWISE)\n \t    fatal (\"EQ_ATTR_ALT not valid inside comparison\");\n@@ -3578,6 +3584,11 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n \n \t  if (!(set & (set - 1)))\n \t    {\n+\t      if (!(set & 0xffffffff))\n+\t\t{\n+\t\t  bit += 32;\n+\t\t  set >>= 32;\n+\t\t}\n \t      if (!(set & 0xffff))\n \t\t{\n \t\t  bit += 16;\n@@ -3602,12 +3613,13 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n \t\tbit++;\n \n \t      fprintf (outf, \"which_alternative %s= %d\",\n-\t\t       XINT (exp, 1) ? \"!\" : \"=\", bit);\n+\t\t       XWINT (exp, 1) ? \"!\" : \"=\", bit);\n \t    }\n \t  else\n \t    {\n-\t      fprintf (outf, \"%s((1 << which_alternative) & %#x)\",\n-\t\t       XINT (exp, 1) ? \"!\" : \"\", set);\n+\t      fprintf (outf, \"%s((1ULL << which_alternative) & %#\" PRIx64\n+\t\t\t     \"ULL)\",\n+\t\t       XWINT (exp, 1) ? \"!\" : \"\", set);\n \t    }\n \t}\n       break;\n@@ -5220,11 +5232,11 @@ main (int argc, const char **argv)\n \n   /* Make `insn_alternatives'.  */\n   int num_insn_codes = get_num_insn_codes ();\n-  insn_alternatives = oballocvec (uint64_t, num_insn_codes);\n+  insn_alternatives = oballocvec (alternative_mask, num_insn_codes);\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code]\n-\t= (((uint64_t) 1) << id->num_alternatives) - 1;\n+\t= (((alternative_mask) 1) << id->num_alternatives) - 1;\n \n   /* Make `insn_n_alternatives'.  */\n   insn_n_alternatives = oballocvec (int, num_insn_codes);"}, {"sha": "3d417ea23ac2926d6cbc310161c8b3253439778a", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=882c3f17b61fffed412c19753c3b71b3c270b72f", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n    a type that has at least MAX_RECOG_ALTERNATIVES + 1 bits, with the extra\n    bit giving an invalid value that can be used to mean \"uninitialized\".  */\n #define MAX_RECOG_ALTERNATIVES 35\n-typedef uint64_t alternative_mask;\n+typedef uint64_t alternative_mask;  /* Keep in sync with genattrtab.c.  */\n \n /* A mask of all alternatives.  */\n #define ALL_ALTERNATIVES ((alternative_mask) -1)"}, {"sha": "b4282ab7ffd86f8f16a0851ac056a403d1efda9f", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/882c3f17b61fffed412c19753c3b71b3c270b72f/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=882c3f17b61fffed412c19753c3b71b3c270b72f", "patch": "@@ -1310,7 +1310,7 @@ DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", RTX_EXTRA)\n \n /* A special case of the above representing a set of alternatives.  The first\n    operand is bitmap of the set, the second one is the default value.  */\n-DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", RTX_EXTRA)\n+DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ww\", RTX_EXTRA)\n \n /* A conditional expression which is true if the specified flag is\n    true for the insn being scheduled in reorg."}]}