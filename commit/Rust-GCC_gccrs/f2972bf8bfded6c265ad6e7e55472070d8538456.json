{"sha": "f2972bf8bfded6c265ad6e7e55472070d8538456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5NzJiZjhiZmRlZDZjMjY1YWQ2ZTdlNTU0NzIwNzBkODUzODQ1Ng==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2009-08-22T02:50:30Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-08-22T02:50:30Z"}, "message": "ia64.c: Include libfuncs.h.\n\n\n\t* config/ia64/ia64.c: Include libfuncs.h.\n\t(TARGET_PROMOTE_FUNCITON_MODE): Define target macro.\n\t(ia64_expand_call): Use reg 25 on VMS.\n\t(ia64_initialize_trampoline): Fix for VMS ABI.\n\t(ia64_function_arg_offset): Always returns 0 when TARGET_ABI_OPEN_VMS.\n\t(ia64_function_arg): Initialize reg 25 on VMS.\n\tFix OpenVMS ABI issues for varargs.\n\tFor OpenVMS, emit the Argument Information register set in the\n\tincoming/sibcall case as well.\n\t(ia64_arg_type): New function.\n\t(ia64_function_arg_advance): Keep track of cum->words.\n\tFix OpenVMS ABI issues for varargs.\n\t(ia64_function_value): On VMS, promote mode of non-aggregate types.\n\t(ia64_override_options): Set flag_no_common on VMS.\n\t(ia64_init_builtins): Disable FWRITE builtin.\n\t(ia64_asm_output_external): Call DO_CRTL_NAMES.\n\t(ia64_vms_init_libfuncs): Add decc$ routines.\n\t(ia64_vms_valid_pointer_mode): New function.\n\t(ia64_struct_value_rtx): Allways NULL_RTX on VMS.\n\t(ia64_promote_function_mode): New function\n\t* config/ia64/ia64.h (TARGET_ABI_OPEN_VMS): Define as 0 for default.\n\t(LONG_DOUBLE_TYPE_SIZE): Force to 64 on VMS.\n\t(LIBCGC2_LONG_DOUBLE_TYPE_SIZE): Likewise.\n\t(INIT_CUMULATIVE_ARGS): Add atypes for VMS.\n\t(INIT_CUMULATIVE_INCOMING_ARGS): Likewise.\n\t(ASM_OUTPUT_DEF): Use ISDIGIT instead of isdigit.\n\tSuppress trailing '#' if VALUE is numeric.\n\t* config/ia64/vms.h (PROMOTE_FUNCTION_MODE): Remove, code moved to\n\tia64_promote_function_mode.\n\t(TARGET_VALID_POINTER_MODE): Define.\n\n\nCo-Authored-By: Olivier Hainque <hainque@adacore.com>\n\nFrom-SVN: r151009", "tree": {"sha": "5ba87de8a7d9c89aad2cd960d2d8dbb5410cc3ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba87de8a7d9c89aad2cd960d2d8dbb5410cc3ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2972bf8bfded6c265ad6e7e55472070d8538456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2972bf8bfded6c265ad6e7e55472070d8538456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2972bf8bfded6c265ad6e7e55472070d8538456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2972bf8bfded6c265ad6e7e55472070d8538456/comments", "author": null, "committer": null, "parents": [{"sha": "124b06300a9b1e1469f712b6db8f8641ce4af0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124b06300a9b1e1469f712b6db8f8641ce4af0f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124b06300a9b1e1469f712b6db8f8641ce4af0f4"}], "stats": {"total": 252, "additions": 217, "deletions": 35}, "files": [{"sha": "d94b0469837538e6a3d8e554188af287c84e76cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2972bf8bfded6c265ad6e7e55472070d8538456", "patch": "@@ -1,3 +1,37 @@\n+2009-08-21  Douglas B Rupp  <rupp@gnat.com>\n+\t    Olivier Hainque  <hainque@adacore.com>\n+\n+\t* config/ia64/ia64.c: Include libfuncs.h.\n+\t(TARGET_PROMOTE_FUNCITON_MODE): Define target macro.\n+\t(ia64_expand_call): Use reg 25 on VMS.\n+\t(ia64_initialize_trampoline): Fix for VMS ABI.\n+\t(ia64_function_arg_offset): Always returns 0 when TARGET_ABI_OPEN_VMS.\n+\t(ia64_function_arg): Initialize reg 25 on VMS.\n+\tFix OpenVMS ABI issues for varargs.\n+\tFor OpenVMS, emit the Argument Information register set in the\n+\tincoming/sibcall case as well.\n+\t(ia64_arg_type): New function.\n+\t(ia64_function_arg_advance): Keep track of cum->words.\n+\tFix OpenVMS ABI issues for varargs.\n+\t(ia64_function_value): On VMS, promote mode of non-aggregate types.\n+\t(ia64_override_options): Set flag_no_common on VMS.\n+\t(ia64_init_builtins): Disable FWRITE builtin.\n+\t(ia64_asm_output_external): Call DO_CRTL_NAMES.\n+\t(ia64_vms_init_libfuncs): Add decc$ routines.\n+\t(ia64_vms_valid_pointer_mode): New function.\n+\t(ia64_struct_value_rtx): Allways NULL_RTX on VMS.\n+\t(ia64_promote_function_mode): New function\n+\t* config/ia64/ia64.h (TARGET_ABI_OPEN_VMS): Define as 0 for default.\n+\t(LONG_DOUBLE_TYPE_SIZE): Force to 64 on VMS.\n+\t(LIBCGC2_LONG_DOUBLE_TYPE_SIZE): Likewise.\n+\t(INIT_CUMULATIVE_ARGS): Add atypes for VMS.\n+\t(INIT_CUMULATIVE_INCOMING_ARGS): Likewise.\n+\t(ASM_OUTPUT_DEF): Use ISDIGIT instead of isdigit.\n+\tSuppress trailing '#' if VALUE is numeric.\n+\t* config/ia64/vms.h (PROMOTE_FUNCTION_MODE): Remove, code moved to\n+\tia64_promote_function_mode.\n+\t(TARGET_VALID_POINTER_MODE): Define.\n+\n 2009-08-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/40671"}, {"sha": "a36e9d2023118a09b0a7f06495074c0d9bba6cf7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 155, "deletions": 11, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f2972bf8bfded6c265ad6e7e55472070d8538456", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n+#include \"libfuncs.h\"\n #include \"toplev.h\"\n #include \"sched-int.h\"\n #include \"timevar.h\"\n@@ -276,6 +277,8 @@ static void ia64_vms_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n static void ia64_soft_fp_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n+static bool ia64_vms_valid_pointer_mode (enum machine_mode mode)\n+     ATTRIBUTE_UNUSED;\n \n static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);\n static tree ia64_handle_version_id_attribute (tree *, tree, tree, int, bool *);\n@@ -290,6 +293,11 @@ static const char *ia64_invalid_conversion (const_tree, const_tree);\n static const char *ia64_invalid_unary_op (int, const_tree);\n static const char *ia64_invalid_binary_op (int, const_tree, const_tree);\n static enum machine_mode ia64_c_mode_for_suffix (char);\n+static enum machine_mode ia64_promote_function_mode (const_tree,\n+\t\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t\t     int *,\n+\t\t\t\t\t\t     const_tree,\n+\t\t\t\t\t\t     int);\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -457,11 +465,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL ia64_output_dwarf_dtprel\n #endif\n \n-/* ??? ABI doesn't allow us to define this.  */\n-#if 0\n #undef TARGET_PROMOTE_FUNCTION_MODE\n-#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode_always_promote\n-#endif\n+#define TARGET_PROMOTE_FUNCTION_MODE ia64_promote_function_mode\n \n /* ??? Investigate.  */\n #if 0\n@@ -1918,6 +1923,10 @@ ia64_expand_call (rtx retval, rtx addr, rtx nextarg ATTRIBUTE_UNUSED,\n \n   if (sibcall_p)\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), b0);\n+\n+  if (TARGET_ABI_OPEN_VMS)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t     gen_rtx_REG (DImode, GR_REG (25)));\n }\n \n static void\n@@ -3832,7 +3841,7 @@ ia64_dbx_register_number (int regno)\n void\n ia64_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n {\n-  rtx addr_reg, eight = GEN_INT (8);\n+  rtx addr_reg, tramp, eight = GEN_INT (8);\n \n   /* The Intel assembler requires that the global __ia64_trampoline symbol\n      be declared explicitly */\n@@ -3859,8 +3868,21 @@ ia64_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n \n   /* The first two words are the fake descriptor:\n      __ia64_trampoline, ADDR+16.  */\n-  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),\n-\t\t  gen_rtx_SYMBOL_REF (Pmode, \"__ia64_trampoline\"));\n+  tramp = gen_rtx_SYMBOL_REF (Pmode, \"__ia64_trampoline\");\n+  if (TARGET_ABI_OPEN_VMS)\n+    {\n+      /* HP decided to break the ELF ABI on VMS (to deal with an ambiguity\n+\t in the Macro-32 compiler) and changed the semantics of the LTOFF22\n+\t relocation against function symbols to make it identical to the\n+\t LTOFF_FPTR22 relocation.  Emit the latter directly to stay within\n+\t strict ELF and dereference to get the bare code address.  */\n+      rtx reg = gen_reg_rtx (Pmode);\n+      SYMBOL_REF_FLAGS (tramp) |= SYMBOL_FLAG_FUNCTION;\n+      emit_move_insn (reg, tramp);\n+      emit_move_insn (reg, gen_rtx_MEM (Pmode, reg));\n+      tramp = reg;\n+   }\n+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), tramp);\n   emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));\n \n   emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),\n@@ -4017,7 +4039,8 @@ ia64_function_arg_words (tree type, enum machine_mode mode)\n static int\n ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)\n {\n-  if ((cum->words & 1) == 0)\n+  /* No registers are skipped on VMS.  */\n+  if (TARGET_ABI_OPEN_VMS || (cum->words & 1) == 0)\n     return 0;\n \n   if (type\n@@ -4042,6 +4065,24 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   int offset = ia64_function_arg_offset (cum, type, words);\n   enum machine_mode hfa_mode = VOIDmode;\n \n+  /* For OPEN VMS, emit the instruction setting up the argument register here,\n+     when we know this will be together with the other arguments setup related\n+     insns.  This is not the conceptually best place to do this, but this is\n+     the easiest as we have convenient access to cumulative args info.  */\n+\n+  if (TARGET_ABI_OPEN_VMS && mode == VOIDmode && type == void_type_node\n+      && named == 1)\n+    {\n+      unsigned HOST_WIDE_INT regval = cum->words;\n+      int i;\n+\n+      for (i = 0; i < 8; i++)\n+\tregval |= ((int) cum->atypes[i]) << (i * 3 + 8);\n+\n+      emit_move_insn (gen_rtx_REG (DImode, GR_REG (25)),\n+\t\t      GEN_INT (regval));\n+    }\n+\n   /* If all argument slots are used, then it must go on the stack.  */\n   if (cum->words + offset >= MAX_ARGUMENT_SLOTS)\n     return 0;\n@@ -4131,6 +4172,15 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \t}\n       return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n+  \n+  /* On OpenVMS variable argument is either in Rn or Fn.  */\n+  else if (TARGET_ABI_OPEN_VMS && named == 0)\n+    {\n+      if (FLOAT_MODE_P (mode))\n+\treturn gen_rtx_REG (mode, FR_ARG_FIRST + cum->words);\n+      else\n+\treturn gen_rtx_REG (mode, basereg + cum->words);\n+    }\n \n   /* Integral and aggregates go in general registers.  If we have run out of\n      FR registers, then FP values must also go in general registers.  This can\n@@ -4223,6 +4273,22 @@ ia64_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   return (MAX_ARGUMENT_SLOTS - cum->words - offset) * UNITS_PER_WORD;\n }\n \n+/* Return ivms_arg_type based on machine_mode.  */\n+\n+static enum ivms_arg_type\n+ia64_arg_type (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SFmode:\n+      return FS;\n+    case DFmode:\n+      return FT;\n+    default:\n+      return I64;\n+    }\n+}\n+\n /* Update CUM to point after this argument.  This is patterned after\n    ia64_function_arg.  */\n \n@@ -4236,8 +4302,12 @@ ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   /* If all arg slots are already full, then there is nothing to do.  */\n   if (cum->words >= MAX_ARGUMENT_SLOTS)\n-    return;\n+    {\n+      cum->words += words + offset;\n+      return;\n+    }\n \n+  cum->atypes[cum->words] = ia64_arg_type (mode);\n   cum->words += words + offset;\n \n   /* Check for and handle homogeneous FP aggregates.  */\n@@ -4280,6 +4350,13 @@ ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cum->fp_regs = fp_regs;\n     }\n \n+  /* On OpenVMS variable argument is either in Rn or Fn.  */\n+  else if (TARGET_ABI_OPEN_VMS && named == 0)\n+    {\n+      cum->int_regs = cum->words;\n+      cum->fp_regs = cum->words;\n+    }\n+\n   /* Integral and aggregates go in general registers.  So do TFmode FP values.\n      If we have run out of FR registers, then other FP values must also go in\n      general registers.  This can happen when we have a SFmode HFA.  */\n@@ -4424,10 +4501,11 @@ ia64_return_in_memory (const_tree valtype, const_tree fntype ATTRIBUTE_UNUSED)\n /* Return rtx for register that holds the function return value.  */\n \n rtx\n-ia64_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n+ia64_function_value (const_tree valtype, const_tree func)\n {\n   enum machine_mode mode;\n   enum machine_mode hfa_mode;\n+  int unsignedp;\n \n   mode = TYPE_MODE (valtype);\n   hfa_mode = hfa_element_mode (valtype, 0);\n@@ -4498,6 +4576,10 @@ ia64_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n \t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n \t}\n \n+      mode = ia64_promote_function_mode (valtype, mode, &unsignedp,\n+\t\t\t\t\t func ? TREE_TYPE (func) : NULL_TREE,\n+\t\t\t\t\t true);\n+\n       return gen_rtx_REG (mode, GR_RET_FIRST);\n     }\n }\n@@ -5306,6 +5388,9 @@ ia64_override_options (void)\n     align_functions = 64;\n   if (align_loops <= 0)\n     align_loops = 32;\n+\n+  if (TARGET_ABI_OPEN_VMS)\n+    flag_no_common = 1;\n }\n \n /* Initialize the record of emitted frame related registers.  */\n@@ -9830,6 +9915,13 @@ ia64_init_builtins (void)\n     (*lang_hooks.types.register_builtin_type) (long_double_type_node,\n \t\t\t\t\t       \"__float128\");\n \n+  /* Fwrite on VMS is non-standard.  */\n+  if (TARGET_ABI_OPEN_VMS)\n+    {\n+      implicit_built_in_decls[(int) BUILT_IN_FWRITE] = NULL_TREE;\n+      implicit_built_in_decls[(int) BUILT_IN_FWRITE_UNLOCKED] = NULL_TREE;\n+    }\n+\n #define def_builtin(name, type, code)\t\t\t\t\t\\\n   add_builtin_function ((name), (type), (code), BUILT_IN_MD,\t\\\n \t\t       NULL, NULL_TREE)\n@@ -9942,6 +10034,10 @@ ia64_asm_output_external (FILE *file, tree decl, const char *name)\n       int need_visibility = ((*targetm.binds_local_p) (decl)\n \t\t\t     && maybe_assemble_visibility (decl));\n \n+#ifdef DO_CRTL_NAMES\n+      DO_CRTL_NAMES;\n+#endif\n+\n       /* GNU as does not need anything here, but the HP linker does\n \t need something for external functions.  */\n       if ((TARGET_HPUX_LD || !TARGET_GNU_AS)\n@@ -10044,6 +10140,11 @@ ia64_vms_init_libfuncs (void)\n   set_optab_libfunc (smod_optab, DImode, \"OTS$REM_L\");\n   set_optab_libfunc (umod_optab, SImode, \"OTS$REM_UI\");\n   set_optab_libfunc (umod_optab, DImode, \"OTS$REM_UL\");\n+  abort_libfunc = init_one_libfunc (\"decc$abort\");\n+  memcmp_libfunc = init_one_libfunc (\"decc$memcmp\");\n+#ifdef MEM_LIBFUNCS_INIT\n+  MEM_LIBFUNCS_INIT;\n+#endif\n }\n \n /* Rename the TFmode libfuncs available from soft-fp in glibc using\n@@ -10074,6 +10175,12 @@ static void\n ia64_soft_fp_init_libfuncs (void)\n {\n }\n+\n+static bool\n+ia64_vms_valid_pointer_mode (enum machine_mode mode)\n+{\n+  return (mode == SImode || mode == DImode);\n+}\n \f\n /* For HPUX, it is illegal to have relocations in shared segments.  */\n \n@@ -10299,7 +10406,8 @@ static rtx\n ia64_struct_value_rtx (tree fntype,\n \t\t       int incoming ATTRIBUTE_UNUSED)\n {\n-  if (fntype && ia64_struct_retval_addr_is_first_parm_p (fntype))\n+  if (TARGET_ABI_OPEN_VMS ||\n+      (fntype && ia64_struct_retval_addr_is_first_parm_p (fntype)))\n     return NULL_RTX;\n   return gen_rtx_REG (Pmode, GR_REG (8));\n }\n@@ -10564,6 +10672,42 @@ ia64_c_mode_for_suffix (char suffix)\n   return VOIDmode;\n }\n \n+static enum machine_mode\n+ia64_promote_function_mode (const_tree type,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    int *punsignedp,\n+\t\t\t    const_tree funtype ATTRIBUTE_UNUSED,\n+\t\t\t    int for_return ATTRIBUTE_UNUSED)\n+{\n+  /* Special processing required for OpenVMS ...  */\n+\n+  if (!TARGET_ABI_OPEN_VMS)\n+    return mode;\n+\n+  /* HP OpenVMS Calling Standard dated June, 2004, that describes\n+     HP OpenVMS I64 Version 8.2EFT,\n+     chapter 4 \"OpenVMS I64 Conventions\"\n+     section 4.7 \"Procedure Linkage\"\n+     subsection 4.7.5.2, \"Normal Register Parameters\"\n+\n+     \"Unsigned integral (except unsigned 32-bit), set, and VAX floating-point\n+     values passed in registers are zero-filled; signed integral values as\n+     well as unsigned 32-bit integral values are sign-extended to 64 bits.\n+     For all other types passed in the general registers, unused bits are\n+     undefined.\"  */\n+\n+  if (!AGGREGATE_TYPE_P (type)\n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+    {\n+      if (mode == SImode)\n+\t*punsignedp = 0;\n+      return DImode;\n+    }\n+  else\n+    return promote_mode (type, mode, punsignedp);\n+}\n+   \n static GTY(()) rtx ia64_dconst_0_5_rtx;\n \n rtx"}, {"sha": "f91e63942f8aed0c78bd95eae6d27e20b685e6f1", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f2972bf8bfded6c265ad6e7e55472070d8538456", "patch": "@@ -73,6 +73,8 @@ extern unsigned int ia64_section_threshold;\n #define TARGET_HPUX\t\t0\n #define TARGET_HPUX_LD\t\t0\n \n+#define TARGET_ABI_OPEN_VMS 0\n+\n #ifndef TARGET_ILP32\n #define TARGET_ILP32 0\n #endif\n@@ -279,11 +281,17 @@ while (0)\n \n #define DOUBLE_TYPE_SIZE 64\n \n-/* long double is XFmode normally, TFmode for HPUX.  */\n-#define LONG_DOUBLE_TYPE_SIZE (TARGET_HPUX ? 128 : 80)\n+/* long double is XFmode normally, and TFmode for HPUX.  It should be\n+   TFmode for VMS as well but we only support up to DFmode now.  */\n+#define LONG_DOUBLE_TYPE_SIZE \\\n+  (TARGET_HPUX ? 128 \\\n+   : TARGET_ABI_OPEN_VMS ? 64 \\\n+   : 80)\n+\n+/* We always want the XFmode operations from libgcc2.c, except on VMS\n+   where this yields references to unimplemented \"insns\".  */\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE  (TARGET_ABI_OPEN_VMS ? 64 : 80)\n \n-/* We always want the XFmode operations from libgcc2.c.  */\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 80\n \n /* On HP-UX, we use the l suffix for TFmode in libgcc2.c.  */\n #define LIBGCC2_TF_CEXT l\n@@ -1077,12 +1085,16 @@ enum reg_class\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far.  */\n \n+enum ivms_arg_type {I64, FF, FD, FG, FS, FT};\n+/* VMS floating point formats VAX F, VAX D, VAX G, IEEE S, IEEE T.  */\n+\n typedef struct ia64_args\n {\n   int words;\t\t\t/* # words of arguments so far  */\n   int int_regs;\t\t\t/* # GR registers used so far  */\n   int fp_regs;\t\t\t/* # FR registers used so far  */\n   int prototype;\t\t/* whether function prototyped  */\n+  enum ivms_arg_type atypes[8]; /* which VMS float type or if not float */\n } CUMULATIVE_ARGS;\n \n /* A C statement (sans semicolon) for initializing the variable CUM for the\n@@ -1094,6 +1106,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   (CUM).int_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).fp_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).prototype = ((FNTYPE) && TYPE_ARG_TYPES (FNTYPE)) || (LIBNAME);\t\\\n+  (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;\t        \\\n+  (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;            \\\n+  (CUM).atypes[6] = (CUM).atypes[7] = I64;                              \\\n } while (0)\n \n /* Like `INIT_CUMULATIVE_ARGS' but overrides it for the purposes of finding the\n@@ -1108,6 +1123,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   (CUM).int_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).fp_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).prototype = 1;\t\t\t\t\t\t\t\\\n+  (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;\t        \\\n+  (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;            \\\n+  (CUM).atypes[6] = (CUM).atypes[7] = I64;                              \\\n } while (0)\n \n /* A C statement (sans semicolon) to update the summarizer variable CUM to\n@@ -1496,8 +1514,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   assemble_name (STREAM, NAME);\t\t\t\t\t\t\\\n   fputs (\" = \", STREAM);\t\t\t\t\t\t\\\n+  if (ISDIGIT (*VALUE))\t\t\t\t\t\t\t\\\n+    ia64_asm_output_label = 1;\t\t\t\t\t\t\\\n   assemble_name (STREAM, VALUE);\t\t\t\t\t\\\n   fputc ('\\n', STREAM);\t\t\t\t\t\t\t\\\n+  ia64_asm_output_label = 0;\t\t\t\t\t\t\\\n } while (0)\n \n \f"}, {"sha": "279586c0398aea43e9dd28014176dbf0e0b24666", "filename": "gcc/config/ia64/vms.h", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2972bf8bfded6c265ad6e7e55472070d8538456/gcc%2Fconfig%2Fia64%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvms.h?ref=f2972bf8bfded6c265ad6e7e55472070d8538456", "patch": "@@ -66,26 +66,6 @@ along with GCC; see the file COPYING3.  If not see\n #undef WIDEST_HARDWARE_FP_SIZE\n #define WIDEST_HARDWARE_FP_SIZE 64\n \n-/* HP OpenVMS Calling Standard dated June, 2004, that describes\n-   HP OpenVMS I64 Version 8.2EFT\n-   chapter 4 \"OpenVMS I64 Conventions\"\n-   section 4.7 \"Procedure Linkage\"\n-   subsection 4.7.5.2, \"Normal Register Parameters\"\n-\n-   \"Unsigned integral (except unsigned 32-bit), set, and VAX\n-   floating-point values passed in registers are zero-filled;\n-   signed integral values as well as unsigned 32-bit integral\n-   values are sign-extended to 64 bits.  For all other types\n-   passed in the general registers, unused bits are undefined.\"  */\n-#define PROMOTE_FUNCTION_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if ((MODE) == SImode)\t\t\t\t\\\n-\t(UNSIGNEDP) = 0;\t\t\t\t\\\n-      (MODE) = DImode;\t\t\t\t\t\\\n-    }\n-\n /* The structure return address arrives as an \"argument\" on VMS.  */\n #undef PCC_STATIC_STRUCT_RETURN\n \n@@ -227,5 +207,8 @@ typedef struct crtl_name_spec\n #define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \\\n   ia64_vms_output_aligned_decl_common (FILE, DECL, NAME, SIZE, ALIGN)\n \n+#undef TARGET_VALID_POINTER_MODE\n+#define TARGET_VALID_POINTER_MODE ia64_vms_valid_pointer_mode\n+\n #undef TARGET_ASM_NAMED_SECTION\n #define TARGET_ASM_NAMED_SECTION ia64_vms_elf_asm_named_section"}]}