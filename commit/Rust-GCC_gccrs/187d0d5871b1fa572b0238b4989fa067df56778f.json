{"sha": "187d0d5871b1fa572b0238b4989fa067df56778f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3ZDBkNTg3MWIxZmE1NzJiMDIzOGI0OTg5ZmEwNjdkZjU2Nzc4Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-02-13T05:40:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-02-19T02:22:18Z"}, "message": "c++: Tuple of self-dependent classes [PR96926]\n\nWhen compiling this testcase, trying to resolve the initialization for the\ntuple member ends up recursively considering the same set of tuple\nconstructor overloads, and since two of them separately depend on\nis_constructible, the one we try second fails to instantiate\nis_constructible because we're still in the middle of instantiating it the\nfirst time.\n\nFixed by implementing an optimization that someone suggested we were already\ndoing: if we see a non-template candidate that is a perfect match for all\narguments, we can skip considering template candidates at all.  It would be\nenough to do this only when LOOKUP_DEFAULTED, but it shouldn't hurt in other\ncases.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96926\n\t* call.c (perfect_conversion_p): New.\n\t(perfect_candidate_p): New.\n\t(add_candidates): Ignore templates after a perfect non-template.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96926\n\t* g++.dg/cpp0x/overload4.C: New test.", "tree": {"sha": "4e944d1d7d0c29ce6c63f221e57c3336a4b996d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e944d1d7d0c29ce6c63f221e57c3336a4b996d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/187d0d5871b1fa572b0238b4989fa067df56778f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187d0d5871b1fa572b0238b4989fa067df56778f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187d0d5871b1fa572b0238b4989fa067df56778f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187d0d5871b1fa572b0238b4989fa067df56778f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf81237eccb1d5d2d8078b1d2c5a0b9cc0258d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf81237eccb1d5d2d8078b1d2c5a0b9cc0258d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf81237eccb1d5d2d8078b1d2c5a0b9cc0258d61"}], "stats": {"total": 264, "additions": 252, "deletions": 12}, "files": [{"sha": "bc369c68c5a63ade9cd97b2e42712591951ab05c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187d0d5871b1fa572b0238b4989fa067df56778f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187d0d5871b1fa572b0238b4989fa067df56778f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=187d0d5871b1fa572b0238b4989fa067df56778f", "patch": "@@ -5853,6 +5853,47 @@ prep_operand (tree operand)\n   return operand;\n }\n \n+/* True iff CONV represents a conversion sequence which no other can be better\n+   than under [over.ics.rank]: in other words, a \"conversion\" to the exact same\n+   type (including binding to a reference to the same type).  This is stronger\n+   than the standard's \"identity\" category, which also includes reference\n+   bindings that add cv-qualifiers or change rvalueness.  */\n+\n+static bool\n+perfect_conversion_p (conversion *conv)\n+{\n+  if (CONVERSION_RANK (conv) != cr_identity)\n+    return false;\n+  if (!conv->rvaluedness_matches_p)\n+    return false;\n+  if (conv->kind == ck_ref_bind\n+      && !same_type_p (TREE_TYPE (conv->type),\n+\t\t       next_conversion (conv)->type))\n+    return false;\n+  return true;\n+}\n+\n+/* True if CAND represents a perfect match, i.e. all perfect conversions, so no\n+   other candidate can be a better match.  Since the template/non-template\n+   tiebreaker comes immediately after the conversion comparison in\n+   [over.match.best], a perfect non-template candidate is better than all\n+   templates.  */\n+\n+static bool\n+perfect_candidate_p (z_candidate *cand)\n+{\n+  if (cand->viable < 1)\n+    return false;\n+  int len = cand->num_convs;\n+  for (int i = 0; i < len; ++i)\n+    if (!perfect_conversion_p (cand->convs[i]))\n+      return false;\n+  if (conversion *conv = cand->second_conv)\n+    if (!perfect_conversion_p (conv))\n+      return false;\n+  return true;\n+}\n+\n /* Add each of the viable functions in FNS (a FUNCTION_DECL or\n    OVERLOAD) to the CANDIDATES, returning an updated list of\n    CANDIDATES.  The ARGS are the arguments provided to the call;\n@@ -5920,6 +5961,18 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n     /* Delay creating the implicit this parameter until it is needed.  */\n     non_static_args = NULL;\n \n+  /* If there's a non-template perfect match, we don't need to consider\n+     templates.  So check non-templates first.  This optimization is only\n+     really needed for the defaulted copy constructor of tuple and the like\n+     (96926), but it seems like we might as well enable it more generally.  */\n+  bool seen_perfect = false;\n+  enum { templates, non_templates, either } which = either;\n+  if (template_only)\n+    which = templates;\n+  else /*if (flags & LOOKUP_DEFAULTED)*/\n+    which = non_templates;\n+\n+ again:\n   for (lkp_iterator iter (fns); iter; ++iter)\n     {\n       fn = *iter;\n@@ -5928,6 +5981,10 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \tcontinue;\n       if (check_list_ctor && !is_list_ctor (fn))\n \tcontinue;\n+      if (which == templates && TREE_CODE (fn) != TEMPLATE_DECL)\n+\tcontinue;\n+      if (which == non_templates && TREE_CODE (fn) == TEMPLATE_DECL)\n+\tcontinue;\n \n       tree fn_first_arg = NULL_TREE;\n       const vec<tree, va_gc> *fn_args = args;\n@@ -5967,25 +6024,34 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t\t\t\tfn,\n \t\t\t\tctype,\n \t\t\t\texplicit_targs,\n-\t\t\t\tfn_first_arg, \n+\t\t\t\tfn_first_arg,\n \t\t\t\tfn_args,\n \t\t\t\treturn_type,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n \t\t\t\tstrict,\n \t\t\t\tcomplain);\n-      else if (!template_only)\n-\tadd_function_candidate (candidates,\n-\t\t\t\tfn,\n-\t\t\t\tctype,\n-\t\t\t\tfn_first_arg,\n-\t\t\t\tfn_args,\n-\t\t\t\taccess_path,\n-\t\t\t\tconversion_path,\n-\t\t\t\tflags,\n-\t\t\t\tNULL,\n-\t\t\t\tcomplain);\n+      else\n+\t{\n+\t  add_function_candidate (candidates,\n+\t\t\t\t  fn,\n+\t\t\t\t  ctype,\n+\t\t\t\t  fn_first_arg,\n+\t\t\t\t  fn_args,\n+\t\t\t\t  access_path,\n+\t\t\t\t  conversion_path,\n+\t\t\t\t  flags,\n+\t\t\t\t  NULL,\n+\t\t\t\t  complain);\n+\t  if (perfect_candidate_p (*candidates))\n+\t    seen_perfect = true;\n+\t}\n+    }\n+  if (which == non_templates && !seen_perfect)\n+    {\n+      which = templates;\n+      goto again;\n     }\n }\n "}, {"sha": "b2f8eb1ba02367f128394eb80eccbc88d519b105", "filename": "gcc/testsuite/g++.dg/cpp0x/overload4.C", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187d0d5871b1fa572b0238b4989fa067df56778f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187d0d5871b1fa572b0238b4989fa067df56778f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload4.C?ref=187d0d5871b1fa572b0238b4989fa067df56778f", "patch": "@@ -0,0 +1,174 @@\n+// PR c++/96926\n+// { dg-do compile { target c++11 } }\n+\n+namespace std\n+{\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp value = __v;\n+      typedef integral_constant<_Tp, __v> type;\n+    };\n+\n+  template<typename _Tp, _Tp __v>\n+    constexpr _Tp integral_constant<_Tp, __v>::value;\n+\n+  typedef integral_constant<bool, true> true_type;\n+  typedef integral_constant<bool, false> false_type;\n+\n+  template<bool __v>\n+    using bool_constant = integral_constant<bool, __v>;\n+\n+  template<bool, typename, typename>\n+    struct conditional;\n+\n+  template<typename...>\n+    struct __and_;\n+\n+  template<>\n+    struct __and_<>\n+    : public true_type\n+    { };\n+\n+  template<typename _B1>\n+    struct __and_<_B1>\n+    : public _B1\n+    { };\n+\n+  template<typename _B1, typename _B2>\n+    struct __and_<_B1, _B2>\n+    : public conditional<_B1::value, _B2, _B1>::type\n+    { };\n+\n+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n+    struct __and_<_B1, _B2, _B3, _Bn...>\n+    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type\n+    { };\n+\n+  template<typename _Tp, typename... _Args>\n+    struct is_constructible\n+    : public bool_constant<__is_constructible(_Tp, _Args...)>\n+    {\n+    };\n+\n+  template<bool, typename _Tp = void>\n+    struct enable_if\n+    { };\n+\n+  template<typename _Tp>\n+    struct enable_if<true, _Tp>\n+    { typedef _Tp type; };\n+\n+  template<bool _Cond, typename _Tp = void>\n+    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;\n+\n+  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n+    struct conditional\n+    { typedef _Iftrue type; };\n+\n+\n+  template<typename _Iftrue, typename _Iffalse>\n+    struct conditional<false, _Iftrue, _Iffalse>\n+    { typedef _Iffalse type; };\n+\n+\n+  template<bool, typename... _Types>\n+    struct _TupleConstraints\n+    {\n+      template<typename... _UTypes>\n+        static constexpr bool __is_implicitly_constructible()\n+        {\n+          // is_constructible is incomplete here, but only when\n+          // it is also instantiated in __is_explicitly_constructible \n+          return __and_<is_constructible<_Types, _UTypes>...,\n+                 true_type\n+                   >::value;\n+        }\n+\n+      template<typename... _UTypes>\n+        static constexpr bool __is_explicitly_constructible()\n+        {\n+#if FIX\n+          return false;\n+#else\n+          return __and_<is_constructible<_Types, _UTypes>...,\n+                 false_type\n+                   >::value;\n+#endif\n+        }\n+    };\n+\n+  template<typename... _Elements>\n+    class tuple\n+    {\n+      template<bool _Cond>\n+        using _TCC = _TupleConstraints<_Cond, _Elements...>;\n+\n+      template<bool _Cond, typename... _Args>\n+        using _ImplicitCtor = __enable_if_t<\n+        _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),\n+        bool>;\n+\n+      template<bool _Cond, typename... _Args>\n+        using _ExplicitCtor = __enable_if_t<\n+        _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),\n+        bool>;\n+\n+    public:\n+\n+      template<bool _NotEmpty = true,\n+        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>\n+          constexpr\n+          tuple(const _Elements&... __elements)\n+          { }\n+\n+      template<bool _NotEmpty = true,\n+        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>\n+          explicit constexpr\n+          tuple(const _Elements&... __elements)\n+          { }\n+    };\n+}\n+\n+// first example\n+\n+template <typename SessionT>\n+struct SomeQuery {\n+    SessionT& session_;\n+    SomeQuery(SessionT& session) : session_(session) {}\n+};\n+\n+template <typename SessionT>\n+struct Handler {\n+    std::tuple<SomeQuery<SessionT>> queries_;\n+    Handler(SessionT& session) : queries_(session) {}\n+};\n+\n+struct Session {\n+    Handler<Session> handler_;\n+    Session() : handler_{*this} {}\n+};\n+\n+int main() {\n+    Session session;\n+}\n+static_assert(std::is_constructible<SomeQuery<Session>, const SomeQuery<Session>&>::value, \"\");\n+\n+// second example\n+\n+template <typename T>\n+class DependsOnT\n+{\n+public:\n+    DependsOnT(T&) {}\n+};\n+\n+class Test\n+{\n+public:\n+    Test() : test_{*this} {}\n+\n+private:\n+    std::tuple<DependsOnT<Test>> test_;\n+};\n+static_assert(std::is_constructible<DependsOnT<Test>, const DependsOnT<Test>&>::value, \"\");"}]}