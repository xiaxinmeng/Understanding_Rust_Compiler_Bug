{"sha": "60b21d2f58f46c93fc33f6192682abfed62d8dd9", "node_id": "C_kwDOANBUbNoAKDYwYjIxZDJmNThmNDZjOTNmYzMzZjYxOTI2ODJhYmZlZDYyZDhkZDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-10-21T13:05:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-21T13:05:18Z"}, "message": "Merge #1607\n\n1607: Improve AST Fragment class r=CohenArthur a=CohenArthur\n\nThis changes the APIs around creating AST fragments and refactors the class into its own header and source file, hopefully making it easier to use. This will also help creating \"unexpanded\" AST fragments for proper builtin macro expansion with the new fixed-point algorithm introduced by #1606 \r\n\r\n`@liushuyu` pinging you since you've worked extensively with the macro system. Would love your review!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "2f8fd5e728e601f5fa74d71afe1579a5fd3ba440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f8fd5e728e601f5fa74d71afe1579a5fd3ba440"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60b21d2f58f46c93fc33f6192682abfed62d8dd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjUpkOCRBK7hj4Ov3rIwAAcx4IAKnCxr0biPX6gv9YJSNjTUEX\nMO4NVtg7lcaLNwdORJSZoBRX8E9X7E52dxtBwe+45tnWfQYxD2/0dmIc8zZe+bd/\nzsEqc2bUHD5X9RJxzuUANBNo8XwsW0oAMYaIvp+mCe3OQ7niHEPGTSXQ4HQLWGcK\nr5ZoYB2V0z0JZI5mlEbw5M9je3sJxE1KWWTP9pjDh/AHh9auVELzCs+Luy0dj7hb\nP7qQyRcaNiO8Gb3dYmRsr7B8oFHvbj/wwSB9wimP7L8lRlLCxOQw7Csi1MDN5IW/\nIY/VwidD6LZlnvxDcRmOCJEoy4cbBzFMoLR6Bog0Wfnzp8oXD1Cxlerfx7z4qoc=\n=6Xrq\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f8fd5e728e601f5fa74d71afe1579a5fd3ba440\nparent dfb5921b76589c09e7794f5f8010427b93616e9d\nparent 89490980726d298311107a452bdebeb43a2ff7e6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1666357518 +0000\ncommitter GitHub <noreply@github.com> 1666357518 +0000\n\nMerge #1607\n\n1607: Improve AST Fragment class r=CohenArthur a=CohenArthur\n\nThis changes the APIs around creating AST fragments and refactors the class into its own header and source file, hopefully making it easier to use. This will also help creating \"unexpanded\" AST fragments for proper builtin macro expansion with the new fixed-point algorithm introduced by #1606 \r\n\r\n`@liushuyu` pinging you since you've worked extensively with the macro system. Would love your review!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b21d2f58f46c93fc33f6192682abfed62d8dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b21d2f58f46c93fc33f6192682abfed62d8dd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b21d2f58f46c93fc33f6192682abfed62d8dd9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb5921b76589c09e7794f5f8010427b93616e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb5921b76589c09e7794f5f8010427b93616e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb5921b76589c09e7794f5f8010427b93616e9d"}, {"sha": "89490980726d298311107a452bdebeb43a2ff7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89490980726d298311107a452bdebeb43a2ff7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89490980726d298311107a452bdebeb43a2ff7e6"}], "stats": {"total": 625, "additions": 390, "deletions": 235}, "files": [{"sha": "5499e8ca157bce365124389134f8dc2818c7217b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -69,6 +69,7 @@ GRS_OBJS = \\\n     rust/rust-cfg-parser.o \\\n     rust/rust-parse.o \\\n     rust/rust-ast-full-test.o \\\n+    rust/rust-ast-fragment.o \\\n     rust/rust-ast-dump.o \\\n     rust/rust-hir-dump.o \\\n     rust/rust-session-manager.o \\"}, {"sha": "c4916093fc6a7dfc4f1475750a9567e339548f90", "filename": "gcc/rust/ast/rust-ast-fragment.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.cc?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -0,0 +1,171 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-fragment.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+Fragment::Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes)\n+  : kind (kind), nodes (std::move (nodes))\n+{}\n+\n+Fragment::Fragment (Fragment const &other) : kind (other.get_kind ())\n+{\n+  *this = other;\n+}\n+\n+Fragment &\n+Fragment::operator= (Fragment const &other)\n+{\n+  nodes.clear ();\n+  nodes.reserve (other.nodes.size ());\n+  kind = other.get_kind ();\n+  for (auto &n : other.nodes)\n+    {\n+      nodes.push_back (n);\n+    }\n+\n+  return *this;\n+}\n+\n+Fragment\n+Fragment::create_error ()\n+{\n+  return Fragment (FragmentKind::Error, {});\n+}\n+\n+Fragment\n+Fragment::complete (std::vector<AST::SingleASTNode> nodes)\n+{\n+  return Fragment (FragmentKind::Complete, std::move (nodes));\n+}\n+\n+Fragment\n+Fragment::unexpanded ()\n+{\n+  return Fragment (FragmentKind::Unexpanded, {});\n+}\n+\n+std::vector<SingleASTNode> &\n+Fragment::get_nodes ()\n+{\n+  return nodes;\n+}\n+\n+FragmentKind\n+Fragment::get_kind () const\n+{\n+  return kind;\n+}\n+\n+bool\n+Fragment::is_error () const\n+{\n+  return get_kind () == FragmentKind::Error;\n+}\n+\n+bool\n+Fragment::should_expand () const\n+{\n+  return !is_error ();\n+}\n+\n+bool\n+Fragment::is_expression_fragment () const\n+{\n+  return is_single_fragment_of_kind (SingleASTNode::NodeType::EXPRESSION);\n+}\n+\n+bool\n+Fragment::is_type_fragment () const\n+{\n+  return is_single_fragment_of_kind (SingleASTNode::NodeType::TYPE);\n+}\n+\n+std::unique_ptr<Expr>\n+Fragment::take_expression_fragment ()\n+{\n+  assert_single_fragment (SingleASTNode::NodeType::EXPRESSION);\n+  return nodes[0].take_expr ();\n+}\n+\n+std::unique_ptr<Type>\n+Fragment::take_type_fragment ()\n+{\n+  assert_single_fragment (SingleASTNode::NodeType::TYPE);\n+  return nodes[0].take_type ();\n+}\n+\n+void\n+Fragment::accept_vis (ASTVisitor &vis)\n+{\n+  for (auto &node : nodes)\n+    node.accept_vis (vis);\n+}\n+\n+bool\n+Fragment::is_single_fragment () const\n+{\n+  return nodes.size () == 1;\n+}\n+\n+bool\n+Fragment::is_single_fragment_of_kind (SingleASTNode::NodeType expected) const\n+{\n+  return is_single_fragment () && nodes[0].get_kind () == expected;\n+}\n+\n+void\n+Fragment::assert_single_fragment (SingleASTNode::NodeType expected) const\n+{\n+  static const std::map<SingleASTNode::NodeType, const char *> str_map = {\n+    {SingleASTNode::NodeType::IMPL, \"impl\"},\n+    {SingleASTNode::NodeType::ITEM, \"item\"},\n+    {SingleASTNode::NodeType::TYPE, \"type\"},\n+    {SingleASTNode::NodeType::EXPRESSION, \"expr\"},\n+    {SingleASTNode::NodeType::STMT, \"stmt\"},\n+    {SingleASTNode::NodeType::EXTERN, \"extern\"},\n+    {SingleASTNode::NodeType::TRAIT, \"trait\"},\n+    {SingleASTNode::NodeType::TRAIT_IMPL, \"trait impl\"},\n+  };\n+\n+  auto actual = nodes[0].get_kind ();\n+  auto fail = false;\n+\n+  if (!is_single_fragment ())\n+    {\n+      rust_error_at (Location (), \"fragment is not single\");\n+      fail = true;\n+    }\n+\n+  if (actual != expected)\n+    {\n+      rust_error_at (\n+\tLocation (),\n+\t\"invalid fragment operation: expected %qs node, got %qs node\",\n+\tstr_map.find (expected)->second,\n+\tstr_map.find (nodes[0].get_kind ())->second);\n+      fail = true;\n+    }\n+\n+  rust_assert (!fail);\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "3ef4ba16dce67aff3e549eb769078d3cdfd5db33", "filename": "gcc/rust/ast/rust-ast-fragment.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -0,0 +1,118 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_FRAGMENT_H\n+#define RUST_AST_FRAGMENT_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+enum class FragmentKind\n+{\n+  /**\n+   * If an AST Fragment still contains unexpanded tokens - this should only be\n+   * used in the case of builtin macros which need to be expanded eagerly.\n+   */\n+  Unexpanded,\n+  /**\n+   * A completely expanded AST Fragment. This signifies that all\n+   * `SingleASTNode`s in the `nodes` vector are valid.\n+   *\n+   * Note that this doesn't imply that the expansion is \"done\". One of the\n+   * expanded nodes could very well be another macro invocation\n+   */\n+  Complete,\n+  /**\n+   * An error fragment.\n+   */\n+  Error,\n+};\n+\n+/**\n+ * An AST Fragment. Previously named `ASTFragment`.\n+ *\n+ * Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment.\n+ */\n+class Fragment\n+{\n+public:\n+  Fragment (Fragment const &other);\n+  Fragment &operator= (Fragment const &other);\n+\n+  /**\n+   * Create an error fragment\n+   */\n+  static Fragment create_error ();\n+\n+  /**\n+   * Create a complete AST fragment\n+   */\n+  static Fragment complete (std::vector<AST::SingleASTNode> nodes);\n+\n+  /**\n+   * Create a fragment which contains unexpanded nodes\n+   */\n+  static Fragment unexpanded ();\n+\n+  FragmentKind get_kind () const;\n+  std::vector<SingleASTNode> &get_nodes ();\n+\n+  bool is_error () const;\n+  bool should_expand () const;\n+\n+  bool is_expression_fragment () const;\n+  bool is_type_fragment () const;\n+\n+  std::unique_ptr<Expr> take_expression_fragment ();\n+  std::unique_ptr<Type> take_type_fragment ();\n+\n+  void accept_vis (ASTVisitor &vis);\n+\n+private:\n+  Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes);\n+\n+  FragmentKind kind;\n+\n+  /**\n+   * Basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance.\n+   */\n+  std::vector<SingleASTNode> nodes;\n+\n+  /**\n+   * We need to make a special case for Expression and Type fragments as only\n+   * one Node will be extracted from the `nodes` vector\n+   */\n+  bool is_single_fragment () const;\n+  bool is_single_fragment_of_kind (SingleASTNode::NodeType expected) const;\n+  void assert_single_fragment (SingleASTNode::NodeType expected) const;\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // !RUST_AST_FRAGMENT_H"}, {"sha": "e0e10dc0d303da783a86b4db9a0d8244ac312a9f", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -1858,138 +1858,6 @@ class SingleASTNode\n   }\n };\n \n-/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n- * a result of macro expansion. Really annoying to work with due to the fact\n- * that macros can really expand to anything. As such, horrible representation\n- * at the moment. */\n-class ASTFragment\n-{\n-private:\n-  /* basic idea: essentially, a vector of tagged unions of different AST node\n-   * types. Now, this could actually be stored without a tagged union if the\n-   * different AST node types had a unified parent, but that would create\n-   * issues with the diamond problem or significant performance penalties. So\n-   * a tagged union had to be used instead. A vector is used to represent the\n-   * ability for a macro to expand to two statements, for instance. */\n-\n-  std::vector<SingleASTNode> nodes;\n-  bool fragment_is_error;\n-\n-  /**\n-   * We need to make a special case for Expression and Type fragments as only\n-   * one Node will be extracted from the `nodes` vector\n-   */\n-\n-  bool is_single_fragment () const { return nodes.size () == 1; }\n-\n-  bool is_single_fragment_of_kind (SingleASTNode::NodeType expected) const\n-  {\n-    return is_single_fragment () && nodes[0].get_kind () == expected;\n-  }\n-\n-  void assert_single_fragment (SingleASTNode::NodeType expected) const\n-  {\n-    static const std::map<SingleASTNode::NodeType, const char *> str_map = {\n-      {SingleASTNode::NodeType::IMPL, \"impl\"},\n-      {SingleASTNode::NodeType::ITEM, \"item\"},\n-      {SingleASTNode::NodeType::TYPE, \"type\"},\n-      {SingleASTNode::NodeType::EXPRESSION, \"expr\"},\n-      {SingleASTNode::NodeType::STMT, \"stmt\"},\n-      {SingleASTNode::NodeType::EXTERN, \"extern\"},\n-      {SingleASTNode::NodeType::TRAIT, \"trait\"},\n-      {SingleASTNode::NodeType::TRAIT_IMPL, \"trait impl\"},\n-    };\n-\n-    auto actual = nodes[0].get_kind ();\n-    auto fail = false;\n-\n-    if (!is_single_fragment ())\n-      {\n-\trust_error_at (Location (), \"fragment is not single\");\n-\tfail = true;\n-      }\n-\n-    if (actual != expected)\n-      {\n-\trust_error_at (\n-\t  Location (),\n-\t  \"invalid fragment operation: expected %qs node, got %qs node\",\n-\t  str_map.find (expected)->second,\n-\t  str_map.find (nodes[0].get_kind ())->second);\n-\tfail = true;\n-      }\n-\n-    rust_assert (!fail);\n-  }\n-\n-public:\n-  ASTFragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false)\n-    : nodes (std::move (nodes)), fragment_is_error (fragment_is_error)\n-  {\n-    if (fragment_is_error)\n-      rust_assert (nodes.empty ());\n-  }\n-\n-  ASTFragment (ASTFragment const &other)\n-    : fragment_is_error (other.fragment_is_error)\n-  {\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-  }\n-\n-  ASTFragment &operator= (ASTFragment const &other)\n-  {\n-    fragment_is_error = other.fragment_is_error;\n-    nodes.clear ();\n-    nodes.reserve (other.nodes.size ());\n-    for (auto &n : other.nodes)\n-      {\n-\tnodes.push_back (n);\n-      }\n-\n-    return *this;\n-  }\n-\n-  static ASTFragment create_error () { return ASTFragment ({}, true); }\n-\n-  std::vector<SingleASTNode> &get_nodes () { return nodes; }\n-  bool is_error () const { return fragment_is_error; }\n-\n-  bool should_expand () const { return !is_error (); }\n-\n-  bool is_expression_fragment () const\n-  {\n-    return is_single_fragment_of_kind (SingleASTNode::NodeType::EXPRESSION);\n-  }\n-\n-  bool is_type_fragment () const\n-  {\n-    return is_single_fragment_of_kind (SingleASTNode::NodeType::TYPE);\n-  }\n-\n-  std::unique_ptr<Expr> take_expression_fragment ()\n-  {\n-    assert_single_fragment (SingleASTNode::NodeType::EXPRESSION);\n-    return nodes[0].take_expr ();\n-  }\n-\n-  std::unique_ptr<Type> take_type_fragment ()\n-  {\n-    assert_single_fragment (SingleASTNode::NodeType::TYPE);\n-    return nodes[0].take_type ();\n-  }\n-\n-  void accept_vis (ASTVisitor &vis)\n-  {\n-    for (auto &node : nodes)\n-      node.accept_vis (vis);\n-  }\n-};\n-\n // A crate AST object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "a02c216450bf864b06ce65ab1463050b0028efaf", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -20,6 +20,7 @@\n #define RUST_AST_MACRO_H\n \n #include \"rust-ast.h\"\n+#include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n #include <string>\n \n@@ -456,8 +457,7 @@ class MacroRulesDefinition : public MacroItem\n   std::vector<MacroRule> rules; // inlined form\n   Location locus;\n \n-  std::function<ASTFragment (Location, MacroInvocData &)>\n-    associated_transcriber;\n+  std::function<Fragment (Location, MacroInvocData &)> associated_transcriber;\n   // Since we can't compare std::functions, we need to use an extra boolean\n   bool is_builtin_rule;\n \n@@ -468,10 +468,10 @@ class MacroRulesDefinition : public MacroItem\n    * should make use of the actual rules. If the macro is builtin, then another\n    * associated transcriber should be used\n    */\n-  static ASTFragment dummy_builtin (Location, MacroInvocData &)\n+  static Fragment dummy_builtin (Location, MacroInvocData &)\n   {\n     gcc_unreachable ();\n-    return ASTFragment::create_error ();\n+    return Fragment::create_error ();\n   }\n \n   /* NOTE: in rustc, macro definitions are considered (and parsed as) a type\n@@ -491,9 +491,9 @@ class MacroRulesDefinition : public MacroItem\n       associated_transcriber (dummy_builtin), is_builtin_rule (false)\n   {}\n \n-  MacroRulesDefinition (Identifier builtin_name, DelimType delim_type,\n-\t\t\tstd::function<ASTFragment (Location, MacroInvocData &)>\n-\t\t\t  associated_transcriber)\n+  MacroRulesDefinition (\n+    Identifier builtin_name, DelimType delim_type,\n+    std::function<Fragment (Location, MacroInvocData &)> associated_transcriber)\n     : outer_attrs (std::vector<Attribute> ()), rule_name (builtin_name),\n       delim_type (delim_type), rules (std::vector<MacroRule> ()),\n       locus (Location ()), associated_transcriber (associated_transcriber),\n@@ -521,14 +521,14 @@ class MacroRulesDefinition : public MacroItem\n   const std::vector<MacroRule> &get_rules () const { return rules; }\n \n   bool is_builtin () const { return is_builtin_rule; }\n-  const std::function<ASTFragment (Location, MacroInvocData &)> &\n+  const std::function<Fragment (Location, MacroInvocData &)> &\n   get_builtin_transcriber () const\n   {\n     rust_assert (is_builtin ());\n     return associated_transcriber;\n   }\n   void set_builtin_transcriber (\n-    std::function<ASTFragment (Location, MacroInvocData &)> transcriber)\n+    std::function<Fragment (Location, MacroInvocData &)> transcriber)\n   {\n     associated_transcriber = transcriber;\n     is_builtin_rule = true;"}, {"sha": "c2e25dff4cb54502e75490b69c9a54f19725f330", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -56,11 +56,11 @@ class AttrVisitor : public AST::ASTVisitor\n    * @return Either the expanded fragment or an empty errored-out fragment\n    * indicating an expansion failure.\n    */\n-  AST::ASTFragment expand_macro_fragment_recursive ()\n+  AST::Fragment expand_macro_fragment_recursive ()\n   {\n     auto fragment = expander.take_expanded_fragment (*this);\n     unsigned int original_depth = expander.expansion_depth;\n-    auto final_fragment = AST::ASTFragment ({}, true);\n+    auto final_fragment = AST::Fragment::create_error ();\n \n     while (fragment.should_expand ())\n       {"}, {"sha": "14322d0db0a8ca18948c49fcbbcf2adadf8ca31f", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -66,7 +66,7 @@ macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n \n /* Expand and extract an expression from the macro */\n \n-static inline AST::ASTFragment\n+static inline AST::Fragment\n try_expand_macro_expression (AST::Expr *expr, MacroExpander *expander)\n {\n   rust_assert (expander);\n@@ -264,25 +264,25 @@ load_file_bytes (const char *filename)\n }\n } // namespace\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::assert (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   rust_debug (\"assert!() called\");\n \n-  return AST::ASTFragment::create_error ();\n+  return AST::Fragment::create_error ();\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::file (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_file\n     = Session::get_instance ().linemap->location_file (invoc_locus);\n   auto file_str = AST::SingleASTNode (make_string (invoc_locus, current_file));\n \n-  return AST::ASTFragment ({file_str});\n+  return AST::Fragment::complete ({file_str});\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_column\n@@ -292,14 +292,14 @@ MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::LiteralExpr (std::to_string (current_column), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({column_no});\n+  return AST::Fragment::complete ({column_no});\n }\n \n /* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n    of the given file as reference to a byte array. Yields an expression of type\n    &'static [u8; N].  */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -308,7 +308,7 @@ MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -335,14 +335,14 @@ MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n \n   auto node = AST::SingleASTNode (std::move (borrow));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment::complete ({node});\n }\n \n /* Expand builtin macro include_str!(\"filename\"), which includes the contents\n    of the given file as a string. The file must be UTF-8 encoded. Yields an\n    expression of type &'static str.  */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -351,7 +351,7 @@ MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -362,30 +362,30 @@ MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n   std::string str ((const char *) &bytes[0], bytes.size ());\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment::complete ({node});\n }\n \n /* Expand builtin macro compile_error!(\"error\"), which forces a compile error\n    during the compile time. */\n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::compile_error (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto lit_expr\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string error_string = lit_expr->as_string ();\n   rust_error_at (invoc_locus, \"%s\", error_string.c_str ());\n \n-  return AST::ASTFragment::create_error ();\n+  return AST::Fragment::create_error ();\n }\n \n /* Expand builtin macro concat!(), which joins all the literal parameters\n    into a string with no delimiter. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n@@ -427,16 +427,16 @@ MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n   parser.skip_token (last_token_id);\n \n   if (has_error)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment::complete ({node});\n }\n \n /* Expand builtin macro env!(), which inspects an environment variable at\n    compile time. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n@@ -451,19 +451,19 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n   auto expanded_expr = try_expand_many_expr (parser, invoc_locus, last_token_id,\n \t\t\t\t\t     invoc.get_expander (), has_error);\n   if (has_error)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n   if (expanded_expr.size () < 1 || expanded_expr.size () > 2)\n     {\n       rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n   if (expanded_expr.size () > 0)\n     {\n       if (!(lit_expr\n \t    = try_extract_string_literal_from_fragment (invoc_locus,\n \t\t\t\t\t\t\texpanded_expr[0])))\n \t{\n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n     }\n   if (expanded_expr.size () > 1)\n@@ -472,7 +472,7 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n \t    = try_extract_string_literal_from_fragment (invoc_locus,\n \t\t\t\t\t\t\texpanded_expr[1])))\n \t{\n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n     }\n \n@@ -487,14 +487,14 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n \t\t       lit_expr->as_string ().c_str ());\n       else\n \trust_error_at (invoc_locus, \"%s\", error_expr->as_string ().c_str ());\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, env_value));\n-  return AST::ASTFragment ({node});\n+  return AST::Fragment::complete ({node});\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::cfg (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   // only parse if not already parsed\n@@ -519,21 +519,21 @@ MacroBuiltin::cfg (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* TODO: assuming that cfg! macros can only have one meta item inner, like cfg\n    * attributes */\n   if (invoc.get_meta_items ().size () != 1)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   bool result = invoc.get_meta_items ()[0]->check_cfg_predicate (\n     Session::get_instance ());\n   auto literal_exp = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n     new AST::LiteralExpr (result ? \"true\" : \"false\", AST::Literal::BOOL,\n \t\t\t  PrimitiveCoreType::CORETYPE_BOOL, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({literal_exp});\n+  return AST::Fragment::complete ({literal_exp});\n }\n \n /* Expand builtin macro include!(), which includes a source file at the current\n  scope compile time. */\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   /* Get target filename from the macro invocation, which is treated as a path\n@@ -542,7 +542,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n-    return AST::ASTFragment::create_error ();\n+    return AST::Fragment::create_error ();\n \n   std::string filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n@@ -556,7 +556,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     {\n       rust_error_at (lit_expr->get_locus (),\n \t\t     \"cannot open included file %qs: %m\", target_filename);\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   rust_debug (\"Attempting to parse included file %s\", target_filename);\n@@ -574,7 +574,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n     {\n       // inform the user that the errors above are from a included file\n       rust_inform (invoc_locus, \"included from here\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   std::vector<AST::SingleASTNode> nodes{};\n@@ -584,10 +584,10 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n       nodes.push_back (node);\n     }\n \n-  return AST::ASTFragment (nodes);\n+  return AST::Fragment::complete (nodes);\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroBuiltin::line (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto current_line\n@@ -597,7 +597,7 @@ MacroBuiltin::line (Location invoc_locus, AST::MacroInvocData &invoc)\n     new AST::LiteralExpr (std::to_string (current_line), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n \n-  return AST::ASTFragment ({line_no});\n+  return AST::Fragment::complete ({line_no});\n }\n \n } // namespace Rust"}, {"sha": "79305e466507ee5cd94fc401440646867c5cf86d", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -20,6 +20,7 @@\n #define RUST_MACRO_BUILTINS_H\n \n #include \"rust-ast.h\"\n+#include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n \n /**\n@@ -61,6 +62,7 @@\n \n /* If assert is defined as a macro this file will not parse, so undefine this\n    before continuing.  */\n+// TODO: Rename all functions here `*_handler`\n #ifdef assert\n #undef assert\n #endif\n@@ -69,38 +71,34 @@ namespace Rust {\n class MacroBuiltin\n {\n public:\n-  static AST::ASTFragment assert (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n-\n-  static AST::ASTFragment file (Location invoc_locus,\n-\t\t\t\tAST::MacroInvocData &invoc);\n+  static AST::Fragment assert (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment column (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n+  static AST::Fragment file (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include_bytes (Location invoc_locus,\n-\t\t\t\t\t AST::MacroInvocData &invoc);\n+  static AST::Fragment column (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include_str (Location invoc_locus,\n-\t\t\t\t       AST::MacroInvocData &invoc);\n+  static AST::Fragment include_bytes (Location invoc_locus,\n+\t\t\t\t      AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment compile_error (Location invoc_locus,\n-\t\t\t\t\t AST::MacroInvocData &invoc);\n+  static AST::Fragment include_str (Location invoc_locus,\n+\t\t\t\t    AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment concat (Location invoc_locus,\n-\t\t\t\t  AST::MacroInvocData &invoc);\n+  static AST::Fragment compile_error (Location invoc_locus,\n+\t\t\t\t      AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment env (Location invoc_locus,\n+  static AST::Fragment concat (Location invoc_locus,\n \t\t\t       AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment cfg (Location invoc_locus,\n-\t\t\t       AST::MacroInvocData &invoc);\n+  static AST::Fragment env (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment include (Location invoc_locus,\n-\t\t\t\t   AST::MacroInvocData &invoc);\n+  static AST::Fragment cfg (Location invoc_locus, AST::MacroInvocData &invoc);\n \n-  static AST::ASTFragment line (Location invoc_locus,\n+  static AST::Fragment include (Location invoc_locus,\n \t\t\t\tAST::MacroInvocData &invoc);\n+\n+  static AST::Fragment line (Location invoc_locus, AST::MacroInvocData &invoc);\n };\n } // namespace Rust\n "}, {"sha": "589443453d6aef3962dbf9559a0a563cc458224b", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -26,7 +26,7 @@\n #include \"rust-early-name-resolver.h\"\n \n namespace Rust {\n-AST::ASTFragment\n+AST::Fragment\n MacroExpander::expand_decl_macro (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc,\n \t\t\t\t  AST::MacroRulesDefinition &rules_def,\n@@ -103,7 +103,7 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n       RichLocation r (invoc_locus);\n       r.add_range (rules_def.get_locus ());\n       rust_error_at (r, \"Failed to match any rule within macro\");\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n@@ -139,7 +139,7 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n   //      - else is unreachable\n   //  - derive container macro - unreachable\n \n-  auto fragment = AST::ASTFragment::create_error ();\n+  auto fragment = AST::Fragment::create_error ();\n   invoc_data.set_expander (this);\n \n   // lookup the rules\n@@ -707,7 +707,7 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n /**\n  * Helper function to refactor calling a parsing function 0 or more times\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t    std::function<AST::SingleASTNode ()> parse_fn)\n {\n@@ -723,13 +723,13 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t  for (auto err : parser.get_errors ())\n \t    err.emit_error ();\n \n-\t  return AST::ASTFragment::create_error ();\n+\t  return AST::Fragment::create_error ();\n \t}\n \n       nodes.emplace_back (std::move (node));\n     }\n \n-  return AST::ASTFragment (std::move (nodes));\n+  return AST::Fragment::complete (std::move (nodes));\n }\n \n /**\n@@ -738,7 +738,7 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -753,7 +753,7 @@ transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -768,7 +768,7 @@ transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n \t\t\t     TokenId &delimiter)\n {\n@@ -784,7 +784,7 @@ transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   return parse_many (parser, delimiter, [&parser] () {\n@@ -799,7 +799,7 @@ transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  * @param parser Parser to extract items from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n \t\t\t\t  TokenId &delimiter)\n {\n@@ -815,7 +815,7 @@ transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n  * @param parser Parser to extract statements from\n  * @param delimiter Id of the token on which parsing should stop\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n   auto restrictions = ParseRestrictions ();\n@@ -835,30 +835,30 @@ transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n  *\n  * @param parser Parser to extract statements from\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_expression (Parser<MacroInvocLexer> &parser)\n {\n   auto expr = parser.parse_expr ();\n \n-  return AST::ASTFragment ({std::move (expr)});\n+  return AST::Fragment::complete ({std::move (expr)});\n }\n \n /**\n  * Transcribe one type from a macro invocation\n  *\n  * @param parser Parser to extract statements from\n  */\n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_type (Parser<MacroInvocLexer> &parser)\n {\n   auto type = parser.parse_type (true);\n   for (auto err : parser.get_errors ())\n     err.emit_error ();\n \n-  return AST::ASTFragment ({std::move (type)});\n+  return AST::Fragment::complete ({std::move (type)});\n }\n \n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n \t\t\t AST::DelimType delimiter, TokenId last_token_id)\n {\n@@ -868,7 +868,7 @@ transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n     return transcribe_expression (parser);\n } // namespace Rust\n \n-static AST::ASTFragment\n+static AST::Fragment\n transcribe_context (MacroExpander::ContextType ctx,\n \t\t    Parser<MacroInvocLexer> &parser, bool semicolon,\n \t\t    AST::DelimType delimiter, TokenId last_token_id)\n@@ -929,7 +929,7 @@ tokens_to_str (std::vector<std::unique_ptr<AST::Token>> &tokens)\n   return str;\n }\n \n-AST::ASTFragment\n+AST::Fragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n   std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n@@ -951,7 +951,7 @@ MacroExpander::transcribe_rule (\n   rust_debug (\"substituted tokens: %s\",\n \t      tokens_to_str (substituted_tokens).c_str ());\n \n-  // parse it to an ASTFragment\n+  // parse it to an Fragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n   Parser<MacroInvocLexer> parser (lex);\n \n@@ -994,7 +994,7 @@ MacroExpander::transcribe_rule (\n     {\n       for (auto &err : parser.get_errors ())\n \trust_error_at (err.locus, \"%s\", err.message.c_str ());\n-      return AST::ASTFragment::create_error ();\n+      return AST::Fragment::create_error ();\n     }\n \n   // are all the tokens used?"}, {"sha": "6253a4ee00042204ee3ec2085fccc8937ffb5a5e", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -230,7 +230,7 @@ struct MacroExpander\n   MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n     : cfg (cfg), crate (crate), session (session),\n       sub_stack (SubstitutionScope ()),\n-      expanded_fragment (AST::ASTFragment::create_error ()),\n+      expanded_fragment (AST::Fragment::create_error ()),\n       resolver (Resolver::Resolver::get ()),\n       mappings (Analysis::Mappings::get ())\n   {}\n@@ -246,10 +246,9 @@ struct MacroExpander\n   void expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon);\n \n   // Expands a single declarative macro.\n-  AST::ASTFragment expand_decl_macro (Location locus,\n-\t\t\t\t      AST::MacroInvocData &invoc,\n-\t\t\t\t      AST::MacroRulesDefinition &rules_def,\n-\t\t\t\t      bool semicolon);\n+  AST::Fragment expand_decl_macro (Location locus, AST::MacroInvocData &invoc,\n+\t\t\t\t   AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t   bool semicolon);\n \n   void expand_cfg_attrs (AST::AttrVec &attrs);\n   bool fails_cfg (const AST::AttrVec &attr) const;\n@@ -260,7 +259,7 @@ struct MacroExpander\n   bool try_match_rule (AST::MacroRule &match_rule,\n \t\t       AST::DelimTokenTree &invoc_token_tree);\n \n-  AST::ASTFragment transcribe_rule (\n+  AST::Fragment transcribe_rule (\n     AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n     std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n     bool semicolon, ContextType ctx);\n@@ -314,16 +313,16 @@ struct MacroExpander\n \n   ContextType peek_context () { return context.back (); }\n \n-  void set_expanded_fragment (AST::ASTFragment &&fragment)\n+  void set_expanded_fragment (AST::Fragment &&fragment)\n   {\n     expanded_fragment = std::move (fragment);\n   }\n \n-  AST::ASTFragment take_expanded_fragment (AST::ASTVisitor &vis)\n+  AST::Fragment take_expanded_fragment (AST::ASTVisitor &vis)\n   {\n-    AST::ASTFragment old_fragment = std::move (expanded_fragment);\n+    AST::Fragment old_fragment = std::move (expanded_fragment);\n     auto accumulator = std::vector<AST::SingleASTNode> ();\n-    expanded_fragment = AST::ASTFragment::create_error ();\n+    expanded_fragment = AST::Fragment::create_error ();\n     auto early_name_resolver = Resolver::EarlyNameResolver ();\n \n     for (auto &node : old_fragment.get_nodes ())\n@@ -345,7 +344,7 @@ struct MacroExpander\n \t    auto new_nodes = expanded_fragment.get_nodes ();\n \t    std::move (new_nodes.begin (), new_nodes.end (),\n \t\t       std::back_inserter (accumulator));\n-\t    expanded_fragment = AST::ASTFragment (accumulator);\n+\t    expanded_fragment = AST::Fragment::complete (accumulator);\n \t  }\n \texpansion_depth--;\n       }\n@@ -358,7 +357,7 @@ struct MacroExpander\n   Session &session;\n   SubstitutionScope sub_stack;\n   std::vector<ContextType> context;\n-  AST::ASTFragment expanded_fragment;\n+  AST::Fragment expanded_fragment;\n \n public:\n   Resolver::Resolver *resolver;"}, {"sha": "a3073c019713c28055ac89a8e7c9fdb568cdde61", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60b21d2f58f46c93fc33f6192682abfed62d8dd9/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=60b21d2f58f46c93fc33f6192682abfed62d8dd9", "patch": "@@ -840,8 +840,8 @@ Mappings::iterate_trait_items (\n void\n Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n {\n-  static std::map<std::string, std::function<AST::ASTFragment (\n-\t\t\t\t Location, AST::MacroInvocData &)>>\n+  static std::map<\n+    std::string, std::function<AST::Fragment (Location, AST::MacroInvocData &)>>\n     builtin_macros = {\n       {\"assert\", MacroBuiltin::assert},\n       {\"file\", MacroBuiltin::file},"}]}