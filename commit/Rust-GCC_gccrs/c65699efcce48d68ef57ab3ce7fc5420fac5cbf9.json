{"sha": "c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY1Njk5ZWZjY2U0OGQ2OGVmNTdhYjNjZTdmYzU0MjBmYWM1Y2JmOQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2016-08-19T17:43:26Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2016-08-19T17:43:26Z"}, "message": "Implement C _FloatN, _FloatNx types.\n\nISO/IEC TS 18661-3:2015 defines C bindings to IEEE interchange and\nextended types, in the form of _FloatN and _FloatNx type names with\ncorresponding fN/FN and fNx/FNx constant suffixes and FLTN_* / FLTNX_*\n<float.h> macros.  This patch implements support for this feature in\nGCC.\n\nThe _FloatN types, for N = 16, 32, 64 or >= 128 and a multiple of 32,\nare types encoded according to the corresponding IEEE interchange\nformat (endianness unspecified; may use either the NaN conventions\nrecommended in IEEE 754-2008, or the MIPS NaN conventions, since the\nchoice of convention is only an IEEE recommendation, not a\nrequirement).  The _FloatNx types, for N = 32, 64 and 128, are IEEE\n\"extended\" types: types extending a narrower format with range and\nprecision at least as big as those specified in IEEE 754 for each\nextended type (and with unspecified representation, but still\nfollowing IEEE semantics for their values and operations - and with\nthe set of values being determined by the precision and the maximum\nexponent, which means that while Intel \"extended\" is suitable for\n_Float64x, m68k \"extended\" is not).  These types are always distinct\nfrom and not compatible with each other and the standard floating\ntypes float, double, long double; thus, double, _Float64 and _Float32x\nmay all have the same ABI, but they are three still distinct types.\nThe type names may be used with _Complex to construct corresponding\ncomplex types (unlike __float128, which acts more like a typedef name\nthan a keyword - thus, this patch may be considered to fix PR\nc/32187).  The new suffixes can be combined with GNU \"i\" and \"j\"\nsuffixes for constants of complex types (e.g. 1.0if128, 2.0f64i).\n\nThe set of types supported is implementation-defined.  In this GCC\npatch, _Float32 is SFmode if that is suitable; _Float32x and _Float64\nare DFmode if that is suitable; _Float128 is TFmode if that is\nsuitable; _Float64x is XFmode if that is suitable, and otherwise\nTFmode if that is suitable.  There is a target hook to override the\nchoices if necessary.  \"Suitable\" means both conforming to the\nrequirements of that type, and supported as a scalar type including in\nlibgcc.  The ABI is whatever the back end does for scalars of that\nmode (but note that _Float32 is passed without promotion in variable\narguments, unlike float).  All the existing issues with exceptions and\nrounding modes for existing types apply equally to the new type names.\n\nNo GCC port supports a floating-point format suitable for _Float128x.\nAlthough there is HFmode support for ARM and AArch64, use of that for\n_Float16 is not enabled.  Supporting _Float16 would require additional\nwork on the excess precision aspects of TS 18661-3: there are new\nvalues of FLT_EVAL_METHOD, which are not currently supported in GCC,\nand FLT_EVAL_METHOD == 0 now means that operations and constants on\ntypes narrower than float are evaluated to the range and precision of\nfloat.  Implementing that, so that _Float16 gets evaluated with excess\nrange and precision, would involve changes to the excess precision\ninfrastructure so that the _Float16 case is enabled by default, unlike\nthe x87 case which is only enabled for -fexcess-precision=standard.\nOther differences between _Float16 and __fp16 would also need to be\ndisentangled.\n\nGCC has some prior support for nonstandard floating-point types in the\nform of __float80 and __float128.  Where these were previously types\ndistinct from long double, they are made by this patch into aliases\nfor _Float64x / _Float128 if those types have the required properties.\n\nIn principle the set of possible _FloatN types is infinite.  This\npatch hardcodes the four such types for N <= 128, but with as much\ncode as possible using loops over types to minimize the number of\nplaces with such hardcoding.  I don't think it's likely any further\nsuch types will be of use in future (or indeed that formats suitable\nfor _Float128x will actually be implemented).  There is a corner case\nthat all _FloatN, for N >= 128 and a multiple of 32, should be treated\nas keywords even when the corresponding type is not supported; I\nintend to deal with that in a followup patch.\n\nTests are added for various functionality of the new types, mostly\nusing type-generic headers.  The tests use dg-add-options to pass any\nextra options needed to enable the types; this is wired up to use the\nsame options as for __float128 on powerpc to enable _Float128 and\n_Float64x, and effective-target keywords for runtime support do the\nsame hardware test as for __float128 to make sure the VSX instructions\ngenerated by those options are supported.  (Corresponding additions\nwould be needed for _Float16 on ARM as well if that were enabled with\n-mfp16-format=ieee required to use it rather than unconditionally\navailable.  Of course, -mfp16-format=alternative enables use of a\nformat which is not compatible with the requirements of the _Float16\ntype.)\n\nC++ note: no support for the new types or constant suffixes is added\nfor C++.  C++ decimal floating-point support was very different from\nthe C support, using class types, and the same may well apply to any\nfuture C++ bindings for IEEE interchange and extended types.  There is\na case, however, for supporting at least *f128 constants in C++, so\nthat code using __float128 can use the newer style for constants\nthroughout rather than needing to use the older *q constants in C++.\nAlso, if built-in functions are added that may provide a way in which\nthe types could leak into C++ code.\n\nFortran note: the float128_type_node used in the Fortran front end is\nrenamed to gfc_float128_type_node, since the semantics are different:\nin particular, if long double has binary128 format, then the new\nlanguage-independent float128_type_node is a distinct type that also\nhas binary128 format, but the Fortran node is expected to be NULL in\nthat case.  Likewise, Fortran's complex_float128_type_node is renamed\nto gfc_complex_float128_type_node.\n\nPowerPC note: the back end had an inconsistency that if TFmode was\nbinary128, *q constants were TFmode instead of KFmode but __float128\nwas KFmode.  This patch follows the same logic as for *q constants, so\nthat _Float128 prefers TFmode (and __float128 becomes an alias for\n_Float128).\n\nARM note: __fp16 is promoted to double (by convert_arguments) when\npassed without a prototype / in variable arguments.  But this is only\nabout the argument promotion; it is not handled as promoting in\nc-common.c:self_promoting_args_p / c-typeck.c:c_type_promotes_to,\nmeaning that a K&R function definition for an argument of type __fp16\ncorresponds to a prototype with an argument of that type, not to one\nwith an argument of type double, whereas a float argument in a K&R\nfunction definition corresponds to a double prototype argument - and\nthe same functions are also what's involved in making va_arg give a\nwarning and generate a call to abort when called with type float.\nThis is preserved by this patch, while arranging for _Float16 not to\nbe promoted when passed without a prototype / in variable arguments\n(the promotion of float being considered a legacy feature, not applied\nto any new types in C99 or later).\n\nTS 18661-3 extends the set of decimal floating-point types similarly,\nand adds new constant suffixes for the existing types, but this patch\ndoes not do anything regarding that extension.\n\nThis patch does nothing regarding built-in functions, although\ntype-generic functions such as __builtin_isinf work for the new types\nand associated tests are included.  There are at least two levels of\nbuilt-in function support possible for these types.  The minimal\nlevel, implemented in\n<https://gcc.gnu.org/ml/gcc-patches/2016-06/msg01702.html> (which\nneeds updating to use dg-add-options), adds built-in functions similar\nto those x86 has for __float128: __builtin_inf* __builtin_huge_val*,\n__builtin_nan*, __builtin_nans*, __builtin_fabs*, __builtin_copysign*.\nThat would be sufficient for glibc to use the *f128 names for built-in\nfunctions by default with *q used only for backwards compatibility\nwhen using older GCC versions.  That would also allow c_cpp_builtins's\nflag_building_libgcc code, defining __LIBGCC_%s_FUNC_EXT__, to use\nsuch suffixes rather than the present code hardcoding logic about\ntarget-specific constant suffixes and how those relate to function\nsuffixes.\n\nFull built-in function support would cover the full range of built-in\nfunctions for existing floating-point types, adding variants for all\nthe new types, except for a few obsolescent functions and\nnon-type-generic variants of type-generic functions.  Some but not all\nreferences to such functions in GCC use macros such as CASE_FLT_FN to\nbe type-generic; a fair amount of work would be needed to identify all\nplaces to update.  Adding all those functions would enable\noptimizations (for constant arguments and otherwise) for TS 18661-3\nfunctions, but it would also substantially expand the enum listing\nbuilt-in functions (and we've had problems with the size of that enum\nin the past), and increase the amount of built-in function\ninitialization to do - I don't know what the startup cost involved in\nbuilt-in function initialization is, but it would be something to\nconsider when adding such a large set of functions.\n\nThere are also a range of optimizations, in match.pd and elsewhere,\nthat only operate on the three standard floating-point types.  Ideally\nthose would be made generic to all floating-point types, but this\npatch does nothing in that regard.  Special care would be needed\nregarding making sure library functions to which calls are generated\nactually exist.  For example, if sqrt is called on an argument of type\n_Float32, and the result converted to _Float32, this is equivalent to\ndoing a square root operation directly on _Float32.  But if the user's\nlibm does not have the sqrtf32 function, or the name is not reserved\nbecause __STDC_WANT_IEC_60559_TYPES_EXT__ was not defined before\nincluding <math.h>, you can only do that optimization if you convert\nto a call to sqrtf instead.\n\nDECIMAL_DIG now relates to all supported floating-point formats, not\njust float, double and long double; I've raised the question with WG14\nof how this relates to the formula for DECIMAL_DIG in C11 not\nconsidering this.  TS 18661-3 says it also covers non-arithmetic\nformats only supported by library conversion functions; this patch\ndoes not add any target hooks to allow for the case where there are\nsuch formats wider than any supported for arithmetic types (where\ne.g. libc supports conversions involving the binary128 representation,\nbut the _Float128 type is not supported).\n\nGCC provides its own <tgmath.h> for some targets.  No attempt is made\nto adapt this to handle the new types.\n\nNothing is done regarding debug info for the new types (see the\n\"Debugger support for __float128 type?\" thread on gcc@, Sep/Oct 2015).\n\nNo __SIZEOF_*__ macros are added for the new types.\n\nNothing is done with do_warn_double_promotion.\n\nNothing is done to include the new types in those determining\nmax_align_t, although properly it should be sufficiently aligned for\nany of those types.\n\nThe logic for usual arithmetic conversions in c_common_type relies on\nTYPE_PRECISION for floating-point types, which is less than ideal\n(doesn't necessarily correspond to whether one type's values are\nsubset of another); looking in more detail at the formats might be\nbetter.  But since I included code in build_common_tree_nodes to work\naround rs6000 KFmode having precision 113 not 128, I think it should\nwork.  Ideally one might have errors in generic code for the case\nwhere the two types do not have one type's values a subset of the\nother (which is undefined behavior).  But the only case where this can\nactually occur is mixing IBM long double with binary128 on powerpc,\nand rs6000_invalid_binary_op deals with that at present.  TS 18661-3\ndoes not fully specify the type resulting from the usual arithmetic\nconversions in the case where two _FloatNx types have the same set of\nvalues; I arranged the code to prefer the greater value of N in that\ncase.\n\nThe __FP_FAST_FMA* macros are not extended to cover the new types,\nsince there are no corresponding built-in functions (if built-in\nfmafN, fmafNx are added, the macros should be extended, and the new\nmacros documented).  Also, only a limited set of modes is handled in\nmode_has_fma.\n\nDiagnostics relating to the use of the new types with -pedantic do not\ntry to distinguish them from purely nonstandard types such as __int128\nand constant suffixes such as *q.\n\nIf you use an unsupported _FloatN / _FloatNx type you get a warning\nabout the type defaulting to int after the warning about the type not\nbeing supported.  That's less than ideal, but it's also a pre-existing\ncondition if you use __int128 on a 32-bit system where it's\nunsupported.\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.  Other\nback-end changes minimally tested by building cc1 for ia64-linux-gnu,\npowerpc64le-linux-gnu, pdp11-none (the last failed for unrelated\nreasons).\n\n\tPR c/32187\ngcc:\n\t* tree-core.h (TI_COMPLEX_FLOAT16_TYPE)\n\t(TI_COMPLEX_FLOATN_NX_TYPE_FIRST, TI_COMPLEX_FLOAT32_TYPE)\n\t(TI_COMPLEX_FLOAT64_TYPE, TI_COMPLEX_FLOAT128_TYPE)\n\t(TI_COMPLEX_FLOAT32X_TYPE, TI_COMPLEX_FLOAT64X_TYPE)\n\t(TI_COMPLEX_FLOAT128X_TYPE, TI_FLOAT16_TYPE, TI_FLOATN_TYPE_FIRST)\n\t(TI_FLOATN_NX_TYPE_FIRST, TI_FLOAT32_TYPE, TI_FLOAT64_TYPE)\n\t(TI_FLOAT128_TYPE, TI_FLOATN_TYPE_LAST, TI_FLOAT32X_TYPE)\n\t(TI_FLOATNX_TYPE_FIRST, TI_FLOAT64X_TYPE, TI_FLOAT128X_TYPE)\n\t(TI_FLOATNX_TYPE_LAST, TI_FLOATN_NX_TYPE_LAST): New enum\n\ttree_index values.\n\t(NUM_FLOATN_TYPES, NUM_FLOATNX_TYPES, NUM_FLOATN_NX_TYPES): New\n\tmacros.\n\t(struct floatn_type_info): New structure type.\n\t(floatn_nx_types): New variable declaration.\n\t* tree.h (FLOATN_TYPE_NODE, FLOATN_NX_TYPE_NODE)\n\t(FLOATNX_TYPE_NODE, float128_type_node, float64x_type_node)\n\t(COMPLEX_FLOATN_NX_TYPE_NODE): New macros.\n\t* tree.c (floatn_nx_types): New variable.\n\t(build_common_tree_nodes): Initialize _FloatN, _FloatNx and\n\tcorresponding complex types.\n\t* target.def (floatn_mode): New hook.\n\t* targhooks.c: Include \"real.h\".\n\t(default_floatn_mode): New function.\n\t* targhooks.h (default_floatn_mode): New prototype.\n\t* doc/extend.texi (Floating Types): Document _FloatN and _FloatNx\n\ttypes.\n\t* doc/sourcebuild.texi (float@var{n}, float@var{n}x): Document new\n\teffective-target and dg-add-options keywords.\n\t(float@var{n}_runtime, float@var{n}x_runtime, floatn_nx_runtime):\n\tDocument new effective-target keywords.\n\t* doc/tm.texi.in (TARGET_FLOATN_MODE): New @hook.\n\t* doc/tm.texi: Regenerate.\n\t* ginclude/float.h (LDBL_DECIMAL_DIG): Define to\n\t__LDBL_DECIMAL_DIG__, not __DECIMAL_DIG__.\n\t[__STDC_WANT_IEC_60559_TYPES_EXT__]: Define macros from TS\n\t18661-3.\n\t* real.h (struct real_format): Add field ieee_bits.\n\t* real.c (ieee_single_format, mips_single_format)\n\t(motorola_single_format, spu_single_format, ieee_double_format)\n\t(mips_double_format, motorola_double_format)\n\t(ieee_extended_motorola_format, ieee_extended_intel_96_format)\n\t(ieee_extended_intel_128_format)\n\t(ieee_extended_intel_96_round_53_format, ibm_extended_format)\n\t(mips_extended_format, ieee_quad_format, mips_quad_format)\n\t(vax_f_format, vax_d_format, vax_g_format, decimal_single_format)\n\t(decimal_double_format, decimal_quad_format, ieee_half_format)\n\t(arm_half_format, real_internal_format: Initialize ieee_bits\n\tfield.\n\t* config/i386/i386.c (ix86_init_builtin_types): Do not initialize\n\tfloat128_type_node.  Set float80_type_node to float64x_type_node\n\tif appropriate and long_double_type_node not appropriate.\n\t* config/ia64/ia64.c (ia64_init_builtins): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_f_format, pdp11_d_format):\n\tInitialize ieee_bits field.\n\t* config/rs6000/rs6000.c (TARGET_FLOATN_MODE): New macro.\n\t(rs6000_init_builtins): Set ieee128_float_type_node to\n\tfloat128_type_node.\n\t(rs6000_floatn_mode): New function.\n\ngcc/c:\n\t* c-tree.h (cts_floatn_nx): New enum c_typespec_keyword value.\n\t(struct c_declspecs): Add field floatn_nx_idx.\n\t* c-decl.c (declspecs_add_type, finish_declspecs): Handle _FloatN\n\tand _FloatNx type specifiers.\n\t* c-parser.c (c_keyword_starts_typename, c_token_starts_declspecs)\n\t(c_parser_declspecs, c_parser_attribute_any_word)\n\t(c_parser_objc_selector): Use CASE_RID_FLOATN_NX.\n\t* c-typeck.c (c_common_type): Handle _FloatN and _FloatNx types.\n\t(convert_arguments): Avoid promoting _FloatN and _FloatNx types\n\tnarrower than double.\n\ngcc/c-family:\n\t* c-common.h (RID_FLOAT16, RID_FLOATN_NX_FIRST, RID_FLOAT32)\n\t(RID_FLOAT64, RID_FLOAT128, RID_FLOAT32X, RID_FLOAT64X)\n\t(RID_FLOAT128X): New enum rid values.\n\t(CASE_RID_FLOATN_NX): New macro.\n\t* c-common.c (c_common_reswords): Add _FloatN and _FloatNx\n\tkeywords.\n\t(c_common_type_for_mode): Check for _FloatN and _FloatNx and\n\tcorresponding complex types.\n\t(c_common_nodes_and_builtins): For non-C++, register _FloatN and\n\t_FloatNx and corresponding complex types.\n\t(keyword_begins_type_specifier): Use CASE_RID_FLOATN_NX.\n\t* c-cppbuiltin.c (builtin_define_float_constants): Check _FloatN\n\tand _FloatNx types for the widest type for determining\n\tDECIMAL_DIG.  Define __LDBL_DECIMAL_DIG__ as well as\n\t__DECIMAL_DIG__ for long double.  Handle FMA_SUFFIX being NULL.\n\t(c_cpp_builtins): Call builtin_define_float_constants for _FloatN\n\tand _FloatNx types.\n\t* c-lex.c (interpret_float): Handle _FloatN and _FloatNx\n\tconstants.\n\t* c-pretty-print.c (pp_c_floating_constant): Handle _FloatN and\n\t_FloatNx types.\n\ngcc/fortran:\n\t* trans-types.h (float128_type_node): Rename to\n\tgfc_float128_type_node.\n\t(complex_float128_type_node): Rename to\n\tgfc_complex_float128_type_node.\n\t* iso-c-binding.def, trans-intrinsic.c, trans-types.c: All users\n\tchanged.\n\ngcc/testsuite:\n\t* lib/target-supports.exp (check_effective_target_float16)\n\t(check_effective_target_float32, check_effective_target_float64)\n\t(check_effective_target_float128, check_effective_target_float32x)\n\t(check_effective_target_float64x)\n\t(check_effective_target_float128x)\n\t(check_effective_target_float16_runtime)\n\t(check_effective_target_float32_runtime)\n\t(check_effective_target_float64_runtime)\n\t(check_effective_target_float128_runtime)\n\t(check_effective_target_float32x_runtime)\n\t(check_effective_target_float64x_runtime)\n\t(check_effective_target_float128x_runtime)\n\t(check_effective_target_floatn_nx_runtime)\n\t(add_options_for_float16, add_options_for_float32)\n\t(add_options_for_float64, add_options_for_float128)\n\t(add_options_for_float32x, add_options_for_float64x)\n\t(add_options_for_float128x): New procedures.\n\t* gcc.dg/dfp/floatn.c, gcc.dg/float128-typeof.c,\n\tgcc.dg/float128x-typeof.c, gcc.dg/float16-typeof.c,\n\tgcc.dg/float32-typeof.c, gcc.dg/float32x-typeof.c,\n\tgcc.dg/float64-typeof.c, gcc.dg/float64x-typeof.c,\n\tgcc.dg/floatn-arithconv.c, gcc.dg/floatn-errs.c,\n\tgcc.dg/floatn-typeof.h, gcc.dg/torture/float128-basic.c,\n\tgcc.dg/torture/float128-complex.c,\n\tgcc.dg/torture/float128-floath.c, gcc.dg/torture/float128-tg.c,\n\tgcc.dg/torture/float128x-basic.c,\n\tgcc.dg/torture/float128x-complex.c,\n\tgcc.dg/torture/float128x-floath.c, gcc.dg/torture/float128x-tg.c,\n\tgcc.dg/torture/float16-basic.c, gcc.dg/torture/float16-complex.c,\n\tgcc.dg/torture/float16-floath.c, gcc.dg/torture/float16-tg.c,\n\tgcc.dg/torture/float32-basic.c, gcc.dg/torture/float32-complex.c,\n\tgcc.dg/torture/float32-floath.c, gcc.dg/torture/float32-tg.c,\n\tgcc.dg/torture/float32x-basic.c,\n\tgcc.dg/torture/float32x-complex.c,\n\tgcc.dg/torture/float32x-floath.c, gcc.dg/torture/float32x-tg.c,\n\tgcc.dg/torture/float64-basic.c, gcc.dg/torture/float64-complex.c,\n\tgcc.dg/torture/float64-floath.c, gcc.dg/torture/float64-tg.c,\n\tgcc.dg/torture/float64x-basic.c,\n\tgcc.dg/torture/float64x-complex.c,\n\tgcc.dg/torture/float64x-floath.c, gcc.dg/torture/float64x-tg.c,\n\tgcc.dg/torture/floatn-basic.h, gcc.dg/torture/floatn-complex.h,\n\tgcc.dg/torture/floatn-convert.c, gcc.dg/torture/floatn-floath.h,\n\tgcc.dg/torture/floatn-tg.h,\n\tgcc.dg/torture/fp-int-convert-float128-ieee-timode.c,\n\tgcc.dg/torture/fp-int-convert-float128-ieee.c,\n\tgcc.dg/torture/fp-int-convert-float128x-timode.c,\n\tgcc.dg/torture/fp-int-convert-float128x.c,\n\tgcc.dg/torture/fp-int-convert-float16-timode.c,\n\tgcc.dg/torture/fp-int-convert-float16.c,\n\tgcc.dg/torture/fp-int-convert-float32-timode.c,\n\tgcc.dg/torture/fp-int-convert-float32.c,\n\tgcc.dg/torture/fp-int-convert-float32x-timode.c,\n\tgcc.dg/torture/fp-int-convert-float32x.c,\n\tgcc.dg/torture/fp-int-convert-float64-timode.c,\n\tgcc.dg/torture/fp-int-convert-float64.c,\n\tgcc.dg/torture/fp-int-convert-float64x-timode.c,\n\tgcc.dg/torture/fp-int-convert-float64x.c: New tests.\n\t* gcc.dg/torture/fp-int-convert.h (TEST_I_F): Add argument for\n\tmaximum exponent of floating-point type.  Use it in testing\n\twhether 0x8...0 fits in the floating-point type.  Always treat -1\n\t(signed 0xf...f) as fitting in the floating-point type.\n\t(M_OK1): New macro.\n\t* gcc.dg/torture/fp-int-convert-double.c,\n\tgcc.dg/torture/fp-int-convert-float.c,\n\tgcc.dg/torture/fp-int-convert-float128-timode.c,\n\tgcc.dg/torture/fp-int-convert-float128.c,\n\tgcc.dg/torture/fp-int-convert-float80-timode.c,\n\tgcc.dg/torture/fp-int-convert-float80.c,\n\tgcc.dg/torture/fp-int-convert-long-double.c,\n\tgcc.dg/torture/fp-int-convert-timode.c: Update calls to TEST_I_F.\n\nlibcpp:\n\t* include/cpplib.h (CPP_N_FLOATN, CPP_N_FLOATNX)\n\t(CPP_N_WIDTH_FLOATN_NX, CPP_FLOATN_SHIFT, CPP_FLOATN_MAX): New\n\tmacros.\n\t* expr.c (interpret_float_suffix): Handle fN, fNx, FN and FNx\n\tsuffixes.\n\nFrom-SVN: r239625", "tree": {"sha": "faa648423e355c925c007b2939a27316e2af3d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faa648423e355c925c007b2939a27316e2af3d9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c54f8ea2d79dad967720b67fbeb720566b8b79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c54f8ea2d79dad967720b67fbeb720566b8b79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c54f8ea2d79dad967720b67fbeb720566b8b79"}], "stats": {"total": 3058, "additions": 2932, "deletions": 126}, "files": [{"sha": "3e03050ede4f7e029ca744c3ab796a4fc4aea0ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,65 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* tree-core.h (TI_COMPLEX_FLOAT16_TYPE)\n+\t(TI_COMPLEX_FLOATN_NX_TYPE_FIRST, TI_COMPLEX_FLOAT32_TYPE)\n+\t(TI_COMPLEX_FLOAT64_TYPE, TI_COMPLEX_FLOAT128_TYPE)\n+\t(TI_COMPLEX_FLOAT32X_TYPE, TI_COMPLEX_FLOAT64X_TYPE)\n+\t(TI_COMPLEX_FLOAT128X_TYPE, TI_FLOAT16_TYPE, TI_FLOATN_TYPE_FIRST)\n+\t(TI_FLOATN_NX_TYPE_FIRST, TI_FLOAT32_TYPE, TI_FLOAT64_TYPE)\n+\t(TI_FLOAT128_TYPE, TI_FLOATN_TYPE_LAST, TI_FLOAT32X_TYPE)\n+\t(TI_FLOATNX_TYPE_FIRST, TI_FLOAT64X_TYPE, TI_FLOAT128X_TYPE)\n+\t(TI_FLOATNX_TYPE_LAST, TI_FLOATN_NX_TYPE_LAST): New enum\n+\ttree_index values.\n+\t(NUM_FLOATN_TYPES, NUM_FLOATNX_TYPES, NUM_FLOATN_NX_TYPES): New\n+\tmacros.\n+\t(struct floatn_type_info): New structure type.\n+\t(floatn_nx_types): New variable declaration.\n+\t* tree.h (FLOATN_TYPE_NODE, FLOATN_NX_TYPE_NODE)\n+\t(FLOATNX_TYPE_NODE, float128_type_node, float64x_type_node)\n+\t(COMPLEX_FLOATN_NX_TYPE_NODE): New macros.\n+\t* tree.c (floatn_nx_types): New variable.\n+\t(build_common_tree_nodes): Initialize _FloatN, _FloatNx and\n+\tcorresponding complex types.\n+\t* target.def (floatn_mode): New hook.\n+\t* targhooks.c: Include \"real.h\".\n+\t(default_floatn_mode): New function.\n+\t* targhooks.h (default_floatn_mode): New prototype.\n+\t* doc/extend.texi (Floating Types): Document _FloatN and _FloatNx\n+\ttypes.\n+\t* doc/sourcebuild.texi (float@var{n}, float@var{n}x): Document new\n+\teffective-target and dg-add-options keywords.\n+\t(float@var{n}_runtime, float@var{n}x_runtime, floatn_nx_runtime):\n+\tDocument new effective-target keywords.\n+\t* doc/tm.texi.in (TARGET_FLOATN_MODE): New @hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* ginclude/float.h (LDBL_DECIMAL_DIG): Define to\n+\t__LDBL_DECIMAL_DIG__, not __DECIMAL_DIG__.\n+\t[__STDC_WANT_IEC_60559_TYPES_EXT__]: Define macros from TS\n+\t18661-3.\n+\t* real.h (struct real_format): Add field ieee_bits.\n+\t* real.c (ieee_single_format, mips_single_format)\n+\t(motorola_single_format, spu_single_format, ieee_double_format)\n+\t(mips_double_format, motorola_double_format)\n+\t(ieee_extended_motorola_format, ieee_extended_intel_96_format)\n+\t(ieee_extended_intel_128_format)\n+\t(ieee_extended_intel_96_round_53_format, ibm_extended_format)\n+\t(mips_extended_format, ieee_quad_format, mips_quad_format)\n+\t(vax_f_format, vax_d_format, vax_g_format, decimal_single_format)\n+\t(decimal_double_format, decimal_quad_format, ieee_half_format)\n+\t(arm_half_format, real_internal_format: Initialize ieee_bits\n+\tfield.\n+\t* config/i386/i386.c (ix86_init_builtin_types): Do not initialize\n+\tfloat128_type_node.  Set float80_type_node to float64x_type_node\n+\tif appropriate and long_double_type_node not appropriate.\n+\t* config/ia64/ia64.c (ia64_init_builtins): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_f_format, pdp11_d_format):\n+\tInitialize ieee_bits field.\n+\t* config/rs6000/rs6000.c (TARGET_FLOATN_MODE): New macro.\n+\t(rs6000_init_builtins): Set ieee128_float_type_node to\n+\tfloat128_type_node.\n+\t(rs6000_floatn_mode): New function.\n+\n 2016-08-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/rdseedintrin.h (_rdseed16_step, _rdseed32_step,"}, {"sha": "bec37cffd7597ce787dd1ec7c3cf7fcef250c1bc", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,28 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* c-common.h (RID_FLOAT16, RID_FLOATN_NX_FIRST, RID_FLOAT32)\n+\t(RID_FLOAT64, RID_FLOAT128, RID_FLOAT32X, RID_FLOAT64X)\n+\t(RID_FLOAT128X): New enum rid values.\n+\t(CASE_RID_FLOATN_NX): New macro.\n+\t* c-common.c (c_common_reswords): Add _FloatN and _FloatNx\n+\tkeywords.\n+\t(c_common_type_for_mode): Check for _FloatN and _FloatNx and\n+\tcorresponding complex types.\n+\t(c_common_nodes_and_builtins): For non-C++, register _FloatN and\n+\t_FloatNx and corresponding complex types.\n+\t(keyword_begins_type_specifier): Use CASE_RID_FLOATN_NX.\n+\t* c-cppbuiltin.c (builtin_define_float_constants): Check _FloatN\n+\tand _FloatNx types for the widest type for determining\n+\tDECIMAL_DIG.  Define __LDBL_DECIMAL_DIG__ as well as\n+\t__DECIMAL_DIG__ for long double.  Handle FMA_SUFFIX being NULL.\n+\t(c_cpp_builtins): Call builtin_define_float_constants for _FloatN\n+\tand _FloatNx types.\n+\t* c-lex.c (interpret_float): Handle _FloatN and _FloatNx\n+\tconstants.\n+\t* c-pretty-print.c (pp_c_floating_constant): Handle _FloatN and\n+\t_FloatNx types.\n+\n 2016-08-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-opts.c (c_diagnostic_finalizer): Update for change to"}, {"sha": "32468ca1351ba31592c729f9fae0347c3410b5ae", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -434,6 +434,13 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Cilk_sync\",       RID_CILK_SYNC,  0 },\n   { \"_Cilk_for\",        RID_CILK_FOR,   0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n+  { \"_Float16\",         RID_FLOAT16,   D_CONLY },\n+  { \"_Float32\",         RID_FLOAT32,   D_CONLY },\n+  { \"_Float64\",         RID_FLOAT64,   D_CONLY },\n+  { \"_Float128\",        RID_FLOAT128,  D_CONLY },\n+  { \"_Float32x\",        RID_FLOAT32X,  D_CONLY },\n+  { \"_Float64x\",        RID_FLOAT64X,  D_CONLY },\n+  { \"_Float128x\",       RID_FLOAT128X, D_CONLY },\n   { \"_Decimal32\",       RID_DFLOAT32,  D_CONLY | D_EXT },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_CONLY | D_EXT },\n   { \"_Decimal128\",      RID_DFLOAT128, D_CONLY | D_EXT },\n@@ -3478,6 +3485,11 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (long_double_type_node))\n     return long_double_type_node;\n \n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE\n+\t&& mode == TYPE_MODE (FLOATN_NX_TYPE_NODE (i)))\n+      return FLOATN_NX_TYPE_NODE (i);\n+\n   if (mode == TYPE_MODE (void_type_node))\n     return void_type_node;\n \n@@ -3503,6 +3515,11 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n       if (mode == TYPE_MODE (complex_long_double_type_node))\n \treturn complex_long_double_type_node;\n \n+      for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+\tif (COMPLEX_FLOATN_NX_TYPE_NODE (i) != NULL_TREE\n+\t    && mode == TYPE_MODE (COMPLEX_FLOATN_NX_TYPE_NODE (i)))\n+\t  return COMPLEX_FLOATN_NX_TYPE_NODE (i);\n+\n       if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n \treturn complex_integer_type_node;\n \n@@ -5406,6 +5423,12 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n+  if (!c_dialect_cxx ())\n+    for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+      if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE)\n+\trecord_builtin_type ((enum rid) (RID_FLOATN_NX_FIRST + i), NULL,\n+\t\t\t     FLOATN_NX_TYPE_NODE (i));\n+\n   /* Only supported decimal floating point extension if the target\n      actually supports underlying modes. */\n   if (targetm.scalar_mode_supported_p (SDmode)\n@@ -5495,6 +5518,20 @@ c_common_nodes_and_builtins (void)\n \t\t TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t complex_long_double_type_node));\n \n+  if (!c_dialect_cxx ())\n+    for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+      if (COMPLEX_FLOATN_NX_TYPE_NODE (i) != NULL_TREE)\n+\t{\n+\t  char buf[30];\n+\t  sprintf (buf, \"complex _Float%d%s\", floatn_nx_types[i].n,\n+\t\t   floatn_nx_types[i].extended ? \"x\" : \"\");\n+\t  lang_hooks.decls.pushdecl\n+\t    (build_decl (UNKNOWN_LOCATION,\n+\t\t\t TYPE_DECL,\n+\t\t\t get_identifier (buf),\n+\t\t\t COMPLEX_FLOATN_NX_TYPE_NODE (i)));\n+\t}\n+\n   if (c_dialect_cxx ())\n     /* For C++, make fileptr_type_node a distinct void * type until\n        FILE type is defined.  */\n@@ -12523,6 +12560,7 @@ keyword_begins_type_specifier (enum rid keyword)\n     case RID_LONG:\n     case RID_SHORT:\n     case RID_SIGNED:\n+    CASE_RID_FLOATN_NX:\n     case RID_DFLOAT32:\n     case RID_DFLOAT64:\n     case RID_DFLOAT128:"}, {"sha": "bc22baa26b8bb26559d7d9131c3d66c281a9432f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -102,6 +102,20 @@ enum rid\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n+\n+  /* TS 18661-3 keywords, in the same sequence as the TI_* values.  */\n+  RID_FLOAT16,\n+  RID_FLOATN_NX_FIRST = RID_FLOAT16,\n+  RID_FLOAT32,\n+  RID_FLOAT64,\n+  RID_FLOAT128,\n+  RID_FLOAT32X,\n+  RID_FLOAT64X,\n+  RID_FLOAT128X,\n+#define CASE_RID_FLOATN_NX\t\t\t\t\t\t\\\n+  case RID_FLOAT16: case RID_FLOAT32: case RID_FLOAT64: case RID_FLOAT128: \\\n+  case RID_FLOAT32X: case RID_FLOAT64X: case RID_FLOAT128X\n+\n   RID_FRACT, RID_ACCUM, RID_AUTO_TYPE, RID_BUILTIN_CALL_WITH_STATIC_CHAIN,\n \n   /* C11 */"}, {"sha": "1f7d013239f291fea65229e6b0c6d8e8f5e5b3c7", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -125,7 +125,7 @@ builtin_define_float_constants (const char *name_prefix,\n   const double log10_2 = .30102999566398119521;\n   double log10_b;\n   const struct real_format *fmt;\n-  const struct real_format *ldfmt;\n+  const struct real_format *widefmt;\n \n   char name[64], buf[128];\n   int dig, min_10_exp, max_10_exp;\n@@ -134,8 +134,20 @@ builtin_define_float_constants (const char *name_prefix,\n \n   fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n   gcc_assert (fmt->b != 10);\n-  ldfmt = REAL_MODE_FORMAT (TYPE_MODE (long_double_type_node));\n-  gcc_assert (ldfmt->b != 10);\n+  widefmt = REAL_MODE_FORMAT (TYPE_MODE (long_double_type_node));\n+  gcc_assert (widefmt->b != 10);\n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n+      tree wtype = FLOATN_NX_TYPE_NODE (i);\n+      if (wtype != NULL_TREE)\n+\t{\n+\t  const struct real_format *wfmt\n+\t    = REAL_MODE_FORMAT (TYPE_MODE (wtype));\n+\t  gcc_assert (wfmt->b != 10);\n+\t  if (wfmt->p > widefmt->p)\n+\t    widefmt = wfmt;\n+\t}\n+    }\n \n   /* The radix of the exponent representation.  */\n   if (type == float_type_node)\n@@ -219,7 +231,7 @@ builtin_define_float_constants (const char *name_prefix,\n      floating type, but we want this value for rendering constants below.  */\n   {\n     double d_decimal_dig\n-      = 1 + (fmt->p < ldfmt->p ? ldfmt->p : fmt->p) * log10_b;\n+      = 1 + (fmt->p < widefmt->p ? widefmt->p : fmt->p) * log10_b;\n     decimal_dig = d_decimal_dig;\n     if (decimal_dig < d_decimal_dig)\n       decimal_dig++;\n@@ -231,13 +243,13 @@ builtin_define_float_constants (const char *name_prefix,\n     if (type_decimal_dig < type_d_decimal_dig)\n       type_decimal_dig++;\n   }\n+  /* Arbitrarily, define __DECIMAL_DIG__ when defining macros for long\n+     double, although it may be greater than the value for long\n+     double.  */\n   if (type == long_double_type_node)\n     builtin_define_with_int_value (\"__DECIMAL_DIG__\", decimal_dig);\n-  else\n-    {\n-      sprintf (name, \"__%s_DECIMAL_DIG__\", name_prefix);\n-      builtin_define_with_int_value (name, type_decimal_dig);\n-    }\n+  sprintf (name, \"__%s_DECIMAL_DIG__\", name_prefix);\n+  builtin_define_with_int_value (name, type_decimal_dig);\n \n   /* Since, for the supported formats, B is always a power of 2, we\n      construct the following numbers directly as a hexadecimal\n@@ -289,7 +301,7 @@ builtin_define_float_constants (const char *name_prefix,\n   builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n \n   /* Note whether we have fast FMA.  */\n-  if (mode_has_fma (TYPE_MODE (type)))\n+  if (mode_has_fma (TYPE_MODE (type)) && fma_suffix != NULL)\n     {\n       sprintf (name, \"__FP_FAST_FMA%s\", fma_suffix);\n       builtin_define_with_int_value (name, 1);\n@@ -984,6 +996,19 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_float_constants (\"LDBL\", \"L\", \"%s\", \"L\",\n \t\t\t\t  long_double_type_node);\n \n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n+      if (FLOATN_NX_TYPE_NODE (i) == NULL_TREE)\n+\tcontinue;\n+      char prefix[20], csuffix[20];\n+      sprintf (prefix, \"FLT%d%s\", floatn_nx_types[i].n,\n+\t       floatn_nx_types[i].extended ? \"X\" : \"\");\n+      sprintf (csuffix, \"F%d%s\", floatn_nx_types[i].n,\n+\t       floatn_nx_types[i].extended ? \"x\" : \"\");\n+      builtin_define_float_constants (prefix, csuffix, \"%s\", NULL,\n+\t\t\t\t      FLOATN_NX_TYPE_NODE (i));\n+    }\n+\n   /* For decfloat.h.  */\n   builtin_define_decimal_float_constants (\"DEC32\", \"DF\", dfloat32_type_node);\n   builtin_define_decimal_float_constants (\"DEC64\", \"DD\", dfloat64_type_node);"}, {"sha": "829c18b26a4c4935c8b947dfb32bdc7664f66414", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -840,6 +840,26 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \ttype = c_common_type_for_mode (mode, 0);\n \tgcc_assert (type);\n       }\n+    else if ((flags & (CPP_N_FLOATN | CPP_N_FLOATNX)) != 0)\n+      {\n+\tunsigned int n = (flags & CPP_N_WIDTH_FLOATN_NX) >> CPP_FLOATN_SHIFT;\n+\tbool extended = (flags & CPP_N_FLOATNX) != 0;\n+\ttype = NULL_TREE;\n+\tfor (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+\t  if (floatn_nx_types[i].n == (int) n\n+\t      && floatn_nx_types[i].extended == extended)\n+\t    {\n+\t      type = FLOATN_NX_TYPE_NODE (i);\n+\t      break;\n+\t    }\n+\tif (type == NULL_TREE)\n+\t  {\n+\t    error (\"unsupported non-standard suffix on floating constant\");\n+\t    return error_mark_node;\n+\t  }\n+\telse\n+\t  pedwarn (input_location, OPT_Wpedantic, \"non-standard suffix on floating constant\");\n+      }\n     else if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n     else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL\n@@ -868,6 +888,17 @@ interpret_float (const cpp_token *token, unsigned int flags,\n       if (flags & CPP_N_IMAGINARY)\n \t/* I or J suffix.  */\n \tcopylen--;\n+      if (flags & CPP_N_FLOATNX)\n+\tcopylen--;\n+      if (flags & (CPP_N_FLOATN | CPP_N_FLOATNX))\n+\t{\n+\t  unsigned int n = (flags & CPP_N_WIDTH_FLOATN_NX) >> CPP_FLOATN_SHIFT;\n+\t  while (n > 0)\n+\t    {\n+\t      copylen--;\n+\t      n /= 10;\n+\t    }\n+\t}\n     }\n \n   copy = (char *) alloca (copylen + 1);"}, {"sha": "90428cac183814dd5fedf06479ce18cafa5d6fa9", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1045,6 +1045,16 @@ pp_c_floating_constant (c_pretty_printer *pp, tree r)\n     pp_string (pp, \"dd\");\n   else if (TREE_TYPE (r) == dfloat32_type_node)\n     pp_string (pp, \"df\");\n+  else if (TREE_TYPE (r) != double_type_node)\n+    for (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+      if (TREE_TYPE (r) == FLOATN_NX_TYPE_NODE (i))\n+\t{\n+\t  pp_character (pp, 'f');\n+\t  pp_decimal_int (pp, floatn_nx_types[i].n);\n+\t  if (floatn_nx_types[i].extended)\n+\t    pp_character (pp, 'x');\n+\t  break;\n+\t}\n }\n \n /* Print out a FIXED value as a decimal-floating-constant.  */"}, {"sha": "8d9d4aabb0a6af00b88e84ec81a2fd2cc6f78b7e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,17 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* c-tree.h (cts_floatn_nx): New enum c_typespec_keyword value.\n+\t(struct c_declspecs): Add field floatn_nx_idx.\n+\t* c-decl.c (declspecs_add_type, finish_declspecs): Handle _FloatN\n+\tand _FloatNx type specifiers.\n+\t* c-parser.c (c_keyword_starts_typename, c_token_starts_declspecs)\n+\t(c_parser_declspecs, c_parser_attribute_any_word)\n+\t(c_parser_objc_selector): Use CASE_RID_FLOATN_NX.\n+\t* c-typeck.c (c_common_type): Handle _FloatN and _FloatNx types.\n+\t(convert_arguments): Avoid promoting _FloatN and _FloatNx types\n+\tnarrower than double.\n+\n 2016-08-12  Jakub Jelinek  <jakub@redhat.com>\n \t    Martin Liska  <mliska@suse.cz>\n "}, {"sha": "0fb2d206458cb221eb7cacdcfeb1dfcf93a3e90d", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 113, "deletions": 2, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9804,6 +9804,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<float%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_floatn_nx)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<_Decimal32%> in \"\n@@ -9857,6 +9865,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<short%> and %<double%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_floatn_nx)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n                 error_at (loc,\n \t\t\t  (\"both %<short%> and %<_Decimal32%> in \"\n@@ -9901,6 +9917,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<signed%> and %<double%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_floatn_nx)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n \t      else if (specs->typespec_word == cts_dfloat32)\n \t\terror_at (loc,\n \t\t\t  (\"both %<signed%> and %<_Decimal32%> in \"\n@@ -9945,6 +9969,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<unsigned%> and %<double%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_floatn_nx)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n               else if (specs->typespec_word == cts_dfloat32)\n \t\terror_at (loc,\n \t\t\t  (\"both %<unsigned%> and %<_Decimal32%> in \"\n@@ -10049,6 +10081,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<_Sat%> and %<double%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_floatn_nx)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n               else if (specs->typespec_word == cts_dfloat32)\n \t\terror_at (loc,\n \t\t\t  (\"both %<_Sat%> and %<_Decimal32%> in \"\n@@ -10082,8 +10122,9 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t}\n       else\n \t{\n-\t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\", \"double\", \"_Decimal32\",\n-\t     \"__intN\", \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\" or\n+\t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\", \"double\",\n+\t     \"_FloatN\", \"_FloatNx\", \"_Decimal32\", \"__intN\",\n+\t     \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\" or\n \t     \"__auto_type\".  */\n \t  if (specs->typespec_word != cts_none)\n \t    {\n@@ -10308,6 +10349,69 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t  specs->locations[cdw_typespec] = loc;\n \t\t}\n \t      return specs;\n+\t    CASE_RID_FLOATN_NX:\n+\t      specs->floatn_nx_idx = i - RID_FLOATN_NX_FIRST;\n+\t      if (!in_system_header_at (input_location))\n+\t\tpedwarn (loc, OPT_Wpedantic,\n+\t\t\t \"ISO C does not support the %<_Float%d%s%> type\",\n+\t\t\t floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t  ? \"x\"\n+\t\t\t  : \"\"));\n+\n+\t      if (specs->long_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else if (specs->short_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else if (specs->signed_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else if (specs->unsigned_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else if (specs->saturating_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<_Float%d%s%> in \"\n+\t\t\t   \"declaration specifiers\"),\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else if (FLOATN_NX_TYPE_NODE (specs->floatn_nx_idx) == NULL_TREE)\n+\t\terror_at (loc,\n+\t\t\t  \"%<_Float%d%s%> is not supported on this target\",\n+\t\t\t  floatn_nx_types[specs->floatn_nx_idx].n,\n+\t\t\t  (floatn_nx_types[specs->floatn_nx_idx].extended\n+\t\t\t   ? \"x\"\n+\t\t\t   : \"\"));\n+\t      else\n+\t\t{\n+\t\t  specs->typespec_word = cts_floatn_nx;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n+\t      return specs;\n \t    case RID_DFLOAT32:\n \t    case RID_DFLOAT64:\n \t    case RID_DFLOAT128:\n@@ -10785,6 +10889,13 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t\t : double_type_node);\n \t}\n       break;\n+    case cts_floatn_nx:\n+      gcc_assert (!specs->long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p);\n+      specs->type = (specs->complex_p\n+\t\t     ? COMPLEX_FLOATN_NX_TYPE_NODE (specs->floatn_nx_idx)\n+\t\t     : FLOATN_NX_TYPE_NODE (specs->floatn_nx_idx));\n+      break;\n     case cts_dfloat32:\n     case cts_dfloat64:\n     case cts_dfloat128:"}, {"sha": "fe0c95f3b1bdedd6e69eedcc8b7a3ed84e145408", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -540,6 +540,7 @@ c_keyword_starts_typename (enum rid keyword)\n     case RID_DFLOAT32:\n     case RID_DFLOAT64:\n     case RID_DFLOAT128:\n+    CASE_RID_FLOATN_NX:\n     case RID_BOOL:\n     case RID_ENUM:\n     case RID_STRUCT:\n@@ -727,6 +728,7 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_DFLOAT32:\n \tcase RID_DFLOAT64:\n \tcase RID_DFLOAT128:\n+\tCASE_RID_FLOATN_NX:\n \tcase RID_BOOL:\n \tcase RID_ENUM:\n \tcase RID_STRUCT:\n@@ -2536,6 +2538,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_DFLOAT32:\n \tcase RID_DFLOAT64:\n \tcase RID_DFLOAT128:\n+\tCASE_RID_FLOATN_NX:\n \tcase RID_BOOL:\n \tcase RID_FRACT:\n \tcase RID_ACCUM:\n@@ -4009,6 +4012,7 @@ c_parser_attribute_any_word (c_parser *parser)\n \tcase RID_DFLOAT32:\n \tcase RID_DFLOAT64:\n \tcase RID_DFLOAT128:\n+\tCASE_RID_FLOATN_NX:\n \tcase RID_BOOL:\n \tcase RID_FRACT:\n \tcase RID_ACCUM:\n@@ -9638,6 +9642,7 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_CHAR:\n     case RID_FLOAT:\n     case RID_DOUBLE:\n+    CASE_RID_FLOATN_NX:\n     case RID_VOID:\n     case RID_BOOL:\n     case RID_ATOMIC:"}, {"sha": "5a8ab6df48381d14a8d53f092b8fe657a6aac9de", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -230,6 +230,7 @@ enum c_typespec_keyword {\n   cts_dfloat32,\n   cts_dfloat64,\n   cts_dfloat128,\n+  cts_floatn_nx,\n   cts_fract,\n   cts_accum,\n   cts_auto_type\n@@ -295,6 +296,9 @@ struct c_declspecs {\n   int align_log;\n   /* For the __intN declspec, this stores the index into the int_n_* arrays.  */\n   int int_n_idx;\n+  /* For the _FloatN and _FloatNx declspec, this stores the index into\n+     the floatn_nx_types array.  */\n+  int floatn_nx_idx;\n   /* The storage class specifier, or csc_none if none.  */\n   enum c_storage_class storage_class;\n   /* Any type specifier keyword used such as \"int\", not reflecting"}, {"sha": "bc8728a49b661b9f62e0f7f9340b83134d6a0ddb", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -927,18 +927,41 @@ c_common_type (tree t1, tree t2)\n \treturn long_integer_type_node;\n     }\n \n+  /* For floating types of the same TYPE_PRECISION (which we here\n+     assume means either the same set of values, or sets of values\n+     neither a subset of the other, with behavior being undefined in\n+     the latter case), follow the rules from TS 18661-3: prefer\n+     interchange types _FloatN, then standard types long double,\n+     double, float, then extended types _FloatNx.  For extended types,\n+     check them starting with _Float128x as that seems most consistent\n+     in spirit with preferring long double to double; for interchange\n+     types, also check in that order for consistency although it's not\n+     possible for more than one of them to have the same\n+     precision.  */\n+  tree mv1 = TYPE_MAIN_VARIANT (t1);\n+  tree mv2 = TYPE_MAIN_VARIANT (t2);\n+\n+  for (int i = NUM_FLOATN_TYPES - 1; i >= 0; i--)\n+    if (mv1 == FLOATN_TYPE_NODE (i) || mv2 == FLOATN_TYPE_NODE (i))\n+      return FLOATN_TYPE_NODE (i);\n+\n   /* Likewise, prefer long double to double even if same size.  */\n-  if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n-      || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n+  if (mv1 == long_double_type_node || mv2 == long_double_type_node)\n     return long_double_type_node;\n \n   /* Likewise, prefer double to float even if same size.\n      We got a couple of embedded targets with 32 bit doubles, and the\n      pdp11 might have 64 bit floats.  */\n-  if (TYPE_MAIN_VARIANT (t1) == double_type_node\n-      || TYPE_MAIN_VARIANT (t2) == double_type_node)\n+  if (mv1 == double_type_node || mv2 == double_type_node)\n     return double_type_node;\n \n+  if (mv1 == float_type_node || mv2 == float_type_node)\n+    return float_type_node;\n+\n+  for (int i = NUM_FLOATNX_TYPES - 1; i >= 0; i--)\n+    if (mv1 == FLOATNX_TYPE_NODE (i) || mv2 == FLOATNX_TYPE_NODE (i))\n+      return FLOATNX_TYPE_NODE (i);\n+\n   /* Otherwise prefer the unsigned one.  */\n \n   if (TYPE_UNSIGNED (t1))\n@@ -3284,6 +3307,30 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \n       val = require_complete_type (ploc, val);\n \n+      /* Some floating-point arguments must be promoted to double when\n+\t no type is specified by a prototype.  This applies to\n+\t arguments of type float, and to architecture-specific types\n+\t (ARM __fp16), but not to _FloatN or _FloatNx types.  */\n+      bool promote_float_arg = false;\n+      if (type == NULL_TREE\n+\t  && TREE_CODE (valtype) == REAL_TYPE\n+\t  && (TYPE_PRECISION (valtype)\n+\t      <= TYPE_PRECISION (double_type_node))\n+\t  && TYPE_MAIN_VARIANT (valtype) != double_type_node\n+\t  && TYPE_MAIN_VARIANT (valtype) != long_double_type_node\n+\t  && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (valtype)))\n+\t{\n+\t  /* Promote this argument, unless it has a _FloatN or\n+\t     _FloatNx type.  */\n+\t  promote_float_arg = true;\n+\t  for (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+\t    if (TYPE_MAIN_VARIANT (valtype) == FLOATN_NX_TYPE_NODE (i))\n+\t      {\n+\t\tpromote_float_arg = false;\n+\t\tbreak;\n+\t      }\n+\t}\n+\n       if (type != 0)\n \t{\n \t  /* Formal parm type is specified by a function prototype.  */\n@@ -3450,12 +3497,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\tparmval = default_conversion (parmval);\n \t    }\n \t}\n-      else if (TREE_CODE (valtype) == REAL_TYPE\n-\t       && (TYPE_PRECISION (valtype)\n-\t\t   <= TYPE_PRECISION (double_type_node))\n-\t       && TYPE_MAIN_VARIANT (valtype) != double_type_node\n-\t       && TYPE_MAIN_VARIANT (valtype) != long_double_type_node\n-\t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (valtype)))\n+      else if (promote_float_arg)\n         {\n \t  if (type_generic)\n \t    parmval = val;"}, {"sha": "39794230c10cf8b66d4c4bd5549b2c5d5280062c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -33325,24 +33325,29 @@ ix86_init_builtins_va_builtins_abi (void)\n static void\n ix86_init_builtin_types (void)\n {\n-  tree float128_type_node, float80_type_node, const_string_type_node;\n+  tree float80_type_node, const_string_type_node;\n \n   /* The __float80 type.  */\n   float80_type_node = long_double_type_node;\n   if (TYPE_MODE (float80_type_node) != XFmode)\n     {\n-      /* The __float80 type.  */\n-      float80_type_node = make_node (REAL_TYPE);\n+      if (float64x_type_node != NULL_TREE\n+\t  && TYPE_MODE (float64x_type_node) == XFmode)\n+\tfloat80_type_node = float64x_type_node;\n+      else\n+\t{\n+\t  /* The __float80 type.  */\n+\t  float80_type_node = make_node (REAL_TYPE);\n \n-      TYPE_PRECISION (float80_type_node) = 80;\n-      layout_type (float80_type_node);\n+\t  TYPE_PRECISION (float80_type_node) = 80;\n+\t  layout_type (float80_type_node);\n+\t}\n     }\n   lang_hooks.types.register_builtin_type (float80_type_node, \"__float80\");\n \n-  /* The __float128 type.  */\n-  float128_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float128_type_node) = 128;\n-  layout_type (float128_type_node);\n+  /* The __float128 type.  The node has already been created as\n+     _Float128, so we only need to register the __float128 name for\n+     it.  */\n   lang_hooks.types.register_builtin_type (float128_type_node, \"__float128\");\n \n   const_string_type_node"}, {"sha": "ebd2c86b8d8f917248453070105b1fb5178bc7a3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -10350,9 +10350,15 @@ ia64_init_builtins (void)\n   (*lang_hooks.types.register_builtin_type) (fpreg_type, \"__fpreg\");\n \n   /* The __float80 type.  */\n-  float80_type = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float80_type) = 80;\n-  layout_type (float80_type);\n+  if (float64x_type_node != NULL_TREE\n+      && TYPE_MODE (float64x_type_node) == XFmode)\n+    float80_type = float64x_type_node;\n+  else\n+    {\n+      float80_type = make_node (REAL_TYPE);\n+      TYPE_PRECISION (float80_type) = 80;\n+      layout_type (float80_type);\n+    }\n   (*lang_hooks.types.register_builtin_type) (float80_type, \"__float80\");\n \n   /* The __float128 type.  */\n@@ -10362,14 +10368,12 @@ ia64_init_builtins (void)\n       tree const_string_type\n \t= build_pointer_type (build_qualified_type\n \t\t\t      (char_type_node, TYPE_QUAL_CONST));\n-      tree float128_type = make_node (REAL_TYPE);\n \n-      TYPE_PRECISION (float128_type) = 128;\n-      layout_type (float128_type);\n-      (*lang_hooks.types.register_builtin_type) (float128_type, \"__float128\");\n+      (*lang_hooks.types.register_builtin_type) (float128_type_node,\n+\t\t\t\t\t\t \"__float128\");\n \n       /* TFmode support builtins.  */\n-      ftype = build_function_type_list (float128_type, NULL_TREE);\n+      ftype = build_function_type_list (float128_type_node, NULL_TREE);\n       decl = add_builtin_function (\"__builtin_infq\", ftype,\n \t\t\t\t   IA64_BUILTIN_INFQ, BUILT_IN_MD,\n \t\t\t\t   NULL, NULL_TREE);\n@@ -10380,7 +10384,7 @@ ia64_init_builtins (void)\n \t\t\t\t   NULL, NULL_TREE);\n       ia64_builtins[IA64_BUILTIN_HUGE_VALQ] = decl;\n \n-      ftype = build_function_type_list (float128_type,\n+      ftype = build_function_type_list (float128_type_node,\n \t\t\t\t\tconst_string_type,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_nanq\", ftype,\n@@ -10395,18 +10399,18 @@ ia64_init_builtins (void)\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_NANSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type,\n-\t\t\t\t\tfloat128_type,\n+      ftype = build_function_type_list (float128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_fabsq\", ftype,\n \t\t\t\t   IA64_BUILTIN_FABSQ, BUILT_IN_MD,\n \t\t\t\t   \"__fabstf2\", NULL_TREE);\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_FABSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type,\n-\t\t\t\t\tfloat128_type,\n-\t\t\t\t\tfloat128_type,\n+      ftype = build_function_type_list (float128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_copysignq\", ftype,\n \t\t\t\t   IA64_BUILTIN_COPYSIGNQ, BUILT_IN_MD,"}, {"sha": "35d57c724889f6582e752f1a7634273f1e8cf3cf", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -69,6 +69,7 @@ const struct real_format pdp11_f_format =\n     127,\n     15,\n     15,\n+    0,\n     false,\n     false,\n     false,\n@@ -91,6 +92,7 @@ const struct real_format pdp11_d_format =\n     127,\n     15,\n     15,\n+    0,\n     false,\n     false,\n     false,"}, {"sha": "b232099b9e7d536b266e77fc5d8d7fc970869086", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1703,6 +1703,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P rs6000_vector_mode_supported_p\n \n+#undef TARGET_FLOATN_MODE\n+#define TARGET_FLOATN_MODE rs6000_floatn_mode\n+\n #undef TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n #define TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN invalid_arg_for_unprototyped_fn\n \n@@ -16303,10 +16306,7 @@ rs6000_init_builtins (void)\n       layout_type (ibm128_float_type_node);\n       SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n \n-      ieee128_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (ieee128_float_type_node) = 128;\n-      layout_type (ieee128_float_type_node);\n-      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n+      ieee128_float_type_node = float128_type_node;\n \n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__float128\");\n@@ -36199,6 +36199,54 @@ rs6000_vector_mode_supported_p (machine_mode mode)\n     return false;\n }\n \n+/* Target hook for floatn_mode.  */\n+static machine_mode\n+rs6000_floatn_mode (int n, bool extended)\n+{\n+  if (extended)\n+    {\n+      switch (n)\n+\t{\n+\tcase 32:\n+\t  return DFmode;\n+\n+\tcase 64:\n+\t  if (TARGET_FLOAT128)\n+\t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n+\t  else\n+\t    return VOIDmode;\n+\n+\tcase 128:\n+\t  return VOIDmode;\n+\n+\tdefault:\n+\t  /* Those are the only valid _FloatNx types.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    {\n+      switch (n)\n+\t{\n+\tcase 32:\n+\t  return SFmode;\n+\n+\tcase 64:\n+\t  return DFmode;\n+\n+\tcase 128:\n+\t  if (TARGET_FLOAT128)\n+\t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n+\t  else\n+\t    return VOIDmode;\n+\n+\tdefault:\n+\t  return VOIDmode;\n+\t}\n+    }\n+\n+}\n+\n /* Target hook for c_mode_for_suffix.  */\n static machine_mode\n rs6000_c_mode_for_suffix (char suffix)"}, {"sha": "5124883ae5c9f543f9bf90cf5e01b1f0b571be36", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -927,6 +927,8 @@ examine and set these two fictitious variables with your debugger.\n @node Floating Types\n @section Additional Floating Types\n @cindex additional floating types\n+@cindex @code{_Float@var{n}} data types\n+@cindex @code{_Float@var{n}x} data types\n @cindex @code{__float80} data type\n @cindex @code{__float128} data type\n @cindex @code{__ibm128} data type\n@@ -935,9 +937,19 @@ examine and set these two fictitious variables with your debugger.\n @cindex @code{W} floating point suffix\n @cindex @code{Q} floating point suffix\n \n-As an extension, GNU C supports additional floating\n+ISO/IEC TS 18661-3:2015 defines C support for additional floating\n+types @code{_Float@var{n}} and @code{_Float@var{n}x}, and GCC supports\n+these type names; the set of types supported depends on the target\n+architecture.  These types are not supported when compiling C++.\n+Constants with these types use suffixes @code{f@var{n}} or\n+@code{F@var{n}} and @code{f@var{n}x} or @code{F@var{n}x}.  These type\n+names can be used together with @code{_Complex} to declare complex\n+types.\n+\n+As an extension, GNU C and GNU C++ support additional floating\n types, @code{__float80} and @code{__float128} to support 80-bit\n-(@code{XFmode}) and 128-bit (@code{TFmode}) floating types.\n+(@code{XFmode}) and 128-bit (@code{TFmode}) floating types; these are\n+aliases for the type names @code{_Float64x} and @code{_Float128}.\n Support for additional types includes the arithmetic operators:\n add, subtract, multiply, divide; unary arithmetic operators;\n relational operators; equality operators; and conversions to and from\n@@ -954,9 +966,11 @@ typedef _Complex float __attribute__((mode(TC))) _Complex128;\n typedef _Complex float __attribute__((mode(XC))) _Complex80;\n @end smallexample\n \n-In order to use @code{__float128} and @code{__ibm128} on PowerPC Linux\n+In order to use @code{_Float128}, @code{__float128} and\n+@code{__ibm128} on PowerPC Linux\n systems, you must use the @option{-mfloat128}. It is expected in\n-future versions of GCC that @code{__float128} will be enabled\n+future versions of GCC that @code{_Float128} and @code{__float128}\n+will be enabled\n automatically.  In addition, there are currently problems in using the\n complex @code{__float128} type.  When these problems are fixed, you\n would use the following syntax to declare @code{_Complex128} to be a\n@@ -976,7 +990,14 @@ Not all targets support additional floating-point types.\n IA-64 targets.  The @code{__float128} type is supported on hppa HP-UX.\n The @code{__float128} type is supported on PowerPC 64-bit Linux\n systems by default if the vector scalar instruction set (VSX) is\n-enabled.\n+enabled.  The @code{_Float128} type is supported on all systems where\n+@code{__float128} is supported or where @code{long double} has the\n+IEEE binary128 format.  The @code{_Float64x} type is supported on all\n+systems where @code{__float128} is supported.  The @code{_Float32}\n+type is supported on all systems supporting IEEE binary32; the\n+@code{_Float64} and @code{Float32x} types are supported on all systems\n+supporting IEEE binary64.  GCC does not currently support\n+@code{_Float16} or @code{_Float128x} on any systems.\n \n On the PowerPC, @code{__ibm128} provides access to the IBM extended\n double format, and it is intended to be used by the library functions"}, {"sha": "d18c3b4c27b8f0bdf5d3fec12aec48087cfc4330", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1321,6 +1321,25 @@ Target supports array and structure sizes that are 32 bits or longer.\n \n @item 4byte_wchar_t\n Target has @code{wchar_t} that is at least 4 bytes.\n+\n+@item float@var{n}\n+Target has the @code{_Float@var{n}} type.\n+\n+@item float@var{n}x\n+Target has the @code{_Float@var{n}x} type.\n+\n+@item float@var{n}_runtime\n+Target has the @code{_Float@var{n}} type, including runtime support\n+for any options added with @code{dg-add-options}.\n+\n+@item float@var{n}x_runtime\n+Target has the @code{_Float@var{n}x} type, including runtime support\n+for any options added with @code{dg-add-options}.\n+\n+@item floatn_nx_runtime\n+Target has runtime support for any options added with\n+@code{dg-add-options} for any @code{_Float@var{n}} or\n+@code{_Float@var{n}x} type.\n @end table\n \n @subsubsection Fortran-specific attributes\n@@ -2135,6 +2154,12 @@ locally when using pic/PIC passes in the testsuite.\n @item c99_runtime\n Add the target-specific flags needed to access the C99 runtime.\n \n+@item float@var{n}\n+Add the target-specific flags needed to use the @code{_Float@var{n}} type.\n+\n+@item float@var{n}x\n+Add the target-specific flags needed to use the @code{_Float@var{n}x} type.\n+\n @item ieee\n Add the target-specific flags needed to enable full IEEE\n compliance mode."}, {"sha": "586626062435f3718cfae84c6aab3024d08d79d7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -4269,6 +4269,24 @@ hook returns true for all of @code{SFmode}, @code{DFmode},\n @code{XFmode} and @code{TFmode}, if such modes exist.\n @end deftypefn\n \n+@deftypefn {Target Hook} machine_mode TARGET_FLOATN_MODE (int @var{n}, bool @var{extended})\n+Define this to return the machine mode to use for the type \n+@code{_Float@var{n}}, if @var{extended} is false, or the type \n+@code{_Float@var{n}x}, if @var{extended} is true.  If such a type \n+is not supported, return @code{VOIDmode}.  The default version of this \n+hook returns @code{SFmode} for @code{_Float32}, @code{DFmode} for \n+@code{_Float64} and @code{_Float32x} and @code{TFmode} for \n+@code{_Float128}, if those modes exist and satisfy the requirements for \n+those types and pass @code{TARGET_SCALAR_MODE_SUPPORTED_P} and \n+@code{TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P}; for @code{_Float64x}, it \n+returns the first of @code{XFmode} and @code{TFmode} that exists and \n+satisfies the same requirements; for other types, it returns \n+@code{VOIDmode}.  The hook is only called for values of @var{n} and \n+@var{extended} that are valid according to ISO/IEC TS 18661-3:2015; that \n+is, @var{n} is one of 32, 64, 128, or, if @var{extended} is false, 16 or \n+greater than 128 and a multiple of 32.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P (machine_mode @var{mode})\n Define this to return nonzero for machine modes for which the port has\n small register classes.  If this target hook returns nonzero for a given"}, {"sha": "da133a4b7010533d85d5bb9a850b91e8a80ce1ca", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -3527,6 +3527,8 @@ stack.\n \n @hook TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P\n \n+@hook TARGET_FLOATN_MODE\n+\n @hook TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n \n @node Scalar Return"}, {"sha": "a404c432d64087f9af0ba36b2e57fa1fd5dcf102", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,13 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* trans-types.h (float128_type_node): Rename to\n+\tgfc_float128_type_node.\n+\t(complex_float128_type_node): Rename to\n+\tgfc_complex_float128_type_node.\n+\t* iso-c-binding.def, trans-intrinsic.c, trans-types.c: All users\n+\tchanged.\n+\n 2016-08-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/71014"}, {"sha": "472e7ae4fafe233113dc082fd819e2d200d4a49e", "filename": "gcc/fortran/iso-c-binding.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Fiso-c-binding.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Fiso-c-binding.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-c-binding.def?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -115,8 +115,8 @@ NAMED_REALCST (ISOCBINDING_DOUBLE, \"c_double\", \\\n NAMED_REALCST (ISOCBINDING_LONG_DOUBLE, \"c_long_double\", \\\n                get_real_kind_from_node (long_double_type_node), GFC_STD_F2003)\n NAMED_REALCST (ISOCBINDING_FLOAT128, \"c_float128\", \\\n-\t       float128_type_node == NULL_TREE \\\n-\t\t  ? -4 : get_real_kind_from_node (float128_type_node), \\\n+\t       gfc_float128_type_node == NULL_TREE \\\n+\t\t  ? -4 : get_real_kind_from_node (gfc_float128_type_node), \\\n \t       GFC_STD_GNU)\n NAMED_CMPXCST (ISOCBINDING_FLOAT_COMPLEX, \"c_float_complex\", \\\n                get_real_kind_from_node (float_type_node), GFC_STD_F2003)\n@@ -125,8 +125,8 @@ NAMED_CMPXCST (ISOCBINDING_DOUBLE_COMPLEX, \"c_double_complex\", \\\n NAMED_CMPXCST (ISOCBINDING_LONG_DOUBLE_COMPLEX, \"c_long_double_complex\", \\\n                get_real_kind_from_node (long_double_type_node), GFC_STD_F2003)\n NAMED_CMPXCST (ISOCBINDING_FLOAT128_COMPLEX, \"c_float128_complex\", \\\n-\t       float128_type_node == NULL_TREE \\\n-\t\t  ? -4 : get_real_kind_from_node (float128_type_node), \\\n+\t       gfc_float128_type_node == NULL_TREE \\\n+\t\t  ? -4 : get_real_kind_from_node (gfc_float128_type_node), \\\n \t       GFC_STD_GNU)\n \n NAMED_LOGCST (ISOCBINDING_BOOL, \"c_bool\", \\"}, {"sha": "81678428f182492a18d62645d2bc418c8ab44d7d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -149,7 +149,7 @@ builtin_decl_for_precision (enum built_in_function base_built_in,\n     i = m->double_built_in;\n   else if (precision == TYPE_PRECISION (long_double_type_node))\n     i = m->long_double_built_in;\n-  else if (precision == TYPE_PRECISION (float128_type_node))\n+  else if (precision == TYPE_PRECISION (gfc_float128_type_node))\n     {\n       /* Special treatment, because it is not exactly a built-in, but\n \t a library function.  */\n@@ -621,8 +621,8 @@ gfc_build_intrinsic_lib_fndecls (void)\n \n     memset (quad_decls, 0, sizeof(tree) * (END_BUILTINS + 1));\n \n-    type = float128_type_node;\n-    complex_type = complex_float128_type_node;\n+    type = gfc_float128_type_node;\n+    complex_type = gfc_complex_float128_type_node;\n     /* type (*) (type) */\n     func_1 = build_function_type_list (type, type, NULL_TREE);\n     /* int (*) (type) */"}, {"sha": "6a89b30e3bf1121016059b8ab9e228424c98adc3", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -62,8 +62,8 @@ tree pfunc_type_node;\n \n tree gfc_charlen_type_node;\n \n-tree float128_type_node = NULL_TREE;\n-tree complex_float128_type_node = NULL_TREE;\n+tree gfc_float128_type_node = NULL_TREE;\n+tree gfc_complex_float128_type_node = NULL_TREE;\n \n bool gfc_real16_is_float128 = false;\n \n@@ -901,7 +901,7 @@ gfc_init_types (void)\n       PUSH_TYPE (name_buf, type);\n \n       if (gfc_real_kinds[index].c_float128)\n-\tfloat128_type_node = type;\n+\tgfc_float128_type_node = type;\n \n       type = gfc_build_complex_type (type);\n       gfc_complex_types[index] = type;\n@@ -910,7 +910,7 @@ gfc_init_types (void)\n       PUSH_TYPE (name_buf, type);\n \n       if (gfc_real_kinds[index].c_float128)\n-\tcomplex_float128_type_node = type;\n+\tgfc_complex_float128_type_node = type;\n     }\n \n   for (index = 0; gfc_character_kinds[index].kind != 0; ++index)"}, {"sha": "c518cc1892650b46d7bb3153e1971ed1b8c53207", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -30,8 +30,8 @@ extern GTY(()) tree ppvoid_type_node;\n extern GTY(()) tree pvoid_type_node;\n extern GTY(()) tree prvoid_type_node;\n extern GTY(()) tree pchar_type_node;\n-extern GTY(()) tree float128_type_node;\n-extern GTY(()) tree complex_float128_type_node;\n+extern GTY(()) tree gfc_float128_type_node;\n+extern GTY(()) tree gfc_complex_float128_type_node;\n \n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */"}, {"sha": "de46a2711a96e7c31f5fcb16441cc1e6da2d86f4", "filename": "gcc/ginclude/float.h", "status": "modified", "additions": 182, "deletions": 1, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fginclude%2Ffloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Fginclude%2Ffloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Ffloat.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -165,7 +165,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #undef LDBL_DECIMAL_DIG\n #define FLT_DECIMAL_DIG\t\t__FLT_DECIMAL_DIG__\n #define DBL_DECIMAL_DIG\t\t__DBL_DECIMAL_DIG__\n-#define LDBL_DECIMAL_DIG\t__DECIMAL_DIG__\n+#define LDBL_DECIMAL_DIG\t__LDBL_DECIMAL_DIG__\n \n /* Whether types support subnormal numbers.  */\n #undef FLT_HAS_SUBNORM\n@@ -185,6 +185,187 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #endif /* C11 */\n \n+#ifdef __STDC_WANT_IEC_60559_TYPES_EXT__\n+/* Constants for _FloatN and _FloatNx types from TS 18661-3.  See\n+   comments above for their semantics.  */\n+\n+#ifdef __FLT16_MANT_DIG__\n+#undef FLT16_MANT_DIG\n+#define FLT16_MANT_DIG\t\t__FLT16_MANT_DIG__\n+#undef FLT16_DIG\n+#define FLT16_DIG\t\t__FLT16_DIG__\n+#undef FLT16_MIN_EXP\n+#define FLT16_MIN_EXP\t\t__FLT16_MIN_EXP__\n+#undef FLT16_MIN_10_EXP\n+#define FLT16_MIN_10_EXP\t__FLT16_MIN_10_EXP__\n+#undef FLT16_MAX_EXP\n+#define FLT16_MAX_EXP\t\t__FLT16_MAX_EXP__\n+#undef FLT16_MAX_10_EXP\n+#define FLT16_MAX_10_EXP\t__FLT16_MAX_10_EXP__\n+#undef FLT16_MAX\n+#define FLT16_MAX\t\t__FLT16_MAX__\n+#undef FLT16_EPSILON\n+#define FLT16_EPSILON\t\t__FLT16_EPSILON__\n+#undef FLT16_MIN\n+#define FLT16_MIN\t\t__FLT16_MIN__\n+#undef FLT16_DECIMAL_DIG\n+#define FLT16_DECIMAL_DIG\t__FLT16_DECIMAL_DIG__\n+#undef FLT16_TRUE_MIN\n+#define FLT16_TRUE_MIN\t\t__FLT16_DENORM_MIN__\n+#endif /* __FLT16_MANT_DIG__.  */\n+\n+#ifdef __FLT32_MANT_DIG__\n+#undef FLT32_MANT_DIG\n+#define FLT32_MANT_DIG\t\t__FLT32_MANT_DIG__\n+#undef FLT32_DIG\n+#define FLT32_DIG\t\t__FLT32_DIG__\n+#undef FLT32_MIN_EXP\n+#define FLT32_MIN_EXP\t\t__FLT32_MIN_EXP__\n+#undef FLT32_MIN_10_EXP\n+#define FLT32_MIN_10_EXP\t__FLT32_MIN_10_EXP__\n+#undef FLT32_MAX_EXP\n+#define FLT32_MAX_EXP\t\t__FLT32_MAX_EXP__\n+#undef FLT32_MAX_10_EXP\n+#define FLT32_MAX_10_EXP\t__FLT32_MAX_10_EXP__\n+#undef FLT32_MAX\n+#define FLT32_MAX\t\t__FLT32_MAX__\n+#undef FLT32_EPSILON\n+#define FLT32_EPSILON\t\t__FLT32_EPSILON__\n+#undef FLT32_MIN\n+#define FLT32_MIN\t\t__FLT32_MIN__\n+#undef FLT32_DECIMAL_DIG\n+#define FLT32_DECIMAL_DIG\t__FLT32_DECIMAL_DIG__\n+#undef FLT32_TRUE_MIN\n+#define FLT32_TRUE_MIN\t\t__FLT32_DENORM_MIN__\n+#endif /* __FLT32_MANT_DIG__.  */\n+\n+#ifdef __FLT64_MANT_DIG__\n+#undef FLT64_MANT_DIG\n+#define FLT64_MANT_DIG\t\t__FLT64_MANT_DIG__\n+#undef FLT64_DIG\n+#define FLT64_DIG\t\t__FLT64_DIG__\n+#undef FLT64_MIN_EXP\n+#define FLT64_MIN_EXP\t\t__FLT64_MIN_EXP__\n+#undef FLT64_MIN_10_EXP\n+#define FLT64_MIN_10_EXP\t__FLT64_MIN_10_EXP__\n+#undef FLT64_MAX_EXP\n+#define FLT64_MAX_EXP\t\t__FLT64_MAX_EXP__\n+#undef FLT64_MAX_10_EXP\n+#define FLT64_MAX_10_EXP\t__FLT64_MAX_10_EXP__\n+#undef FLT64_MAX\n+#define FLT64_MAX\t\t__FLT64_MAX__\n+#undef FLT64_EPSILON\n+#define FLT64_EPSILON\t\t__FLT64_EPSILON__\n+#undef FLT64_MIN\n+#define FLT64_MIN\t\t__FLT64_MIN__\n+#undef FLT64_DECIMAL_DIG\n+#define FLT64_DECIMAL_DIG\t__FLT64_DECIMAL_DIG__\n+#undef FLT64_TRUE_MIN\n+#define FLT64_TRUE_MIN\t\t__FLT64_DENORM_MIN__\n+#endif /* __FLT64_MANT_DIG__.  */\n+\n+#ifdef __FLT128_MANT_DIG__\n+#undef FLT128_MANT_DIG\n+#define FLT128_MANT_DIG\t\t__FLT128_MANT_DIG__\n+#undef FLT128_DIG\n+#define FLT128_DIG\t\t__FLT128_DIG__\n+#undef FLT128_MIN_EXP\n+#define FLT128_MIN_EXP\t\t__FLT128_MIN_EXP__\n+#undef FLT128_MIN_10_EXP\n+#define FLT128_MIN_10_EXP\t__FLT128_MIN_10_EXP__\n+#undef FLT128_MAX_EXP\n+#define FLT128_MAX_EXP\t\t__FLT128_MAX_EXP__\n+#undef FLT128_MAX_10_EXP\n+#define FLT128_MAX_10_EXP\t__FLT128_MAX_10_EXP__\n+#undef FLT128_MAX\n+#define FLT128_MAX\t\t__FLT128_MAX__\n+#undef FLT128_EPSILON\n+#define FLT128_EPSILON\t\t__FLT128_EPSILON__\n+#undef FLT128_MIN\n+#define FLT128_MIN\t\t__FLT128_MIN__\n+#undef FLT128_DECIMAL_DIG\n+#define FLT128_DECIMAL_DIG\t__FLT128_DECIMAL_DIG__\n+#undef FLT128_TRUE_MIN\n+#define FLT128_TRUE_MIN\t\t__FLT128_DENORM_MIN__\n+#endif /* __FLT128_MANT_DIG__.  */\n+\n+#ifdef __FLT32X_MANT_DIG__\n+#undef FLT32X_MANT_DIG\n+#define FLT32X_MANT_DIG\t\t__FLT32X_MANT_DIG__\n+#undef FLT32X_DIG\n+#define FLT32X_DIG\t\t__FLT32X_DIG__\n+#undef FLT32X_MIN_EXP\n+#define FLT32X_MIN_EXP\t\t__FLT32X_MIN_EXP__\n+#undef FLT32X_MIN_10_EXP\n+#define FLT32X_MIN_10_EXP\t__FLT32X_MIN_10_EXP__\n+#undef FLT32X_MAX_EXP\n+#define FLT32X_MAX_EXP\t\t__FLT32X_MAX_EXP__\n+#undef FLT32X_MAX_10_EXP\n+#define FLT32X_MAX_10_EXP\t__FLT32X_MAX_10_EXP__\n+#undef FLT32X_MAX\n+#define FLT32X_MAX\t\t__FLT32X_MAX__\n+#undef FLT32X_EPSILON\n+#define FLT32X_EPSILON\t\t__FLT32X_EPSILON__\n+#undef FLT32X_MIN\n+#define FLT32X_MIN\t\t__FLT32X_MIN__\n+#undef FLT32X_DECIMAL_DIG\n+#define FLT32X_DECIMAL_DIG\t__FLT32X_DECIMAL_DIG__\n+#undef FLT32X_TRUE_MIN\n+#define FLT32X_TRUE_MIN\t\t__FLT32X_DENORM_MIN__\n+#endif /* __FLT32X_MANT_DIG__.  */\n+\n+#ifdef __FLT64X_MANT_DIG__\n+#undef FLT64X_MANT_DIG\n+#define FLT64X_MANT_DIG\t\t__FLT64X_MANT_DIG__\n+#undef FLT64X_DIG\n+#define FLT64X_DIG\t\t__FLT64X_DIG__\n+#undef FLT64X_MIN_EXP\n+#define FLT64X_MIN_EXP\t\t__FLT64X_MIN_EXP__\n+#undef FLT64X_MIN_10_EXP\n+#define FLT64X_MIN_10_EXP\t__FLT64X_MIN_10_EXP__\n+#undef FLT64X_MAX_EXP\n+#define FLT64X_MAX_EXP\t\t__FLT64X_MAX_EXP__\n+#undef FLT64X_MAX_10_EXP\n+#define FLT64X_MAX_10_EXP\t__FLT64X_MAX_10_EXP__\n+#undef FLT64X_MAX\n+#define FLT64X_MAX\t\t__FLT64X_MAX__\n+#undef FLT64X_EPSILON\n+#define FLT64X_EPSILON\t\t__FLT64X_EPSILON__\n+#undef FLT64X_MIN\n+#define FLT64X_MIN\t\t__FLT64X_MIN__\n+#undef FLT64X_DECIMAL_DIG\n+#define FLT64X_DECIMAL_DIG\t__FLT64X_DECIMAL_DIG__\n+#undef FLT64X_TRUE_MIN\n+#define FLT64X_TRUE_MIN\t\t__FLT64X_DENORM_MIN__\n+#endif /* __FLT64X_MANT_DIG__.  */\n+\n+#ifdef __FLT128X_MANT_DIG__\n+#undef FLT128X_MANT_DIG\n+#define FLT128X_MANT_DIG\t__FLT128X_MANT_DIG__\n+#undef FLT128X_DIG\n+#define FLT128X_DIG\t\t__FLT128X_DIG__\n+#undef FLT128X_MIN_EXP\n+#define FLT128X_MIN_EXP\t\t__FLT128X_MIN_EXP__\n+#undef FLT128X_MIN_10_EXP\n+#define FLT128X_MIN_10_EXP\t__FLT128X_MIN_10_EXP__\n+#undef FLT128X_MAX_EXP\n+#define FLT128X_MAX_EXP\t\t__FLT128X_MAX_EXP__\n+#undef FLT128X_MAX_10_EXP\n+#define FLT128X_MAX_10_EXP\t__FLT128X_MAX_10_EXP__\n+#undef FLT128X_MAX\n+#define FLT128X_MAX\t\t__FLT128X_MAX__\n+#undef FLT128X_EPSILON\n+#define FLT128X_EPSILON\t\t__FLT128X_EPSILON__\n+#undef FLT128X_MIN\n+#define FLT128X_MIN\t\t__FLT128X_MIN__\n+#undef FLT128X_DECIMAL_DIG\n+#define FLT128X_DECIMAL_DIG\t__FLT128X_DECIMAL_DIG__\n+#undef FLT128X_TRUE_MIN\n+#define FLT128X_TRUE_MIN\t__FLT128X_DENORM_MIN__\n+#endif /* __FLT128X_MANT_DIG__.  */\n+\n+#endif /* __STDC_WANT_IEC_60559_TYPES_EXT__.  */\n+\n #ifdef __STDC_WANT_DEC_FP__\n /* Draft Technical Report 24732, extension for decimal floating-point\n    arithmetic: Characteristic of decimal floating types <float.h>.  */"}, {"sha": "66e88e2ad366f7848609d157074c80420d778bcf", "filename": "gcc/real.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -3043,6 +3043,7 @@ const struct real_format ieee_single_format =\n     128,\n     31,\n     31,\n+    32,\n     false,\n     true,\n     true,\n@@ -3065,6 +3066,7 @@ const struct real_format mips_single_format =\n     128,\n     31,\n     31,\n+    32,\n     false,\n     true,\n     true,\n@@ -3087,6 +3089,7 @@ const struct real_format motorola_single_format =\n     128,\n     31,\n     31,\n+    32,\n     false,\n     true,\n     true,\n@@ -3120,6 +3123,7 @@ const struct real_format spu_single_format =\n     129,\n     31,\n     31,\n+    0,\n     true,\n     false,\n     false,\n@@ -3330,6 +3334,7 @@ const struct real_format ieee_double_format =\n     1024,\n     63,\n     63,\n+    64,\n     false,\n     true,\n     true,\n@@ -3352,6 +3357,7 @@ const struct real_format mips_double_format =\n     1024,\n     63,\n     63,\n+    64,\n     false,\n     true,\n     true,\n@@ -3374,6 +3380,7 @@ const struct real_format motorola_double_format =\n     1024,\n     63,\n     63,\n+    64,\n     false,\n     true,\n     true,\n@@ -3719,6 +3726,7 @@ const struct real_format ieee_extended_motorola_format =\n     16384,\n     95,\n     95,\n+    0,\n     false,\n     true,\n     true,\n@@ -3741,6 +3749,7 @@ const struct real_format ieee_extended_intel_96_format =\n     16384,\n     79,\n     79,\n+    65,\n     false,\n     true,\n     true,\n@@ -3763,6 +3772,7 @@ const struct real_format ieee_extended_intel_128_format =\n     16384,\n     79,\n     79,\n+    65,\n     false,\n     true,\n     true,\n@@ -3787,6 +3797,7 @@ const struct real_format ieee_extended_intel_96_round_53_format =\n     16384,\n     79,\n     79,\n+    33,\n     false,\n     true,\n     true,\n@@ -3876,6 +3887,7 @@ const struct real_format ibm_extended_format =\n     1024,\n     127,\n     -1,\n+    0,\n     false,\n     true,\n     true,\n@@ -3898,6 +3910,7 @@ const struct real_format mips_extended_format =\n     1024,\n     127,\n     -1,\n+    0,\n     false,\n     true,\n     true,\n@@ -4162,6 +4175,7 @@ const struct real_format ieee_quad_format =\n     16384,\n     127,\n     127,\n+    128,\n     false,\n     true,\n     true,\n@@ -4184,6 +4198,7 @@ const struct real_format mips_quad_format =\n     16384,\n     127,\n     127,\n+    128,\n     false,\n     true,\n     true,\n@@ -4485,6 +4500,7 @@ const struct real_format vax_f_format =\n     127,\n     15,\n     15,\n+    0,\n     false,\n     false,\n     false,\n@@ -4507,6 +4523,7 @@ const struct real_format vax_d_format =\n     127,\n     15,\n     15,\n+    0,\n     false,\n     false,\n     false,\n@@ -4529,6 +4546,7 @@ const struct real_format vax_g_format =\n     1023,\n     15,\n     15,\n+    0,\n     false,\n     false,\n     false,\n@@ -4606,6 +4624,7 @@ const struct real_format decimal_single_format =\n     97,\n     31,\n     31,\n+    32,\n     false,\n     true,\n     true,\n@@ -4629,6 +4648,7 @@ const struct real_format decimal_double_format =\n     385,\n     63,\n     63,\n+    64,\n     false,\n     true,\n     true,\n@@ -4652,6 +4672,7 @@ const struct real_format decimal_quad_format =\n     6145,\n     127,\n     127,\n+    128,\n     false,\n     true,\n     true,\n@@ -4790,6 +4811,7 @@ const struct real_format ieee_half_format =\n     16,\n     15,\n     15,\n+    16,\n     false,\n     true,\n     true,\n@@ -4815,6 +4837,7 @@ const struct real_format arm_half_format =\n     17,\n     15,\n     15,\n+    0,\n     false,\n     true,\n     false,\n@@ -4861,6 +4884,7 @@ const struct real_format real_internal_format =\n     MAX_EXP,\n     -1,\n     -1,\n+    0,\n     false,\n     false,\n     true,"}, {"sha": "59af580e78f2637be84f71b98b45ec6611053222", "filename": "gcc/real.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -139,6 +139,17 @@ struct real_format\n      or -1 for a complex encoding.  */\n   int signbit_rw;\n \n+  /* If this is an IEEE interchange format, the number of bits in the\n+     format; otherwise, if it is an IEEE extended format, one more\n+     than the greatest number of bits in an interchange format it\n+     extends; otherwise 0.  Formats need not follow the IEEE 754-2008\n+     recommended practice regarding how signaling NaNs are identified,\n+     and may vary in the choice of default NaN, but must follow other\n+     IEEE practice regarding having NaNs, infinities and subnormal\n+     values, and the relation of minimum and maximum exponents, and,\n+     for interchange formats, the details of the encoding.  */\n+  int ieee_bits;\n+\n   /* Default rounding mode for operations on this format.  */\n   bool round_towards_zero;\n   bool has_sign_dependent_rounding;"}, {"sha": "8d50691206356e460b38c1264be1f28cf15290cf", "filename": "gcc/target.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -3333,6 +3333,26 @@ hook returns true for all of @code{SFmode}, @code{DFmode}, \\n\\\n  bool, (machine_mode mode),\n  default_libgcc_floating_mode_supported_p)\n \n+DEFHOOK\n+(floatn_mode,\n+ \"Define this to return the machine mode to use for the type \\n\\\n+@code{_Float@var{n}}, if @var{extended} is false, or the type \\n\\\n+@code{_Float@var{n}x}, if @var{extended} is true.  If such a type \\n\\\n+is not supported, return @code{VOIDmode}.  The default version of this \\n\\\n+hook returns @code{SFmode} for @code{_Float32}, @code{DFmode} for \\n\\\n+@code{_Float64} and @code{_Float32x} and @code{TFmode} for \\n\\\n+@code{_Float128}, if those modes exist and satisfy the requirements for \\n\\\n+those types and pass @code{TARGET_SCALAR_MODE_SUPPORTED_P} and \\n\\\n+@code{TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P}; for @code{_Float64x}, it \\n\\\n+returns the first of @code{XFmode} and @code{TFmode} that exists and \\n\\\n+satisfies the same requirements; for other types, it returns \\n\\\n+@code{VOIDmode}.  The hook is only called for values of @var{n} and \\n\\\n+@var{extended} that are valid according to ISO/IEC TS 18661-3:2015; that \\n\\\n+is, @var{n} is one of 32, 64, 128, or, if @var{extended} is false, 16 or \\n\\\n+greater than 128 and a multiple of 32.\",\n+ machine_mode, (int n, bool extended),\n+ default_floatn_mode)\n+\n /* Compute cost of moving data from a register of class FROM to one of\n    TO, using MODE.  */\n DEFHOOK"}, {"sha": "9d5be1706ddd3601a80844d74e5d8e4fc1ee83a9", "filename": "gcc/targhooks.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"predict.h\"\n #include \"params.h\"\n+#include \"real.h\"\n \n \n bool\n@@ -461,6 +462,92 @@ default_libgcc_floating_mode_supported_p (machine_mode mode)\n     }\n }\n \n+/* Return the machine mode to use for the type _FloatN, if EXTENDED is\n+   false, or _FloatNx, if EXTENDED is true, or VOIDmode if not\n+   supported.  */\n+machine_mode\n+default_floatn_mode (int n, bool extended)\n+{\n+  if (extended)\n+    {\n+      machine_mode cand1 = VOIDmode, cand2 = VOIDmode;\n+      switch (n)\n+\t{\n+\tcase 32:\n+#ifdef HAVE_DFmode\n+\t  cand1 = DFmode;\n+#endif\n+\t  break;\n+\n+\tcase 64:\n+#ifdef HAVE_XFmode\n+\t  cand1 = XFmode;\n+#endif\n+#ifdef HAVE_TFmode\n+\t  cand2 = TFmode;\n+#endif\n+\t  break;\n+\n+\tcase 128:\n+\t  break;\n+\n+\tdefault:\n+\t  /* Those are the only valid _FloatNx types.  */\n+\t  gcc_unreachable ();\n+\t}\n+      if (cand1 != VOIDmode\n+\t  && REAL_MODE_FORMAT (cand1)->ieee_bits > n\n+\t  && targetm.scalar_mode_supported_p (cand1)\n+\t  && targetm.libgcc_floating_mode_supported_p (cand1))\n+\treturn cand1;\n+      if (cand2 != VOIDmode\n+\t  && REAL_MODE_FORMAT (cand2)->ieee_bits > n\n+\t  && targetm.scalar_mode_supported_p (cand2)\n+\t  && targetm.libgcc_floating_mode_supported_p (cand2))\n+\treturn cand2;\n+    }\n+  else\n+    {\n+      machine_mode cand = VOIDmode;\n+      switch (n)\n+\t{\n+\tcase 16:\n+\t  /* We do not use HFmode for _Float16 by default because the\n+\t     required excess precision support is not present and the\n+\t     interactions with promotion of the older __fp16 need to\n+\t     be worked out.  */\n+\t  break;\n+\n+\tcase 32:\n+#ifdef HAVE_SFmode\n+\t  cand = SFmode;\n+#endif\n+\t  break;\n+\n+\tcase 64:\n+#ifdef HAVE_DFmode\n+\t  cand = DFmode;\n+#endif\n+\t  break;\n+\n+\tcase 128:\n+#ifdef HAVE_TFmode\n+\t  cand = TFmode;\n+#endif\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      if (cand != VOIDmode\n+\t  && REAL_MODE_FORMAT (cand)->ieee_bits == n\n+\t  && targetm.scalar_mode_supported_p (cand)\n+\t  && targetm.libgcc_floating_mode_supported_p (cand))\n+\treturn cand;\n+    }\n+  return VOIDmode;\n+}\n+\n /* Make some target macros useable by target-independent code.  */\n bool\n targhook_words_big_endian (void)"}, {"sha": "a2fa49f89b35127cc09c19bff84e15415d989b27", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -73,6 +73,7 @@ extern tree default_mangle_assembler_name (const char *);\n \n extern bool default_scalar_mode_supported_p (machine_mode);\n extern bool default_libgcc_floating_mode_supported_p (machine_mode);\n+extern machine_mode default_floatn_mode (int, bool);\n extern bool targhook_words_big_endian (void);\n extern bool targhook_float_words_big_endian (void);\n extern bool default_float_exceptions_rounding_supported_p (void);"}, {"sha": "91ea2788d4c1b8a70f4d98138be94caa285257bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,77 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* lib/target-supports.exp (check_effective_target_float16)\n+\t(check_effective_target_float32, check_effective_target_float64)\n+\t(check_effective_target_float128, check_effective_target_float32x)\n+\t(check_effective_target_float64x)\n+\t(check_effective_target_float128x)\n+\t(check_effective_target_float16_runtime)\n+\t(check_effective_target_float32_runtime)\n+\t(check_effective_target_float64_runtime)\n+\t(check_effective_target_float128_runtime)\n+\t(check_effective_target_float32x_runtime)\n+\t(check_effective_target_float64x_runtime)\n+\t(check_effective_target_float128x_runtime)\n+\t(check_effective_target_floatn_nx_runtime)\n+\t(add_options_for_float16, add_options_for_float32)\n+\t(add_options_for_float64, add_options_for_float128)\n+\t(add_options_for_float32x, add_options_for_float64x)\n+\t(add_options_for_float128x): New procedures.\n+\t* gcc.dg/dfp/floatn.c, gcc.dg/float128-typeof.c,\n+\tgcc.dg/float128x-typeof.c, gcc.dg/float16-typeof.c,\n+\tgcc.dg/float32-typeof.c, gcc.dg/float32x-typeof.c,\n+\tgcc.dg/float64-typeof.c, gcc.dg/float64x-typeof.c,\n+\tgcc.dg/floatn-arithconv.c, gcc.dg/floatn-errs.c,\n+\tgcc.dg/floatn-typeof.h, gcc.dg/torture/float128-basic.c,\n+\tgcc.dg/torture/float128-complex.c,\n+\tgcc.dg/torture/float128-floath.c, gcc.dg/torture/float128-tg.c,\n+\tgcc.dg/torture/float128x-basic.c,\n+\tgcc.dg/torture/float128x-complex.c,\n+\tgcc.dg/torture/float128x-floath.c, gcc.dg/torture/float128x-tg.c,\n+\tgcc.dg/torture/float16-basic.c, gcc.dg/torture/float16-complex.c,\n+\tgcc.dg/torture/float16-floath.c, gcc.dg/torture/float16-tg.c,\n+\tgcc.dg/torture/float32-basic.c, gcc.dg/torture/float32-complex.c,\n+\tgcc.dg/torture/float32-floath.c, gcc.dg/torture/float32-tg.c,\n+\tgcc.dg/torture/float32x-basic.c,\n+\tgcc.dg/torture/float32x-complex.c,\n+\tgcc.dg/torture/float32x-floath.c, gcc.dg/torture/float32x-tg.c,\n+\tgcc.dg/torture/float64-basic.c, gcc.dg/torture/float64-complex.c,\n+\tgcc.dg/torture/float64-floath.c, gcc.dg/torture/float64-tg.c,\n+\tgcc.dg/torture/float64x-basic.c,\n+\tgcc.dg/torture/float64x-complex.c,\n+\tgcc.dg/torture/float64x-floath.c, gcc.dg/torture/float64x-tg.c,\n+\tgcc.dg/torture/floatn-basic.h, gcc.dg/torture/floatn-complex.h,\n+\tgcc.dg/torture/floatn-convert.c, gcc.dg/torture/floatn-floath.h,\n+\tgcc.dg/torture/floatn-tg.h,\n+\tgcc.dg/torture/fp-int-convert-float128-ieee-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float128-ieee.c,\n+\tgcc.dg/torture/fp-int-convert-float128x-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float128x.c,\n+\tgcc.dg/torture/fp-int-convert-float16-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float16.c,\n+\tgcc.dg/torture/fp-int-convert-float32-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float32.c,\n+\tgcc.dg/torture/fp-int-convert-float32x-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float32x.c,\n+\tgcc.dg/torture/fp-int-convert-float64-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float64.c,\n+\tgcc.dg/torture/fp-int-convert-float64x-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float64x.c: New tests.\n+\t* gcc.dg/torture/fp-int-convert.h (TEST_I_F): Add argument for\n+\tmaximum exponent of floating-point type.  Use it in testing\n+\twhether 0x8...0 fits in the floating-point type.  Always treat -1\n+\t(signed 0xf...f) as fitting in the floating-point type.\n+\t(M_OK1): New macro.\n+\t* gcc.dg/torture/fp-int-convert-double.c,\n+\tgcc.dg/torture/fp-int-convert-float.c,\n+\tgcc.dg/torture/fp-int-convert-float128-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float128.c,\n+\tgcc.dg/torture/fp-int-convert-float80-timode.c,\n+\tgcc.dg/torture/fp-int-convert-float80.c,\n+\tgcc.dg/torture/fp-int-convert-long-double.c,\n+\tgcc.dg/torture/fp-int-convert-timode.c: Update calls to TEST_I_F.\n+\n 2016-08-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/72744"}, {"sha": "4fa7a091ab9cf8036f2f6fd9a21c7345b515fd98", "filename": "gcc/testsuite/gcc.dg/dfp/floatn.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Ffloatn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Ffloatn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Ffloatn.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Tests for _FloatN / _FloatNx types: test erroneous mixing with DFP.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32 } */\n+/* { dg-require-effective-target float32x } */\n+\n+_Decimal32 d32;\n+_Float32 f32;\n+_Float32x f32x;\n+int i;\n+\n+void\n+f (void)\n+{\n+  (void) (d32 + f32); /* { dg-error \"mix operands\" } */\n+  (void) (f32x * d32); /* { dg-error \"mix operands\" } */\n+  (void) (i ? d32 : f32); /* { dg-error \"mix operands\" } */\n+}"}, {"sha": "b6f95b770aa0599bb8ee436421431cc301cb2f9d", "filename": "gcc/testsuite/gcc.dg/float128-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128 constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128 } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-typeof.h\""}, {"sha": "3ab2ce2debbbfab6ebfce7132ce212f6c5f83044", "filename": "gcc/testsuite/gcc.dg/float128x-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128x-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128x-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat128x-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128x constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-typeof.h\""}, {"sha": "a781239efa29b1b7491fc914f5fa22a05158d33d", "filename": "gcc/testsuite/gcc.dg/float16-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat16-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat16-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat16-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float16 constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16 } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-typeof.h\""}, {"sha": "4b9ccf82cc3a5b44cc91254c12c80ff41e68a0d7", "filename": "gcc/testsuite/gcc.dg/float32-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32 constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32 } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-typeof.h\""}, {"sha": "9af60778d44d667372bd1f4db9872cd9ead7fa67", "filename": "gcc/testsuite/gcc.dg/float32x-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32x-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32x-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat32x-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32x constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-typeof.h\""}, {"sha": "aa7d504efda2d5771bed5aa1199d3712c174866c", "filename": "gcc/testsuite/gcc.dg/float64-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64 constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64 } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-typeof.h\""}, {"sha": "934d6cf5f4e5f389a52acdbbe9526a03480374a8", "filename": "gcc/testsuite/gcc.dg/float64x-typeof.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64x-typeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64x-typeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloat64x-typeof.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64x constant types.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-typeof.h\""}, {"sha": "c3eb24e1fcd1dc53212f07b72e27fb5dc2ab0378", "filename": "gcc/testsuite/gcc.dg/floatn-arithconv.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-arithconv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-arithconv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-arithconv.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,50 @@\n+/* Tests for _FloatN / _FloatNx types: test usual arithmetic\n+   conversions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options float64 } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32 } */\n+/* { dg-require-effective-target float64 } */\n+/* { dg-require-effective-target float32x } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+\n+int i;\n+\n+#define TEST(VAR, TYPE1, TYPE2, RESTYPE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      typedef __typeof__ ((TYPE1) 0 + (TYPE2) 1) restype;\t\\\n+      typedef __typeof__ (i ? (TYPE1) 0 : (TYPE2) 1) restype2;\t\\\n+      typedef RESTYPE exptype;\t\t\t\t\t\\\n+      extern restype VAR;\t\t\t\t\t\\\n+      extern restype2 VAR;\t\t\t\t\t\\\n+      extern exptype VAR;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+void\n+f (void)\n+{\n+  TEST (v1, float, double, double);\n+#if DBL_MANT_DIG > FLT32_MANT_DIG\n+  TEST (v2, double, _Float32, double);\n+#endif\n+#if DBL_MANT_DIG <= FLT64_MANT_DIG\n+  TEST (v3, double, _Float64, _Float64);\n+#endif\n+#if DBL_MANT_DIG >= FLT32X_MANT_DIG\n+  TEST (v4, double, _Float32x, double);\n+#endif\n+#if FLT_MANT_DIG <= FLT32_MANT_DIG\n+  TEST (v5, float, _Float32, _Float32);\n+#endif\n+#if FLT32X_MANT_DIG <= FLT64_MANT_DIG\n+  TEST (v6, _Float32x, _Float64, _Float64);\n+#endif\n+  TEST (v7, _Float32, _Float64, _Float64);\n+  TEST (v8, _Float32, _Float32x, _Float32x);\n+}"}, {"sha": "0dcc2f1bb97518ed31a5fb401d3b50ec13518baf", "filename": "gcc/testsuite/gcc.dg/floatn-errs.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-errs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-errs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-errs.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,44 @@\n+/* Tests for _FloatN / _FloatNx types: test erroneous code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options float64 } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32 } */\n+/* { dg-require-effective-target float32x } */\n+/* { dg-require-effective-target float64 } */\n+\n+/* _FloatN, _FloatNx and standard types are incompatible even if they\n+   have the same ABI.  */\n+\n+extern float a; /* { dg-message \"previous declaration\" } */\n+extern _Float32 a; /* { dg-error \"conflicting\" } */\n+\n+extern double b; /* { dg-message \"previous declaration\" } */\n+extern _Float32x b; /* { dg-error \"conflicting\" } */\n+\n+extern _Float64 c; /* { dg-message \"previous declaration\" } */\n+extern _Float32x c; /* { dg-error \"conflicting\" } */\n+\n+/* These types are not promoted in old-style function definitions.  */\n+\n+void f (_Float32);\n+void\n+f (x)\n+     _Float32 x;\n+{\n+}\n+\n+void g (double); /* { dg-error \"prototype declaration\" } */\n+void\n+g (x)\n+     _Float32 x; /* { dg-error \"match prototype\" } */\n+{\n+}\n+\n+void h (_Float64); /* { dg-error \"prototype declaration\" } */\n+void\n+h (x)\n+     _Float32 x; /* { dg-error \"match prototype\" } */\n+{\n+}"}, {"sha": "4a3e5865a4b1417a91e1145b41631966b761ddc2", "filename": "gcc/testsuite/gcc.dg/floatn-typeof.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-typeof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-typeof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffloatn-typeof.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,22 @@\n+/* Tests for _FloatN / _FloatNx types: test types of constants.\n+   Before including this file, define WIDTH as the value N; define EXT\n+   to 1 for _FloatNx and 0 for _FloatN.  */\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define CSTU(C) CONCAT4 (C, F, WIDTH, x)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define CSTU(C) CONCAT3 (C, F, WIDTH)\n+#endif\n+\n+extern TYPE test_type;\n+extern __typeof (CST (1.0)) test_type;\n+extern __typeof (CSTU (1.0)) test_type;"}, {"sha": "b23d45bf72bacebf04c3f0c28e29c13607c95974", "filename": "gcc/testsuite/gcc.dg/torture/float128-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-basic.h\""}, {"sha": "fe93fe69a57d8c6524fbe3619c3a8b294639c2e8", "filename": "gcc/testsuite/gcc.dg/torture/float128-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128 complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-complex.h\""}, {"sha": "68147c35fb60058c9dae8f1eaed949644b07a8af", "filename": "gcc/testsuite/gcc.dg/torture/float128-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float128 <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT128_MANT_DIG\n+# error \"FLT128_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128_DECIMAL_DIG\n+# error \"FLT128_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128_DIG\n+# error \"FLT128_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128_MIN_EXP\n+# error \"FLT128_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128_MIN_10_EXP\n+# error \"FLT128_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128_MAX_EXP\n+# error \"FLT128_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128_MAX_10_EXP\n+# error \"FLT128_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128_MAX\n+# error \"FLT128_MAX undefined\"\n+#endif\n+\n+#ifndef FLT128_EPSILON\n+# error \"FLT128_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT128_MIN\n+# error \"FLT128_MIN undefined\"\n+#endif\n+\n+#ifndef FLT128_TRUE_MIN\n+# error \"FLT128_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT128_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT128_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT128_MANT_DIG != 113 || FLT128_MAX_EXP != 16384 || FLT128_MIN_EXP != -16381\n+# error \"_Float128 bad format\"\n+#endif"}, {"sha": "c1b6398d92bf62b8ef8619e2f9b123b69ae847d5", "filename": "gcc/testsuite/gcc.dg/torture/float128-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128 type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"floatn-tg.h\""}, {"sha": "75c5a28bb9d0c18fcfa7b69e06561fde21739dcd", "filename": "gcc/testsuite/gcc.dg/torture/float128x-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-basic.h\""}, {"sha": "185b501840c8afafab69132ec36a336cefbb2c8f", "filename": "gcc/testsuite/gcc.dg/torture/float128x-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128x complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-complex.h\""}, {"sha": "0fc3db2744fde288f78f5091224c9ab21cdcca4b", "filename": "gcc/testsuite/gcc.dg/torture/float128x-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float128x <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT128X_MANT_DIG\n+# error \"FLT128X_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128X_DECIMAL_DIG\n+# error \"FLT128X_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128X_DIG\n+# error \"FLT128X_DIG undefined\"\n+#endif\n+\n+#ifndef FLT128X_MIN_EXP\n+# error \"FLT128X_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128X_MIN_10_EXP\n+# error \"FLT128X_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128X_MAX_EXP\n+# error \"FLT128X_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128X_MAX_10_EXP\n+# error \"FLT128X_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT128X_MAX\n+# error \"FLT128X_MAX undefined\"\n+#endif\n+\n+#ifndef FLT128X_EPSILON\n+# error \"FLT128X_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT128X_MIN\n+# error \"FLT128X_MIN undefined\"\n+#endif\n+\n+#ifndef FLT128X_TRUE_MIN\n+# error \"FLT128X_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT128X_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT128X_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT128X_MANT_DIG < 128 || FLT128X_MAX_EXP < 65536 || FLT128X_MIN_EXP + FLT128X_MAX_EXP != 3\n+# error \"_Float128x bad format\"\n+#endif"}, {"sha": "0dc1e0f6823c5d3dda1034c27fdef28c15354981", "filename": "gcc/testsuite/gcc.dg/torture/float128x-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float128x type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"floatn-tg.h\""}, {"sha": "e94aa203d40a86d2345b87daeac34f5e1b580da7", "filename": "gcc/testsuite/gcc.dg/torture/float16-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float16.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-basic.h\""}, {"sha": "463e703d6c836d431f23c4f580923c51d4ef2cee", "filename": "gcc/testsuite/gcc.dg/torture/float16-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float16 complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-complex.h\""}, {"sha": "6857c2e9aa87d4e369eac37e24c917db5416c91d", "filename": "gcc/testsuite/gcc.dg/torture/float16-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float16 <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT16_MANT_DIG\n+# error \"FLT16_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT16_DECIMAL_DIG\n+# error \"FLT16_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT16_DIG\n+# error \"FLT16_DIG undefined\"\n+#endif\n+\n+#ifndef FLT16_MIN_EXP\n+# error \"FLT16_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT16_MIN_10_EXP\n+# error \"FLT16_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT16_MAX_EXP\n+# error \"FLT16_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT16_MAX_10_EXP\n+# error \"FLT16_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT16_MAX\n+# error \"FLT16_MAX undefined\"\n+#endif\n+\n+#ifndef FLT16_EPSILON\n+# error \"FLT16_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT16_MIN\n+# error \"FLT16_MIN undefined\"\n+#endif\n+\n+#ifndef FLT16_TRUE_MIN\n+# error \"FLT16_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT16_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT16_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT16_MANT_DIG != 11 || FLT16_MAX_EXP != 16 || FLT16_MIN_EXP != -13\n+# error \"_Float16 bad format\"\n+#endif"}, {"sha": "39e8285b6e8a1bb5a4c1f6b87829ad508cbb8bb7", "filename": "gcc/testsuite/gcc.dg/torture/float16-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float16 type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"floatn-tg.h\""}, {"sha": "2d3e7a9617516e0dd916a67ae9944ea00544ca48", "filename": "gcc/testsuite/gcc.dg/torture/float32-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-basic.h\""}, {"sha": "8717a3f4571e954717bf04e76b9a3989b8133d71", "filename": "gcc/testsuite/gcc.dg/torture/float32-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32 complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-complex.h\""}, {"sha": "795cb21082f2ca0fb93b7d6040da9dba1b043a99", "filename": "gcc/testsuite/gcc.dg/torture/float32-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float32 <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT32_MANT_DIG\n+# error \"FLT32_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32_DECIMAL_DIG\n+# error \"FLT32_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32_DIG\n+# error \"FLT32_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32_MIN_EXP\n+# error \"FLT32_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32_MIN_10_EXP\n+# error \"FLT32_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32_MAX_EXP\n+# error \"FLT32_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32_MAX_10_EXP\n+# error \"FLT32_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32_MAX\n+# error \"FLT32_MAX undefined\"\n+#endif\n+\n+#ifndef FLT32_EPSILON\n+# error \"FLT32_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT32_MIN\n+# error \"FLT32_MIN undefined\"\n+#endif\n+\n+#ifndef FLT32_TRUE_MIN\n+# error \"FLT32_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT32_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT32_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT32_MANT_DIG != 24 || FLT32_MAX_EXP != 128 || FLT32_MIN_EXP != -125\n+# error \"_Float32 bad format\"\n+#endif"}, {"sha": "da480ca87c5f5df40449a82e911430678c51d768", "filename": "gcc/testsuite/gcc.dg/torture/float32-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32 type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"floatn-tg.h\""}, {"sha": "f2abc332488e86f93feae34cf66affb677df9574", "filename": "gcc/testsuite/gcc.dg/torture/float32x-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-basic.h\""}, {"sha": "4a63a50b5c95cd9a2508843a7fe0ebf6e411d808", "filename": "gcc/testsuite/gcc.dg/torture/float32x-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32x complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-complex.h\""}, {"sha": "49e7ba4ed3aa06960601a9e525a88a042584274a", "filename": "gcc/testsuite/gcc.dg/torture/float32x-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float32x <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT32X_MANT_DIG\n+# error \"FLT32X_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32X_DECIMAL_DIG\n+# error \"FLT32X_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32X_DIG\n+# error \"FLT32X_DIG undefined\"\n+#endif\n+\n+#ifndef FLT32X_MIN_EXP\n+# error \"FLT32X_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32X_MIN_10_EXP\n+# error \"FLT32X_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32X_MAX_EXP\n+# error \"FLT32X_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32X_MAX_10_EXP\n+# error \"FLT32X_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT32X_MAX\n+# error \"FLT32X_MAX undefined\"\n+#endif\n+\n+#ifndef FLT32X_EPSILON\n+# error \"FLT32X_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT32X_MIN\n+# error \"FLT32X_MIN undefined\"\n+#endif\n+\n+#ifndef FLT32X_TRUE_MIN\n+# error \"FLT32X_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT32X_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT32X_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT32X_MANT_DIG < 32 || FLT32X_MAX_EXP < 1024 || FLT32X_MIN_EXP + FLT32X_MAX_EXP != 3\n+# error \"_Float32x bad format\"\n+#endif"}, {"sha": "9f9a3bf8682df8e4a41842f867f13940045bd45d", "filename": "gcc/testsuite/gcc.dg/torture/float32x-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float32x type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"floatn-tg.h\""}, {"sha": "decb05f34b26ffbe722df23c5b4b25e79afe8b13", "filename": "gcc/testsuite/gcc.dg/torture/float64-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-basic.h\""}, {"sha": "6a832c2a057459b0a8973ca0e5e97118c0046930", "filename": "gcc/testsuite/gcc.dg/torture/float64-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64 complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-complex.h\""}, {"sha": "a03d2e7dab78fb7666eda28d5bf777b014e19334", "filename": "gcc/testsuite/gcc.dg/torture/float64-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float64 <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT64_MANT_DIG\n+# error \"FLT64_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64_DECIMAL_DIG\n+# error \"FLT64_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64_DIG\n+# error \"FLT64_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64_MIN_EXP\n+# error \"FLT64_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64_MIN_10_EXP\n+# error \"FLT64_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64_MAX_EXP\n+# error \"FLT64_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64_MAX_10_EXP\n+# error \"FLT64_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64_MAX\n+# error \"FLT64_MAX undefined\"\n+#endif\n+\n+#ifndef FLT64_EPSILON\n+# error \"FLT64_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT64_MIN\n+# error \"FLT64_MIN undefined\"\n+#endif\n+\n+#ifndef FLT64_TRUE_MIN\n+# error \"FLT64_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT64_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT64_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT64_MANT_DIG != 53 || FLT64_MAX_EXP != 1024 || FLT64_MIN_EXP != -1021\n+# error \"_Float64 bad format\"\n+#endif"}, {"sha": "c970d53b5ec09fa74e8d0abe08e6bb0196f54217", "filename": "gcc/testsuite/gcc.dg/torture/float64-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64 type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"floatn-tg.h\""}, {"sha": "7a140af0bd78a3d88a1d291084a5ecb2c0e02a65", "filename": "gcc/testsuite/gcc.dg/torture/float64x-basic.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-basic.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-basic.h\""}, {"sha": "cb573befebb860b67e3ffb58ab1f8c69bf6dba41", "filename": "gcc/testsuite/gcc.dg/torture/float64x-complex.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-complex.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64x complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-complex.h\""}, {"sha": "11eddc7036b92f0ab052af6cfc903d029f1b6f97", "filename": "gcc/testsuite/gcc.dg/torture/float64x-floath.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-floath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-floath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-floath.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,61 @@\n+/* Test _Float64x <float.h> macros.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-floath.h\"\n+\n+#ifndef FLT64X_MANT_DIG\n+# error \"FLT64X_MANT_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64X_DECIMAL_DIG\n+# error \"FLT64X_DECIMAL_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64X_DIG\n+# error \"FLT64X_DIG undefined\"\n+#endif\n+\n+#ifndef FLT64X_MIN_EXP\n+# error \"FLT64X_MIN_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64X_MIN_10_EXP\n+# error \"FLT64X_MIN_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64X_MAX_EXP\n+# error \"FLT64X_MAX_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64X_MAX_10_EXP\n+# error \"FLT64X_MAX_10_EXP undefined\"\n+#endif\n+\n+#ifndef FLT64X_MAX\n+# error \"FLT64X_MAX undefined\"\n+#endif\n+\n+#ifndef FLT64X_EPSILON\n+# error \"FLT64X_EPSILON undefined\"\n+#endif\n+\n+#ifndef FLT64X_MIN\n+# error \"FLT64X_MIN undefined\"\n+#endif\n+\n+#ifndef FLT64X_TRUE_MIN\n+# error \"FLT64X_TRUE_MIN undefined\"\n+#endif\n+\n+#if FLT64X_DECIMAL_DIG > DECIMAL_DIG\n+# error \"FLT64X_DECIMAL_DIG > DECIMAL_DIG\"\n+#endif\n+\n+#if FLT64X_MANT_DIG < 64 || FLT64X_MAX_EXP < 16384 || FLT64X_MIN_EXP + FLT64X_MAX_EXP != 3\n+# error \"_Float64x bad format\"\n+#endif"}, {"sha": "ac14675a669274303915a2a6fc8af63ac6cf65a1", "filename": "gcc/testsuite/gcc.dg/torture/float64x-tg.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-tg.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,9 @@\n+/* Test _Float64x type-generic built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"floatn-tg.h\""}, {"sha": "9131f46752c02c4d6fcc4ddf621014cbc8e74d4b", "filename": "gcc/testsuite/gcc.dg/torture/floatn-basic.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,141 @@\n+/* Basic tests for _FloatN / _FloatNx types: compile and execution\n+   tests for valid code.  Before including this file, define WIDTH as\n+   the value N; define EXT to 1 for _FloatNx and 0 for _FloatN.  */\n+\n+#include <stdarg.h>\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define CSTU(C) CONCAT4 (C, F, WIDTH, x)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define CSTU(C) CONCAT3 (C, F, WIDTH)\n+#endif\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+volatile TYPE a = CST (1.0), b = CSTU (2.5), c = -CST (2.5);\n+volatile TYPE a2 = CST (1.0), z = CST (0.0), nz = -CST (0.0);\n+\n+/* These types are not subject to default argument promotions.  */\n+\n+TYPE\n+vafn (TYPE arg1, ...)\n+{\n+  va_list ap;\n+  TYPE ret;\n+  va_start (ap, arg1);\n+  ret = arg1 + va_arg (ap, TYPE);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+TYPE\n+krfn (arg)\n+     TYPE arg;\n+{\n+  return arg + 1;\n+}\n+\n+TYPE krprofn (TYPE);\n+TYPE\n+krprofn (arg)\n+     TYPE arg;\n+{\n+  return arg * 3;\n+}\n+\n+TYPE\n+profn (TYPE arg)\n+{\n+  return arg / 4;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile TYPE r;\n+  r = -b;\n+  if (r != c)\n+    abort ();\n+  r = a + b;\n+  if (r != CST (3.5))\n+    abort ();\n+  r = a - b;\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = 2 * c;\n+  if (r != -5)\n+    abort ();\n+  r = b * c;\n+  if (r != -CST (6.25))\n+    abort ();\n+  r = b / (a + a);\n+  if (r != CST (1.25))\n+    abort ();\n+  r = c * 3;\n+  if (r != -CST (7.5))\n+    abort ();\n+  volatile int i = r;\n+  if (i != -7)\n+    abort ();\n+  r = vafn (a, c);\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = krfn (b);\n+  if (r != CST (3.5))\n+    abort ();\n+  r = krprofn (a);\n+  if (r != CST (3.0))\n+    abort ();\n+  r = profn (a);\n+  if (r != CST (0.25))\n+    abort ();\n+  if ((a < b) != 1)\n+    abort ();\n+  if ((b < a) != 0)\n+    abort ();\n+  if ((a < a2) != 0)\n+    abort ();\n+  if ((nz < z) != 0)\n+    abort ();\n+  if ((a <= b) != 1)\n+    abort ();\n+  if ((b <= a) != 0)\n+    abort ();\n+  if ((a <= a2) != 1)\n+    abort ();\n+  if ((nz <= z) != 1)\n+    abort ();\n+  if ((a > b) != 0)\n+    abort ();\n+  if ((b > a) != 1)\n+    abort ();\n+  if ((a > a2) != 0)\n+    abort ();\n+  if ((nz > z) != 0)\n+    abort ();\n+  if ((a >= b) != 0)\n+    abort ();\n+  if ((b >= a) != 1)\n+    abort ();\n+  if ((a >= a2) != 1)\n+    abort ();\n+  if ((nz >= z) != 1)\n+    abort ();\n+  i = (nz == z);\n+  if (i != 1)\n+    abort ();\n+  i = (a == b);\n+  if (i != 0)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "7e32fafdbcf42fe2f3725436659d866a06256f71", "filename": "gcc/testsuite/gcc.dg/torture/floatn-complex.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-complex.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,76 @@\n+/* Tests for _FloatN / _FloatNx types: compile and execution tests for\n+   valid code with complex arithmetic.  Before including this file,\n+   define WIDTH as the value N; define EXT to 1 for _FloatNx and 0 for\n+   _FloatN.  */\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define CSTI(C) CONCAT4 (C, if, WIDTH, x)\n+# define CSTI2(C) CONCAT4 (C, F, WIDTH, xi)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define CSTI(C) CONCAT3 (C, if, WIDTH)\n+# define CSTI2(C) CONCAT4 (C, F, WIDTH, i)\n+#endif\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+volatile TYPE a = CST (1.0);\n+volatile _Complex TYPE b = CST (2.0) + CSTI (3.0);\n+volatile _Complex TYPE c = CST (2.0) + CSTI2 (3.0);\n+volatile _Complex TYPE d = __builtin_complex (CST (2.0), CST (3.0));\n+\n+_Complex TYPE\n+fn (_Complex TYPE arg)\n+{\n+  return arg / 4;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile _Complex TYPE r;\n+  if (b != c)\n+    abort ();\n+  if (b != d)\n+    abort ();\n+  r = a + b;\n+  if (__real__ r != CST (3.0) || __imag__ r != CST (3.0))\n+    abort ();\n+  r += d;\n+  if (__real__ r != CST (5.0) || __imag__ r != CST (6.0))\n+    abort ();\n+  r -= a;\n+  if (__real__ r != CST (4.0) || __imag__ r != CST (6.0))\n+    abort ();\n+  r /= (a + a);\n+  if (__real__ r != CST (2.0) || __imag__ r != CST (3.0))\n+    abort ();\n+  r *= (a + a);\n+  if (__real__ r != CST (4.0) || __imag__ r != CST (6.0))\n+    abort ();\n+  r -= b;\n+  if (__real__ r != CST (2.0) || __imag__ r != CST (3.0))\n+    abort ();\n+  r *= r;\n+  if (__real__ r != -CST (5.0) || __imag__ r != CST (12.0))\n+    abort ();\n+  /* Division may not be exact, so round result before comparing.  */\n+  r /= b;\n+  r += __builtin_complex (CST (100.0), CST (100.0));\n+  r -= __builtin_complex (CST (100.0), CST (100.0));\n+  if (r != b)\n+    abort ();\n+  r = fn (r);\n+  if (__real__ r != CST (0.5) || __imag__ r != CST (0.75))\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "741ffc8800fff02b29f57fe6e9db329165636192", "filename": "gcc/testsuite/gcc.dg/torture/floatn-convert.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-convert.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,104 @@\n+/* Tests for _FloatN / _FloatNx types: test conversions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options float64 } */\n+/* { dg-add-options float128 } */\n+/* { dg-add-options float32x } */\n+/* { dg-add-options float64x } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float32 } */\n+/* { dg-require-effective-target floatn_nx_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+\n+#ifndef FLT16_MAX\n+# define _Float16 _Float32\n+# define FLT16_MAX FLT32_MAX\n+# define FLT16_MANT_DIG FLT32_MANT_DIG\n+# define FLT16_EPSILON FLT32_EPSILON\n+#endif\n+\n+#ifndef FLT64_MAX\n+# define _Float64 _Float32\n+# define FLT64_MAX FLT32_MAX\n+# define FLT64_MANT_DIG FLT32_MANT_DIG\n+# define FLT64_EPSILON FLT32_EPSILON\n+#endif\n+\n+#ifndef FLT128_MAX\n+# define _Float128 _Float32\n+# define FLT128_MAX FLT32_MAX\n+# define FLT128_MANT_DIG FLT32_MANT_DIG\n+# define FLT128_EPSILON FLT32_EPSILON\n+#endif\n+\n+#ifndef FLT32X_MAX\n+# define _Float32x _Float32\n+# define FLT32X_MAX FLT32_MAX\n+# define FLT32X_MANT_DIG FLT32_MANT_DIG\n+# define FLT32X_EPSILON FLT32_EPSILON\n+#endif\n+\n+#ifndef FLT64X_MAX\n+# define _Float64x _Float32\n+# define FLT64X_MAX FLT32_MAX\n+# define FLT64X_MANT_DIG FLT32_MANT_DIG\n+# define FLT64X_EPSILON FLT32_EPSILON\n+#endif\n+\n+#ifndef FLT128X_MAX\n+# define _Float128x _Float32\n+# define FLT128X_MAX FLT32_MAX\n+# define FLT128X_MANT_DIG FLT32_MANT_DIG\n+# define FLT128X_EPSILON FLT32_EPSILON\n+#endif\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+#define DO_TEST(TYPE1, PFX1, TYPE2, PFX2)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      volatile TYPE1 a = (TYPE1) 1 + CONCAT (PFX1, _EPSILON);\t\\\n+      volatile TYPE2 b = (TYPE2) a;\t\t\t\t\\\n+      volatile TYPE2 expected;\t\t\t\t\t\\\n+      if (CONCAT (PFX2, _MANT_DIG) < CONCAT (PFX1, _MANT_DIG))\t\\\n+\texpected = (TYPE2) 1;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\texpected = (TYPE2) 1 + (TYPE2) CONCAT (PFX1, _EPSILON); \\\n+      if (b != expected)\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define DO_TEST1(TYPE1, PFX1)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float16, FLT16);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float32, FLT32);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float64, FLT64);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float128, FLT128);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float32x, FLT32X);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float64x, FLT64X);\t\t\\\n+      DO_TEST (TYPE1, PFX1, _Float128x, FLT128X);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+int\n+main (void)\n+{\n+  DO_TEST1 (_Float16, FLT16);\n+  DO_TEST1 (_Float32, FLT32);\n+  DO_TEST1 (_Float64, FLT64);\n+  DO_TEST1 (_Float128, FLT128);\n+  DO_TEST1 (_Float32x, FLT32X);\n+  DO_TEST1 (_Float64x, FLT64X);\n+  DO_TEST1 (_Float128x, FLT128X);\n+  exit (0);\n+}"}, {"sha": "a09b59e7551d755aed7e4e14cb915fe62e45241e", "filename": "gcc/testsuite/gcc.dg/torture/floatn-floath.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-floath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-floath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-floath.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,52 @@\n+/* Tests for _FloatN / _FloatNx types: compile and execution tests for\n+   <float.h>.  Before including this file, define WIDTH as the value\n+   N; define EXT to 1 for _FloatNx and 0 for _FloatN.  */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define FMAC(M) CONCAT4 (FLT, WIDTH, X_, M)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define FMAC(M) CONCAT4 (FLT, WIDTH, _, M)\n+#endif\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  volatile TYPE a = CST (1.0);\n+  for (int i = 0; i >= FMAC (MIN_EXP); i--)\n+    a *= CST (0.5);\n+  if (a != FMAC (MIN))\n+    abort ();\n+  for (int i = 0; i < FMAC (MANT_DIG) - 1; i++)\n+    a *= CST (0.5);\n+  if (a != FMAC (TRUE_MIN))\n+    abort ();\n+  a *= CST (0.5);\n+  if (a != CST (0.0))\n+    abort ();\n+  a = FMAC (EPSILON);\n+  for (int i = 0; i < FMAC (MANT_DIG) - 1; i++)\n+    a *= CST (2.0);\n+  if (a != CST (1.0))\n+    abort ();\n+  a = FMAC (MAX);\n+  for (int i = 0; i < FMAC (MAX_EXP); i++)\n+    a *= CST (0.5);\n+  if (a != CST (1.0) - FMAC (EPSILON) * CST (0.5))\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "822229764aec4ff73ad1e54a2e1cfc59a90e9aed", "filename": "gcc/testsuite/gcc.dg/torture/floatn-tg.h", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-tg.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,113 @@\n+/* Tests for _FloatN / _FloatNx types: compile and execution tests for\n+   type-generic built-in functions.  Before including this file,\n+   define WIDTH as the value N; define EXT to 1 for _FloatNx and 0 for\n+   _FloatN.  */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define TRUE_MIN CONCAT3 (FLT, WIDTH, X_TRUE_MIN)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define TRUE_MIN CONCAT3 (FLT, WIDTH, _TRUE_MIN)\n+#endif\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+volatile TYPE inf = __builtin_inf (), nanval = __builtin_nan (\"\");\n+volatile TYPE zero = CST (0.0), negzero = -CST (0.0), one = CST (1.0);\n+volatile TYPE true_min = TRUE_MIN;\n+\n+int\n+main (void)\n+{\n+  if (__builtin_signbit (inf) != 0)\n+    abort ();\n+  if (__builtin_signbit (zero) != 0)\n+    abort ();\n+  if (__builtin_signbit (negzero) == 0)\n+    abort ();\n+  if (__builtin_isfinite (nanval) != 0)\n+    abort ();\n+  if (__builtin_isfinite (inf) != 0)\n+    abort ();\n+  if (__builtin_isfinite (one) == 0)\n+    abort ();\n+  if (__builtin_isinf (nanval) != 0)\n+    abort ();\n+  if (__builtin_isinf (inf) == 0)\n+    abort ();\n+  if (__builtin_isnan (nanval) == 0)\n+    abort ();\n+  if (__builtin_isnan (inf) != 0)\n+    abort ();\n+  if (__builtin_isnormal (inf) != 0)\n+    abort ();\n+  if (__builtin_isnormal (one) == 0)\n+    abort ();\n+  if (__builtin_isnormal (nanval) != 0)\n+    abort ();\n+  if (__builtin_isnormal (zero) != 0)\n+    abort ();\n+  if (__builtin_isnormal (true_min) != 0)\n+    abort ();\n+  if (__builtin_islessequal (zero, one) != 1)\n+    abort ();\n+  if (__builtin_islessequal (one, zero) != 0)\n+    abort ();\n+  if (__builtin_islessequal (zero, negzero) != 1)\n+    abort ();\n+  if (__builtin_islessequal (zero, nanval) != 0)\n+    abort ();\n+  if (__builtin_isless (zero, one) != 1)\n+    abort ();\n+  if (__builtin_isless (one, zero) != 0)\n+    abort ();\n+  if (__builtin_isless (zero, negzero) != 0)\n+    abort ();\n+  if (__builtin_isless (zero, nanval) != 0)\n+    abort ();\n+  if (__builtin_isgreaterequal (zero, one) != 0)\n+    abort ();\n+  if (__builtin_isgreaterequal (one, zero) != 1)\n+    abort ();\n+  if (__builtin_isgreaterequal (zero, negzero) != 1)\n+    abort ();\n+  if (__builtin_isgreaterequal (zero, nanval) != 0)\n+    abort ();\n+  if (__builtin_isgreater (zero, one) != 0)\n+    abort ();\n+  if (__builtin_isgreater (one, zero) != 1)\n+    abort ();\n+  if (__builtin_isgreater (zero, negzero) != 0)\n+    abort ();\n+  if (__builtin_isgreater (zero, nanval) != 0)\n+    abort ();\n+  if (__builtin_islessgreater (zero, one) != 1)\n+    abort ();\n+  if (__builtin_islessgreater (one, zero) != 1)\n+    abort ();\n+  if (__builtin_islessgreater (zero, negzero) != 0)\n+    abort ();\n+  if (__builtin_islessgreater (zero, nanval) != 0)\n+    abort ();\n+  if (__builtin_isunordered (zero, one) != 0)\n+    abort ();\n+  if (__builtin_isunordered (one, zero) != 0)\n+    abort ();\n+  if (__builtin_isunordered (zero, negzero) != 0)\n+    abort ();\n+  if (__builtin_isunordered (zero, nanval) != 1)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "f2446d7fd5a5eac0c3f984893214fa6a4cd3bb8a", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-double.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-double.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9,10 +9,10 @@\n int\n main (void)\n {\n-  TEST_I_F(signed char, unsigned char, double, DBL_MANT_DIG);\n-  TEST_I_F(signed short, unsigned short, double, DBL_MANT_DIG);\n-  TEST_I_F(signed int, unsigned int, double, DBL_MANT_DIG);\n-  TEST_I_F(signed long, unsigned long, double, DBL_MANT_DIG);\n-  TEST_I_F(signed long long, unsigned long long, double, DBL_MANT_DIG);\n+  TEST_I_F(signed char, unsigned char, double, DBL_MANT_DIG, DBL_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, double, DBL_MANT_DIG, DBL_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, double, DBL_MANT_DIG, DBL_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, double, DBL_MANT_DIG, DBL_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, double, DBL_MANT_DIG, DBL_MAX_EXP);\n   exit (0);\n }"}, {"sha": "f0f371bcbc1a7664cee3001ccdbeff25bbada90c", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9,10 +9,10 @@\n int\n main (void)\n {\n-  TEST_I_F(signed char, unsigned char, float, FLT_MANT_DIG);\n-  TEST_I_F(signed short, unsigned short, float, FLT_MANT_DIG);\n-  TEST_I_F(signed int, unsigned int, float, FLT_MANT_DIG);\n-  TEST_I_F(signed long, unsigned long, float, FLT_MANT_DIG);\n-  TEST_I_F(signed long long, unsigned long long, float, FLT_MANT_DIG);\n+  TEST_I_F(signed char, unsigned char, float, FLT_MANT_DIG, FLT_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, float, FLT_MANT_DIG, FLT_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, float, FLT_MANT_DIG, FLT_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, float, FLT_MANT_DIG, FLT_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, float, FLT_MANT_DIG, FLT_MAX_EXP);\n   exit (0);\n }"}, {"sha": "59a7a8c07caa34268c6be67b7ca09cac28f396bb", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-ieee-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float128 type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "e1aeab0581aad81e7dd6341cded2489fd61407fa", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-ieee.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-ieee.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float128.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-require-effective-target float128_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float128, FLT128_MANT_DIG, FLT128_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "ddeef869581b416700324460c8a606ded46f732a", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128-timode.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9,10 +9,11 @@\n #include \"fp-int-convert.h\"\n \n #define FLOAT128_MANT_DIG 113\n+#define FLOAT128_MAX_EXP 16384\n \n int\n main (void)\n {\n-  TEST_I_F(TItype, UTItype, __float128, FLOAT128_MANT_DIG);\n+  TEST_I_F(TItype, UTItype, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n   exit (0);\n }"}, {"sha": "4adff79078dbdd4725dee87d7a04b403720b2006", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -6,14 +6,15 @@\n #include \"fp-int-convert.h\"\n \n #define FLOAT128_MANT_DIG 113\n+#define FLOAT128_MAX_EXP 16384\n \n int\n main (void)\n {\n-  TEST_I_F(signed char, unsigned char, __float128, FLOAT128_MANT_DIG);\n-  TEST_I_F(signed short, unsigned short, __float128, FLOAT128_MANT_DIG);\n-  TEST_I_F(signed int, unsigned int, __float128, FLOAT128_MANT_DIG);\n-  TEST_I_F(signed long, unsigned long, __float128, FLOAT128_MANT_DIG);\n-  TEST_I_F(signed long long, unsigned long long, __float128, FLOAT128_MANT_DIG);\n+  TEST_I_F(signed char, unsigned char, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);\n   exit (0);\n }"}, {"sha": "682dcdc82f26d9701abad9a54c751a71481319fc", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128x-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float128x type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float128, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "a09ed5d545eb064c670bbbf4319e508cd4d222d7", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float128x.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float128x.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float128x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-require-effective-target float128x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float128x, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float128x, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float128x, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float128x, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float128x, FLT128X_MANT_DIG, FLT128X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "f64f1d2ed6b337874ff3824be4017cd19396c31a", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float16-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float16 type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "92e976f6ac1eb6bb29dbecf25d5c123d2e81ce41", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float16.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float16.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-require-effective-target float16_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float16, FLT16_MANT_DIG, FLT16_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "c248497d7dc90ae2b920095ba51eb27cff7ff655", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float32-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float32 type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "09847d82a3a8b96f2e55c28720b3d31744aa33f5", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float32.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-require-effective-target float32_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "f08bd0073b0d51a81e5c078256ebc2b3d68e4667", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float32x-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float32x type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float32, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "8ea2eafe2f3af7d1f2a300ac6587b7e7014e5490", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float32x.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float32x.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float32x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-require-effective-target float32x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float32x, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float32x, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float32x, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float32x, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float32x, FLT32X_MANT_DIG, FLT32X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "ecefa8120b8acaa2b39ea60335836ea47249e25d", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float64-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float64 type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "196d611493fd635b4f7885026dbe1690888d81d4", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float64.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float64.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-require-effective-target float64_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float64, FLT64_MANT_DIG, FLT64_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "7b06a80422697d37d6c77d7cb6f1ab297c757566", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float64x-timode.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,16 @@\n+/* Test floating-point conversions.  _Float64x type with TImode.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(TItype, UTItype, _Float64, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "e103a5e6d0d3b7d6a8c05c26f9a5aa1c7dd5fedd", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float64x.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float64x.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -0,0 +1,20 @@\n+/* Test floating-point conversions.  Standard types and _Float64x.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-require-effective-target float64x_runtime } */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+#include <float.h>\n+#include \"fp-int-convert.h\"\n+\n+int\n+main (void)\n+{\n+  TEST_I_F(signed char, unsigned char, _Float64x, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, _Float64x, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, _Float64x, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, _Float64x, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, _Float64x, FLT64X_MANT_DIG, FLT64X_MAX_EXP);\n+  exit (0);\n+}"}, {"sha": "9c94438b56e1d11eb136f297105197aff4da4bbe", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float80-timode.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -7,10 +7,11 @@\n #include \"fp-int-convert.h\"\n \n #define FLOAT80_MANT_DIG 64\n+#define FLOAT80_MAX_EXP 16384\n \n int\n main (void)\n {\n-  TEST_I_F(TItype, UTItype, __float80, FLOAT80_MANT_DIG);\n+  TEST_I_F(TItype, UTItype, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n   exit (0);\n }"}, {"sha": "e545613beed094f3dd0ca5870e659511d0f04398", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-float80.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-float80.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -6,14 +6,15 @@\n #include \"fp-int-convert.h\"\n \n #define FLOAT80_MANT_DIG 64\n+#define FLOAT80_MAX_EXP 16384\n \n int\n main (void)\n {\n-  TEST_I_F(signed char, unsigned char, __float80, FLOAT80_MANT_DIG);\n-  TEST_I_F(signed short, unsigned short, __float80, FLOAT80_MANT_DIG);\n-  TEST_I_F(signed int, unsigned int, __float80, FLOAT80_MANT_DIG);\n-  TEST_I_F(signed long, unsigned long, __float80, FLOAT80_MANT_DIG);\n-  TEST_I_F(signed long long, unsigned long long, __float80, FLOAT80_MANT_DIG);\n+  TEST_I_F(signed char, unsigned char, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, __float80, FLOAT80_MANT_DIG, FLOAT80_MAX_EXP);\n   exit (0);\n }"}, {"sha": "d8e5197f1d390a4a46b807c8de6499b29d031640", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-long-double.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-long-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-long-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-long-double.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9,10 +9,10 @@\n int\n main (void)\n {\n-  TEST_I_F(signed char, unsigned char, long double, LDBL_MANT_DIG);\n-  TEST_I_F(signed short, unsigned short, long double, LDBL_MANT_DIG);\n-  TEST_I_F(signed int, unsigned int, long double, LDBL_MANT_DIG);\n-  TEST_I_F(signed long, unsigned long, long double, LDBL_MANT_DIG);\n-  TEST_I_F(signed long long, unsigned long long, long double, LDBL_MANT_DIG);\n+  TEST_I_F(signed char, unsigned char, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n+  TEST_I_F(signed short, unsigned short, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n+  TEST_I_F(signed int, unsigned int, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n+  TEST_I_F(signed long, unsigned long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n+  TEST_I_F(signed long long, unsigned long long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n   exit (0);\n }"}, {"sha": "0ef3e5454656441eb3275a520ce9ca84ba8248a3", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert-timode.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert-timode.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -9,13 +9,13 @@\n int\n main (void)\n {\n-  TEST_I_F(TItype, UTItype, float, FLT_MANT_DIG);\n-  TEST_I_F(TItype, UTItype, double, DBL_MANT_DIG);\n+  TEST_I_F(TItype, UTItype, float, FLT_MANT_DIG, FLT_MAX_EXP);\n+  TEST_I_F(TItype, UTItype, double, DBL_MANT_DIG, DBL_MAX_EXP);\n   /* Disable the long double tests when using IBM Extended Doubles.\n      They have variable precision, but constants calculated by gcc's\n      real.c assume fixed precision.  */\n #if DBL_MANT_DIG != LDBL_MANT_DIG  && LDBL_MANT_DIG != 106\n-  TEST_I_F(TItype, UTItype, long double, LDBL_MANT_DIG);\n+  TEST_I_F(TItype, UTItype, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);\n #endif\n   exit (0);\n }"}, {"sha": "59773e34fa851791b1fc84e4cb444b5684450a14", "filename": "gcc/testsuite/gcc.dg/torture/fp-int-convert.h", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffp-int-convert.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -15,20 +15,21 @@ typedef long TItype;\n typedef unsigned long UTItype;\n #endif\n \n-/* TEST_I_F(I, U, F, P) tests conversions between the pair of signed\n-   and unsigned integer types I and U and the floating-point type F,\n-   where P is the binary precision of the floating point type.  We\n-   test conversions of the values 0, 1, 0x7...f, 0x8...0, 0xf...f.  We\n-   also test conversions of values half way between two\n-   representable values (rounding both ways), just above half way, and\n-   just below half way.  */\n-#define TEST_I_F(I, U, F, P)\t\t\t\t\t\\\n+/* TEST_I_F(I, U, F, P, M) tests conversions between the pair of\n+   signed and unsigned integer types I and U and the floating-point\n+   type F, where P is the binary precision of the floating point type\n+   and M is the MAX_EXP value for that type (so 2^M overflows, 2^(M-1)\n+   does not).  We test conversions of the values 0, 1, 0x7...f,\n+   0x8...0, 0xf...f.  We also test conversions of values half way\n+   between two representable values (rounding both ways), just above\n+   half way, and just below half way.  */\n+#define TEST_I_F(I, U, F, P, M)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   TEST_I_F_VAL (I, F, (I)0, 1);\t\t\t\t\t\\\n   TEST_I_F_VAL (I, F, (I)1, 1);\t\t\t\t\t\\\n   TEST_I_F_VAL (I, F, (I)(((U)~(U)0) >> 1), P_OK1 (P, I));\t\\\n-  TEST_I_F_VAL (I, F, (I)(U)~(((U)~(U)0) >> 1), 1);\t\t\\\n-  TEST_I_F_VAL (I, F, (I)(U)~(U)0, P_OK (P, I));\t\t\\\n+  TEST_I_F_VAL (I, F, (I)(U)~(((U)~(U)0) >> 1), M_OK1 (M, I));\t\\\n+  TEST_I_F_VAL (I, F, (I)(U)~(U)0, 1);\t\t\t\t\\\n   TEST_I_F_VAL (I, F, HVAL0S (P, I), P_OK (P, I));\t\t\\\n   TEST_I_F_VAL (I, F, HVAL0S (P, I) + 1, P_OK (P, I));\t\t\\\n   TEST_I_F_VAL (I, F, HVAL0S (P, I) - 1, P_OK (P, I));\t\t\\\n@@ -44,7 +45,7 @@ do {\t\t\t\t\t\t\t\t\\\n   TEST_I_F_VAL (U, F, (U)0, 1);\t\t\t\t\t\\\n   TEST_I_F_VAL (U, F, (U)1, 1);\t\t\t\t\t\\\n   TEST_I_F_VAL (U, F, (U)(((U)~(U)0) >> 1), P_OK1 (P, U));\t\\\n-  TEST_I_F_VAL (U, F, (U)~(((U)~(U)0) >> 1), 1);\t\t\\\n+  TEST_I_F_VAL (U, F, (U)~(((U)~(U)0) >> 1), M_OK1 (M, U));\t\\\n   TEST_I_F_VAL (U, F, (U)~(U)0, P_OK (P, U));\t\t\t\\\n   TEST_I_F_VAL (U, F, HVAL0U (P, U), P_OK (P, U));\t\t\\\n   TEST_I_F_VAL (U, F, HVAL0U (P, U) + 1, P_OK (P, U));\t\t\\\n@@ -56,6 +57,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n #define P_OK(P, T) ((P) >= sizeof(T) * CHAR_BIT)\n #define P_OK1(P, T) ((P) >= sizeof(T) * CHAR_BIT - 1)\n+#define M_OK1(M, T) ((M) > sizeof(T) * CHAR_BIT - 1)\n #define HVAL0U(P, U) (U)(P_OK (P, U)\t\t\t\t\t \\\n \t\t\t ? (U)1\t\t\t\t\t\t \\\n \t\t\t : (((U)1 << (sizeof(U) * CHAR_BIT - 1))\t \\"}, {"sha": "b264686324a24ab1d9c5fe41808284dda79d3f3a", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -2433,6 +2433,135 @@ proc check_effective_target_has_q_floating_suffix { } {\n     } \"$opts\"]\n }\n \n+# Return 1 if the target supports the _FloatN / _FloatNx type\n+# indicated in the function name, 0 otherwise.\n+\n+proc check_effective_target_float16 {} {\n+    return [check_no_compiler_messages_nocache float16 object {\n+        _Float16 x;\n+    }]\n+}\n+\n+proc check_effective_target_float32 {} {\n+    return [check_no_compiler_messages_nocache float32 object {\n+        _Float32 x;\n+    }]\n+}\n+\n+proc check_effective_target_float64 {} {\n+    return [check_no_compiler_messages_nocache float64 object {\n+        _Float64 x;\n+    }]\n+}\n+\n+proc check_effective_target_float128 {} {\n+    return [check_no_compiler_messages_nocache float128 object {\n+        _Float128 x;\n+    }]\n+}\n+\n+proc check_effective_target_float32x {} {\n+    return [check_no_compiler_messages_nocache float32x object {\n+        _Float32x x;\n+    }]\n+}\n+\n+proc check_effective_target_float64x {} {\n+    return [check_no_compiler_messages_nocache float64x object {\n+        _Float64x x;\n+    }]\n+}\n+\n+proc check_effective_target_float128x {} {\n+    return [check_no_compiler_messages_nocache float128x object {\n+        _Float128x x;\n+    }]\n+}\n+\n+# Likewise, but runtime support for any special options used as well\n+# as compile-time support is required.\n+\n+proc check_effective_target_float16_runtime {} {\n+    return [check_effective_target_float16]\n+}\n+\n+proc check_effective_target_float32_runtime {} {\n+    return [check_effective_target_float32]\n+}\n+\n+proc check_effective_target_float64_runtime {} {\n+    return [check_effective_target_float64]\n+}\n+\n+proc check_effective_target_float128_runtime {} {\n+    if { ![check_effective_target_float128] } {\n+\treturn 0\n+    }\n+    if { [istarget powerpc*-*-*] } {\n+\treturn [check_effective_target_base_quadfloat_support]\n+    }\n+    return 1\n+}\n+\n+proc check_effective_target_float32x_runtime {} {\n+    return [check_effective_target_float32x]\n+}\n+\n+proc check_effective_target_float64x_runtime {} {\n+    if { ![check_effective_target_float64x] } {\n+\treturn 0\n+    }\n+    if { [istarget powerpc*-*-*] } {\n+\treturn [check_effective_target_base_quadfloat_support]\n+    }\n+    return 1\n+}\n+\n+proc check_effective_target_float128x_runtime {} {\n+    return [check_effective_target_float128x]\n+}\n+\n+# Return 1 if the target hardware supports any options added for\n+# _FloatN and _FloatNx types, 0 otherwise.\n+\n+proc check_effective_target_floatn_nx_runtime {} {\n+    if { [istarget powerpc*-*-*] } {\n+\treturn [check_effective_target_base_quadfloat_support]\n+    }\n+    return 1\n+}\n+\n+# Add options needed to use the _FloatN / _FloatNx type indicated in\n+# the function name.\n+\n+proc add_options_for_float16 { flags } {\n+    return \"$flags\"\n+}\n+\n+proc add_options_for_float32 { flags } {\n+    return \"$flags\"\n+}\n+\n+proc add_options_for_float64 { flags } {\n+    return \"$flags\"\n+}\n+\n+proc add_options_for_float128 { flags } {\n+    return [add_options_for___float128 \"$flags\"]\n+}\n+\n+proc add_options_for_float32x { flags } {\n+    return \"$flags\"\n+}\n+\n+proc add_options_for_float64x { flags } {\n+    return [add_options_for___float128 \"$flags\"]\n+}\n+\n+proc add_options_for_float128x { flags } {\n+    return \"$flags\"\n+}\n+\n # Return 1 if the target supports __float128,\n # 0 otherwise.\n "}, {"sha": "8b3e5cc75a4e2cb80c0078558f8ddaa94bd1dc96", "filename": "gcc/tree-core.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -558,10 +558,44 @@ enum tree_index {\n   TI_COMPLEX_DOUBLE_TYPE,\n   TI_COMPLEX_LONG_DOUBLE_TYPE,\n \n+  TI_COMPLEX_FLOAT16_TYPE,\n+  TI_COMPLEX_FLOATN_NX_TYPE_FIRST = TI_COMPLEX_FLOAT16_TYPE,\n+  TI_COMPLEX_FLOAT32_TYPE,\n+  TI_COMPLEX_FLOAT64_TYPE,\n+  TI_COMPLEX_FLOAT128_TYPE,\n+  TI_COMPLEX_FLOAT32X_TYPE,\n+  TI_COMPLEX_FLOAT64X_TYPE,\n+  TI_COMPLEX_FLOAT128X_TYPE,\n+\n   TI_FLOAT_TYPE,\n   TI_DOUBLE_TYPE,\n   TI_LONG_DOUBLE_TYPE,\n \n+  /* The _FloatN and _FloatNx types must be consecutive, and in the\n+     same sequence as the corresponding complex types, which must also\n+     be consecutive; _FloatN must come before _FloatNx; the order must\n+     also be the same as in the floatn_nx_types array and the RID_*\n+     values in c-common.h.  This is so that iterations over these\n+     types work as intended.  */\n+  TI_FLOAT16_TYPE,\n+  TI_FLOATN_TYPE_FIRST = TI_FLOAT16_TYPE,\n+  TI_FLOATN_NX_TYPE_FIRST = TI_FLOAT16_TYPE,\n+  TI_FLOAT32_TYPE,\n+  TI_FLOAT64_TYPE,\n+  TI_FLOAT128_TYPE,\n+  TI_FLOATN_TYPE_LAST = TI_FLOAT128_TYPE,\n+#define NUM_FLOATN_TYPES (TI_FLOATN_TYPE_LAST - TI_FLOATN_TYPE_FIRST + 1)\n+  TI_FLOAT32X_TYPE,\n+  TI_FLOATNX_TYPE_FIRST = TI_FLOAT32X_TYPE,\n+  TI_FLOAT64X_TYPE,\n+  TI_FLOAT128X_TYPE,\n+  TI_FLOATNX_TYPE_LAST = TI_FLOAT128X_TYPE,\n+  TI_FLOATN_NX_TYPE_LAST = TI_FLOAT128X_TYPE,\n+#define NUM_FLOATNX_TYPES (TI_FLOATNX_TYPE_LAST - TI_FLOATNX_TYPE_FIRST + 1)\n+#define NUM_FLOATN_NX_TYPES (TI_FLOATN_NX_TYPE_LAST\t\t\\\n+\t\t\t     - TI_FLOATN_NX_TYPE_FIRST\t\t\\\n+\t\t\t     + 1)\n+\n   TI_FLOAT_PTR_TYPE,\n   TI_DOUBLE_PTR_TYPE,\n   TI_LONG_DOUBLE_PTR_TYPE,\n@@ -1959,6 +1993,16 @@ struct GTY(()) builtin_info_type {\n   unsigned declared_p : 1;\n };\n \n+/* Information about a _FloatN or _FloatNx type that may be\n+   supported.  */\n+struct floatn_type_info {\n+  /* The number N in the type name.  */\n+  int n;\n+  /* Whether it is an extended type _FloatNx (true) or an interchange\n+     type (false).  */\n+  bool extended;\n+};\n+\n \n /*---------------------------------------------------------------------------\n                                 Global variables\n@@ -2023,4 +2067,7 @@ extern GTY(()) tree current_function_decl;\n /* Nonzero means a FUNC_BEGIN label was emitted.  */\n extern GTY(()) const char * current_function_func_begin_label;\n \n+/* Information about the _FloatN and _FloatNx types.  */\n+extern const floatn_type_info floatn_nx_types[NUM_FLOATN_NX_TYPES];\n+\n #endif  // GCC_TREE_CORE_H"}, {"sha": "33e6f979b55c3e091a99cf1b66d32dee3572c404", "filename": "gcc/tree.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -10140,6 +10140,20 @@ build_atomic_base (tree type, unsigned int align)\n   return t;\n }\n \n+/* Information about the _FloatN and _FloatNx types.  This must be in\n+   the same order as the corresponding TI_* enum values.  */\n+const floatn_type_info floatn_nx_types[NUM_FLOATN_NX_TYPES] =\n+  {\n+    { 16, false },\n+    { 32, false },\n+    { 64, false },\n+    { 128, false },\n+    { 32, true },\n+    { 64, true },\n+    { 128, true },\n+  };\n+\n+\n /* Create nodes for all integer types (and error_mark_node) using the sizes\n    of C datatypes.  SIGNED_CHAR specifies whether char is signed.  */\n \n@@ -10312,6 +10326,29 @@ build_common_tree_nodes (bool signed_char)\n   TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n   layout_type (long_double_type_node);\n \n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n+      int n = floatn_nx_types[i].n;\n+      bool extended = floatn_nx_types[i].extended;\n+      machine_mode mode = targetm.floatn_mode (n, extended);\n+      if (mode == VOIDmode)\n+\tcontinue;\n+      int precision = GET_MODE_PRECISION (mode);\n+      /* Work around the rs6000 KFmode having precision 113 not\n+\t 128.  */\n+      const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n+      gcc_assert (fmt->b == 2 && fmt->emin + fmt->emax == 3);\n+      int min_precision = fmt->p + ceil_log2 (fmt->emax - fmt->emin);\n+      if (!extended)\n+\tgcc_assert (min_precision == n);\n+      if (precision < min_precision)\n+\tprecision = min_precision;\n+      FLOATN_NX_TYPE_NODE (i) = make_node (REAL_TYPE);\n+      TYPE_PRECISION (FLOATN_NX_TYPE_NODE (i)) = precision;\n+      layout_type (FLOATN_NX_TYPE_NODE (i));\n+      SET_TYPE_MODE (FLOATN_NX_TYPE_NODE (i), mode);\n+    }\n+\n   float_ptr_type_node = build_pointer_type (float_type_node);\n   double_ptr_type_node = build_pointer_type (double_type_node);\n   long_double_ptr_type_node = build_pointer_type (long_double_type_node);\n@@ -10346,6 +10383,13 @@ build_common_tree_nodes (bool signed_char)\n   complex_double_type_node = build_complex_type (double_type_node);\n   complex_long_double_type_node = build_complex_type (long_double_type_node);\n \n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n+      if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE)\n+\tCOMPLEX_FLOATN_NX_TYPE_NODE (i)\n+\t  = build_complex_type (FLOATN_NX_TYPE_NODE (i));\n+    }\n+\n /* Make fixed-point nodes based on sat/non-sat and signed/unsigned.  */\n #define MAKE_FIXED_TYPE_NODE(KIND,SIZE) \\\n   sat_ ## KIND ## _type_node = \\"}, {"sha": "16d13f3266b982a665b2f4b7de2b96f759bd5c08", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -3605,6 +3605,17 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define double_type_node\t\tglobal_trees[TI_DOUBLE_TYPE]\n #define long_double_type_node\t\tglobal_trees[TI_LONG_DOUBLE_TYPE]\n \n+/* Nodes for particular _FloatN and _FloatNx types in sequence.  */\n+#define FLOATN_TYPE_NODE(IDX)\t\tglobal_trees[TI_FLOATN_TYPE_FIRST + (IDX)]\n+#define FLOATN_NX_TYPE_NODE(IDX)\tglobal_trees[TI_FLOATN_NX_TYPE_FIRST + (IDX)]\n+#define FLOATNX_TYPE_NODE(IDX)\t\tglobal_trees[TI_FLOATNX_TYPE_FIRST + (IDX)]\n+\n+/* Names for individual types, where required by back ends\n+   (architecture-independent code should always iterate over all such\n+   types).  */\n+#define float128_type_node\t\tglobal_trees[TI_FLOAT128_TYPE]\n+#define float64x_type_node\t\tglobal_trees[TI_FLOAT64X_TYPE]\n+\n #define float_ptr_type_node\t\tglobal_trees[TI_FLOAT_PTR_TYPE]\n #define double_ptr_type_node\t\tglobal_trees[TI_DOUBLE_PTR_TYPE]\n #define long_double_ptr_type_node\tglobal_trees[TI_LONG_DOUBLE_PTR_TYPE]\n@@ -3615,6 +3626,8 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define complex_double_type_node\tglobal_trees[TI_COMPLEX_DOUBLE_TYPE]\n #define complex_long_double_type_node\tglobal_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]\n \n+#define COMPLEX_FLOATN_NX_TYPE_NODE(IDX)\tglobal_trees[TI_COMPLEX_FLOATN_NX_TYPE_FIRST + (IDX)]\n+\n #define pointer_bounds_type_node        global_trees[TI_POINTER_BOUNDS_TYPE]\n \n #define void_type_node\t\t\tglobal_trees[TI_VOID_TYPE]"}, {"sha": "f680f8bc89913bc662e7d5546d5d8d3864ac5fd6", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -1,3 +1,12 @@\n+2016-08-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/32187\n+\t* include/cpplib.h (CPP_N_FLOATN, CPP_N_FLOATNX)\n+\t(CPP_N_WIDTH_FLOATN_NX, CPP_FLOATN_SHIFT, CPP_FLOATN_MAX): New\n+\tmacros.\n+\t* expr.c (interpret_float_suffix): Handle fN, fNx, FN and FNx\n+\tsuffixes.\n+\n 2016-08-19  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \t* expr.c (eval_token): Append \"evaluates to 0\" to Wundef diagnostic."}, {"sha": "61bc1b21af1837e0e1e98b0b9b3a079887f4dd0a", "filename": "libcpp/expr.c", "status": "modified", "additions": 101, "deletions": 17, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -86,15 +86,52 @@ static cpp_num parse_has_include (cpp_reader *, enum include_type);\n \n /* Subroutine of cpp_classify_number.  S points to a float suffix of\n    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a\n-   flag vector describing the suffix.  */\n+   flag vector (of CPP_N_* bits) describing the suffix.  */\n static unsigned int\n interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n {\n   size_t flags;\n-  size_t f, d, l, w, q, i;\n+  size_t f, d, l, w, q, i, fn, fnx, fn_bits;\n \n   flags = 0;\n-  f = d = l = w = q = i = 0;\n+  f = d = l = w = q = i = fn = fnx = fn_bits = 0;\n+\n+  /* The following decimal float suffixes, from TR 24732:2009 and TS\n+     18661-2:2015, are supported:\n+\n+     df, DF - _Decimal32.\n+     dd, DD - _Decimal64.\n+     dl, DL - _Decimal128.\n+\n+     The dN and DN suffixes for _DecimalN, and dNx and DNx for\n+     _DecimalNx, defined in TS 18661-3:2015, are not supported.\n+\n+     Fixed-point suffixes, from TR 18037:2008, are supported.  They\n+     consist of three parts, in order:\n+\n+     (i) An optional u or U, for unsigned types.\n+\n+     (ii) An optional h or H, for short types, or l or L, for long\n+     types, or ll or LL, for long long types.  Use of ll or LL is a\n+     GNU extension.\n+\n+     (iii) r or R, for _Fract types, or k or K, for _Accum types.\n+\n+     Otherwise the suffix is for a binary or standard floating-point\n+     type.  Such a suffix, or the absence of a suffix, may be preceded\n+     or followed by i, I, j or J, to indicate an imaginary number with\n+     the corresponding complex type.  The following suffixes for\n+     binary or standard floating-point types are supported:\n+\n+     f, F - float (ISO C and C++).\n+     l, L - long double (ISO C and C++).\n+     d, D - double, even with the FLOAT_CONST_DECIMAL64 pragma in\n+\t    operation (from TR 24732:2009; the pragma and the suffix\n+\t    are not included in TS 18661-2:2015).\n+     w, W - machine-specific type such as __float80 (GNU extension).\n+     q, Q - machine-specific type such as __float128 (GNU extension).\n+     fN, FN - _FloatN (TS 18661-3:2015).\n+     fNx, FNx - _FloatNx (TS 18661-3:2015).  */\n \n   /* Process decimal float suffixes, which are two letters starting\n      with d or D.  Order and case are significant.  */\n@@ -172,20 +209,64 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \n   /* In any remaining valid suffix, the case and order don't matter.  */\n   while (len--)\n-    switch (s[len])\n-      {\n-      case 'f': case 'F': f++; break;\n-      case 'd': case 'D': d++; break;\n-      case 'l': case 'L': l++; break;\n-      case 'w': case 'W': w++; break;\n-      case 'q': case 'Q': q++; break;\n-      case 'i': case 'I':\n-      case 'j': case 'J': i++; break;\n-      default:\n-\treturn 0;\n-      }\n+    {\n+      switch (s[0])\n+\t{\n+\tcase 'f': case 'F':\n+\t  f++;\n+\t  if (len > 0\n+\t      && !CPP_OPTION (pfile, cplusplus)\n+\t      && s[1] >= '1'\n+\t      && s[1] <= '9'\n+\t      && fn_bits == 0)\n+\t    {\n+\t      f--;\n+\t      while (len > 0\n+\t\t     && s[1] >= '0'\n+\t\t     && s[1] <= '9'\n+\t\t     && fn_bits < CPP_FLOATN_MAX)\n+\t\t{\n+\t\t  fn_bits = fn_bits * 10 + (s[1] - '0');\n+\t\t  len--;\n+\t\t  s++;\n+\t\t}\n+\t      if (len > 0 && s[1] == 'x')\n+\t\t{\n+\t\t  fnx++;\n+\t\t  len--;\n+\t\t  s++;\n+\t\t}\n+\t      else\n+\t\tfn++;\n+\t    }\n+\t  break;\n+\tcase 'd': case 'D': d++; break;\n+\tcase 'l': case 'L': l++; break;\n+\tcase 'w': case 'W': w++; break;\n+\tcase 'q': case 'Q': q++; break;\n+\tcase 'i': case 'I':\n+\tcase 'j': case 'J': i++; break;\n+\tdefault:\n+\t  return 0;\n+\t}\n+      s++;\n+    }\n \n-  if (f + d + l + w + q > 1 || i > 1)\n+  /* Reject any case of multiple suffixes specifying types, multiple\n+     suffixes specifying an imaginary constant, _FloatN or _FloatNx\n+     suffixes for invalid values of N, and _FloatN suffixes for values\n+     of N larger than can be represented in the return value.  The\n+     caller is responsible for rejecting _FloatN suffixes where\n+     _FloatN is not supported on the chosen target.  */\n+  if (f + d + l + w + q + fn + fnx > 1 || i > 1)\n+    return 0;\n+  if (fn_bits > CPP_FLOATN_MAX)\n+    return 0;\n+  if (fnx && fn_bits != 32 && fn_bits != 64 && fn_bits != 128)\n+    return 0;\n+  if (fn && fn_bits != 16 && fn_bits % 32 != 0)\n+    return 0;\n+  if (fn && fn_bits == 96)\n     return 0;\n \n   if (i && !CPP_OPTION (pfile, ext_numeric_literals))\n@@ -199,7 +280,10 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \t     d ? CPP_N_MEDIUM :\n \t     l ? CPP_N_LARGE :\n \t     w ? CPP_N_MD_W :\n-\t     q ? CPP_N_MD_Q : CPP_N_DEFAULT));\n+\t     q ? CPP_N_MD_Q :\n+\t     fn ? CPP_N_FLOATN | (fn_bits << CPP_FLOATN_SHIFT) :\n+\t     fnx ? CPP_N_FLOATNX | (fn_bits << CPP_FLOATN_SHIFT) :\n+\t     CPP_N_DEFAULT));\n }\n \n /* Return the classification flags for a float suffix.  */"}, {"sha": "cfc6ccd1a907c5067c02bf0517a8a00884ae3bc7", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65699efcce48d68ef57ab3ce7fc5420fac5cbf9/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=c65699efcce48d68ef57ab3ce7fc5420fac5cbf9", "patch": "@@ -956,9 +956,16 @@ struct cpp_num\n \n #define CPP_N_FRACT\t0x100000 /* Fract types.  */\n #define CPP_N_ACCUM\t0x200000 /* Accum types.  */\n+#define CPP_N_FLOATN\t0x400000 /* _FloatN types.  */\n+#define CPP_N_FLOATNX\t0x800000 /* _FloatNx types.  */\n \n #define CPP_N_USERDEF\t0x1000000 /* C++0x user-defined literal.  */\n \n+#define CPP_N_WIDTH_FLOATN_NX\t0xF0000000 /* _FloatN / _FloatNx value\n+\t\t\t\t\t      of N, divided by 16.  */\n+#define CPP_FLOATN_SHIFT\t24\n+#define CPP_FLOATN_MAX\t0xF0\n+\n /* Classify a CPP_NUMBER token.  The return value is a combination of\n    the flags from the above sets.  */\n extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *,"}]}